
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>随笔录一 - iOS梦工厂</title>
  <meta name="author" content="iCocos">

  
  <meta name="description" content="随笔录一 ordinal 散列函数 Hash，常见的有 MD5、SHA1、SHA256，该类函数特点是函数单向不可逆、对输入非常敏感、输出长度固定，针对数据的任何修改都会改变散列函数的结果，用于防止信息篡改并验证数据的完整性；对称加密，常见的有 AES-CBC、DES、3DES、AES-GCM等 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://al1020119.github.io/other/iCocos/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="iOS梦工厂" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//libs.baidu.com/jquery/1.7.2/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <script>
function addBlankTargetForLinks () {
    $('a[href^="http"]').each(function(){
                              $(this).attr('target', '_blank');
                              });
}
$(document).bind('DOMNodeInserted', function(event) {
             addBlankTargetForLinks();
             });
</script>
  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">iOS梦工厂</a></h1>
  
    <h2>不战胜自己，何以改变未来！</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="al1020119.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">首页</a></li>
  <li><a href="/blog/archives">归档</a></li>
  <li><a href="/icocos">iCocos</a></li>
  <li><a href="/other">随笔录</a></li>
  <li><a href="/about">关于</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article role="article">
  
  <header>
    <h1 class="entry-title">随笔录一</h1>
    <p class="meta">








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> </p>
  </header>
  
  <p>散列函数 Hash，常见的有 MD5、SHA1、SHA256，该类函数特点是函数单向不可逆、对输入非常敏感、输出长度固定，针对数据的任何修改都会改变散列函数的结果，用于防止信息篡改并验证数据的完整性；对称加密，常见的有 AES-CBC、DES、3DES、AES-GCM等，相同的密钥可以用于信息的加密和解密，掌握密钥才能获取信息，能够防止信息窃听，通信方式是1对1；非对称加密，即常见的 RSA 算法，还包括 ECC、DH 等算法，算法特点是，密钥成对出现，一般称为公钥(公开)和私钥(保密)，公钥加密的信息只能私钥解开，私钥加密的信息只能公钥解开。因此掌握公钥的不同客户端之间不能互相解密信息，只能和掌握私钥的服务器进行加密通信，服务器可以实现1对多的通信，客户端也可以用来验证掌握私钥的服务器身份。</p>

<hr />

<p>Objective-C：NSLog(@&ldquo;祝大家平安夜快乐&rdquo;);
Swift：print(&ldquo;祝大家平安夜快乐&rdquo;);
C：printf(&ldquo;祝大家平安夜快乐&rdquo;);
C++ : cout&lt;&lt;&ldquo;祝大家平安夜快乐&rdquo;;
QBasic : Print &ldquo;祝大家平安夜快乐&rdquo;
Asp : Response.Write &ldquo;祝大家平安夜快乐&rdquo;
PHP : echo &ldquo;祝大家平安夜快乐&rdquo;;
JScript: alert(&ldquo;祝大家平安夜快乐&rdquo;)
VBScript:MsgBox &ldquo;祝大家平安夜快乐&rdquo;
Jscript:document.write(&ldquo;祝大家平安夜快乐&rdquo;)
Delphi: ShowMessage(&lsquo;祝大家平安夜快乐！&rsquo;);
VB: Print &ldquo;祝大家平安夜快乐！&rdquo;
VC: MessageBox(&ldquo;祝大家平安夜快乐！&rdquo;);
shell: echo 祝大家平安夜快乐
perl: print &lsquo;祝大家平安夜快乐&rsquo;
java: System.out.println(&ldquo;祝大家平安夜快乐&rdquo;);
powerBuilder:messagebox（"祝大家平安夜快乐")
C#：System.Console.WriteLine(&ldquo;祝大家平安夜快乐!&rdquo;)
COBOL:DISPLAY &lsquo;祝大家平安夜快乐！
Python:print(&ldquo;祝大家平安夜快乐！&rdquo;)
AS:Alert.show(&ldquo;祝大家平安夜快乐！&rdquo;);
Foxpro: ? [祝大家平安夜快乐！]
DOS 批处理: echo 祝大家平安夜快乐
易语言:调试输出(“祝大家平安夜快乐！！！”</p>

<hr />

<p>在 VSync 信号到来后，系统图形服务会通过 CADisplayLink 等机制通知 App，App 主线程开始在 CPU 中计算显示内容，比如视图的创建、布局计算、图片解码、文本绘制等。随后 CPU 会将计算好的内容提交到 GPU 去，由 GPU 进行变换、合成、渲染。随后 GPU 会把渲染结果提交到帧缓冲区去，等待下一次 VSync 信号到来时显示到屏幕上。由于垂直同步的机制，如果在一个 VSync 时间内，CPU 或者 GPU 没有完成内容提交，则那一帧就会被丢弃，等待下一次机会再显示，而这时显示屏会保留之前的内容不变。这就是界面卡顿的原因。</p>

<hr />

<p>不能使用retain/release/retainCount/autorelease
不能使用NSAllocateObject/NSDeallocateObject
必须遵守内存管理的方法命名规则
不能显示的调用dealloc
使用@autoreleasepool块来替代NSAutoreleasePool
不能使用区域(NSZone)
对象型变量不能作为C语言结构体(struct/union)的成员
显示的转化“id”和“void*”</p>

<hr />

<p>1、如何让HTML文本onLoad的时候，禁用自身的图片加载而是从本地获取图片？2、如何把native端下载好的图片返回给网页？：WebViewJavascriptBridge</p>

<hr />

<p>H5：大段文字，格式比较丰富（原生解析json并格式差），APP用户常见页面频换，预算有限，不是很讲究用户体验，不在乎加载速度</p>

<p>原生：讲究APP反应速度（含页面切换流畅性）（H5网页依赖网速，切加载所有），对有无网络、网络优劣敏感（譬如有离线操作，在线操作），需要频繁调用硬件（摄像头、麦克风、未来的湿度检测仪等等）</p>

<p>实际上有个采阴补阳的方法是H5+原生混合开发，对于固定格式、页面速度要求高，的模块（如PDB的即时通讯、宝典、我的项目）采用原生开发，对于新闻、大段文字、资讯类的（如信息广场、发表、问吧等）用H5页面来加载，将其嵌入到原生框架中那么，可以达到比较良好的体验。</p>

<hr />

<p>1）各手机浏览器的兼容测试</p>

<p>2）底层服务的调取（能调取，但只有当其是核心功能时才保留 eg：新浪、美团等皆去掉了头像上传功能）</p>

<p>3）注意离线数据存储，减少数据请求频率。</p>

<p>4）考虑保存用户的哪些数据：设置、个人数据、阅读锚点、跳出页面等。</p>

<p>5）避免动效与浏览器的交互冲突</p>

<p>6）按顺序 异步加载  eg： 腾讯视频</p>

<hr />

<p>尽量设置Cell的view为opaque，避免GPU对Cell下面的内容也进行绘制。
避免大量的图片缩放、颜色渐变等。
避免同步的从网络、文件获取数据（这个是必须的=。=）
用shadowPath创建阴影。
尽量减少subview的数量，如多用drawRect绘制元素，替代用view显示。
尽量显示“大小刚好合适”的图片资源。</p>

<p>总的来说，就是：</p>

<p>缓存一切可以缓存的！就是“用空间替换时间”！</p>

<p>在UITableView的Delegate、DataSource方法中，减少任何不必要的操作</p>

<hr />

<p>提前计算并缓存好高度（布局），因为heightForRowAtIndexPath:是调用最频繁的方法；
异步绘制，遇到复杂界面，遇到性能瓶颈时，可能就是突破口；
滑动时按需加载，这个在大量图片展示，网络加载的时候很管用！（SDWebImage已经实现异步加载，配合这条性能杠杠的）。
除了上面最主要的三个方面外，还有很多几乎大伙都很熟知的优化点：</p>

<p>正确使用reuseIdentifier来重用Cells
尽量使所有的view opaque，包括Cell自身
尽量少用或不用透明图层
如果Cell内现实的内容来自web，使用异步加载，缓存请求结果
减少subviews的数量
在heightForRowAtIndexPath:中尽量不使用cellForRowAtIndexPath:，如果你需要用到它，只用一次然后缓存结果
尽量少用addView给Cell动态添加View，可以初始化时就添加，然后通过hide来控制是否显示</p>

<hr />

<p>1.最常用的就是cell的重用， 注册重用标识符</p>

<p>如果不重用cell时，每当一个cell显示到屏幕上时，就会重新创建一个新的cell
如果有很多数据的时候，就会堆积很多cell。如果重用cell，为cell创建一个ID
每当需要显示cell 的时候，都会先去缓冲池中寻找可循环利用的cell，如果没有再重新创建cell
设置正确的reuseIdentifer以重用cell
2.避免cell的重新布局</p>

<p>cell的布局填充等操作 比较耗时，一般创建时就布局好
如可以将cell单独放到一个自定义类，初始化时就布局好
3.提前计算并缓存cell的属性及内容</p>

<p>在cellForRowAtIndexPath:中尽量做更少的操作。如果需要做一些处理，那么最好做过一次之后，就将结果缓存起来。
当我们创建cell的数据源方法时，编译器并不是先创建cell 再定cell的高度
而是先根据内容一次确定每一个cell的高度，高度确定后，再创建要显示的cell，滚动时，每当cell进入凭虚都会计算高度，提前估算高度告诉编译器，编译器知道高度后，紧接着就会创建cell，这时再调用高度的具体计算方法，这样可以方式浪费时间去计算显示以外的cell
4.减少cell中控件的数量</p>

<p>尽量使cell得布局大致相同，不同风格的cell可以使用不用的重用标识符，初始化时添加控件，
不适用的可以先隐藏
5.不要使用ClearColor，无背景色，透明度也不要设置为0</p>

<p>渲染耗时比较长
尽量将view设置为不透明，包括cell本身。
6.使用局部更新</p>

<p>如果只是更新某组的话，使用reloadSection进行局部更新
7.加载网络数据，下载图片，使用异步加载，并缓存</p>

<p>如果cell显示的内容来此网络，那么确保这些内容是通过异步来获取的
8.少使用addView 给cell动态添加view</p>

<p>9.按需加载cell，cell滚动很快时，只加载范围内的cell</p>

<p>注意正确使用懒加载
10.不要实现无用的代理方法，tableView只遵守两个协议</p>

<p>非必要的代理或者数据源方法可以省略，比如numberofsention
11.缓存行高：</p>

<p>如果row的高度不相同，那么将其缓存下来
estimatedHeightForRow不能和HeightForRow里面的layoutIfNeed同时存在，这两者同时存在才会出现“窜动”的bug。所以我的建议是：只要是固定行高就写预估行高来减少行高调用次数提升性能。如果是动态行高就不要写预估方法了，用一个行高的缓存字典来减少代码的调用次数即可
12.避免渐变，图像缩放以及离屏绘制</p>

<p>13.使用shadowPath来设置阴影。</p>

<p>14.使用适当的数据结构来保存需要的信息。不同的结构会带来不同的操作代价。</p>

<p>15.使用rowHeight, sectionFooterHeight 和 sectionHeaderHeight 来设置一个恒定 高度，而不要从delegate中获取。</p>

<p>16.使用富文本标签代价是很昂贵的</p>

<p>费尽周折用富文本标签，代价太昂贵了。尽可能地避免使用这个。问问你自己是否真的需要这个。如果是的话，尽可能的做缓存。</p>

<hr />

<p>卡顿：重用是否成功（自己写）—是否是多次请求-青花瓷（每次滚动）—github，博客，微博&ndash;Instruments三件套(Time Profiler,Core Animation,GPU Driver)—GPU-CPU-代码逻辑-1.cell高度没有缓存。2. refreshData（reloadData）2次。 3.懒加载View 4.圆角问题  5.尺寸对应  6.
NSDateFormatter 7.UIImage缓存取舍 8.</p>

<p>手动 Drawing（Cell 中 view 的组织复杂</p>

<p> ）9. UI 线程的时间 10.缓存一切可以缓存的！就是“用空间替换时间”！</p>

<hr />

<p>iOS人机界面指南，开篇始终是遵从（Deference），清晰（Clarity），深度（Depth）</p>

<hr />

<p>动态切换皮肤的风格如下：</p>

<p>1.首先按照风格建立相应的组件类，例如，你有几种Button，就继承实现几个Button类。</p>

<p>2.设置全局风格标志。</p>

<p>3.触发风格修改的地方，通过全局广播发送消息。</p>

<p>4.UIAppDelegate重新装载window的rootViewController</p>

<hr />

<p>一、网络各个协议：TCP/IP、SOCKET、HTTP等</p>

<p>网络七层由下往上分别为物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。
其中物理层、数据链路层和网络层通常被称作媒体层，是网络工程师所研究的对象；
传输层、会话层、表示层和应用层则被称作主机层，是用户所面向和关心的内容。
 http协议   对应于应用层
 tcp协议    对应于传输层<br/>
 ip协议     对应于网络层
 三者本质上没有可比性。  何况HTTP协议是基于TCP连接的。
 TCP/IP是传输层协议，主要解决数据如何在网络中传输；而HTTP是应用层协议，主要解决如何包装数据。
 我 们在传输数据时，可以只使用传输层（TCP/IP），但是那样的话，由于没有应用层，便无法识别数据内容，如果想要使传输的数据有意义，则必须使用应用层 协议，应用层协议很多，有HTTP、FTP、TELNET等等，也可以自己定义应用层协议。WEB使用HTTP作传输层协议，以封装HTTP文本信息，然 后使用TCP/IP做传输层协议将它发送到网络上。Socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口（API），通过Socket，我们才能使用TCP/IP协议。
二、Http和Socket连接区别
 相信不少初学手机联网开发的朋友都想知道Http与Socket连接究竟有什么区别，希望通过自己的浅显理解能对初学者有所帮助。
2.1、TCP连接
要想明白Socket连接，先要明白TCP连接。手机能够使用联网功能是因为手机底层实现了TCP/IP协议，可以使手机终端通过无线网络建立TCP连接。TCP协议可以对上层网络提供接口，使上层网络数据的传输建立在“无差别”的网络之上。
建立起一个TCP连接需要经过“三次握手”：
第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；
第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；
第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。
握 手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连 接之前，TCP 连接都将被一直保持下去。断开连接时服务器和客户端均可以主动发起断开TCP连接的请求，断开过程需要经过“四次握手”（过程就不细写了，就是服务器和客 户端交互，最终确定断开）
2.2、HTTP连接
HTTP协议即超文本传送协议(HypertextTransfer Protocol )，是Web联网的基础，也是手机联网常用的协议之一，HTTP协议是建立在TCP协议之上的一种应用。
HTTP连接最显著的特点是客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接。从建立连接到关闭连接的过程称为“一次连接”。
1）在HTTP 1.0中，客户端的每次请求都要求建立一次单独的连接，在处理完本次请求后，就自动释放连接。
2）在HTTP 1.1中则可以在一次连接中处理多个请求，并且多个请求可以重叠进行，不需要等待一个请求结束后再发送下一个请求。
由 于HTTP在每次请求结束后都会主动释放连接，因此HTTP连接是一种“短连接”，要保持客户端程序的在线状态，需要不断地向服务器发起连接请求。通常的 做法是即时不需要获得任何数据，客户端也保持每隔一段固定的时间向服务器发送一次“保持连接”的请求，服务器在收到该请求后对客户端进行回复，表明知道客 户端“在线”。若服务器长时间无法收到客户端的请求，则认为客户端“下线”，若客户端长时间无法收到服务器的回复，则认为网络已经断开。
三、SOCKET原理
3.1、套接字（socket）概念
套接字（socket）是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元。它是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息：连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口。
应 用层通过传输层进行数据通信时，TCP会遇到同时为多个应用程序进程提供并发服务的问题。多个TCP连接或多个应用程序进程可能需要通过同一个 TCP协议端口传输数据。为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与TCP／IP协议交互提供了套接字(Socket)接口。应 用层可以和传输层通过Socket接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。
3.2 、建立socket连接
建立Socket连接至少需要一对套接字，其中一个运行于客户端，称为ClientSocket，另一个运行于服务器端，称为ServerSocket。
套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认。
服务器监听：服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求。
客户端请求：指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。
连 接确认：当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户 端，一旦客户端确认了此描述，双方就正式建立连接。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。
 3.3、SOCKET连接与TCP连接
创建Socket连接时，可以指定使用的传输层协议，Socket可以支持不同的传输层协议（TCP或UDP），当使用TCP协议进行连接时，该Socket连接就是一个TCP连接。
 3.4、Socket连接与HTTP连接
由 于通常情况下Socket连接就是TCP连接，因此Socket连接一旦建立，通信双方即可开始相互发送数据内容，直到双方连接断开。但在实际网络应用 中，客户端到服务器之间的通信往往需要穿越多个中间节点，例如路由器、网关、防火墙等，大部分防火墙默认会关闭长时间处于非活跃状态的连接而导致 Socket 连接断连，因此需要通过轮询告诉网络，该连接处于活跃状态。
而HTTP连接使用的是“请求—响应”的方式，不仅在请求时需要先建立连接，而且需要客户端向服务器发出请求后，服务器端才能回复数据。
很 多情况下，需要服务器端主动向客户端推送数据，保持客户端与服务器数据的实时与同步。此时若双方建立的是Socket连接，服务器就可以直接将数据传送给 客户端；若双方建立的是HTTP连接，则服务器需要等到客户端发送一次请求后才能将数据传回给客户端，因此，客户端定时向服务器端发送连接请求，不仅可以 保持在线，同时也是在“询问”服务器是否有新的数据，如果有就将数据传给客户端。
这里我们使用Socket实现一个聊天室的功能，关于服务器这里的就不介绍了</p>

<hr />

<p>画中画模式
iOS 9 中多任务的另一种表现形式就是视频的画中画模式：即使退出了，你的视频 app 也可以在用户使用别的 app 的时候保持播放，比如一边看美剧一边写日记或者发邮件。这大概会是所有的视频类 app 都必须要支持的特性了，实现起来也很容易：</p>

<p>使用 iOS 9 SDK 构建你的 app；
在 app 的 Capabilities 里，将 Background Modes 的 &ldquo;Audio, AirPlay, and Picture in Picture&rdquo; 勾选上 (Xcode 7 beta 中暂时为 &ldquo;Audio and AirPlay&rdquo;)；
将 AudioSession Catogory 设置为合适的选项，比如 AVAudioSessionCategoryPlayback
使用 AVKit，AVFoundation 或者 WebKit 框架来播放视频。</p>

<hr />

<p>URL加载系统
URL加载
NSURLConnection
NSURLRequest    NSMutableURLRequest
NSURLResponse   NSHTTPURLResponse
缓存管理
NSURLCache
NSCacheURLRequest
NSCachedURLResponse
认证 &amp; 证书
NSURLCredential
NSURLCredentialStorage
NSURLAuthenticationChallenge
NSURLProtectionSpace
Cookie存储
NSHTTPCookie
NSHTTPCookieStorage
协议支持
NSURLProtocol</p>

<hr />

<p>NSLock 属性或者使用如 OSAtomicCompareAndSwap32(3) 的底层的死锁函数，@synchronized(){}：</p>

<hr />

<p>@defs
@defs 用于返回一个Objective-C类的struct结构，这个struct与原Objective-C类具有相同的内存布局。</p>

<p>@compatibility_alis
@compatibility_alis 是用于给一个类设置一个别名。这样就不用重构以前的类文件就可以用新的名字来替代原有名字。</p>

<p>@encode
@encode 是用于表示一个类型的字符串，</p>

<hr />

<p><strong>block id weakSelf = self;  //MRC
//</strong>unsafe_unretained __block id weakSelf = self;   ARC下面用这个</p>

<hr />

<p>➢ define 和 const常量有什么区别?
• define在预处理阶段进行替换，const常量在编译阶段使用
• 宏不做类型检查，仅仅进行替换，const常量有数据类型，会执行类型检查
• define不能调试，const常量可以调试
• define定义的常量在替换后运行过程中会不断地占用内存，而const定义的常量存储在数据段只有一份copy，效率更高
• define可以定义一些简单的函数，const不可以
蔡石辟  21:11:23
➢ 如何进行iOS6、7的适配
☺ 通过判断版本来控制，来执行响应的代码
☺ 功能适配：保证同一个功能在6、7上都能用
☺ UI适配：保证各自的显示风格</p>

<hr />

<p>我当时答了大概五个：（在他的提示下）1.    没经过用户同意，你不能随便获取用户信息。2.  所有的程序都在沙盒里运行，B程序不能进入A程序的运行范围。3.   如果跟钱有关，比如说支付宝，这些底层的实现都是保密的，只提供接口供开发者调用，这样的话安全性得到保障。4. 如果要防止代码被反编译，可以将自己的代码中的.m文件封装成静态库（.a文件）或者是framework文件，只提供给其它人.h文件。这样就保证了个人代码的安全性。5.    网络登录的话跟用户名跟密码相关要发送POST请求，如果是GET请求的话密码会直接在URL中显示。然后同时要对帐号密码采用加密技术，加一句：我们公司用的是MD5，但是现在MD5有一个专门的网站来破解，为了防止这个，可以采用加盐技术。1. 客户端安全性处理方式？1> 网络数据传输(敏感数据[账号\密码\消费数据\银行卡账号], 不能明文发送)2>  协议的问题(自定义协议, 游戏代练)3>    本地文件存储(游戏的存档)4>   源代码5> 熟悉Socket、TCP、UDP、XMPP 、HTTP、TCP：安全的协议，能保证数据顺序和正确性，服务器和客户端能随时互发数据。如果服务器要主动发送数据给客户端，可以用这个协议UDP：非安全的协议，容易丢失数据，一般用于联机对战的游戏XMPP：基于XML通讯的协议，基于TCP发送XML数据，一般用于即时通讯（比如QQ、微信）HTTP：一般用于非实时连接的请求，只有客户端主动向服务器发送请求时，服务器才能返回数据给客户端SOCKET：套接口，可以使用TCP/UDP/XMPP通讯</p>

<hr />

<p>今天弄了一个Swift源码的脑图，基本包括了Swift主要功能，当然一些可扩展功能没有包含进去。</p>

<p>Swift源码大致可以分为6块</p>

<p>   物理节点的管理   ： 主要包括物理节点的添加，删除，ring文件，builder文件生成，重平衡，核心算法与数据结构。
   请求与处理    : 各种服务处理请求的模型，都使用线程池来处理并发请求，一致性的服务也使用了固定的daemon模型。
   文件操作    ：文件的操作，具体的逻辑。
   文件管理    ：account和container概念，类别与用户与文件夹的概念（但是不是这个概念）。
   认证与鉴权    ： 认证的程序依靠keystone中间件，而鉴权独立到swift中，真正的鉴权发生在具体操作之前。
   服务管理    ：同一启动服务，管理服务，manager功能。</p>

<hr />

<p>200 [成功] 服务器已成功处理了请求</p>

<p>202 [已接受] 已接受请求，但尚未处理</p>

<p>204 成功处理了请求，但没有返回内容</p>

<p>206 服务器成功处理了部分 GET 请求</p>

<p>301 请求的网页已永久移动到新位置</p>

<p>302 从不同位置响应请求,以后恢复</p>

<p>305 请求者只能使用代理访问请求的网页</p>

<p>400 错误请求，服务器不理解请求的语法</p>

<p>401 未授权，请求要求身份验证</p>

<p>403 [禁止] 服务器拒绝请求</p>

<p>404 [未找到] 服务器找不到请求的网页</p>

<p>500 服务器遇到错误，无法完成请求</p>

<p>502 作为网关或代理从上游收到无效响应</p>

<hr />

<p>IMP实际上是一个函数指针，指向方法实现的首地址。
Method用于表示类定义中的方法，相当于在SEL和IMP之间作了一个映射。有了SEL，我们便可以找到对应的IMP，从而调用方法的实现代码
Ivar是表示实例变量的类型，其实际是一个指向objc_ivar结构体的指针
Meta Class所有的类自身也是一个对象，我们可以向这个对象发送消息
SEL又叫选择器，是表示一个方法的selector的指针</p>

<hr />

<p>使用CoreGraphics，不要过多使用Xib（如果可以的话使用storyboard），透明度，NsDateFormatter 的痛苦，cell高度计算，使用富文本标签代价是很昂贵的，缓存下载的图片，重用cells，避免阻塞主线程，提升速度Instruments</p>

<hr />

<p>alloc-init-loadView-viewDidLoad-viewWillAppear-viewWilllayoutSubviews-viewDidLayoutSubviews-viewDidAppear-viewWillDisappear-viewDidDisappear-dealloc</p>

<hr />

<p>红包功能需要自行实现，红包的实现，在ui展示上就是一个消息。真正的逻辑是点击的时候实现了什么。还有验证双方是否可以领取，发红包就是发个自定义消息。点了消息去领取，您自己服务器做验证才行。比如现在的demo里发图片，点击是显示大图。扩展消息，点击后，就可以让它去您那边服务器做验证，然后领取。</p>

<hr />

<hr />

<hr />

<hr />

<hr />

  
    <footer>
      <p class="meta">
        
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
      
        <div class="sharing">
  
  
  
</div>

      
    </footer>
  
</article>

</div>

<aside class="sidebar">
  
    <section>
    <h1>文章分类</h1>
    <ul id="categories">
        <li class='category'><a href='/blog/categories/advanced/'>advanced (22)</a></li>
<li class='category'><a href='/blog/categories/algorithm/'>algorithm (1)</a></li>
<li class='category'><a href='/blog/categories/background/'>background (1)</a></li>
<li class='category'><a href='/blog/categories/bottom/'>bottom (5)</a></li>
<li class='category'><a href='/blog/categories/developer/'>developer (7)</a></li>
<li class='category'><a href='/blog/categories/fore-end/'>fore-end (2)</a></li>
<li class='category'><a href='/blog/categories/interview/'>interview (1)</a></li>
<li class='category'><a href='/blog/categories/necessary/'>necessary (5)</a></li>
<li class='category'><a href='/blog/categories/newfeatures/'>newfeatures (5)</a></li>
<li class='category'><a href='/blog/categories/performance/'>performance (8)</a></li>
<li class='category'><a href='/blog/categories/projects/'>projects (27)</a></li>
<li class='category'><a href='/blog/categories/summary/'>summary (20)</a></li>
<li class='category'><a href='/blog/categories/tools/'>tools (5)</a></li>
<li class='category'><a href='/blog/categories/watchos2/'>watchos2 (1)</a></li>

    </ul>
</section><section>
  <h1>最新文章</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2016/01/24/iCocos/">温馨提示</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/01/22/cookie-session/">Cookie是撒(&session）</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/01/21/keyChain/">Keychain介绍与使用</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/01/18/disanfangzhifu/">第三方支付总结</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/01/15/tupianyibuhuancun/">图片处理-异步缓存优化</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/al1020119">@al1020119</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'al1020119',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>




<section>
<h1>扫一扫<abbr title="The word '扫一扫' is a registered trademark of DENSO WAVE INCORPORATED. It applies only for the word '扫一扫', not for image.">&trade;</abbr></h1>
<a href="http://al1020119.github.io/other/iCocos/index.html"><img src="http://chart.apis.google.com/chart?chs=150x150&cht=qr&chld=|0&chco=165B94&chl=http://al1020119.github.io/other/iCocos/index.html" alt="post-qrcode"></a></section>
<section>
    <h1>访客统计</h1>
    <br/>
    <a href="http://s07.flagcounter.com/more/2SH"><img src="http://s07.flagcounter.com/count/2SH/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_1/flags_0/" alt="Flag Counter" border="0"></a>
</section><section>
    <h1>新浪微博</h1>
    <ul id="weibo">
        <li>
            
            <!-- 在此插入获得的微博秀代码 -->
            <iframe width="100%" height="550" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=550&fansRow=2&ptype=1&speed=0&skin=1&isTitle=1&noborder=1&isWeibo=1&isFans=1&uid=3288975567&verifier=20ffcedd&dpc=1"></iframe>
            
        </li>
    </ul>
</section>
  
</aside>


<!-- 多说评论 -->

<section>
    <h1>更多评论</h1>
    <div id="comments" aria-live="polite"><!-- Duoshuo Comment BEGIN -->
<div class="ds-thread" data-title="Octopress博客的个性化配置"></div>
<script type="text/javascript">
    var duoshuoQuery = {short_name:"tianweili"};
    (function() {
     var ds = document.createElement('script');
     ds.type = 'text/javascript';ds.async = true;
     ds.src = 'http://static.duoshuo.com/embed.js';
     ds.charset = 'UTF-8';
     (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
     })();
    </script>
<!-- Duoshuo Comment END --></div>
</section>


    </div>
  </div>
  <footer role="contentinfo"><!--<p>-->
<!--  Copyright &copy; 2016 - iCocos --->
<!--<span class="credit">Preview in <a href="http://al1020119.github.io">[曹#黎]</a></span>-->
<!--</p>-->


<p>
    Copyright &copy; <span>2013</span> - iCocos -
    <span class="credit">Preview in <a href="http://al1020119.github.io">[曹#黎]</a></span>
</p>

</footer>
  






<!--
--->



</body>
</html>
