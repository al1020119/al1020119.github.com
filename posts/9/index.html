
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>iOS梦工厂</title>
  <meta name="author" content="iCocos">

  
  <meta name="description" content="用ARC管理内存 ARC(Automatic Reference Counting, 自动引用计数)和iOS5一起发布，它避免了最常见的也就是经常是由于我们忘记释放内存所造成的内存泄露。它自动为你管理retain和release的过程，所以你就不必去手动干预了。 除了帮你避免内存泄露， &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://al1020119.github.io/posts/9/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="iOS梦工厂" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//libs.baidu.com/jquery/1.7.2/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <script>
function addBlankTargetForLinks () {
    $('a[href^="http"]').each(function(){
                              $(this).attr('target', '_blank');
                              });
}
$(document).bind('DOMNodeInserted', function(event) {
             addBlankTargetForLinks();
             });
</script>
  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">iOS梦工厂</a></h1>
  
    <h2>不战胜自己，何以改变未来！</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="al1020119.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">首页</a></li>
  <li><a href="/blog/archives">归档</a></li>
  <li><a href="/icocos">iCocos</a></li>
  <li><a href="/other">随笔录</a></li>
  <li><a href="/about">关于</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/12/25/xingnengyouhua-xiaojie/">性能优化小结</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><ol>
<li>用ARC管理内存
 ARC(Automatic Reference Counting, 自动引用计数)和iOS5一起发布，它避免了最常见的也就是经常是由于我们忘记释放内存所造成的内存泄露。它自动为你管理retain和release的过程，所以你就不必去手动干预了。
 除了帮你避免内存泄露，ARC还可以帮你提高性能，它能保证释放掉不再需要的对象的内存</li>
<li>在正确的地方使用reuseIdentifier
 这个方法把那些已经存在的cell从队列中排除，或者在必要时使用先前注册的nib或者class创造新的cell。如果没有可重用的cell，你也没有注册一个class或者nib的话，这个方法返回nil。</li>
<li>尽可能使Views不透明
 如果你有不透明的Views，你应该设置它们的opaque属性为YES。
 (opaque)这个属性给渲染系统提供了一个如何处理这个view的提示。如果设为YES， 渲染系统就认为这个view是完全不透明的，这使得渲染系统优化一些渲染过程和提高性能。如果设置为NO，渲染系统正常地和其它内容组成这个View。默认值是YES。</li>
</ol>


<p>在相对比较静止的画面中，设置这个属性不会有太大影响。然而当这个view嵌在scroll view里边，或者是一个复杂动画的一部分，不设置这个属性的话会在很大程度上影响app的性能。</p>

<p>你可以在模拟器中用Debug\Color Blended Layers选项来发现哪些view没有被设置为opaque。目标就是，能设为opaque的就全设为opaque!</p>

<ol>
<li><p>避免庞大的XIB（一次性加载）</p>

<p> 如果你不得不XIB的话，使他们尽量简单。尝试为每个Controller配置一个单独的XIB，尽可能把一个View Controller的view层次结构分散到单独的XIB中去。
 原因是这会使系统用一个最优的方式渲染这些views。这个简单的属性在IB或者代码里都可以设定。</p>

<p> 需要注意的是，当你加载一个XIB的时候所有内容都被放在了内存里，包括任何图片。如果有一个不会即刻用到的view，你这就是在浪费宝贵的内存资源了。Storyboards就是另一码事儿了，storyboard仅在需要时实例化一个view controller.</p>

<p> 当家在XIB是，所有图片都被chache，如果你在做OS X开发的话，声音文件也是。Apple在相关文档中的记述是：
 当你加载一个引用了图片或者声音资源的nib时，nib加载代码会把图片和声音文件写进内存。在OS X中，图片和声音资源被缓存在named cache中以便将来用到时获取。在iOS中，仅图片资源会被存进named caches。取决于你所在的平台，使用NSImage 或UIImage 的<code>imageNamed:</code>方法来获取图片资源。</p></li>
<li><p>不要block主线程（主：UI）
 永远不要使主线程承担过多。因为UIKit在主线程上做所有工作，渲染，管理触摸反应，回应输入等都需要在它上面完成
 大部分阻碍主进程的情形是你的app在做一些牵涉到读写外部资源的I/O操作，比如存储或者网络。</p></li>
</ol>


<p>你可以使用<code>NSURLConnection</code>异步地做网络操作:
或者使用像 AFNetworking这样的框架来异步地做这些操作。</p>

<p>如果你需要做其它类型的需要耗费巨大资源的操作(比如时间敏感的计算或者存储读写)那就用 Grand Central Dispatch，或者 NSOperation 和 NSOperationQueues.</p>

<ol>
<li><p>在Image Views中调整图片大小(与控件对应)
 如果要在<code>UIImageView</code>中显示一个来自bundle的图片，你应保证图片的大小和UIImageView的大小相同。在运行中缩放图片是很耗费资源的，特别是<code>UIImageView</code>嵌套在<code>UIScrollView</code>中的情况下。</p>

<p> 如果图片是从远端服务加载的你不能控制图片大小，比如在下载前调整到合适大小的话，你可以在下载完成后，最好是用background thread，缩放一次，然后在UIImageView中使用缩放后的图片。</p></li>
<li>选择正确的Collection（Arrays: 有序的一组值。使用index来lookup很快，使用value lookup很慢， 插入/删除很慢。Dictionaries: 存储键值对。 用键来查找比较快。Sets: 无序的一组值。用值来查找很快，插入/删除很快。）</li>
<li>打开gzip压缩 （服务端和你的app）
 好消息是，iOS已经在NSURLConnection中默认支持了gzip压缩，当然AFNetworking这些基于它的框架亦然。像Google App Engine这些云服务提供者也已经支持了压缩输出</li>
<li><p>重用和延迟加载Views
 这里我们用到的技巧就是模仿<code>UITableView</code>和<code>UICollectionView</code>的操作: 不要一次创建所有的subview，而是当需要时才创建，当它们完成了使命，把他们放进一个可重用的队列中。</p>

<p> 这样的话你就只需要在滚动发生时创建你的views，避免了不划算的内存分配。</p>

<p> 创建views的能效问题也适用于你app的其它方面。想象一下一个用户点击一个按钮的时候需要呈现一个view的场景。有两种实现方法：</p>

<ol>
<li>创建并隐藏这个view当这个screen加载的时候，当需要时显示它；</li>
<li>当需要时才创建并展示。
每个方案都有其优缺点。</li>
</ol>


<p> 用第一种方案的话因为你需要一开始就创建一个view并保持它直到不再使用，这就会更加消耗内存。然而这也会使你的app操作更敏感因为当用户点击按钮的时候它只需要改变一下这个view的可见性。</p>

<p> 第二种方案则相反-消耗更少内存，但是会在点击按钮的时候比第一种稍显卡顿。</p></li>
<li><p>Cache, Cache, 还是Cache！（NSCache：系统回收内存的时候它会自动删掉它的内容）
你可以通过 NSURLConnection 获取一个URL request， AFNetworking也一样的。这样你就不必为采用这条tip而改变所有的networking代码了。
如果你需要缓存其它不是HTTP Request的东西，你可以用NSCache。</p></li>
<li>权衡渲染方法（CALayer， CoreGraphics，OpenGL，Metal：性能能&amp;bundle大小）</li>
<li><p>处理内存警告
 在app delegate中使用<code>applicationDidReceiveMemoryWarning:</code> 的方法
在你的自定义UIViewController的子类(subclass)中覆盖<code>didReceiveMemoryWarning</code>
注册并接收 UIApplicationDidReceiveMemoryWarningNotification 的通知
一旦收到这类通知，你就需要释放任何不必要的内存使用。
UIViewController的默认行为是移除一些不可见的view， 它的一些子类则可以补充这个方法，删掉一些额外的数据结构。一个有图片缓存的app可以移除不在屏幕上显示的图片。</p>

<p>这样对内存警报的处理是很必要的，若不重视，你的app就可能被系统杀掉。</p>

<p>然而，当你一定要确认你所选择的object是可以被重现创建的来释放内存。一定要在开发中用模拟器中的内存提醒模拟去测试一下。</p></li>
<li>重用大开销的对象
还需要注意的是，其实设置一个NSDateFormatter的速度差不多是和创建新的一样慢的！所以如果你的app需要经常进行日期格式处理的话，你会从这个方法中得到不小的性能提升。</li>
<li>使用Sprite Sheets（渲染速度加快，甚至比标准的屏幕渲染方法节省内存。）</li>
<li>避免反复处理数据（从特定key中取数据，那么就使用键值对的dictionary）
 你需要数据来展示一个table view,最好直接从服务器取array结构的数据以避免额外的中间数据结构改变。</li>
<li><p>选择正确的数据格式（JSON和XML）
解析JSON会比XML更快一些，JSON也通常更小更便于传输。从iOS5起有了官方内建的JSON deserialization 就更加方便使用了。</p>

<p>但是XML也有XML的好处，比如使用SAX 来解析XML就像解析本地文件一样，你不需像解析json一样等到整个文档下载完成才开始解析。当你处理很大的数据的时候就会极大地减低内存消耗和增加性能</p></li>
<li><p>正确地设定Background Images（colorWithPatternImage，UIImageView）
 如果你使用全画幅的背景图，你就必须使用UIImageView因为UIColor的colorWithPatternImage是用来创建小的重复的图片作为背景的。这种情形下使用UIImageView可以节约不少的内存：</p>

<p>如果你用小图平铺来创建背景，你就需要用UIColor的colorWithPatternImage来做了，它会更快地渲染也不会花费很多内存：</p></li>
<li><p>减少使用Web特性（不像驱动Safari的那么快，尽可能移除不必要的javascript，避免使用过大的框架。能只用原生js就更好了）
另外，尽可能异步加载例如用户行为统计script这种不影响页面表达的javascript。</p>

<p>最后，永远要注意你使用的图片，保证图片的符合你使用的大小。使用Sprite sheet提高加载速度和节约内存。</p></li>
<li><p>设定Shadow Path（QuartzCore：Core Animation不得不先在后台得出你的图形并加好阴影然后才渲染，这开销是很大的。）
使用shadow path的话iOS就不必每次都计算如何渲染，它使用一个预先计算好的路径。但问题是自己计算path的话可能在某些View中比较困难，且每当view的frame变化的时候你都需要去update shadow path.</p></li>
<li><p>优化你的Table View</p>

<p>正确使用<code>reuseIdentifier</code>来重用cells
尽量使所有的view opaque，包括cell自身
避免渐变，图片缩放，后台选人
缓存行高
如果cell内现实的内容来自web，使用异步加载，缓存请求结果
使用<code>shadowPath</code>来画阴影
减少subviews的数量
尽量不适用<code>cellForRowAtIndexPath:</code>，如果你需要用到它，只用一次然后缓存结果
使用正确的数据结构来存储数据
使用<code>rowHeight</code>, <code>sectionFooterHeight</code> 和 <code>sectionHeaderHeight</code>来设定固定的高，不要请求delegate</p></li>
<li><p>选择正确的数据存储选项</p>

<p>使用<code>NSUerDefaults</code>
使用XML, JSON, 或者 plist
使用NSCoding存档
使用类似SQLite的本地SQL数据库
使用 Core Data
NSUserDefaults的问题是什么？虽然它很nice也很便捷，但是它只适用于小数据，比如一些简单的布尔型的设置选项，再大点你就要考虑其它方式了</p>

<p>XML这种结构化档案呢？总体来说，你需要读取整个文件到内存里去解析，这样是很不经济的。使用SAX又是一个很麻烦的事情。</p>

<p>NSCoding？不幸的是，它也需要读写文件，所以也有以上问题。</p>

<p>在这种应用场景下，使用SQLite 或者 Core Data比较好。使用这些技术你用特定的查询语句就能只加载你需要的对象。</p>

<p>在性能层面来讲，SQLite和Core Data是很相似的。他们的不同在于具体使用方法。Core Data代表一个对象的graph model，但SQLite就是一个DBMS。Apple在一般情况下建议使用Core Data，但是如果你有理由不使用它，那么就去使用更加底层的SQLite吧。</p>

<p>如果你使用SQLite，你可以用FMDB(<a href="https://github.com/ccgus/fmdb">https://github.com/ccgus/fmdb</a>)这个库来简化SQLite的操作，这样你就不用花很多经历了解SQLite的C API了。</p></li>
<li><p>加速启动时间
尽可能做更多的异步任务，比如加载远端或者数据库数据，解析数据。</p></li>
</ol>


<p>还是那句话，避免过于庞大的XIB，因为他们是在主线程上加载的。所以尽量使用没有这个问题的Storyboards吧！</p>

<p>注意，用Xcode debug时watchdog并不运行，一定要把设备从Xcode断开来测试启动速度</p>

<ol>
<li><p>使用Autorelease Pool</p>

<p> 你创建很多临时对象，你会发现内存一直在减少直到这些对象被release的时候。这是因为只有当UIKit用光了autorelease pool的时候memory才会被释放。</p></li>
<li><p>选择是否缓存图片（一个是用<code>imageNamed</code>：当加载时会缓存图片，用一个指定的名字在系统缓存中查找并返回一个图片对象如果它存在的话。如果缓存中没有找到相应的图片，这个方法从指定的文档中加载然后缓存并返回这个对象，二是用<code>imageWithContentsOfFile</code>，仅加载图片）</p>

<p>如果你要加载一个大图片而且是一次性使用，那么就没必要缓存这个图片，用<code>imageWithContentsOfFile</code>足矣，这样不会浪费内存来缓存它。</p>

<p>然而，在图片反复重用的情况下<code>imageNamed</code>是一个好得多的选择。</p></li>
<li>尽量避免日期格式转换（尽量选择Unix时间戳）
许多web API会以微秒的形式返回时间戳，因为这种格式在javascript中更方便使用。记住用<code>dateFromUnixTimestamp</code>之前除以1000就好了。</li>
</ol>


<hr />

<p>tableView优化总结：</p>

<blockquote><p>卡顿：重用是否成功（自己写）—是否是多次请求-青花瓷（每次滚动）—github，博客，微博&ndash;Instruments三件套(Time Profiler,Core Animation,GPU Driver)—GPU-CPU-代码逻辑-1.cell高度没有缓存。2. refreshData（reloadData）2次。 3.懒加载View 4.圆角问题  5.尺寸对应  6.NSDateFormatter 7.UIImage缓存取舍 8.手动 Drawing（Cell 中 view 的组织复杂）9. UI 线程的时间 10.缓存一切可以缓存的！就是“用空间替换时间”！</p></blockquote>

<ol>
<li><p>最常用的就是cell的重用， 注册重用标识符</p>

<p> 如果不重用cell时，每当一个cell显示到屏幕上时，就会重新创建一个新的cell
 如果有很多数据的时候，就会堆积很多cell。如果重用cell，为cell创建一个ID
 每当需要显示cell 的时候，都会先去缓冲池中寻找可循环利用的cell，如果没有再重新创建cell
 设置正确的reuseIdentifer以重用cell</p></li>
<li><p>避免cell的重新布局</p>

<p> cell的布局填充等操作 比较耗时，一般创建时就布局好
 如可以将cell单独放到一个自定义类，初始化时就布局好</p></li>
<li><p>提前计算并缓存cell的属性及内容</p>

<p> 在cellForRowAtIndexPath:中尽量做更少的操作。如果需要做一些处理，那么最好做过一次之后，就将结果缓存起来。
 当我们创建cell的数据源方法时，编译器并不是先创建cell 再定cell的高度
 而是先根据内容一次确定每一个cell的高度，高度确定后，再创建要显示的cell，滚动时，每当cell进入凭虚都会计算高度，提前估算高度告诉编译器，编译器知道高度后，紧接着就会创建cell，这时再调用高度的具体计算方法，这样可以方式浪费时间去计算显示以外的cell</p></li>
<li><p>减少cell中控件的数量</p>

<p> 尽量使cell得布局大致相同，不同风格的cell可以使用不用的重用标识符，初始化时添加控件，
 不适用的可以先隐藏</p></li>
<li><p>不要使用ClearColor，无背景色，透明度也不要设置为0</p>

<p> 渲染耗时比较长
 尽量将view设置为不透明，包括cell本身。</p></li>
<li><p>使用局部更新</p>

<p> 如果只是更新某组的话，使用reloadSection进行局部更新</p></li>
<li><p>加载网络数据，下载图片，使用异步加载，并缓存</p>

<p> 如果cell显示的内容来此网络，那么确保这些内容是通过异步来获取的</p></li>
<li><p>少使用addView 给cell动态添加view</p></li>
<li><p>按需加载cell，cell滚动很快时，只加载范围内的cell</p>

<p> 注意正确使用懒加载</p></li>
<li><p>不要实现无用的代理方法，tableView只遵守两个协议</p>

<p>非必要的代理或者数据源方法可以省略，比如numberofsention</p></li>
<li><p>缓存行高：</p>

<p>如果row的高度不相同，那么将其缓存下来
estimatedHeightForRow不能和HeightForRow里面的layoutIfNeed同时存在，这两者同时存在才会出现“窜动”的bug。所以我的建议是：只要是固定行高就写预估行高来减少行高调用次数提升性能。如果是动态行高就不要写预估方法了，用一个行高的缓存字典来减少代码的调用次数即可</p></li>
<li><p>避免渐变，图像缩放以及离屏绘制</p></li>
<li><p>使用shadowPath来设置阴影。</p></li>
<li><p>使用适当的数据结构来保存需要的信息。不同的结构会带来不同的操作代价。</p></li>
<li><p>使用rowHeight, sectionFooterHeight 和 sectionHeaderHeight 来设置一个恒定 高度，而不要从delegate中获取。</p></li>
<li><p>使用富文本标签代价是很昂贵的</p></li>
</ol>


<p>费尽周折用富文本标签，代价太昂贵了。尽可能地避免使用这个。问问你自己是否真的需要这个。如果是的话，尽可能的做缓存。</p>

<p>提前计算并缓存好高度（布局），因为heightForRowAtIndexPath:是调用最频繁的方法；
异步绘制，遇到复杂界面，遇到性能瓶颈时，可能就是突破口；
滑动时按需加载，这个在大量图片展示，网络加载的时候很管用！（SDWebImage已经实现异步加载，配合这条性能杠杠的）。
除了上面最主要的三个方面外，还有很多几乎大伙都很熟知的优化点：</p>

<ul>
<li>正确使用reuseIdentifier来重用Cells</li>
<li>尽量使所有的view opaque，包括Cell自身</li>
<li>尽量少用或不用透明图层</li>
<li>如果Cell内现实的内容来自web，使用异步加载，缓存请求结果</li>
<li>减少subviews的数量</li>
<li>在heightForRowAtIndexPath:中尽量不使用cellForRowAtIndexPath:，如果你需要用到它，只用一次然后缓存结果</li>
<li>尽量少用addView给Cell动态添加View，可以初始化时就添加，然后通过hide来控制是否显示</li>
<li>尽量设置Cell的view为opaque，避免GPU对Cell下面的内容也进行绘制。</li>
<li>避免大量的图片缩放、颜色渐变等。</li>
<li>避免同步的从网络、文件获取数据（这个是必须的=。=）</li>
<li>用shadowPath创建阴影。</li>
<li>尽量减少subview的数量，如多用drawRect绘制元素，替代用view显示。</li>
<li>尽量显示“大小刚好合适”的图片资源。</li>
</ul>


<p>总的来说，就是：</p>

<ul>
<li>缓存一切可以缓存的！就是“用空间替换时间”！</li>
</ul>


<p>在UITableView的Delegate、DataSource方法中，减少任何不必要的操作</p>
</div>
  
  




| <a href="/blog/2013/12/25/xingnengyouhua-xiaojie/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/12/08/badaccess-error/">EXC_BAD_ACCESS无处不在</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><p>这种错误可以说是每次写代码都会遇到的，所以如果是你你会怎么解决呢，如果不知道那么请往下看
EXC_BAD_ACCESS, objc_msgSend,</p>

<p>此类报错往往来的莫明奇妙.</p>

<p>原因往往是内存过度释放导致, 即多写了release;</p>

<p>至于是哪里多写了release, 很难查知,</p>

<p>出现这种情况， 也就是对指针对象的过度释放，导致次指针为野指针报错， （注意：如：[nil release] 操作空指针是不会报错的，在java中是有问题， [野指针 release] 报错  crash  很危险，）解决中bug，有很多中，暂时简单的说下几种简单的：</p>

<h5>一： 在xcode中Run，Stop 右边也就是选择设备的地方左边找到</h5>

<p> Scheme >Edit Scheme>Arguments>Environment Variables下添加</p>

<ol>
<li>NSZombieEnabled               YES</li>
<li>MallocStackLoggingNoCompact  YES</li>
<li>MallocStackLogging                      YES</li>
</ol>


<p><img src="/images/BADACCESS001.png" title="Caption" ></p>

<p><img src="/images/BADACCESS002.png" title="Caption" ></p>

<p><img src="/images/BADACCESS003.png" title="Caption" ></p>

<ul>
<li>第一項 让系统把错误地址打印出来</li>
<li>第二項 可让xcode记录每个地址alloc的历史，这样我们就可以用命令把这个地址还原出来</li>
<li>第三項 可開啟MallocStack，就知道記憶體在程式運行中被配置的歷史</li>
</ul>


<blockquote><p>（注意：这个命令只支持gdb，必须把控制台的输出改成gdb，只支持模拟器，不支持真机调试）</p></blockquote>

<h5>二：在.m或者.mm文件中  直接添加打印最后日志文件 代码如下：</h5>

<pre><code>#ifdef _FOR_DEBUG_

- (BOOL)respondsToSelector:(SEL)rtSelector

{

    NSString *className = NSStringFromClass([self class]) ;    

    NSLog(@"%@ --&gt; RTSelector: %s",className,[NSStringFromSelector(rtSelector)UTF8String]);

        return [super respondsToSelector:rtSelector];

}

#endif
</code></pre>

<h5>三：找到模糊的地方， 断点调试， 或者打印标识 从大范围到小范围，</h5>

<p>具体操作我这里就不多说了，根据项目的需求在对应代码行的左边点击就可以打断点</p>

<h5>四：Leak的方式</h5>

<ol>
<li>打开Instruments工具:</li>
</ol>


<p>Xcode -> Open Developer Tool -> Instruments,</p>

<ol>
<li><p>选择Zombies类型.
<img src="/images/BADACCESS004.png" title="Caption" ></p></li>
<li><p>重新启动运行Project, 先不要执行到崩溃点.</p></li>
<li><p>在打开的Instruments工具中choose要检查的程序名称;</p></li>
<li><p>然后点击Instruments左上角的record按钮, 开始记录内存使用情况.</p></li>
</ol>


<p><img src="/images/BADACCESS005.png" title="Caption" ></p>

<p><img src="/images/BADACCESS006.png" title="Caption" ><br/>
6. 继续执行程序至崩溃点.</p>

<p>程序执行到第40秒报出zombie Messaged错误;</p>

<ol>
<li><p>点击图中圈选的">&ldquo;查看内存详情.
<img src="/images/BADACCESS007.png" title="Caption" ></p></li>
<li><p>分析内存调用详情:</p></li>
</ol>


<p>排除操作系统retain, release的部分,</p>

<p>可知是由于CameraLiveViewController执行dealloc,</p>

<p>对内存0x180d5420多调用了release.
<img src="/images/BADACCESS008.png" title="Caption" ></p>

<h3>综合以上结果:</h3>

<p>可知是存在于CameraLiveViewController中的一个UILabel多执行了release.</p>

<p>此时可添加代码对CameraLiveViewController中的可疑UILabel打印日志.</p>

<p>重新执行上述过程, 对比打印UILabel与Zobmie内存的地址,</p>

<p>从而定位出错位置.
<img src="/images/BADACCESS009.png" title="Caption" ></p>
</div>
  
  




| <a href="/blog/2013/12/08/badaccess-error/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/11/26/xcode-settingfile/">Xcode配置文件</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><p>一个xcodeproj文件，其实是一个目录，它的格式大体上是这样的：</p>

<p>这里写图片描述</p>

<p>有的文件，比如user.mode1v3，在没有多个用户操作项目的时候，是没有的。Apple并没有提供.xcodeproj文件的文档，而且它也没有准备提供，更坑爹的是，xcodeproj的格式、内容都是随时可变的，比如一个Xcode版本上来，可能其目录就会变化，而没有任何通知。这可苦了那些为.xcodeproj开发每三方库的同学，不仅要一点一点摸索各个文件的内容，修改方法，还要忍受Apple没有任何通知地修改格式。</p>

<p>Stackoverflow中这位就在抱怨苹果开发人员的傲慢：</p>

<p><a href="http://stackoverflow.com/questions/49478/git-ignore-file-for-xcode-projects/12021580#12021580">http://stackoverflow.com/questions/49478/git-ignore-file-for-xcode-projects/12021580#12021580</a></p>

<p>闲话少说，下面进入正题：各个文件/目录的作用，以及要不要提交更新。</p>

<ul>
<li>project.pbxproj文件</li>
</ul>


<p>这个文件包含了所有此项目build需要的元数据，setting、file reference、configuration、targets…也就是说，这个文件代表的就是这个project。
因此，在修改了这个文件之后，需要提交上去。</p>

<ul>
<li>project.xcworkspace目录</li>
</ul>


<p>这个文件比较特殊。
首先要了解的是workspace和project的概念。project应该比较清楚，那workspace是什么呢？workspace是一种Xcode documentation，可以将多个project和其它文件放到一起，这样可以work on them together。一个project也可以属于多个workspace。所以简单来讲，workspace里面就是一个或多个projects的reference，放在一起，有时候比较好工作。
这样的话，如果项目里面根本就没有workspace的概念，或者只有一个workspace+一个project，这个workspace并不会有什么变动，那这个文件就不需要提交同步。如果project很依赖workspace，没有workspace就运行不了，活不下去了，这时候这个文件肯定是要同步的。</p>

<ul>
<li>user.pbxuser文件</li>
</ul>


<p>Xcode项目为每一个使用这个项目的用户创建一个user.pbxuser文件，存储了此用户对项目的偏好设置，如Xcode的位置和大小、文件书签等。可以看到这个文件是针对某个用户的，可以说是私人性质的，跟整个项目没有太大关系，所以一般不需要同步。</p>

<ul>
<li>user.mode1v3和user.mode2v3文件</li>
</ul>


<p>这个也是用户相关的文件，和user.pbxuser差不多，存储某用户特定的项目设置，比如Xcode中window的状态和结构，断点等等。
因此也不需要同步。</p>

<ul>
<li>xcuserdata目录/xcshareddata目录：</li>
</ul>


<p>大体上来说，和上面两种一样，也是用户相关的文件，包含user state，folders的状态，最后打开的文件等。因此一般来说是不需要同步的。
例外是，这个目录里也包含了scheme相关的内容。如果项目里需要同步特定的scheme，这时候，需要在Edit Scheme里，勾选Share框，然后把新生成的xcshareddata目录提交上去。</p>

<ul>
<li>.xccheckout</li>
</ul>


<p>我没有碰到过这个文件。
这个文件在xcworkspace目录里。</p>

<ul>
<li>.xccheckout文件包含了关于workspace中用到了什么repo的数据。</li>
</ul>


<p>根据说明，它的规则和xcworkspace差不多：如果没用过，或者只是简单使用workspace，不需要同步；如果深入使用workspace，则需要同步。</p>

<p>总结1：
.xcodeproj里的文件大体上有3种：</p>

<ul>
<li>项目文件</li>
<li>单个用户的文件</li>
<li>跟workspace相关的文件</li>
</ul>


<blockquote><p>项目文件，需要同步；</p>

<p>单个用户的文件，不需要同步；</p>

<p>跟workspace相关的文件，视有没有深入使用workspace而定。</p></blockquote>

<p>总结2：</p>

<p>需要同步的文件：</p>

<ul>
<li>project.pbxproj文件</li>
<li>xcsharedata目录</li>
</ul>


<blockquote><p>不需要同步的文件</p></blockquote>

<ul>
<li>user.pbxuser文件</li>
<li>user.mode1v3/user.mode2v3文件</li>
</ul>


<p>xcuserdata目录,视workspace情况而定的文件：</p>

<ul>
<li>.xcworkspace目录</li>
<li>.xccheckout文件</li>
</ul>

</div>
  
  




| <a href="/blog/2013/11/26/xcode-settingfile/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/11/11/changenumber/">不借助第三方变量修改两个值（四种方法）</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><p>交换值</p>

<ul>
<li>1）算术运算；</li>
<li>2）指针地址操作；</li>
<li>3）位运算；</li>
<li>4）栈实现。</li>
</ul>


<p>1） 算术运算</p>

<pre><code>int a,b;
a=10;b=12;
a=b-a; //a=2;b=12
b=b-a; //a=2;b=10
a=b+a; //a=10;b=10
</code></pre>

<p>2） 指针地址操作</p>

<pre><code>int *a,*b; //假设
*a=new int(10);
*b=new int(20); //&amp;a=0x00001000h,&amp;b=0x00001200h
a=(int*)(b-a); //&amp;a=0x00000200h,&amp;b=0x00001200h
b=(int*)(b-a); //&amp;a=0x00000200h,&amp;b=0x00001000h
a=(int*)(b+int(a)); //&amp;a=0x00001200h,&amp;b=0x00001000h
</code></pre>

<p>3） 位运算</p>

<pre><code>int a=10,b=12; //a=1010^b=1100;
a=a^b; //a=0110^b=1100;
b=a^b; //a=0110^b=1010;
a=a^b; //a=1100=12;b=1010;
</code></pre>

<p>4）栈实现。</p>

<pre><code>int exchange(int x,int y) 
{ 
 stack S; 
 push(S,x); 
 push(S,y); 
 x=pop(S); 
 y=pop(S); 
}
</code></pre>

<blockquote><p>以上方法中第一种和第三中是最常见的！</p></blockquote>
</div>
  
  




| <a href="/blog/2013/11/11/changenumber/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/10/17/pingguoshenhe/">苹果审核指南</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><p>审核指南(修改部分红色字体标出)：</p>

<h3>1.条款和条件</h3>

<ul>
<li>1.1为App Store开发程序，开发者必须遵守Program License Agreement (PLA)、人机交互指南(HIG)以及开发者和苹果签订的任何其他协议和合同。以下规则和例证旨在帮助开发者的程序能获得App Store的认可，而不是修改或删除任何其他协议中的条款。</li>
</ul>


<h3>2.功能</h3>

<ul>
<li><p>2.1 崩溃的程序将会被拒绝。</p></li>
<li><p>2.2 存在错误的程序将会被拒绝。</p></li>
<li><p>2.3 跟开发者宣传不符的程序将会被拒绝。</p></li>
<li><p>2.4 无应用文档或隐藏功能与描述不符的程序将会被拒绝。</p></li>
<li><p>2.5 使用非公开API的程序将会被拒绝。</p></li>
<li><p>2.6 在指定容器范围外读写数据的程序将会被拒绝。</p></li>
<li><p>2.7 以任何方式或形式下载代码的程序将会被拒绝。</p></li>
<li><p>2.8 安装或运行其他可执行代码的程序将会被拒绝。</p></li>
<li><p>2.9 Demo版、trial版和test版的程序将会被拒绝。Beta版应用程序可通过TestFlight提交，并且必须遵守相关指南。(此前并未允许Beta版通过TestFlight提交)</p></li>
<li><p>2.10 iPhone程序必须不经修改就能以iPhone分辨率和2倍iPhone 3GS的分辨率在iPad上运行。</p></li>
<li><p>2.11 与App Store已有程序重复的应用可能会被拒绝，特别是数量很多的情况下，比如手电筒应用和爱经应用。</p></li>
<li><p>2.12 没有显著用途、不独特的应用程序或者与网站简单捆绑的应用有可能被拒;不提供任何持久娱乐价值的程序可能会被拒绝。</p></li>
<li><p>2.13 内容主要是营销材料或广告的程序将会被拒绝。</p></li>
<li><p>2.14 包含欺骗或虚假功能，却有没有标明的应用程序将会被拒绝。</p></li>
<li><p>2.15 大于100MB无法通过蜂窝网络下载的应用(App Store会自动禁止)。</p></li>
<li><p>2.16 多任务程序使用后台服务仅限于几种目的：VoIP、音频播放、地理位置、完成任务以及本地提醒等。</p></li>
<li><p>2.17 应用程序只允许使用iOS WebKit框架和WebKit Javascript浏览web内容。</p></li>
<li><p>2.18 鼓励酗酒或使用违禁药物，或引诱青少年饮酒或吸烟的程序将会被拒绝。</p></li>
<li><p>2.19 提供错误的系统诊断或不精确的设备数据的应用将会被拒绝。</p></li>
<li><p>2.20 向App Store上传大量相似版本程序的开发者将会从iOS开发者计划中除名。</p></li>
<li><p>2.21 简单一首歌曲或者一部影片应用要提交到iTunes store，书籍类应用应该提交到iBookstore。</p></li>
<li><p>2.22 随意根据环境(如定位或者运营商)限制用户使用的应用会被拒。</p></li>
<li><p>2.23 应用必须遵守iOS数据储存指导方针(iOS Data Storage Guidelines )，否则应用将被拒。</p></li>
<li><p>2.24 存放在Newsstand的应用必须遵守开发者项目许可协议(Program License Agreement)的表1、表2以及表3，否则应用将会被拒。</p></li>
<li><p>2.25 类似App store，或者基于购买或者促销的目的而展示其他应用的应用将会被拒绝</p></li>
</ul>


<p>(限制更加严格，此前经过特殊审核批准(比如健康管理、航空以及其他无障碍需求等)，或者为特殊群体用户提供具有重大意义的附加值的应用是可以通过的)</p>

<ul>
<li>2.26 只有当app是出于特殊审核需要(比如健康管理、航空以及无障碍需求等)或为特殊群体用户提供具有重大意义的附加值时，才可以展示和推荐自身以外的其他应用程序，否则应用程序将会被拒绝。</li>
</ul>


<h3>3.元数据(名称、描述、评级、排名等)</h3>

<p>近来厂商踩雷屡见不鲜，此部分请详细阅读</p>

<ul>
<li><p>3.1 应用或者元数据中提到其他任何移动平台将会被拒。</p></li>
<li><p>3.2 带有占位符文本的程序将会被拒绝</p></li>
<li><p>3.3 应用程序的名称、描述、截图或者预览与应用的内容和功能不相关将会被拒绝。</p></li>
</ul>


<p>(此前仅对描述有所限制)</p>

<ul>
<li><p>3.4 为了不混淆用户，iTunes Connect中的应用名称应该和展示在设备上的应用名称一致。</p></li>
<li><p>3.5 不同尺寸的app icon要一致，否则会造成混淆。</p></li>
<li><p>3.6 图标、截图以及预览不符合4+年龄评级的程序将会被拒绝。</p></li>
</ul>


<p>(增加了对预览的限制)</p>

<ul>
<li><p>3.7 目录与类型不适合于程序内容的程序将会被拒绝。</p></li>
<li><p>3.8 开发者有责任为其程序指定适合的评级。不相称的评级可能会由苹果公司修改。</p></li>
<li><p>3.9 开发者有责任为其程序指定恰当的关键字。不恰当的关键词可能会被苹果公司修改/删除。</p></li>
<li><p>3.10 试图通过伪造评论或者付费评论的方式在AppStore中操纵或者其欺骗用户评论(或者采用其他不正当方式)以提升排名的开发者将会被苹果从iOS开发者计划中除名。</p></li>
<li><p>3.11 在安装或打开应用之前，推荐用户重启iOS设备的应用将会被拒。</p></li>
<li><p>3.12 提交审核的应用程序应包含能正常运行的URL，比如支持服务URL和隐私政策URL。</p></li>
<li><p>3.13 应用程序的截图、预览或者营销文本没有清晰地指出附加内容或项目需要额外单独购买(比如使用IAP)将会被拒绝。</p></li>
<li><p>3.14 App预览仅能使用从应用程序捕获的视频屏幕、旁白、文本以及design overlays，否则应用程序将会被拒绝。</p></li>
<li><p>3.15 添加App预览的应用程序，未经许可展示真人个人信息将会被拒绝。</p></li>
<li><p>3.16 App预览仅能使用在所有选定地区内经过授权许可、用于此目的的音乐。</p></li>
<li><p>3.17 App预览包含未经授权的通过app播放的内容(比如iTunes playlist和YouTube流媒体)的应用将会被拒绝。</p></li>
</ul>


<h3>4.位置</h3>

<ul>
<li><p>4.1 在收集、传输或使用位置数据之前未通知并获得用户同意的程序将会被拒绝。</p></li>
<li><p>4.2 将基于位置的API用于车辆、飞机或其他设备的自动控制或自主控制的应用程序将会被拒绝。</p></li>
<li><p>4.3 使用基于位置的API用于应急服务的应用程序将会被拒绝。</p></li>
</ul>


<p>(此处进行了描述修改，未着重指出调度和车队管理)</p>

<ul>
<li>4.4 当与提供的功能或服务密切相关，或者为支持经过授权的广告时，应用程序才可以使用位置数据。</li>
</ul>


<h3>5.推送通知</h3>

<ul>
<li><p>5.1 不使用苹果推送通知(APN)应用接口提供推送通知的程序将会被拒绝。</p></li>
<li><p>5.2 未从苹果获得Push Application ID便擅自使用APN服务的程序将会被拒绝。</p></li>
<li><p>5.3 在首次推送消息或者要求运行推送通知之前未获得用户许可的应用将会被拒绝。</p></li>
<li><p>5.4 使用推送通知发送敏感个人信息或机密信息的程序将会被拒绝。</p></li>
<li><p>5.5 使用推送通知发送非请求消息，或用于钓鱼或群发垃圾信息用途的程序将会被拒绝。</p></li>
<li><p>5.6 应用程序不可使用推送通知发送广告、促销或任何类型的直销信息。</p></li>
<li><p>5.7 应用程序不能向使用推送通知服务的用户收取费用。</p></li>
<li><p>5.8 使用推送通知会过多利用APN服务的网络流量或带宽或给设备带来过度负担的程序将会被拒绝。</p></li>
<li><p>5.9 如果应用程序传送病毒、文件、计算机代码或程序，并且对APN服务的正常运行造成损害或中断，那么该程序将会被拒绝。</p></li>
</ul>


<h3>6.游戏中心</h3>

<ul>
<li><p>6.1 向终端用户或任意第三方显示玩家ID的程序将会被拒绝。</p></li>
<li><p>6.2 将玩家ID用于任何未经游戏中心条款批准用途的程序将会被拒绝。</p></li>
<li><p>6.3 试图进行反向搜索、跟踪、关联、挖掘、获得或利用玩家ID、别名或通过游戏中心获得其他信息的开发者将会iOS开发者计划除名。</p></li>
<li><p>6.4 游戏中心信息(例如排行榜分数)，只能用于游戏中心批准的应用程序中。</p></li>
<li><p>6.5 利用游戏中心服务发送非请求信息，或用于钓鱼或群发垃圾邮件的程序将会被拒绝。</p></li>
<li><p>6.6 过多使用游戏中心网络流量或带宽的应用程序将会被拒绝。</p></li>
<li><p>6.7 如果程序能够传送病毒、文件、计算机代码或程序，并且对游戏中心服务的正常运行造成损害或中断，该程序将会被拒绝。</p></li>
</ul>


<h3>7.广告</h3>

<ul>
<li><p>7.1 人工刷广告浏览量或者广告点击率的应用程序将会被拒绝。</p></li>
<li><p>7.2 包含空iAd广告的应用程序将会被拒绝。</p></li>
<li><p>7.3 主要设计目的在于显示广告的应用程序将会被拒绝。</p></li>
</ul>


<h3>8.商标与商品外观</h3>

<ul>
<li><p>8.1 应用程序必须遵守”Guidelines for Using Apple Trademarks and Copyrights”和”Apple Trademark List”中说明的所有条款与条件。</p></li>
<li><p>8.2 任何误导和暗示苹果公司是该应用程序来源或提供商，或者苹果公司以任何形式表示认可其质量或功能的应用程序将会被拒绝。</p></li>
<li><p>8.3 与目前已有苹果产品或者广告主题外观相似或混淆的应用程序将会被拒绝。</p></li>
<li><p>8.4 在应用程序名称中将苹果产品名拼错的应用程序(例如，GPS for iPhone，iTunz)将会被拒绝。</p></li>
<li><p>8.5 应用程序不得使用受保护的第三方材料(比如商标、版权以及专利)，不能违反第三方使用条款。必须提供使用这些材料的授权许可。</p></li>
<li><p>8.6 若无明确授权许可，从第三方来源处(比如YouTube、SoundCloud以及Vimeo等)下载音乐或者视频内容的应用程序将会被拒绝。</p></li>
</ul>


<h3>9.媒体内容</h3>

<ul>
<li><p>9.1 不使用媒体播放器框架(MediaPlayer Framework)获取音乐库中媒体内容的应用程序将会被拒绝。</p></li>
<li><p>9.2 用户界面模仿任何iPod或者iTunes界面的应用程序将会被拒绝。</p></li>
<li><p>9.3 通过蜂窝网络传输的音频流内容每5分钟不得超过5MB。</p></li>
<li><p>9.4 通过蜂窝网络传输超过10分钟的视频流内容必须使用HTTP Live Streaming协议，并且要包含一个基线为192kbps或者更低的HTTP实时流。</p></li>
</ul>


<h3>10.用户界面</h3>

<ul>
<li><p>10.1 应用程序必须遵守苹果的《iOS Human Interface Guidelines》中所有的条款和条件。</p></li>
<li><p>10.2 外观与iPhone自带应用(比如App Store、iTunes Store和iBookstore)相似的应用程序将会被拒绝。</p></li>
<li><p>10.3 未能按苹果《iOS Human Interface Guidelines》描述正确使用系统提供的项目(比如按钮、图标)的应用将会被拒绝。</p></li>
<li><p>10.4 创建桌面/主屏幕环境或者模拟multi-App插件体验的应用程序将会被拒绝。</p></li>
<li><p>10.5 修改音量大小和铃声/静音等标准开关功能的应用程序将会被拒绝。</p></li>
<li><p>10.6 苹果和我们的客户高度推崇简单、精致、富有创造性以及经过精心设计的界面。虽然需要付出更多，但却非常值得。苹果设立了很高的门槛。如果你的用户界面太过复杂或者水准不高，可能会被拒绝。</p></li>
</ul>


<h3>11.购买与货币流通</h3>

<ul>
<li><p>11.1 使用App Store以外的渠道解锁或开启附加属性和功能的应用程序将会被拒绝。</p></li>
<li><p>11.2 使用应用内支付系统(IAP)以外的系统购买内容、功能或服务的应用软件将会被拒绝。</p></li>
<li><p>11.3 使用IAP购买实物商品或者用于该软件之外的商品和服务的应用软件将会被拒绝。</p></li>
<li><p>11.4 使用IAP购买积分(信用点)或者其他货币必须在本应用中消费。</p></li>
<li><p>11.5 使用IAP购买已过期积分或其他货币的应用软件将会被拒绝。</p></li>
<li><p>11.6 使用IAP订阅的内容至少要持续7天，而且允许在用户的其他iOS设备间共享。</p></li>
<li><p>11.7 使用IAP购买项目的应用程序必须指派正确的购买类型。</p></li>
<li><p>11.8 使用IAP购买iOS内置功能(如照相机，陀螺仪)的应用程序将会被拒绝。</p></li>
<li><p>11.9 含有超过限定时间的内容或服务的应用程序将会被拒绝，除经特定批准的内容(比如电影、电视节目音乐以及书籍)。</p></li>
<li><p>11.10 保险类应用程序必须免费，要遵守发布地区的法律，并且不能使用IAP。</p></li>
<li><p>11.11 一般而言，你的应用程序越贵，我们的评审会越深入。(对不起，我们国产大部分是免费网游)</p></li>
<li><p>11.12 提供订阅功能的应用必须使用IAP，苹果将会按照Developer Program License Agreement中的约定与开发者按30/70比例分成。</p></li>
<li><p>11.13 在应用内使用跳转至外部购买或订阅链接的应用将会被拒，比如”buy”按钮跳转至一个购买电子书的web页面。</p></li>
<li><p>11.14 只要应用内没有跳转至外部购买、订阅的按钮或链接，苹果允许这些应用读取或展示经批准的、在应用外购买或订阅内容(特别是杂志、报纸、书籍、音频、音乐、视频以及云存储内容)。苹果只能通过应用程序内的购买获得一部分收益。</p></li>
<li><p>11.15 应用程序可以只使用自动更新订阅期刊(报纸、杂志)、商业应用程序(企业类、效率类、专业创意类以及云存储类)和媒体类应用程序(视频、音频、声音)，否则应用程序将被拒绝。</p></li>
<li><p>11.16 当与特定的经过审核的实体产品(比如玩具)结合使用时，应用程序可以使用获得批准的附加特性和功能，只要附加功能完全依赖于该硬件产品(比如一款用于控制望远镜的应用程序)或者也可以在不使用实物产品的情况下使用应用程序，比如成就奖励或者使用IAP。</p></li>
<li><p>11.17 如果应用功能遵照各州和联邦法律，那么应用可以用来促进被认可的虚拟货币的流通。</p></li>
</ul>


<h3>12.抓取和聚合</h3>

<ul>
<li><p>12.1 从苹果网站(例如apple.com、iTunes Store、App Store、iTunes Connect以及Apple Developer Programs等)抓取任何信息或者使用苹果网站内容和服务进行排名的应用程序将会被拒绝。</p></li>
<li><p>12.2 应用软件可以使用获得批准的苹果RSS feeds，例如iTunes Store RSS feeds。</p></li>
<li><p>12.3 只是简单的网页剪切、内容整合或者收集链接的应用程序可能会被拒绝。</p></li>
</ul>


<h3>13.损害设备</h3>

<ul>
<li><p>13.1 怂恿用户以可能造成损害的方式使用苹果设备的应用软件将会被拒绝。</p></li>
<li><p>13.2 快速耗光设备电量或产生过多热量的应用软件将会被拒绝。</p></li>
<li><p>13.3 能导致用户人身伤害的app将会被拒绝。</p></li>
</ul>


<h3>14.人身攻击</h3>

<ul>
<li><p>14.1 涉及诽谤、人身攻击性质以及内容狭隘卑鄙的应用软件或者打击特定个人或组织的应用软件将会被拒绝。</p></li>
<li><p>14.2 职业政治讽刺家和幽默作家不受这一条款约束。(开门，查水表)</p></li>
<li><p>14.3 展示用户创作内容(UGC)的应用程序必须提供一个过滤不良资讯的方法，一个用户可以标记侵犯性内容的机制，以及可以阻止辱骂用户的能力。</p></li>
<li><p>15.暴力(此前传禁枪的消息并未在条款中明确指出)</p></li>
<li><p>15.1 应用程序中出现人或动物被杀、致残以及枪击、刺伤、拷打等受伤情形的真实画面将会被拒绝。</p></li>
<li><p>15.2 出现描绘暴力或虐待儿童等内容的应用程序将会被拒绝。</p></li>
<li><p>15.3 游戏中出现的”敌人”不可指向一个特定种族、文化、一个真实存在的政府、企业或者其他任何现实中的实体。</p></li>
<li><p>15.4 对武器进行真实描述以怂恿非法使用或滥用这些武器的应用程序将会被拒绝。</p></li>
<li><p>15.5 包含俄罗斯轮盘赌博内容的游戏将会被拒。</p></li>
<li><p>16.令人反感的内容</p></li>
<li><p>16.1 应用程序中出现过于令人反感或者低俗的内容将会被拒绝。</p></li>
<li><p>16.2 在设计上激怒用户或令人感到厌恶的应用程序将会被拒绝。</p></li>
</ul>


<h3>17.隐私</h3>

<ul>
<li><p>17.1 在未经用户事先许可，或未告知用户如何使用信息以及在何处使用信息的情况下，应用程序不能传输用户数据。</p></li>
<li><p>17.2 要求用户共享电子邮箱地址和出生日期等私人信息才可使用其功能的应用程序将会被拒绝。</p></li>
<li><p>17.3 仅出于遵守适用的儿童隐私法规的目的，应用程序可以要求用户的出生日期(或者使用其他年龄评级机制)，但是必须包括一些有用的功能或者娱乐价值，不管用户年龄大小。</p></li>
<li><p>17.4 收集、传输以及分享未成年用户个人信息(比如名字、地址、邮件、位置、照片、视频、绘画、聊天信息以及其他个人数据，或者与以上所述相关的永久性标示符)的应用程序必须遵守应用儿童隐私法规，并且必须包含隐私条款。</p></li>
<li><p>17.5 包含账号注册或者访问用户现有账号的应用程序必须包含隐私策略，否则将会被拒绝。</p></li>
</ul>


<h3>18.色情</h3>

<ul>
<li><p>18.1 含有色情素材，也就是《韦氏词典》中定义的”旨在激发情欲，对性器官或性行为的明确描述或展示，而无关美学或情绪感受”的程序将会被拒绝。</p></li>
<li><p>18.2 包含用户频繁提供的色情内容的应用程序(比如以前的“Chat Roulette”程序)将会被拒绝。</p></li>
</ul>


<h3>19.宗教，文化与种族</h3>

<ul>
<li><p>19.1 涉及宗教、文化或种族群体的引用或评论包含诽谤性、攻击性或狭隘内容，或会使特定群体遭受伤害或暴力的应用程序将会被拒绝。</p></li>
<li><p>19.2 程序可以包含或引用宗教经文，程序所提供的引用或翻译必须准确且不会引起误导。评论应该有教育意义，可以令人开阔眼界，而不应有煽动性。</p></li>
</ul>


<h3>20. 竞赛、赌博、彩票以及抽奖</h3>

<ul>
<li><p>20.1 彩票抽奖和竞赛必须由应用程序的开发者或者app所属公司发起。</p></li>
<li><p>20.2 应用程序必须展示彩票抽奖和竞赛的正式规则，并声明苹果不是发起者，也没有以任何方式参与活动。</p></li>
<li><p>20.3 开发者运营一款具有抽奖性质的应用必须经过法律允许，并且抽奖应用必须具备以下特征：报酬、运气以及奖品。</p></li>
<li><p>20.4 允许用户在应用中直接购买彩票或彩券的应用将会被拒。</p></li>
<li><p>20.5 提供真钱游戏(比如体育博彩、扑克牌、赌场游戏、赛马以及彩票)的应用程序必须有应用程序适用地区当地必要的许可和允许，必须限制在这些区域，必须可以从App Store免费下载。</p></li>
<li><p>20.6 使用IAP购买信誉或者货币，且结合真钱游戏的应用将会被拒绝。</p></li>
</ul>


<h3>21.慈善与援助</h3>

<ul>
<li><p>21.1 包含可以向已认证的慈善组织捐赠功能的应用程序必须是免费的。</p></li>
<li><p>21.2 捐赠款项的募集必须通过Safari浏览器访问web页面或是手机短消息完成。</p></li>
</ul>


<h3>22.法律要件</h3>

<ul>
<li><p>22.1 应用程序必须遵守所有发布地区当地法律，开发者有义务了解并遵守所有当地法律。</p></li>
<li><p>22.2 包含虚假，欺诈或误导性陈述的程序将会被拒绝。</p></li>
<li><p>22.3 任何用于招徕、促进或鼓励犯罪或明显鲁莽行为的应用程序将会被拒绝。</p></li>
<li><p>22.4 支持非法文件共享的程序将会被拒绝。</p></li>
<li><p>22.5 被设计用以非法赌博工具的应用程序(包括点算牌)将会被拒绝。</p></li>
<li><p>22.6 具有匿名或恶作剧拨打电话或发送类似短信/彩信功能的程序将会被拒绝。</p></li>
<li><p>22.7 任何开发暗中收集用户密码或用户私人数据程序的开发者将会从iOS开发者计划中除名。</p></li>
<li><p>22.8 包含非执法机构发布的DUI检查点信息，或者怂恿/协助酒后驾车的应用将会被拒绝。</p></li>
<li><p>22.9 计算药剂用量的应用程序必须由药品制造商或者认可机构发布，比如医院、保险公司以及高校。</p></li>
<li><p>22.10 在未授权的情况下使用iTunes音乐预览的应用程序将会被拒绝。</p></li>
</ul>


<h3>23. Passbook</h3>

<ul>
<li><p>23.1 Passbook Passes可被用来支付或者接收支付，传递商业信息或者提供验证(比如电影票、飞机票、优惠券以及其他)，但把Passbook Passes用于其他用途的应用程序可能会遭到拒绝，并且会被撤销Passbook证书。</p></li>
<li><p>23.2 Passes必须包含有效的pass发行人有效的联系资料，否则app将会被拒绝，并且Passbook证书也会被取消。</p></li>
<li><p>23.3 Passes必须经过实体签名，并基于其名字、商标或者品牌进行分发，否则应用程序将会被拒绝，而Passbook证书也可能会被撤销。</p></li>
</ul>


<h3>24.儿童类别</h3>

<ul>
<li><p>24.1 儿童类别中的应用程序必须包含隐私政策，必须遵守适用的儿童隐私法规。</p></li>
<li><p>24.2 儿童类别中的应用程序不允许包括行为广告(比如app内部基于用户行动的服务广告)，任何在应用程序中展示的上下文广告必须适合儿童。</p></li>
<li><p>24.3 儿童类别中的应用程序必须得到家长许可或使用parental gate才能链接至应用程序外部或进行交易。</p></li>
<li><p>24.4 儿童类别中的应用程序必须标明”5岁以下，6-8岁或者9-11岁”。</p></li>
</ul>


<h3>25.扩展</h3>

<ul>
<li><p>25.1 包含扩展的应用程序必须遵照App Extension Programming Guide要求。</p></li>
<li><p>25.2 包含扩展的应用程序必须提供某些功能(辅助屏幕，附加设置)，否则将会被拒绝。</p></li>
<li><p>25.3 如果扩展的视图中包含营销推广、广告或者IAP内容，那么包含该扩展的应用将会被拒绝。</p></li>
<li><p>25.4 键盘扩展必须提供一个切换至下个键盘的方法。</p></li>
<li><p>25.5 键盘扩展必须具有离线访问功能，否则将会被拒绝。</p></li>
<li><p>25.6 键盘扩展必须提供和App Extension Programming Guide描述一致的数字和十进键盘类型，否则将会被拒绝。</p></li>
<li><p>25.7 提供键盘扩展的应用必须拥有基本的功能分类和隐私政策，否则将会被拒绝。</p></li>
<li><p>25.8 提供键盘扩展的应用程序只允许收集用户活动以增强键盘扩展在iOS设备上的功能，否则将会被拒绝。</p></li>
</ul>


<h3>26.HomeKit</h3>

<ul>
<li><p>26.1 使用HomeKit框架的应用程序必须有提供家庭自动化服务的主要目的。</p></li>
<li><p>26.2 使用HomeKit框架的应用程序必须在营销文本中说明用途，同时必须提供隐私政策，否则将会被拒绝。</p></li>
<li><p>26.3 应用程序不允许将从HomeKit API收集的数据用于广告宣传或者其他基于使用的数据挖掘。</p></li>
<li><p>26.4 出于其他目的使用从HomeKit API收集的数据，而不是用于提高用户体验或者家庭自动化功能中硬件/软件性能，这类应用将会被拒绝。</p></li>
</ul>


<h3>27.HealthKit</h3>

<ul>
<li><p>27.1 使用HealthKit或者ResearchKit框架(出于健康目的用于进行人体生物学研究的框架)的应用程序，必须遵守其所有适用区域的法律，以及iOS Developer Program License Agreement中的3.3.28和3.39条款。(增加了对于ResearchKit框架的支持)</p></li>
<li><p>27.2 将虚假或者错误的数据写入HealthKit的应用程序将会被拒绝。</p></li>
<li><p>27.3 使用HealthKit框架的应用程序在iCloud中储存用户健康信息将会被拒绝。</p></li>
<li><p>27.4 应用程序不允许将通过HealthKit API收集的用户数据用作广告宣传或者基于使用的数据挖掘目的，除了改善健康、医疗、健康管理以及医学研究目的。</p></li>
<li><p>27.5 未经用户许可与第三方分享通过HealthKit API获得的用户数据的应用程序将会被拒绝。</p></li>
<li><p>27.6 使用HealthKit框架的应用程序必须在营销文本中说明集成了Health app，同时必须在app用户界面清楚阐释HealthKit的功能。</p></li>
<li><p>27.7 使用HealthKit框架的应用程序必须提供隐私政策，否则将会被拒绝。</p></li>
<li><p>27.8 提供诊断、治疗建议，或者控制诊断疾病的硬件，或者治疗疾病的应用程序，若没有根据要求提供书面的监管审批，将会被拒绝。</p></li>
<li><p>27.9 收集人体生物学研究相关数据的应用程序必须要获得参与者的许可，对于未成年人，应用程序要得到其父母或者监护人的许可。许可内容必须包括：(a)研究的性质、目的以及持续性;(b)参与流程、风险以及受益(福利);&copy;信息的机密性和数据处理(包括与任何与第三方的共享);(d)参与者问题切入点;(e)取消方法(新增)</p></li>
</ul>


<h3>28.TestFlight</h3>

<ul>
<li><p>28.1 应用程序仅能使用TestFlight对以公开发布为目的的应用进行beta版测试，且必须遵守完整的App Review Guidelines。</p></li>
<li><p>28.2 当版本中包含的内容或功能有重大变化时，使用TestFlight的应用程序必须提交审核。</p></li>
<li><p>28.3 使用TestFlight的应用程序不允许分发给测试者，以作为任何形式的补偿。</p></li>
</ul>


<h3>29. Apple Pay</h3>

<ul>
<li><p>29.1 使用Apple Pay的应用程序必须在出售任何商品或者服务之前为用户提供所有材料的购买信息，否则将会被拒绝。使用Apple Pay进行定期付款的应用程序必须提供最低限度续费期限，付费将持续直至被取消，每个阶段所付款额，费用付款归属，以及如何取消等。(增加了对于定期付款的规定)</p></li>
<li><p>29.2 使用Apple Pay的应用程序必须正确使用Apple Pay Human Interface Guidelines中的Apple Pay标识和用户界面元素，否则将会被拒绝。</p></li>
<li><p>29.3 使用Apple Pay作为购买机制的应用程序所提供的商品或服务不能触犯任何交付地范围内的法律，也不能用作任何非法目的。</p></li>
<li><p>29.4 使用Apple Pay的应用程序必须提供隐私政策，否则将会被拒绝。</p></li>
<li><p>29.5 只有为了促进或提高商品和服务的交付，或者依照法律要件，使用Apple Pay的应用程序才能与第三方分享通过Apple Pay获得的数据。</p></li>
</ul>

</div>
  
  




| <a href="/blog/2013/10/17/pingguoshenhe/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/10/01/ruanjianceshi/">软件测试技术</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><p>一：分类</p>

<p><img src="/images/ruanjianceshi001.png" title="Caption" ></p>

<p>二：方式</p>

<p>代码:(不建议白盒)</p>

<p><img src="/images/ruanjianceshi002.png" title="Caption" ><br/>
接口、协议</p>

<p><img src="/images/ruanjianceshi003.png" title="Caption" ><br/>
界面</p>

<p><img src="/images/ruanjianceshi004.png" title="Caption" ></p>

<p>三：测试步骤</p>

<p><img src="/images/ruanjianceshi005.png" title="Caption" ></p>

<p>四：测试驱动开发（TDD）</p>

<p><img src="/images/ruanjianceshi006.png" title="Caption" ></p>
</div>
  
  




| <a href="/blog/2013/10/01/ruanjianceshi/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/09/25/changjianshejimoshi/">常见设计模式总结</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><p>ios开发学习中，经常弄不清楚ios的开发模式，今天我们就来进行简单的总结和探讨~</p>

<h3>（一）代理模式</h3>

<ul>
<li>应用场景：当一个类的某些功能需要由别的类来实现，但是又不确定具体会是哪个类实现。</li>
<li>优势：解耦合</li>
<li>敏捷原则：开放-封闭原则</li>
<li>实例：tableview的 数据源delegate，通过和protocol的配合，完成委托诉求。
列表row个数delegate
自定义的delegate</li>
</ul>


<h3>（二）观察者模式(通知)</h3>

<ul>
<li>应用场景：一般为model层对，controller和view进行的通知方式，不关心谁去接收，只负责发布信息。</li>
<li>优势：解耦合</li>
<li>敏捷原则：接口隔离原则，开放-封闭原则</li>
<li>实例：Notification通知中心，注册通知中心，任何位置可以发送消息，注册观察者的对象可以接收。
kvo，键值对改变通知的观察者，平时基本没用过。</li>
</ul>


<h3>（三）MVC模式</h3>

<ul>
<li>应用场景：是一中非常古老的设计模式，通过数据模型，控制器逻辑，视图展示将应用程序进行逻辑划分。</li>
<li>优势：使系统，层次清晰，职责分明，易于维护</li>
<li>敏捷原则：对扩展开放-对修改封闭</li>
<li>实例：model-即数据模型，view-视图展示，controller进行UI展现和数据交互的逻辑控制。</li>
</ul>


<h3>（四）单例模式</h3>

<ul>
<li>应用场景：确保程序运行期某个类，只有一份实例，用于进行资源共享控制。</li>
<li>优势：使用简单，延时求值，易于跨模块</li>
<li>敏捷原则：单一职责原则</li>
<li>实例：[UIApplication sharedApplication]。</li>
<li>注意事项：确保使用者只能通过 getInstance方法才能获得，单例类的唯一实例。
java，C++中使其没有公有构造函数，私有化并覆盖其构造函数。
object c中，重写allocWithZone方法，保证即使用户用 alloc方法直接创建单例类的实例，
返回的也只是此单例类的唯一静态变量。</li>
</ul>


<h3>（五）策略模式</h3>

<ul>
<li>应用场景：定义算法族，封装起来，使他们之间可以相互替换。</li>
<li>优势：使算法的变化独立于使用算法的用户</li>
<li>敏捷原则：接口隔离原则；多用组合，少用继承；针对接口编程，而非实现。</li>
<li>实例：排序算法，NSArray的sortedArrayUsingSelector；经典的鸭子会叫，会飞案例。</li>
<li>注意事项：

<ul>
<li>1，剥离类中易于变化的行为，通过组合的方式嵌入抽象基类</li>
<li>2，变化的行为抽象基类为，所有可变变化的父类</li>
<li>3，用户类的最终实例，通过注入行为实例的方式，设定易变行为</li>
</ul>
</li>
</ul>


<p>防止了继承行为方式，导致无关行为污染子类。完成了策略封装和可替换性。</p>

<h3>（六）工厂模式</h3>

<ul>
<li>应用场景：工厂方式创建类的实例，多与proxy模式配合，创建可替换代理类。</li>
<li>优势：易于替换，面向抽象编程，application只与抽象工厂和易变类的共性抽象类发生调用关系。</li>
<li>敏捷原则：DIP依赖倒置原则</li>
<li>实例：项目部署环境中依赖多个不同类型的数据库时，需要使用工厂配合proxy完成易用性替换</li>
<li>注意事项：项目初期，软件结构和需求都没有稳定下来时，不建议使用此模式，因为其劣势也很明显，
增 加了代码的复杂度，增加了调用层次，增加了内存负担。所以要注意防止模式的滥用。</li>
</ul>

</div>
  
  




| <a href="/blog/2013/09/25/changjianshejimoshi/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/09/10/xitong-xianguanjiance/">系统相关检测</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><p>iOS系统版本的不断升级的前提，伴随着用户使用设备的安全性提升，iOS系统对于App需要使用的硬件限制也越来越严格，App处理稍有不妥，轻则造成功能不可用用户还不知道，重则会造成App Crash。</p>

<p>当用户在App启动时，看到弹出来的一条条“XXX 请求访问您的位置” “XXX 请求访问您的通讯录” “XXX 请求访问您的日历” “XXX 请求访问您的摄像头” 等一系列消息时，用户觉得不耐烦的同时，也会由于一时的安全考虑而把相应的功能给屏蔽掉，这还只是开始，当用户真正在使用对应功能的时候，就会出现一连续的奇怪现象，比如数据显示异常：明明通讯录里面有信息，却总是加载不出数据;有的甚至是直接Crash。</p>

<p>下面，笔者将会综合性地把上述硬件的授权检测，一一地详细列出，并给出相关示例代码：</p>

<p>1、定位服务</p>

<p>相关框架</p>

<p>检测方法</p>

<pre><code>+ (CLAuthorizationStatus)authorizationStatus
</code></pre>

<p>相关返回参数</p>

<pre><code>//用户尚未做出选择
kCLAuthorizationStatusNotDetermined = 0,

// 未授权，且用户无法更新，如家长控制情况下
kCLAuthorizationStatusRestricted,

// 用户拒绝App使用
kCLAuthorizationStatusDenied,

// 总是使用
kCLAuthorizationStatusAuthorizedAlways NS_ENUM_AVAILABLE(NA, 8_0),

// 按需使用
kCLAuthorizationStatusAuthorizedWhenInUse NS_ENUM_AVAILABLE(NA, 8_0),

// 已授权
kCLAuthorizationStatusAuthorized
</code></pre>

<p>参考代码</p>

<pre><code>__block void (^checkLocationAuth)(void) = ^{
    CLAuthorizationStatus authStatus = [CLLocationManager  authorizationStatus];

    if (CLAuthorizationStatusAuthorized == authStatus) {
        //授权成功，执行后续操作
    }else {
        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
            checkLocationAuth();
        });
    }
};
checkLocationAuth();
</code></pre>

<p>2、通讯录</p>

<p>检测方法</p>

<pre><code>ABAuthorizationStatus ABAddressBookGetAuthorizationStatus(void)
</code></pre>

<p>授权状态</p>

<pre><code>kABAuthorizationStatusNotDetermined = 0,    // 未进行授权选择
kABAuthorizationStatusRestricted,           // 未授权，且用户无法更新，如家长控制情况下
kABAuthorizationStatusDenied,               // 用户拒绝App使用
kABAuthorizationStatusAuthorized            // 已授权，可使用
</code></pre>

<p>参考代码</p>

<pre><code>__block void (^checkAddressBookAuth)(void) = ^{
    ABAuthorizationStatus authStatus = ABAddressBookGetAuthorizationStatus();

    if (kABAuthorizationStatusAuthorized == authStatus) {
        //授权成功，执行后续操作
    }else {
        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
            checkAddressBookAuth();
        });
    }
};
checkAddressBookAuth();
</code></pre>

<p>3、日历/提醒事项授权</p>

<p>检测方法</p>

<pre><code>+ (EKAuthorizationStatus)authorizationStatusForEntityType:(EKEntityType)entityType
</code></pre>

<p>参数类型</p>

<pre><code>EKEntityTypeEvent,  //事件

EKEntityTypeReminder//提醒
</code></pre>

<p>授权状态</p>

<pre><code>EKAuthorizationStatusNotDetermined = 0,// 未进行授权选择

EKAuthorizationStatusRestricted,　　　　// 未授权，且用户无法更新，如家长控制情况下

EKAuthorizationStatusDenied,　　　　　　 // 用户拒绝App使用

EKAuthorizationStatusAuthorized,　　　　// 已授权，可使用
</code></pre>

<p>参考代码</p>

<pre><code>__block void (^checkCalanderAuth)(void) = ^{
    EKAuthorizationStatus authStatus = [EKAuthorizationStatus authorizationStatusForEntityType:EKEntityTypeEvent];

    if (EKAuthorizationStatusAuthorized == authStatus) {
        //授权成功，执行后续操作
    }else {
        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
            checkCalanderAuth();
        });
    }
};
checkCalanderAuth();
</code></pre>

<p>4、照片库授权</p>

<p>检测方法</p>

<pre><code>+ (ALAuthorizationStatus)authorizationStatus;
</code></pre>

<p>授权状态</p>

<pre><code>ALAuthorizationStatusNotDetermined = 0,// 未进行授权选择

ALAuthorizationStatusRestricted,　　　　// 未授权，且用户无法更新，如家长控制情况下

ALAuthorizationStatusDenied,　　　　　　 // 用户拒绝App使用

ALAuthorizationStatusAuthorized,　　　　// 已授权，可使用
</code></pre>

<p>参考代码</p>

<pre><code>__block void (^checkAssetLibraryAuth)(void) = ^{
    ALAuthorizationStatus authStatus = [ALAuthorizationStatus authorizationStatus];

    if (ALAuthorizationStatusAuthorized == authStatus) {
        //授权成功，执行后续操作
    }else {
        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
            checkAssetLibraryAuth();
        });
    }
};
checkAssetLibraryAuth();
</code></pre>

<p>5、蓝牙授权状态检测</p>

<p>检测方法</p>

<pre><code>+ (CBPeripheralManagerAuthorizationStatus)authorizationStatus;
</code></pre>

<p>授权状态</p>

<pre><code>CBPeripheralManagerAuthorizationStatusNotDetermined = 0,// 未进行授权选择

CBPeripheralManagerAuthorizationStatusRestricted,　　　　// 未授权，且用户无法更新，如家长控制情况下

CBPeripheralManagerAuthorizationStatusDenied,　　　　　　 // 用户拒绝App使用

CBPeripheralManagerAuthorizationStatusAuthorized,　　　　// 已授权，可使用
</code></pre>

<p>参考代码</p>

<pre><code>__block void (^checkPeripheralAuth)(void) = ^{
    CBPeripheralManagerAuthorizationStatus authStatus = [CBPeripheralManagerAuthorizationStatus authorizationStatus];

    if (CBPeripheralManagerAuthorizationStatusAuthorized == authStatus) {
        //授权成功，执行后续操作
    }else {
        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
            checkPeripheralAuth();
        });
    }
};
checkPeripheralAuth();
</code></pre>

<p>6、摄像头授权状态检测</p>

<p>检测方法</p>

<pre><code>+ (AVAuthorizationStatus)authorizationStatusForMediaType:(NSString *)mediaType;
</code></pre>

<p>授权状态</p>

<pre><code>AVAuthorizationStatusNotDetermined = 0,// 未进行授权选择

AVAuthorizationStatusRestricted,　　　　// 未授权，且用户无法更新，如家长控制情况下

AVAuthorizationStatusDenied,　　　　　　 // 用户拒绝App使用

AVAuthorizationStatusAuthorized,　　　　// 已授权，可使用
</code></pre>

<p>参考代码</p>

<pre><code>__block void (^checkCameraAuth)(void) = ^{
    AVAuthorizationStatus authStatus = [AVAuthorizationStatus authorizationStatusForMediaType:AVMediaTypeVideo];

    if (AVAuthorizationStatusAuthorized == authStatus) {
        //授权成功，执行后续操作
    }else {
        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
            checkCameraAuth();
        });
    }
};
checkCameraAuth();
</code></pre>

<p>7、麦克风授权状态检测</p>

<p>检测方法</p>

<pre><code>- (AVAudioSessionRecordPermission)recordPermission;
</code></pre>

<p>授权状态</p>

<pre><code>AVAudioSessionRecordPermissionUndetermined,　　　　// 用户尚未被请求许可。

AVAudioSessionRecordPermissionDenied,　　　　　　 // 用户已被要求并已拒绝许可。

AVAudioSessionRecordPermissionGranted,　　　　// 用户已被要求并已授予权限。
</code></pre>

<p>参考代码</p>

<pre><code>__block void (^checkRecordPermission)(void) = ^{
    AVAudioSessionRecordPermission authStatus = [[AVAudioSession sharedInstance] recordPermission];

    if (AVAudioSessionRecordPermissionGranted == authStatus) {
        //授权成功，执行后续操作
    }else {
        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
            checkRecordPermission();
        });
    }
};
checkRecordPermission();
</code></pre>
</div>
  
  




| <a href="/blog/2013/09/10/xitong-xianguanjiance/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/08/18/gif-jibenshiyong/">教你怎么显示gif图片</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><h3>方法一：第三方</h3>

<pre><code>// 网络图片
//  NSData *urlData = [NSData dataWithContentsOfURL:[NSURL URLWithString:@"http://www.chinagif.com/gif/part/boy/0045.gif"]]; 

// 本地图片 
NSData *localData = [NSData dataWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@"run" ofType:@"gif"]]; 

GifView *dataView = [[GifView alloc] initWithFrame:CGRectMake(0, 0, 100, 100) data:localData];  
[self.view addSubview:dataView];
</code></pre>

<h6>或者你也可以这样，直接加载路径</h6>

<pre><code>GifView *pathView =[[GifView alloc] initWithFrame:CGRectMake(100, 0, 100, 100) filePath:[[NSBundle mainBundle] pathForResource:@"run" ofType:@"gif"]];
[self.view addSubview:pathView];
</code></pre>

<h3>方法二：webView</h3>

<pre><code>NSString *path = [[NSBundle mainBundle] pathForResource:@"run" ofType:@"gif"];
NSData *gifData = [NSData dataWithContentsOfFile:path];
UIWebView *webView = [[UIWebView alloc] initWithFrame:CGRectMake(0, 120, 100, 100)];
webView.backgroundColor = [UIColor redColor];
webView.scalesPageToFit = YES;
[webView loadData:gifData MIMEType:@"image/gif" textEncodingName:nil baseURL:nil];
[self.view addSubview:webView];
[webView release];
</code></pre>

<h3>方法三：animationView</h3>

<pre><code>UIImageView *gifImageView = [[UIImageView alloc] initWithFrame:CGRectMake(0, 240, 100, 100)];
NSArray *gifArray = [NSArray arrayWithObjects:[UIImage imageNamed:@"1"],
                     [UIImage imageNamed:@"2"],
                     [UIImage imageNamed:@"3"],
                     [UIImage imageNamed:@"4"],
                     [UIImage imageNamed:@"5"],
                     [UIImage imageNamed:@"6"],
                     [UIImage imageNamed:@"7"],
                     [UIImage imageNamed:@"8"],
                     [UIImage imageNamed:@"9"],
                     [UIImage imageNamed:@"10"],
                     [UIImage imageNamed:@"11"],
                     [UIImage imageNamed:@"12"],
                     [UIImage imageNamed:@"13"],
                     [UIImage imageNamed:@"14"],
                     [UIImage imageNamed:@"15"],
                     [UIImage imageNamed:@"16"],
                     [UIImage imageNamed:@"17"],
                     [UIImage imageNamed:@"18"],
                     [UIImage imageNamed:@"19"],
                     [UIImage imageNamed:@"20"],
                     [UIImage imageNamed:@"21"],
                     [UIImage imageNamed:@"22"],nil];
gifImageView.animationImages = gifArray; //动画图片数组
gifImageView.animationDuration = 5; //执行一次完整动画所需的时长
gifImageView.animationRepeatCount = 999;  //动画重复次数
[gifImageView startAnimating];
[self.view addSubview:gifImageView];
[gifImageView release];
</code></pre>
</div>
  
  




| <a href="/blog/2013/08/18/gif-jibenshiyong/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/08/18/collectionview/">玩转CollectionView</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><p>实现步骤</p>

<h3>一、新建两个类</h3>

<p>1.继承自UIScrollView的子类，比如iCocosWaterflowView</p>

<ul>
<li>瀑布流显示控件，用来显示所有的瀑布流数据</li>
</ul>


<p>2.继承自UIView的子类，比如iCocosWaterflowViewCell</p>

<ul>
<li>代表着瀑布流数据中的一个单元（一个格子）</li>
</ul>


<p>3.总结</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2013/08/18/collectionview/">阅读全文😘</a>
    </footer>
  




| <a href="/blog/2013/08/18/collectionview/#comments">更多评论</a>

    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/10">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/8">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
    <h1>文章分类</h1>
    <ul id="categories">
        <li class='category'><a href='/blog/categories/advanced/'>advanced (22)</a></li>
<li class='category'><a href='/blog/categories/algorithm/'>algorithm (1)</a></li>
<li class='category'><a href='/blog/categories/background/'>background (1)</a></li>
<li class='category'><a href='/blog/categories/bottom/'>bottom (5)</a></li>
<li class='category'><a href='/blog/categories/developer/'>developer (7)</a></li>
<li class='category'><a href='/blog/categories/fore-end/'>fore-end (2)</a></li>
<li class='category'><a href='/blog/categories/interview/'>interview (1)</a></li>
<li class='category'><a href='/blog/categories/necessary/'>necessary (5)</a></li>
<li class='category'><a href='/blog/categories/newfeatures/'>newfeatures (5)</a></li>
<li class='category'><a href='/blog/categories/performance/'>performance (8)</a></li>
<li class='category'><a href='/blog/categories/projects/'>projects (27)</a></li>
<li class='category'><a href='/blog/categories/summary/'>summary (8)</a></li>
<li class='category'><a href='/blog/categories/tools/'>tools (5)</a></li>
<li class='category'><a href='/blog/categories/watchos2/'>watchos2 (1)</a></li>

    </ul>
</section><section>
  <h1>最新文章</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/12/30/zhong-liang-ji/">重量级-MVC-MVVM-DC</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/12/30/ni-huan-zai-deng-shi-yao-%3F/">你还在等什么？</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/12/28/git-plus-souretreeshi-zhan/">Git+SoureTree实战</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/12/25/ios9-corespotlight/">iOS9-CoreSpotlight</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/12/24/ios9xin-te-xing-wkwebview/">iOS9-WKWebView+SFSafariViewController</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/al1020119">@al1020119</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'al1020119',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>




<section>
<h1>扫一扫<abbr title="The word '扫一扫' is a registered trademark of DENSO WAVE INCORPORATED. It applies only for the word '扫一扫', not for image.">&trade;</abbr></h1>
<a href="http://al1020119.github.io/posts/9/index.html"><img src="http://chart.apis.google.com/chart?chs=150x150&cht=qr&chld=|0&chco=165B94&chl=http://al1020119.github.io/posts/9/index.html" alt="post-qrcode"></a></section>
<section>
    <h1>访客统计</h1>
    <br/>
    <a href="http://s07.flagcounter.com/more/2SH"><img src="http://s07.flagcounter.com/count/2SH/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_1/flags_0/" alt="Flag Counter" border="0"></a>
</section><section>
    <h1>新浪微博</h1>
    <ul id="weibo">
        <li>
            
            <!-- 在此插入获得的微博秀代码 -->
            <iframe width="100%" height="550" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=550&fansRow=2&ptype=1&speed=0&skin=1&isTitle=1&noborder=1&isWeibo=1&isFans=1&uid=3288975567&verifier=20ffcedd&dpc=1"></iframe>
            
        </li>
    </ul>
</section>
  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><!--<p>-->
<!--  Copyright &copy; 2015 - iCocos --->
<!--<span class="credit">Preview in <a href="http://al1020119.github.io">[曹#黎]</a></span>-->
<!--</p>-->


<p>
    Copyright &copy; <span>2013</span> - iCocos -
    <span class="credit">Preview in <a href="http://al1020119.github.io">[曹#黎]</a></span>
</p>

</footer>
  






<!--
--->



</body>
</html>
