
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>iOS梦工厂</title>
  <meta name="author" content="iCocos">

  
  <meta name="description" content="摘要
序列化和反序列化几乎是工程师们每天都要面对的事情，但是要精确掌握这两个概念并不容易：一方面，它们往往作为框架的一部分出现而湮没在框架之中；另一方面，它们会以其他更容易理解的概念出现，例如加密、持久化。然而，序列化和反序列化的选型却是系统设计或重构一个重要的环节，在分布式、 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://al1020119.github.io/posts/3/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="iOS梦工厂" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//libs.baidu.com/jquery/1.7.2/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <script>
function addBlankTargetForLinks () {
    $('a[href^="http"]').each(function(){
                              $(this).attr('target', '_blank');
                              });
}
$(document).bind('DOMNodeInserted', function(event) {
             addBlankTargetForLinks();
             });
</script>
  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">iOS梦工厂</a></h1>
  
    <h2>不战胜自己，何以改变未来！</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="al1020119.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">首页</a></li>
  <li><a href="/blog/archives">归档</a></li>
  <li><a href="/icocos">iCocos</a></li>
  <li><a href="/other">其他</a></li>
  <li><a href="/about">关于</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/12/04/xu-lie-hua-and-fan-xu-lie-hua-shen-jiu/">序列化&amp;反序列化深究</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><blockquote><p>摘要
序列化和反序列化几乎是工程师们每天都要面对的事情，但是要精确掌握这两个概念并不容易：一方面，它们往往作为框架的一部分出现而湮没在框架之中；另一方面，它们会以其他更容易理解的概念出现，例如加密、持久化。然而，序列化和反序列化的选型却是系统设计或重构一个重要的环节，在分布式、大数据量系统设计里面更为显著。恰当的序列化协议不仅可以提高系统的通用性、强健性、安全性、优化系统性能，而且会让系统更加易于调试、便于扩展。本文从多个角度去分析和讲解“序列化和反序列化”，并对比了当前流行的几种序列化协议，期望对读者做序列化选型有所帮助。</p></blockquote>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2015/12/04/xu-lie-hua-and-fan-xu-lie-hua-shen-jiu/">阅读全文😘</a>
    </footer>
  




| <a href="/blog/2015/12/04/xu-lie-hua-and-fan-xu-lie-hua-shen-jiu/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/12/03/you-xiu-cheng-xu-yuan-shi-zen-yao-xie-zhu-shi-de/">够逼格的注释习惯</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><p>够逼格的注释习惯总结</p>

<p>首先关于注意这里就不说什么VVDocument了，来点新鲜的！</p>

<h6>也许你使用过#warning 警告提示</h6>

<h6>也许你也使用过#pragma marks。</h6>

<p>但是你见过或者使用过下面这个吗？</p>

<pre><code>Comments containing:
MARK:
TODO:
FIXME:
!!!:
???:
</code></pre>

<p>没有，那么你就快速的看看下面的内容，非常好用，也非常简单，不过具体使用看个人</p>

<p> 首先说一下三个最常用的：</p>

<ul>
<li>1、TODO</li>
</ul>


<p> 等待实现的功能</p>

<ul>
<li>2、FIXME</li>
</ul>


<p> 需要修正的功能</p>

<ul>
<li>3、！！！</li>
</ul>


<p> 需要改进的功能</p>

<p>具体使用</p>

<pre><code>// FIXME:sss
/* FIXME: sss */


// MARK:sss
/* MARK:sss */


// !!!:sss
/* !!!: sss */


// ???:sss
/* ???: sss */


// TODO:sss
/* TODO: sss */


// Comments containing: sss
/* Comments containing: sss */
</code></pre>

<p>注意空格.</p>

<p> 最后你会发现下面的效果，虽然和#pragma marks没有什么区别，但是这就是装逼原因</p>

<p>关于最后一个/<em> Comments containing: sss </em>/，笔者还没照发对应的使用方法，如果你知道可以联系我哦！</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2015/12/03/you-xiu-cheng-xu-yuan-shi-zen-yao-xie-zhu-shi-de/">阅读全文😘</a>
    </footer>
  




| <a href="/blog/2015/12/03/you-xiu-cheng-xu-yuan-shi-zen-yao-xie-zhu-shi-de/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/12/02/xiao-chu-jing-gao/">消除警告</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><h6>前言：</h6>

<p>现在你维护的项目有多少警告？看着几百条警告觉得心里烦么？你真的觉得警告又不是错误可以完全不管么？ 如果你也被这些问题困惑，可以和我一起进行下面的操作。其实大部分的警告都是很好改的，把自己整个项目的警告撸一遍应该也就耗费半小时的时间，一次麻烦带来之后的清净这样不好么？</p>

<p>本文分为三个部分：</p>

<ul>
<li>1.简单粗暴的消除警告。</li>
<li>2.详细科学的消除警告。（包括警告收录）</li>
<li>3.添加警告。</li>
</ul>


<h4>一、简单粗暴的消除警告</h4>

<p>警告如果是自己项目中的还好直接改了，如果是第三方库，你改了之后，pod下作者更新一下又白改了，所以可以用这种简单粗暴的方法：直接让第三方库的警告不显示</p>

<p> 就是在podfile文件里面加上一行指令 。
inhibit_all_warnings!
如果某警告实在无法消除，但是又不想让他显示，可以加入预编译指令</p>

<p>比如我已经知道某行会报上面警告了，我就用这个宏把这几行包住，就不会报引号中-Wunused-variable的警告了</p>

<pre><code>#pragma clang diagnostic push
#pragma clang diagnostic ignored"-Wunused-variable" //这里是会报警告的代码

#pragma clang diagnostic pop
</code></pre>

<p>这个-Wunused-variable代表的意思就是 有的东西 你实例化了但是没有使用（同上面第几条）。 但是如何得到一个警告的标示符？</p>

<ol>
<li><p>如图选择一个警告，点击右键，reveal in log  就能看到右边有个方括号[]里面的东西就是 这个警告对应的标示符</p></li>
<li><p>如果希望整个项目中都忽略 某种很无聊的警告，就在项目中Build Setting里加上这个标示符，可以连着加的。</p></li>
<li><p>如果不想整个项目都忽略，只想个别文件忽略，那就找到个别文件加上此指令，这个操作应该使用率不高（一般都是全项目忽略），就不上图了。去Build Phases 里面的 Compile Sources里面改。</p></li>
</ol>


<h4>二、详细科学的消除警告</h4>

<p>其实笔者本意是想把一些第一眼看不懂比较坑的警告收录进来，但是后来发现那基本没几个需要些写了，所以就采用了全收录的方法，遇到的就记录下以后也会不断更新。 可以直接按command+F 在本页面搜索警告</p>

<pre><code>Unused variable 'replyURL'
</code></pre>

<h6>1.没有使用</h6>

<pre><code>Cannot find protocol definition for 'TencentSessionDelegate'
</code></pre>

<h6>2.这种明明都能运行还说我没有定义的警告，是因为你这个协议虽然定义了，但是你这个协议可能还遵守了XX协议，然后这个XX协议没有定义导致会报这种警告，所以遇到这种警告要往“父协议”找。 举个栗子，上面这行就是腾讯授权的库里面报的警告，</h6>

<pre><code>@protocol TencentSessionDelegate
此协议遵守了TencentApiInterfaceDelegate协议，在TencentOAuth.h类中#import "TencentApiInterface.h" 警告可破


Null passed to a callee that requires a non-null argument
</code></pre>

<h6>3.这个警告比较新，是xcode6.3开始 为了让OC也能有swift的？和！的功能，你在声明一个属性的时候加上 <strong>nullable（？可以为空）与</strong>nonnull（！不能为空） 如果放在@property里面的话不用写下划线</h6>

<pre><code>@property (nonatomic, copy, nonnull) NSString * tickets;
@property (nonatomic, copy) NSString * __nonnull tickets;
</code></pre>

<p>或者用宏NS_ASSUME_NONNULL_BEGIN和NS_ASSUME_NONNULL_END 包住多个属性全部具备nonnull，然后仅对需要nullable的改下就行，有点类似于f-no-objc-arc那种先整体给个路线在单独改个别文件的思想。 此警告就是某属性说好的不能为空，你又在某地方写了XX = nil 所以冲突了。</p>

<pre><code>Auto property synthesis will not synthesize property 'privateCacheDirectory'; it will be implemented by its superclass, use @dynamic to acknowledge intention
</code></pre>

<h6>4.他说你的父类实现了setget方法，但是如果你什么都不写，就会系统自动生成出最一般的setget方法，请用@dynamic 来承认父类实现的这个getset方法。</h6>

<pre><code>Unsupported Configuration: Scene is unreachable due to lack of entry points and does not have an identifier for runtime access via -instantiateViewControllerWithIdentifier:.
</code></pre>

<h6>5.一般是storyboard报的警告，简而言之就是你有的页面没有和箭头所指的控制器连起来，导致最终改页面可能无法显示。</h6>

<pre><code>Deprecated: Push segues are deprecated in iOS 8.0 and later
</code></pre>

<h6>6.iOS8之后呢，不要再用push拖线了，统一用show，他会自己根据你是否有导航栏来判断走push还是走modal</h6>

<pre><code>Unsupported Configuration: Plain Style unsupported in a Navigation Item
</code></pre>

<h6>7.导航栏的item 不支持用plain ，那就用Bordered呗。</h6>

<pre><code>The launch image set "LaunchImage" has 2 unassigned images.
The app icon set "AppIcon" has 2 unassigned images.
</code></pre>

<h6>8.几张图标还是启动图找不到自己的位置，可能是一次导入了全部尺寸图片，但是右边的设置只勾了iOS8的 那iOS7尺寸的图标就会报此警告。删掉，或者对照右边匹配。</h6>

<pre><code>'sizeWithFont:constrainedToSize:lineBreakMode:' is deprecated: first deprecated in iOS 7.0 - Use -boundingRectWithSize:options:attributes:context:
</code></pre>

<h6>9.方法废除，旧的方法sizeWithFontToSize在iOS7后就废除了取而代之是boundingRectWithSize方法</h6>

<pre><code>Undeclared selector 'historyAction'
</code></pre>

<h6>10.使用未声明的方法，一般出现在@selector() 括号里写了个不存在的方法或方法名写错了。</h6>

<pre><code>PerformSelector may cause a leak because its selector is unknown
</code></pre>

<h6>11.这个和上面类似就是直接把上面那个@SEL拿来用会报这个警告</h6>

<pre><code>'strongify' macro redefined
</code></pre>

<h6>12.这个宏声明重复,删一个吧</h6>

<pre><code>'UITextAttributeFont' is deprecated: first deprecated in iOS 7.0 - Use NSFontAttributeName
'UITextAttributeTextColor' is deprecated: first deprecated in iOS 7.0 - Use NSForegroundColorAttributeName
'UITextAttributeTextShadowColor' is deprecated: first deprecated in iOS 7.0 - Use NSShadowAttributeName with an NSShadow instance as the value
</code></pre>

<h6>13.方法废除,一般一起出现</h6>

<pre><code>Code will never be executed
</code></pre>

<h6>14.他说这代码永远也轮不到他执行，估计是有几行代码写在了return之后</h6>

<pre><code>Assigning to 'id' from incompatible type 'SXTabViewController *const __strong'
</code></pre>

<h6>15.一般出现在xxx.delegate = self ，应该在上面遵守协议</h6>

<pre><code>Format specifies type 'unsigned long' but the argument has type 'unsigned int'
</code></pre>

<h6>16.这个警告一般会出现在NSStringWithFormat里面 前面%d %lu 什么的和后面填进去的参数不匹配就报了警告</h6>

<pre><code>Values of type 'NSInteger' should not be used as format arguments; add an explicit cast to 'long' instead
</code></pre>

<h6>17.类似于上面，也是format里面前后写的不匹配</h6>

<pre><code>Method 'dealWithURL:andTitle:andKeyword:' in protocol 'SXPostAdDelegate' not implemented
</code></pre>

<h6>18.经典警告，遵守了协议，但是没有实现协议方法。 也可能你实现了只是又加了个参数或是你写的方法和协议方法名字有点轻微不同</h6>

<pre><code>Using integer absolute value function 'abs' when argument is of floating point type
</code></pre>

<h6>19.这个可以自动修正，就是说abs适用于整数绝对值，要是float取绝对值要用fabsf</h6>

<pre><code>Attribute Unavailable: Automatic Preferred Max Layout Width is not available on iOS versions prior to 8.0
</code></pre>

<h6>20.有的方法你用的太落后了，也有的方法你用的太超前了。 说这个最大宽度在iOS8之前的系统是要坑的</h6>

<pre><code>Too many personality routines for compact unwind to encode
</code></pre>

<h6>21.你可以在otherlink 中加入 -Wl,-no_compact_unwind 去掉该警告，根据苹果的解释，这个是由于某些地方 c/c++/oc/oc++混用会造成编译警告。一般没有什么伤害。</h6>

<pre><code>Property 'ssid' requires method 'ssid' to be defined - use @synthesize, @dynamic or provide a method implementation in this class implementation
</code></pre>

<h6>22.说这个ssid必须要定义个这个属性的getter方法，如果警告是setSsid就是setter方法， 用@synthesize和@dynamic 都行，一个是让编译器生成getter和setter，一个是自己生成，如果你有模型分发或kvc之类的，选@dynamic就行</h6>

<pre><code>Unknown escape sequence '\)'
</code></pre>

<h6>23.未知的转义序列。 一般有个斜杠再加个东西他都会以为是转义字符，一看\）不认识就报警告了，一般正则表达式容易报这种警告</h6>

<pre><code>Property 'LoginPort' not found on object of type 'LoginLvsTestTask *'; did you mean to access property loginPort?
</code></pre>

<h6>24.这种可以点击自动修复，是典型的大小写写错了，他提醒了一下。</h6>

<pre><code>Variable 'type' is used uninitialized whenever switch default is taken
</code></pre>

<h6>25.这是出现在switch语句中的警告， 一般可能是switch外面定义了个type但是并没有初始化（初始化操作都写在switch的各个分支里），然后在最后return type。 但是switch的有个分支没有对type初始化，他说如果你来到这个分支的话，那还没初始化就要被return。</h6>

<h5>三、添加警告</h5>

<h6>1.首先最常用的就是 普通警告，这也没什么好说的了</h6>

<pre><code>#warning TODO
</code></pre>

<h6>2.如果是自己写的文件或第三方库，有了新的接口，然后提示旧的接口废除的话需要在方法后加上宏NS_DEPRECATED_IOS和范围</h6>

<pre><code>- (void)addTapAction:(SEL)tapAction target:(id)target NS_DEPRECATED_IOS(2_0, 4_0);
</code></pre>

<h6>3.如果需要在此方法后加上带信息的警告则需要这么写</h6>

<pre><code>- (void)addTapAction:(SEL)tapAction target:(id)target __attribute((deprecated("这个接口会爆内存 不建议使用")));
</code></pre>

<p>显示的效果像这样：</p>
</div>
  
  




| <a href="/blog/2015/12/02/xiao-chu-jing-gao/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/12/01/zi-dian-zhuan-mo-xing-shen-jiu/">字典转模型深究</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><blockquote><p>引言：
在文字开始之前先介绍两个软件：</p></blockquote>

<h5>JSONExport</h5>

<p><img src="/images/zidianzhuanmoxin005.png" title="Caption" ></p>

<h5>JSON Accelerator</h5>

<p><img src="/images/zidianzhuanmoxin006.png" title="Caption" ></p>

<blockquote><p>关于模型类的两个神器，我也是刚接触不久，但是感觉非常有用，基本上可以节省你在模型类上的99%的时间。</p></blockquote>

<ul>
<li>如果你觉得自己对应本文后面的内容非常了解，那么请直接下载上面的软件试试。</li>
<li>如果你并不是很熟练，那么轻认真看完后面的内容，相信对你有好处，再去下载对应的软件。</li>
</ul>


<p>关于Plist转模型在iOS开发中是非常常见的，每开一一个项目或者实现一个功能都要用到它，所以今天就给大家讲讲Plist怎么转成模型数据，</p>

<blockquote><p>前提：必须有一个Plist文件或者通过一定的方式返回的plist数据</p></blockquote>

<h2>一：直接加载Plist数据</h2>

<p><img src="/images/zidianzhuanmoxin001.png" title="Caption" ></p>

<pre><code>定义一个数组属性 
@property (nonatomic, assign) NSArray *apps; 
</code></pre>

<h6>获取Plist文件</h6>

<pre><code>//懒加载plist文件，返回一个apps数据，后面直接使用旧可以
-(NSArray *)apps
{
    if (_apps == nil) {
        _apps = [NSArray arrayWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@"iCocos.plist" ofType:nil]];
    }
    return _apps;
}
</code></pre>

<h6>加载Plsit中的数据</h6>

<pre><code>    //取出数组中对应的数据放到一个字典里面
    NSDictionary *dic = self.apps[i];


    //创建一个UIImageView
    UIImageView *icon = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, iW, 50)];
    /**
     取出字典中的icon
    */
     icon.image = [UIImage imageNamed:dic[@"icon"]];

    [view addSubview:icon];



    //创建一个Label
    UILabel *l = [[UILabel alloc] initWithFrame:CGRectMake(0, CGRectGetMaxY(icon.frame), iW, 20)];
    /**
     取出字典中的label
     */
    l.text = dic[@"label"];

    [view addSubview:l];



    //创建一个按钮
    UIButton *btn = [[UIButton alloc] initWithFrame:CGRectMake(0, CGRectGetMaxY(l.frame), iW, 20)];
    /**
     取出字典中的btn
     */
    [btn setTitle:dic[@"btn"] forState:UIControlStateNormal];

    [view addSubview:btn];
</code></pre>

<h2>二：使用简单的模型加载Plist数据</h2>

<p><img src="/images/zidianzhuanmoxin002.png" title="Caption" ></p>

<pre><code> 1 //定义一个数组属性

  2 @property (nonatomic, assign) NSArray *apps; 
</code></pre>

<h6>在模型中定义模型对应的属性</h6>

<pre><code>@property (nonatomic, copy) NSString *icon;


@property (nonatomic, copy) NSString *label;


@property (nonatomic, copy) NSString *btn;
</code></pre>

<h6>模型方法</h6>

<pre><code>/**
 模型数据方法
 */
+(instancetype)messageWithDict:(NSDictionary *)dict;


-(instancetype)initWithDict:(NSDictionary *)dict;
</code></pre>

<h6>模型的实现文件</h6>

<pre><code>/**
 模型数据方法的实现
 */

+ (instancetype)messageWithDict:(NSDictionary *)dict
{
    return [[self alloc] initWithDict:dict];
}

- (instancetype)initWithDict:(NSDictionary *)dict
{
    if (self = [super init]) {
        [self setValuesForKeysWithDictionary:dict];
    }
    return self;
}
</code></pre>

<h6>实用模型加载Plist文件</h6>

<pre><code>/**
 模型数据的加载，返回arry以后我们就只要使用array就能使用这个模型类里面的数据也就是使用plist数据
 */
//懒加载plist文件，返回一个apps数据，后面直接使用旧可以
-(NSMutableArray *)apps
{
    if (_apps == nil) {
        NSArray *array = [NSArray arrayWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@"iCocos.plist" ofType:nil]];

        NSMutableArray *arrayApps = [NSMutableArray array];

        for (NSDictionary *dic in array) {
            appsModel *model = [[appsModel alloc] init];
            model.label = dic[@"label"];
            model.btn = dic[@"btn"];
            model.icon = dic[@"icon"];

            [arrayApps addObject:model];
        }
        _apps = arrayApps;
    }
    return _apps;
}
</code></pre>

<h6>加载模型中对应的plist数据</h6>

<pre><code>    //取出数组中对应的数据放到一个字典里面
    appsModel *app = self.apps[i];


    //创建一个UIImageView
    UIImageView *icon = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, iW, 50)];
    /**
     取出字典中的icon
     */
    icon.image = [UIImage imageNamed:app.icon];
    [view addSubview:icon];



    //创建一个Label
    UILabel *l = [[UILabel alloc] initWithFrame:CGRectMake(0, CGRectGetMaxY(icon.frame), iW, 20)];
    /**
     取出字典中的label
     */
    l.text = app.label;
    [view addSubview:l];



    //创建一个按钮
    UIButton *btn = [[UIButton alloc] initWithFrame:CGRectMake(0, CGRectGetMaxY(l.frame), iW, 20)];
    /**
     取出字典中的btn
     */
    [btn setTitle:app.btn forState:UIControlStateNormal];
    [view addSubview:btn];
</code></pre>

<h5>注：上面是plist中的属性和模型中定义的属性一一对应的时候的，如果不是一一对应我们就要将模型一个一个的赋值与实现</h5>

<pre><code>- (instancetype)initWithDict:(NSDictionary *)dict
{
self = [super init];
if (self) {
    self.label = dict[@"label"];
    self.btn = dict[@"btn"];
    self.icon = dict[@"icon"];

//[self setValue:dict[@"label"] forKeyPath:@"label"];

    //封装
    [self setValuesForKeysWithDictionary:dict];
}

return self;
}
</code></pre>

<p>/<em>*
 模型数据的加载，返回arry以后我们就只要使用array就能使用这个模型类里面的数据也就是使用plist数据
 </em>/</p>

<pre><code>//懒加载plist文件，返回一个apps数据，后面直接使用旧可以
-(NSMutableArray *)apps
{
    if (_apps == nil) {
        NSArray *array = [NSArray arrayWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@"iCocos.plist" ofType:nil]];

        NSMutableArray *arrayApps = [NSMutableArray array];

        for (NSDictionary *dic in array) {
//            appsModel *model = [[appsModel alloc] initWithDict:dic];
            appsModel *model = [appsModel appsWithDict:dic];

            [arrayApps addObject:model];
        }
        _apps = arrayApps;
    }
    return _apps;
}
</code></pre>

<h6>我们也可以讲加载模型的代码进行封装，这样更加简单的实现模式数据的的使用</h6>

<p>在模型中定义并且实现一个模型封装的方法</p>

<pre><code>+(NSArray *)appList
{
        NSArray *array = [NSArray arrayWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@"iCocos.plist" ofType:nil]];

        NSMutableArray *arrayApps = [NSMutableArray array];

        for (NSDictionary *dic in array) {
            //            appsModel *model = [[appsModel alloc] initWithDict:dic];
            appsModel *model = [appsModel appsWithDict:dic];

            [arrayApps addObject:model];
    }
    return arrayApps;

}
</code></pre>

<h6>实用的时候只要直接使用封装好的模型方法就可以：</h6>

<pre><code>/**
 模型数据的加载，返回arry以后我们就只要使用array就能使用这个模型类里面的数据也就是使用plist数据
 */
//懒加载plist文件，返回一个apps数据，后面直接使用旧可以
-(NSArray *)apps
{
    if (_apps == nil) {

        _apps = [appsModel appList];
    }
    return _apps;
}
</code></pre>

<h2>三：复杂Plist转模型</h2>

<p>有的时候我们会遇到Plist中还有更小一级的节点和属性这个时候我们就需要更复杂的模型来加载，但是实用起来并不复杂</p>

<p>比如Plist中海油一个friends这歌子模型</p>

<p><img src="/images/zidianzhuanmoxin003.png" title="Caption" ></p>

<h6>那么我转模型的时候就可以根据plist中的数据进行处理，</h6>

<h6>首先我们一一般都是从子模型开始，我们就先定义子模型</h6>

<pre><code>/**
 根据plist里面存在的子列中的数据再创建一个模型数据
 */

/**
 设置子模型数据的属性
 */

@property (nonatomic, assign) NSString *icon;

@property (nonatomic, assign) NSString *intro;

@property (nonatomic, assign) NSString *name;

@property (nonatomic, assign, getter=isVip)BOOL vip;


/**
 子模型数据的方法
 */
+ (instancetype)friendWithDict:(NSDictionary *)dict;

- (instancetype)initWithDict:(NSDictionary *)dict;
</code></pre>

<h6>子模型的实现</h6>

<pre><code>/**
 子模型数据的方法de实现
 */

+ (instancetype)friendWithDict:(NSDictionary *)dict
{
    return [[self alloc] initWithDict:dict];
}

- (instancetype)initWithDict:(NSDictionary *)dict
{
    if (self = [super init]) {
        [self setValuesForKeysWithDictionary:dict];
    }
    return self;
}
</code></pre>

<h6>然后就是根模型</h6>

<pre><code>/**
 根据plist中的数据创建一个模型数据
 */

/**
 设置模型数据的中的属性
 */

@property (nonatomic, assign) NSArray *friends;

@property (nonatomic, copy) NSString *name;

@property (nonatomic, assign) NSNumber *online;

/**
 模型数据的方法
 */

+ (instancetype)groupWithDict:(NSDictionary *)dict;


- (instancetype)initWithDict:(NSDictionary *)dict;
</code></pre>

<h6>根模型的实现，这里只需要在根模型加载需要实现的子模型酒可以</h6>

<pre><code>/**
 模型数据的方法的实现
 */

+ (instancetype)groupWithDict:(NSDictionary *)dict
{
    return [[self alloc] initWithDict:dict];
}

- (instancetype)initWithDict:(NSDictionary *)dict
{
    if (self = [super init]) {
        [self setValuesForKeysWithDictionary:dict];

        NSMutableArray *friendArray = [NSMutableArray array];
        for (NSDictionary *dict in self.friends) {
            FriendsPlistChildren *friend = [FriendsPlistChildren friendWithDict:dict];
            [friendArray addObject:friend];
        }
        self.friends = friendArray;
    }
    return self;
}
</code></pre>

<h6>使用模型数据，方法还是和之前一样的，不需要去处理子模型，因为我们在跟模型里面已经处理好了</h6>

<pre><code>/**
 加载模型数据的方法
 */

- (NSArray *)groups
{
    if (_groups == nil) {
        NSArray *dictArray = [NSArray arrayWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@"friends.plist" ofType:nil]];

        NSMutableArray *groupArray = [NSMutableArray array];
        for (NSDictionary *dict in dictArray) {
            FirendsPlistRoot *group = [FirendsPlistRoot groupWithDict:dict];
            [groupArray addObject:group];
        }

        _groups = groupArray;
    }
    return _groups;
}
</code></pre>

<h2>四：使用第三份库</h2>

<p>在iOS届有一个神人不知道大家知不知道————他叫李明杰，他（MJ）不仅技术牛逼，而且对天朝iOS界的贡献也是无法用语言来形容的，如果你是老一辈的iOS开发者倒是很正常，如果你只是刚开始学习iOS或者学习iOS不久你都不知道或者没有听过这个名字那么就可以说明你真的out了，甚至说你你根本没有用心在学，关于这个神人我就不做多介绍了，如果你想知道更多，请点击www.520it.com</p>

<p>今天我就使用他的一个NB的框架来实现plist转模型数据，这个框架使用起来非常简单，一行代码就可以搞定你想的功能，</p>

<p>首先你需要去github上面下载这个框架：<a href="https://github.com/CoderMJLee/MJExtension">MJExtension</a></p>

<p>下载好了之后直接讲MJExtension拖到你的项目</p>

<p><img src="/images/zidianzhuanmoxin004.png" title="Caption" ></p>

<h6>首先根据plist数据新建对应的模型数据</h6>

<p>这里我一新浪微博中的小部分做测试</p>

<pre><code>#import "User.h"
#import "Status.h"
#import "StatusResult.h"

/**
 *  微博文本内容
 */
@property (copy, nonatomic) NSString *text;

/**
 *  微博作者
 */
@property (strong, nonatomic) User *user;

/**
 *  转发的微博
 */
@property (strong, nonatomic) Status *retweetedStatus;
/**
 *  存放着某一页微博数据（里面都是Status模型）
 */
@property (strong, nonatomic) NSMutableArray *statuses;

/**
 *  总数
 */
@property (assign, nonatomic) NSNumber *totalNumber;

/**
 *  上一页的游标
 */
@property (assign, nonatomic) long long previousCursor;

/**
 *  下一页的游标
 */
@property (assign, nonatomic) long long nextCursor;
/**
 *  名称
 */
@property (copy, nonatomic) NSString *name;

/**
 *  头像
 */
@property (copy, nonatomic) NSString *icon;
</code></pre>

<h6>下面就是证明去使用这个框架实现你想要的功能了，这里介绍了几乎你开发中需要用到的所有方法和例子，</h6>

<pre><code>/**
 MJ友情提醒：
 1.MJExtension是一套“字典和模型之间互相转换”的轻量级框架
 2.MJExtension能完成的功能
 * 字典 --&gt; 模型
 * 模型 --&gt; 字典
 * 字典数组 --&gt; 模型数组
 * 模型数组 --&gt; 字典数组
 3.具体用法主要参考 main.m中各个函数 以及 "NSObject+MJKeyValue.h"
 4.希望各位大神能用得爽
 */

#import &lt;Foundation/Foundation.h&gt;
#import "MJExtension.h"
#import "User.h"
#import "Status.h"
#import "StatusResult.h"

/**
 *  简单的字典 -&gt; 模型
 */
void keyValues2object()
{
    // 1.定义一个字典
    NSDictionary *dict = @{
                           @"name" : @"Jack",
                           @"icon" : @"lufy.png",
                           };

    // 2.将字典转为User模型
    User *user = [User objectWithKeyValues:dict];

    // 3.打印User模型的属性
    NSLog(@"name=%@, icon=%@", user.name, user.icon);
}

/**
 *  复杂的字典 -&gt; 模型 (模型里面包含了模型)
 */
void keyValues2object2()
{
    // 1.定义一个字典
    NSDictionary *dict = @{
                           @"text" : @"是啊，今天天气确实不错！",

                           @"user" : @{
                                   @"name" : @"Jack",
                                   @"icon" : @"lufy.png"
                                   },

                           @"retweetedStatus" : @{
                                   @"text" : @"今天天气真不错！",

                                   @"user" : @{
                                           @"name" : @"Rose",
                                           @"icon" : @"nami.png"
                                           }
                                   }
                           };

    // 2.将字典转为Status模型
    Status *status = [Status objectWithKeyValues:dict];

    // 3.打印status的属性
    NSString *text = status.text;
    NSString *name = status.user.name;
    NSString *icon = status.user.icon;
    NSLog(@"text=%@, name=%@, icon=%@", text, name, icon);

    // 4.打印status.retweetedStatus的属性
    NSString *text2 = status.retweetedStatus.text;
    NSString *name2 = status.retweetedStatus.user.name;
    NSString *icon2 = status.retweetedStatus.user.icon;
    NSLog(@"text2=%@, name2=%@, icon2=%@", text2, name2, icon2);
}

/**
 *  复杂的字典 -&gt; 模型 (模型的数组属性里面又装着模型)
 */
void keyValues2object3()
{
    // 1.定义一个字典
    NSDictionary *dict = @{
                           @"statuses" : @[
                                   @{
                                       @"text" : @"今天天气真不错！",

                                       @"user" : @{
                                               @"name" : @"Rose",
                                               @"icon" : @"nami.png"
                                               }
                                       },

                                   @{
                                       @"text" : @"明天去旅游了",

                                       @"user" : @{
                                               @"name" : @"Jack",
                                               @"icon" : @"lufy.png"
                                               }
                                       },

                                   @{
                                       @"text" : @"嘿嘿，这东西不错哦！",

                                       @"user" : @{
                                               @"name" : @"Jim",
                                               @"icon" : @"zero.png"
                                               }
                                       }

                                   ],

                           @"totalNumber" : @"2014",

                           @"previousCursor" : @"13476589",

                           @"nextCursor" : @"13476599"
                           };

    // 2.将字典转为StatusResult模型
    StatusResult *result = [StatusResult objectWithKeyValues:dict];

    // 3.打印StatusResult模型的简单属性
    NSLog(@"totalNumber=%d, previousCursor=%lld, nextCursor=%lld", result.totalNumber, result.previousCursor, result.nextCursor);

    // 4.打印statuses数组中的模型属性
    for (Status *status in result.statuses) {
        NSString *text = status.text;
        NSString *name = status.user.name;
        NSString *icon = status.user.icon;
        NSLog(@"text=%@, name=%@, icon=%@", text, name, icon);
    }
}

/**
 *  字典数组 -&gt; 模型数组
 */
void keyValuesArray2objectArray()
{
    // 1.定义一个字典数组
    NSArray *dictArray = @[
                           @{
                               @"name" : @"Jack",
                               @"icon" : @"lufy.png",
                               },

                           @{
                               @"name" : @"Rose",
                               @"icon" : @"nami.png",
                               },

                           @{
                               @"name" : @"Jim",
                               @"icon" : @"zero.png",
                               }
                           ];

    // 2.将字典数组转为User模型数组
    NSArray *userArray = [User objectArrayWithKeyValuesArray:dictArray];

    // 3.打印userArray数组中的User模型属性
    for (User *user in userArray) {
        NSLog(@"name=%@, icon=%@", user.name, user.icon);
    }
}

/**
 *  模型 -&gt; 字典
 */
void object2keyValues()
{
    // 1.新建模型
    User *user = [[User alloc] init];
    user.name = @"Jack";
    user.icon = @"lufy.png";

    Status *status = [[Status alloc] init];
    status.user = user;
    status.text = @"今天的心情不错！";

    // 2.将模型转为字典
    //    NSDictionary *dict = [status keyValues];
    NSDictionary *dict = status.keyValues;
    NSLog(@"%@", dict);
}

/**
 *  模型数组 -&gt; 字典数组
 */
void objectArray2keyValuesArray()
{
    // 1.新建模型数组
    User *user1 = [[User alloc] init];
    user1.name = @"Jack";
    user1.icon = @"lufy.png";

    User *user2 = [[User alloc] init];
    user2.name = @"Rose";
    user2.icon = @"nami.png";

    User *user3 = [[User alloc] init];
    user3.name = @"Jim";
    user3.icon = @"zero.png";

    NSArray *userArray = @[user1, user2, user3];

    // 2.将模型数组转为字典数组
    NSArray *dictArray = [User keyValuesArrayWithObjectArray:userArray];
    NSLog(@"%@", dictArray);
}

int main(int argc, const char * argv[])
{
    @autoreleasepool {
        // 简单的字典 -&gt; 模型
        keyValues2object();

        // 复杂的字典 -&gt; 模型 (模型里面包含了模型)
        keyValues2object2();

        // 复杂的字典 -&gt; 模型 (模型的数组属性里面又装着模型)
        keyValues2object3();

        // 字典数组 -&gt; 模型数组
        keyValuesArray2objectArray();

        // 模型转字典
        object2keyValues();

        // 模型数组 -&gt; 字典数组
        objectArray2keyValuesArray();
    }
    return 0;
}
</code></pre>
</div>
  
  




| <a href="/blog/2015/12/01/zi-dian-zhuan-mo-xing-shen-jiu/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/11/30/iossheng-ming-zhou-qi/">iOS生命周期</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><h3>控制器（View）生命周期</h3>

<p>当一个视图控制器被创建，并在屏幕上显示的时候。 代码的执行顺序</p>

<pre><code>1、 alloc                                   创建对象，分配空间
2、init (initWithNibName) 初始化对象，初始化数据
3、loadView                          从nib载入视图 ，通常这一步不需要去干涉。除非你没有使用xib文件创建视图
4、viewDidLoad                   载入完成，可以进行自定义数据以及动态创建其他控件
5、viewWillAppear              视图将出现在屏幕之前，马上这个视图就会被展现在屏幕上了
6、viewDidAppear               视图已在屏幕上渲染完成
</code></pre>

<p>当一个视图被移除屏幕并且销毁的时候的执行顺序，这个顺序差不多和上面的相反</p>

<pre><code>1、viewWillDisappear            视图将被从屏幕上移除之前执行
2、viewDidDisappear             视图已经被从屏幕上移除，用户看不到这个视图了
3、dealloc                                 视图被销毁，此处需要对你在init和viewDidLoad中创建的对象进行释放
</code></pre>

<p>－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－</p>

<h3>app的启动过程</h3>

<pre><code>1.先执行main函数，main内部会调用UIApplicationMain函数

2.UIApplicationMain函数里面做了什么事情：

    1&gt; 创建UIApplication对象
    2&gt; 创建UIApplication的delegate对象—–PYAppDelegate
    3&gt; 开启一个消息循环

每监听到对应的系统事件时，就会通知MJAppDelegate

根据plist文件判断是否需要加载storyBoard
</code></pre>

<p>如果有storyBoard</p>

<pre><code>加载Info.plist文件，读取最主要storyboard文件的名称

加载最主要的storyboard文件，创建白色箭头所指的控制器对象

并且设置创建的控制器为UIWindow的rootViewController属性(根控制器)

初始化对应的子控件
</code></pre>

<p>如果没有storyBoard</p>

<pre><code>在代理的difinishLuaunchWithOPtions中为应用程序创建一个UIWindow对象(继承自UIView)，设置为PYAppDelegate的window属性

并且设置创建的控制器为UIWindow的rootViewController属性(根控制器)

初始化对应的子控件
</code></pre>

<p>－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－</p>

<h3>App的生命周期</h3>

<p>这里只是简单的总结，关于有些方法我们并没有解除过，所以就略过了。</p>

<pre><code> 1、application didFinishLaunchingWithOptions：当应用程序启动时执行，应用程序启动入口，只在应用程序启动时执行一次。若用户直接启动，lauchOptions内无数据,若通过其他方式启动应用，lauchOptions包含对应方式的内容。
 2、applicationWillResignActive：在应用程序将要由活动状态切换到非活动状态时候，要执行的委托调用，如 按下 home 按钮，返回主屏幕，或全屏之间切换应用程序等。

 3、applicationDidEnterBackground：在应用程序已进入后台程序时，要执行的委托调用。

 4、applicationWillEnterForeground：在应用程序将要进入前台时(被激活)，要执行的委托调用，刚好与applicationWillResignActive 方法相对应。

 5、applicationDidBecomeActive：在应用程序已被激活后，要执行的委托调用，刚好与applicationDidEnterBackground 方法相对应。

 6、applicationWillTerminate：在应用程序要完全推出的时候，要执行的委托调用，这个需要要设置UIApplicationExitsOnSuspend的键值。
</code></pre>
</div>
  
  




| <a href="/blog/2015/11/30/iossheng-ming-zhou-qi/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/11/29/h5chu-tan/">H5初探</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><h2>H5精华</h2>

<blockquote><p>标准通用标记语言下的一个应用HTML标准自1999年12月发布的HTML4.01后，后继的HTML5和其它标准被束之高阁，为了推动Web标准化运动的发展，一些公司联合起来，成立了一个叫做 Web Hypertext Application Technology Working Group （Web超文本应用技术工作组 -WHATWG） 的组织。WHATWG 致力于 Web 表单和应用程序，而W3C（World Wide Web Consortium，万维网联盟） 专注于XHTML2.0。在 2006 年，双方决定进行合作，来创建一个新版本的 HTML。</p></blockquote>

<h6>1：链接</h6>

<p>图像标签</p>

<pre><code>相对路径 ../../

绝对路径  https:// http://  ftp://  file://
</code></pre>

<ul>
<li><p> href: 引用 不是必须的</p></li>
<li><p> src: 引入  必需的</p></li>
</ul>


<hr />

<pre><code>&lt;!--超链接标签  javascript:void(0) --&gt;
&lt;a href="#"&gt;我是超链接&lt;/a&gt;
&lt;a href="http://baidu.com" target="_blank"&gt;百度一下,你就知道&lt;/a&gt;


&lt;img src="https://www.baidu.com/img/bd_logo1.png" alt="百度logo" width="200"&gt;
&lt;img src="images/img_01.jpg"&gt;
</code></pre>

<h6>2：列表&lt;&ndash;列表标签&ndash;></h6>

<p>无序：</p>

<pre><code>&lt;ul&gt;
  &lt;li&gt;我是列表1&lt;/li&gt;
  &lt;li&gt;我是列表2&lt;/li&gt;
  &lt;li&gt;我是列表3&lt;/li&gt;
  &lt;li&gt;我是列表4&lt;/li&gt;
&lt;/ul&gt;
</code></pre>

<p>有序：</p>

<pre><code>&lt;Ol&gt;
    &lt;li&gt;我是列表1&lt;/li&gt;
    &lt;li&gt;我是列表2&lt;/li&gt;
    &lt;li&gt;我是列表3&lt;/li&gt;
    &lt;li&gt;我是列表4&lt;/li&gt;
&lt;/Ol&gt;
</code></pre>

<h6>3:文章：</h6>

<pre><code>&lt;article&gt;

    &lt;header&gt;

    &lt;/header&gt;

    &lt;section&gt;&lt;/section&gt;

    &lt;section&gt;&lt;/section&gt;

    &lt;footer&gt;

    &lt;/footer&gt;

&lt;/article&gt;
</code></pre>

<h6>4：高级:</h6>

<pre><code>   &lt;!--进度条--&gt;
   &lt;progress max="100" value="50"&gt;&lt;/progress&gt;
   &lt;!--音频--&gt;
   &lt;audio src="sources/music.m4a" controls="controls"&gt;&lt;/audio&gt;
   &lt;!--视频--&gt;
   &lt;video src="sources/BigBuck.m4v" controls="controls"&gt;&lt;/video&gt;
</code></pre>

<blockquote><h6>其他请参考相关文档</h6></blockquote>

<hr />

<h2>CSS3</h2>

<h4>一:样式</h4>

<blockquote><p>CSS即层叠样式表（Cascading StyleSheet）。 在网页制作时采用层叠样式表技术，可以有效地对页面的布局、字体、颜色、背景和其它效果实现更加精确的控制。 只要对相应的代码做一些简单的修改，就可以改变同一页面的不同部分，或者页数不同的网页的外观和格式。CSS3是CSS技术的升级版本，CSS3语言开发是朝着模块化发展的。以前的规范作为一个模块实在是太庞大而且比较复杂，所以，把它分解为一些小的模块，更多新的模块也被加入进来。这些模块包括： 盒子模型、列表模块、超链接方式 、语言模块 、背景和边框 、文字特效 、多栏布局等。</p></blockquote>

<h6>1.行内：</h6>

<p>&lt;&ndash;style=&ldquo;background-color: red;&rdquo;&ndash;></p>

<p><--
   单值属性: 后面只有一个属性值
   复合属性: 后面有多个属性值
--></p>

<pre><code>   &lt;div style="color: purple; font-size: 40px; background-color: yellowgreen;"&gt;我是容器div&lt;/div&gt;
   &lt;p style="color: blue; font-size: 100px; border:3px solid red;"&gt;我是段落&lt;/p&gt;
</code></pre>

<h6>2.页内：</h6>

<pre><code>&lt;--
  网站 = N个网页 + 服务器 + 数据库 + ....

--&gt;

&lt;!--
  css遵循的规律:
  1&gt; 就近原则
  2&gt; 叠加原则
--&gt;
</code></pre>

<hr />

<pre><code>    &lt;style&gt;
        div{
            color: chartreuse;
            border: 3px dashed blueviolet;
            font-size: 90px;
        }
    &lt;/style&gt; 
&lt;/head&gt;
&lt;body&gt;
  &lt;div&gt;我是div&lt;/div&gt; 
</code></pre>

<h6>3.外部</h6>

<pre><code>    &lt;!--引入--&gt;
    &lt;link href="css/index.css" rel="stylesheet"&gt;
&lt;/head&gt;
&lt;body&gt;
   &lt;div&gt;哈哈哈哈哈&lt;/div&gt;
</code></pre>

<hr />

<pre><code>div{
    color: darkgoldenrod;
    background-color: mediumvioletred;
    font-size: 5px;
}
</code></pre>

<h4>二：选择器</h4>

<pre><code>    /** 标签选择器*/
    div{
        color: red;
    }
    /*类选择器*/
    .test1{
        color: green;
    }
    /*id选择器*/
    #main{
        font-size: 90px;
    }
    /*并列选择器*/
    #main,.test1{
        border: 5px double darkviolet;
    }
    /*复合选择器*/
    p.test2{
       background-color: red;
    }
    /*后代选择器*/
    #first p a{
        font-size: 90px;
    }
    /*伪类*/
    input:focus{
       width: 500px;
       height: 60px;
       font-size: 55px;
       /*去除外边框*/
       outline: none;
    }

    div#main:hover{
       background-color: yellow;
       width: 500px;
       height: 250px;
    }
    /*伪元素*/
    p:first-letter{
        color: goldenrod;
        font-size: 60px;
    }
</code></pre>

<hr />

<pre><code>   &lt;div id="main"&gt;bjbjwefbjb&lt;/div&gt;
   &lt;div&gt;bjbjwefbjb&lt;/div&gt; 
   &lt;p&gt;我是段落&lt;/p&gt; 
   &lt;div class="test1"&gt;bjbjwefbjb&lt;/div&gt;
   &lt;div id="first"&gt;
       &lt;p&gt;
           &lt;a href="#"&gt;我是超链接&lt;/a&gt;
       &lt;/p&gt;
   &lt;/div&gt;
</code></pre>

<h4>三：优先级：</h4>

<pre><code>    &lt;--
      CSS遵循的规律:
      1.相同级别的选择器: a.就近原则  b.叠加原则
      2.不同选择器:
        important &gt; 内联 &gt; id &gt; 类 &gt; 标签 | 伪类 | 属性选择 &gt; 伪元素 &gt; 通配符 &gt; 继承
      3. 选择器的针对性越强，它的优先级就越高
    --&gt;
</code></pre>

<blockquote><h6>其他请参考相关文档</h6></blockquote>

<hr />

<h2>编写 JScript</h2>

<blockquote><p>与其他许多编程语言一样， Microsoft JScript 是用文本方式编写的，并被组织成为语句、由相关的语句集组成的块、以及注释。在一条语句内可以使用变量、比如字符串和数字（称为“文字”）的立即数、以及表达式。</p></blockquote>

<h5>一：语句</h5>

<p>JScript 程序是语句的集合。一条 Jscript 语句相当于英语中的一个完整句。Jscript 语句将表达式组合起来，完成一个任务。</p>

<p>一条语句由一个或多个表达式、关键字或者运算符（符号）组成。典型地，一条语句写一行，尽管一条语句可以超过两行或更多行。两条或更多条语句也可以写在同一行上，语句之间用分号“;”隔开。通常，每一新行开始一条新语句。不过显式地终止语句是一个好方法。这是用分号 (;)来实现的，分号是 JScript 语句的终止字符。下面给出 Jscript 语句的两隔示例。</p>

<pre><code>aBird = "Robin"; //将文本“Robin”赋值给变量 aBird
var today = new Date(); // 将今天的日期赋值给变量 today
</code></pre>

<p>用大括号（{}）括起来的一组 JScript 语句称为一个语句块。分组到一个语句块中的语句通常可当作单条语句处理。这就是说在 JScript 期望有一条单个语句的大多数地方可以使用语句块。应该注意以 for 和 while 打头的循环语句是例外情况。注意，语句块中的原始语句以分号结束，但语句块本身并不以分号结束。</p>

<p>通常，在函数和条件语句中使用语句块。</p>

<blockquote><p>注意，Jscript 与 C++ 以及其他某些语言不同，它不认为语句块是一个新的范围；只有函数创建新范围。在下面的示例中，第一条语句开始定义一个函数，该函数包含一个五条语句组成的语句块。语句块后的三条语句没有用大括号括起来；这些语句不是一个语句块，所以就不是函数定义的一部分。</p></blockquote>

<pre><code>function convert(inches)  {
   feet = inches / 12;  //  这五条语句属于一个语句块。
   miles = feet / 5280;
   nauticalMiles = feet / 6080;
   cm = inches * 2.54;
   meters = inches / 39.37;
}
km = meters / 1000;  //  这三条语句不在语句块内。
kradius = km;
mradius = miles;
</code></pre>

<h5>二：注释</h5>

<p>单行的 JScript 注释以一对正斜杠(//)开始。下面给出一个单行注释的示例。</p>

<pre><code>aGoodIdea = "Comment your code thoroughly.";  //  这是一个单行注释。
</code></pre>

<p>多行注释以一个正斜杠加一个星号的组合(/<em>)开始,并以其逆向顺序 (</em>/)结束。</p>

<pre><code>/*
这是一个用来解释前面的代码语句的多行注释。

该语句将一个值赋给 aGoodIdea 变量。
用引号包含的这种值称为一个文字。
文字显式并直接包含信息；
而不是简接地引用信息。
（引号不属于该文字的内容。）
*/
</code></pre>

<blockquote><p>注意   如果您试图将一个多行注释插入到另一个中，JScript 不能按正常的方式解释生成的多行注释。标明嵌入的多行注释结束的 */ 被认为是整个多行注释的结尾。这就意味着嵌入多行注释之后的文本不再被认为是注释；相应地，它将被解释为 JScript 代码，并会产生语法错误。</p></blockquote>

<p>建议将所有的注释写为单行注释的语句块。这样您以后就能够将大段的代码与多行注释区分开。</p>

<pre><code>//这是另一种多行注释，写成一系列单行注释。

//  在执行完该语句后，可以使用 aGoodIdea 变量的名字来引用其内容，
//  如下一条语句那样，即采用连接操作将字符串文字添加到
//  aGoodIdea 变量，以创建一个新的变量。

var extendedIdea = aGoodIdea + " You never know when you'll have to figure out what it does.";
</code></pre>

<p>赋值和相等</p>

<p>JScript 语句中使用等号 (=)给变量赋值：等号是赋值运算符。= 运算符左边的操作项总是一个 Lvalue。Lvalue 可以是：</p>

<h5>三：变量，</h5>

<p>数组元素，
对象属性。
= 运算符右边的操作项总是一个 Rvalue。Rvalues 可以是任何类型的一个任意值，包括表达式的值。下面给出一个 JScript 赋值语句的示例。</p>

<pre><code>anInteger = 3;
</code></pre>

<p>Jscript 编译器解释本语句的意义为：“将 3 赋给变量 anInteger”或“anInteger 的值为 3”。</p>

<p>确定您理解了 = 运算符（赋值）和 == 运算符（相等）的差异。在比较两个值是否相等时，应使用两个等于号 (==)。这些内容将在 控制程序的流程 中详细介绍。</p>

<h5>四：表达式</h5>

<p>JScript 表达式是指 JScript 解释器能够计算生成值的 JScript “短语”。这个值可以是任何有效的 JScript 类型 — 数字、字符串、对象，等等。最简单的表达式是文字。下面给出 JScript 文字表达式的一些示例。</p>

<pre><code>3.9                       // 数字文字
"Hello!"                  // 字符串文字
false                     // 布尔文字
null                      // 文字空值
{x:1, y:2}                // 对象文字
[1,2,3]                   // 数组文字
function(x){return x*x;}  // 函数文字
</code></pre>

<p>更多复杂的表达式中包含变量、函数、函数调用以及其他表达式。可以用运算符将表达式组合，创建复合表达式。运算符可以是：</p>

<pre><code>+  // 加法
-  // 减法
*  // 乘法
/  // 除法
</code></pre>

<p>下面给出 JScript 复合表达式的一些示例。</p>

<pre><code>var anExpression = 3 * (4 / 5) + 6;
var aSecondExpression = Math.PI * radius * radius;
var aThirdExpression = aSecondExpression + "%" + anExpression;
var aFourthExpression = "(" + aSecondExpression + ") % (" + anExpression + ")";
</code></pre>

<blockquote><h6>其他请参考相关文档</h6></blockquote>
</div>
  
  




| <a href="/blog/2015/11/29/h5chu-tan/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/11/29/zi-ding-yi-xiang-ce-shan-chu-fu-huo-de-shi-xian/">自定义相册删除复活的实现</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><p>在这里（<a href="http://www.cnblogs.com/iCocos/p/4705585.html">http://www.cnblogs.com/iCocos/p/4705585.html</a>）我们提到了。</p>

<ul>
<li>简单的实现了获取系统相册图片并且保存图片到系统相册</li>
<li>定义自定义的相册，并且保存到自定义相册</li>
</ul>


<p>这里久以一个简单的例子实现一个上面的所有功能，并且添加一个很有用的功能实现
App中自定义的相册呗删除之后再次保存相片无法成功</p>

<p>这里使用的是一个系统的库：ALAssetsLibrary</p>

<p>先来看看咱们取得相册中的相片</p>

<pre><code>- (void)getAllPhotos
{
    ALAssetsLibrary *library = [[ALAssetsLibrary alloc] init];
    // 遍历所有的文件夹, 一个ALAssetsGroup对象就代表一个文件夹
    [library enumerateGroupsWithTypes:ALAssetsGroupAll usingBlock:^(ALAssetsGroup *group, BOOL *stop) {
        // 遍历文件夹内的所有多媒体文件（图片、视频）, 一个ALAsset对象就代表一张图片
        [group enumerateAssetsUsingBlock:^(ALAsset *result, NSUInteger index, BOOL *stop) {
            // 缩略图
            XMGLog(@"%@", [UIImage imageWithCGImage:result.thumbnail]);
            // 获得原始图片
            //            XMGLog(@"%@", [UIImage imageWithCGImage:result.defaultRepresentation.fullResolutionImage]);
        }];

   } failureBlock:nil];
}
</code></pre>

<p>下面我们看看代码具体的实现</p>

<p>一：首先定义一个属性涌来记录并且实现其他一些功能</p>

<pre><code> /** 相册库 */
@property (nonatomic, strong) ALAssetsLibrary *library;
</code></pre>

<p>二：然后就懒加载这个属性</p>

<pre><code>- (ALAssetsLibrary *)library
{
    if (!_library) {
        _library = [[ALAssetsLibrary alloc] init];
    }
    return _library;
}
</code></pre>

<p>三：点击保存按钮的实现</p>

<pre><code>- (IBAction)save
{
// 获得文件夹的名字
__block NSString *groupName = [self groupName];

// self的弱引用
XMGWeakSelf;

// 图片库
__weak ALAssetsLibrary *weakLibrary = self.library;

// 创建文件夹
[weakLibrary addAssetsGroupAlbumWithName:groupName resultBlock:^(ALAssetsGroup *group) {
    if (group) { // 新创建的文件夹
        // 添加图片到文件夹中
        [weakSelf addImageToGroup:group];
    } else { // 文件夹已经存在
        [weakLibrary enumerateGroupsWithTypes:ALAssetsGroupAll usingBlock:^(ALAssetsGroup *group, BOOL *stop) {
            NSString *name = [group valueForProperty:ALAssetsGroupPropertyName];
            if ([name isEqualToString:groupName]) { // 是自己创建的文件夹
                // 添加图片到文件夹中

                [weakSelf addImageToGroup:group];

                *stop = YES; // 停止遍历
            } else if ([name isEqualToString:@"Camera Roll"]) {
                // 文件夹被用户强制删除了
                groupName = [groupName stringByAppendingString:@" "];
                // 存储新的名字
                [[NSUserDefaults standardUserDefaults] setObject:groupName forKey:XMGGroupNameKey];
                [[NSUserDefaults standardUserDefaults] synchronize];
                // 创建新的文件夹
                [weakLibrary addAssetsGroupAlbumWithName:groupName resultBlock:^(ALAssetsGroup *group) {
                    // 添加图片到文件夹中
                    [weakSelf addImageToGroup:group];
                } failureBlock:nil];
            }
        } failureBlock:nil];
    }

    } failureBlock:nil];
    }
</code></pre>

<p>四：添加图片</p>

<pre><code>/**
 * 添加一张图片到某个文件夹中
 */
- (void)addImageToGroup:(ALAssetsGroup *)group
{
__weak ALAssetsLibrary *weakLibrary = self.library;
// 需要保存的图片

CGImageRef image = self.imageView.image.CGImage;

// 添加图片到【相机胶卷】
[weakLibrary writeImageToSavedPhotosAlbum:image metadata:nil completionBlock:^(NSURL *assetURL, NSError *error) {
    [weakLibrary assetForURL:assetURL resultBlock:^(ALAsset *asset) {
        // 添加一张图片到自定义的文件夹中
        [group addAsset:asset];
        [SVProgressHUD showSuccessWithStatus:@"保存成功!"];
    } failureBlock:nil];
}];
}
</code></pre>

<p>五：关于沙河中的组名</p>

<p>先定义一个用于保存名字用的key和一个需要保存的名字</p>

<pre><code>static NSString * const iCocosGroupNameKey = @"iCocosGroupNameKey";
static NSString * const iCocosDefaultGroupName = @"iCocos";
</code></pre>

<p>实现祖名的存取</p>

<pre><code>- (NSString *)groupName
{
    // 先从沙盒中取得名字

    NSString *groupName = [[NSUserDefaults standardUserDefaults] stringForKey:XMGGroupNameKey];
    if (groupName == nil) { // 沙盒中没有存储任何文件夹的名字
   groupName = XMGDefaultGroupName;

    // 存储名字到沙盒中
    [[NSUserDefaults standardUserDefaults] setObject:groupName forKey:XMGGroupNameKey];
 [[NSUserDefaults standardUserDefaults] synchronize];
}
return groupName;
}
</code></pre>
</div>
  
  




| <a href="/blog/2015/11/29/zi-ding-yi-xiang-ce-shan-chu-fu-huo-de-shi-xian/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/11/28/qu-xiao-tableviewde-headeryu-footerde-nian-xing-xiao-guo/">取消TableView的Header与Footer的黏性效果</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><p>引言：</p>

<p>最近做一个项目的时候，遇到了一个bug问题，或者说个人能力有限，想了很久没有想到最好的方法去现实。</p>

<h6>那么是什么问题呢？</h6>

<p>首先当我在tabelView中为没饿过section设置一个header和footer之后，滑动tableView的时候，发现header和footer并不随着tableView中的cell一起滚动，而且会在顶部活着底部停留一段时间，这样的效果虽然好，但是上面就是不需要者也的功能，所以只好自己想办法解决。</p>

<p>我记得有时候header是不会停顿的，可是为什么这个时候header和footer都隐藏呢？</p>

<p>后来发现原来设置tableView.tableHeaderView = ?或者footerView的时候就不会停顿，那是当然，因为这个是tableView的一部分，不是section的一部分。</p>

<p>也在网上找了一段这样的代码</p>

<h3>去掉UItableview headerview黏性(sticky)</h3>

<pre><code>- (void)scrollViewDidScroll:(UIScrollView *)scrollView {

if (scrollView == self.tableView)

{

        CGFloat sectionHeaderHeight = 64; //sectionHeaderHeight

        if (scrollView.contentOffset.y &lt;= sectionHeaderHeight &amp;&amp; scrollView.contentOffset.y &gt;= 0) {

            scrollView.contentInset = UIEdgeInsetsMake(-scrollView.contentOffset.y, 0, 0, 0);

        } else if (scrollView.contentOffset.y &gt;= sectionHeaderHeight) {

            scrollView.contentInset = UIEdgeInsetsMake(-sectionHeaderHeight, 0, 0, 0);

        }

    }

}
</code></pre>

<p>但是他职能设置headerView不能设置footerView，自己也试着去补充footerView的实现，但是发现技术有限，所以，你懂的！</p>

<h3>最后看到国外一位大神写的一一篇文章找到了下面的代码</h3>

<pre><code> -(void)scrollViewDidScroll:(UIScrollView *)scrollView {

    if (scrollView == self.tableView)

        {

        UITableView *tableview = (UITableView *)scrollView;

        CGFloat sectionHeaderHeight = 64;

        CGFloat sectionFooterHeight = 120;

        CGFloat offsetY = tableview.contentOffset.y;

        if (offsetY &gt;= 0 &amp;&amp; offsetY &lt;= sectionHeaderHeight)

        {

            tableview.contentInset = UIEdgeInsetsMake(-offsetY, 0, -sectionFooterHeight, 0);

        }else if (offsetY &gt;= sectionHeaderHeight &amp;&amp; offsetY &lt;= tableview.contentSize.height - tableview.frame.size.height - sectionFooterHeight)

        {

            tableview.contentInset = UIEdgeInsetsMake(-sectionHeaderHeight, 0, -sectionFooterHeight, 0);

        }else if (offsetY &gt;= tableview.contentSize.height - tableview.frame.size.height - sectionFooterHeight &amp;&amp; offsetY &lt;= tableview.contentSize.height - tableview.frame.size.height)         {

            tableview.contentInset = UIEdgeInsetsMake(-offsetY, 0, -(tableview.contentSize.height - tableview.frame.size.height - sectionFooterHeight), 0);

        }

    }

}
</code></pre>

<p>注：sectionHeaderHeight和sectionFooterHeight根据项目进行设置。</p>

<p>发现基本上搞定，最后只需要设置对应的内边距即可！</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2015/11/28/qu-xiao-tableviewde-headeryu-footerde-nian-xing-xiao-guo/">阅读全文😘</a>
    </footer>
  




| <a href="/blog/2015/11/28/qu-xiao-tableviewde-headeryu-footerde-nian-xing-xiao-guo/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/11/25/wang-shang-qing-qiu-feng-(feng-)zhuang/">网络请求疯（封）装</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><p>一直想总结一下关于iOS的离线数据缓存的方面的问题，然后最近也简单的对AFN进行了再次封装，所有想把这两个结合起来写一下。数据展示型的页面做离线缓存可以有更好的用户体验，用户在离线环境下仍然可以获取一些数据，这里的数据缓存首选肯定是SQLite，轻量级，对数据的存储读取相对于其他几种方式有优势，这里对AFN的封装没有涉及太多业务逻辑层面的需求，主要还是对一些方法再次封装方便使用，解除项目对第三方的耦合性，能够简单的快速的更换底层使用的网络请求代码。这篇主要写离线缓存思路，对AFN的封装只做简单的介绍。</p>

<p>关于XLNetworkApi</p>

<p>XLNetworkApi的一些功能和说明：</p>

<p>使用XLNetworkRequest做一些GET、POST、PUT、DELETE请求，与业务逻辑对接部分直接以数组或者字典的形式返回。
以及网络下载、上传文件，以block的形式返回实时的下载、上传进度，上传文件参数通过模型XLFileConfig去存取。
通过继承于XLDataService来将一些数据处理，模型转化封装起来，于业务逻辑对接返回的是对应的模型，减少Controllor处理数据处理逻辑的压力。
自定义一些回调的block</p>

<pre><code>/**
请求成功block
*/
typedef void (^requestSuccessBlock)(id responseObj);
/**
请求失败block
*/
typedef void (^requestFailureBlock) (NSError *error);
/**
请求响应block
*/
typedef void (^responseBlock)(id dataObj, NSError *error);
/**
监听进度响应block
*/
typedef void (^progressBlock)(int64_t bytesWritten, int64_t totalBytesWritten, int64_t totalBytesExpectedToWrite);
XLNetworkRequest.m部分实现
#import "XLNetworkRequest.h"
#import "AFNetworking.h"
@implementation XLNetworkRequest
+ (void)getRequest:(NSString *)url params:(NSDictionary *)params success:(requestSuccessBlock)successHandler failure:(requestFailureBlock)failureHandler {
//网络不可用
  if (![self checkNetworkStatus]) {
      successHandler(nil);
      failureHandler(nil);
      return;
  }
  AFHTTPRequestOperationManager *manager = [self getRequstManager];
  [manager GET:url parameters:params success:^(AFHTTPRequestOperation * _Nonnull operation, id  _Nonnull responseObject) {
      successHandler(responseObject);
  } failure:^(AFHTTPRequestOperation * _Nullable operation, NSError * _Nonnull error) {
      XLLog(@"------请求失败-------%@",error);
      failureHandler(error);
  }];
}
</code></pre>

<p>下载部分代码</p>

<pre><code>    //下载文件，监听下载进度
    + (void)downloadRequest:(NSString *)url successAndProgress:(progressBlock)progressHandler complete:(responseBlock)completionHandler {
      if (![self checkNetworkStatus]) {
          progressHandler(0, 0, 0);
          completionHandler(nil, nil);
          return;
      }
      NSURLSessionConfiguration *sessionConfiguration = [NSURLSessionConfiguration defaultSessionConfiguration];
      AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:sessionConfiguration];
      NSURLRequest *request = [NSURLRequest requestWithURL:[NSURL URLWithString:url]];
      NSProgress *kProgress = nil;
      NSURLSessionDownloadTask *downloadTask = [manager downloadTaskWithRequest:request progress:&amp;kProgress destination:^NSURL * _Nonnull(NSURL * _Nonnull targetPath, NSURLResponse * _Nonnull response) {
          NSURL *documentUrl = [[NSFileManager defaultManager] URLForDirectory :NSDocumentDirectory inDomain:NSUserDomainMask appropriateForURL:nil create:NO error:nil];
          return [documentUrl URLByAppendingPathComponent:[response suggestedFilename]];
      } completionHandler:^(NSURLResponse * _Nonnull response, NSURL * _Nonnull filePath, NSError * _Nonnull error){
          if (error) {
              XLLog(@"------下载失败-------%@",error);
          }
          completionHandler(response, error);
      }];
      [manager setDownloadTaskDidWriteDataBlock:^(NSURLSession * _Nonnull session, NSURLSessionDownloadTask * _Nonnull downloadTask, int64_t bytesWritten, int64_t totalBytesWritten, int64_t totalBytesExpectedToWrite) {
          progressHandler(bytesWritten, totalBytesWritten, totalBytesExpectedToWrite);
      }];
      [downloadTask resume];
    }
</code></pre>

<p>上传部分代码</p>

<pre><code>//上传文件，监听上传进度
+ (void)updateRequest:(NSString *)url params:(NSDictionary *)params fileConfig:(XLFileConfig *)fileConfig successAndProgress:(progressBlock)progressHandler complete:(responseBlock)completionHandler {
  if (![self checkNetworkStatus]) {
      progressHandler(0, 0, 0);
      completionHandler(nil, nil);
      return;
  }
  NSMutableURLRequest *request = [[AFHTTPRequestSerializer serializer] multipartFormRequestWithMethod:@"POST" URLString:url parameters:params constructingBodyWithBlock:^(id  _Nonnull formData) {
      [formData appendPartWithFileData:fileConfig.fileData name:fileConfig.name fileName:fileConfig.fileName mimeType:fileConfig.mimeType];
  } error:nil];
  //获取上传进度
  AFHTTPRequestOperation *operation = [[AFHTTPRequestOperation alloc] initWithRequest:request];
  [operation setUploadProgressBlock:^(NSUInteger bytesWritten, long long totalBytesWritten, long long totalBytesExpectedToWrite) {
      progressHandler(bytesWritten, totalBytesWritten, totalBytesExpectedToWrite);
  }];
  [operation setCompletionBlockWithSuccess:^(AFHTTPRequestOperation * _Nonnull operation, id  _Nonnull responseObject) {
      completionHandler(responseObject, nil);
  } failure:^(AFHTTPRequestOperation * _Nonnull operation, NSError * _Nonnull error) {
      completionHandler(nil, error);
      if (error) {
          XLLog(@"------上传失败-------%@",error);
      }
  }];
  [operation start];
}
</code></pre>

<p>XLDataService.m部分实现</p>

<pre><code>+ (void)getWithUrl:(NSString *)url param:(id)param modelClass:(Class)modelClass responseBlock:(responseBlock)responseDataBlock {
      [XLNetworkRequest getRequest:url params:param success:^(id responseObj) {
      //数组、字典转化为模型数组
      dataObj = [self modelTransformationWithResponseObj:responseObj modelClass:modelClass];
      responseDataBlock(dataObj, nil);
  } failure:^(NSError *error) {
      responseDataBlock(nil, error);
  }];
}
</code></pre>

<p>（关键）下面这个方法提供给继承XLDataService的子类重写，将转化为模型的代码写在这里，相似业务的网络数据请求都可以用这个子类去请求数据，直接返回对应的模型数组。
    /<em>*
    数组、字典转化为模型
    </em>/
    + (id)modelTransformationWithResponseObj:(id)responseObj modelClass:(Class)modelClass {
         return nil;
    }
关于离线数据缓存</p>

<p>当用户进入程序的展示页面，有三个情况下可能涉及到数据库存取操作，简单画了个图来理解，思路比较简单，主要是一些存取的细节处理。</p>

<p>进入展示页面</p>

<p><img src="/images/net001.png" title="Caption" ></p>

<p>下拉刷新最新数据</p>

<p><img src="/images/net002.png" title="Caption" ></p>

<p>上拉加载更多数据</p>

<p><img src="/images/net003.png" title="Caption" ></p>

<p>需要注意的是，上拉加载更多的时候，每次从数据库返回一定数量的数据，而不是一次性将数据全部加载，否则会有内存问题，直到数据库中没有更多数据时再发生网络请求，再次将新数据存入数据库。这里存储数据的方式是将服务器返回每组数据的字典归档成二进制作为数据库字段直接存储，这样存储在模型属性比较多的情况下更有好处，避免每一个属性作为一个字段，另外增加了一个idStr字段用来判断数据的唯一性，避免重复存储。
首先定义一个工具类XLDataBase来做数据库相关的操作，这里用的是第三方的FMDB。</p>

<pre><code>#import "XLDataBase.h"
#import "FMDatabase.h"
#import "Item.h"
#import "MJExtension.h"
@implementation XLDataBase
static FMDatabase *_db;
+ (void)initialize {
    NSString *path = [NSString stringWithFormat:@"%@/Library/Caches/Data.db",NSHomeDirectory()];
    _db = [FMDatabase databaseWithPath:path];
    [_db open];
    [_db executeUpdate:@"CREATE TABLE IF NOT EXISTS t_item (id integer PRIMARY KEY, itemDict blob NOT NULL, idStr text NOT NULL)"];
}
//存入数据库
+ (void)saveItemDict:(NSDictionary *)itemDict {
    //此处把字典归档成二进制数据直接存入数据库，避免添加过多的数据库字段
    NSData *dictData = [NSKeyedArchiver archivedDataWithRootObject:itemDict];
    [_db executeUpdateWithFormat:@"INSERT INTO t_item (itemDict, idStr) VALUES (%@, %@)",dictData, itemDict[@"id"]];
}
//返回全部数据
+ (NSArray *)list {
    FMResultSet *set = [_db executeQuery:@"SELECT * FROM t_item"];
    NSMutableArray *list = [NSMutableArray array];
    while (set.next) {
        // 获得当前所指向的数据
        NSData *dictData = [set objectForColumnName:@"itemDict"];
        NSDictionary *dict = [NSKeyedUnarchiver unarchiveObjectWithData:dictData];
        [list addObject:[Item mj_objectWithKeyValues:dict]];
    }
    return list;
}
//取出某个范围内的数据
+ (NSArray *)listWithRange:(NSRange)range {
    NSString *SQL = [NSString stringWithFormat:@"SELECT * FROM t_item LIMIT %lu, %lu",range.location, range.length];
    FMResultSet *set = [_db executeQuery:SQL];
    NSMutableArray *list = [NSMutableArray array];
    while (set.next) {
        NSData *dictData = [set objectForColumnName:@"itemDict"];
        NSDictionary *dict = [NSKeyedUnarchiver unarchiveObjectWithData:dictData];
        [list addObject:[Item mj_objectWithKeyValues:dict]];
    }
    return list;
}
//通过一组数据的唯一标识判断数据是否存在
+ (BOOL)isExistWithId:(NSString *)idStr
{
    BOOL isExist = NO;
    FMResultSet *resultSet= [_db executeQuery:@"SELECT * FROM t_item where idStr = ?",idStr];
    while ([resultSet next]) {
        if([resultSet stringForColumn:@"idStr"]) {
            isExist = YES;
        }else{
            isExist = NO;
        }
    }
    return isExist;
}
@end
</code></pre>

<p>一些继承于XLDataService的子类的数据库存储和模型转换的逻辑代码</p>

<pre><code>#import "GetTableViewData.h"
#import "XLDataBase.h"
@implementation GetTableViewData
//重写父类方法
+ (id)modelTransformationWithResponseObj:(id)responseObj modelClass:(Class)modelClass {
    NSArray *lists = responseObj[@"data"][@"list"];
    NSMutableArray *array = [NSMutableArray array];
    for (NSDictionary *dict in lists) {
        [modelClass mj_setupReplacedKeyFromPropertyName:^NSDictionary *{
            return @{ @"ID" : @"id" };
        }];
        [array addObject:[modelClass mj_objectWithKeyValues:dict]];
        //通过idStr先判断数据是否存储过，如果没有，网络请求新数据存入数据库
        if (![XLDataBase isExistWithId:dict[@"id"]]) {
            //存数据库
            NSLog(@"存入数据库");
            [XLDataBase saveItemDict:dict];
        }
    }
    return array;
}
</code></pre>

<p>下面是一些控制器的代码实现：</p>

<pre><code>#import "ViewController.h"
#import "GetTableViewData.h"
#import "Item.h"
#import "XLDataBase.h"
#import "ItemCell.h"
#import "MJRefresh.h"
#define URL_TABLEVIEW @"https://api.108tian.com/mobile/v3/EventList?cityId=1&amp;step=10&amp;theme=0&amp;page=%lu"
@interface ViewController () {
    NSMutableArray *_dataArray;
    UITableView *_tableView;
    NSInteger _currentPage;//当前数据对应的page
}
@end
@implementation ViewController
#pragma mark Life cycle
- (void)viewDidLoad {
    [super viewDidLoad];
    // Do any additional setup after loading the view, typically from a nib.
    [self createTableView];
    _dataArray = [NSMutableArray array];
}
- (void)viewWillAppear:(BOOL)animated {
    [super viewWillAppear:animated];
    NSRange range = NSMakeRange(0, 10);
    //如果数据库有数据则读取，不发送网络请求
    if ([[XLDataBase listWithRange:range] count]) {
        [_dataArray addObjectsFromArray:[XLDataBase listWithRange:range]];
        NSLog(@"从数据库加载");
    }else{
        [self getTableViewDataWithPage:0];
    }
}
#pragma mark UI
- (void)createTableView {
    _tableView = [[UITableView alloc] initWithFrame:self.view.bounds];
    _tableView.delegate = self;
    _tableView.dataSource = self;
    _tableView.rowHeight = 100.0;
    [self.view addSubview:_tableView];
    _tableView.mj_header = [MJRefreshNormalHeader headerWithRefreshingBlock:^{
        [self loadNewData];
    }];
    _tableView.mj_footer = [MJRefreshAutoNormalFooter footerWithRefreshingBlock:^{
        [self loadMoreData];
    }];
}
#pragma mark GetDataSoure
- (void)getTableViewDataWithPage:(NSInteger)page {
    NSLog(@"发送网络请求！");
    NSString *url = [NSString stringWithFormat:URL_TABLEVIEW, page];
    [GetTableViewData getWithUrl:url param:nil modelClass:[Item class] responseBlock:^(id dataObj, NSError *error) {
        [_dataArray addObjectsFromArray:dataObj];
        [_tableView reloadData];
        [_tableView.mj_header endRefreshing];
        [_tableView.mj_footer endRefreshing];
    }];
}
- (void)loadNewData {
    NSLog(@"下拉刷新");
    _currentPage = 0;
    [_dataArray removeAllObjects];
    [self getTableViewDataWithPage:_currentPage];
}
- (void)loadMoreData {
    NSLog(@"上拉加载");
    _currentPage ++;
    NSRange range = NSMakeRange(_currentPage * 10, 10);
    if ([[XLDataBase listWithRange:range] count]) {
        [_dataArray addObjectsFromArray:[XLDataBase listWithRange:range]];
        [_tableView reloadData];
        [_tableView.mj_footer endRefreshing];
        NSLog(@"数据库加载%lu条更多数据",[[XLDataBase listWithRange:range] count]);
    }else{
        //数据库没更多数据时再网络请求
        [self getTableViewDataWithPage:_currentPage];
    }
}
#pragma mark UITableViewDataSource
- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section {
    return _dataArray.count;
}
- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {
    ItemCell *cell = [ItemCell itemCellWithTableView:tableView];
    cell.item = _dataArray[indexPath.row];
    return cell;
}
@end
</code></pre>

<p>最后附上代码的下载地址，重要的部分代码中都有相应的注释和文字打印，运行程序可以很直观的表现。</p>

<p><a href="https://github.com/ShelinShelin/OffLineCache.git">Demo</a></p>

<p>希望大家能提出一些意见，很乐意与大家互相交流。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2015/11/25/wang-shang-qing-qiu-feng-(feng-)zhuang/">阅读全文😘</a>
    </footer>
  




| <a href="/blog/2015/11/25/wang-shang-qing-qiu-feng-(feng-)zhuang/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/11/16/appqia-dun-liao-zen-yao-ban-%3F/">App卡顿了怎么办？</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><p><img src="/images/kadun001.jpg" title="Caption" ></p>

<p>在 VSync 信号到来后，系统图形服务会通过 CADisplayLink 等机制通知 App，App 主线程开始在 CPU 中计算显示内容，比如视图的创建、布局计算、图片解码、文本绘制等。</p>

<p>随后 CPU 会将计算好的内容提交到 GPU 去，由 GPU 进行变换、合成、渲染。随后 GPU 会把渲染结果提交到帧缓冲区去，等待下一次 VSync 信号到来时显示到屏幕上。</p>

<p>由于垂直同步的机制，如果在一个 VSync 时间内，CPU 或者 GPU 没有完成内容提交，则那一帧就会被丢弃，等待下一次机会再显示，而这时显示屏会保留之前的内容不变。这就是界面卡顿的原因。</p>

<p>从上面的图中可以看到，CPU 和 GPU 不论哪个阻碍了显示流程，都会造成掉帧现象。所以开发时，也需要分别对 CPU 和 GPU 压力进行评估和优化。</p>

<h2>CPU 资源消耗原因和解决方案</h2>

<h4>对象创建</h4>

<p>对象的创建会分配内存、调整属性、甚至还有读取文件等操作，比较消耗 CPU 资源。</p>

<p>尽量用轻量的对象代替重量的对象，可以对性能有所优化。</p>

<p>比如 CALayer 比 UIView 要轻量许多，那么不需要响应触摸事件的控件，用 CALayer 显示会更加合适。如果对象不涉及 UI 操作，则尽量放到后台线程去创建，但可惜的是包含有 CALayer 的控件，都只能在主线程创建和操作。通过 Storyboard 创建视图对象时，其资源消耗会比直接通过代码创建对象要大非常多，在性能敏感的界面里，Storyboard 并不是一个好的技术选择。</p>

<p>尽量推迟对象创建的时间，并把对象的创建分散到多个任务中去。尽管这实现起来比较麻烦，并且带来的优势并不多，但如果有能力做，还是要尽量尝试一下。如果对象可以复用，并且复用的代价比释放、创建新对象要小，那么这类对象应当尽量放到一个缓存池里复用。</p>

<h4>对象调整</h4>

<p>对象的调整也经常是消耗 CPU 资源的地方。</p>

<p>这里特别说一下 CALayer：</p>

<ul>
<li><p>CALayer 内部并没有属性，当调用属性方法时，它内部是通过运行时 resolveInstanceMethod 为对象临时添加一个方法，并把对应属性值保存到内部的一个 Dictionary 里，同时还会通知 delegate、创建动画等等，非常消耗资源。</p></li>
<li><p>UIView 的关于显示相关的属性（比如 frame/bounds/transform）等实际上都是 CALayer 属性映射来的，所以对 UIView 的这些属性进行调整时，消耗的资源要远大于一般的属性。对此你在应用中，应该尽量减少不必要的属性修改。</p></li>
</ul>


<p>当视图层次调整时，UIView、CALayer 之间会出现很多方法调用与通知，所以在优化性能时，应该尽量避免调整视图层次、添加和移除视图。</p>

<h4>对象销毁</h4>

<p>对象的销毁虽然消耗资源不多，但累积起来也是不容忽视的。通常当容器类持有大量对象时，其销毁时的资源消耗就非常明显。同样的，如果对象可以放到后台线程去释放，那就挪到后台线程去。这里有个小 Tip：把对象捕获到 block 中，然后扔到后台队列去随便发送个消息以避免编译器警告，就可以让对象在后台线程销毁了。</p>

<pre><code>NSArray *tmp = self.array;

self.array = nil;

dispatch_async(queue, ^{

    [tmp class];

});
</code></pre>

<h4>布局计算</h4>

<p>视图布局的计算是 App 中最为常见的消耗 CPU 资源的地方。如果能在后台线程提前计算好视图布局、并且对视图布局进行缓存，那么这个地方基本就不会产生性能问题了。</p>

<p>不论通过何种技术对视图进行布局，其最终都会落到对 UIView.frame/bounds/center 等属性的调整上。上面也说过，对这些属性的调整非常消耗资源，所以尽量提前计算好布局，在需要时一次性调整好对应属性，而不要多次、频繁的计算和调整这些属性。</p>

<h4>Autolayout</h4>

<ul>
<li>Autolayout 是苹果本身提倡的技术，在大部分情况下也能很好的提升开发效率，但是 Autolayout 对于复杂视图来说常常会产生严重的性能问题。随着视图数量的增长，Autolayout 带来的 CPU 消耗会呈指数级上升。具体数据可以看这个文章：<a href="http://pilky.me/36/%E3%80%82">http://pilky.me/36/%E3%80%82</a> 如果你不想手动调整 frame 等属性，你可以用一些工具方法替代（比如常见的 left/right/top/bottom/width/height 快捷属性），或者使用 ComponentKit、AsyncDisplayKit 等框架。</li>
</ul>


<h4>文本计算</h4>

<p>如果一个界面中包含大量文本（比如微博微信朋友圈等），文本的宽高计算会占用很大一部分资源，并且不可避免。如果你对文本显示没有特殊要求，可以参考下 UILabel 内部的实现方式：用 [NSAttributedString boundingRectWithSize:options:context:] 来计算文本宽高，用 -[NSAttributedString drawWithRect:options:context:] 来绘制文本。尽管这两个方法性能不错，但仍旧需要放到后台线程进行以避免阻塞主线程。</p>

<blockquote><p>注意：如果你用 CoreText 绘制文本，那就可以先生成 CoreText 排版对象，然后自己计算了，并且 CoreText 对象还能保留以供稍后绘制使用。</p></blockquote>

<h4>文本渲染</h4>

<p>屏幕上能看到的所有文本内容控件，包括 UIWebView，在底层都是通过 CoreText 排版、绘制为 Bitmap 显示的。常见的文本控件 （UILabel、UITextView 等），其排版和绘制都是在主线程进行的，当显示大量文本时，CPU 的压力会非常大。对此解决方案只有一个，那就是自定义文本控件，用 TextKit 或最底层的 CoreText 对文本异步绘制。尽管这实现起来非常麻烦，但其带来的优势也非常大，CoreText 对象创建好后，能直接获取文本的宽高等信息，避免了多次计算（调整 UILabel 大小时算一遍、UILabel 绘制时内部再算一遍）；CoreText 对象占用内存较少，可以缓存下来以备稍后多次渲染。</p>

<h4>图片的解码</h4>

<p>当你用 UIImage 或 CGImageSource 的那几个方法创建图片时，图片数据并不会立刻解码。图片设置到 UIImageView 或者 CALayer.contents 中去，并且 CALayer 被提交到 GPU 前，CGImage 中的数据才会得到解码。这一步是发生在主线程的，并且不可避免。如果想要绕开这个机制，常见的做法是在后台线程先把图片绘制到 CGBitmapContext 中，然后从 Bitmap 直接创建图片。目前常见的网络图片库都自带这个功能。</p>

<h4>图像的绘制</h4>

<p>图像的绘制通常是指用那些以 CG 开头的方法把图像绘制到画布中，然后从画布创建图片并显示这样一个过程。这个最常见的地方就是 [UIView drawRect:] 里面了。由于 CoreGraphic 方法通常都是线程安全的，所以图像的绘制可以很容易的放到后台线程进行。一个简单异步绘制的过程大致如下（实际情况会比这个复杂得多，但原理基本一致）：</p>

<pre><code>- (void)display {

    dispatch_async(backgroundQueue, ^{

    CGContextRef ctx = CGBitmapContextCreate(...);

    // draw in context...

    CGImageRef img = CGBitmapContextCreateImage(ctx);

    CFRelease(ctx);

    dispatch_async(mainQueue, ^{

        layer.contents = img;

    });

    });
}
</code></pre>

<h2>GPU 资源消耗原因和解决方案</h2>

<p>相对于 CPU 来说，GPU 能干的事情比较单一：接收提交的纹理（Texture）和顶点描述（三角形），应用变换（transform）、混合并渲染，然后输出到屏幕上。通常你所能看到的内容，主要也就是纹理（图片）和形状（三角模拟的矢量图形）两类。</p>

<h4>纹理的渲染</h4>

<p>所有的 Bitmap，包括图片、文本、栅格化的内容，最终都要由内存提交到显存，绑定为 GPU Texture。不论是提交到显存的过程，还是 GPU 调整和渲染 Texture 的过程，都要消耗不少 GPU 资源。当在较短时间显示大量图片时（比如 TableView 存在非常多的图片并且快速滑动时），CPU 占用率很低，GPU 占用非常高，界面仍然会掉帧。避免这种情况的方法只能是尽量减少在短时间内大量图片的显示，尽可能将多张图片合成为一张进行显示。</p>

<blockquote><p>注意：当图片过大，超过 GPU 的最大纹理尺寸时，图片需要先由 CPU 进行预处理，这对 CPU 和 GPU 都会带来额外的资源消耗。目前来说，iPhone 4S 以上机型，纹理尺寸上限都是 4096x4096，更详细的资料可以看这里：iosres.com。所以，尽量不要让图片和视图的大小超过这个值。</p></blockquote>

<h4>视图的混合 (Composing)</h4>

<p>当多个视图（或者说 CALayer）重叠在一起显示时，GPU 会首先把他们混合到一起。如果视图结构过于复杂，混合的过程也会消耗很多 GPU 资源。为了减轻这种情况的 GPU 消耗，应用应当尽量减少视图数量和层次，并在不透明的视图里标明 opaque 属性以避免无用的 Alpha 通道合成。当然，这也可以用上面的方法，把多个视图预先渲染为一张图片来显示。</p>

<h4>图形的生成</h4>

<p>CALayer 的 border、圆角、阴影、遮罩（mask），CASharpLayer 的矢量图形显示，通常会触发离屏渲染（offscreen rendering），而离屏渲染通常发生在 GPU 中。当一个列表视图中出现大量圆角的 CALayer，并且快速滑动时，可以观察到 GPU 资源已经占满，而 CPU 资源消耗很少。这时界面仍然能正常滑动，但平均帧数会降到很低。为了避免这种情况，可以尝试开启 CALayer.shouldRasterize 属性，但这会把原本离屏渲染的操作转嫁到 CPU 上去。对于只需要圆角的某些场合，也可以用一张已经绘制好的圆角图片覆盖到原本视图上面来模拟相同的视觉效果。最彻底的解决办法，就是把需要显示的图形在后台线程绘制为图片，避免使用圆角、阴影、遮罩等属性。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2015/11/16/appqia-dun-liao-zen-yao-ban-%3F/">阅读全文😘</a>
    </footer>
  




| <a href="/blog/2015/11/16/appqia-dun-liao-zen-yao-ban-%3F/#comments">更多评论</a>

    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/4">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/2">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
    <h1>文章分类</h1>
    <ul id="categories">
        <li class='category'><a href='/blog/categories/全栈工程师必备/'>全栈工程师必备 (2)</a></li>
<li class='category'><a href='/blog/categories/底层开发/'>底层开发 (4)</a></li>
<li class='category'><a href='/blog/categories/开发工具/'>开发工具 (2)</a></li>
<li class='category'><a href='/blog/categories/性能相关/'>性能相关 (7)</a></li>
<li class='category'><a href='/blog/categories/性能问题/'>性能问题 (4)</a></li>
<li class='category'><a href='/blog/categories/新技术/'>新技术 (1)</a></li>
<li class='category'><a href='/blog/categories/欢迎来到ios梦工厂/'>欢迎来到ios梦工厂 (1)</a></li>
<li class='category'><a href='/blog/categories/程序员必备/'>程序员必备 (7)</a></li>
<li class='category'><a href='/blog/categories/适配问题/'>适配问题 (1)</a></li>
<li class='category'><a href='/blog/categories/面试总结-技术/'>面试总结＋技术 (1)</a></li>
<li class='category'><a href='/blog/categories/面试汇总/'>面试汇总 (1)</a></li>
<li class='category'><a href='/blog/categories/项目实战/'>项目实战 (17)</a></li>
<li class='category'><a href='/blog/categories/高级开发/'>高级开发 (25)</a></li>

    </ul>
</section><section>
  <h1>最新文章</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/12/11/anquan/">安全机制</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/12/11/java/">爬虫必备-java抓包</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/12/11/pa-chong-bi-bei-phthonzhua-bao/">爬虫必备-Phthon抓包</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/12/11/zhengze/">爬虫必备-正则表达式抓包</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/12/11/qinghuaci/">爬虫必备-青花瓷</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/al1020119">@al1020119</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'al1020119',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>




<section>
<h1>扫一扫<abbr title="The word '扫一扫' is a registered trademark of DENSO WAVE INCORPORATED. It applies only for the word '扫一扫', not for image.">&trade;</abbr></h1>
<a href="http://al1020119.github.io/posts/3/index.html"><img src="http://chart.apis.google.com/chart?chs=150x150&cht=qr&chld=|0&chco=165B94&chl=http://al1020119.github.io/posts/3/index.html" alt="post-qrcode"></a></section>
<section>
    <h1>访客统计</h1>
    <br/>
    <a href="http://s07.flagcounter.com/more/2SH"><img src="http://s07.flagcounter.com/count/2SH/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_1/flags_0/" alt="Flag Counter" border="0"></a>
</section><section>
    <h1>新浪微博</h1>
    <ul id="weibo">
        <li>
            
            <!-- 在此插入获得的微博秀代码 -->
            <iframe width="100%" height="550" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=550&fansRow=2&ptype=1&speed=0&skin=1&isTitle=1&noborder=1&isWeibo=1&isFans=1&uid=3288975567&verifier=20ffcedd&dpc=1"></iframe>
            
        </li>
    </ul>
</section>
  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - iCocos -
<span class="credit">Preview in <a href="http://al1020119.github.io">[曹#黎]</a></span>
</p>

</footer>
  






<!--
--->



</body>
</html>
