
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>iOS梦工厂</title>
  <meta name="author" content="iCocos">

  
  <meta name="description" content="够逼格的注释习惯总结 首先关于注意这里就不说什么VVDocument了，来点新鲜的！ 也许你使用过#warning 警告提示 也许你也使用过#pragma marks。 但是你见过或者使用过下面这个吗？ Comments containing:
MARK:
TODO:
FIXME &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://al1020119.github.io/posts/3/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="iOS梦工厂" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//libs.baidu.com/jquery/1.7.2/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <script>
function addBlankTargetForLinks () {
    $('a[href^="http"]').each(function(){
                              $(this).attr('target', '_blank');
                              });
}
$(document).bind('DOMNodeInserted', function(event) {
             addBlankTargetForLinks();
             });
</script>
  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">iOS梦工厂</a></h1>
  
    <h2>不战胜自己，何以改变未来！</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="al1020119.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">首页</a></li>
  <li><a href="/blog/archives">归档</a></li>
  <li><a href="/icocos">iCocos</a></li>
  <li><a href="/other">其他</a></li>
  <li><a href="/about">关于</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/12/03/you-xiu-cheng-xu-yuan-shi-zen-yao-xie-zhu-shi-de/">够逼格的注释习惯</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><p>够逼格的注释习惯总结</p>

<p>首先关于注意这里就不说什么VVDocument了，来点新鲜的！</p>

<h6>也许你使用过#warning 警告提示</h6>

<h6>也许你也使用过#pragma marks。</h6>

<p>但是你见过或者使用过下面这个吗？</p>

<pre><code>Comments containing:
MARK:
TODO:
FIXME:
!!!:
???:
</code></pre>

<p>没有，那么你就快速的看看下面的内容，非常好用，也非常简单，不过具体使用看个人</p>

<p> 首先说一下三个最常用的：</p>

<ul>
<li>1、TODO</li>
</ul>


<p> 等待实现的功能</p>

<ul>
<li>2、FIXME</li>
</ul>


<p> 需要修正的功能</p>

<ul>
<li>3、！！！</li>
</ul>


<p> 需要改进的功能</p>

<p>具体使用</p>

<pre><code>// FIXME:sss
/* FIXME: sss */


// MARK:sss
/* MARK:sss */


// !!!:sss
/* !!!: sss */


// ???:sss
/* ???: sss */


// TODO:sss
/* TODO: sss */


// Comments containing: sss
/* Comments containing: sss */
</code></pre>

<p>注意空格.</p>

<p> 最后你会发现下面的效果，虽然和#pragma marks没有什么区别，但是这就是装逼原因</p>

<p>关于最后一个/<em> Comments containing: sss </em>/，笔者还没照发对应的使用方法，如果你知道可以联系我哦！</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2015/12/03/you-xiu-cheng-xu-yuan-shi-zen-yao-xie-zhu-shi-de/">阅读全文😘</a>
    </footer>
  




| <a href="/blog/2015/12/03/you-xiu-cheng-xu-yuan-shi-zen-yao-xie-zhu-shi-de/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/12/03/nian-tie-shen-jiu/">粘贴深究</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><p>在iOS中，可以使用剪贴板实现应用程序之中以及应用程序之间实现数据的共享。比如你可以从iPhone QQ复制一个url，然后粘贴到safari浏览器中查看这个链接的内容。</p>

<h3>一、在iOS中下面三个控件，自身就有复制-粘贴的功能：</h3>

<ul>
<li>1、UITextView</li>
<li>2、UITextField</li>
<li>3、UIWebView</li>
</ul>


<h3>二、UIKit framework提供了几个类和协议方便我们在自己的应用程序中实现剪贴板的功能。</h3>

<ul>
<li>1、UIPasteboard：我们可以向其中写入数据，也可以读取数据</li>
<li>2、UIMenuController：显示一个快捷菜单，用来复制、剪贴、粘贴选择的项。</li>
<li>3、UIResponder中的 canPerformAction:withSender:用于控制哪些命令显示在快捷菜单中。</li>
<li>4、当快捷菜单上的命令点击的时候，UIResponderStandardEditActions将会被调用。</li>
</ul>


<h3>三、下面这些项能被放置到剪贴板中</h3>

<ul>
<li>1、UIPasteboardTypeListString —  字符串数组, 包含kUTTypeUTF8PlainText</li>
<li>2、UIPasteboardTypeListURL —   URL数组，包含kUTTypeURL</li>
<li>3、UIPasteboardTypeListImage —   图形数组, 包含kUTTypePNG 和kUTTypeJPEG</li>
<li>4、UIPasteboardTypeListColor —   颜色数组</li>
</ul>


<h3>四、剪贴板的类型分为两种：</h3>

<p>系统级：使用UIPasteboardNameGeneral和UIPasteboardNameFind创建，系统级的剪贴板，当应用程序关闭，或者卸载时，数据都不会丢失。
应用程序级：通过设置，可以让数据在应用程序关闭之后仍然保存在剪贴板中，但是应用程序卸载之后数据就会失去。我们可用通过pasteboardWithName:create：来创建。</p>

<p>了解这些之后，下面通过一系列的例子来说明如何在应用程序中使用剪贴板。</p>

<p>例子：</p>

<h5>1、复制剪贴文本。</h5>

<pre><code>下面通过一个例子，可以在tableview上显示一个快捷菜单，上面只有复制按钮，复制tableview上的数据之后，然后粘贴到title上。
</code></pre>

<p>定义一个单元格类CopyTableViewCell，在这个类的上显示快捷菜单，实现复制功能。</p>

<pre><code>@interface CopyTableViewCell : UITableViewCell {
    id delegate;
}
@property (nonatomic, retain) id delegate;
@end
</code></pre>

<p>实现CopyTableViewCell ：</p>

<pre><code>#import "CopyTableViewCell.h"

@implementation CopyTableViewCell

@synthesize delegate;

- (id)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier {
    if ((self = [super initWithStyle:style reuseIdentifier:reuseIdentifier])) {
    }
    return self;
}
- (void)setSelected:(BOOL)selected animated:(BOOL)animated {
    [super setSelected:selected animated:animated];
}
- (void)setHighlighted:(BOOL)highlighted animated:(BOOL)animated {
    [[self delegate] performSelector:@selector(showMenu:)
                          withObject:self afterDelay:0.9f];

    [super setHighlighted:highlighted animated:animated];

}
- (BOOL)canBecomeFirstResponder
{
    return YES;
}
- (BOOL)canPerformAction:(SEL)action withSender:(id)sender{
    if (action == @selector(cut:)){
        return NO;
    }
    else if(action == @selector(copy:)){
        return YES;
    }
    else if(action == @selector(paste:)){
        return NO;
    }
    else if(action == @selector(select:)){
        return NO;
    }
    else if(action == @selector(selectAll:)){
        return NO;
    }
    else
    {
        return [super canPerformAction:action withSender:sender];
    }
}
- (void)copy:(id)sender {
    UIPasteboard *pasteboard = [UIPasteboard generalPasteboard];
    [pasteboard setString:[[self textLabel]text]];
}
- (void)dealloc {
    [super dealloc];
}
@end
</code></pre>

<p>复制代码
定义CopyPasteTextController，实现粘贴功能。
    @interface CopyPasteTextController : UIViewController<UITableViewDelegate> {
        //用来标识是否显示快捷菜单
        BOOL menuVisible;
        UITableView *tableView;
    }</p>

<pre><code>@property (nonatomic, getter=isMenuVisible) BOOL menuVisible;

@property (nonatomic, retain) IBOutlet UITableView *tableView;
@end
</code></pre>

<p>实现CopyPasteTextController ：</p>

<pre><code>#import "CopyPasteTextController.h"
#import "CopyTableViewCell.h"

@implementation CopyPasteTextController
@synthesize menuVisible,tableView;
- (void)viewDidLoad {
    [super viewDidLoad];
    [self setTitle:@"文字复制粘贴"];
    //点击这个按钮将剪贴板的内容粘贴到title上
    UIBarButtonItem *addButton = [[[UIBarButtonItem alloc]
                                      initWithBarButtonSystemItem:UIBarButtonSystemItemRefresh
                                      target:self
                                      action:@selector(readFromPasteboard:)]
                                     autorelease];
    [[self navigationItem] setRightBarButtonItem:addButton];
}


// Customize the number of sections in the table view.
- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView
{
    return 1;
}

- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section
{
    return 9;
}

// Customize the appearance of table view cells.
- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath
{
    static NSString *CellIdentifier =@"Cell";
    CopyTableViewCell *cell = (CopyTableViewCell *)[tableView
                                                           dequeueReusableCellWithIdentifier:CellIdentifier];
    if (cell == nil)
    {
        cell = [[[CopyTableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:CellIdentifier] autorelease];
        [cell setDelegate:self];
    }

    // Configure the cell.
    NSString *text = [NSString stringWithFormat:@"Row %d", [indexPath row]];
    [[cell textLabel] setText:text];
    return cell;
}

- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath
{
    if([self isMenuVisible])
    {
        return;
    }
    [[[self tableView] cellForRowAtIndexPath:indexPath] setSelected:YES
                                                           animated:YES];
}
//显示菜单
- (void)showMenu:(id)cell {
    if ([cell isHighlighted]) {
        [cell becomeFirstResponder];

        UIMenuController * menu = [UIMenuController sharedMenuController];
        [menu setTargetRect: [cell frame] inView: [self view]];
        [menu setMenuVisible: YES animated: YES];
    }
}
- (void)readFromPasteboard:(id)sender {
    [self setTitle:[NSString stringWithFormat:@"Pasteboard = %@",
                      [[UIPasteboard generalPasteboard] string]]];
}

- (void)didReceiveMemoryWarning
{
    // Releases the view if it doesn't have a superview.
    [super didReceiveMemoryWarning];

    // Relinquish ownership any cached data, images, etc that aren't in use.
}

- (void)viewDidUnload
{
    [super viewDidUnload];
    [self.tableView release];

    // Relinquish ownership of anything that can be recreated in viewDidLoad or on demand.
    // For example: self.myOutlet = nil;
}
</code></pre>

<p>复制一行数据：
点击右上角的按钮粘贴，将数据显示在title上：</p>

<h6>2、图片复制粘贴</h6>

<p>   下面通过一个例子，将图片复制和剪贴到另外一个UIImageView中间。</p>

<ul>
<li>1、在界面上放置两个uiimageview，一个是图片的数据源，一个是将图片粘贴到的地方。CopyPasteImageViewController 代码如下：</li>
</ul>


<p>@interface CopyPasteImageViewController : UIViewController {
    UIImageView <em>imageView;
    UIImageView </em>pasteView;
    UIImageView <em>selectedView;
}
@property (nonatomic, retain) IBOutlet UIImageView </em>imageView;
@property (nonatomic, retain) IBOutlet UIImageView <em>pasteView;
@property (nonatomic, retain) UIImageView </em>selectedView;
- (void)placeImageOnPasteboard:(id)view;
@end
* 2、当触摸图片的时候我们显示快捷菜单：</p>

<hr />

<pre><code>- (void)touchesBegan:(NSSet*)touches withEvent:(UIEvent*)event {
    NSSet *copyTouches = [event touchesForView:imageView];
    NSSet *pasteTouches = [event touchesForView:pasteView];

    [self becomeFirstResponder];
    if ([copyTouches count] &gt; 0) {
        [self performSelector:@selector(showMenu:)
                   withObject:imageView afterDelay:0.9f];
    }
    else  if([pasteTouches count] &gt; 0) {
        [self performSelector:@selector(showMenu:)
                   withObject:pasteView afterDelay:0.9f];
    }
    [super touchesBegan:touches withEvent:event];
}

- (void)showMenu:(id)view {
    [self setSelectedView:view];

    UIMenuController * menu = [UIMenuController sharedMenuController];
    [menu setTargetRect: CGRectMake(5, 10, 1, 1) inView: view];
    [menu setMenuVisible: YES animated: YES];
}
</code></pre>

<p>这里的快捷菜单，显示三个菜单项：剪贴、粘贴、复制：</p>

<hr />

<pre><code>- (BOOL)canPerformAction:(SEL)action withSender:(id)sender{
    if (action == @selector(cut:)) {
        return ([self selectedView] == imageView) ? YES : NO;
    } else if (action == @selector(copy:)) {
        return ([self selectedView] == imageView) ? YES : NO;
    } else if (action == @selector(paste:)) {
        return ([self selectedView] == pasteView) ? YES : NO;
    } else if (action == @selector(select:)) {
        return NO;
    } else if (action == @selector(selectAll:)) {
        return NO;
    } else {
        return [super canPerformAction:action withSender:sender];
    }
}
- (void)cut:(id)sender {
    [self copy:sender];
    [imageView setHidden:YES];
}
- (void)copy:(id)sender {
    [self placeImageOnPasteboard:[self imageView]];
}
- (void)paste:(id)sender {
    UIPasteboard *appPasteBoard =
    [UIPasteboard pasteboardWithName:@"CopyPasteImage" create:YES];
    NSData *data =[appPasteBoard dataForPasteboardType:@"com.marizack.CopyPasteImage.imageView"];
    pasteView.image = [UIImage imageWithData:data];
}
</code></pre>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2015/12/03/nian-tie-shen-jiu/">阅读全文😘</a>
    </footer>
  




| <a href="/blog/2015/12/03/nian-tie-shen-jiu/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/12/02/xiao-chu-jing-gao/">消除警告</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><h6>前言：</h6>

<p>现在你维护的项目有多少警告？看着几百条警告觉得心里烦么？你真的觉得警告又不是错误可以完全不管么？ 如果你也被这些问题困惑，可以和我一起进行下面的操作。其实大部分的警告都是很好改的，把自己整个项目的警告撸一遍应该也就耗费半小时的时间，一次麻烦带来之后的清净这样不好么？</p>

<p>本文分为三个部分：</p>

<ul>
<li>1.简单粗暴的消除警告。</li>
<li>2.详细科学的消除警告。（包括警告收录）</li>
<li>3.添加警告。</li>
</ul>


<h4>一、简单粗暴的消除警告</h4>

<p>警告如果是自己项目中的还好直接改了，如果是第三方库，你改了之后，pod下作者更新一下又白改了，所以可以用这种简单粗暴的方法：直接让第三方库的警告不显示</p>

<p> 就是在podfile文件里面加上一行指令 。
inhibit_all_warnings!
如果某警告实在无法消除，但是又不想让他显示，可以加入预编译指令</p>

<p>比如我已经知道某行会报上面警告了，我就用这个宏把这几行包住，就不会报引号中-Wunused-variable的警告了</p>

<pre><code>#pragma clang diagnostic push
#pragma clang diagnostic ignored"-Wunused-variable" //这里是会报警告的代码

#pragma clang diagnostic pop
</code></pre>

<p>这个-Wunused-variable代表的意思就是 有的东西 你实例化了但是没有使用（同上面第几条）。 但是如何得到一个警告的标示符？</p>

<ol>
<li><p>如图选择一个警告，点击右键，reveal in log  就能看到右边有个方括号[]里面的东西就是 这个警告对应的标示符</p></li>
<li><p>如果希望整个项目中都忽略 某种很无聊的警告，就在项目中Build Setting里加上这个标示符，可以连着加的。</p></li>
<li><p>如果不想整个项目都忽略，只想个别文件忽略，那就找到个别文件加上此指令，这个操作应该使用率不高（一般都是全项目忽略），就不上图了。去Build Phases 里面的 Compile Sources里面改。</p></li>
</ol>


<h4>二、详细科学的消除警告</h4>

<p>其实笔者本意是想把一些第一眼看不懂比较坑的警告收录进来，但是后来发现那基本没几个需要些写了，所以就采用了全收录的方法，遇到的就记录下以后也会不断更新。 可以直接按command+F 在本页面搜索警告</p>

<pre><code>Unused variable 'replyURL'
</code></pre>

<h6>1.没有使用</h6>

<pre><code>Cannot find protocol definition for 'TencentSessionDelegate'
</code></pre>

<h6>2.这种明明都能运行还说我没有定义的警告，是因为你这个协议虽然定义了，但是你这个协议可能还遵守了XX协议，然后这个XX协议没有定义导致会报这种警告，所以遇到这种警告要往“父协议”找。 举个栗子，上面这行就是腾讯授权的库里面报的警告，</h6>

<pre><code>@protocol TencentSessionDelegate
此协议遵守了TencentApiInterfaceDelegate协议，在TencentOAuth.h类中#import "TencentApiInterface.h" 警告可破


Null passed to a callee that requires a non-null argument
</code></pre>

<h6>3.这个警告比较新，是xcode6.3开始 为了让OC也能有swift的？和！的功能，你在声明一个属性的时候加上 <strong>nullable（？可以为空）与</strong>nonnull（！不能为空） 如果放在@property里面的话不用写下划线</h6>

<pre><code>@property (nonatomic, copy, nonnull) NSString * tickets;
@property (nonatomic, copy) NSString * __nonnull tickets;
</code></pre>

<p>或者用宏NS_ASSUME_NONNULL_BEGIN和NS_ASSUME_NONNULL_END 包住多个属性全部具备nonnull，然后仅对需要nullable的改下就行，有点类似于f-no-objc-arc那种先整体给个路线在单独改个别文件的思想。 此警告就是某属性说好的不能为空，你又在某地方写了XX = nil 所以冲突了。</p>

<pre><code>Auto property synthesis will not synthesize property 'privateCacheDirectory'; it will be implemented by its superclass, use @dynamic to acknowledge intention
</code></pre>

<h6>4.他说你的父类实现了setget方法，但是如果你什么都不写，就会系统自动生成出最一般的setget方法，请用@dynamic 来承认父类实现的这个getset方法。</h6>

<pre><code>Unsupported Configuration: Scene is unreachable due to lack of entry points and does not have an identifier for runtime access via -instantiateViewControllerWithIdentifier:.
</code></pre>

<h6>5.一般是storyboard报的警告，简而言之就是你有的页面没有和箭头所指的控制器连起来，导致最终改页面可能无法显示。</h6>

<pre><code>Deprecated: Push segues are deprecated in iOS 8.0 and later
</code></pre>

<h6>6.iOS8之后呢，不要再用push拖线了，统一用show，他会自己根据你是否有导航栏来判断走push还是走modal</h6>

<pre><code>Unsupported Configuration: Plain Style unsupported in a Navigation Item
</code></pre>

<h6>7.导航栏的item 不支持用plain ，那就用Bordered呗。</h6>

<pre><code>The launch image set "LaunchImage" has 2 unassigned images.
The app icon set "AppIcon" has 2 unassigned images.
</code></pre>

<h6>8.几张图标还是启动图找不到自己的位置，可能是一次导入了全部尺寸图片，但是右边的设置只勾了iOS8的 那iOS7尺寸的图标就会报此警告。删掉，或者对照右边匹配。</h6>

<pre><code>'sizeWithFont:constrainedToSize:lineBreakMode:' is deprecated: first deprecated in iOS 7.0 - Use -boundingRectWithSize:options:attributes:context:
</code></pre>

<h6>9.方法废除，旧的方法sizeWithFontToSize在iOS7后就废除了取而代之是boundingRectWithSize方法</h6>

<pre><code>Undeclared selector 'historyAction'
</code></pre>

<h6>10.使用未声明的方法，一般出现在@selector() 括号里写了个不存在的方法或方法名写错了。</h6>

<pre><code>PerformSelector may cause a leak because its selector is unknown
</code></pre>

<h6>11.这个和上面类似就是直接把上面那个@SEL拿来用会报这个警告</h6>

<pre><code>'strongify' macro redefined
</code></pre>

<h6>12.这个宏声明重复,删一个吧</h6>

<pre><code>'UITextAttributeFont' is deprecated: first deprecated in iOS 7.0 - Use NSFontAttributeName
'UITextAttributeTextColor' is deprecated: first deprecated in iOS 7.0 - Use NSForegroundColorAttributeName
'UITextAttributeTextShadowColor' is deprecated: first deprecated in iOS 7.0 - Use NSShadowAttributeName with an NSShadow instance as the value
</code></pre>

<h6>13.方法废除,一般一起出现</h6>

<pre><code>Code will never be executed
</code></pre>

<h6>14.他说这代码永远也轮不到他执行，估计是有几行代码写在了return之后</h6>

<pre><code>Assigning to 'id' from incompatible type 'SXTabViewController *const __strong'
</code></pre>

<h6>15.一般出现在xxx.delegate = self ，应该在上面遵守协议</h6>

<pre><code>Format specifies type 'unsigned long' but the argument has type 'unsigned int'
</code></pre>

<h6>16.这个警告一般会出现在NSStringWithFormat里面 前面%d %lu 什么的和后面填进去的参数不匹配就报了警告</h6>

<pre><code>Values of type 'NSInteger' should not be used as format arguments; add an explicit cast to 'long' instead
</code></pre>

<h6>17.类似于上面，也是format里面前后写的不匹配</h6>

<pre><code>Method 'dealWithURL:andTitle:andKeyword:' in protocol 'SXPostAdDelegate' not implemented
</code></pre>

<h6>18.经典警告，遵守了协议，但是没有实现协议方法。 也可能你实现了只是又加了个参数或是你写的方法和协议方法名字有点轻微不同</h6>

<pre><code>Using integer absolute value function 'abs' when argument is of floating point type
</code></pre>

<h6>19.这个可以自动修正，就是说abs适用于整数绝对值，要是float取绝对值要用fabsf</h6>

<pre><code>Attribute Unavailable: Automatic Preferred Max Layout Width is not available on iOS versions prior to 8.0
</code></pre>

<h6>20.有的方法你用的太落后了，也有的方法你用的太超前了。 说这个最大宽度在iOS8之前的系统是要坑的</h6>

<pre><code>Too many personality routines for compact unwind to encode
</code></pre>

<h6>21.你可以在otherlink 中加入 -Wl,-no_compact_unwind 去掉该警告，根据苹果的解释，这个是由于某些地方 c/c++/oc/oc++混用会造成编译警告。一般没有什么伤害。</h6>

<pre><code>Property 'ssid' requires method 'ssid' to be defined - use @synthesize, @dynamic or provide a method implementation in this class implementation
</code></pre>

<h6>22.说这个ssid必须要定义个这个属性的getter方法，如果警告是setSsid就是setter方法， 用@synthesize和@dynamic 都行，一个是让编译器生成getter和setter，一个是自己生成，如果你有模型分发或kvc之类的，选@dynamic就行</h6>

<pre><code>Unknown escape sequence '\)'
</code></pre>

<h6>23.未知的转义序列。 一般有个斜杠再加个东西他都会以为是转义字符，一看\）不认识就报警告了，一般正则表达式容易报这种警告</h6>

<pre><code>Property 'LoginPort' not found on object of type 'LoginLvsTestTask *'; did you mean to access property loginPort?
</code></pre>

<h6>24.这种可以点击自动修复，是典型的大小写写错了，他提醒了一下。</h6>

<pre><code>Variable 'type' is used uninitialized whenever switch default is taken
</code></pre>

<h6>25.这是出现在switch语句中的警告， 一般可能是switch外面定义了个type但是并没有初始化（初始化操作都写在switch的各个分支里），然后在最后return type。 但是switch的有个分支没有对type初始化，他说如果你来到这个分支的话，那还没初始化就要被return。</h6>

<h5>三、添加警告</h5>

<h6>1.首先最常用的就是 普通警告，这也没什么好说的了</h6>

<pre><code>#warning TODO
</code></pre>

<h6>2.如果是自己写的文件或第三方库，有了新的接口，然后提示旧的接口废除的话需要在方法后加上宏NS_DEPRECATED_IOS和范围</h6>

<pre><code>- (void)addTapAction:(SEL)tapAction target:(id)target NS_DEPRECATED_IOS(2_0, 4_0);
</code></pre>

<h6>3.如果需要在此方法后加上带信息的警告则需要这么写</h6>

<pre><code>- (void)addTapAction:(SEL)tapAction target:(id)target __attribute((deprecated("这个接口会爆内存 不建议使用")));
</code></pre>

<p>显示的效果像这样：</p>
</div>
  
  




| <a href="/blog/2015/12/02/xiao-chu-jing-gao/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/12/02/quan-ping-fan-hui-(runtime)/">全屏返回（Runtime）</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><blockquote><p>前言</p>

<p>此次文章，讲述的是导航控制器全屏滑动返回效果，而且代码量非常少，10行内搞定。</p></blockquote>

<p>如果喜欢我的文章，可以关注我，也可以来小码哥，了解下我们的iOS培训课程。陆续还会有更新ing&hellip;.</p>

<h5>一、自定义导航控制器</h5>

<p>目的：以后需要使用全屏滑动返回功能，就使用自己定义的导航控制器。</p>

<h5>二、分析导航控制器侧滑功能</h5>

<p>效果：导航控制器默认自带了侧滑功能，当用户在界面的左边滑动的时候，就会有侧滑功能。</p>

<p>系统自带的侧滑效果：</p>

<p>分析：</p>

<ul>
<li><p>1.导航控制器的view自带了滑动手势，只不过手势的触发范围只能在左边。</p></li>
<li><p>2.当用户在界面左边拖动，就会触发滑动手势方法，并且有滑动返回功能，说明系统手势触发的方法已经实现了滑动返回功能。</p></li>
<li><p>3.为什么说系统手势触发的方法已经实现了滑动返回功能？</p></li>
</ul>


<h3>原因：</h3>

<p>创建滑动手势对象的时候，需要绑定监听者，当触发手势的时候会调用target的action。</p>

<p>UIPanGestureRecognizer *pan = [[UIPanGestureRecognizer alloc] initWithTarget:target action:action];
当用户在界面左边滑动，有滑动返回功能，这是因为触发手势了，调用target的action方法，说明action方法内部实现滑动返回功能，否则就不会有滑动返回效果。</p>

<h5>三、实现全屏滑动功能分析</h5>

<p>打印导航控制器自带的滑动手势，看下它的真实面目。</p>

<p>系统自带的滑动手势interactivePopGestureRecognizer</p>

<pre><code>//  self指向的导航控制器，在导航控制器的viewDidLoad方法打印 
- (void)viewDidLoad { 
    [super viewDidLoad]; 
    NSLog(@"%@",self.interactivePopGestureRecognizer); 
} 
</code></pre>

<p>由图中可知：</p>

<ul>
<li><p>1.系统自带的手势是UIScreenEdgePanGestureRecognizer类型对象,屏幕边缘滑动手势</p></li>
<li><p>2.系统自带手势target是_UINavigationInteractiveTransition类型的对象</p></li>
<li><p>3.target调用的action方法名叫handleNavigationTransition:</p></li>
</ul>


<p>分析：</p>

<p>UIScreenEdgePanGestureRecognizer，看名称就知道，这个手势的范围只能在屏幕的周边，就是因为这个手势，系统自带的滑动效果，只能实现侧边滑动。</p>

<h5>四、如何实现全屏滑动功能</h5>

<p>给自己的导航控制器，添加一个全屏的滑动手势，调用系统自带滑动手势的target的action方法，利用系统实现的滑动返回功能，加上自己全屏滑动手势，就有全屏滑动功能了。</p>

<p>问题：如何拿到系统自带的target对象?，action方法名已经知道，而且系统肯定在target对象实现了，只要拿到target对象，调用这个方法就行。</p>

<p>通过打印系统自带的滑动手势的代理，发现正好是_UINavigationInteractiveTransition对象，因此我猜测这个代理对象就是target对象,只要拿到它，就拿到系统自带滑动手势的target对象。</p>

<pre><code>// 打印系统自带滑动手势的代理对象 
SLog(@"%@",self.interactivePopGestureRecognizer.delegate); 
</code></pre>

<p>导航控制器全屏滑动注意点:</p>

<ul>
<li><p>1.禁止系统自带滑动手势使用。</p></li>
<li><p>2.只有导航控制器的非根控制器才需要触发手势，使用手势代理，控制手势触发。</p></li>
</ul>


<p>全屏滑动代码实现</p>

<pre><code>- (void)viewDidLoad { 
    [super viewDidLoad]; 
    // 获取系统自带滑动手势的target对象 
    id target = self.interactivePopGestureRecognizer.delegate; 
    // 创建全屏滑动手势，调用系统自带滑动手势的target的action方法 
    UIPanGestureRecognizer *pan = [[UIPanGestureRecognizer alloc] initWithTarget:target action:@selector(handleNavigationTransition:)]; 
    // 设置手势代理，拦截手势触发 
    pan.delegate = self; 
    // 给导航控制器的view添加全屏滑动手势 
    [self.view addGestureRecognizer:pan]; 
    // 禁止使用系统自带的滑动手势 
    self.interactivePopGestureRecognizer.enabled = NO; 
} 
// 什么时候调用：每次触发手势之前都会询问下代理，是否触发。 
// 作用：拦截手势触发 
- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer 
{ 
    // 注意：只有非根控制器才有滑动返回功能，根控制器没有。 
    // 判断导航控制器是否只有一个子控制器，如果只有一个子控制器，肯定是根控制器 
    if (self.childViewControllers.count == 1) { 
        // 表示用户在根控制器界面，就不需要触发滑动手势， 
        return NO; 
    } 
    return YES; 
} 
</code></pre>
</div>
  
  




| <a href="/blog/2015/12/02/quan-ping-fan-hui-(runtime)/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/12/02/qie-huan-kong-zhi-qi/">切换控制器</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><p>从一个视图控制器切换到另一个视图控制器的几种方式</p>

<h4>1,模态(modal)画面的显示方法：</h4>

<p>例如iphone通讯录管理程序中，追加新的通讯纪录时，就是使用这种模态画面
例：点击一个按钮，进入另一个界面
    - (IBAction)pressAbout:(id)sender {</p>

<pre><code>iCocosViewController *iCocos=[[[iCocosViewController alloc] initWithNibName:@"iCocosViewController" bundle:nil] autorelease];

[self presentModalViewController:aboutanimated:YES];//显示模态画面

关闭模态画面的方法：

[self dissmissModalViewControllerAnimationed:YES];
</code></pre>

<h4>2,SwitchViewController中有2个控制器的属性：BviewController,CViewController</h4>

<ul>
<li>使用方法：insertSubview: atIndex:
这种画面跳转方法并非最佳的跳转方法：</li>
<li>实际上并非真的实现了两个画面间的跳转，而是同时启动了2个画面，控制其中哪一个画面显示在前台，哪一个画面显示在后台而已。</li>
<li>这种画面跳转方式有一个很大的缺点，即当画面数量增加时，画面跳转的实现代码将月来越复杂，而且各个画面间不可避免的有相互依赖关系。</li>
</ul>


<h4>3,UITabBarController实现并列画面跳转（这里其实就是window的切花）</h4>

<pre><code>//将5个viewController实例放入TabBar的viewcontrollers属性中    

self.tabBarController.viewControllers = @[navFrist, navSecond,navThird,navFourth,navFifth];   

self.window.rootViewController = self.tabBarController;

[self.window addSubview:self.tabBarController.view];//将根控制器的视图加到应用程序主窗口
</code></pre>

<h4>4,UINavigationController实现多层画面跳转，在导航控制器中，载入有层级关系的界面</h4>

<pre><code>- (IBAction)addRightAction:(id)sender
{
    iCocosViewController *iCocos=[[[iCocosViewController alloc]initWithNibName:@"iCocosViewController" bundle:nil] autorelease];

[self.navigationController pushViewController:aiCocos animated:YES];
}
</code></pre>
</div>
  
  




| <a href="/blog/2015/12/02/qie-huan-kong-zhi-qi/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/12/01/zi-dian-zhuan-mo-xing-shen-jiu/">字典转模型深究</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><blockquote><p>引言：
在文字开始之前先介绍两个软件：</p></blockquote>

<h5>JSONExport</h5>

<p><img src="/images/zidianzhuanmoxin005.png" title="Caption" ></p>

<h5>JSON Accelerator</h5>

<p><img src="/images/zidianzhuanmoxin006.png" title="Caption" ></p>

<blockquote><p>关于模型类的两个神器，我也是刚接触不久，但是感觉非常有用，基本上可以节省你在模型类上的99%的时间。</p></blockquote>

<ul>
<li>如果你觉得自己对应本文后面的内容非常了解，那么请直接下载上面的软件试试。</li>
<li>如果你并不是很熟练，那么轻认真看完后面的内容，相信对你有好处，再去下载对应的软件。</li>
</ul>


<p>关于Plist转模型在iOS开发中是非常常见的，每开一一个项目或者实现一个功能都要用到它，所以今天就给大家讲讲Plist怎么转成模型数据，</p>

<blockquote><p>前提：必须有一个Plist文件或者通过一定的方式返回的plist数据</p></blockquote>

<h2>一：直接加载Plist数据</h2>

<p><img src="/images/zidianzhuanmoxin001.png" title="Caption" ></p>

<pre><code>定义一个数组属性 
@property (nonatomic, assign) NSArray *apps; 
</code></pre>

<h6>获取Plist文件</h6>

<pre><code>//懒加载plist文件，返回一个apps数据，后面直接使用旧可以
-(NSArray *)apps
{
    if (_apps == nil) {
        _apps = [NSArray arrayWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@"iCocos.plist" ofType:nil]];
    }
    return _apps;
}
</code></pre>

<h6>加载Plsit中的数据</h6>

<pre><code>    //取出数组中对应的数据放到一个字典里面
    NSDictionary *dic = self.apps[i];


    //创建一个UIImageView
    UIImageView *icon = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, iW, 50)];
    /**
     取出字典中的icon
    */
     icon.image = [UIImage imageNamed:dic[@"icon"]];

    [view addSubview:icon];



    //创建一个Label
    UILabel *l = [[UILabel alloc] initWithFrame:CGRectMake(0, CGRectGetMaxY(icon.frame), iW, 20)];
    /**
     取出字典中的label
     */
    l.text = dic[@"label"];

    [view addSubview:l];



    //创建一个按钮
    UIButton *btn = [[UIButton alloc] initWithFrame:CGRectMake(0, CGRectGetMaxY(l.frame), iW, 20)];
    /**
     取出字典中的btn
     */
    [btn setTitle:dic[@"btn"] forState:UIControlStateNormal];

    [view addSubview:btn];
</code></pre>

<h2>二：使用简单的模型加载Plist数据</h2>

<p><img src="/images/zidianzhuanmoxin002.png" title="Caption" ></p>

<pre><code> 1 //定义一个数组属性

  2 @property (nonatomic, assign) NSArray *apps; 
</code></pre>

<h6>在模型中定义模型对应的属性</h6>

<pre><code>@property (nonatomic, copy) NSString *icon;


@property (nonatomic, copy) NSString *label;


@property (nonatomic, copy) NSString *btn;
</code></pre>

<h6>模型方法</h6>

<pre><code>/**
 模型数据方法
 */
+(instancetype)messageWithDict:(NSDictionary *)dict;


-(instancetype)initWithDict:(NSDictionary *)dict;
</code></pre>

<h6>模型的实现文件</h6>

<pre><code>/**
 模型数据方法的实现
 */

+ (instancetype)messageWithDict:(NSDictionary *)dict
{
    return [[self alloc] initWithDict:dict];
}

- (instancetype)initWithDict:(NSDictionary *)dict
{
    if (self = [super init]) {
        [self setValuesForKeysWithDictionary:dict];
    }
    return self;
}
</code></pre>

<h6>实用模型加载Plist文件</h6>

<pre><code>/**
 模型数据的加载，返回arry以后我们就只要使用array就能使用这个模型类里面的数据也就是使用plist数据
 */
//懒加载plist文件，返回一个apps数据，后面直接使用旧可以
-(NSMutableArray *)apps
{
    if (_apps == nil) {
        NSArray *array = [NSArray arrayWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@"iCocos.plist" ofType:nil]];

        NSMutableArray *arrayApps = [NSMutableArray array];

        for (NSDictionary *dic in array) {
            appsModel *model = [[appsModel alloc] init];
            model.label = dic[@"label"];
            model.btn = dic[@"btn"];
            model.icon = dic[@"icon"];

            [arrayApps addObject:model];
        }
        _apps = arrayApps;
    }
    return _apps;
}
</code></pre>

<h6>加载模型中对应的plist数据</h6>

<pre><code>    //取出数组中对应的数据放到一个字典里面
    appsModel *app = self.apps[i];


    //创建一个UIImageView
    UIImageView *icon = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, iW, 50)];
    /**
     取出字典中的icon
     */
    icon.image = [UIImage imageNamed:app.icon];
    [view addSubview:icon];



    //创建一个Label
    UILabel *l = [[UILabel alloc] initWithFrame:CGRectMake(0, CGRectGetMaxY(icon.frame), iW, 20)];
    /**
     取出字典中的label
     */
    l.text = app.label;
    [view addSubview:l];



    //创建一个按钮
    UIButton *btn = [[UIButton alloc] initWithFrame:CGRectMake(0, CGRectGetMaxY(l.frame), iW, 20)];
    /**
     取出字典中的btn
     */
    [btn setTitle:app.btn forState:UIControlStateNormal];
    [view addSubview:btn];
</code></pre>

<h5>注：上面是plist中的属性和模型中定义的属性一一对应的时候的，如果不是一一对应我们就要将模型一个一个的赋值与实现</h5>

<pre><code>- (instancetype)initWithDict:(NSDictionary *)dict
{
self = [super init];
if (self) {
    self.label = dict[@"label"];
    self.btn = dict[@"btn"];
    self.icon = dict[@"icon"];

//[self setValue:dict[@"label"] forKeyPath:@"label"];

    //封装
    [self setValuesForKeysWithDictionary:dict];
}

return self;
}
</code></pre>

<p>/<em>*
 模型数据的加载，返回arry以后我们就只要使用array就能使用这个模型类里面的数据也就是使用plist数据
 </em>/</p>

<pre><code>//懒加载plist文件，返回一个apps数据，后面直接使用旧可以
-(NSMutableArray *)apps
{
    if (_apps == nil) {
        NSArray *array = [NSArray arrayWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@"iCocos.plist" ofType:nil]];

        NSMutableArray *arrayApps = [NSMutableArray array];

        for (NSDictionary *dic in array) {
//            appsModel *model = [[appsModel alloc] initWithDict:dic];
            appsModel *model = [appsModel appsWithDict:dic];

            [arrayApps addObject:model];
        }
        _apps = arrayApps;
    }
    return _apps;
}
</code></pre>

<h6>我们也可以讲加载模型的代码进行封装，这样更加简单的实现模式数据的的使用</h6>

<p>在模型中定义并且实现一个模型封装的方法</p>

<pre><code>+(NSArray *)appList
{
        NSArray *array = [NSArray arrayWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@"iCocos.plist" ofType:nil]];

        NSMutableArray *arrayApps = [NSMutableArray array];

        for (NSDictionary *dic in array) {
            //            appsModel *model = [[appsModel alloc] initWithDict:dic];
            appsModel *model = [appsModel appsWithDict:dic];

            [arrayApps addObject:model];
    }
    return arrayApps;

}
</code></pre>

<h6>实用的时候只要直接使用封装好的模型方法就可以：</h6>

<pre><code>/**
 模型数据的加载，返回arry以后我们就只要使用array就能使用这个模型类里面的数据也就是使用plist数据
 */
//懒加载plist文件，返回一个apps数据，后面直接使用旧可以
-(NSArray *)apps
{
    if (_apps == nil) {

        _apps = [appsModel appList];
    }
    return _apps;
}
</code></pre>

<h2>三：复杂Plist转模型</h2>

<p>有的时候我们会遇到Plist中还有更小一级的节点和属性这个时候我们就需要更复杂的模型来加载，但是实用起来并不复杂</p>

<p>比如Plist中海油一个friends这歌子模型</p>

<p><img src="/images/zidianzhuanmoxin003.png" title="Caption" ></p>

<h6>那么我转模型的时候就可以根据plist中的数据进行处理，</h6>

<h6>首先我们一一般都是从子模型开始，我们就先定义子模型</h6>

<pre><code>/**
 根据plist里面存在的子列中的数据再创建一个模型数据
 */

/**
 设置子模型数据的属性
 */

@property (nonatomic, assign) NSString *icon;

@property (nonatomic, assign) NSString *intro;

@property (nonatomic, assign) NSString *name;

@property (nonatomic, assign, getter=isVip)BOOL vip;


/**
 子模型数据的方法
 */
+ (instancetype)friendWithDict:(NSDictionary *)dict;

- (instancetype)initWithDict:(NSDictionary *)dict;
</code></pre>

<h6>子模型的实现</h6>

<pre><code>/**
 子模型数据的方法de实现
 */

+ (instancetype)friendWithDict:(NSDictionary *)dict
{
    return [[self alloc] initWithDict:dict];
}

- (instancetype)initWithDict:(NSDictionary *)dict
{
    if (self = [super init]) {
        [self setValuesForKeysWithDictionary:dict];
    }
    return self;
}
</code></pre>

<h6>然后就是根模型</h6>

<pre><code>/**
 根据plist中的数据创建一个模型数据
 */

/**
 设置模型数据的中的属性
 */

@property (nonatomic, assign) NSArray *friends;

@property (nonatomic, copy) NSString *name;

@property (nonatomic, assign) NSNumber *online;

/**
 模型数据的方法
 */

+ (instancetype)groupWithDict:(NSDictionary *)dict;


- (instancetype)initWithDict:(NSDictionary *)dict;
</code></pre>

<h6>根模型的实现，这里只需要在根模型加载需要实现的子模型酒可以</h6>

<pre><code>/**
 模型数据的方法的实现
 */

+ (instancetype)groupWithDict:(NSDictionary *)dict
{
    return [[self alloc] initWithDict:dict];
}

- (instancetype)initWithDict:(NSDictionary *)dict
{
    if (self = [super init]) {
        [self setValuesForKeysWithDictionary:dict];

        NSMutableArray *friendArray = [NSMutableArray array];
        for (NSDictionary *dict in self.friends) {
            FriendsPlistChildren *friend = [FriendsPlistChildren friendWithDict:dict];
            [friendArray addObject:friend];
        }
        self.friends = friendArray;
    }
    return self;
}
</code></pre>

<h6>使用模型数据，方法还是和之前一样的，不需要去处理子模型，因为我们在跟模型里面已经处理好了</h6>

<pre><code>/**
 加载模型数据的方法
 */

- (NSArray *)groups
{
    if (_groups == nil) {
        NSArray *dictArray = [NSArray arrayWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@"friends.plist" ofType:nil]];

        NSMutableArray *groupArray = [NSMutableArray array];
        for (NSDictionary *dict in dictArray) {
            FirendsPlistRoot *group = [FirendsPlistRoot groupWithDict:dict];
            [groupArray addObject:group];
        }

        _groups = groupArray;
    }
    return _groups;
}
</code></pre>

<h2>四：使用第三份库</h2>

<p>在iOS届有一个神人不知道大家知不知道————他叫李明杰，他（MJ）不仅技术牛逼，而且对天朝iOS界的贡献也是无法用语言来形容的，如果你是老一辈的iOS开发者倒是很正常，如果你只是刚开始学习iOS或者学习iOS不久你都不知道或者没有听过这个名字那么就可以说明你真的out了，甚至说你你根本没有用心在学，关于这个神人我就不做多介绍了，如果你想知道更多，请点击www.520it.com</p>

<p>今天我就使用他的一个NB的框架来实现plist转模型数据，这个框架使用起来非常简单，一行代码就可以搞定你想的功能，</p>

<p>首先你需要去github上面下载这个框架：<a href="https://github.com/CoderMJLee/MJExtension">MJExtension</a></p>

<p>下载好了之后直接讲MJExtension拖到你的项目</p>

<p><img src="/images/zidianzhuanmoxin004.png" title="Caption" ></p>

<h6>首先根据plist数据新建对应的模型数据</h6>

<p>这里我一新浪微博中的小部分做测试</p>

<pre><code>#import "User.h"
#import "Status.h"
#import "StatusResult.h"

/**
 *  微博文本内容
 */
@property (copy, nonatomic) NSString *text;

/**
 *  微博作者
 */
@property (strong, nonatomic) User *user;

/**
 *  转发的微博
 */
@property (strong, nonatomic) Status *retweetedStatus;
/**
 *  存放着某一页微博数据（里面都是Status模型）
 */
@property (strong, nonatomic) NSMutableArray *statuses;

/**
 *  总数
 */
@property (assign, nonatomic) NSNumber *totalNumber;

/**
 *  上一页的游标
 */
@property (assign, nonatomic) long long previousCursor;

/**
 *  下一页的游标
 */
@property (assign, nonatomic) long long nextCursor;
/**
 *  名称
 */
@property (copy, nonatomic) NSString *name;

/**
 *  头像
 */
@property (copy, nonatomic) NSString *icon;
</code></pre>

<h6>下面就是证明去使用这个框架实现你想要的功能了，这里介绍了几乎你开发中需要用到的所有方法和例子，</h6>

<pre><code>/**
 MJ友情提醒：
 1.MJExtension是一套“字典和模型之间互相转换”的轻量级框架
 2.MJExtension能完成的功能
 * 字典 --&gt; 模型
 * 模型 --&gt; 字典
 * 字典数组 --&gt; 模型数组
 * 模型数组 --&gt; 字典数组
 3.具体用法主要参考 main.m中各个函数 以及 "NSObject+MJKeyValue.h"
 4.希望各位大神能用得爽
 */

#import &lt;Foundation/Foundation.h&gt;
#import "MJExtension.h"
#import "User.h"
#import "Status.h"
#import "StatusResult.h"

/**
 *  简单的字典 -&gt; 模型
 */
void keyValues2object()
{
    // 1.定义一个字典
    NSDictionary *dict = @{
                           @"name" : @"Jack",
                           @"icon" : @"lufy.png",
                           };

    // 2.将字典转为User模型
    User *user = [User objectWithKeyValues:dict];

    // 3.打印User模型的属性
    NSLog(@"name=%@, icon=%@", user.name, user.icon);
}

/**
 *  复杂的字典 -&gt; 模型 (模型里面包含了模型)
 */
void keyValues2object2()
{
    // 1.定义一个字典
    NSDictionary *dict = @{
                           @"text" : @"是啊，今天天气确实不错！",

                           @"user" : @{
                                   @"name" : @"Jack",
                                   @"icon" : @"lufy.png"
                                   },

                           @"retweetedStatus" : @{
                                   @"text" : @"今天天气真不错！",

                                   @"user" : @{
                                           @"name" : @"Rose",
                                           @"icon" : @"nami.png"
                                           }
                                   }
                           };

    // 2.将字典转为Status模型
    Status *status = [Status objectWithKeyValues:dict];

    // 3.打印status的属性
    NSString *text = status.text;
    NSString *name = status.user.name;
    NSString *icon = status.user.icon;
    NSLog(@"text=%@, name=%@, icon=%@", text, name, icon);

    // 4.打印status.retweetedStatus的属性
    NSString *text2 = status.retweetedStatus.text;
    NSString *name2 = status.retweetedStatus.user.name;
    NSString *icon2 = status.retweetedStatus.user.icon;
    NSLog(@"text2=%@, name2=%@, icon2=%@", text2, name2, icon2);
}

/**
 *  复杂的字典 -&gt; 模型 (模型的数组属性里面又装着模型)
 */
void keyValues2object3()
{
    // 1.定义一个字典
    NSDictionary *dict = @{
                           @"statuses" : @[
                                   @{
                                       @"text" : @"今天天气真不错！",

                                       @"user" : @{
                                               @"name" : @"Rose",
                                               @"icon" : @"nami.png"
                                               }
                                       },

                                   @{
                                       @"text" : @"明天去旅游了",

                                       @"user" : @{
                                               @"name" : @"Jack",
                                               @"icon" : @"lufy.png"
                                               }
                                       },

                                   @{
                                       @"text" : @"嘿嘿，这东西不错哦！",

                                       @"user" : @{
                                               @"name" : @"Jim",
                                               @"icon" : @"zero.png"
                                               }
                                       }

                                   ],

                           @"totalNumber" : @"2014",

                           @"previousCursor" : @"13476589",

                           @"nextCursor" : @"13476599"
                           };

    // 2.将字典转为StatusResult模型
    StatusResult *result = [StatusResult objectWithKeyValues:dict];

    // 3.打印StatusResult模型的简单属性
    NSLog(@"totalNumber=%d, previousCursor=%lld, nextCursor=%lld", result.totalNumber, result.previousCursor, result.nextCursor);

    // 4.打印statuses数组中的模型属性
    for (Status *status in result.statuses) {
        NSString *text = status.text;
        NSString *name = status.user.name;
        NSString *icon = status.user.icon;
        NSLog(@"text=%@, name=%@, icon=%@", text, name, icon);
    }
}

/**
 *  字典数组 -&gt; 模型数组
 */
void keyValuesArray2objectArray()
{
    // 1.定义一个字典数组
    NSArray *dictArray = @[
                           @{
                               @"name" : @"Jack",
                               @"icon" : @"lufy.png",
                               },

                           @{
                               @"name" : @"Rose",
                               @"icon" : @"nami.png",
                               },

                           @{
                               @"name" : @"Jim",
                               @"icon" : @"zero.png",
                               }
                           ];

    // 2.将字典数组转为User模型数组
    NSArray *userArray = [User objectArrayWithKeyValuesArray:dictArray];

    // 3.打印userArray数组中的User模型属性
    for (User *user in userArray) {
        NSLog(@"name=%@, icon=%@", user.name, user.icon);
    }
}

/**
 *  模型 -&gt; 字典
 */
void object2keyValues()
{
    // 1.新建模型
    User *user = [[User alloc] init];
    user.name = @"Jack";
    user.icon = @"lufy.png";

    Status *status = [[Status alloc] init];
    status.user = user;
    status.text = @"今天的心情不错！";

    // 2.将模型转为字典
    //    NSDictionary *dict = [status keyValues];
    NSDictionary *dict = status.keyValues;
    NSLog(@"%@", dict);
}

/**
 *  模型数组 -&gt; 字典数组
 */
void objectArray2keyValuesArray()
{
    // 1.新建模型数组
    User *user1 = [[User alloc] init];
    user1.name = @"Jack";
    user1.icon = @"lufy.png";

    User *user2 = [[User alloc] init];
    user2.name = @"Rose";
    user2.icon = @"nami.png";

    User *user3 = [[User alloc] init];
    user3.name = @"Jim";
    user3.icon = @"zero.png";

    NSArray *userArray = @[user1, user2, user3];

    // 2.将模型数组转为字典数组
    NSArray *dictArray = [User keyValuesArrayWithObjectArray:userArray];
    NSLog(@"%@", dictArray);
}

int main(int argc, const char * argv[])
{
    @autoreleasepool {
        // 简单的字典 -&gt; 模型
        keyValues2object();

        // 复杂的字典 -&gt; 模型 (模型里面包含了模型)
        keyValues2object2();

        // 复杂的字典 -&gt; 模型 (模型的数组属性里面又装着模型)
        keyValues2object3();

        // 字典数组 -&gt; 模型数组
        keyValuesArray2objectArray();

        // 模型转字典
        object2keyValues();

        // 模型数组 -&gt; 字典数组
        objectArray2keyValuesArray();
    }
    return 0;
}
</code></pre>
</div>
  
  




| <a href="/blog/2015/12/01/zi-dian-zhuan-mo-xing-shen-jiu/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/12/01/scrollviewhui-dao-ding-bu-fu-yuan/">ScrollView回到顶部复原</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><p>相信细心的开发者都会发现scrollView自带一个功能,当用户点击顶部的状态栏时,scrollView的ContentOffset.y轴会自动滚动到初始位置,效果如图所示:</p>

<blockquote><p>单个scrollView单击顶部状态栏系统自带功能展示</p></blockquote>

<p>这个功能对用户来说非常实用,尤其是在scrollView(TableView, WebView, CollectionView一切继承scrollView的控件)展示的内容很多,当用户翻看很久以后,想回到最顶部时,只需单击一下顶部的状态栏位置就可以轻松返回到顶部(这里吐槽下.貌似很多用户都不知道有这个功能),而不用使劲用手滑动到顶部.</p>

<ul>
<li>可是功能在当前控制器有多个scrollView(TableView, WebView, CollectionView一切继承scrollView的控件)的时候就会失效,效果如下图所示:</li>
</ul>


<p>当控制器内有多个scrollView时,系统自带的滚动到顶的功能就会失效</p>

<p>实际开发中,我们的产品在同一个控制器经常会有多个scrollView组合在一起的情况,这就意味着系统的方法已经失效了,需要开发人员自己来实现这个效果,下面我们就来搞定这个需求</p>

<blockquote><p>我们分析下原生的方法为什么会失效,当一个控制器内只有一个scrollView时,点击状态栏,系统会遍历当前keyWindow的子控件,发现子控件中只有一个scrollView会调用这个scrollView的setContentOffset: animated:的这个方法,将scrollView的contentOffset.y值修改为初始值,但是当子控件中又多个scrollView时,系统会不知道掉用哪一个scrollView而失效,知道这点我们就知道该如何搞定这个问题了</p></blockquote>

<p>这里就直接将解决思路一一写出来不将代码分段展示了,在代码中我加了详细的注释objective-c的套路和swift基本一样,在最后会将Swift和objective-c的代码一起放上,如果需要直接解决问题的童鞋可以直接将代码拷贝到工程里即可</p>

<ul>
<li>首先创建一个topWindow继承至NSObject,这里我们考虑将这个功能完全封装起来,所以所有的方法都用的类方法,所以用最基本的类就可以</li>
<li>在initialize方法中初始化topWIndow,将topWIndow的级别改成最高的UIWindowLevelAlert级别,设置topWindow位置,并且添加点击手势</li>
<li>在topWIndow被点击调用的方法中,我们拿出UIApplication的keyWindow,遍历keyWindow的所有子控件,如果满足是scrollView同时又显示在当前keyWindow条件时,将subView的contentOffset的y值回复到原始</li>
<li>然后采用递归的套路在遍历subView内时候有满足条件的子控件,直到没有满足条件时会停止</li>
</ul>


<h4>Swift的代码</h4>

<pre><code>import UIKit
class TopWindow: UIWindow {
    private static let window_: UIWindow = UIWindow()
    ///  类初始化方法,保证window_只被创建一次
    override class func initialize() {
        window_.frame = CGRectMake(0, 0, global.appWidth, 20)
        window_.windowLevel = UIWindowLevelAlert
        window_.addGestureRecognizer(UITapGestureRecognizer(target: self, action: "topWindowClick"))
    }
    class func topWindowClick() {
        // 遍历当前主窗口所有view,将满足条件的scrollView滚动回原位
        searchAllowScrollViewInView(UIApplication.sharedApplication().keyWindow!)
    }
    private class func searchAllowScrollViewInView(superView: UIView) {
        for subview: UIView in superView.subviews as! [UIView] {
            if subview.isKindOfClass(UIScrollView.self) &amp;&amp; superView.viewIsInKeyWindow() {
                // 拿到scrollView的contentOffset
                var offest = (subview as! UIScrollView).contentOffset
                // 将offest的y轴还原成最开始的值
                offest.y = -(subview as! UIScrollView).contentInset.top
                // 重新设置scrollView的内容
                (subview as! UIScrollView).setContentOffset(offest, animated: true)
            }
            // 递归,让子控件再次调用这个方法判断时候还有满足条件的view
            searchAllowScrollViewInView(subview)
        }
    }
    ///  添加topWindow,使手势生效
    class func showTopWindow() {
        window_.hidden = false
    }
    ///  隐藏topWindow,移除手势
    class func hiddenTopWindow() {
        window_.hidden = true
    }
}
///  对UIView的一个扩展
extension UIView {
    ///  判断调用方法的view是否在keyWindow中
    func viewIsInKeyWindow() -&gt; Bool {
        let keyWindow = UIApplication.sharedApplication().keyWindow!
        // 将当前view的坐标系转换到window.bounds
        let viewNewFrame = keyWindow.convertRect(self.frame, fromView: self.superview)
        let keyWindowBounds = keyWindow.bounds
        // 判断当前view是否在keyWindow的范围内
        let isIntersects = CGRectIntersectsRect(viewNewFrame, keyWindowBounds)
        // 判断是否满足所有条件
        return !self.hidden &amp;&amp; self.alpha &gt; 0.01 &amp;&amp; self.window == keyWindow &amp;&amp; isIntersects
    }   
}
</code></pre>

<p>在AppDelegate里,程序启动完成方法时添加就OK了</p>

<pre><code>  func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -&gt; Bool {
      // 添加顶部的window
      TopWindow.showTopWindow()
      return true
  }
</code></pre>

<p>需要注意添加了自定义的window后,控制器的改变状态栏状态方法会失效,可以在info.plist中将改变状态栏的管理权交给UIApplication解决,或者在需要改变状态栏的控制器中调用TopWindow.hiddenTopWindow()即可,或者直接改info.plist,用UIApplication.sharedApplication().setStatusBarStyle来管理</p>

<h4>Objective-C代码</h4>

<p>.h文件只暴露显示和隐藏方法</p>

<pre><code>#import @interface WNXTopWindow : NSObject
+ (void)show;
+ (void)hide;
@end
</code></pre>

<p>.m文件</p>

<pre><code>#import "WNXTopWindow.h"
@implementation WNXTopWindow
static UIWindow *window_;
//初始化window
+ (void)initialize {
  window_ = [[UIWindow alloc] init];
  window_.frame = CGRectMake(0, 0, [UIScreen mainScreen].bounds.size.width, 20);
  window_.windowLevel = UIWindowLevelAlert;
  [window_ addGestureRecognizer:[[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(windowClick)]];
}  
+ (void)show {
  window_.hidden = NO;
}
+ (void)hide {
  window_.hidden = YES;
}
// 监听窗口点击
+ (void)windowClick {
  UIWindow *window = [UIApplication sharedApplication].keyWindow;
  [self searchScrollViewInView:window];
}
+ (void)searchScrollViewInView:(UIView *)superview {
  for (UIScrollView *subview in superview.subviews) {
      // 如果是scrollview, 滚动最顶部
      if ([subview isKindOfClass:[UIScrollView class]] &amp;&amp; [subview isShowingOnKeyWindow]) {
          CGPoint offset = subview.contentOffset;
          offset.y = - subview.contentInset.top;
          [subview setContentOffset:offset animated:YES];
      }
      // 递归继续查找子控件
      [self searchScrollViewInView:subview];
  }
}
+ (BOOL)isShowingOnKeyWindow:(UIView *)view {
  // 主窗口
  UIWindow *keyWindow = [UIApplication sharedApplication].keyWindow;
  // 以主窗口左上角为坐标原点, 计算self的矩形框
  CGRect newFrame = [keyWindow convertRect:view.frame fromView:view.superview];
  CGRect winBounds = keyWindow.bounds;
  // 主窗口的bounds 和 self的矩形框 是否有重叠
  BOOL intersects = CGRectIntersectsRect(newFrame, winBounds);
  return !view.isHidden &amp;&amp; view.alpha &gt; 0.01 &amp;&amp; view.window == keyWindow &amp;&amp; intersects;
}
@end
</code></pre>

<p>同样,也是在程序初始化完成AppDelegate文件中显示topWindow,整个工程这个问题就统统解决了</p>

<pre><code>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
  // 添加一个window, 点击这个window, 可以让屏幕上的scrollView滚到最顶部
  [WNXTopWindow show];
  return YES;
}
</code></pre>
</div>
  
  




| <a href="/blog/2015/12/01/scrollviewhui-dao-ding-bu-fu-yuan/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/12/01/chuan-zhi-fang-shi-zong-jie/">传值方式总结</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><ul>
<li>简单总结

<ul>
<li>代理</li>
<li>Block</li>
<li>通知</li>
</ul>
</li>
</ul>


<hr />

<ul>
<li>简单实用

<ul>
<li>代理</li>
<li>Block</li>
<li>通知</li>
</ul>
</li>
</ul>


<p>虽然这一期的主题是关于Foundation Framework的，不过本文中还介绍了一些超出Foundation Framework(KVO和Notification)范围的一些消息传递机制，另外还介绍了delegation，block和target- action。</p>

<p>大多数情况下，消息传递该使用什么机制，是很明确的了，当然了，在某些情况下该使用什么机制并没有明确的答案，需要你亲自去尝试一下。</p>

<hr />

<h3>简单总结</h3>

<ul>
<li><p>delegation</p>

<ul>
<li><p>在苹果的Framework中，delegation模式被广泛的只用着。delegation允许我们定制某个对象的行为，并且可以收到某些 确定的事件。为了使用delegation模式，消息的发送者需要知道消息的接收者(delegate)，反过来就不用了。这里的发送者和接收者是比较松 耦合的，因为发送者只知道它的delegate是遵循某个特定的协议。</p></li>
<li><p>delegate协议可以定义任意的方法，因此你可以准确的定义出你所需要的类型。你可以用函数参数的形式来处理消息内容，delegate还 可以通过返回值的形式给发送者做出回应。如果只需要在相对接近的两个模块之间进行消息传递，那么Delegation是一种非常灵活和直接方式。</p></li>
<li><p>不过，过渡使用delegation也有一定的风险，如果两个对象的耦合程度比较紧密，相互之间不能独立存在，那么此时就没有必要使用 delegate协议了，针对这种情况，对象之间可以知道相互间的类型，进而直接进行消息传递。例如UICollectionViewLayout和 NSURLSessionConfiguration。</p></li>
</ul>
</li>
<li><p>block</p>

<ul>
<li><p>Block相对来说，是一种比较新的技术，它首次出现是在OS X 10.6和iOS 4中。一般情况下，block可以满足用delegation实现的消息传递机制。不过这两种机制都有各自的需求和优势。</p></li>
<li><p>当不考虑使用block时，一般主要是考虑到block极易引起retain环。如果发送者需要reatain block，而又不能确保这个引用什么时候被nil，这样就会发生潜在的retain环。</p></li>
</ul>
</li>
<li><p>Notification</p>

<ul>
<li><p>在不相关的两部分代码中要想进行消息传递，通知(notifacation)是非常好的一种机制，它可以对消息进行广播。特别是想要传递丰富的信息，并且不一定指望有谁对此消息关心。</p></li>
<li><p>通知可以用来发送任意的消息，甚至包含一个userInfo字典，或者是NSNotifacation的一个子类。通知的独特之处就在于发送者 和接收者双方并不需要相互知道。这样就可以在非常松耦合的模块间进行消息的传递。记住，这种消息传递机制是单向的，作为接收者是不可以回复消息的。</p></li>
</ul>
</li>
</ul>


<hr />

<h3>简单使用</h3>

<p>初始化之后出现下面的界面</p>

<p><img src="/images/chuanzhi001.png" title="Caption" ></p>

<h5>准备：</h5>

<p>这里试试根据本文的实战做相应的介绍，关于拓展只要理解了这里的思路基本是三种传值的使用没有什么问题。</p>

<p>首先，由于我们要实现的点击对应的组实现展开分组显示对应组里面的所有行。</p>

<p>我这个项目使用的是多层分组模型，讲每一组合对应的属性还有friends作为组模型，再将friends作为子模型，实现表格数据的现实。</p>

<p><img src="/images/chuanzhi002.png" title="Caption" ></p>

<h6>定义一个BOOL值用来记录点击（由于我们需要实现点击对应组做事情，所以先在组模型中定义一个BOOL）</h6>

<pre><code>@property (nonatomic, assign, getter = isOpen) BOOL open; 
</code></pre>

<h6>在相应的点击方法里面是实现取反点击，这里的点击方法是分组View上面一个按钮的点击事件。</h6>

<pre><code>self.group.open = !self.group.open; 
</code></pre>

<h6>在numberOfRowsInSection中返回的时候使用三木判断是否点击，并且实现伸缩与展开，</h6>

<pre><code>return model.open?model.friends.cout:0; 
</code></pre>

<p>这里完成之后运行程序点一下试试，你会发现。。。。。。。。。。。。。。。。。什么效果也没有。</p>

<p>当然会没有效果，因为我们没有传值，后面才是本章的重点，学会了这里以后关于通知，代理。Block的使用基本上没有问题。</p>

<hr />

<p>/######################代理######################/</p>

<hr />

<h2>方法一：代理</h2>

<h6>在对应的View中创建一个协议</h6>

<pre><code>@class iCocosView



@protocol iCocoDelegate &lt;NSObject&gt;

@optional

-(void)headerView:(iCocosView *)view;



@end
</code></pre>

<h6>创建一个代理属性</h6>

<pre><code> @property (nonatomic, assign) id&lt;iCocoDelegate&gt; delegate; 
</code></pre>

<h6>在这个实现文件中判断有没有实现这个代理方法</h6>

<pre><code>if([self.delegate repondToSelector:selector(headerView)]) {

[self.delegate headerView];

}
</code></pre>

<h6>先在对应的控制器遵守这个协议，并且设置代理</h6>

<pre><code> &lt;iCocosDelegate&gt; 

header.delegate = self; //让控制器充当代理
</code></pre>

<h6>实现代理方法</h6>

<pre><code>－（void）headerView:(iCocosView *)view {[self.tableView reloadData];  }  
</code></pre>

<hr />

<p>/######################Block######################/</p>

<hr />

<h2>方法二：Block</h2>

<h6>定义一个Block</h6>

<pre><code>typedef void (^iCocosBlock)(id);  
</code></pre>

<h6>创建一个Block对应的属性（使用Copy）</h6>

<pre><code> @property （nonatomic， weak）iCocosBlock block; 
</code></pre>

<h6>实现文件中判读</h6>

<pre><code>  if(self.block) { self.block(self);}  
</code></pre>

<h6>在控制器中实现</h6>

<pre><code> header.block = ^(id sender) {  //sender是传过来的参数

 [self.tableView reloadData];

 };
</code></pre>

<hr />

<p>/######################通知######################/</p>

<hr />

<h2>方法三：通知</h2>

<p> 注意：通知的使用是前面的反向思维，在控制器里面注册并且实现通知方法，然后在分组View里面发布这个通知。</p>

<h6>在控制器中注册一个通知</h6>

<pre><code>[［NSNotificationCenter defaultCenter］ addObserver:self selector:@selector(notiClick) name:@“friends” object:nil]; 2 3  
</code></pre>

<h6>实现通知方法</h6>

<pre><code>－（void）notiClick

{

[self.tableView reloadData];

}
</code></pre>

<h6>同样在Header分组的实现文件中发布一个通知</h6>

<pre><code>[［NSNotificationCenter defaultCenter］postNotificationName: @“friends”object:self userInfo:nil]; 2 3  
</code></pre>

<h6>移除通知：我们可以在两个方法里面一出通知：ViewDidDidApper和Dealloc</h6>

<p>并且使用良种两种方法</p>

<p>@1:移除所有通知</p>

<pre><code>[［NSNotificationCenter defaultCenter］ removeObserver:self]; 
</code></pre>

<p>@2:根据名字移除通知</p>

<pre><code>[［NSNotificationCenter defaultCenter］removeObserver:self name:@“friedns” object:nil];  
</code></pre>

<p>这里需要注意：实际开发中使用完通知之后一定要移除通知，否则如果里面通知太多，当你再次发送一个通知的时候程序就不知道去找那个通知甚至会导致程序奔溃。</p>

<hr />

<p>/######################运行结果######################/</p>

<hr />

<p>使用上面任何一种方法都可以实现同样的功能，点击每一行的组的时候就会展开相应行并且显示对应组的所有行。</p>

<p><img src="/images/chuanzhi003.png" title="Caption" ></p>

<p>实现Header左边按钮上面图标的旋转：（这里是一个重点，也是以后以后开发中肯呢过遇到的一个难点，可能不是一样的但是或许思路和原理一样，这里是这篇文章中除了传值的三种方式以后最重要的地方）
    /<strong><strong><em>在这个方法里面实现旋转：当View移到父控件的时候，不然旋转也看不到选过，因为刷新实在旋转之后的，旋转之后再刷新，从缓存迟里面取出来</em></strong></strong>***/</p>

<pre><code>-(void)didMoveToSuperview
{
    if (self.group.open) {
        self.nameView.imageView.transform = CGAffineTransformMakeRotation(M_PI_2);
    }else {
        self.nameView.imageView.transform = CGAffineTransformMakeRotation(0);
    }

}
/ 
</code></pre>

<p>但是具体使用说明视情况而定：</p>

<p>总结：。。。。。。。。待续</p>
</div>
  
  




| <a href="/blog/2015/12/01/chuan-zhi-fang-shi-zong-jie/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/11/30/iossheng-ming-zhou-qi/">iOS生命周期</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><h3>控制器（View）生命周期</h3>

<p>当一个视图控制器被创建，并在屏幕上显示的时候。 代码的执行顺序</p>

<pre><code>1、 alloc                                   创建对象，分配空间
2、init (initWithNibName) 初始化对象，初始化数据
3、loadView                          从nib载入视图 ，通常这一步不需要去干涉。除非你没有使用xib文件创建视图
4、viewDidLoad                   载入完成，可以进行自定义数据以及动态创建其他控件
5、viewWillAppear              视图将出现在屏幕之前，马上这个视图就会被展现在屏幕上了
6、viewDidAppear               视图已在屏幕上渲染完成
</code></pre>

<p>当一个视图被移除屏幕并且销毁的时候的执行顺序，这个顺序差不多和上面的相反</p>

<pre><code>1、viewWillDisappear            视图将被从屏幕上移除之前执行
2、viewDidDisappear             视图已经被从屏幕上移除，用户看不到这个视图了
3、dealloc                                 视图被销毁，此处需要对你在init和viewDidLoad中创建的对象进行释放
</code></pre>

<p>－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－</p>

<h3>app的启动过程</h3>

<pre><code>1.先执行main函数，main内部会调用UIApplicationMain函数

2.UIApplicationMain函数里面做了什么事情：

    1&gt; 创建UIApplication对象
    2&gt; 创建UIApplication的delegate对象—–PYAppDelegate
    3&gt; 开启一个消息循环

每监听到对应的系统事件时，就会通知MJAppDelegate

根据plist文件判断是否需要加载storyBoard
</code></pre>

<p>如果有storyBoard</p>

<pre><code>加载Info.plist文件，读取最主要storyboard文件的名称

加载最主要的storyboard文件，创建白色箭头所指的控制器对象

并且设置创建的控制器为UIWindow的rootViewController属性(根控制器)

初始化对应的子控件
</code></pre>

<p>如果没有storyBoard</p>

<pre><code>在代理的difinishLuaunchWithOPtions中为应用程序创建一个UIWindow对象(继承自UIView)，设置为PYAppDelegate的window属性

并且设置创建的控制器为UIWindow的rootViewController属性(根控制器)

初始化对应的子控件
</code></pre>

<p>－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－</p>

<h3>App的生命周期</h3>

<p>这里只是简单的总结，关于有些方法我们并没有解除过，所以就略过了。</p>

<pre><code> 1、application didFinishLaunchingWithOptions：当应用程序启动时执行，应用程序启动入口，只在应用程序启动时执行一次。若用户直接启动，lauchOptions内无数据,若通过其他方式启动应用，lauchOptions包含对应方式的内容。
 2、applicationWillResignActive：在应用程序将要由活动状态切换到非活动状态时候，要执行的委托调用，如 按下 home 按钮，返回主屏幕，或全屏之间切换应用程序等。

 3、applicationDidEnterBackground：在应用程序已进入后台程序时，要执行的委托调用。

 4、applicationWillEnterForeground：在应用程序将要进入前台时(被激活)，要执行的委托调用，刚好与applicationWillResignActive 方法相对应。

 5、applicationDidBecomeActive：在应用程序已被激活后，要执行的委托调用，刚好与applicationDidEnterBackground 方法相对应。

 6、applicationWillTerminate：在应用程序要完全推出的时候，要执行的委托调用，这个需要要设置UIApplicationExitsOnSuspend的键值。
</code></pre>
</div>
  
  




| <a href="/blog/2015/11/30/iossheng-ming-zhou-qi/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/11/30/chang-lian-jie-and-duan-lian-jie/">长链接&amp;短链接</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><ul>
<li>HTTP协议与TCP/IP协议的关系</li>
<li>如何理解HTTP协议是无状态的</li>
<li>什么是长连接、短连接？

<ul>
<li> TCP连接</li>
<li> TCP短连接</li>
<li> TCP长连接</li>
</ul>
</li>
<li>长连接短连接操作过程</li>
<li>长连接和短连接的优点和缺点</li>
<li>什么时候用长连接，短连接？</li>
</ul>


<h3>HTTP协议与TCP/IP协议的关系</h3>

<p>HTTP的长连接和短连接本质上是TCP长连接和短连接。HTTP属于应用层协议，在传输层使用TCP协议，在网络层使用IP协议。IP协议主要解决网络路由和寻址问题，TCP协议主要解决如何在IP层之上可靠的传递数据包，使在网络上的另一端收到发端发出的所有包，并且顺序与发出顺序一致。TCP有可靠，面向连接的特点。</p>

<h3>如何理解HTTP协议是无状态的</h3>

<p>HTTP协议是无状态的，指的是协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。也就是说，打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系。HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接）。</p>

<h3>什么是长连接、短连接？</h3>

<p>在HTTP/1.0中，默认使用的是短连接。也就是说，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。如果客户端浏览器访问的某个HTML或其他类型的 Web页中包含有其他的Web资源，如JavaScript文件、图像文件、CSS文件等；当浏览器每遇到这样一个Web资源，就会建立一个HTTP会话。</p>

<p>但从 HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头有加入这行代码：</p>

<p>Connection:keep-alive</p>

<p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的 TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接要客户端和服务端都支持长连接。</p>

<p>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</p>

<h5>TCP连接</h5>

<p>当网络通信时采用TCP协议时，在真正的读写操作之前，server与client之间必须建立一个连接，当读写操作完成后，双方不再需要这个连接 时它们可以释放这个连接，连接的建立是需要三次握手的，而释放则需要4次握手，所以说每个连接的建立都是需要资源消耗和时间消耗的</p>

<p>经典的三次握手示意图：</p>

<p>经典的四次握手关闭图：</p>

<h5>TCP短连接</h5>

<p>我们模拟一下TCP短连接的情况，client向server发起连接请求，server接到请求，然后双方建立连接。client向server 发送消息，server回应client，然后一次读写就完成了，这时候双方任何一个都可以发起close操作，不过一般都是client先发起 close操作。为什么呢，一般的server不会回复完client后立即关闭连接的，当然不排除有特殊的情况。从上面的描述看，短连接一般只会在 client/server间传递一次读写操作</p>

<p>短连接的优点是：管理起来比较简单，存在的连接都是有用的连接，不需要额外的控制手段</p>

<h5>TCP长连接</h5>

<p>接下来我们再模拟一下长连接的情况，client向server发起连接，server接受client连接，双方建立连接。Client与server完成一次读写之后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。</p>

<p>首先说一下TCP/IP详解上讲到的TCP保活功能，保活功能主要为服务器应用提供，服务器应用希望知道客户主机是否崩溃，从而可以代表客户使用资源。如果客户已经消失，使得服务器上保留一个半开放的连接，而服务器又在等待来自客户端的数据，则服务器将应远等待客户端的数据，保活功能就是试图在服务 器端检测到这种半开放的连接。</p>

<p>如果一个给定的连接在两小时内没有任何的动作，则服务器就向客户发一个探测报文段，客户主机必须处于以下4个状态之一：</p>

<p>客户主机依然正常运行，并从服务器可达。客户的TCP响应正常，而服务器也知道对方是正常的，服务器在两小时后将保活定时器复位。
客户主机已经崩溃，并且关闭或者正在重新启动。在任何一种情况下，客户的TCP都没有响应。服务端将不能收到对探测的响应，并在75秒后超时。服务器总共发送10个这样的探测 ，每个间隔75秒。如果服务器没有收到一个响应，它就认为客户主机已经关闭并终止连接。
客户主机崩溃并已经重新启动。服务器将收到一个对其保活探测的响应，这个响应是一个复位，使得服务器终止这个连接。
客户机正常运行，但是服务器不可达，这种情况与2类似，TCP能发现的就是没有收到探查的响应。</p>

<h5>长连接短连接操作过程</h5>

<p>短连接的操作步骤是：</p>

<p>建立连接——数据传输——关闭连接…建立连接——数据传输——关闭连接</p>

<p>长连接的操作步骤是：</p>

<p>建立连接——数据传输…（保持连接）…数据传输——关闭连接</p>

<h3>长连接和短连接的优点和缺点</h3>

<p>由上可以看出，长连接可以省去较多的TCP建立和关闭的操作，减少浪费，节约时间。对于频繁请求资源的客户来说，较适用长连接。不过这里存在一个问题，存活功能的探测周期太长，还有就是它只是探测TCP连接的存活，属于比较斯文的做法，遇到恶意的连接时，保活功能就不够使了。在长连接的应用场景下，client端一般不会主动关闭它们之间的连接，Client与server之间的连接如果一直不关闭的话，会存在一个问题，随着客户端连接越来越多，server早晚有扛不住的时候，这时候server端需要采取一些策略，如关闭一些长时间没有读写事件发生的连接，这样可 以避免一些恶意连接导致server端服务受损；如果条件再允许就可以以客户端机器为颗粒度，限制每个客户端的最大长连接数，这样可以完全避免某个蛋疼的客户端连累后端服务。</p>

<p>短连接对于服务器来说管理较为简单，存在的连接都是有用的连接，不需要额外的控制手段。但如果客户请求频繁，将在TCP的建立和关闭操作上浪费时间和带宽。</p>

<p>长连接和短连接的产生在于client和server采取的关闭策略，具体的应用场景采用具体的策略，没有十全十美的选择，只有合适的选择。</p>

<h3>什么时候用长连接，短连接？</h3>

<p>长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况，。每个TCP连接都需要三步握手，这需要时间，如果每个操作都是先连接，再操作的话那么处理速度会降低很多，所以每个操作完后都不断开，次处理时直接发送数据包就OK了，不用建立TCP连接。例如：数据库的连接用长连接， 如果用短连接频繁的通信会造成socket错误，而且频繁的socket 创建也是对资源的浪费。</p>

<p>而像WEB网站的http服务一般都用短链接，因为长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以并发量大，但每个用户无需频繁操作情况下需用短连好。</p>
</div>
  
  




| <a href="/blog/2015/11/30/chang-lian-jie-and-duan-lian-jie/#comments">更多评论</a>

    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/4">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/2">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
    <h1>文章分类</h1>
    <ul id="categories">
        <li class='category'><a href='/blog/categories/全栈工程师必备/'>全栈工程师必备 (1)</a></li>
<li class='category'><a href='/blog/categories/底层开发/'>底层开发 (3)</a></li>
<li class='category'><a href='/blog/categories/开发工具/'>开发工具 (1)</a></li>
<li class='category'><a href='/blog/categories/性能相关/'>性能相关 (6)</a></li>
<li class='category'><a href='/blog/categories/新技术/'>新技术 (1)</a></li>
<li class='category'><a href='/blog/categories/欢迎来到ios梦工厂/'>欢迎来到ios梦工厂 (1)</a></li>
<li class='category'><a href='/blog/categories/程序员必备/'>程序员必备 (2)</a></li>
<li class='category'><a href='/blog/categories/适配问题/'>适配问题 (1)</a></li>
<li class='category'><a href='/blog/categories/面试总结-技术/'>面试总结＋技术 (1)</a></li>
<li class='category'><a href='/blog/categories/项目实战/'>项目实战 (10)</a></li>
<li class='category'><a href='/blog/categories/高级开发/'>高级开发 (10)</a></li>

    </ul>
</section><section>
  <h1>最新文章</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/12/10/core-image-chu-tan/">Core Image 初探</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/12/09/wan-zheng-ding-shi-qi/">玩转定时器</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/12/09/shi-jian-chu-li-yu-tu-xiang-xuan-ran-shen-jiu/">事件处理与图像渲染深究</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/12/08/watch-os2-chu-tan/">Watch OS2 初探</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/12/08/fang-fa-huan-cun/">方法缓存</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/al1020119">@al1020119</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'al1020119',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>




<section>
<h1>扫一扫<abbr title="The word '扫一扫' is a registered trademark of DENSO WAVE INCORPORATED. It applies only for the word '扫一扫', not for image.">&trade;</abbr></h1>
<a href="http://al1020119.github.io/posts/3/index.html"><img src="http://chart.apis.google.com/chart?chs=150x150&cht=qr&chld=|0&chco=165B94&chl=http://al1020119.github.io/posts/3/index.html" alt="post-qrcode"></a></section>
<section>
    <h1>访客统计</h1>
    <br/>
    <a href="http://s07.flagcounter.com/more/2SH"><img src="http://s07.flagcounter.com/count/2SH/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_1/flags_0/" alt="Flag Counter" border="0"></a>
</section><section>
    <h1>新浪微博</h1>
    <ul id="weibo">
        <li>
            
            <!-- 在此插入获得的微博秀代码 -->
            <iframe width="100%" height="550" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=550&fansRow=2&ptype=1&speed=0&skin=1&isTitle=1&noborder=1&isWeibo=1&isFans=1&uid=3288975567&verifier=20ffcedd&dpc=1"></iframe>
            
        </li>
    </ul>
</section>
  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - iCocos -
<span class="credit">Preview in <a href="http://al1020119.github.io">[曹#黎]</a></span>
</p>

</footer>
  






<!--
--->



</body>
</html>
