
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>iOS梦工厂</title>
  <meta name="author" content="iCocos">

  
  <meta name="description" content="H5精华 标准通用标记语言下的一个应用HTML标准自1999年12月发布的HTML4.01后，后继的HTML5和其它标准被束之高阁，为了推动Web标准化运动的发展，一些公司联合起来，成立了一个叫做 Web Hypertext Application Technology Working Group &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://al1020119.github.io/posts/3/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="iOS梦工厂" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//libs.baidu.com/jquery/1.7.2/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <script>
function addBlankTargetForLinks () {
    $('a[href^="http"]').each(function(){
                              $(this).attr('target', '_blank');
                              });
}
$(document).bind('DOMNodeInserted', function(event) {
             addBlankTargetForLinks();
             });
</script>
  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">iOS梦工厂</a></h1>
  
    <h2>不战胜自己，何以改变未来！</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="al1020119.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">首页</a></li>
  <li><a href="/blog/archives">归档</a></li>
  <li><a href="/icocos">iCocos</a></li>
  <li><a href="/other">其他</a></li>
  <li><a href="/about">关于</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/11/29/h5chu-tan/">H5初探</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><h2>H5精华</h2>

<blockquote><p>标准通用标记语言下的一个应用HTML标准自1999年12月发布的HTML4.01后，后继的HTML5和其它标准被束之高阁，为了推动Web标准化运动的发展，一些公司联合起来，成立了一个叫做 Web Hypertext Application Technology Working Group （Web超文本应用技术工作组 -WHATWG） 的组织。WHATWG 致力于 Web 表单和应用程序，而W3C（World Wide Web Consortium，万维网联盟） 专注于XHTML2.0。在 2006 年，双方决定进行合作，来创建一个新版本的 HTML。</p></blockquote>

<h6>1：链接</h6>

<p>图像标签</p>

<pre><code>相对路径 ../../

绝对路径  https:// http://  ftp://  file://
</code></pre>

<ul>
<li><p> href: 引用 不是必须的</p></li>
<li><p> src: 引入  必需的</p></li>
</ul>


<hr />

<pre><code>&lt;!--超链接标签  javascript:void(0) --&gt;
&lt;a href="#"&gt;我是超链接&lt;/a&gt;
&lt;a href="http://baidu.com" target="_blank"&gt;百度一下,你就知道&lt;/a&gt;


&lt;img src="https://www.baidu.com/img/bd_logo1.png" alt="百度logo" width="200"&gt;
&lt;img src="images/img_01.jpg"&gt;
</code></pre>

<h6>2：列表&lt;&ndash;列表标签&ndash;></h6>

<p>无序：</p>

<pre><code>&lt;ul&gt;
  &lt;li&gt;我是列表1&lt;/li&gt;
  &lt;li&gt;我是列表2&lt;/li&gt;
  &lt;li&gt;我是列表3&lt;/li&gt;
  &lt;li&gt;我是列表4&lt;/li&gt;
&lt;/ul&gt;
</code></pre>

<p>有序：</p>

<pre><code>&lt;Ol&gt;
    &lt;li&gt;我是列表1&lt;/li&gt;
    &lt;li&gt;我是列表2&lt;/li&gt;
    &lt;li&gt;我是列表3&lt;/li&gt;
    &lt;li&gt;我是列表4&lt;/li&gt;
&lt;/Ol&gt;
</code></pre>

<h6>3:文章：</h6>

<pre><code>&lt;article&gt;

    &lt;header&gt;

    &lt;/header&gt;

    &lt;section&gt;&lt;/section&gt;

    &lt;section&gt;&lt;/section&gt;

    &lt;footer&gt;

    &lt;/footer&gt;

&lt;/article&gt;
</code></pre>

<h6>4：高级:</h6>

<pre><code>   &lt;!--进度条--&gt;
   &lt;progress max="100" value="50"&gt;&lt;/progress&gt;
   &lt;!--音频--&gt;
   &lt;audio src="sources/music.m4a" controls="controls"&gt;&lt;/audio&gt;
   &lt;!--视频--&gt;
   &lt;video src="sources/BigBuck.m4v" controls="controls"&gt;&lt;/video&gt;
</code></pre>

<blockquote><h6>其他请参考相关文档</h6></blockquote>

<hr />

<h2>CSS3</h2>

<h4>一:样式</h4>

<blockquote><p>CSS即层叠样式表（Cascading StyleSheet）。 在网页制作时采用层叠样式表技术，可以有效地对页面的布局、字体、颜色、背景和其它效果实现更加精确的控制。 只要对相应的代码做一些简单的修改，就可以改变同一页面的不同部分，或者页数不同的网页的外观和格式。CSS3是CSS技术的升级版本，CSS3语言开发是朝着模块化发展的。以前的规范作为一个模块实在是太庞大而且比较复杂，所以，把它分解为一些小的模块，更多新的模块也被加入进来。这些模块包括： 盒子模型、列表模块、超链接方式 、语言模块 、背景和边框 、文字特效 、多栏布局等。</p></blockquote>

<h6>1.行内：</h6>

<p>&lt;&ndash;style=&ldquo;background-color: red;&rdquo;&ndash;></p>

<p><--
   单值属性: 后面只有一个属性值
   复合属性: 后面有多个属性值
--></p>

<pre><code>   &lt;div style="color: purple; font-size: 40px; background-color: yellowgreen;"&gt;我是容器div&lt;/div&gt;
   &lt;p style="color: blue; font-size: 100px; border:3px solid red;"&gt;我是段落&lt;/p&gt;
</code></pre>

<h6>2.页内：</h6>

<pre><code>&lt;--
  网站 = N个网页 + 服务器 + 数据库 + ....

--&gt;

&lt;!--
  css遵循的规律:
  1&gt; 就近原则
  2&gt; 叠加原则
--&gt;
</code></pre>

<hr />

<pre><code>    &lt;style&gt;
        div{
            color: chartreuse;
            border: 3px dashed blueviolet;
            font-size: 90px;
        }
    &lt;/style&gt; 
&lt;/head&gt;
&lt;body&gt;
  &lt;div&gt;我是div&lt;/div&gt; 
</code></pre>

<h6>3.外部</h6>

<pre><code>    &lt;!--引入--&gt;
    &lt;link href="css/index.css" rel="stylesheet"&gt;
&lt;/head&gt;
&lt;body&gt;
   &lt;div&gt;哈哈哈哈哈&lt;/div&gt;
</code></pre>

<hr />

<pre><code>div{
    color: darkgoldenrod;
    background-color: mediumvioletred;
    font-size: 5px;
}
</code></pre>

<h4>二：选择器</h4>

<pre><code>    /** 标签选择器*/
    div{
        color: red;
    }
    /*类选择器*/
    .test1{
        color: green;
    }
    /*id选择器*/
    #main{
        font-size: 90px;
    }
    /*并列选择器*/
    #main,.test1{
        border: 5px double darkviolet;
    }
    /*复合选择器*/
    p.test2{
       background-color: red;
    }
    /*后代选择器*/
    #first p a{
        font-size: 90px;
    }
    /*伪类*/
    input:focus{
       width: 500px;
       height: 60px;
       font-size: 55px;
       /*去除外边框*/
       outline: none;
    }

    div#main:hover{
       background-color: yellow;
       width: 500px;
       height: 250px;
    }
    /*伪元素*/
    p:first-letter{
        color: goldenrod;
        font-size: 60px;
    }
</code></pre>

<hr />

<pre><code>   &lt;div id="main"&gt;bjbjwefbjb&lt;/div&gt;
   &lt;div&gt;bjbjwefbjb&lt;/div&gt; 
   &lt;p&gt;我是段落&lt;/p&gt; 
   &lt;div class="test1"&gt;bjbjwefbjb&lt;/div&gt;
   &lt;div id="first"&gt;
       &lt;p&gt;
           &lt;a href="#"&gt;我是超链接&lt;/a&gt;
       &lt;/p&gt;
   &lt;/div&gt;
</code></pre>

<h4>三：优先级：</h4>

<pre><code>    &lt;--
      CSS遵循的规律:
      1.相同级别的选择器: a.就近原则  b.叠加原则
      2.不同选择器:
        important &gt; 内联 &gt; id &gt; 类 &gt; 标签 | 伪类 | 属性选择 &gt; 伪元素 &gt; 通配符 &gt; 继承
      3. 选择器的针对性越强，它的优先级就越高
    --&gt;
</code></pre>

<blockquote><h6>其他请参考相关文档</h6></blockquote>

<hr />

<h2>编写 JScript</h2>

<blockquote><p>与其他许多编程语言一样， Microsoft JScript 是用文本方式编写的，并被组织成为语句、由相关的语句集组成的块、以及注释。在一条语句内可以使用变量、比如字符串和数字（称为“文字”）的立即数、以及表达式。</p></blockquote>

<h5>一：语句</h5>

<p>JScript 程序是语句的集合。一条 Jscript 语句相当于英语中的一个完整句。Jscript 语句将表达式组合起来，完成一个任务。</p>

<p>一条语句由一个或多个表达式、关键字或者运算符（符号）组成。典型地，一条语句写一行，尽管一条语句可以超过两行或更多行。两条或更多条语句也可以写在同一行上，语句之间用分号“;”隔开。通常，每一新行开始一条新语句。不过显式地终止语句是一个好方法。这是用分号 (;)来实现的，分号是 JScript 语句的终止字符。下面给出 Jscript 语句的两隔示例。</p>

<pre><code>aBird = "Robin"; //将文本“Robin”赋值给变量 aBird
var today = new Date(); // 将今天的日期赋值给变量 today
</code></pre>

<p>用大括号（{}）括起来的一组 JScript 语句称为一个语句块。分组到一个语句块中的语句通常可当作单条语句处理。这就是说在 JScript 期望有一条单个语句的大多数地方可以使用语句块。应该注意以 for 和 while 打头的循环语句是例外情况。注意，语句块中的原始语句以分号结束，但语句块本身并不以分号结束。</p>

<p>通常，在函数和条件语句中使用语句块。</p>

<blockquote><p>注意，Jscript 与 C++ 以及其他某些语言不同，它不认为语句块是一个新的范围；只有函数创建新范围。在下面的示例中，第一条语句开始定义一个函数，该函数包含一个五条语句组成的语句块。语句块后的三条语句没有用大括号括起来；这些语句不是一个语句块，所以就不是函数定义的一部分。</p></blockquote>

<pre><code>function convert(inches)  {
   feet = inches / 12;  //  这五条语句属于一个语句块。
   miles = feet / 5280;
   nauticalMiles = feet / 6080;
   cm = inches * 2.54;
   meters = inches / 39.37;
}
km = meters / 1000;  //  这三条语句不在语句块内。
kradius = km;
mradius = miles;
</code></pre>

<h5>二：注释</h5>

<p>单行的 JScript 注释以一对正斜杠(//)开始。下面给出一个单行注释的示例。</p>

<pre><code>aGoodIdea = "Comment your code thoroughly.";  //  这是一个单行注释。
</code></pre>

<p>多行注释以一个正斜杠加一个星号的组合(/<em>)开始,并以其逆向顺序 (</em>/)结束。</p>

<pre><code>/*
这是一个用来解释前面的代码语句的多行注释。

该语句将一个值赋给 aGoodIdea 变量。
用引号包含的这种值称为一个文字。
文字显式并直接包含信息；
而不是简接地引用信息。
（引号不属于该文字的内容。）
*/
</code></pre>

<blockquote><p>注意   如果您试图将一个多行注释插入到另一个中，JScript 不能按正常的方式解释生成的多行注释。标明嵌入的多行注释结束的 */ 被认为是整个多行注释的结尾。这就意味着嵌入多行注释之后的文本不再被认为是注释；相应地，它将被解释为 JScript 代码，并会产生语法错误。</p></blockquote>

<p>建议将所有的注释写为单行注释的语句块。这样您以后就能够将大段的代码与多行注释区分开。</p>

<pre><code>//这是另一种多行注释，写成一系列单行注释。

//  在执行完该语句后，可以使用 aGoodIdea 变量的名字来引用其内容，
//  如下一条语句那样，即采用连接操作将字符串文字添加到
//  aGoodIdea 变量，以创建一个新的变量。

var extendedIdea = aGoodIdea + " You never know when you'll have to figure out what it does.";
</code></pre>

<p>赋值和相等</p>

<p>JScript 语句中使用等号 (=)给变量赋值：等号是赋值运算符。= 运算符左边的操作项总是一个 Lvalue。Lvalue 可以是：</p>

<h5>三：变量，</h5>

<p>数组元素，
对象属性。
= 运算符右边的操作项总是一个 Rvalue。Rvalues 可以是任何类型的一个任意值，包括表达式的值。下面给出一个 JScript 赋值语句的示例。</p>

<pre><code>anInteger = 3;
</code></pre>

<p>Jscript 编译器解释本语句的意义为：“将 3 赋给变量 anInteger”或“anInteger 的值为 3”。</p>

<p>确定您理解了 = 运算符（赋值）和 == 运算符（相等）的差异。在比较两个值是否相等时，应使用两个等于号 (==)。这些内容将在 控制程序的流程 中详细介绍。</p>

<h5>四：表达式</h5>

<p>JScript 表达式是指 JScript 解释器能够计算生成值的 JScript “短语”。这个值可以是任何有效的 JScript 类型 — 数字、字符串、对象，等等。最简单的表达式是文字。下面给出 JScript 文字表达式的一些示例。</p>

<pre><code>3.9                       // 数字文字
"Hello!"                  // 字符串文字
false                     // 布尔文字
null                      // 文字空值
{x:1, y:2}                // 对象文字
[1,2,3]                   // 数组文字
function(x){return x*x;}  // 函数文字
</code></pre>

<p>更多复杂的表达式中包含变量、函数、函数调用以及其他表达式。可以用运算符将表达式组合，创建复合表达式。运算符可以是：</p>

<pre><code>+  // 加法
-  // 减法
*  // 乘法
/  // 除法
</code></pre>

<p>下面给出 JScript 复合表达式的一些示例。</p>

<pre><code>var anExpression = 3 * (4 / 5) + 6;
var aSecondExpression = Math.PI * radius * radius;
var aThirdExpression = aSecondExpression + "%" + anExpression;
var aFourthExpression = "(" + aSecondExpression + ") % (" + anExpression + ")";
</code></pre>

<blockquote><h6>其他请参考相关文档</h6></blockquote>
</div>
  
  




| <a href="/blog/2015/11/29/h5chu-tan/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/11/29/zi-ding-yi-xiang-ce-shan-chu-fu-huo-de-shi-xian/">自定义相册删除复活的实现</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><p>在这里（<a href="http://www.cnblogs.com/iCocos/p/4705585.html">http://www.cnblogs.com/iCocos/p/4705585.html</a>）我们提到了。</p>

<ul>
<li>简单的实现了获取系统相册图片并且保存图片到系统相册</li>
<li>定义自定义的相册，并且保存到自定义相册</li>
</ul>


<p>这里久以一个简单的例子实现一个上面的所有功能，并且添加一个很有用的功能实现
App中自定义的相册呗删除之后再次保存相片无法成功</p>

<p>这里使用的是一个系统的库：ALAssetsLibrary</p>

<p>先来看看咱们取得相册中的相片</p>

<pre><code>- (void)getAllPhotos
{
    ALAssetsLibrary *library = [[ALAssetsLibrary alloc] init];
    // 遍历所有的文件夹, 一个ALAssetsGroup对象就代表一个文件夹
    [library enumerateGroupsWithTypes:ALAssetsGroupAll usingBlock:^(ALAssetsGroup *group, BOOL *stop) {
        // 遍历文件夹内的所有多媒体文件（图片、视频）, 一个ALAsset对象就代表一张图片
        [group enumerateAssetsUsingBlock:^(ALAsset *result, NSUInteger index, BOOL *stop) {
            // 缩略图
            XMGLog(@"%@", [UIImage imageWithCGImage:result.thumbnail]);
            // 获得原始图片
            //            XMGLog(@"%@", [UIImage imageWithCGImage:result.defaultRepresentation.fullResolutionImage]);
        }];

   } failureBlock:nil];
}
</code></pre>

<p>下面我们看看代码具体的实现</p>

<p>一：首先定义一个属性涌来记录并且实现其他一些功能</p>

<pre><code> /** 相册库 */
@property (nonatomic, strong) ALAssetsLibrary *library;
</code></pre>

<p>二：然后就懒加载这个属性</p>

<pre><code>- (ALAssetsLibrary *)library
{
    if (!_library) {
        _library = [[ALAssetsLibrary alloc] init];
    }
    return _library;
}
</code></pre>

<p>三：点击保存按钮的实现</p>

<pre><code>- (IBAction)save
{
// 获得文件夹的名字
__block NSString *groupName = [self groupName];

// self的弱引用
XMGWeakSelf;

// 图片库
__weak ALAssetsLibrary *weakLibrary = self.library;

// 创建文件夹
[weakLibrary addAssetsGroupAlbumWithName:groupName resultBlock:^(ALAssetsGroup *group) {
    if (group) { // 新创建的文件夹
        // 添加图片到文件夹中
        [weakSelf addImageToGroup:group];
    } else { // 文件夹已经存在
        [weakLibrary enumerateGroupsWithTypes:ALAssetsGroupAll usingBlock:^(ALAssetsGroup *group, BOOL *stop) {
            NSString *name = [group valueForProperty:ALAssetsGroupPropertyName];
            if ([name isEqualToString:groupName]) { // 是自己创建的文件夹
                // 添加图片到文件夹中

                [weakSelf addImageToGroup:group];

                *stop = YES; // 停止遍历
            } else if ([name isEqualToString:@"Camera Roll"]) {
                // 文件夹被用户强制删除了
                groupName = [groupName stringByAppendingString:@" "];
                // 存储新的名字
                [[NSUserDefaults standardUserDefaults] setObject:groupName forKey:XMGGroupNameKey];
                [[NSUserDefaults standardUserDefaults] synchronize];
                // 创建新的文件夹
                [weakLibrary addAssetsGroupAlbumWithName:groupName resultBlock:^(ALAssetsGroup *group) {
                    // 添加图片到文件夹中
                    [weakSelf addImageToGroup:group];
                } failureBlock:nil];
            }
        } failureBlock:nil];
    }

    } failureBlock:nil];
    }
</code></pre>

<p>四：添加图片</p>

<pre><code>/**
 * 添加一张图片到某个文件夹中
 */
- (void)addImageToGroup:(ALAssetsGroup *)group
{
__weak ALAssetsLibrary *weakLibrary = self.library;
// 需要保存的图片

CGImageRef image = self.imageView.image.CGImage;

// 添加图片到【相机胶卷】
[weakLibrary writeImageToSavedPhotosAlbum:image metadata:nil completionBlock:^(NSURL *assetURL, NSError *error) {
    [weakLibrary assetForURL:assetURL resultBlock:^(ALAsset *asset) {
        // 添加一张图片到自定义的文件夹中
        [group addAsset:asset];
        [SVProgressHUD showSuccessWithStatus:@"保存成功!"];
    } failureBlock:nil];
}];
}
</code></pre>

<p>五：关于沙河中的组名</p>

<p>先定义一个用于保存名字用的key和一个需要保存的名字</p>

<pre><code>static NSString * const iCocosGroupNameKey = @"iCocosGroupNameKey";
static NSString * const iCocosDefaultGroupName = @"iCocos";
</code></pre>

<p>实现祖名的存取</p>

<pre><code>- (NSString *)groupName
{
    // 先从沙盒中取得名字

    NSString *groupName = [[NSUserDefaults standardUserDefaults] stringForKey:XMGGroupNameKey];
    if (groupName == nil) { // 沙盒中没有存储任何文件夹的名字
   groupName = XMGDefaultGroupName;

    // 存储名字到沙盒中
    [[NSUserDefaults standardUserDefaults] setObject:groupName forKey:XMGGroupNameKey];
 [[NSUserDefaults standardUserDefaults] synchronize];
}
return groupName;
}
</code></pre>
</div>
  
  




| <a href="/blog/2015/11/29/zi-ding-yi-xiang-ce-shan-chu-fu-huo-de-shi-xian/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/11/28/qu-xiao-tableviewde-headeryu-footerde-nian-xing-xiao-guo/">取消TableView的Header与Footer的黏性效果</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><p>引言：</p>

<p>最近做一个项目的时候，遇到了一个bug问题，或者说个人能力有限，想了很久没有想到最好的方法去现实。</p>

<h6>那么是什么问题呢？</h6>

<p>首先当我在tabelView中为没饿过section设置一个header和footer之后，滑动tableView的时候，发现header和footer并不随着tableView中的cell一起滚动，而且会在顶部活着底部停留一段时间，这样的效果虽然好，但是上面就是不需要者也的功能，所以只好自己想办法解决。</p>

<p>我记得有时候header是不会停顿的，可是为什么这个时候header和footer都隐藏呢？</p>

<p>后来发现原来设置tableView.tableHeaderView = ?或者footerView的时候就不会停顿，那是当然，因为这个是tableView的一部分，不是section的一部分。</p>

<p>也在网上找了一段这样的代码</p>

<h3>去掉UItableview headerview黏性(sticky)</h3>

<pre><code>- (void)scrollViewDidScroll:(UIScrollView *)scrollView {

if (scrollView == self.tableView)

{

        CGFloat sectionHeaderHeight = 64; //sectionHeaderHeight

        if (scrollView.contentOffset.y &lt;= sectionHeaderHeight &amp;&amp; scrollView.contentOffset.y &gt;= 0) {

            scrollView.contentInset = UIEdgeInsetsMake(-scrollView.contentOffset.y, 0, 0, 0);

        } else if (scrollView.contentOffset.y &gt;= sectionHeaderHeight) {

            scrollView.contentInset = UIEdgeInsetsMake(-sectionHeaderHeight, 0, 0, 0);

        }

    }

}
</code></pre>

<p>但是他职能设置headerView不能设置footerView，自己也试着去补充footerView的实现，但是发现技术有限，所以，你懂的！</p>

<h3>最后看到国外一位大神写的一一篇文章找到了下面的代码</h3>

<pre><code> -(void)scrollViewDidScroll:(UIScrollView *)scrollView {

    if (scrollView == self.tableView)

        {

        UITableView *tableview = (UITableView *)scrollView;

        CGFloat sectionHeaderHeight = 64;

        CGFloat sectionFooterHeight = 120;

        CGFloat offsetY = tableview.contentOffset.y;

        if (offsetY &gt;= 0 &amp;&amp; offsetY &lt;= sectionHeaderHeight)

        {

            tableview.contentInset = UIEdgeInsetsMake(-offsetY, 0, -sectionFooterHeight, 0);

        }else if (offsetY &gt;= sectionHeaderHeight &amp;&amp; offsetY &lt;= tableview.contentSize.height - tableview.frame.size.height - sectionFooterHeight)

        {

            tableview.contentInset = UIEdgeInsetsMake(-sectionHeaderHeight, 0, -sectionFooterHeight, 0);

        }else if (offsetY &gt;= tableview.contentSize.height - tableview.frame.size.height - sectionFooterHeight &amp;&amp; offsetY &lt;= tableview.contentSize.height - tableview.frame.size.height)         {

            tableview.contentInset = UIEdgeInsetsMake(-offsetY, 0, -(tableview.contentSize.height - tableview.frame.size.height - sectionFooterHeight), 0);

        }

    }

}
</code></pre>

<p>注：sectionHeaderHeight和sectionFooterHeight根据项目进行设置。</p>

<p>发现基本上搞定，最后只需要设置对应的内边距即可！</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2015/11/28/qu-xiao-tableviewde-headeryu-footerde-nian-xing-xiao-guo/">阅读全文😘</a>
    </footer>
  




| <a href="/blog/2015/11/28/qu-xiao-tableviewde-headeryu-footerde-nian-xing-xiao-guo/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/11/25/wang-shang-qing-qiu-feng-(feng-)zhuang/">网络请求疯（封）装</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><p>一直想总结一下关于iOS的离线数据缓存的方面的问题，然后最近也简单的对AFN进行了再次封装，所有想把这两个结合起来写一下。数据展示型的页面做离线缓存可以有更好的用户体验，用户在离线环境下仍然可以获取一些数据，这里的数据缓存首选肯定是SQLite，轻量级，对数据的存储读取相对于其他几种方式有优势，这里对AFN的封装没有涉及太多业务逻辑层面的需求，主要还是对一些方法再次封装方便使用，解除项目对第三方的耦合性，能够简单的快速的更换底层使用的网络请求代码。这篇主要写离线缓存思路，对AFN的封装只做简单的介绍。</p>

<p>关于XLNetworkApi</p>

<p>XLNetworkApi的一些功能和说明：</p>

<p>使用XLNetworkRequest做一些GET、POST、PUT、DELETE请求，与业务逻辑对接部分直接以数组或者字典的形式返回。
以及网络下载、上传文件，以block的形式返回实时的下载、上传进度，上传文件参数通过模型XLFileConfig去存取。
通过继承于XLDataService来将一些数据处理，模型转化封装起来，于业务逻辑对接返回的是对应的模型，减少Controllor处理数据处理逻辑的压力。
自定义一些回调的block</p>

<pre><code>/**
请求成功block
*/
typedef void (^requestSuccessBlock)(id responseObj);
/**
请求失败block
*/
typedef void (^requestFailureBlock) (NSError *error);
/**
请求响应block
*/
typedef void (^responseBlock)(id dataObj, NSError *error);
/**
监听进度响应block
*/
typedef void (^progressBlock)(int64_t bytesWritten, int64_t totalBytesWritten, int64_t totalBytesExpectedToWrite);
XLNetworkRequest.m部分实现
#import "XLNetworkRequest.h"
#import "AFNetworking.h"
@implementation XLNetworkRequest
+ (void)getRequest:(NSString *)url params:(NSDictionary *)params success:(requestSuccessBlock)successHandler failure:(requestFailureBlock)failureHandler {
//网络不可用
  if (![self checkNetworkStatus]) {
      successHandler(nil);
      failureHandler(nil);
      return;
  }
  AFHTTPRequestOperationManager *manager = [self getRequstManager];
  [manager GET:url parameters:params success:^(AFHTTPRequestOperation * _Nonnull operation, id  _Nonnull responseObject) {
      successHandler(responseObject);
  } failure:^(AFHTTPRequestOperation * _Nullable operation, NSError * _Nonnull error) {
      XLLog(@"------请求失败-------%@",error);
      failureHandler(error);
  }];
}
</code></pre>

<p>下载部分代码</p>

<pre><code>    //下载文件，监听下载进度
    + (void)downloadRequest:(NSString *)url successAndProgress:(progressBlock)progressHandler complete:(responseBlock)completionHandler {
      if (![self checkNetworkStatus]) {
          progressHandler(0, 0, 0);
          completionHandler(nil, nil);
          return;
      }
      NSURLSessionConfiguration *sessionConfiguration = [NSURLSessionConfiguration defaultSessionConfiguration];
      AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:sessionConfiguration];
      NSURLRequest *request = [NSURLRequest requestWithURL:[NSURL URLWithString:url]];
      NSProgress *kProgress = nil;
      NSURLSessionDownloadTask *downloadTask = [manager downloadTaskWithRequest:request progress:&amp;kProgress destination:^NSURL * _Nonnull(NSURL * _Nonnull targetPath, NSURLResponse * _Nonnull response) {
          NSURL *documentUrl = [[NSFileManager defaultManager] URLForDirectory :NSDocumentDirectory inDomain:NSUserDomainMask appropriateForURL:nil create:NO error:nil];
          return [documentUrl URLByAppendingPathComponent:[response suggestedFilename]];
      } completionHandler:^(NSURLResponse * _Nonnull response, NSURL * _Nonnull filePath, NSError * _Nonnull error){
          if (error) {
              XLLog(@"------下载失败-------%@",error);
          }
          completionHandler(response, error);
      }];
      [manager setDownloadTaskDidWriteDataBlock:^(NSURLSession * _Nonnull session, NSURLSessionDownloadTask * _Nonnull downloadTask, int64_t bytesWritten, int64_t totalBytesWritten, int64_t totalBytesExpectedToWrite) {
          progressHandler(bytesWritten, totalBytesWritten, totalBytesExpectedToWrite);
      }];
      [downloadTask resume];
    }
</code></pre>

<p>上传部分代码</p>

<pre><code>//上传文件，监听上传进度
+ (void)updateRequest:(NSString *)url params:(NSDictionary *)params fileConfig:(XLFileConfig *)fileConfig successAndProgress:(progressBlock)progressHandler complete:(responseBlock)completionHandler {
  if (![self checkNetworkStatus]) {
      progressHandler(0, 0, 0);
      completionHandler(nil, nil);
      return;
  }
  NSMutableURLRequest *request = [[AFHTTPRequestSerializer serializer] multipartFormRequestWithMethod:@"POST" URLString:url parameters:params constructingBodyWithBlock:^(id  _Nonnull formData) {
      [formData appendPartWithFileData:fileConfig.fileData name:fileConfig.name fileName:fileConfig.fileName mimeType:fileConfig.mimeType];
  } error:nil];
  //获取上传进度
  AFHTTPRequestOperation *operation = [[AFHTTPRequestOperation alloc] initWithRequest:request];
  [operation setUploadProgressBlock:^(NSUInteger bytesWritten, long long totalBytesWritten, long long totalBytesExpectedToWrite) {
      progressHandler(bytesWritten, totalBytesWritten, totalBytesExpectedToWrite);
  }];
  [operation setCompletionBlockWithSuccess:^(AFHTTPRequestOperation * _Nonnull operation, id  _Nonnull responseObject) {
      completionHandler(responseObject, nil);
  } failure:^(AFHTTPRequestOperation * _Nonnull operation, NSError * _Nonnull error) {
      completionHandler(nil, error);
      if (error) {
          XLLog(@"------上传失败-------%@",error);
      }
  }];
  [operation start];
}
</code></pre>

<p>XLDataService.m部分实现</p>

<pre><code>+ (void)getWithUrl:(NSString *)url param:(id)param modelClass:(Class)modelClass responseBlock:(responseBlock)responseDataBlock {
      [XLNetworkRequest getRequest:url params:param success:^(id responseObj) {
      //数组、字典转化为模型数组
      dataObj = [self modelTransformationWithResponseObj:responseObj modelClass:modelClass];
      responseDataBlock(dataObj, nil);
  } failure:^(NSError *error) {
      responseDataBlock(nil, error);
  }];
}
</code></pre>

<p>（关键）下面这个方法提供给继承XLDataService的子类重写，将转化为模型的代码写在这里，相似业务的网络数据请求都可以用这个子类去请求数据，直接返回对应的模型数组。
    /<em>*
    数组、字典转化为模型
    </em>/
    + (id)modelTransformationWithResponseObj:(id)responseObj modelClass:(Class)modelClass {
         return nil;
    }
关于离线数据缓存</p>

<p>当用户进入程序的展示页面，有三个情况下可能涉及到数据库存取操作，简单画了个图来理解，思路比较简单，主要是一些存取的细节处理。</p>

<p>进入展示页面</p>

<p><img src="/images/net001.png" title="Caption" ></p>

<p>下拉刷新最新数据</p>

<p><img src="/images/net002.png" title="Caption" ></p>

<p>上拉加载更多数据</p>

<p><img src="/images/net003.png" title="Caption" ></p>

<p>需要注意的是，上拉加载更多的时候，每次从数据库返回一定数量的数据，而不是一次性将数据全部加载，否则会有内存问题，直到数据库中没有更多数据时再发生网络请求，再次将新数据存入数据库。这里存储数据的方式是将服务器返回每组数据的字典归档成二进制作为数据库字段直接存储，这样存储在模型属性比较多的情况下更有好处，避免每一个属性作为一个字段，另外增加了一个idStr字段用来判断数据的唯一性，避免重复存储。
首先定义一个工具类XLDataBase来做数据库相关的操作，这里用的是第三方的FMDB。</p>

<pre><code>#import "XLDataBase.h"
#import "FMDatabase.h"
#import "Item.h"
#import "MJExtension.h"
@implementation XLDataBase
static FMDatabase *_db;
+ (void)initialize {
    NSString *path = [NSString stringWithFormat:@"%@/Library/Caches/Data.db",NSHomeDirectory()];
    _db = [FMDatabase databaseWithPath:path];
    [_db open];
    [_db executeUpdate:@"CREATE TABLE IF NOT EXISTS t_item (id integer PRIMARY KEY, itemDict blob NOT NULL, idStr text NOT NULL)"];
}
//存入数据库
+ (void)saveItemDict:(NSDictionary *)itemDict {
    //此处把字典归档成二进制数据直接存入数据库，避免添加过多的数据库字段
    NSData *dictData = [NSKeyedArchiver archivedDataWithRootObject:itemDict];
    [_db executeUpdateWithFormat:@"INSERT INTO t_item (itemDict, idStr) VALUES (%@, %@)",dictData, itemDict[@"id"]];
}
//返回全部数据
+ (NSArray *)list {
    FMResultSet *set = [_db executeQuery:@"SELECT * FROM t_item"];
    NSMutableArray *list = [NSMutableArray array];
    while (set.next) {
        // 获得当前所指向的数据
        NSData *dictData = [set objectForColumnName:@"itemDict"];
        NSDictionary *dict = [NSKeyedUnarchiver unarchiveObjectWithData:dictData];
        [list addObject:[Item mj_objectWithKeyValues:dict]];
    }
    return list;
}
//取出某个范围内的数据
+ (NSArray *)listWithRange:(NSRange)range {
    NSString *SQL = [NSString stringWithFormat:@"SELECT * FROM t_item LIMIT %lu, %lu",range.location, range.length];
    FMResultSet *set = [_db executeQuery:SQL];
    NSMutableArray *list = [NSMutableArray array];
    while (set.next) {
        NSData *dictData = [set objectForColumnName:@"itemDict"];
        NSDictionary *dict = [NSKeyedUnarchiver unarchiveObjectWithData:dictData];
        [list addObject:[Item mj_objectWithKeyValues:dict]];
    }
    return list;
}
//通过一组数据的唯一标识判断数据是否存在
+ (BOOL)isExistWithId:(NSString *)idStr
{
    BOOL isExist = NO;
    FMResultSet *resultSet= [_db executeQuery:@"SELECT * FROM t_item where idStr = ?",idStr];
    while ([resultSet next]) {
        if([resultSet stringForColumn:@"idStr"]) {
            isExist = YES;
        }else{
            isExist = NO;
        }
    }
    return isExist;
}
@end
</code></pre>

<p>一些继承于XLDataService的子类的数据库存储和模型转换的逻辑代码</p>

<pre><code>#import "GetTableViewData.h"
#import "XLDataBase.h"
@implementation GetTableViewData
//重写父类方法
+ (id)modelTransformationWithResponseObj:(id)responseObj modelClass:(Class)modelClass {
    NSArray *lists = responseObj[@"data"][@"list"];
    NSMutableArray *array = [NSMutableArray array];
    for (NSDictionary *dict in lists) {
        [modelClass mj_setupReplacedKeyFromPropertyName:^NSDictionary *{
            return @{ @"ID" : @"id" };
        }];
        [array addObject:[modelClass mj_objectWithKeyValues:dict]];
        //通过idStr先判断数据是否存储过，如果没有，网络请求新数据存入数据库
        if (![XLDataBase isExistWithId:dict[@"id"]]) {
            //存数据库
            NSLog(@"存入数据库");
            [XLDataBase saveItemDict:dict];
        }
    }
    return array;
}
</code></pre>

<p>下面是一些控制器的代码实现：</p>

<pre><code>#import "ViewController.h"
#import "GetTableViewData.h"
#import "Item.h"
#import "XLDataBase.h"
#import "ItemCell.h"
#import "MJRefresh.h"
#define URL_TABLEVIEW @"https://api.108tian.com/mobile/v3/EventList?cityId=1&amp;step=10&amp;theme=0&amp;page=%lu"
@interface ViewController () {
    NSMutableArray *_dataArray;
    UITableView *_tableView;
    NSInteger _currentPage;//当前数据对应的page
}
@end
@implementation ViewController
#pragma mark Life cycle
- (void)viewDidLoad {
    [super viewDidLoad];
    // Do any additional setup after loading the view, typically from a nib.
    [self createTableView];
    _dataArray = [NSMutableArray array];
}
- (void)viewWillAppear:(BOOL)animated {
    [super viewWillAppear:animated];
    NSRange range = NSMakeRange(0, 10);
    //如果数据库有数据则读取，不发送网络请求
    if ([[XLDataBase listWithRange:range] count]) {
        [_dataArray addObjectsFromArray:[XLDataBase listWithRange:range]];
        NSLog(@"从数据库加载");
    }else{
        [self getTableViewDataWithPage:0];
    }
}
#pragma mark UI
- (void)createTableView {
    _tableView = [[UITableView alloc] initWithFrame:self.view.bounds];
    _tableView.delegate = self;
    _tableView.dataSource = self;
    _tableView.rowHeight = 100.0;
    [self.view addSubview:_tableView];
    _tableView.mj_header = [MJRefreshNormalHeader headerWithRefreshingBlock:^{
        [self loadNewData];
    }];
    _tableView.mj_footer = [MJRefreshAutoNormalFooter footerWithRefreshingBlock:^{
        [self loadMoreData];
    }];
}
#pragma mark GetDataSoure
- (void)getTableViewDataWithPage:(NSInteger)page {
    NSLog(@"发送网络请求！");
    NSString *url = [NSString stringWithFormat:URL_TABLEVIEW, page];
    [GetTableViewData getWithUrl:url param:nil modelClass:[Item class] responseBlock:^(id dataObj, NSError *error) {
        [_dataArray addObjectsFromArray:dataObj];
        [_tableView reloadData];
        [_tableView.mj_header endRefreshing];
        [_tableView.mj_footer endRefreshing];
    }];
}
- (void)loadNewData {
    NSLog(@"下拉刷新");
    _currentPage = 0;
    [_dataArray removeAllObjects];
    [self getTableViewDataWithPage:_currentPage];
}
- (void)loadMoreData {
    NSLog(@"上拉加载");
    _currentPage ++;
    NSRange range = NSMakeRange(_currentPage * 10, 10);
    if ([[XLDataBase listWithRange:range] count]) {
        [_dataArray addObjectsFromArray:[XLDataBase listWithRange:range]];
        [_tableView reloadData];
        [_tableView.mj_footer endRefreshing];
        NSLog(@"数据库加载%lu条更多数据",[[XLDataBase listWithRange:range] count]);
    }else{
        //数据库没更多数据时再网络请求
        [self getTableViewDataWithPage:_currentPage];
    }
}
#pragma mark UITableViewDataSource
- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section {
    return _dataArray.count;
}
- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {
    ItemCell *cell = [ItemCell itemCellWithTableView:tableView];
    cell.item = _dataArray[indexPath.row];
    return cell;
}
@end
</code></pre>

<p>最后附上代码的下载地址，重要的部分代码中都有相应的注释和文字打印，运行程序可以很直观的表现。</p>

<p><a href="https://github.com/ShelinShelin/OffLineCache.git">Demo</a></p>

<p>希望大家能提出一些意见，很乐意与大家互相交流。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2015/11/25/wang-shang-qing-qiu-feng-(feng-)zhuang/">阅读全文😘</a>
    </footer>
  




| <a href="/blog/2015/11/25/wang-shang-qing-qiu-feng-(feng-)zhuang/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/11/16/appqia-dun-liao-zen-yao-ban-%3F/">App卡顿了怎么办？</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><p><img src="/images/kadun001.jpg" title="Caption" ></p>

<p>在 VSync 信号到来后，系统图形服务会通过 CADisplayLink 等机制通知 App，App 主线程开始在 CPU 中计算显示内容，比如视图的创建、布局计算、图片解码、文本绘制等。</p>

<p>随后 CPU 会将计算好的内容提交到 GPU 去，由 GPU 进行变换、合成、渲染。随后 GPU 会把渲染结果提交到帧缓冲区去，等待下一次 VSync 信号到来时显示到屏幕上。</p>

<p>由于垂直同步的机制，如果在一个 VSync 时间内，CPU 或者 GPU 没有完成内容提交，则那一帧就会被丢弃，等待下一次机会再显示，而这时显示屏会保留之前的内容不变。这就是界面卡顿的原因。</p>

<p>从上面的图中可以看到，CPU 和 GPU 不论哪个阻碍了显示流程，都会造成掉帧现象。所以开发时，也需要分别对 CPU 和 GPU 压力进行评估和优化。</p>

<h2>CPU 资源消耗原因和解决方案</h2>

<h4>对象创建</h4>

<p>对象的创建会分配内存、调整属性、甚至还有读取文件等操作，比较消耗 CPU 资源。</p>

<p>尽量用轻量的对象代替重量的对象，可以对性能有所优化。</p>

<p>比如 CALayer 比 UIView 要轻量许多，那么不需要响应触摸事件的控件，用 CALayer 显示会更加合适。如果对象不涉及 UI 操作，则尽量放到后台线程去创建，但可惜的是包含有 CALayer 的控件，都只能在主线程创建和操作。通过 Storyboard 创建视图对象时，其资源消耗会比直接通过代码创建对象要大非常多，在性能敏感的界面里，Storyboard 并不是一个好的技术选择。</p>

<p>尽量推迟对象创建的时间，并把对象的创建分散到多个任务中去。尽管这实现起来比较麻烦，并且带来的优势并不多，但如果有能力做，还是要尽量尝试一下。如果对象可以复用，并且复用的代价比释放、创建新对象要小，那么这类对象应当尽量放到一个缓存池里复用。</p>

<h4>对象调整</h4>

<p>对象的调整也经常是消耗 CPU 资源的地方。</p>

<p>这里特别说一下 CALayer：</p>

<ul>
<li><p>CALayer 内部并没有属性，当调用属性方法时，它内部是通过运行时 resolveInstanceMethod 为对象临时添加一个方法，并把对应属性值保存到内部的一个 Dictionary 里，同时还会通知 delegate、创建动画等等，非常消耗资源。</p></li>
<li><p>UIView 的关于显示相关的属性（比如 frame/bounds/transform）等实际上都是 CALayer 属性映射来的，所以对 UIView 的这些属性进行调整时，消耗的资源要远大于一般的属性。对此你在应用中，应该尽量减少不必要的属性修改。</p></li>
</ul>


<p>当视图层次调整时，UIView、CALayer 之间会出现很多方法调用与通知，所以在优化性能时，应该尽量避免调整视图层次、添加和移除视图。</p>

<h4>对象销毁</h4>

<p>对象的销毁虽然消耗资源不多，但累积起来也是不容忽视的。通常当容器类持有大量对象时，其销毁时的资源消耗就非常明显。同样的，如果对象可以放到后台线程去释放，那就挪到后台线程去。这里有个小 Tip：把对象捕获到 block 中，然后扔到后台队列去随便发送个消息以避免编译器警告，就可以让对象在后台线程销毁了。</p>

<pre><code>NSArray *tmp = self.array;

self.array = nil;

dispatch_async(queue, ^{

    [tmp class];

});
</code></pre>

<h4>布局计算</h4>

<p>视图布局的计算是 App 中最为常见的消耗 CPU 资源的地方。如果能在后台线程提前计算好视图布局、并且对视图布局进行缓存，那么这个地方基本就不会产生性能问题了。</p>

<p>不论通过何种技术对视图进行布局，其最终都会落到对 UIView.frame/bounds/center 等属性的调整上。上面也说过，对这些属性的调整非常消耗资源，所以尽量提前计算好布局，在需要时一次性调整好对应属性，而不要多次、频繁的计算和调整这些属性。</p>

<h4>Autolayout</h4>

<ul>
<li>Autolayout 是苹果本身提倡的技术，在大部分情况下也能很好的提升开发效率，但是 Autolayout 对于复杂视图来说常常会产生严重的性能问题。随着视图数量的增长，Autolayout 带来的 CPU 消耗会呈指数级上升。具体数据可以看这个文章：<a href="http://pilky.me/36/%E3%80%82">http://pilky.me/36/%E3%80%82</a> 如果你不想手动调整 frame 等属性，你可以用一些工具方法替代（比如常见的 left/right/top/bottom/width/height 快捷属性），或者使用 ComponentKit、AsyncDisplayKit 等框架。</li>
</ul>


<h4>文本计算</h4>

<p>如果一个界面中包含大量文本（比如微博微信朋友圈等），文本的宽高计算会占用很大一部分资源，并且不可避免。如果你对文本显示没有特殊要求，可以参考下 UILabel 内部的实现方式：用 [NSAttributedString boundingRectWithSize:options:context:] 来计算文本宽高，用 -[NSAttributedString drawWithRect:options:context:] 来绘制文本。尽管这两个方法性能不错，但仍旧需要放到后台线程进行以避免阻塞主线程。</p>

<blockquote><p>注意：如果你用 CoreText 绘制文本，那就可以先生成 CoreText 排版对象，然后自己计算了，并且 CoreText 对象还能保留以供稍后绘制使用。</p></blockquote>

<h4>文本渲染</h4>

<p>屏幕上能看到的所有文本内容控件，包括 UIWebView，在底层都是通过 CoreText 排版、绘制为 Bitmap 显示的。常见的文本控件 （UILabel、UITextView 等），其排版和绘制都是在主线程进行的，当显示大量文本时，CPU 的压力会非常大。对此解决方案只有一个，那就是自定义文本控件，用 TextKit 或最底层的 CoreText 对文本异步绘制。尽管这实现起来非常麻烦，但其带来的优势也非常大，CoreText 对象创建好后，能直接获取文本的宽高等信息，避免了多次计算（调整 UILabel 大小时算一遍、UILabel 绘制时内部再算一遍）；CoreText 对象占用内存较少，可以缓存下来以备稍后多次渲染。</p>

<h4>图片的解码</h4>

<p>当你用 UIImage 或 CGImageSource 的那几个方法创建图片时，图片数据并不会立刻解码。图片设置到 UIImageView 或者 CALayer.contents 中去，并且 CALayer 被提交到 GPU 前，CGImage 中的数据才会得到解码。这一步是发生在主线程的，并且不可避免。如果想要绕开这个机制，常见的做法是在后台线程先把图片绘制到 CGBitmapContext 中，然后从 Bitmap 直接创建图片。目前常见的网络图片库都自带这个功能。</p>

<h4>图像的绘制</h4>

<p>图像的绘制通常是指用那些以 CG 开头的方法把图像绘制到画布中，然后从画布创建图片并显示这样一个过程。这个最常见的地方就是 [UIView drawRect:] 里面了。由于 CoreGraphic 方法通常都是线程安全的，所以图像的绘制可以很容易的放到后台线程进行。一个简单异步绘制的过程大致如下（实际情况会比这个复杂得多，但原理基本一致）：</p>

<pre><code>- (void)display {

    dispatch_async(backgroundQueue, ^{

    CGContextRef ctx = CGBitmapContextCreate(...);

    // draw in context...

    CGImageRef img = CGBitmapContextCreateImage(ctx);

    CFRelease(ctx);

    dispatch_async(mainQueue, ^{

        layer.contents = img;

    });

    });
}
</code></pre>

<h2>GPU 资源消耗原因和解决方案</h2>

<p>相对于 CPU 来说，GPU 能干的事情比较单一：接收提交的纹理（Texture）和顶点描述（三角形），应用变换（transform）、混合并渲染，然后输出到屏幕上。通常你所能看到的内容，主要也就是纹理（图片）和形状（三角模拟的矢量图形）两类。</p>

<h4>纹理的渲染</h4>

<p>所有的 Bitmap，包括图片、文本、栅格化的内容，最终都要由内存提交到显存，绑定为 GPU Texture。不论是提交到显存的过程，还是 GPU 调整和渲染 Texture 的过程，都要消耗不少 GPU 资源。当在较短时间显示大量图片时（比如 TableView 存在非常多的图片并且快速滑动时），CPU 占用率很低，GPU 占用非常高，界面仍然会掉帧。避免这种情况的方法只能是尽量减少在短时间内大量图片的显示，尽可能将多张图片合成为一张进行显示。</p>

<blockquote><p>注意：当图片过大，超过 GPU 的最大纹理尺寸时，图片需要先由 CPU 进行预处理，这对 CPU 和 GPU 都会带来额外的资源消耗。目前来说，iPhone 4S 以上机型，纹理尺寸上限都是 4096x4096，更详细的资料可以看这里：iosres.com。所以，尽量不要让图片和视图的大小超过这个值。</p></blockquote>

<h4>视图的混合 (Composing)</h4>

<p>当多个视图（或者说 CALayer）重叠在一起显示时，GPU 会首先把他们混合到一起。如果视图结构过于复杂，混合的过程也会消耗很多 GPU 资源。为了减轻这种情况的 GPU 消耗，应用应当尽量减少视图数量和层次，并在不透明的视图里标明 opaque 属性以避免无用的 Alpha 通道合成。当然，这也可以用上面的方法，把多个视图预先渲染为一张图片来显示。</p>

<h4>图形的生成</h4>

<p>CALayer 的 border、圆角、阴影、遮罩（mask），CASharpLayer 的矢量图形显示，通常会触发离屏渲染（offscreen rendering），而离屏渲染通常发生在 GPU 中。当一个列表视图中出现大量圆角的 CALayer，并且快速滑动时，可以观察到 GPU 资源已经占满，而 CPU 资源消耗很少。这时界面仍然能正常滑动，但平均帧数会降到很低。为了避免这种情况，可以尝试开启 CALayer.shouldRasterize 属性，但这会把原本离屏渲染的操作转嫁到 CPU 上去。对于只需要圆角的某些场合，也可以用一张已经绘制好的圆角图片覆盖到原本视图上面来模拟相同的视觉效果。最彻底的解决办法，就是把需要显示的图形在后台线程绘制为图片，避免使用圆角、阴影、遮罩等属性。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2015/11/16/appqia-dun-liao-zen-yao-ban-%3F/">阅读全文😘</a>
    </footer>
  




| <a href="/blog/2015/11/16/appqia-dun-liao-zen-yao-ban-%3F/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/11/08/nian-tie-shen-jiu/">粘贴深究</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><p>在iOS中，可以使用剪贴板实现应用程序之中以及应用程序之间实现数据的共享。比如你可以从iPhone QQ复制一个url，然后粘贴到safari浏览器中查看这个链接的内容。</p>

<h3>一、在iOS中下面三个控件，自身就有复制-粘贴的功能：</h3>

<ul>
<li>1、UITextView</li>
<li>2、UITextField</li>
<li>3、UIWebView</li>
</ul>


<h3>二、UIKit framework提供了几个类和协议方便我们在自己的应用程序中实现剪贴板的功能。</h3>

<ul>
<li>1、UIPasteboard：我们可以向其中写入数据，也可以读取数据</li>
<li>2、UIMenuController：显示一个快捷菜单，用来复制、剪贴、粘贴选择的项。</li>
<li>3、UIResponder中的 canPerformAction:withSender:用于控制哪些命令显示在快捷菜单中。</li>
<li>4、当快捷菜单上的命令点击的时候，UIResponderStandardEditActions将会被调用。</li>
</ul>


<h3>三、下面这些项能被放置到剪贴板中</h3>

<ul>
<li>1、UIPasteboardTypeListString —  字符串数组, 包含kUTTypeUTF8PlainText</li>
<li>2、UIPasteboardTypeListURL —   URL数组，包含kUTTypeURL</li>
<li>3、UIPasteboardTypeListImage —   图形数组, 包含kUTTypePNG 和kUTTypeJPEG</li>
<li>4、UIPasteboardTypeListColor —   颜色数组</li>
</ul>


<h3>四、剪贴板的类型分为两种：</h3>

<p>系统级：使用UIPasteboardNameGeneral和UIPasteboardNameFind创建，系统级的剪贴板，当应用程序关闭，或者卸载时，数据都不会丢失。
应用程序级：通过设置，可以让数据在应用程序关闭之后仍然保存在剪贴板中，但是应用程序卸载之后数据就会失去。我们可用通过pasteboardWithName:create：来创建。</p>

<p>了解这些之后，下面通过一系列的例子来说明如何在应用程序中使用剪贴板。</p>

<p>例子：</p>

<h5>1、复制剪贴文本。</h5>

<pre><code>下面通过一个例子，可以在tableview上显示一个快捷菜单，上面只有复制按钮，复制tableview上的数据之后，然后粘贴到title上。
</code></pre>

<p>定义一个单元格类CopyTableViewCell，在这个类的上显示快捷菜单，实现复制功能。</p>

<pre><code>@interface CopyTableViewCell : UITableViewCell {
    id delegate;
}
@property (nonatomic, retain) id delegate;
@end
</code></pre>

<p>实现CopyTableViewCell ：</p>

<pre><code>#import "CopyTableViewCell.h"

@implementation CopyTableViewCell

@synthesize delegate;

- (id)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier {
    if ((self = [super initWithStyle:style reuseIdentifier:reuseIdentifier])) {
    }
    return self;
}
- (void)setSelected:(BOOL)selected animated:(BOOL)animated {
    [super setSelected:selected animated:animated];
}
- (void)setHighlighted:(BOOL)highlighted animated:(BOOL)animated {
    [[self delegate] performSelector:@selector(showMenu:)
                          withObject:self afterDelay:0.9f];

    [super setHighlighted:highlighted animated:animated];

}
- (BOOL)canBecomeFirstResponder
{
    return YES;
}
- (BOOL)canPerformAction:(SEL)action withSender:(id)sender{
    if (action == @selector(cut:)){
        return NO;
    }
    else if(action == @selector(copy:)){
        return YES;
    }
    else if(action == @selector(paste:)){
        return NO;
    }
    else if(action == @selector(select:)){
        return NO;
    }
    else if(action == @selector(selectAll:)){
        return NO;
    }
    else
    {
        return [super canPerformAction:action withSender:sender];
    }
}
- (void)copy:(id)sender {
    UIPasteboard *pasteboard = [UIPasteboard generalPasteboard];
    [pasteboard setString:[[self textLabel]text]];
}
- (void)dealloc {
    [super dealloc];
}
@end
</code></pre>

<p>复制代码
定义CopyPasteTextController，实现粘贴功能。
    @interface CopyPasteTextController : UIViewController<UITableViewDelegate> {
        //用来标识是否显示快捷菜单
        BOOL menuVisible;
        UITableView *tableView;
    }</p>

<pre><code>@property (nonatomic, getter=isMenuVisible) BOOL menuVisible;

@property (nonatomic, retain) IBOutlet UITableView *tableView;
@end
</code></pre>

<p>实现CopyPasteTextController ：</p>

<pre><code>#import "CopyPasteTextController.h"
#import "CopyTableViewCell.h"

@implementation CopyPasteTextController
@synthesize menuVisible,tableView;
- (void)viewDidLoad {
    [super viewDidLoad];
    [self setTitle:@"文字复制粘贴"];
    //点击这个按钮将剪贴板的内容粘贴到title上
    UIBarButtonItem *addButton = [[[UIBarButtonItem alloc]
                                      initWithBarButtonSystemItem:UIBarButtonSystemItemRefresh
                                      target:self
                                      action:@selector(readFromPasteboard:)]
                                     autorelease];
    [[self navigationItem] setRightBarButtonItem:addButton];
}


// Customize the number of sections in the table view.
- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView
{
    return 1;
}

- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section
{
    return 9;
}

// Customize the appearance of table view cells.
- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath
{
    static NSString *CellIdentifier =@"Cell";
    CopyTableViewCell *cell = (CopyTableViewCell *)[tableView
                                                           dequeueReusableCellWithIdentifier:CellIdentifier];
    if (cell == nil)
    {
        cell = [[[CopyTableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:CellIdentifier] autorelease];
        [cell setDelegate:self];
    }

    // Configure the cell.
    NSString *text = [NSString stringWithFormat:@"Row %d", [indexPath row]];
    [[cell textLabel] setText:text];
    return cell;
}

- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath
{
    if([self isMenuVisible])
    {
        return;
    }
    [[[self tableView] cellForRowAtIndexPath:indexPath] setSelected:YES
                                                           animated:YES];
}
//显示菜单
- (void)showMenu:(id)cell {
    if ([cell isHighlighted]) {
        [cell becomeFirstResponder];

        UIMenuController * menu = [UIMenuController sharedMenuController];
        [menu setTargetRect: [cell frame] inView: [self view]];
        [menu setMenuVisible: YES animated: YES];
    }
}
- (void)readFromPasteboard:(id)sender {
    [self setTitle:[NSString stringWithFormat:@"Pasteboard = %@",
                      [[UIPasteboard generalPasteboard] string]]];
}

- (void)didReceiveMemoryWarning
{
    // Releases the view if it doesn't have a superview.
    [super didReceiveMemoryWarning];

    // Relinquish ownership any cached data, images, etc that aren't in use.
}

- (void)viewDidUnload
{
    [super viewDidUnload];
    [self.tableView release];

    // Relinquish ownership of anything that can be recreated in viewDidLoad or on demand.
    // For example: self.myOutlet = nil;
}
</code></pre>

<p>复制一行数据：
点击右上角的按钮粘贴，将数据显示在title上：</p>

<h6>2、图片复制粘贴</h6>

<p>   下面通过一个例子，将图片复制和剪贴到另外一个UIImageView中间。</p>

<ul>
<li>1、在界面上放置两个uiimageview，一个是图片的数据源，一个是将图片粘贴到的地方。CopyPasteImageViewController 代码如下：</li>
</ul>


<p>@interface CopyPasteImageViewController : UIViewController {
    UIImageView <em>imageView;
    UIImageView </em>pasteView;
    UIImageView <em>selectedView;
}
@property (nonatomic, retain) IBOutlet UIImageView </em>imageView;
@property (nonatomic, retain) IBOutlet UIImageView <em>pasteView;
@property (nonatomic, retain) UIImageView </em>selectedView;
- (void)placeImageOnPasteboard:(id)view;
@end
* 2、当触摸图片的时候我们显示快捷菜单：</p>

<hr />

<pre><code>- (void)touchesBegan:(NSSet*)touches withEvent:(UIEvent*)event {
    NSSet *copyTouches = [event touchesForView:imageView];
    NSSet *pasteTouches = [event touchesForView:pasteView];

    [self becomeFirstResponder];
    if ([copyTouches count] &gt; 0) {
        [self performSelector:@selector(showMenu:)
                   withObject:imageView afterDelay:0.9f];
    }
    else  if([pasteTouches count] &gt; 0) {
        [self performSelector:@selector(showMenu:)
                   withObject:pasteView afterDelay:0.9f];
    }
    [super touchesBegan:touches withEvent:event];
}

- (void)showMenu:(id)view {
    [self setSelectedView:view];

    UIMenuController * menu = [UIMenuController sharedMenuController];
    [menu setTargetRect: CGRectMake(5, 10, 1, 1) inView: view];
    [menu setMenuVisible: YES animated: YES];
}
</code></pre>

<p>这里的快捷菜单，显示三个菜单项：剪贴、粘贴、复制：</p>

<hr />

<pre><code>- (BOOL)canPerformAction:(SEL)action withSender:(id)sender{
    if (action == @selector(cut:)) {
        return ([self selectedView] == imageView) ? YES : NO;
    } else if (action == @selector(copy:)) {
        return ([self selectedView] == imageView) ? YES : NO;
    } else if (action == @selector(paste:)) {
        return ([self selectedView] == pasteView) ? YES : NO;
    } else if (action == @selector(select:)) {
        return NO;
    } else if (action == @selector(selectAll:)) {
        return NO;
    } else {
        return [super canPerformAction:action withSender:sender];
    }
}
- (void)cut:(id)sender {
    [self copy:sender];
    [imageView setHidden:YES];
}
- (void)copy:(id)sender {
    [self placeImageOnPasteboard:[self imageView]];
}
- (void)paste:(id)sender {
    UIPasteboard *appPasteBoard =
    [UIPasteboard pasteboardWithName:@"CopyPasteImage" create:YES];
    NSData *data =[appPasteBoard dataForPasteboardType:@"com.marizack.CopyPasteImage.imageView"];
    pasteView.image = [UIImage imageWithData:data];
}
</code></pre>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2015/11/08/nian-tie-shen-jiu/">阅读全文😘</a>
    </footer>
  




| <a href="/blog/2015/11/08/nian-tie-shen-jiu/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/11/03/chang-yong-guan-jian-zi-zong-jie/">常用关键字总结</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><table>
<thead>
<tr>
<th> Name  </th>
<th style="text-align:center;"> Typedef</th>
<th style="text-align:right;">  Header</th>
<th>     True Value  </th>
<th> False Value</th>
</tr>
</thead>
<tbody>
<tr>
<td> BOOL</td>
<td style="text-align:center;">     signed char objc.h</td>
<td style="text-align:right;">     YES</td>
<td>    NO</td>
<td></td>
</tr>
<tr>
<td> bool  </td>
<td style="text-align:center;"> _Bool (int)   </td>
<td style="text-align:right;"> stdbool.h true    </td>
<td> false</td>
<td></td>
</tr>
<tr>
<td> Boolean</td>
<td style="text-align:center;">  unsigned char</td>
<td style="text-align:right;">  MacTypes.h  TRUE    </td>
<td> FALSE</td>
<td></td>
</tr>
<tr>
<td> NSNumber</td>
<td style="text-align:center;">     __NSCFBoolean</td>
<td style="text-align:right;">  Foundation.h    </td>
<td> @(YES)</td>
<td>   @(NO)</td>
</tr>
<tr>
<td> CFBooleanRef</td>
<td style="text-align:center;">     struct</td>
<td style="text-align:right;">     CoreFoundation.h    </td>
<td> kCFBooleanTrue</td>
<td>   kCFBooleanFalse</td>
</tr>
</tbody>
</table>


<table>
<thead>
<tr>
<th> 标志    </th>
<th style="text-align:center;"> 值</th>
<th style="text-align:right;">  含义</th>
</tr>
</thead>
<tbody>
<tr>
<td> NULL</td>
<td style="text-align:center;">     (void *)0   </td>
<td style="text-align:right;"> C指针的字面零值</td>
</tr>
<tr>
<td> nil   </td>
<td style="text-align:center;"> (id)0 </td>
<td style="text-align:right;"> Objective-C对象的字面零值</td>
</tr>
<tr>
<td> Nil   </td>
<td style="text-align:center;"> (Class)0  </td>
<td style="text-align:right;"> Objective-C类的字面零值</td>
</tr>
<tr>
<td> NSNull    </td>
<td style="text-align:center;"> [NSNull null] </td>
<td style="text-align:right;"> 用来表示零值的单独的对象</td>
</tr>
</tbody>
</table>

</div>
  
  




| <a href="/blog/2015/11/03/chang-yong-guan-jian-zi-zong-jie/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/10/06/quan-ping-fan-hui-(runtime)/">全屏返回（Runtime）</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><blockquote><p>前言</p>

<p>此次文章，讲述的是导航控制器全屏滑动返回效果，而且代码量非常少，10行内搞定。</p></blockquote>

<p>如果喜欢我的文章，可以关注我，也可以来小码哥，了解下我们的iOS培训课程。陆续还会有更新ing&hellip;.</p>

<h5>一、自定义导航控制器</h5>

<p>目的：以后需要使用全屏滑动返回功能，就使用自己定义的导航控制器。</p>

<h5>二、分析导航控制器侧滑功能</h5>

<p>效果：导航控制器默认自带了侧滑功能，当用户在界面的左边滑动的时候，就会有侧滑功能。</p>

<p>系统自带的侧滑效果：</p>

<p>分析：</p>

<ul>
<li><p>1.导航控制器的view自带了滑动手势，只不过手势的触发范围只能在左边。</p></li>
<li><p>2.当用户在界面左边拖动，就会触发滑动手势方法，并且有滑动返回功能，说明系统手势触发的方法已经实现了滑动返回功能。</p></li>
<li><p>3.为什么说系统手势触发的方法已经实现了滑动返回功能？</p></li>
</ul>


<h3>原因：</h3>

<p>创建滑动手势对象的时候，需要绑定监听者，当触发手势的时候会调用target的action。</p>

<p>UIPanGestureRecognizer *pan = [[UIPanGestureRecognizer alloc] initWithTarget:target action:action];
当用户在界面左边滑动，有滑动返回功能，这是因为触发手势了，调用target的action方法，说明action方法内部实现滑动返回功能，否则就不会有滑动返回效果。</p>

<h5>三、实现全屏滑动功能分析</h5>

<p>打印导航控制器自带的滑动手势，看下它的真实面目。</p>

<p>系统自带的滑动手势interactivePopGestureRecognizer</p>

<pre><code>//  self指向的导航控制器，在导航控制器的viewDidLoad方法打印 
- (void)viewDidLoad { 
    [super viewDidLoad]; 
    NSLog(@"%@",self.interactivePopGestureRecognizer); 
} 
</code></pre>

<p>由图中可知：</p>

<ul>
<li><p>1.系统自带的手势是UIScreenEdgePanGestureRecognizer类型对象,屏幕边缘滑动手势</p></li>
<li><p>2.系统自带手势target是_UINavigationInteractiveTransition类型的对象</p></li>
<li><p>3.target调用的action方法名叫handleNavigationTransition:</p></li>
</ul>


<p>分析：</p>

<p>UIScreenEdgePanGestureRecognizer，看名称就知道，这个手势的范围只能在屏幕的周边，就是因为这个手势，系统自带的滑动效果，只能实现侧边滑动。</p>

<h5>四、如何实现全屏滑动功能</h5>

<p>给自己的导航控制器，添加一个全屏的滑动手势，调用系统自带滑动手势的target的action方法，利用系统实现的滑动返回功能，加上自己全屏滑动手势，就有全屏滑动功能了。</p>

<p>问题：如何拿到系统自带的target对象?，action方法名已经知道，而且系统肯定在target对象实现了，只要拿到target对象，调用这个方法就行。</p>

<p>通过打印系统自带的滑动手势的代理，发现正好是_UINavigationInteractiveTransition对象，因此我猜测这个代理对象就是target对象,只要拿到它，就拿到系统自带滑动手势的target对象。</p>

<pre><code>// 打印系统自带滑动手势的代理对象 
SLog(@"%@",self.interactivePopGestureRecognizer.delegate); 
</code></pre>

<p>导航控制器全屏滑动注意点:</p>

<ul>
<li><p>1.禁止系统自带滑动手势使用。</p></li>
<li><p>2.只有导航控制器的非根控制器才需要触发手势，使用手势代理，控制手势触发。</p></li>
</ul>


<p>全屏滑动代码实现</p>

<pre><code>- (void)viewDidLoad { 
    [super viewDidLoad]; 
    // 获取系统自带滑动手势的target对象 
    id target = self.interactivePopGestureRecognizer.delegate; 
    // 创建全屏滑动手势，调用系统自带滑动手势的target的action方法 
    UIPanGestureRecognizer *pan = [[UIPanGestureRecognizer alloc] initWithTarget:target action:@selector(handleNavigationTransition:)]; 
    // 设置手势代理，拦截手势触发 
    pan.delegate = self; 
    // 给导航控制器的view添加全屏滑动手势 
    [self.view addGestureRecognizer:pan]; 
    // 禁止使用系统自带的滑动手势 
    self.interactivePopGestureRecognizer.enabled = NO; 
} 
// 什么时候调用：每次触发手势之前都会询问下代理，是否触发。 
// 作用：拦截手势触发 
- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer 
{ 
    // 注意：只有非根控制器才有滑动返回功能，根控制器没有。 
    // 判断导航控制器是否只有一个子控制器，如果只有一个子控制器，肯定是根控制器 
    if (self.childViewControllers.count == 1) { 
        // 表示用户在根控制器界面，就不需要触发滑动手势， 
        return NO; 
    } 
    return YES; 
} 
</code></pre>
</div>
  
  




| <a href="/blog/2015/10/06/quan-ping-fan-hui-(runtime)/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/09/22/qie-huan-kong-zhi-qi/">切换控制器</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><p>从一个视图控制器切换到另一个视图控制器的几种方式</p>

<h4>1,模态(modal)画面的显示方法：</h4>

<p>例如iphone通讯录管理程序中，追加新的通讯纪录时，就是使用这种模态画面
例：点击一个按钮，进入另一个界面
    - (IBAction)pressAbout:(id)sender {</p>

<pre><code>iCocosViewController *iCocos=[[[iCocosViewController alloc] initWithNibName:@"iCocosViewController" bundle:nil] autorelease];

[self presentModalViewController:aboutanimated:YES];//显示模态画面

关闭模态画面的方法：

[self dissmissModalViewControllerAnimationed:YES];
</code></pre>

<h4>2,SwitchViewController中有2个控制器的属性：BviewController,CViewController</h4>

<ul>
<li>使用方法：insertSubview: atIndex:
这种画面跳转方法并非最佳的跳转方法：</li>
<li>实际上并非真的实现了两个画面间的跳转，而是同时启动了2个画面，控制其中哪一个画面显示在前台，哪一个画面显示在后台而已。</li>
<li>这种画面跳转方式有一个很大的缺点，即当画面数量增加时，画面跳转的实现代码将月来越复杂，而且各个画面间不可避免的有相互依赖关系。</li>
</ul>


<h4>3,UITabBarController实现并列画面跳转（这里其实就是window的切花）</h4>

<pre><code>//将5个viewController实例放入TabBar的viewcontrollers属性中    

self.tabBarController.viewControllers = @[navFrist, navSecond,navThird,navFourth,navFifth];   

self.window.rootViewController = self.tabBarController;

[self.window addSubview:self.tabBarController.view];//将根控制器的视图加到应用程序主窗口
</code></pre>

<h4>4,UINavigationController实现多层画面跳转，在导航控制器中，载入有层级关系的界面</h4>

<pre><code>- (IBAction)addRightAction:(id)sender
{
    iCocosViewController *iCocos=[[[iCocosViewController alloc]initWithNibName:@"iCocosViewController" bundle:nil] autorelease];

[self.navigationController pushViewController:aiCocos animated:YES];
}
</code></pre>
</div>
  
  




| <a href="/blog/2015/09/22/qie-huan-kong-zhi-qi/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/08/21/scrollviewhui-dao-ding-bu-fu-yuan/">ScrollView回到顶部复原</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><p>相信细心的开发者都会发现scrollView自带一个功能,当用户点击顶部的状态栏时,scrollView的ContentOffset.y轴会自动滚动到初始位置,效果如图所示:</p>

<blockquote><p>单个scrollView单击顶部状态栏系统自带功能展示</p></blockquote>

<p>这个功能对用户来说非常实用,尤其是在scrollView(TableView, WebView, CollectionView一切继承scrollView的控件)展示的内容很多,当用户翻看很久以后,想回到最顶部时,只需单击一下顶部的状态栏位置就可以轻松返回到顶部(这里吐槽下.貌似很多用户都不知道有这个功能),而不用使劲用手滑动到顶部.</p>

<ul>
<li>可是功能在当前控制器有多个scrollView(TableView, WebView, CollectionView一切继承scrollView的控件)的时候就会失效,效果如下图所示:</li>
</ul>


<p>当控制器内有多个scrollView时,系统自带的滚动到顶的功能就会失效</p>

<p>实际开发中,我们的产品在同一个控制器经常会有多个scrollView组合在一起的情况,这就意味着系统的方法已经失效了,需要开发人员自己来实现这个效果,下面我们就来搞定这个需求</p>

<blockquote><p>我们分析下原生的方法为什么会失效,当一个控制器内只有一个scrollView时,点击状态栏,系统会遍历当前keyWindow的子控件,发现子控件中只有一个scrollView会调用这个scrollView的setContentOffset: animated:的这个方法,将scrollView的contentOffset.y值修改为初始值,但是当子控件中又多个scrollView时,系统会不知道掉用哪一个scrollView而失效,知道这点我们就知道该如何搞定这个问题了</p></blockquote>

<p>这里就直接将解决思路一一写出来不将代码分段展示了,在代码中我加了详细的注释objective-c的套路和swift基本一样,在最后会将Swift和objective-c的代码一起放上,如果需要直接解决问题的童鞋可以直接将代码拷贝到工程里即可</p>

<ul>
<li>首先创建一个topWindow继承至NSObject,这里我们考虑将这个功能完全封装起来,所以所有的方法都用的类方法,所以用最基本的类就可以</li>
<li>在initialize方法中初始化topWIndow,将topWIndow的级别改成最高的UIWindowLevelAlert级别,设置topWindow位置,并且添加点击手势</li>
<li>在topWIndow被点击调用的方法中,我们拿出UIApplication的keyWindow,遍历keyWindow的所有子控件,如果满足是scrollView同时又显示在当前keyWindow条件时,将subView的contentOffset的y值回复到原始</li>
<li>然后采用递归的套路在遍历subView内时候有满足条件的子控件,直到没有满足条件时会停止</li>
</ul>


<h4>Swift的代码</h4>

<pre><code>import UIKit
class TopWindow: UIWindow {
    private static let window_: UIWindow = UIWindow()
    ///  类初始化方法,保证window_只被创建一次
    override class func initialize() {
        window_.frame = CGRectMake(0, 0, global.appWidth, 20)
        window_.windowLevel = UIWindowLevelAlert
        window_.addGestureRecognizer(UITapGestureRecognizer(target: self, action: "topWindowClick"))
    }
    class func topWindowClick() {
        // 遍历当前主窗口所有view,将满足条件的scrollView滚动回原位
        searchAllowScrollViewInView(UIApplication.sharedApplication().keyWindow!)
    }
    private class func searchAllowScrollViewInView(superView: UIView) {
        for subview: UIView in superView.subviews as! [UIView] {
            if subview.isKindOfClass(UIScrollView.self) &amp;&amp; superView.viewIsInKeyWindow() {
                // 拿到scrollView的contentOffset
                var offest = (subview as! UIScrollView).contentOffset
                // 将offest的y轴还原成最开始的值
                offest.y = -(subview as! UIScrollView).contentInset.top
                // 重新设置scrollView的内容
                (subview as! UIScrollView).setContentOffset(offest, animated: true)
            }
            // 递归,让子控件再次调用这个方法判断时候还有满足条件的view
            searchAllowScrollViewInView(subview)
        }
    }
    ///  添加topWindow,使手势生效
    class func showTopWindow() {
        window_.hidden = false
    }
    ///  隐藏topWindow,移除手势
    class func hiddenTopWindow() {
        window_.hidden = true
    }
}
///  对UIView的一个扩展
extension UIView {
    ///  判断调用方法的view是否在keyWindow中
    func viewIsInKeyWindow() -&gt; Bool {
        let keyWindow = UIApplication.sharedApplication().keyWindow!
        // 将当前view的坐标系转换到window.bounds
        let viewNewFrame = keyWindow.convertRect(self.frame, fromView: self.superview)
        let keyWindowBounds = keyWindow.bounds
        // 判断当前view是否在keyWindow的范围内
        let isIntersects = CGRectIntersectsRect(viewNewFrame, keyWindowBounds)
        // 判断是否满足所有条件
        return !self.hidden &amp;&amp; self.alpha &gt; 0.01 &amp;&amp; self.window == keyWindow &amp;&amp; isIntersects
    }   
}
</code></pre>

<p>在AppDelegate里,程序启动完成方法时添加就OK了</p>

<pre><code>  func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -&gt; Bool {
      // 添加顶部的window
      TopWindow.showTopWindow()
      return true
  }
</code></pre>

<p>需要注意添加了自定义的window后,控制器的改变状态栏状态方法会失效,可以在info.plist中将改变状态栏的管理权交给UIApplication解决,或者在需要改变状态栏的控制器中调用TopWindow.hiddenTopWindow()即可,或者直接改info.plist,用UIApplication.sharedApplication().setStatusBarStyle来管理</p>

<h4>Objective-C代码</h4>

<p>.h文件只暴露显示和隐藏方法</p>

<pre><code>#import @interface WNXTopWindow : NSObject
+ (void)show;
+ (void)hide;
@end
</code></pre>

<p>.m文件</p>

<pre><code>#import "WNXTopWindow.h"
@implementation WNXTopWindow
static UIWindow *window_;
//初始化window
+ (void)initialize {
  window_ = [[UIWindow alloc] init];
  window_.frame = CGRectMake(0, 0, [UIScreen mainScreen].bounds.size.width, 20);
  window_.windowLevel = UIWindowLevelAlert;
  [window_ addGestureRecognizer:[[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(windowClick)]];
}  
+ (void)show {
  window_.hidden = NO;
}
+ (void)hide {
  window_.hidden = YES;
}
// 监听窗口点击
+ (void)windowClick {
  UIWindow *window = [UIApplication sharedApplication].keyWindow;
  [self searchScrollViewInView:window];
}
+ (void)searchScrollViewInView:(UIView *)superview {
  for (UIScrollView *subview in superview.subviews) {
      // 如果是scrollview, 滚动最顶部
      if ([subview isKindOfClass:[UIScrollView class]] &amp;&amp; [subview isShowingOnKeyWindow]) {
          CGPoint offset = subview.contentOffset;
          offset.y = - subview.contentInset.top;
          [subview setContentOffset:offset animated:YES];
      }
      // 递归继续查找子控件
      [self searchScrollViewInView:subview];
  }
}
+ (BOOL)isShowingOnKeyWindow:(UIView *)view {
  // 主窗口
  UIWindow *keyWindow = [UIApplication sharedApplication].keyWindow;
  // 以主窗口左上角为坐标原点, 计算self的矩形框
  CGRect newFrame = [keyWindow convertRect:view.frame fromView:view.superview];
  CGRect winBounds = keyWindow.bounds;
  // 主窗口的bounds 和 self的矩形框 是否有重叠
  BOOL intersects = CGRectIntersectsRect(newFrame, winBounds);
  return !view.isHidden &amp;&amp; view.alpha &gt; 0.01 &amp;&amp; view.window == keyWindow &amp;&amp; intersects;
}
@end
</code></pre>

<p>同样,也是在程序初始化完成AppDelegate文件中显示topWindow,整个工程这个问题就统统解决了</p>

<pre><code>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
  // 添加一个window, 点击这个window, 可以让屏幕上的scrollView滚到最顶部
  [WNXTopWindow show];
  return YES;
}
</code></pre>
</div>
  
  




| <a href="/blog/2015/08/21/scrollviewhui-dao-ding-bu-fu-yuan/#comments">更多评论</a>

    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/4">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/2">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
    <h1>文章分类</h1>
    <ul id="categories">
        <li class='category'><a href='/blog/categories/全栈工程师必备/'>全栈工程师必备 (1)</a></li>
<li class='category'><a href='/blog/categories/底层开发/'>底层开发 (3)</a></li>
<li class='category'><a href='/blog/categories/开发工具/'>开发工具 (1)</a></li>
<li class='category'><a href='/blog/categories/性能相关/'>性能相关 (6)</a></li>
<li class='category'><a href='/blog/categories/性能问题/'>性能问题 (1)</a></li>
<li class='category'><a href='/blog/categories/新技术/'>新技术 (1)</a></li>
<li class='category'><a href='/blog/categories/欢迎来到ios梦工厂/'>欢迎来到ios梦工厂 (1)</a></li>
<li class='category'><a href='/blog/categories/程序员必备/'>程序员必备 (2)</a></li>
<li class='category'><a href='/blog/categories/适配问题/'>适配问题 (1)</a></li>
<li class='category'><a href='/blog/categories/面试总结-技术/'>面试总结＋技术 (1)</a></li>
<li class='category'><a href='/blog/categories/项目实战/'>项目实战 (11)</a></li>
<li class='category'><a href='/blog/categories/高级开发/'>高级开发 (11)</a></li>

    </ul>
</section><section>
  <h1>最新文章</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/12/10/h5ying-yong-shi-zhan/">H5应用实战</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/12/10/core-image-chu-tan/">Core Image 初探</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/12/09/wan-zheng-ding-shi-qi/">玩转定时器</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/12/09/shi-jian-chu-li-yu-tu-xiang-xuan-ran-shen-jiu/">事件处理与图像渲染深究</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/12/08/watch-os2-chu-tan/">Watch OS2 初探</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/al1020119">@al1020119</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'al1020119',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>




<section>
<h1>扫一扫<abbr title="The word '扫一扫' is a registered trademark of DENSO WAVE INCORPORATED. It applies only for the word '扫一扫', not for image.">&trade;</abbr></h1>
<a href="http://al1020119.github.io/posts/3/index.html"><img src="http://chart.apis.google.com/chart?chs=150x150&cht=qr&chld=|0&chco=165B94&chl=http://al1020119.github.io/posts/3/index.html" alt="post-qrcode"></a></section>
<section>
    <h1>访客统计</h1>
    <br/>
    <a href="http://s07.flagcounter.com/more/2SH"><img src="http://s07.flagcounter.com/count/2SH/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_1/flags_0/" alt="Flag Counter" border="0"></a>
</section><section>
    <h1>新浪微博</h1>
    <ul id="weibo">
        <li>
            
            <!-- 在此插入获得的微博秀代码 -->
            <iframe width="100%" height="550" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=550&fansRow=2&ptype=1&speed=0&skin=1&isTitle=1&noborder=1&isWeibo=1&isFans=1&uid=3288975567&verifier=20ffcedd&dpc=1"></iframe>
            
        </li>
    </ul>
</section>
  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - iCocos -
<span class="credit">Preview in <a href="http://al1020119.github.io">[曹#黎]</a></span>
</p>

</footer>
  






<!--
--->



</body>
</html>
