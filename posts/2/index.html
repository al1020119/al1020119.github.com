
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>iOS梦工厂</title>
  <meta name="author" content="iCocos">

  
  <meta name="description" content="引用：http://log.fyscu.com/index.php/archives/28/ 文件格式
m3u文件是用来描述一个或多个媒体文件地址的纯文本文件，通常以 M3U 或 m3u 作为扩展名。 m3u文件里描述的最小单位（元素/行/记录），可以是一下三者之一： 1.一个文件的绝对路径
2. &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://al1020119.github.io/posts/2/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="iOS梦工厂" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//libs.baidu.com/jquery/1.7.2/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->

<!--<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
-->
  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">iOS梦工厂</a></h1>
  
    <h2>iCocos——不战胜自己，何以改变未来！</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="al1020119.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">博文</a></li>
  <li><a href="/blog/archives">归档</a></li>
  <li><a href="/icocos">iCocos</a></li>
  <li><a href="/about">文章</a></li>
  <li><a href="/other">其他</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/09/06/m3u8/">直播-M3U8</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-09-06T14:41:56+08:00'><span class='date'><span class='date-month'>Sep</span> <span class='date-day'>6</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>2:41 pm</span></time>
        
        
        |   <a href="/blog/2016/09/06/m3u8/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>引用：<a href="http://log.fyscu.com/index.php/archives/28/">http://log.fyscu.com/index.php/archives/28/</a></p>

<pre><code>文件格式
m3u文件是用来描述一个或多个媒体文件地址的纯文本文件，通常以 M3U 或 m3u 作为扩展名。

m3u文件里描述的最小单位（元素/行/记录），可以是一下三者之一：

1.一个文件的绝对路径
2.相对于m3u文件的相对路径
3.一个网络url
</code></pre>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2016/09/06/m3u8/">阅读全文😘</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/09/05/zhi-bo-shi-pin-bian-jie-ma-h-dot-264/">直播-视频编解码H.264</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-09-05T14:41:34+08:00'><span class='date'><span class='date-month'>Sep</span> <span class='date-day'>5</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>2:41 pm</span></time>
        
        
        |   <a href="/blog/2016/09/05/zhi-bo-shi-pin-bian-jie-ma-h-dot-264/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><pre><code>1995年，ITU-T针对低比特率视频应用制定了H.263标准，当时H.263被公认为是以像素为基础的采用第一代编码技术混合编码方案所能 达到的最佳结果。在随后几年中，ITU-T又对其进行了多次完善，以提高编码效率，增强编码功能。1998年发布了H.263+；2000年发布了 H.263++。尽管采用H263编码技术较H261编码在压缩率和图像质量上都有大幅度的提升，但H.263信源编码算法的核心仍然是H.261标准中 采用的 DPCM/DCT混和编码算法，原理框图也和H.261十分相似。
</code></pre>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2016/09/05/zhi-bo-shi-pin-bian-jie-ma-h-dot-264/">阅读全文😘</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/09/03/zhi-bo-yin-pin-bian-jie-ma-acc/">直播-音频编解码ACC</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-09-03T14:41:15+08:00'><span class='date'><span class='date-month'>Sep</span> <span class='date-day'>3</span><span class='date-suffix'>rd</span>, <span class='date-year'>2016</span></span> <span class='time'>2:41 pm</span></time>
        
        
        |   <a href="/blog/2016/09/03/zhi-bo-yin-pin-bian-jie-ma-acc/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><ul>
<li><p>AAC是高级音频编码（Advanced Audio Coding）的缩写，出现于1997年，最初是基于MPEG-2的音频编码技术。由Fraunhofer IIS、Dolby Laboratories、AT&amp;T、Sony等公司共同开发，目的是取代MP3格式。2000年，MPEG-4标准出台，AAC重新集成了其它技术（PS,SBR），为区别于传统的MPEG-2 AAC，故含有SBR或PS特性的AAC又称为MPEG-4 AAC。</p></li>
<li><p>AAC是新一代的音频有损压缩技术，它通过一些附加的编码技术（比如PS,SBR等），衍生出了LC-AAC,HE-AAC,HE-AACv2三种主要的编码，LC-AAC就是比较传统的AAC，相对而言，主要用于中高码率(>=80Kbps)，HE-AAC(相当于AAC+SBR)主要用于中低码(&lt;=80Kbps)，而新近推出的HE-AACv2(相当于AAC+SBR+PS)主要用于低码率(&lt;=48Kbps）,事实上大部分编码器设成&lt;=48Kbps自动启用PS技术，而>48Kbps就不加PS,就相当于普通的HE-AAC。</p></li>
</ul>


</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2016/09/03/zhi-bo-yin-pin-bian-jie-ma-acc/">阅读全文😘</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/09/01/guan-yu-zhi-bo/">关于直播</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-09-01T14:39:39+08:00'><span class='date'><span class='date-month'>Sep</span> <span class='date-day'>1</span><span class='date-suffix'>st</span>, <span class='date-year'>2016</span></span> <span class='time'>2:39 pm</span></time>
        
        
        |   <a href="/blog/2016/09/01/guan-yu-zhi-bo/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p><img src="/images/zhibo001.png" title="Caption" ></p>

<p>关于直播，这里先推荐几篇相关的文字，都是非常经典的，虽然有些难，直播本来就很难，不难还叫直播吗？是吧！</p>

<p><a href="http://www.zhihu.com/question/42162310">知乎经典问答直播：如何搭建一个完整的视频直播系统？</a></p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2016/09/01/guan-yu-zhi-bo/">阅读全文😘</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/08/31/duo-xian-cheng-an-quan-%3Fge-chong-suo-de-shi-xian-yuan-li/">多线程安全？各种锁的实现原理😂</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-08-31T15:06:21+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>31</span><span class='date-suffix'>st</span>, <span class='date-year'>2016</span></span> <span class='time'>3:06 pm</span></time>
        
        
        |   <a href="/blog/2016/08/31/duo-xian-cheng-an-quan-%3Fge-chong-suo-de-shi-xian-yuan-li/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>本文要做的就是简单的分析 iOS 开发中常见的几种锁如何实现，以及优缺点是什么，为什么会有性能上的差距，最终会简单的介绍锁的底层实现原理。水平有限，如果不慎有误，欢迎交流指正。同时建议读者在阅读本文以前，对 OC 中各种锁的使用方法先有大概的认识。</p>

<p>在 ibireme 的 不再安全的 OSSpinLock 一文中，有一张图片简单的比较了各种锁的加解锁性能:</p>

<p><img src="/images/duoxianchengsuoshixianyuanli001.png" title="Caption" ></p>

<p>本文会按照从上至下(速度由快至慢)的顺序分析每个锁的实现原理。需要说明的是，加解锁速度不表示锁的效率，只表示加解锁操作在执行时的复杂程度，下文会通过具体的例子来解释。</p>

<h2>OSSpinLock</h2>

<p>上述文章中已经介绍了 OSSpinLock 不再安全，主要原因发生在低优先级线程拿到锁时，高优先级线程进入忙等(busy-wait)状态，消耗大量 CPU 时间，从而导致低优先级线程拿不到 CPU 时间，也就无法完成任务并释放锁。这种问题被称为优先级反转。</p>

<p>为什么忙等会导致低优先级线程拿不到时间片？这还得从操作系统的线程调度说起。</p>

<pre><code>现代操作系统在管理普通线程时，通常采用时间片轮转算法(Round Robin，简称 RR)。每个线程会被分配一段时间片(quantum)，通常在 10-100 毫秒左右。当线程用完属于自己的时间片以后，就会被操作系统挂起，放入等待队列中，直到下一次被分配时间片。
</code></pre>

<h4>自旋锁的实现原理</h4>

<p>自旋锁的目的是为了确保临界区只有一个线程可以访问，它的使用可以用下面这段伪代码来描述:</p>

<pre><code>do {

    Acquire Lock

        Critical section  // 临界区

    Release Lock

        Reminder section // 不需要锁保护的代码

}
</code></pre>

<p>在 Acquire Lock 这一步，我们申请加锁，目的是为了保护临界区(Critical Section) 中的代码不会被多个线程执行。</p>

<p>自旋锁的实现思路很简单，理论上来说只要定义一个全局变量，用来表示锁的可用情况即可，伪代码如下:</p>

<pre><code>bool lock = false; // 一开始没有锁上，任何线程都可以申请锁

do {

    while(lock); // 如果 lock 为 true 就一直死循环，相当于申请锁

    lock = true; // 挂上锁，这样别的线程就无法获得锁

        Critical section  // 临界区

    lock = false; // 相当于释放锁，这样别的线程可以进入临界区

        Reminder section // 不需要锁保护的代码        

}
</code></pre>

<p>注释写得很清楚，就不再逐行分析了。可惜这段代码存在一个问题: 如果一开始有多个线程同时执行 while 循环，他们都不会在这里卡住，而是继续执行，这样就无法保证锁的可靠性了。解决思路也很简单，只要确保申请锁的过程是原子操作即可。</p>

<h4>原子操作</h4>

<p>狭义上的原子操作表示一条不可打断的操作，也就是说线程在执行操作过程中，不会被操作系统挂起，而是一定会执行完。在单处理器环境下，一条汇编指令显然是原子操作，因为中断也要通过指令来实现。</p>

<blockquote><p>然而在多处理器的情况下，能够被多个处理器同时执行的操作任然算不上原子操作。因此，真正的原子操作必须由硬件提供支持，比如 x86 平台上如果在指令前面加上 “LOCK” 前缀，对应的机器码在执行时会把总线锁住，使得其他 CPU不能再执行相同操作，从而从硬件层面确保了操作的原子性。</p></blockquote>

<p>这些非常底层的概念无需完全掌握，我们只要知道上述申请锁的过程，可以用一个原子性操作 test_and_set 来完成，它用伪代码可以这样表示:</p>

<pre><code>bool test_and_set (bool *target) {

    bool rv = *target; 

    *target = TRUE; 

    return rv;

}
</code></pre>

<p>这段代码的作用是把 target 的值设置为 1，并返回原来的值。当然，在具体实现时，它通过一个原子性的指令来完成。</p>

<h4>自旋锁的总结</h4>

<p>至此，自旋锁的实现原理就很清楚了:</p>

<pre><code>bool lock = false; // 一开始没有锁上，任何线程都可以申请锁

do {

    while(test_and_set(&amp;lock); // test_and_set 是一个原子操作

        Critical section  // 临界区

    lock = false; // 相当于释放锁，这样别的线程可以进入临界区

        Reminder section // 不需要锁保护的代码        

}
</code></pre>

<p>如果临界区的执行时间过长，使用自旋锁不是个好主意。之前我们介绍过时间片轮转算法，线程在多种情况下会退出自己的时间片。其中一种是用完了时间片的时间，被操作系统强制抢占。除此以外，当线程进行 I/O 操作，或进入睡眠状态时，都会主动让出时间片。显然在 while 循环中，线程处于忙等状态，白白浪费 CPU 时间，最终因为超时被操作系统抢占时间片。如果临界区执行时间较长，比如是文件读写，这种忙等是毫无必要的。</p>

<h2>信号量</h2>

<p>之前我在 介绍 GCD 底层实现的文章 中简单描述了信号量 dispatch_semaphore_t 的实现原理，它最终会调用到 sem_wait 方法，这个方法在 glibc 中被实现如下:</p>

<pre><code>int sem_wait (sem_t *sem) {

  int *futex = (int *) sem;

  if (atomic_decrement_if_positive (futex) &gt; 0)

    return 0;

  int err = lll_futex_wait (futex, 0);

    return -1;

)
</code></pre>

<p>首先会把信号量的值减一，并判断是否大于零。如果大于零，说明不用等待，所以立刻返回。具体的等待操作在 lll_futex_wait 函数中实现，lll 是 low level lock 的简称。这个函数通过汇编代码实现，调用到 SYS_futex 这个系统调用，使线程进入睡眠状态，主动让出时间片，这个函数在互斥锁的实现中，也有可能被用到。</p>

<ul>
<li>主动让出时间片并不总是代表效率高。让出时间片会导致操作系统切换到另一个线程，这种上下文切换通常需要 10 微秒左右，而且至少需要两次切换。如果等待时间很短，比如只有几个微秒，忙等就比线程睡眠更高效。</li>
</ul>


<p>可以看到，自旋锁和信号量的实现都非常简单，这也是两者的加解锁耗时分别排在第一和第二的原因。再次强调，加解锁耗时不能准确反应出锁的效率(比如时间片切换就无法发生)，它只能从一定程度上衡量锁的实现复杂程度。</p>

<h2>pthread_mutex</h2>

<p>pthread 表示 POSIX thread，定义了一组跨平台的线程相关的 API，pthread_mutex 表示互斥锁。互斥锁的实现原理与信号量非常相似，不是使用忙等，而是阻塞线程并睡眠，需要进行上下文切换。</p>

<p>互斥锁的常见用法如下:</p>

<pre><code>pthread_mutexattr_t attr;

pthread_mutexattr_init(&amp;attr);

pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_NORMAL);  // 定义锁的属性



pthread_mutex_t mutex;

pthread_mutex_init(&amp;mutex, &amp;attr) // 创建锁



pthread_mutex_lock(&amp;mutex); // 申请锁

    // 临界区

pthread_mutex_unlock(&amp;mutex); // 释放锁
</code></pre>

<p>对于 pthread_mutex 来说，它的用法和之前没有太大的改变，比较重要的是锁的类型，可以有 PTHREAD_MUTEX_NORMAL、PTHREAD_MUTEX_ERRORCHECK、PTHREAD_MUTEX_RECURSIVE 等等，具体的特性就不做解释了，网上有很多相关资料。</p>

<blockquote><p>一般情况下，一个线程只能申请一次锁，也只能在获得锁的情况下才能释放锁，多次申请锁或释放未获得的锁都会导致崩溃。假设在已经获得锁的情况下再次申请锁，线程会因为等待锁的释放而进入睡眠状态，因此就不可能再释放锁，从而导致死锁。</p></blockquote>

<p>然而这种情况经常会发生，比如某个函数申请了锁，在临界区内又递归调用了自己。辛运的是 pthread_mutex 支持递归锁，也就是允许一个线程递归的申请锁，只要把 attr 的类型改成 PTHREAD_MUTEX_RECURSIVE 即可。</p>

<h2>互斥锁的实现</h2>

<p>互斥锁在申请锁时，调用了 pthread_mutex_lock 方法，它在不同的系统上实现各有不同，有时候它的内部是使用信号量来实现，即使不用信号量，也会调用到 lll_futex_wait 函数，从而导致线程休眠。</p>

<blockquote><p>上文说到如果临界区很短，忙等的效率也许更高，所以在有些版本的实现中，会首先尝试一定次数(比如 1000 次)的 test_and_test，这样可以在错误使用互斥锁时提高性能。</p></blockquote>

<p>另外，由于 pthread_mutex 有多种类型，可以支持递归锁等，因此在申请加锁时，需要对锁的类型加以判断，这也就是为什么它和信号量的实现类似，但效率略低的原因。</p>

<h2>NSLock</h2>

<p>NSLock 是 Objective-C 以对象的形式暴露给开发者的一种锁，它的实现非常简单，通过宏，定义了 lock 方法:</p>

<pre><code>#define    MLOCK \

- (void) lock\

{\

  int err = pthread_mutex_lock(&amp;_mutex);\

  // 错误处理 ……

}
</code></pre>

<p>NSLock 只是在内部封装了一个 pthread_mutex，属性为 PTHREAD_MUTEX_ERRORCHECK，它会损失一定性能换来错误提示。</p>

<p>这里使用宏定义的原因是，OC 内部还有其他几种锁，他们的 lock 方法都是一模一样，仅仅是内部 pthread_mutex 互斥锁的类型不同。通过宏定义，可以简化方法的定义。</p>

<blockquote><p>NSLock 比 pthread_mutex 略慢的原因在于它需要经过方法调用，同时由于缓存的存在，多次方法调用不会对性能产生太大的影响。</p></blockquote>

<h2>NSCondition</h2>

<p>NSCondition 的底层是通过条件变量(condition variable) pthread_cond_t 来实现的。条件变量有点像信号量，提供了线程阻塞与信号机制，因此可以用来阻塞某个线程，并等待某个数据就绪，随后唤醒线程，比如常见的生产者-消费者模式。</p>

<h4>如何使用条件变量</h4>

<p>很多介绍 pthread_cond_t 的文章都会提到，它需要与互斥锁配合使用:</p>

<pre><code>void consumer () { // 消费者

    pthread_mutex_lock(&amp;mutex);

    while (data == NULL) {

        pthread_cond_wait(&amp;condition_variable_signal, &amp;mutex); // 等待数据

    }

    // --- 有新的数据，以下代码负责处理 ↓↓↓↓↓↓

    // temp = data;

    // --- 有新的数据，以上代码负责处理 ↑↑↑↑↑↑

    pthread_mutex_unlock(&amp;mutex);

}



void producer () {

    pthread_mutex_lock(&amp;mutex);

    // 生产数据

    pthread_cond_signal(&amp;condition_variable_signal); // 发出信号给消费者，告诉他们有了新的数据

    pthread_mutex_unlock(&amp;mutex);

}
</code></pre>

<p>自然我们会有疑问:“如果不用互斥锁，只用条件变量会有什么问题呢？”。问题在于，temp = data; 这段代码不是线程安全的，也许在你把 data 读出来以前，已经有别的线程修改了数据。因此我们需要保证消费者拿到的数据是线程安全的。</p>

<p>wait 方法除了会被 signal 方法唤醒，有时还会被虚假唤醒，所以需要这里 while 循环中的判断来做二次确认。</p>

<h4>为什么要使用条件变量</h4>

<p>介绍条件变量的文章非常多，但大多都对一个一个基本问题避而不谈:“为什么要用条件变量？它仅仅是控制了线程的执行顺序，用信号量或者互斥锁能不能模拟出类似效果？”</p>

<p>网上的相关资料比较少，我简单说一下个人看法。信号量可以一定程度上替代 condition，但是互斥锁不行。在以上给出的生产者-消费者模式的代码中， pthread_cond_wait 方法的本质是锁的转移，消费者放弃锁，然后生产者获得锁，同理，pthread_cond_signal 则是一个锁从生产者到消费者转移的过程。</p>

<p>如果使用互斥锁，我们需要把代码改成这样:</p>

<pre><code>void consumer () { // 消费者

    pthread_mutex_lock(&amp;mutex);

    while (data == NULL) {

        pthread_mutex_unlock(&amp;mutex);

        pthread_mutex_lock(&amp;another_lock)  // 相当于 wait 另一个互斥锁

        pthread_mutex_lock(&amp;mutex);

    }

    pthread_mutex_unlock(&amp;mutex);

}
</code></pre>

<p>这样做存在的问题在于，在等待 another_lock 之前， 生产者有可能先执行代码， 从而释放了 another_lock。也就是说，我们无法保证释放锁和等待另一个锁这两个操作是原子性的，也就无法保证“先等待、后释放 another_lock” 这个顺序。</p>

<blockquote><p>用信号量则不存在这个问题，因为信号量的等待和唤醒并不需要满足先后顺序，信号量只表示有多少个资源可用，因此不存在上述问题。然而与 pthread_cond_wait 保证的原子性锁转移相比，使用信号量似乎存在一定风险(暂时没有查到非原子性操作有何不妥)。</p></blockquote>

<p>不过，使用 condition 有一个好处，我们可以调用 pthread_cond_broadcast 方法通知所有等待中的消费者，这是使用信号量无法实现的。</p>

<h2>NSCondition 的做法</h2>

<p>NSCondition 其实是封装了一个互斥锁和条件变量， 它把前者的 lock 方法和后者的 wait/signal 统一在 NSCondition 对象中，暴露给使用者:</p>

<pre><code>- (void) signal {

  pthread_cond_signal(&amp;_condition);

}



// 其实这个函数是通过宏来定义的，展开后就是这样

- (void) lock {

  int err = pthread_mutex_lock(&amp;_mutex);

}
</code></pre>

<p>它的加解锁过程与 NSLock 几乎一致，理论上来说耗时也应该一样(实际测试也是如此)。在图中显示它耗时略长，我猜测有可能是测试者在每次加解锁的前后还附带了变量的初始化和销毁操作。</p>

<h2>NSRecursiveLock</h2>

<p>上文已经说过，递归锁也是通过 pthread_mutex_lock 函数来实现，在函数内部会判断锁的类型，如果显示是递归锁，就允许递归调用，仅仅将一个计数器加一，锁的释放过程也是同理。</p>

<blockquote><p>NSRecursiveLock 与 NSLock 的区别在于内部封装的 pthread_mutex_t 对象的类型不同，前者的类型为 PTHREAD_MUTEX_RECURSIVE。</p></blockquote>

<h2>NSConditionLock</h2>

<p>NSConditionLock 借助 NSCondition 来实现，它的本质就是一个生产者-消费者模型。“条件被满足”可以理解为生产者提供了新的内容。NSConditionLock 的内部持有一个 NSCondition 对象，以及 _condition_value 属性，在初始化时就会对这个属性进行赋值:</p>

<pre><code>// 简化版代码

- (id) initWithCondition: (NSInteger)value {

    if (nil != (self = [super init])) {

        _condition = [NSCondition new]

        _condition_value = value;

    }

    return self;

}
</code></pre>

<p>它的 lockWhenCondition 方法其实就是消费者方法:</p>

<pre><code>- (void) lockWhenCondition: (NSInteger)value {

    [_condition lock];

    while (value != _condition_value) {

        [_condition wait];

    }

}
</code></pre>

<p>对应的 unlockWhenCondition 方法则是生产者，使用了 broadcast 方法通知了所有的消费者:</p>

<pre><code>- (void) unlockWithCondition: (NSInteger)value {

    _condition_value = value;

    [_condition broadcast];

    [_condition unlock];

}
</code></pre>

<h2>@synchronized</h2>

<p>这其实是一个 OC 层面的锁， 主要是通过牺牲性能换来语法上的简洁与可读。</p>

<blockquote><p>我们知道 @synchronized 后面需要紧跟一个 OC 对象，它实际上是把这个对象当做锁来使用。这是通过一个哈希表来实现的，OC 在底层使用了一个互斥锁的数组(你可以理解为锁池)，通过对对象去哈希值来得到对应的互斥锁。</p></blockquote>

<p>具体的实现原理可以参考这篇文章: 关于 @synchronized，这儿比你想知道的还要多</p>

<blockquote><p>参考资料</p></blockquote>

<pre><code>pthread_mutex_lock

ThreadSafety

Difference between binary semaphore and mutex

关于 @synchronized，这儿比你想知道的还要多

pthread_mutex_lock.c 源码

[Pthread] Linux中的线程同步机制(二)–In Glibc

pthread的各种同步机制

pthread_cond_wait

Conditional Variable vs Semaphore
</code></pre>

<hr />

<pre><code>Q Q：2211523682/790806573

微信：18370997821/13148454507

微博WB:http://weibo.com/u/3288975567?is_hot=1

git博文：http://al1020119.github.io/

github：https://github.com/al1020119
</code></pre>

<p><img src="/images/iCocosCoder.jpg" title="Caption" ></p>

<p><img src="/images/iCocosPublic.jpg" title="Caption" ></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/08/31/duo-xian-cheng-an-quan-%3Fying-gai-bu-zhi-zhe-xie-%3F!/">多线程安全？应该不止这些😂！</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-08-31T12:33:27+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>31</span><span class='date-suffix'>st</span>, <span class='date-year'>2016</span></span> <span class='time'>12:33 pm</span></time>
        
        
        |   <a href="/blog/2016/08/31/duo-xian-cheng-an-quan-%3Fying-gai-bu-zhi-zhe-xie-%3F!/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><ul>
<li>前言</li>
<li>介绍与使用</li>
<li>总结</li>
<li>其他实战使用</li>
</ul>


<h2>一、前言</h2>

<p>前段时间看了几个开源项目，发现他们保持线程同步的方式各不相同，有@synchronized、NSLock、dispatch_semaphore、NSCondition、pthread_mutex、OSSpinLock。后来网上查了一下，发现他们的实现机制各不相同，性能也各不一样。不好意思，我们平常使用最多的@synchronized是性能最差的。下面我们先分别介绍每个加锁方式的使用，在使用一个案例来对他们进行性能对比。</p>

<h2>二、介绍与使用</h2>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2016/08/31/duo-xian-cheng-an-quan-%3Fying-gai-bu-zhi-zhe-xie-%3F!/">阅读全文😘</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/08/30/xiu-xing-pian-ioskai-fa-zhong-chang-jian-she-ji-mo-shi/">修行篇-ios开发中常见设计模式</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-08-30T13:10:04+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>30</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>1:10 pm</span></time>
        
        
        |   <a href="/blog/2016/08/30/xiu-xing-pian-ioskai-fa-zhong-chang-jian-she-ji-mo-shi/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>本文摘自：<a href="http://ios.jobbole.com/85360/">伯乐在线</a>,因为自己研究并学习ios设计模式的时候寻找了好多相关文章，最后发现这篇才是最适合ios开发的，当然你也可以自己通过C或者java设计模式的规范进行演变。</p>

<p>源码下载地址：<a href="https://github.com/al1020119/iCocosDesignPattern">https://github.com/al1020119/iCocosDesignPattern</a></p>

<h1>对象创建</h1>

<h4>原型（Prototype）</h4>

<p>使用原型实例指定创建对象的种类，并通过复制这个原型创建新的对象。</p>

<pre><code>NSArray *array = [[NSArray alloc] initWithObjects:@1, nil];
NSArray *array2 = array.copy;
</code></pre>

<p>array 就是原型了，array2 以 array 为原型，通过 copy 操作创建了 array2。</p>

<p>当创建的实例非常复杂且耗时，或者新实例和已存在的实例值相同，使用原型模式去复制已经存在的实例效率更高。</p>

<h4>工厂方法（Factory Method）</h4>

<pre><code>定义创建对象的接口，让子类决定实例化哪一个类。工厂方法使得类的实例化延迟到其子类。
</code></pre>

<p>工厂方法是针对每一种产品提供一个工厂类。通过不同的工厂类来创建不同的产品实例。</p>

<p><img src="/images/iosshejimoshi001.png" title="Caption" ></p>

<ul>
<li>如上图，+ create():Product 就是工厂方法，ConcreatFactoryA 与 ConcreateFactoryB 就是两个工厂类，ConcreateProductA 与 ConcreateProductB 就是两个工厂类对应的产品类，通过不同的工厂生产不同类型的产品，且两个产品类最终返回的是他们的父类 Product，隐藏了对象的具体类型。工厂方法模式让创建的对象拥有一组共同的接口，使我们无需关心做了不同类型接口的具体实现，只需要调用 Product 的接口就行。</li>
</ul>


<blockquote><p>工厂方法模式的扩展性也很好，新增的产品类并不需要修改客户端代码。但每新加一个产品类都需要新建一个工厂类，会造成项目中的类过多。</p></blockquote>

<p>而在 Cocoa Touch 框架中，以 NSNumber 举例，将原有的 alloc+init 拆开写：</p>

<pre><code> id obj1 = [NSNumber alloc];
    id obj2 = [NSNumber alloc];
    id obj3 = [obj1 initWithBool:YES];
</code></pre>

<p>发现 + alloc 后并非生成了我们期望的类实例，而是一个NSPlacehodlerNumber 的中间对象，后面的 – initWithXXXXX 消息都是发送给这个中间对象，再由它做工厂，生成真的对象。如 obj3 的实际类型为 NSCFBoolean，而 obj4 的实际类型为 NSCFNumber 。</p>

<h4>抽象工厂（Abstract Factory）</h4>

<pre><code>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。
</code></pre>

<p><img src="/images/iosshejimoshi002.png" title="Caption" ></p>

<ul>
<li>如上图，抽象工厂有一个产品族的概念，Factory1 与 Factory2 是继承 AbstractFactory 的两个产品族工厂类， 继承了父类创建 A，B 两个产品的方法，不同产品族工厂类会创建不同类型的产品，最终返回了不同的产品族对象，既 ProductA 和 ProductB。</li>
</ul>


<p>在 Cocoa Touch 框架中，类簇是抽象工厂模式在 iOS 下的一种实现，以 NSArray 举例，将原有的 alloc+init 拆开写：</p>

<pre><code>id obj1 = [NSArray alloc]; // __NSPlacehodlerArray *
id obj2 = [NSMutableArray alloc];  // __NSPlacehodlerArray *
id obj3 = [obj1 init];  // __NSArrayI *
id obj4 = [obj2 init];  // __NSArrayM *
</code></pre>

<p>发现 + alloc 后并非生成了我们期望的类实例，而是一个NSPlacehodlerArray 的中间对象，后面的 – init 或 – initWithXXXXX 消息都是发送给这个中间对象，再由它做工厂，生成真的对象。这里的 NSArrayI 和 __NSArrayM 分别对应 Immutable 和 Mutable（后面的 I 和 M 的意思）</p>

<blockquote><p>于是顺着思路猜实现，__NSPlacehodlerArray 必定用某种方式存储了它是由谁 alloc 出来的这个信息，才能在 init 的时候知道要创建的是可变数组还是不可变数组。</p></blockquote>

<p>抽象工厂将一系列的产品族统一到一起创建，增加产品族很方便，但增加产品很麻烦，需要改动太多的类的接口。</p>

<h4>生成器（Builder）</h4>

<p>将一个复杂对象的构建与它的表现分离，使得同样的构建过程可以创建不同的表现。
生成器可以将构建对象的过程分为，客户 – 指导者 – 生成器 的关系，</p>

<pre><code>CharacterBuilder *characterBuilder = [[StandarCharacterBuilder alloc] init];
ChasingGame *game = [[ChasingGame alloc] init];

Character *player = [chasingGame createPlayer:characterBuilder];
Character *enemy = [chasingGame createEnemy:characterBuilder];
</code></pre>

<p>characterBuilder 就是生成器了，而 game 就是指导者。指导者里声明了创建不同表现的对象的方法。而方法里由生成器 characterBuilder 来构建不同的 Character 类型的对象。</p>

<ul>
<li>生成器模式将复杂的生成对象的过程交给了生成器去完成，作为客户的我们只需要根据简单的接口去生成不同表现的对象。如上述代码中的 player 以及 enemy。玩家和敌人具体的属性数值我们不需要去设置，而是交给生成器去设置。</li>
</ul>


<h4>单例（Singleton）</h4>

<pre><code>保证一个类仅有一个实例，并提供一个访问它的全局访问点。
</code></pre>

<p>在 Cocoa Touch 框架中，最常见的使用了单例模式的就是 UIApplication 类了。每个应用程序有且仅有一个 UIApplication 的实例，它由 UIApplicationMain 函数在程序启动时创建为单例对象，之后，对同一 UIApplication 实例可以通过其 sharedApplication 类方法进行访问。</p>

<p>单例用来集中管理对类的对象所提供的资源，例如应用程序中需要用集中式的类来协调其服务，这个类就应该生成单一的实例。</p>

<ul>
<li>单例模式在多线程的应用场合下必须小心使用。如果当唯一实例尚未创建时，有两个线程同时调用创建方法，那么它们同时没有检测到唯一实例的存在，从而同时各自创建了一个实例，这样就有两个实例被构造出来，从而违反了单例模式中实例唯一的原则。 解决这个问题的办法是为指示类是否已经实例化的变量提供一个互斥锁。</li>
</ul>


<h1>接口适配</h1>

<h4>适配器（Adapter）</h4>

<pre><code>将一个类的接口转换成客户希望的另一个接口，适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
</code></pre>

<p>适配器模式分为类适配器模式和对象适配器模式。
<img src="/images/iosshejimoshi003.png" title="Caption" ></p>

<ul>
<li>上图是对象适配器模式，Adapter（适配器）遵守了 Target（目标接口）协议，拥有一个 Adaptee（被适配者）的对象 adaptee 的引用，当调用 Adapter 的 request 方法，request 方法里会去调用 adapteee 的 specificRequest 方法。</li>
</ul>


<h4>类适配模式</h4>

<p><img src="/images/iosshejimoshi004.png" title="Caption" ></p>

<p>类适配器模式中适配器和被适配者是继承关系。request 方法里会去调用 super 的 specificRequest 方法，达到将类的接口转换成客户希望的另一个接口。</p>

<p>适配器模式主要应用于“希望复用一些现存的类，但是接口又与复用环境要求不一致的情况”，在遗留代码复用、类库迁移等方面非常有用。</p>

<h4>桥接（Bridge）</h4>

<pre><code>将抽象部分与它的实现部分分离，使它们都可以独立地变化。
</code></pre>

<p>桥接模式是软件设计模式中最复杂的模式之一，在软件系统中，某些类型由于自身的逻辑，它具有两个或多个维度的变化。</p>

<p><img src="/images/iosshejimoshi005.png" title="Caption" ></p>

<ul>
<li>如上图，毛笔和颜色是两个维度的变化，可以选择新建 9 个类去实现不同颜色的不同毛笔，也可以如图所示，去组合两个维度。对于客户端而言，可以针对两个维度的抽象层编程，在程序运行的时候再动态确认两个维度的子类，动态组合对象，将两个独立变化的维度完全解耦，以便能够灵活地扩充任一维度而对另一维度不造成任何影响。比如增加一种毛笔并不需要去改动图中的实现部分，增加一种颜色也不需要去改变抽象部分。（抽象部分是面向我们编程的接口部分，我们绘图的时候是调用毛笔类的绘图方法）。</li>
</ul>


<p>桥接模式可以让抽象与实现之间不形成绑定关系，在运行时可以切换实现，也将抽象和实现完全解耦，可以独立扩展。</p>

<h4>外观（Facade）</h4>

<pre><code>为系统中的一组接口提供一个统一的接口。外观顶一个高层接口，让子系统更易于使用。
</code></pre>

<p>外观模式主要是使用一个外观类，为复杂的子系统提供一个简单的接口，而子系统的复杂调用交给外观类去做。</p>

<p><img src="/images/iosshejimoshi006.png" title="Caption" ></p>

<ul>
<li>如上图，数据的来源可能是不同数据库，获取数据可能非常的复杂，所以使用一个外观类提供简单的获取数据的接口，复杂的操作让外观类去做。做到让子系统更加的易用。</li>
</ul>


<h1>对象去耦</h1>

<h4>中介者（Mediator）</h4>

<pre><code>用一个对象来封装一系列对象的交互方式，中介者使各对象不需要显示地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。
</code></pre>

<p>我们开发的程序是由大量的类来组成的，随着程序功能的不断增加，类和类之间的依赖关系也跟着趋于复杂，而中介者模式便能解决这个问题，</p>

<p><img src="/images/iosshejimoshi007.png" title="Caption" ></p>

<ul>
<li>如图所示，6 个 VC 类之间的交互可能特别多，如果让他们相互依赖，然后管理这些 VC 之间的关系是一件非常繁琐的事情，我们要处理各个 VC 之间的关系，每当一个 VC 要跳转到另外个 VC，我们需要包含新的 VC 的头文件。而使用中介者模式，让 VC 之间的交互变成 VC 和中介者的交互，用中介者来管理多对多的复杂的对象群，降低了各个对象之间的耦合，减少了对象之间逻辑的复杂度，但也可能导致中介者类中的实现过于复杂。</li>
</ul>


<p>UINavigationController 就是一个中介者，如下图所示</p>

<p><img src="/images/iosshejimoshi008.png" title="Caption" ></p>

<p>视图控制器的切换都是与 UINavigationController 做交互。由 UINavigationController 去做集中管理。</p>

<h4>观察者（Observer）</h4>

<pre><code>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。
</code></pre>

<p>在 Cocoa Touch 框架中通知和 KVO 都实现了观察者模式。通知是由一个中心对象为所有观察者提供变更通知，KVO 是被观察的对象直接向观察者发送通知。</p>

<p><img src="/images/iosshejimoshi009.png" title="Caption" ></p>

<ul>
<li>如上图，Subject 的值改变时，通知观察者 ObserverA，ObserverB，ObserverC，我的数据改变了，依赖我的你们需要更新状态了。</li>
</ul>


<p>被观察者不需要知道有多少个观察者和观察者的更新细节，降低被观察者和观察者之间的耦合。</p>

<h1>抽象集合</h1>

<h4>组合（Composite）</h4>

<pre><code>将对象组合成树形结构以表示“部分-整体”的层次结构。组合使得用户对单个对象和组合对象的使用具有一致性。
</code></pre>

<p>在 Cocoa Touch 框架中，UIView 被组织成一个组合结构。每个 UIView 都可以将其它 UIView 设置为自己的子视图，形成一个树形结构，让客户端可以对单个 UIView 或者对 UIView 组合统一对待。</p>

<p>既平移一个 UIView，可以做到平移这一个 UIView 组合，且操作方法与平移单个 UIView 一致。</p>

<h4>迭代器（Iterator）</h4>

<pre><code>提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示，
</code></pre>

<p>在 Cocoa Touch 中的 NSEnumerator 就实现了迭代器模式，如以下代码</p>

<pre><code> NSArray *anArray = @[@"this", @"is", @"a", @"test"];
    NSEnumerator *itemEnumerator = [anArray objectEnumerator];

    NSString *item;
    while (item = [itemEnumerator nextObject]) {
        NSLog(@"%@", item);
    }
</code></pre>

<p>迭代器分为两种，上面使用了一个外部迭代器，外部迭代器让客户端直接操作迭代过程，如上面代码就是使用一个 while 循环去迭代。</p>

<p>下面是使用了内部迭代器，客户端不需要知道实现迭代的方式。</p>

<pre><code> NSArray *anArray = @[@"this", @"is", @"a", @"test"];
    NSString *string = @"a";
    [anArray enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
        NSLog(@"%@", obj);
        if ([obj isEqualToString:string]) {
            *stop = YES;
        }
    }];
</code></pre>

<p>客户端不需要手动实现迭代器，只要对每个元素进行处理就行。</p>

<h1>行为扩展</h1>

<h4>访问者（Visitor）</h4>

<pre><code>表示一个作用于某对象结构中的各元素的操作，它让我们可以在不改变各元素的类的前提下定义作用于这些元素的新操作。
</code></pre>

<p>当一个复杂的对象结构包含很多其他的对象，每个对象都有不同的接口，这个时候如果想添加新的接口进行新的操作，就得修改该对象的类，如果每个对象都需要添加新操作，就需要修改更多的类。而访问者模式就是用来不修改原有类添加新的操作。</p>

<p>访问者模式涉及两个关键元素，访问者和被访问对象。访问者遵从访问协议，访问协议里声明了访问方法。访问方法类似下面</p>

<pre><code>- (void)visitEngine:(NimoEngine *)engine;
- (void)visitWheel:(NimoWheel *)wheel;
</code></pre>

<p>访问者模式流程，直接调用访问者里的访问方法，访问方法里实现了新添加的操作，engine 与 wheel 既被访问对象，达到了将新操作集中在访问者里处理的效果。如果再需要新添加一系列对各个元素的操作，只需要再添加一个访问者类就行。</p>

<blockquote><p>访问者能访问复杂元素里的每一个元素，然后由访问者对这些元素进行行为扩展。</p>

<h4>装饰（Decorator）</h4></blockquote>

<pre><code>动态地给一个对象添加一些额外的职责。就扩展功能来说，装饰模式相比生成子类更为灵活。
</code></pre>

<p>Category 就是实现了装饰的设计模式。Category 是 Objective-C 的语言功能，通过它可以给类添加方法的接口与实现，而不必子类化。 从这个设计模式的描述联想到 Category，就没什么难理解了。
责任链（Chain of Responsibility）</p>

<pre><code>使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间发生耦合。此模式将这些对象连成一条链，并沿着这条链传递请求，直到有一个对象处理它为止。
</code></pre>

<p>Cocoa Touch 中的事件处理流程–响应者链就实现了责任链模式。以点击为例，首先通过 hit-test view 的流程找到被点击的视图，被点击的视图如果不处理点击事件，则沿着响应者链向上回溯，比如给父视图发消息，让父视图去处理，父视图不处理则继续沿着响应者链向上回溯，直到有对象处理它为止，如果都不处理，则该事件丢弃。</p>

<h1>算法封装</h1>

<h4>模板方法（Template Method）</h4>

<pre><code>定义一个操作中算法的骨架，而将一些步骤延迟到子类中。模板方法使子类可以重定义算法的某些特定步骤而不改变该算法的结构。
</code></pre>

<p>模板方法可以提高可扩展性与可复用性，比如 UIView 类中的定制绘图,UIView 的结构不改变，只是继承 UIView,再重载 – (void)drawRect:(CGRect)rect
方法。所以 – (void)drawRect:(CGRect)rect 就是模板方法，默认什么都不做或者只是做了部分操作，缺少特性操作，用来给子类选择重载与实现的方法。</p>

<h4>策略（Strategy）</h4>

<pre><code>定义一系列算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。
</code></pre>

<p>举一个常见的例子，验证 UITextField 输入是否有效。有两个算法分别是验证邮箱的和验证电话号码的。可以通过 if else 这样的判断代码来决定执行哪个算法。也可以通过策略模式，将算法封装起来，如下图
￼</p>

<p><img src="/images/iosshejimoshi010.png" title="Caption" ></p>

<p>Strategy 是这一系列算法的父类，ConcreteStrategyA, B, C。是三种算法，给 Context 对象添加一个 Strategy 类型的属性，里面存放着 ConcreteStrategyA 或者 B，C。然后 Context 对象就知道去执行哪个算法。也就知道自己需要执行什么策略。</p>

<blockquote><p>策略模式首先将算法都封装起来了，易于理解，且易于切换和扩展。</p>

<h4>命令（Command）</h4></blockquote>

<pre><code>将请求封装为一个对象，从而可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。
</code></pre>

<p>Cocoa Touch 框架中的 NSInvocation 就是实现了命令模式。</p>

<pre><code>NSMethodSignature*signature = [ViewController instanceMethodSignatureForSelector:@selector(sendMessageWithNumber:WithContent:)];
  //1、创建NSInvocation对象
  NSInvocation*invocation = [NSInvocation invocationWithMethodSignature:signature];
  invocation.target = self;
  //invocation中的方法必须和签名中的方法一致。
  invocation.selector = @selector(sendMessageWithNumber:WithContent:);
  /*第一个参数：需要给指定方法传递的值
         第一个参数需要接收一个指针，也就是传递值的时候需要传递地址*/
  //第二个参数：需要给指定方法的第几个参数传值
  NSString*number = @"1111";
  //注意：设置参数的索引时不能从0开始，因为0已经被self占用，1已经被_cmd占用
  [invocation setArgument:&amp;number atIndex:2];
  NSString*number2 = @"啊啊啊";
  [invocation setArgument:&amp;number2 atIndex:3];
  //2、调用NSInvocation对象的invoke方法
  //只要调用invocation的invoke方法，就代表需要执行NSInvocation对象中制定对象的指定方法，并且传递指定的参数
  [invocation invoke];
</code></pre>

<p>将行为封装成对象，而不是直接触发行为，因为是对象，所以可以很容易的设计一个命令队列，也可以方便的记录进日志里，以及实现行为的撤销。（因为行为对象可以记录进日志里，所以可以根据日志得知上一个操作做了什么，从而进行撤销）。</p>

<h1>性能与对象访问</h1>

<h2>享元（Flyweight）</h2>

<pre><code>利用共享技术有效地支持大量细粒度的对象。
</code></pre>

<p>tableViewCell 的重用机制就是实现了享元模式。在要使用一个 Cell 的时候，会先去重用池里看看 tableView 有没有可以重用的 cell，如果有重用该 cell，没有创建一个，这就是享元模式。</p>

<p>享元模式主要有两个关键组件，可共享的享元对象和保存它们的享元池。</p>

<blockquote><p>举另一个实现例子，画面上需要显示 100 个相同的图案，可以只生成一个包含该图案 image 的 imageView。其它 99 个只需要去享元池里去拿这个 imageView 实例的信息，然后在页面里直接绘制图案，这样就不需要生成 100 个图案实例。</p></blockquote>

<p>享元模式通过共享一部分必须的对象，减少对象的创建，节省大量的内存。</p>

<h4>代理（Proxy）</h4>

<pre><code>为其它对象提供一种代理以控制对这个对象的访问。
</code></pre>

<p>代理设计模式的英文名是 Proxy pattern，和我们常见的 delegate（委托） 没关系。</p>

<p>iOS 中常见的代理模式例子为引用计数，当一个复杂对象的多份副本须存在时，代理模式可以结合享元模式以减少内存用量。典型做法是创建一个复杂对象及多个代理者，每个代理者会引用到原本的复杂对象。而作用在代理者的运算会转送到原本对象。一旦所有的代理者都不存在时，复杂对象会被移除。</p>

<blockquote><p>当然，上面的代理模式中的代理者什么都没做，代理对象作为 A 和 C 中间的协调者，可以多做点操作，可以理解为 VPN 中的代理者可以对传输数据加密，而 A 和 C 中的代理者，也可以隐藏 C 的信息，做到对 C 的保护。</p></blockquote>

<h1>对象状态</h1>

<h4>备忘录（Memento）</h4>

<pre><code>在不破坏封装的情况下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可将该对象恢复到原先保存的状态。
</code></pre>

<p>Cocoa Touch 框架中归档可以实现备忘录模式，Cocoa 的归档是对对象及其属性还有同其他对象间的关系进行编码，形成一个文档，该文档可以保存于文件系统，也可在进程或网络间传输，最后又可以通过解档将文档解码成与该对象归档时状态一致的对象。</p>

<blockquote><p>既将对象保存一个备份放置到其它地方，可以随时使用备份将该对象恢复到原先保存的状态，用来储存关键对象的关键状态。</p></blockquote>

<h5>总结：（如果看了这么久您依然不知道上面在扯上面鬼，那么请结合ios开发中遇到的技术点简单粗略的体会一下下面的东西，再返回看看或许你就会明白很多）</h5>

<ul>
<li>备忘录-归档</li>
<li>代理-引用计数（非delegate）</li>
<li>享元-TableView重用机制</li>
<li>命令-NSInvocation</li>
<li>策略-文本有效</li>
<li>模板-drawRect</li>
<li>装饰-分类</li>
<li>责任链-响应者</li>
<li>迭代器-NSEnumerator</li>
<li>组合-UIView</li>
<li>观察者-通知、KVO</li>
<li>中介-导航</li>
<li>原型-.copy</li>
<li>工厂方法-initWithBool</li>
<li>抽象工厂-alloc]initWithXXX</li>
<li>单利-无处不在哈哈</li>
<li>适配器-网络请求接口</li>
</ul>


<hr />

<pre><code>Q Q：2211523682/790806573

微信：18370997821/13148454507

微博WB:http://weibo.com/u/3288975567?is_hot=1

git博文：http://al1020119.github.io/

github：https://github.com/al1020119
</code></pre>

<p><img src="/images/iCocosCoder.jpg" title="Caption" ></p>

<p><img src="/images/iCocosPublic.jpg" title="Caption" ></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/08/28/xiu-xing-pian-shu-ju-jie-gou-chang-jian-cao-zuo-yu-zong-jie/">修行篇-数据结构常见操作与总结</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-08-28T12:33:11+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>28</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>12:33 pm</span></time>
        
        
        |   <a href="/blog/2016/08/28/xiu-xing-pian-shu-ju-jie-gou-chang-jian-cao-zuo-yu-zong-jie/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>一、栈</h1>

<p>栈是只能在一端进行插入和删除的线性表。
（别看只是个定义，非常重要，已经道出了运算方法：只能在一端插入和删除。)</p>

<blockquote><p>栈的特征：后进先出，先进后出。</p></blockquote>

<p>插入和删除元素的一端称为栈顶。（说明了我们在栈顶操作）
另一端称为栈底。
插入元素和删除元素的操作称为入栈和出栈。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2016/08/28/xiu-xing-pian-shu-ju-jie-gou-chang-jian-cao-zuo-yu-zong-jie/">阅读全文😘</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/08/25/xiu-xing-pian-suan-fa-zhi-jing-hua-suan-fa-and-mou-pao/">修行篇-算法之精华-算法&amp;冒泡</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-08-25T12:32:56+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>25</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>12:32 pm</span></time>
        
        
        |   <a href="/blog/2016/08/25/xiu-xing-pian-suan-fa-zhi-jing-hua-suan-fa-and-mou-pao/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><ul>
<li><p>冒泡排序（交换）</p>

<ul>
<li>改进</li>
</ul>
</li>
<li><p>快速排序（交换）</p>

<ul>
<li>改进</li>
</ul>
</li>
</ul>


<h2>交换排序—冒泡排序（Bubble Sort）</h2>

<p>基本思想：</p>

<blockquote><p>在要排序的一组数中，对当前还未排好序的范围内的全部数，自上而下对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。即：每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。
算法的实现：</p></blockquote>

<pre><code>void bubbleSort(int a[], int n){  
    for(int i =0 ; i&lt; n-1; ++i) {  
        for(int j = 0; j &lt; n-i-1; ++j) {  
            if(a[j] &gt; a[j+1])  
            {  
                int tmp = a[j] ; a[j] = a[j+1] ;  a[j+1] = tmp;  
            }  
        }  
    }  
}  
</code></pre>

<h4>改进</h4>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2016/08/25/xiu-xing-pian-suan-fa-zhi-jing-hua-suan-fa-and-mou-pao/">阅读全文😘</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/08/23/xiu-xing-pian-23chong-she-ji-mo-shi/">修行篇-23种设计模式</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-08-23T12:32:39+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>23</span><span class='date-suffix'>rd</span>, <span class='date-year'>2016</span></span> <span class='time'>12:32 pm</span></time>
        
        
        |   <a href="/blog/2016/08/23/xiu-xing-pian-23chong-she-ji-mo-shi/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>设计模式</h2>

<p>总体来说设计模式分为三大类：</p>

<ul>
<li><p>创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</p></li>
<li><p>结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</p></li>
<li><p>行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p>

<ul>
<li>其实还有两类：并发型模式和线程池模式。</li>
</ul>
</li>
</ul>


</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2016/08/23/xiu-xing-pian-23chong-she-ji-mo-shi/">阅读全文😘</a>
    </footer>
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/3">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/index.html">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
    <h1>文章分类</h1>
    <ul id="categories">
        <li class='category'><a href='/blog/categories/algorithms/'>algorithms (6)</a></li>
<li class='category'><a href='/blog/categories/and/'>and (14)</a></li>
<li class='category'><a href='/blog/categories/apples/'>apples (2)</a></li>
<li class='category'><a href='/blog/categories/application/'>application (1)</a></li>
<li class='category'><a href='/blog/categories/architecture/'>architecture (2)</a></li>
<li class='category'><a href='/blog/categories/audio/'>audio (8)</a></li>
<li class='category'><a href='/blog/categories/audio-video/'>audio-video (1)</a></li>
<li class='category'><a href='/blog/categories/data/'>data (6)</a></li>
<li class='category'><a href='/blog/categories/developer/'>developer (16)</a></li>
<li class='category'><a href='/blog/categories/foundation/'>foundation (31)</a></li>
<li class='category'><a href='/blog/categories/full/'>full (13)</a></li>
<li class='category'><a href='/blog/categories/low-level/'>low-level (4)</a></li>
<li class='category'><a href='/blog/categories/lve/'>lve (8)</a></li>
<li class='category'><a href='/blog/categories/news/'>news (4)</a></li>
<li class='category'><a href='/blog/categories/others/'>others (1)</a></li>
<li class='category'><a href='/blog/categories/performance/'>performance (12)</a></li>
<li class='category'><a href='/blog/categories/practical/'>practical (1)</a></li>
<li class='category'><a href='/blog/categories/radio/'>radio (8)</a></li>
<li class='category'><a href='/blog/categories/reverse/'>reverse (25)</a></li>
<li class='category'><a href='/blog/categories/senior/'>senior (40)</a></li>
<li class='category'><a href='/blog/categories/stack/'>stack (13)</a></li>
<li class='category'><a href='/blog/categories/structures/'>structures (6)</a></li>
<li class='category'><a href='/blog/categories/summarize/'>summarize (5)</a></li>
<li class='category'><a href='/blog/categories/tools/'>tools (5)</a></li>
<li class='category'><a href='/blog/categories/video/'>video (8)</a></li>

    </ul>
</section><section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2016/10/13/iosda-shen-zhi-lu-ying-you-jin-you/">iOS大神之路——应有尽有</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/10/13/iosda-shen-zhi-lu-jing-hua-pian/">iOS大神之路——精华篇</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/10/12/wan-zhuan-ios10-plus-xcode8gua-pei/">玩转iOS10+Xcode8适配</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/09/26/zui-xin-shu-dan/">最新书单</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/09/26/zhi-bo-mei-yan-pian/">直播-美颜篇</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/al1020119">@al1020119</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'al1020119',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>




<section>
<h1>扫一扫<abbr title="The word '扫一扫' is a registered trademark of DENSO WAVE INCORPORATED. It applies only for the word '扫一扫', not for image.">&trade;</abbr></h1>
<a href="http://al1020119.github.io/posts/2/index.html"><img src="http://chart.apis.google.com/chart?chs=150x150&cht=qr&chld=|0&chco=165B94&chl=http://al1020119.github.io/posts/2/index.html" alt="post-qrcode"></a></section>
<section>
    <h1>访客统计</h1>
    <br/>
    <a href="http://s07.flagcounter.com/more/2SH"><img src="http://s07.flagcounter.com/count/2SH/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_1/flags_0/" alt="Flag Counter" border="0"></a>
</section><section>
    <h1>新浪微博</h1>
    <ul id="weibo">
        <li>
            
            <!-- 在此插入获得的微博秀代码 -->
            <iframe width="100%" height="550" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=550&fansRow=2&ptype=1&speed=0&skin=1&isTitle=1&noborder=1&isWeibo=1&isFans=1&uid=3288975567&verifier=20ffcedd&dpc=1"></iframe>
            
        </li>
    </ul>
</section>
  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2013 - iCocos -
<span class="credit">welcome to <a href="http://al1020119.github.io">曹#黎</a></span>
</p>

</footer>
  






<!--
-->



</body>
</html>
