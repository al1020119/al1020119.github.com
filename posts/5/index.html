
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>iOS梦工厂</title>
  <meta name="author" content="iCocos">

  
  <meta name="description" content="XMPP使用总结 ordinal 引言：
最近面试被问到了一个问题，笔者当时就懵了：什么XMPP，平时怎么使用，使用过程中遇到什么问题？。 但是还是通过记忆，简单的说了一下自己所知道了，不过那并没有撒卵用，所以你懂的 ##XMPPFramework是一个OS X/iOS平台的开源项目， &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://al1020119.github.io/posts/5/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="iOS梦工厂" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//libs.baidu.com/jquery/1.7.2/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <script>
function addBlankTargetForLinks () {
    $('a[href^="http"]').each(function(){
                              $(this).attr('target', '_blank');
                              });
}
$(document).bind('DOMNodeInserted', function(event) {
             addBlankTargetForLinks();
             });
</script>
  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">iOS梦工厂</a></h1>
  
    <h2>不战胜自己，何以改变未来！</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="al1020119.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">首页</a></li>
  <li><a href="/blog/archives">归档</a></li>
  <li><a href="/icocos">iCocos</a></li>
  <li><a href="/other">其他</a></li>
  <li><a href="/about">关于</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/04/12/xmppshi-yong-zong-jie/">XMPP使用总结</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><p>引言：
最近面试被问到了一个问题，笔者当时就懵了：什么XMPP，平时怎么使用，使用过程中遇到什么问题？。</p>

<p>但是还是通过记忆，简单的说了一下自己所知道了，不过那并没有撒卵用，所以你懂的</p>

<h6>##XMPPFramework是一个OS X/iOS平台的开源项目，使用Objective-C实现了XMPP协议（RFC-3920），同时还提供了用于读写XML的工具，大大简化了基于XMPP的通信应用的开发。</h6>

<h3>关于连接的</h3>

<pre><code>//此方法在stream开始连接服务器的时候调用
 - (void)xmppStreamDidConnect:(XMPPStream *)sender
 //此方法在stream连接断开的时候调用
 - (void)xmppStreamDidDisconnect:(XMPPStream *)sender withError:(NSError *)error;
</code></pre>

<h3>关于验证的</h3>

<pre><code>//验证失败后调用
 - (void)xmppStream:(XMPPStream *)sender didNotAuthenticate:(NSXMLElement *)error
//验证成功后调用
 - (void)xmppStreamDidAuthenticate:(XMPPStream *)sender
</code></pre>

<h3>关于通信的</h3>

<pre><code>//收到消息后调用
- (void)xmppStream:(XMPPStream *)sender didReceiveMessage:(XMPPMessage *)message
//接受到好友状态更新
- (void)xmppStream:(XMPPStream *)sender didReceivePresence:(XMPPPresence *)presence
</code></pre>

<h4>简单实战</h4>

<h6>登录和好友上下线</h6>

<h5>XMPP中常用对象们</h5>

<pre><code>XMPPStream：xmpp基础服务类
XMPPRoster：好友列表类
XMPPRosterCoreDataStorage：好友列表（用户账号）在core data中的操作类
XMPPvCardCoreDataStorage：好友名片（昵称，签名，性别，年龄等信息）在core data中的操作类
XMPPvCardTemp：好友名片实体类，从数据库里取出来的都是它
xmppvCardAvatarModule：好友头像
XMPPReconnect：如果失去连接,自动重连
XMPPRoom：提供多用户聊天支持
</code></pre>

<p>XMPPPubSub：发布订阅</p>

<h5>登录操作，也就是连接xmpp服务器</h5>

<pre><code>- (void)connect {
    if (self.xmppStream == nil) {
        self.xmppStream = [[XMPPStream alloc] init];
        [self.xmppStream addDelegate:self delegateQueue:dispatch_get_main_queue()];
    }
    if (![self.xmppStream isConnected]) {
        NSString *username = [[NSUserDefaults standardUserDefaults] objectForKey:@"username"];
        XMPPJID *jid = [XMPPJID jidWithUser:username domain:@"lizhen" resource:@"Ework"];
        [self.xmppStream setMyJID:jid];
        [self.xmppStream setHostName:@"10.4.125.113"];
        NSError *error = nil;
        if (![self.xmppStream connect:&amp;error]) {
            NSLog(@"Connect Error: %@", [[error userInfo] description]);
        }
    }
}
</code></pre>

<p>connect成功之后会依次调用XMPPStreamDelegate的方法，首先调用</p>

<pre><code>- (void)xmppStream:(XMPPStream *)sender socketDidConnect:(GCDAsyncSocket *)socket
</code></pre>

<p>&hellip;
然后</p>

<ul>
<li><p>(void)xmppStreamDidConnect:(XMPPStream *)sender
在该方法下面需要使用xmppStream 的authenticateWithPassword方法进行密码验证，成功的话会响应delegate的方法，就是下面这个</p></li>
<li><p>(void)xmppStreamDidAuthenticate:(XMPPStream *)sender</p></li>
</ul>


<h5>上线</h5>

<p>实现 - (void)xmppStreamDidAuthenticate:(XMPPStream *)sender 委托方法</p>

<pre><code>- (void)xmppStreamDidAuthenticate:(XMPPStream *)sender {
     XMPPPresence *presence = [XMPPPresence presenceWithType:@"available"];
    [self.xmppStream sendElement:presence];
 }
</code></pre>

<h5>退出并断开连接</h5>

<pre><code> - (void)disconnect {
     XMPPPresence *presence = [XMPPPresence presenceWithType:@"unavailable"];
    [self.xmppStream sendElement:presence];

      [self.xmppStream disconnect];
  }
</code></pre>

<h5>好友状态</h5>

<p>获取好友状态，通过实现</p>

<pre><code>- (void)xmppStream:(XMPPStream *)sender didReceivePresence:(XMPPPresence *)presence
</code></pre>

<p>&hellip;
方法，当接收到 presence 标签的内容时，XMPPFramework 框架回调该方法</p>

<pre><code>presence 的状态：
available 上线
away 离开
do not disturb 忙碌
unavailable 下线

- (void)xmppStream:(XMPPStream *)sender didReceivePresence:(XMPPPresence *)presence {
    NSString *presenceType = [presence type];
    NSString *presenceFromUser = [[presence from] user];
    if (![presenceFromUser isEqualToString:[[sender myJID] user]]) {
        if ([presenceType isEqualToString:@"available"]) {
            //
        } else if ([presenceType isEqualToString:@"unavailable"]) {
            //
        }
    }
}
</code></pre>

<h3>接收消息和发送消息</h3>

<h5>接收消息</h5>

<p>通过实现</p>

<ul>
<li><p>(void)xmppStream:(XMPPStream <em>)sender didReceiveMessage:(XMPPMessage </em>)message;
当接收到 message 标签的内容时，XMPPFramework 框架回调该方法
根据 XMPP 协议，消息体的内容存储在标签 body 内</p></li>
<li><p>(void)xmppStream:(XMPPStream <em>)sender didReceiveMessage:(XMPPMessage </em>)message {
  NSString *messageBody = [[message elementForName:@&ldquo;body&rdquo;] stringValue];
}</p></li>
</ul>


<h5>发送消息</h5>

<p>发送消息，我们需要根据 XMPP 协议，将数据放到标签内</p>

<pre><code>- (void)sendMessage:(NSString *) message toUser:(NSString *) user {
    NSXMLElement *body = [NSXMLElement elementWithName:@"body"];
    [body setStringValue:message];
    NSXMLElement *message = [NSXMLElement elementWithName:@"message"];
    [message addAttributeWithName:@"type" stringValue:@"chat"];
    NSString *to = [NSString stringWithFormat:@"%@@example.com", user];
    [message addAttributeWithName:@"to" stringValue:to];
    [message addChild:body];
    [self.xmppStream sendElement:message];
}
</code></pre>

<h3>获取好友信息和删除好友</h3>

<h5>好友列表和好友名片</h5>

<pre><code>[_xmppRoster fetchRoster];//获取好友列表
//获取到一个好友节点
- (void)xmppRoster:(XMPPRoster *)sender didRecieveRosterItem:(NSXMLElement *)item
//获取完好友列表
- (void)xmppRosterDidEndPopulating:(XMPPRoster *)sender
//到服务器上请求联系人名片信息
- (void)fetchvCardTempForJID:(XMPPJID *)jid;
//请求联系人的名片，如果数据库有就不请求，没有就发送名片请求
- (void)fetchvCardTempForJID:(XMPPJID *)jid ignoreStorage:(BOOL)ignoreStorage;
//获取联系人的名片，如果数据库有就返回，没有返回空，并到服务器上抓取
- (XMPPvCardTemp *)vCardTempForJID:(XMPPJID *)jid shouldFetch:(BOOL)shouldFetch;
//更新自己的名片信息
- (void)updateMyvCardTemp:(XMPPvCardTemp *)vCardTemp;
//获取到一盒联系人的名片信息的回调
- (void)xmppvCardTempModule:(XMPPvCardTempModule *)vCardTempModule
        didReceivevCardTemp:(XMPPvCardTemp *)vCardTemp
                     forJID:(XMPPJID *)jid
</code></pre>

<h5>添加好友</h5>

<pre><code>//name为用户账号
    - (void)XMPPAddFriendSubscribe:(NSString *)name
    {
        //XMPPHOST 就是服务器名，  主机名
        XMPPJID *jid = [XMPPJID jidWithString:[NSString stringWithFormat:@"%@@%@",name,XMPPHOST]];
        //[presence addAttributeWithName:@"subscription" stringValue:@"好友"];
        [xmppRoster subscribePresenceToUser:jid];

    }
</code></pre>

<h5>收到添加好友的请求</h5>

<pre><code>- (void)xmppRoster:(XMPPRoster *)sender didReceivePresenceSubscriptionRequest:(XMPPPresence *)presence
    {
        //取得好友状态
        NSString *presenceType = [NSString stringWithFormat:@"%@", [presence type]]; //online/offline
        //请求的用户
        NSString *presenceFromUser =[NSString stringWithFormat:@"%@", [[presence from] user]];
        NSLog(@"presenceType:%@",presenceType);

        NSLog(@"presence2:%@  sender2:%@",presence,sender);

        XMPPJID *jid = [XMPPJID jidWithString:presenceFromUser];
        //接收添加好友请求
        [xmppRoster acceptPresenceSubscriptionRequestFrom:jid andAddToRoster:YES];

    }
</code></pre>

<h5>删除好友</h5>

<pre><code>//删除好友，name为好友账号
- (void)removeBuddy:(NSString *)name  
{  
    XMPPJID *jid = [XMPPJID jidWithString:[NSString stringWithFormat:@"%@@%@",name,XMPPHOST]];  

    [self xmppRoster] removeUser:jid];  
}
</code></pre>

<h5>聊天室</h5>

<p>初始化聊天室</p>

<pre><code>     XMPPJID *roomJID = [XMPPJID jidWithString:ROOM_JID];

    xmppRoom = [[XMPPRoom alloc] initWithRoomStorage:self jid:roomJID];

    [xmppRoom activate:xmppStream];
     [xmppRoom addDelegate:self delegateQueue:dispatch_get_main_queue()];
</code></pre>

<p>创建聊天室成功</p>

<pre><code>`- (void)xmppRoomDidCreate:(XMPPRoom *)sender
{
    DDLogInfo(@"%@: %@", THIS_FILE, THIS_METHOD);
}`
</code></pre>

<p>加入聊天室，使用昵称</p>

<pre><code>[xmppRoom joinRoomUsingNickname:@"quack" history:nil];
</code></pre>

<p>获取聊天室信息</p>

<pre><code>- (void)xmppRoomDidJoin:(XMPPRoom *)sender
    {
        [xmppRoom fetchConfigurationForm];
        [xmppRoom fetchBanList];
        [xmppRoom fetchMembersList];
        [xmppRoom fetchModeratorsList];
    }
</code></pre>

<p>如果房间存在，会调用委托</p>

<pre><code>    // 收到禁止名单列表

    - (void)xmppRoom:(XMPPRoom *)sender didFetchBanList:(NSArray *)items;
    // 收到好友名单列表

    - (void)xmppRoom:(XMPPRoom *)sender didFetchMembersList:(NSArray *)items;
    // 收到主持人名单列表

    - (void)xmppRoom:(XMPPRoom *)sender didFetchModeratorsList:(NSArray *)items;
房间不存在，调用委托

    - (void)xmppRoom:(XMPPRoom *)sender didNotFetchBanList:(XMPPIQ *)iqError;
    - (void)xmppRoom:(XMPPRoom *)sender didNotFetchMembersList:(XMPPIQ *)iqError;
    - (void)xmppRoom:(XMPPRoom *)sender didNotFetchModeratorsList:(XMPPIQ *)iqError;
</code></pre>

<p>离开房间</p>

<pre><code>[xmppRoom deactivate:xmppStream];
</code></pre>

<p>XMPPRoomDelegate的其他代理方法:</p>

<p>离开聊天室</p>

<pre><code>    - (void)xmppRoomDidLeave:(XMPPRoom *)sender
    {
        DDLogVerbose(@"%@: %@", THIS_FILE, THIS_METHOD);
    }
</code></pre>

<p>新人加入群聊</p>

<pre><code>    - (void)xmppRoom:(XMPPRoom *)sender occupantDidJoin:(XMPPJID *)occupantJID
     {
         DDLogVerbose(@"%@: %@", THIS_FILE, THIS_METHOD);
    }
</code></pre>

<p>有人退出群聊</p>

<pre><code>    - (void)xmppRoom:(XMPPRoom *)sender occupantDidLeave:(XMPPJID *)occupantJID
    {
        DDLogVerbose(@"%@: %@", THIS_FILE, THIS_METHOD);
    }
</code></pre>

<p>有人在群里发言</p>

<pre><code>    - (void)xmppRoom:(XMPPRoom *)sender didReceiveMessage:(XMPPMessage *)message fromOccupant:(XMPPJID *)occupantJID
     {
         DDLogVerbose(@"%@: %@", THIS_FILE, THIS_METHOD);
    }
</code></pre>

<h5>消息回执</h5>

<p>这个是XEP－0184协议的内容
发送消息时附加回执请求
代码实现</p>

<pre><code>NSString *siID = [XMPPStream generateUUID];
    //发送消息
    XMPPMessage *message = [XMPPMessage messageWithType:@"chat" to:jid elementID:siID];
    NSXMLElement *receipt = [NSXMLElement elementWithName:@"request" xmlns:@"urn:xmpp:receipts"];
    [message addChild:receipt];
    [message addBody:@"测试"];
    [self.xmppStream sendElement:message];
</code></pre>

<p>收到回执请求的消息，发送回执</p>

<pre><code>- (void)xmppStream:(XMPPStream *)sender didReceiveMessage:(XMPPMessage *)message
    {
        //回执判断
        NSXMLElement *request = [message elementForName:@"request"];
        if (request)
        {
            if ([request.xmlns isEqualToString:@"urn:xmpp:receipts"])//消息回执
            {
                //组装消息回执
                XMPPMessage *msg = [XMPPMessage messageWithType:[message attributeStringValueForName:@"type"] to:message.from elementID:[message attributeStringValueForName:@"id"]];
                NSXMLElement *recieved = [NSXMLElement elementWithName:@"received" xmlns:@"urn:xmpp:receipts"];
                [msg addChild:recieved];

                //发送回执
                [self.xmppStream sendElement:msg];
            }
        }else
        {
            NSXMLElement *received = [message elementForName:@"received"];
            if (received)
            {
                if ([received.xmlns isEqualToString:@"urn:xmpp:receipts"])//消息回执
                {
                    //发送成功
                    NSLog(@"message send success!");
                }  
            }  
        }  

        //消息处理  
        //...  
    }
</code></pre>

<h5>添加AutoPing</h5>

<p>为 了监听服务器是否有效，增加心跳监听。用XEP-0199协议，在XMPPFrameWork框架下，封装了 XMPPAutoPing 和 XMPPPing两个类都可以使用，因为XMPPAutoPing已经组合进了XMPPPing类，所以XMPPAutoPing使用起来更方便。</p>

<pre><code>//初始化并启动ping
-(void)autoPingProxyServer:(NSString*)strProxyServer
{
    _xmppAutoPing = [[XMPPAutoPingalloc] init];
    [_xmppAutoPingactivate:_xmppStream];
    [_xmppAutoPingaddDelegate:selfdelegateQueue:  dispatch_get_main_queue()];
    _xmppAutoPing.respondsToQueries = YES;
    _xmppAutoPing.pingInterval=2;//ping 间隔时间
    if (nil != strProxyServer)
    {
       _xmppAutoPing.targetJID = [XMPPJID jidWithString: strProxyServer ];//设置ping目标服务器，如果为nil,则监听socketstream当前连接上的那个服务器
    }
}
//卸载监听
 [_xmppAutoPing   deactivate];
  [_xmppAutoPing   removeDelegate:self];
   _xmppAutoPing = nil;
//ping XMPPAutoPingDelegate的委托方法:
- (void)xmppAutoPingDidSendPing:(XMPPAutoPing *)sender
{
    NSLog(@"- (void)xmppAutoPingDidSendPing:(XMPPAutoPing *)sender");
}
- (void)xmppAutoPingDidReceivePong:(XMPPAutoPing *)sender
{
    NSLog(@"- (void)xmppAutoPingDidReceivePong:(XMPPAutoPing *)sender");
}

- (void)xmppAutoPingDidTimeout:(XMPPAutoPing *)sender
{
    NSLog(@"- (void)xmppAutoPingDidTimeout:(XMPPAutoPing *)sender");
}
</code></pre>
</div>
  
  




| <a href="/blog/2015/04/12/xmppshi-yong-zong-jie/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/03/02/uitableviewxing-neng-you-hua-yu-qia-dun-wen-ti/">UITableView性能优化与卡顿问题</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><p>引言：</p>

<p>在iOS开发中关于TableView算是已经用烂了的控件，但是又有几个人认真去考路过他的性能优化问题（卡顿）</p>

<p>最近项目中也遇到了不少卡顿的问题，为了更好的饿提高项目的性能，也为了提高自己的技术，专门花了一段时间研究了一下关于TableView的性能问题，在这里就总结了一下，希望可以帮你解决实际问题。</p>

<p>1.最常用的就是cell的重用， 注册重用标识符</p>

<pre><code>如果不重用cell时，每当一个cell显示到屏幕上时，就会重新创建一个新的cell
如果有很多数据的时候，就会堆积很多cell。如果重用cell，为cell创建一个ID
每当需要显示cell 的时候，都会先去缓冲池中寻找可循环利用的cell，如果没有再重新创建cell
设置正确的reuseIdentifer以重用cell
</code></pre>

<p>2.避免cell的重新布局</p>

<pre><code>cell的布局填充等操作 比较耗时，一般创建时就布局好
如可以将cell单独放到一个自定义类，初始化时就布局好
</code></pre>

<p>3.提前计算并缓存cell的属性及内容</p>

<pre><code>在cellForRowAtIndexPath:中尽量做更少的操作。如果需要做一些处理，那么最好做过一次之后，就将结果缓存起来。
当我们创建cell的数据源方法时，编译器并不是先创建cell 再定cell的高度
而是先根据内容一次确定每一个cell的高度，高度确定后，再创建要显示的cell，滚动时，每当cell进入凭虚都会计算高度，提前估算高度告诉编译器，编译器知道高度后，紧接着就会创建cell，这时再调用高度的具体计算方法，这样可以方式浪费时间去计算显示以外的cell
</code></pre>

<p>4.减少cell中控件的数量</p>

<pre><code>尽量使cell得布局大致相同，不同风格的cell可以使用不用的重用标识符，初始化时添加控件，
不适用的可以先隐藏
</code></pre>

<p>5.不要使用ClearColor，无背景色，透明度也不要设置为0</p>

<pre><code>渲染耗时比较长
尽量将view设置为不透明，包括cell本身。
</code></pre>

<p>6.使用局部更新</p>

<pre><code>如果只是更新某组的话，使用reloadSection进行局部更新
</code></pre>

<p>7.加载网络数据，下载图片，使用异步加载，并缓存</p>

<pre><code>如果cell显示的内容来此网络，那么确保这些内容是通过异步来获取的
</code></pre>

<p>8.少使用addView 给cell动态添加view</p>

<p>9.按需加载cell，cell滚动很快时，只加载范围内的cell</p>

<pre><code>注意正确使用懒加载
</code></pre>

<p>10.不要实现无用的代理方法，tableView只遵守两个协议</p>

<pre><code>非必要的代理或者数据源方法可以省略，比如numberofsention
</code></pre>

<p>11.缓存行高：</p>

<pre><code>如果row的高度不相同，那么将其缓存下来
estimatedHeightForRow不能和HeightForRow里面的layoutIfNeed同时存在，这两者同时存在才会出现“窜动”的bug。所以我的建议是：只要是固定行高就写预估行高来减少行高调用次数提升性能。如果是动态行高就不要写预估方法了，用一个行高的缓存字典来减少代码的调用次数即可
</code></pre>

<p>12.避免渐变，图像缩放以及离屏绘制</p>

<p>13.使用shadowPath来设置阴影。</p>

<p>14.使用适当的数据结构来保存需要的信息。不同的结构会带来不同的操作代价。</p>

<p>15.使用rowHeight, sectionFooterHeight 和 sectionHeaderHeight 来设置一个恒定 高度，而不要从delegate中获取。</p>

<p>16.使用富文本标签代价是很昂贵的</p>

<p>费尽周折用富文本标签，代价太昂贵了。尽可能地避免使用这个。问问你自己是否真的需要这个。如果是的话，尽可能的做缓存。</p>

<hr />

<p>参考：相关性能优化问题</p>

<p><a href="http://www.cocoachina.com/ios/20150408/11501.html">iOS应用性能调优的25个建议和技巧</a></p>
</div>
  
  




| <a href="/blog/2015/03/02/uitableviewxing-neng-you-hua-yu-qia-dun-wen-ti/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/03/01/lan-ya-kai-fa-ni-zhi-dao-duo-shao/">蓝牙开发你知道多少</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><p>蓝牙简单介绍和4.0的基本使用</p>

<p>背景：</p>

<ul>
<li>iOS的蓝牙不能用来传输文件。</li>
<li>iOS与iOS设备之间进行数据通信，使用gameKit.framework</li>
<li>iOS与其他非iOS设备进行数据通信，使用coreBluetooth.framework</li>
</ul>


<h3>iOS中蓝牙的实现方案</h3>

<p>iOS中提供了4个框架用于实现蓝牙连接</p>

<ol>
<li><p>GameKit.framework（用法简单）</p>

<p> <code>只能用于iOS设备之间的连接，多用于游戏（比如五子棋对战），从iOS7开始过期</code></p></li>
<li><p>MultipeerConnectivity.framework</p>

<p> <code>只能用于iOS设备之间的连接，从iOS7开始引入，主要用于文件共享（仅限于沙盒的文件）</code></p></li>
<li><p>ExternalAccessory.framework</p>

<p> <code>可用于第三方蓝牙设备交互，但是蓝牙设备必须经过苹果MFi认证（国内较少）</code></p></li>
<li><h6>CoreBluetooth.framework（时下热门）</h6>

<p> <code>可用于第三方蓝牙设备交互，必须要支持蓝牙4.0</code></p>

<p> <code>硬件至少是4s，系统至少是iOS6</code></p>

<p> <code>蓝牙4.0以低功耗著称，一般也叫BLE（BluetoothLowEnergy）</code></p>

<p> <code>目前应用比较多的案例：运动手坏、嵌入式设备、智能家居</code></p></li>
</ol>


<p>下面具体介绍使用CoreBluetooth.framework的代码步骤：</p>

<h5>蓝牙系统库</h5>

<pre><code>#import &lt;CoreBluetooth/CoreBluetooth.h&gt;
</code></pre>

<h5>必须要由UUID来唯一标示对应的service和characteristic</h5>

<pre><code>#define kServiceUUID @"5C476471-1109-4EBE-A826-45B4F9D74FB9"

#define kCharacteristicHeartRateUUID @"82C7AC0F-6113-4EC9-92D1-5EEF44571398"

#define kCharacteristicBodyLocationUUID @"537B5FD6-1889-4041-9C35-F6949D1CA034"
</code></pre>

<hr />

<pre><code>@interface ViewController ()&lt;CBCentralManagerDelegate,CBPeripheralDelegate&gt;



@property (nonatomic,strong)CBCentralManager * centralManager;

@property (nonatomic,strong)CBPeripheral     * peripheral;

@end
</code></pre>

<h4>创建中心角色</h4>

<pre><code>#import &lt;CoreBluetooth/CoreBluetooth.h&gt;

- (void)viewDidLoad
{

    [super viewDidLoad];

    //初始化蓝牙 central manager

    _centralManager = [[CBCentralManager alloc]initWithDelegate:self queue:dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0) options:nil];    

}
</code></pre>

<h4>扫描外设</h4>

<pre><code>[manager scanForPeripheralsWithServices:nil options:@{CBCentralManagerRestoredStateScanOptionsKey:@(YES)}];
</code></pre>

<h4>连接外设</h4>

<pre><code>- (void)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)peripheral advertisementData:(NSDictionary *)advertisementData RSSI:(NSNumber *)RSSI
{
        if([peripheral.name  isEqualToString:BLE_SERVICE_NAME]){
                [self connect:peripheral];
        }
}       

-(BOOL)connect:(CBPeripheral *)peripheral{
        self.manager.delegate = self;
        [self.manager connectPeripheral:peripheral
                                options:[NSDictionary dictionaryWithObject:[NSNumber numberWithBool:YES] forKey:CBConnectPeripheralOptionNotifyOnDisconnectionKey]];
}
</code></pre>

<h4>扫描外设中的服务和特征</h4>

<pre><code>- (void)centralManager:(CBCentralManager *)central didConnectPeripheral:(CBPeripheral *)peripheral
{

   NSLog(@"Did connect to peripheral: %@", peripheral);       

   _testPeripheral = peripheral;
   [peripheral setDelegate:self];  &lt;br&gt;//查找服务
   [peripheral discoverServices:nil];


}
</code></pre>

<h4>发现服务：</h4>

<pre><code>- (void)peripheral:(CBPeripheral *)peripheral didDiscoverServices:(NSError *)error
{


NSLog(@"didDiscoverServices");

if (error)
{
    NSLog(@"Discovered services for %@ with error: %@", peripheral.name, [error localizedDescription]);

    if ([self.delegate respondsToSelector:@selector(DidNotifyFailConnectService:withPeripheral:error:)])
        [self.delegate DidNotifyFailConnectService:nil withPeripheral:nil error:nil];

    return;
}


for (CBService *service in peripheral.services)
{
     //发现服务
    if ([service.UUID isEqual:[CBUUID UUIDWithString:UUIDSTR_ISSC_PROPRIETARY_SERVICE]])
    {
        NSLog(@"Service found with UUID: %@", service.UUID);  &lt;br&gt;//查找特征
        [peripheral discoverCharacteristics:nil forService:service];
        break;
    }


}
}
</code></pre>

<h4>发现服务中的特征：</h4>

<pre><code>- (void)peripheral:(CBPeripheral *)peripheral didDiscoverCharacteristicsForService:(CBService *)service error:(NSError *)error
{

if (error)
{
    NSLog(@"Discovered characteristics for %@ with error: %@", service.UUID, [error localizedDescription]);

    [self error];
    return;
}

NSLog(@"服务：%@",service.UUID);
for (CBCharacteristic *characteristic in service.characteristics)
{
   //发现特征
        if ([characteristic.UUID isEqual:[CBUUID UUIDWithString:@"xxxxxxx"]]) {
            NSLog(@"监听：%@",characteristic);&lt;br&gt;//监听特征
            [self.peripheral setNotifyValue:YES forCharacteristic:characteristic];
        }

}
}
</code></pre>

<h4>与外设进行数据交互</h4>

<p>读取数据：</p>

<pre><code>- (void)peripheral:(CBPeripheral *)peripheral didUpdateValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error
{
    if (error)
    {
        NSLog(@"Error updating value for characteristic %@ error: %@", characteristic.UUID, [error localizedDescription]);
        self.error_b = BluetoothError_System;
        [self error];
        return;
}

//    NSLog(@"收到的数据：%@",characteristic.value);
[self decodeData:characteristic.value];
}
</code></pre>

<h4>写数据：</h4>

<pre><code>NSData *d2 = [[PBABluetoothDecode sharedManager] HexStringToNSData:@"0x02"];
            [self.peripheral writeValue:d2 forCharacteristic:characteristic type:CBCharacteristicWriteWithoutResponse];
</code></pre>
</div>
  
  




| <a href="/blog/2015/03/01/lan-ya-kai-fa-ni-zhi-dao-duo-shao/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/01/28/cocoapodsjian-dan-cu-bao/">cocoaPods简单粗暴</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><p>直接上代码，不要问为什么，照着做就可以，我也是这么做的，具体的细节，请查看相关文档，网上太多！</p>

<p>1:移除ruby镜像（天朝的网你们懂的）</p>

<pre><code> $ gem sources --remove https://rubygems.org/ 
</code></pre>

<p>2:新增淘宝镜像</p>

<pre><code>$ gem sources -a http://ruby.taobao.org/ 
</code></pre>

<p>3:查看列表</p>

<pre><code> $ gem sources -l 
</code></pre>

<p>成功的征兆：</p>

<pre><code>*** CURRENT SOURCES ***
http://ruby.taobao.org/
$ sudo gem install cocoapods
</code></pre>

<p>4:正式安装</p>

<pre><code> sudo gem install cocoapods 
</code></pre>

<p>接下来就是开始使用了。</p>

<p>查看对应的框架</p>

<pre><code> $ pod search AFNetworking 
</code></pre>

<p>创建文件</p>

<pre><code> $ vim Podfile 
</code></pre>

<p> 或者在命令行行中cd到对应的项目文件夹使用</p>

<pre><code>touch Podfile
</code></pre>

<p>新建一个文件</p>

<p>然后在Podfile文件中输入以下文字：</p>

<pre><code>platform :ios, '7.0'
pod "AFNetworking", "~&gt; 2.0”
</code></pre>

<p>安装</p>

<pre><code> pod install  
</code></pre>

<p>更新</p>

<pre><code> $ pod update 
</code></pre>

<p>有时候可能上面的命令没有用可能是网络的原因，那么你可以试试下面的：</p>

<pre><code>pod update 换成pod update --verbose --no-repo-update
pod install 换成pod install --verbose --no-repo-update
</code></pre>

<ul>
<li>$ pod install只会按照Podfile的要求来请求类库，如果类库版本号有变化，那么将获取失败。
$ pod update会更新所有的类库，获取最新版本的类库。
或许还有一些情况是因为mac中对应的文件有问题，比如有两个Xcode的时候就会发生歧义（系统不知道用哪个），这个时候我们可以试试下面的方法。</li>
</ul>


<p>CocoaPods安装东西的时候它要找到Xcode的Developer文件夹, 如果找不到会报如下错误</p>

<ul>
<li>解决方案</li>
</ul>


<p>LNJ替换为你自己的用户名</p>

<pre><code>sudo xcode-select --switch /Users/LNJ/Applications/Xcode.app/Contents/Developer
</code></pre>

<p>而且你会发现，如果用了 $ pod update，再用 $ pod install 就成功了。</p>

<ul>
<li><p>那你也许会问，什么时候用 $ pod install，什么时候用 $ pod update 呢，我又不知道类库有没有新版本。</p></li>
<li><p>好吧，那你每次直接用 $ pod update 算了。或者先用 $ pod install，如果不行，再用 <br/>
  <code>$ pod update。</code></p></li>
</ul>


<p>当然你也可以使用Xcode插件，使用非常简单，这里就不多介绍，以后有机会给大家整理：</p>

<p><a href="https://github.com/kattrali/cocoapods-xcode-plugin">cocoapods-xcode-plugin</a></p>
</div>
  
  




| <a href="/blog/2015/01/28/cocoapodsjian-dan-cu-bao/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/12/29/yue-yu-kai-fa-xiang-jie/">底层开发之越狱开发</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><p>做越狱开发也有一些时间了，有很多东西想总结一下，希望给他人一些借鉴，也是自己对过去开发经历的一些总结。个人不推荐使用盗版，这里主要以技术介绍为主。</p>

<p>这个系列里面主要介绍怎样进行越狱开发，涉及到以下几个方面:</p>

<ul>
<li>(1)主要涉及到越狱市场的建立，在App内部实现ipa的安装和卸载以及更新。参照的对象就是91助手，25pp，同步推那样的应用。建立一个盗版的App Store.当然了，如果通过299刀的企业证书的话，是不需要通过Cydia的，直接通过网页链接就可以实现app的推广，有一定的风险。这里面涉及到一些协议，后面会进行介绍。</li>
<li>(2)在App内部实现壁纸和铃声的替换。这个过程涉及到的东西很多，特别是铃声的替换，iPhone里面非常麻烦；</li>
<li>(3)一些越狱插件的开发，通过里面有些插件非常好用，合理，而且非常美观漂亮。
这里先从App内部安装ipa包开始讲，后面逐步把上面提到的3点全部讲完。</li>
</ul>


<p>一般情况下安装91助手，同步推这样的应用需要手机越狱，同时安装AppSync，这样才能使用，所以进行开发的必备条件也是如此。</p>

<p>上传的demo工程的地址，我的github链接：<a href="https://github.com/easonoutlook/IPAInstaller">https://github.com/easonoutlook/IPAInstaller</a></p>

<p>之前一直在fork别人的东西，也没做什么贡献，从现在开始，为开发为开源，做一点自己的贡献。</p>

<p>进入正题：</p>

<p>需要的工具和环境：</p>

<ol type="a">
<li>iPhone or iPad越狱，安装AppSync</li>
<li>Xcode安装 Command Line Tools</li>
<li>下载最新版本的ldid <a href="https://github.com/downloads/rpetrich/ldid/ldid.zip">https://github.com/downloads/rpetrich/ldid/ldid.zip</a></li>
</ol>


<p>1、修改SDKSettings.plist文件</p>

<p>我用的是Xcode4.6.3版本，iPhone的版本是6.1.2, 路径为：</p>

<pre><code>/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS6.1.sdk/
</code></pre>

<p>将这个目录下的 SDKSettings.plist里面的CODE_SIGNING_REQUIRED置为NO</p>

<p>执行命令为：</p>

<p>转到目录下</p>

<pre><code>cd /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS6.1.sdk
</code></pre>

<p>将原有文件备份</p>

<pre><code>sudo cp SDKSettings.plist SDKSettings.plist.orig
</code></pre>

<p>对SDKSettings.plist文件进行编辑</p>

<pre><code>sudo vim SDKSettings.plist
</code></pre>

<p>将下面对应的字段改为NO</p>

<pre><code>&lt;key&gt;CODE_SIGNING_REQUIRED&lt;/key&gt;
&lt;string&gt;YES&lt;/string&gt;  // 默认为YES, 需要改为NO
</code></pre>

<p>此操作参考的路径如下：</p>

<pre><code>http://kqwd.blog.163.com/blog/static/4122344820117191351263/
</code></pre>

<p>2、给工程添加相应的权限，iOS6里面需要赋予权限才可以，iOS5之前不需要此操作</p>

<p>新建一个plist文件，命名为entitlements.</p>

<pre><code>![Alt text](/iamges/yueyu001.jpg)
</code></pre>

<p><img src="/images/yueyu001.png" title="Caption" ></p>

<p>创建一个plist</p>

<pre><code>![Alt text](/iamges/yueyu002.jpg)
</code></pre>

<p><img src="/images/yueyu002.png" title="Caption" ></p>

<p>将plist文件改为：</p>

<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;
&lt;plist version="1.0"&gt;
&lt;dict&gt;
    &lt;key&gt;com.apple.private.mobileinstall.allowedSPI&lt;/key&gt;
    &lt;array&gt;
        &lt;string&gt;Install&lt;/string&gt;
        &lt;string&gt;Browse&lt;/string&gt;
        &lt;string&gt;Uninstall&lt;/string&gt;
        &lt;string&gt;Archive&lt;/string&gt;
        &lt;string&gt;RemoveArchive&lt;/string&gt;
    &lt;/array&gt;
&lt;/dict&gt;
&lt;/plist&gt;
</code></pre>

<p>将Code Signing 的Code Signing Entilements设置为刚刚创建的entitlements.plist文件</p>

<pre><code>![Alt text](/iamges/yueyu003.jpg)
</code></pre>

<p><img src="/images/yueyu003.png" title="Caption" ></p>

<p>后面还需要一个手续，将生产的app文件用ldid签名。后面再介绍。</p>

<p>3、实现越狱安装的代码：</p>

<pre><code>typedef NSDictionary *(*PMobileInstallationLookup)(NSDictionary *params, id callback_unknown_usage);
NSDictionary *IPAInstalledApps()
{
void *lib = dlopen("/System/Library/PrivateFrameworks/MobileInstallation.framework/MobileInstallation", RTLD_LAZY);
if (lib)
{
    PMobileInstallationLookup pMobileInstallationLookup = (PMobileInstallationLookup)dlsym(lib, "MobileInstallationLookup");
    if (pMobileInstallationLookup)
    {
        NSArray *wanted = nil;//[NSArray arrayWithObjects:@"com.celeware.IPADeploy",@"com.celeware.celedial",nil]; Lookup specified only
        NSDictionary *params = [NSDictionary dictionaryWithObjectsAndKeys:@"User", @"ApplicationType", wanted, @"BundleIDs",nil];
        NSDictionary *dict = pMobileInstallationLookup(params, NULL);
#ifdef DEBUG
        NSLog(@"%@", dict);
#endif
        return dict;
    }
}
return nil;
}
</code></pre>

<p>所有代码均在之前的github目录中，可以自行查看。</p>

<p>4、编译生成App文件</p>

<p>因为需要给APP签名加权限，所以不要生成IPA文件，而是生成APP文件。等把签名与权限加好后，再手动用APP制作IPA文件。</p>

<p> 在Xcode中选择设备（IOS Device）（图3），编译（Build）（图4）。编译完成后，在工程的Products文件夹中可以看到刚刚编译好的APP文件，右键Show in Finder（图5），就可以在文件夹中显示。将APP复制到一个别的文件夹中，什么地方都可以，后面需要用到。</p>

<pre><code>![Alt text](/iamges/yueyu004.jpg)
</code></pre>

<p><img src="/images/yueyu004.png" title="Caption" ></p>

<p>5、制作ipa文件</p>

<p>将之前提到的ldid下载好后，将ldid文件放到/usr/bin中。</p>

<p>比如在 Download 目录下， sudo -i</p>

<p>然后 cp ldid /usr/bin/即可将文件拷贝到/usr/bin中。</p>

<p>然后对之前生成的文件，进行ldid签名</p>

<pre><code>![Alt text](/iamges/yueyu005.jpg)
</code></pre>

<p><img src="/images/yueyu005.png" title="Caption" ></p>

<ul>
<li><p>这个命令中“ldid -S” ，“ldid”与“-S”之间有一个空格。“-S”与“entitlements.xml”之间没有空格。“entitlements.xml”就是上面说到的XML文件，如果你的XML不是这个名，请将命令修改为你的XML文件名即可。</p></li>
<li><p>“-Sentitlements.xm”与“ipainstall.app”之间有一个空格。“ipainstall”是刚刚生成的APP文件，如果你的名字不一样，请修改为你的名字。“/“后面和APP的名字是一样的。  如果没有输出错误信息或是卡住（就是敲回车后没反应）就是添加权限成功了。</p></li>
</ul>


<p>6、生成ipa文件，安装</p>

<p>新建一个文件夹，命名为“Payload”。将刚刚添加好权限的APP文件放到这个文件夹中。右键“压缩Payload”，得到一个“.zip”文件，将这个ZIP文件的后缀名改为“.ipa”。好了，IPA文件就制作完成了。</p>

<p>然后通过itools安装，测试刚刚生成的文件</p>

<pre><code>![Alt text](/iamges/yueyu006.jpg)
</code></pre>

<p><img src="/images/yueyu006.png" title="Caption" ></p>

<p>整合了很多资源，有些地方弄的比较凌乱，后面加以完善</p>

<h1>检查iphone时候越狱</h1>

<p>今天项目中要用到检查iPhone是否越狱的方法。</p>

<p>Umeng统计的Mobclick.h里面已经包含了越狱检测的代码，可以直接使用</p>

<p>复制代码
复制代码</p>

<pre><code>/*方法名:
 *        isJailbroken
*介绍:
*        类方法，判断设备是否越狱，判断方法根据 apt和Cydia.app的path来判断
*参数说明:
*        无
*        
*
*/

#pragma mark utils api
// 类方法，判断当前设备是否已经越狱
+ (BOOL)isJailbroken;
// 类方法，判断你的App是否被破解
+ (BOOL)isPirated;
</code></pre>

<p>apt和Cydia的方式来进行判断的，没看见源码</p>

<p>然后再介绍两种方法来查看是否已经越狱，知其然知其所以然、、、</p>

<h3>apt</h3>

<pre><code>- (BOOL) asAP
{
return [[NSFileManager defaultManager] fileExistsAtPath:@"/private/var/lib/at/"];
4 }`
</code></pre>

<h3>system</h3>

<pre><code>`1 - (BOOL) successCallSystem
2 {
3 return (system("ls") == 0) ? YES : NO;
4 }`
</code></pre>

<h3>示例代码</h3>

<pre><code>static const char* jailbreak_apps[] =

  {
      "/Applications/Cydia.app",
      "/Applications/limera1n.app",
      "/Applications/greenpois0n.app",
      "/Applications/blackra1n.app",
      "/Applications/blacksn0w.app",
      "/Applications/redsn0w.app",
     "/Applications/Absinthe.app",
     NULL,
 };

 - (BOOL) isJailBroken
 {
     // Now check for known jailbreak apps. If we encounter one, the device is jailbroken.
     for (int i = 0; jailbreak_apps[i] != NULL; ++i)
     {
         if ([[NSFileManager defaultManager] fileExistsAtPath:[NSString stringWithUTF8String:jailbreak_apps[i]]])
         {
             //NSLog(@"isjailbroken: %s", jailbreak_apps[i]);
             return YES;
         }
     }

               // TODO: Add more checks? This is an arms-race we're bound to lose.

     return NO;
 }
</code></pre>

<hr />

<pre><code>@interface UIDevice (Helper)  
 - (BOOL)isJailbroken;  
 @end
</code></pre>

<hr />

<pre><code>@implementation UIDevice (Helper)  
- (BOOL)isJailbroken {  
BOOL jailbroken = NO;  
NSString *cydiaPath = @"/Applications/Cydia.app";  
NSString *aptPath = @"/private/var/lib/apt/";  
if ([[NSFileManager defaultManager] fileExistsAtPath:cydiaPath]) {  
 jailbroken = YES;  
}  
if ([[NSFileManager defaultManager] fileExistsAtPath:aptPath]) {  
 jailbroken = YES;  
}  
return jailbroken;  
}  
@end
</code></pre>

<hr />

<p>参考资源链接：</p>

<p><a href="http://since2006.com/blog/240/ios6-mobileinstallationinstall">http://since2006.com/blog/240/ios6-mobileinstallationinstall</a>
<a href="http://blog.sina.com.cn/s/blog_9cd1705d0101l4bo.html">http://blog.sina.com.cn/s/blog_9cd1705d0101l4bo.html</a></p>
</div>
  
  




| <a href="/blog/2014/12/29/yue-yu-kai-fa-xiang-jie/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/12/05/tan-tan-kvcyu-kvojing-sui/">谈谈KVC与KVO精髓</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><p>Swift中使用KVC和KVO的类都必须必须继承自NSObject</p>

<p>由于ObjC主要基于Smalltalk进行设计，因此它有很多类似于Ruby、Python的动态特性，例如动态类型、动态加载、动态绑定等。今天我们着重介绍ObjC中的键值编码（KVC）、键值监听（KVO）特性：</p>

<ul>
<li>键值编码KVC</li>
<li>键值监听KVO</li>
</ul>


<h5>键值编码KVC</h5>

<p>我们知道在C#中可以通过反射读写一个对象的属性，有时候这种方式特别方便，因为你可以利用字符串的方式去动态控制一个对象。其实由于ObjC的语言特性，你根部不必进行任何操作就可以进行属性的动态读写，这种方式就是Key Value Coding（简称KVC）。</p>

<p>KVC的操作方法由NSKeyValueCoding协议提供，而NSObject就实现了这个协议，也就是说ObjC中几乎所有的对象都支持KVC操作，常用的KVC操作方法如下：</p>

<ul>
<li>动态设置： setValue:属性值 forKey:属性名（用于简单路径）、setValue:属性值 forKeyPath:属性路径（用于复合路径，例如Person有一个Account类型的属性，那么person.account就是一个复合属性）
动态读取： valueForKey:属性名 、valueForKeyPath:属性名（用于复合路径）</li>
</ul>


<h5>键值监听KVO</h5>

<p>我们知道在WPF、Silverlight中都有一种双向绑定机制，如果数据模型修改了之后会立即反映到UI视图上，类似的还有如今比较流行的基于MVVM设计模式的前端框架，例如Knockout.js。其实在ObjC中原生就支持这种机制，它叫做Key Value Observing（简称KVO）。</p>

<p>KVO其实是一种观察者模式，利用它可以很容易实现视图组件和数据模型的分离，当数据模型的属性值改变之后作为监听器的视图组件就会被激发，激发时就会回调监听器自身。在ObjC中要实现KVO则必须实现NSKeyValueObServing协议，不过幸运的是NSObject已经实现了该协议，因此几乎所有的ObjC对象都可以使用KVO。</p>

<p>在ObjC中使用KVO操作常用的方法如下：</p>

<ul>
<li>注册指定Key路径的监听器： addObserver: forKeyPath: options:  context:</li>
<li>删除指定Key路径的监听器： removeObserver: forKeyPath、removeObserver: forKeyPath: context:</li>
<li>回调监听： observeValueForKeyPath: ofObject: change: context:</li>
</ul>


<blockquote><p>KVO的使用步骤也比较简单：
通过addObserver: forKeyPath: options: context:为被监听对象（它通常是数据模型）注册监听器
重写监听器的observeValueForKeyPath: ofObject: change: context:方法</p></blockquote>

<hr />

<h3>KVC</h3>

<p>key-value coding
是1种间接访问对象的机制
key的值就是属性名称的字符串，返回的value是任意类型，需要自己转化为需要的类型
KVC主要就是两个方法</p>

<ul>
<li>（1）通过key设置对应的属性</li>
<li>（2）通过key获得对应的属性</li>
</ul>


<p>举例</p>

<pre><code>class TestForKVC:NSObject{ var hwcCSDN = "hello world" } var instance = TestForKVC() var value = instance.valueForKey("hwcCSDN") as String instance.setValue("hello hwc",forKey:"hwcCSDN")
</code></pre>

<h3>KVO</h3>

<p>key-value observing
建立在KVC之上的的机制
主要功能是检测对象属性的变化
这是1个完善的机制，不需要用户自己设计复杂的视察者模式
对需要视察的属性要在前面加上dynamic关键字
举例</p>

<h5>第1步，对要视察的对象的属性加上dynamic关键字</h5>

<pre><code>class ToObserver:NSObject{ dynamic var hwcDate = NSDate() func updateDate(){ hwcDate = NSDate() } }
</code></pre>

<h5>第2步，声明1个全局的用来辨别是哪一个被视察属性的变量</h5>

<pre><code>private var mycontext = 0
</code></pre>

<h5>第3步，在要视察的类中addObserver,在析构中removeObserver，重写observerValueForKeyPath</h5>

<pre><code>class TestForCSDN:UIViewController{ var testVariable = ToObserver() override func viewDidLoad(){ super.viewDidLoad() testVariable.addObserver(self,forKeyPath:"hwcDate",options:.New,context:&amp;mycontext) } deinit{ testVariable.removeObserver(self,forKeyPath:"hwcDate") } overfide func observeValueForKeyPath(keyPath:String,ofObject:AnyObject,change:[NSObject:AnyObject],context:UnsafeMutablePointer&lt;Void&gt;){ if(context == &amp;mycontext){ println("Changed to:(change[NSKeyValueChangeNewKey]!)") } } }
</code></pre>

<p>这样，就能够在函数observeValueForKeyPath检测到变化了</p>

<p>下面来看看OC是怎么实现KVO和KVC的</p>

<h3>1、KVC</h3>

<p>KVC(KeyValueCoding)　“键-值-编码”是一种可以直接通过字符串的名字（key）来访问类实例变量的机制，是通过setter、getter方法访问。
属性的访问和设置
KVC可以用来访问和设置实例变量的值。key是属性名称</p>

<pre><code>设置方式：[self setValue:aName forKey:@"name"]
等同于　self.name = aName;
</code></pre>

<hr />

<pre><code>访问方式： aString　=　[self valueForKey:@"name"]
等同于　aString = self.name;
</code></pre>

<h3>2、KVO 观察者</h3>

<p>KVO(KeyValueObserver)　“键-值-监听”定义了这样一种机制，当对象的属性值发生变化的时候，我们能收到一个“通知”。观察者更准确
NSObject提供了监听机制。所有子类也就全都能进行监听
KVO是基于KVC来实现的。 实现监听步骤</p>

<ul>
<li>（1）注册监听对象。</li>
</ul>


<p>anObserver指监听者，keyPath就是要监听的属性值，而context方便传输你需要的数据，它是个指针类型。</p>

<pre><code>-(void)addObserver:(NSObject *)anObserver
　　　　forKeyPath:(NSString *)keyPath
　　　　　　options:(NSKeyValueObservingOptio


ns)options            
　　　　　　context:(void *)context//（void*）是任何指针类型
</code></pre>

<p>其中， options是监听的选项，也就是说明监听返回的字典包含什么值。有两个常用的选项：
NSKeyValueObservingOptionNew　指返回的字典包含新值。
NSKeyValueObservingOptionOld    指返回的字典包含旧值。</p>

<ul>
<li>（2）实现监听方法。</li>
</ul>


<p>监听方法在Value（属性的值）发生变化的时候自动调用。</p>

<pre><code>-(void) observeValueForKeyPath:(NSString *)keyPath
                      ofObject:(id)object
                        change:(NSDictionary *)change
                       context:(void *)context
</code></pre>

<p>其中，object指被监听的对象。change里存储了一些变化的数据，比如变化前的数据，变化后的数据。</p>

<h3>3、通知</h3>

<p>通知是iOS开发框架中的一种设计模式，内部的实现机制由Cocoa框架支持。
通知一般用于M、V、C的间的信息传递。像我在设置页面设置App皮肤。
M是modol模型 V是view视图 C是control控制器。
系统通知</p>

<pre><code>//注册通知
[[NSNotificationCenter defaultCenter] addObserver:self
selector:@selector(didFinish:) //didFinish:是方法名   self （谁的）和  didFinish:确定方法
name:MPMoviePlayerPlaybackDidFinishNotification
　object:nil];
selector是方法名     class是描述类的类    SEL method=@selector（方法名）
通知用完要移除
//移除通知
[[NSNotificationCenter defaultCenter] removeObserver:self
         name:MPMoviePlayerPlaybackDidFinishNotification
                                              object:nil];
</code></pre>

<blockquote><p>总结:这一篇就介绍了iOS开发中比较有特色的两个机制：KVC和KVO</p></blockquote>

<pre><code>    KVC：就是可以暴力的去get/set类的私有属性，同时还有强大的键值路径对数组类型的属性进行操作

    KVO：监听类中属性值变化的
</code></pre>
</div>
  
  




| <a href="/blog/2014/12/05/tan-tan-kvcyu-kvojing-sui/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/11/25/fmdb/">FMDB你了解多少？</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><p>FMDB详解</p>

<p>前一篇文章中我们介绍的SQLite的使用，在iOS中原生的SQLite API在使用上相当不友好。</p>

<p>于是，就出现了一系列将SQLite API进行封装的库，例如FMDB、PlausibleDatabase、sqlitepersistentobjects等，FMDB (<a href="https://github.com/ccgus/fmdb">https://github.com/ccgus/fmdb</a>) 是一款简洁、易用的封装库，这一篇文章简单介绍下FMDB的使用。</p>

<p>在FMDB下载文件后，工程中必须导入，并使用 libsqlite3.dylib 依赖包。</p>

<p>FMDB同时兼容ARC和非ARC工程，会自动根据工程配置来调整相关的内存管理代码。</p>

<p>FMDB常用类：</p>

<ul>
<li>FMDatabase ： 一个单一的SQLite数据库，用于执行SQL语句。</li>
<li>FMResultSet ：执行查询一个FMDatabase结果集，这个和Android的Cursor类似。</li>
<li>FMDatabaseQueue ：在多个线程来执行查询和更新时会使用这个类。</li>
</ul>


<h3>创建数据库：</h3>

<pre><code>db = [FMDatabase databaseWithPath:database_path];
</code></pre>

<p>1、当数据库文件不存在时，fmdb会自己创建一个。
2、 如果你传入的参数是空串：@&ldquo;&rdquo; ，则fmdb会在临时文件目录下创建这个数据库，数据库断开连接时，数据库文件被删除。
3、如果你传入的参数是 NULL，则它会建立一个在内存中的数据库，数据库断开连接时，数据库文件被删除。</p>

<h3>打开数据库：</h3>

<pre><code>[db open]
</code></pre>

<p>返回BOOL型。</p>

<h3>关闭数据库：</h3>

<pre><code>[db close]
</code></pre>

<h3>数据库增删改等操作：</h3>

<p>除了查询操作，FMDB数据库操作都执行executeUpdate方法，这个方法返回BOOL型。</p>

<p>数据库操作(使用FMDB)</p>

<p>看一下例子：</p>

<h5>创建表：</h5>

<pre><code>if ([db open]) {
        NSString *sqlCreateTable =  [NSString stringWithFormat:@"CREATE TABLE IF NOT EXISTS '%@' ('%@' INTEGER PRIMARY KEY AUTOINCREMENT, '%@' TEXT, '%@' INTEGER, '%@' TEXT)",TABLENAME,ID,NAME,AGE,ADDRESS];
        BOOL res = [db executeUpdate:sqlCreateTable];
        if (!res) {
            NSLog(@"error when creating db table");
        } else {
            NSLog(@"success to creating db table");
        }
        [db close];

    }
</code></pre>

<h5>添加数据：</h5>

<pre><code>if ([db open]) {
        NSString *insertSql1= [NSString stringWithFormat:
                              @"INSERT INTO '%@' ('%@', '%@', '%@') VALUES ('%@', '%@', '%@')",
                              TABLENAME, NAME, AGE, ADDRESS, @"张三", @"13", @"济南"];
        BOOL res = [db executeUpdate:insertSql1];
        NSString *insertSql2 = [NSString stringWithFormat:
                                @"INSERT INTO '%@' ('%@', '%@', '%@') VALUES ('%@', '%@', '%@')",
                                TABLENAME, NAME, AGE, ADDRESS, @"李四", @"12", @"济南"];
        BOOL res2 = [db executeUpdate:insertSql2];

    if (!res) {
        NSLog(@"error when insert db table");
    } else {
        NSLog(@"success to insert db table");
    }
    [db close];

}
</code></pre>

<h5>修改数据：</h5>

<pre><code>if ([db open]) {
        NSString *updateSql = [NSString stringWithFormat:
                              @"UPDATE '%@' SET '%@' = '%@' WHERE '%@' = '%@'",
                              TABLENAME,  AGE,  @"15" ,AGE,  @"13"];
        BOOL res = [db executeUpdate:updateSql];
        if (!res) {
            NSLog(@"error when update db table");
        } else {
            NSLog(@"success to update db table");
        }
        [db close];

    }
</code></pre>

<h5>删除数据：</h5>

<pre><code>if ([db open]) {

    NSString *deleteSql = [NSString stringWithFormat:
                          @"delete from %@ where %@ = '%@'",
                          TABLENAME, NAME, @"张三"];
    BOOL res = [db executeUpdate:deleteSql];

    if (!res) {
        NSLog(@"error when delete db table");
    } else {
        NSLog(@"success to delete db table");
    }
    [db close];

}
</code></pre>

<h5>数据库查询操作：</h5>

<p>查询操作使用了executeQuery，并涉及到FMResultSet。</p>

<pre><code>if ([db open]) {
        NSString * sql = [NSString stringWithFormat:
                          @"SELECT * FROM %@",TABLENAME];
        FMResultSet * rs = [db executeQuery:sql];
        while ([rs next]) {
            int Id = [rs intForColumn:ID];
            NSString * name = [rs stringForColumn:NAME];
            NSString * age = [rs stringForColumn:AGE];
            NSString * address = [rs stringForColumn:ADDRESS];
            NSLog(@"id = %d, name = %@, age = %@  address = %@", Id, name, age, address);
        }
        [db close];
    }
</code></pre>

<p>FMDB的FMResultSet提供了多个方法来获取不同类型的数据：</p>

<h3>数据库操作(使用FMDB)</h3>

<h5>数据库多线程操作：</h5>

<p>如果应用中使用了多线程操作数据库，那么就需要使用FMDatabaseQueue来保证线程安全了。 应用中不可在多个线程中共同使用一个FMDatabase对象操作数据库，这样会引起数据库数据混乱。 为了多线程操作数据库安全，FMDB使用了FMDatabaseQueue，使用FMDatabaseQueue很简单，首先用一个数据库文件地址来初使 化FMDatabaseQueue，然后就可以将一个闭包(block)传入inDatabase方法中。 在闭包中操作数据库，而不直接参与FMDatabase的管理。</p>

<pre><code>FMDatabaseQueue * queue = [FMDatabaseQueue databaseQueueWithPath:database_path];
    dispatch_queue_t q1 = dispatch_queue_create("queue1", NULL);
    dispatch_queue_t q2 = dispatch_queue_create("queue2", NULL);

dispatch_async(q1, ^{
    for (int i = 0; i &lt; 50; ++i) {
        [queue inDatabase:^(FMDatabase *db2) {

            NSString *insertSql1= [NSString stringWithFormat:
                                  @"INSERT INTO '%@' ('%@', '%@', '%@') VALUES (?, ?, ?)",
                                  TABLENAME, NAME, AGE, ADDRESS];

            NSString * name = [NSString stringWithFormat:@"jack %d", i];
            NSString * age = [NSString stringWithFormat:@"%d", 10+i];


            BOOL res = [db2 executeUpdate:insertSql1, name, age,@"济南"];
            if (!res) {
                NSLog(@"error to inster data: %@", name);
            } else {
                NSLog(@"succ to inster data: %@", name);
            }
        }];
    }
});

dispatch_async(q2, ^{
    for (int i = 0; i &lt; 50; ++i) {
        [queue inDatabase:^(FMDatabase *db2) {
            NSString *insertSql2= [NSString stringWithFormat:
                                  @"INSERT INTO '%@' ('%@', '%@', '%@') VALUES (?, ?, ?)",
                                  TABLENAME, NAME, AGE, ADDRESS];

            NSString * name = [NSString stringWithFormat:@"lilei %d", i];
            NSString * age = [NSString stringWithFormat:@"%d", 10+i];

            BOOL res = [db2 executeUpdate:insertSql2, name, age,@"北京"];
            if (!res) {
                NSLog(@"error to inster data: %@", name);
            } else {
                NSLog(@"succ to inster data: %@", name);
            }
        }];
    }
});
</code></pre>

<blockquote><p>注：FMDB最重要的就是下面两个方法的使用，</p></blockquote>

<ul>
<li>executeUpdate ：创建。修改，删除</li>
<li>executeQuery ：查询</li>
</ul>


<p>关键是SQL语句的使用</p>
</div>
  
  




| <a href="/blog/2014/11/25/fmdb/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/11/11/mknetworking/">MKNetWorking是撒？</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><p>常用框架比如：</p>

<ul>
<li>AFNetworking</li>
<li>ASIHttpRequest</li>
<li>SDWebImage</li>
<li>MKNetWorKit等。</li>
</ul>


<p>iOS5已出来这么久了，而ASIHttpRequest的作者已经申明不更新了，在iOS5环境下，其实还是有些问题的。</p>

<p>现在MKNetWorkKi吸取了ASIHttpRequest与AFNetWorking的优点，并加入了自己特有的功能。</p>

<p>下载：</p>

<pre><code>gitHub地址：https://github.com/MugunthKumar/MKNetworkKit.git

官方使用说明：http://blog.mugunthkumar.com/products/ios-framework-introducing-mknetworkkit/
</code></pre>

<p>github下载了该项目后，如果想运行其demo，一定要打开MKNetworkKit.xcworkspace该文件，若单独打开，则编译时会提示缺少libMKNetworkKit-iOS.a文件！！！</p>

<h6>安装：</h6>

<p>克隆下来之后把其中的 MKNetworkKit文件夹拖入项目，然后引入3个framework：</p>

<ul>
<li>CFNetwork.Framework</li>
<li>SystemConfiguration.framework</li>
<li><p>Security.framework</p>

<p> <img src="/images/MKNet001.png" title="Caption" ></p></li>
</ul>


<blockquote><p>注意：由于MKNetworkKit支持ARC，我们在项目中要开启ARC，不然会报错</p></blockquote>

<p><img src="/images/MKNet002.png" title="Caption" ></p>

<p>开启ARC自动内存控制机制：(开启ARC之后项目中所有的dealloc 、release 、autorelease都得注释掉)</p>

<p> <img src="/images/MKNet003.png" title="Caption" ></p>

<h6>使用方法：</h6>

<p>  在需要使用的地方导入：#import"MKNetworkKit.h"</p>

<h1>http方式：</h1>

<h3>GET请求：</h3>

<pre><code>MKNetworkEngine *engine = [[MKNetworkEngine alloc] initWithHostName:@"192.168.2.176:3000" customHeaderFields:nil];  
MKNetworkOperation *op = [engine operationWithPath:@"/index" params:nil httpMethod:@"GET" ssl:NO];  
[op addCompletionHandler:^(MKNetworkOperation *operation) {  
    NSLog(@"[operation responseData]--&gt;&gt;%@", [operation responseString]);  
}errorHandler:^(MKNetworkOperation *errorOp, NSError* err) {  
    NSLog(@"MKNetwork request error : %@", [err localizedDescription]);  
}];  
[engine enqueueOperation:op];  
</code></pre>

<h3>POST请求：</h3>

<pre><code>MKNetworkEngine *engine = [[MKNetworkEngine alloc] initWithHostName:@"192.168.2.176:3000" customHeaderFields:nil];  
NSMutableDictionary *dic = [[NSMutableDictionary alloc] init];  
[dic setValue:@"admin" forKey:@"username"];  
[dic setValue:@"123" forKey:@"password"];  

MKNetworkOperation *op = [engine operationWithPath:@"/login" params:dic httpMethod:@"POST"];  
[op addCompletionHandler:^(MKNetworkOperation *operation) {  
    NSLog(@"[operation responseData]--&gt;&gt;%@", [operation responseString]);  
}errorHandler:^(MKNetworkOperation *errorOp, NSError* err) {  
    NSLog(@"MKNetwork request error : %@", [err localizedDescription]);  
}];  
[engine enqueueOperation:op];  
</code></pre>

<h1>https方式：</h1>

<pre><code>#define serverHost               @"192.168.1.84:5558"  

- (NSDictionary *)getDataFromURL:(NSString *)Path params:(NSDictionary *)data  
{  
    NSLog(@"MKNetwork request URL:  %@%@   \n Data: %@",serverHost,Path,data);  

    __block NSDictionary *responseJSON;  
    __block NSError *error = nil;  
    MKNetworkEngine *engine = [[MKNetworkEngine alloc] initWithHostName:serverHost customHeaderFields:nil];  
    MKNetworkOperation *op = [engine operationWithPath:Path  params:data httpMethod:@"POST" ssl:YES];  
//    在请求中添加证书  
    op.clientCertificate = [[[NSBundle mainBundle] resourcePath] stringByAppendingPathComponent:@"client.p12"];  
    op.clientCertificatePassword = @"test";  
//   当服务器端证书不合法时是否继续访问  
    op.shouldContinueWithInvalidCertificate=YES;  
    [op addCompletionHandler:^(MKNetworkOperation *operation) {  
        NSLog(@"[operation responseData]--&gt;&gt;%@", [operation responseString]);  
        responseJSON=[NSJSONSerialization JSONObjectWithData:[operation responseData] options:kNilOptions error:&amp;error];  
        if(error) {  
            NSLog(@"JSONSerialization failed! - error: %@", error);  
        };  
        error=nil;  
    } errorHandler:^(MKNetworkOperation *errorOp, NSError* err) {  
        error=err;  
    }];  
    [engine enqueueOperation:op];  
    while(!error&amp;&amp;!responseJSON){}  
    if (error) {  
        NSLog(@"MKNetwork request error : %@", error);  
        return nil;  
    }  
    if(responseJSON){  
        NSLog(@"JSONSerialization successed! - responseJSON: %@", responseJSON);  
    }  
    return responseJSON;  
}  


    NSDictionary *params=[NSDictionary dictionaryWithObjectsAndKeys:@"admin",@"userName", @"123",@"password", nil];  
    NSDictionary *responseDict = [self getDataFromURL:@"/login" params:params];  
</code></pre>

<h3>下载文件：</h3>

<pre><code>+(MKNetworkOperation*) downloadFatAssFileFrom:(NSString*) remoteURL toFile:(NSString*) filePath {  
    MKNetworkEngine *engine = [[MKNetworkEngine alloc] initWithHostName:@"127.0.0.1:5558" customHeaderFields:nil];  
    MKNetworkOperation *op = [engine operationWithURLString:remoteURL  
                                                   params:nil  
                                               httpMethod:@"GET"];  

    [op addDownloadStream:[NSOutputStream outputStreamToFileAtPath:filePath  
                                                            append:YES]];  
    [engine enqueueOperation:op];  
    return op;  
}  
+(void)testDownload{  
    NSArray *paths = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES);  
    NSString *cachesDirectory = [paths objectAtIndex:0];  
    NSString *downloadPath = [cachesDirectory stringByAppendingPathComponent:@"DownloadedFile.pdf"];  

    MKNetworkOperation *downloadOperation=[HttpManager downloadFatAssFileFrom:@"http://127.0.0.1:5558/QQ"  
                                                                      toFile:downloadPath];  

    [downloadOperation onDownloadProgressChanged:^(double progress) {  
        //下载进度  
        NSLog(@"download progress: %.2f", progress*100.0);  
    }];  
    //事件处理  
    [downloadOperation addCompletionHandler:^(MKNetworkOperation* completedRequest) {  
        NSLog(@"download file finished!");  
    }  errorHandler:^(MKNetworkOperation *errorOp, NSError* err) {  
        NSLog(@"download file error: %@", err);  
    }];  
}  
</code></pre>

<h3>上传文件：</h3>

<pre><code>+(MKNetworkOperation*) uploadImageFromFile:(NSString*) filePath mimeType:(NSString *)fileType{  
    MKNetworkEngine *engine = [[MKNetworkEngine alloc] initWithHostName:@"127.0.0.1:5558" customHeaderFields:nil];  
    MKNetworkOperation *op = [engine operationWithPath:@"upload"  
                                              params:[NSDictionary dictionaryWithObjectsAndKeys:  
                                                      @"admin", @"username",  
                                                      @"123", @"password",nil]  
                                          httpMethod:@"POST"];  

    [op addFile:filePath forKey:@"media" mimeType:fileType];  

    // setFreezable uploads your images after connection is restored!  
    [op setFreezable:YES];  

    [op addCompletionHandler:^(MKNetworkOperation* completedOperation) {  

        NSString *responseString = [completedOperation responseString];  
        NSLog(@"server response: %@",responseString);  
    } errorHandler:^(MKNetworkOperation *errorOp, NSError* err){  

        NSLog(@"Upload file error: %@", err);  
    }];  

    [engine enqueueOperation:op];  

    return op;  
}  

+(void)testUpload{  
    NSString *uploadPath = [[[NSBundle mainBundle] resourcePath] stringByAppendingPathComponent:@"SampleImage.jpg"];  
    //    NSData *myData = [NSData dataWithContentsOfFile:uploadPath];  
    //    NSLog(@"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;%@",myData);  
    MKNetworkOperation *uploadOperation = [HttpManager uploadImageFromFile:uploadPath mimeType:@"jpg"];  
    [uploadOperation onUploadProgressChanged:^(double progress) {  
        //        上传进度  
        DLog(@"Upload file progress: %.2f", progress*100.0);  
    }];  
}  
</code></pre>

<h3>上传文件时服务器端程序(Node.Js):</h3>

<pre><code>var express = require('express')  
    ,fs=require('fs');  

var app = module.exports = express.createServer();  
// Configuration  
app.configure(function(){  
    app.use(express.bodyParser());  
    app.use(express.methodOverride());  
    app.use(app.router);  
});  
// Routes  
app.post('/upload', function(req, res) {  
    console.log(req);  
    var tmp_path = req.files.media.path; // 获得文件的临时路径  
    var target_path = './'+req.files.media.name;// 指定文件上传后的目录  
    fs.rename(tmp_path, target_path, function(err) { // 移动文件  
        if (err) throw err;  
        fs.unlink(tmp_path, function() {// 删除临时文件夹文件,  
            if (err) throw err;  
            res.send({server:'success'});  
            res.end();  
        });  
    });  
});  
app.listen(5558);  
console.log("Express server listening on port %d in %s mode", app.address().port, app.settings.env);  
</code></pre>
</div>
  
  




| <a href="/blog/2014/11/11/mknetworking/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/10/22/collectionview/">玩转CollectionView</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><p>实现步骤</p>

<h3>一、新建两个类</h3>

<p>1.继承自UIScrollView的子类，比如iCocosWaterflowView</p>

<ul>
<li>瀑布流显示控件，用来显示所有的瀑布流数据</li>
</ul>


<p>2.继承自UIView的子类，比如iCocosWaterflowViewCell</p>

<ul>
<li>代表着瀑布流数据中的一个单元（一个格子）</li>
</ul>


<p>3.总结</p>

<ul>
<li>iCocosWaterflowView和iCocosWaterflowViewCell的关系实际上类似于
UITableView和UITableViewCell的关系</li>
</ul>


<h3>二、设计iCocosWaterflowView的接口</h3>

<p>1.模仿UITableView的接口来设计</p>

<ul>
<li>设计一套数据源和代理方法</li>
</ul>


<h3>三、iCocosWaterflowView的实现</h3>

<p>1.reloadData</p>

<ul>
<li>作用：刷新数据</li>
<li>步骤：
1> 清空以前残余的数据
2> 计算所有新数据对应的frame</li>
</ul>


<p>2.layoutSubviews</p>

<ul>
<li>作用：显示和移除子控件</li>
<li><p>步骤：</p>

<ul>
<li><p>检测每一个数据对应的frame在不在屏幕上（用户能不能看见）</p></li>
<li><p>如果这个数据对应的frame在屏幕上：向数据源索要这个数据对应的cell，添加这个cell到iCocosWaterflowView中显示</p></li>
<li><p>如果这个数据对应的frame不在屏幕上：从iCocosWaterflowView中移除这个数据对应的cell，并将这个cell添加到缓存池中</p></li>
</ul>
</li>
</ul>


<p>View.h文件</p>

<pre><code>#import &lt;UIKit/UIKit.h&gt;

typedef enum {
    iCocosWaterflowViewMarginTypeTop,
    iCocosWaterflowViewMarginTypeBottom,
    iCocosWaterflowViewMarginTypeLeft,
    iCocosWaterflowViewMarginTypeRight,
    iCocosWaterflowViewMarginTypeColumn, // 每一列
    iCocosWaterflowViewMarginTypeRow, // 每一行
} iCocosWaterflowViewMarginType;

@class iCocosWaterflowView, iCocosWaterflowViewCell;

/**
 *  数据源方法
 */
@protocol iCocosWaterflowViewDataSource &lt;NSObject&gt;
@required
/**
 *  一共有多少个数据
 */
- (NSUInteger)numberOfCellsInWaterflowView:(iCocosWaterflowView *)waterflowView;
/**
 *  返回index位置对应的cell
 */
- (iCocosWaterflowViewCell *)waterflowView:(iCocosWaterflowView *)waterflowView cellAtIndex:(NSUInteger)index;

@optional
/**
 *  一共有多少列
 */
- (NSUInteger)numberOfColumnsInWaterflowView:(iCocosWaterflowView *)waterflowView;
@end

/**
 *  代理方法
 */
@protocol iCocosWaterflowViewDelegate &lt;UIScrollViewDelegate&gt;
@optional
/**
 *  第index位置cell对应的高度
 */
- (CGFloat)waterflowView:(iCocosWaterflowView *)waterflowView heightAtIndex:(NSUInteger)index;
/**
 *  选中第index位置的cell
 */
- (void)waterflowView:(iCocosWaterflowView *)waterflowView didSelectAtIndex:(NSUInteger)index;
/**
 *  返回间距
 */
- (CGFloat)waterflowView:(iCocosWaterflowView *)waterflowView marginForType:(iCocosWaterflowViewMarginType)type;
@end

/**
 *  瀑布流控件
 */
@interface iCocosWaterflowView : UIScrollView
/**
 *  数据源
 */
@property (nonatomic, weak) id&lt;iCocosWaterflowViewDataSource&gt; dataSource;
/**
 *  代理
 */
@property (nonatomic, weak) id&lt;iCocosWaterflowViewDelegate&gt; delegate;

/**
 *  刷新数据（只要调用这个方法，会重新向数据源和代理发送请求，请求数据）
 */
- (void)reloadData;

/**
 *  cell的宽度
 */
- (CGFloat)cellWidth;

/**
 *  根据标识去缓存池查找可循环利用的cell
 */
- (id)dequeueReusableCellWithIdentifier:(NSString *)identifier;
@end
</code></pre>

<p>复制代码</p>

<p>View.m文件</p>

<pre><code>#import "iCocosWaterflowView.h"
#import "iCocosWaterflowViewCell.h"

#define iCocosWaterflowViewDefaultCellH 70
#define iCocosWaterflowViewDefaultMargin 8
#define iCocosWaterflowViewDefaultNumberOfColumns 3

@interface iCocosWaterflowView()
/**
 *  所有cell的frame数据
 */
@property (nonatomic, strong) NSMutableArray *cellFrames;
/**
 *  正在展示的cell
 */
@property (nonatomic, strong) NSMutableDictionary *displayingCells;
/**
 *  缓存池（用Set，存放离开屏幕的cell）
 */
@property (nonatomic, strong) NSMutableSet *reusableCells;
@end

@implementation iCocosWaterflowView

#pragma mark - 初始化
- (NSMutableArray *)cellFrames
{
    if (_cellFrames == nil) {
        self.cellFrames = [NSMutableArray array];
    }
    return _cellFrames;
}

- (NSMutableDictionary *)displayingCells
{
    if (_displayingCells == nil) {
        self.displayingCells = [NSMutableDictionary dictionary];
    }
    return _displayingCells;
}

- (NSMutableSet *)reusableCells
{
    if (_reusableCells == nil) {
        self.reusableCells = [NSMutableSet set];
    }
    return _reusableCells;
}

- (id)initWithFrame:(CGRect)frame
{
    self = [super initWithFrame:frame];
    if (self) {

    }
    return self;
}

- (void)willMoveToSuperview:(UIView *)newSuperview
{
    [self reloadData];
}

#pragma mark - 公共接口
/**
 *  cell的宽度
 */
- (CGFloat)cellWidth
{
    // 总列数
    int numberOfColumns = [self numberOfColumns];
    CGFloat leftM = [self marginForType:iCocosWaterflowViewMarginTypeLeft];
    CGFloat rightM = [self marginForType:iCocosWaterflowViewMarginTypeRight];
    CGFloat columnM = [self marginForType:iCocosWaterflowViewMarginTypeColumn];
    return (self.bounds.size.width - leftM - rightM - (numberOfColumns - 1) * columnM) / numberOfColumns;
}

/**
 *  刷新数据
 */
- (void)reloadData
{
    // 清空之前的所有数据
    // 移除正在正在显示cell
    [self.displayingCells.allValues makeObjectsPerformSelector:@selector(removeFromSuperview)];
    [self.displayingCells removeAllObjects];
    [self.cellFrames removeAllObjects];
    [self.reusableCells removeAllObjects];

    // cell的总数
    int numberOfCells = [self.dataSource numberOfCellsInWaterflowView:self];

    // 总列数
    int numberOfColumns = [self numberOfColumns];

    // 间距
    CGFloat topM = [self marginForType:iCocosWaterflowViewMarginTypeTop];
    CGFloat bottomM = [self marginForType:iCocosWaterflowViewMarginTypeBottom];
    CGFloat leftM = [self marginForType:iCocosWaterflowViewMarginTypeLeft];
    CGFloat columnM = [self marginForType:iCocosWaterflowViewMarginTypeColumn];
    CGFloat rowM = [self marginForType:iCocosWaterflowViewMarginTypeRow];

    // cell的宽度
    CGFloat cellW = [self cellWidth];

    // 用一个C语言数组存放所有列的最大Y值
    CGFloat maxYOfColumns[numberOfColumns];
    for (int i = 0; i&lt;numberOfColumns; i++) {
        maxYOfColumns[i] = 0.0;
    }

    // 计算所有cell的frame
    for (int i = 0; i&lt;numberOfCells; i++) {
        // cell处在第几列(最短的一列)
        NSUInteger cellColumn = 0;
        // cell所处那列的最大Y值(最短那一列的最大Y值)
        CGFloat maxYOfCellColumn = maxYOfColumns[cellColumn];
        // 求出最短的一列
        for (int j = 1; j&lt;numberOfColumns; j++) {
            if (maxYOfColumns[j] &lt; maxYOfCellColumn) {
                cellColumn = j;
                maxYOfCellColumn = maxYOfColumns[j];
            }
        }

        // 询问代理i位置的高度
        CGFloat cellH = [self heightAtIndex:i];

        // cell的位置
        CGFloat cellX = leftM + cellColumn * (cellW + columnM);
        CGFloat cellY = 0;
        if (maxYOfCellColumn == 0.0) { // 首行
            cellY = topM;
        } else {
            cellY = maxYOfCellColumn + rowM;
        }

        // 添加frame到数组中
        CGRect cellFrame = CGRectMake(cellX, cellY, cellW, cellH);
        [self.cellFrames addObject:[NSValue valueWithCGRect:cellFrame]];

        // 更新最短那一列的最大Y值
        maxYOfColumns[cellColumn] = CGRectGetMaxY(cellFrame);
    }

    // 设置contentSize
    CGFloat contentH = maxYOfColumns[0];
    for (int j = 1; j&lt;numberOfColumns; j++) {
        if (maxYOfColumns[j] &gt; contentH) {
            contentH = maxYOfColumns[j];
        }
    }
    contentH += bottomM;
    self.contentSize = CGSizeMake(0, contentH);
}

/**
 *  当UIScrollView滚动的时候也会调用这个方法
 */
- (void)layoutSubviews
{
    [super layoutSubviews];

    // 向数据源索要对应位置的cell
    NSUInteger numberOfCells = self.cellFrames.count;
    for (int i = 0; i&lt;numberOfCells; i++) {
        // 取出i位置的frame
        CGRect cellFrame = [self.cellFrames[i] CGRectValue];

        // 优先从字典中取出i位置的cell
        iCocosWaterflowViewCell *cell = self.displayingCells[@(i)];

        // 判断i位置对应的frame在不在屏幕上（能否看见）
        if ([self isInScreen:cellFrame]) { // 在屏幕上
            if (cell == nil) {
                cell = [self.dataSource waterflowView:self cellAtIndex:i];
                cell.frame = cellFrame;
                [self addSubview:cell];

                // 存放到字典中
                self.displayingCells[@(i)] = cell;
            }
        } else {  // 不在屏幕上
            if (cell) {
                // 从scrollView和字典中移除
                [cell removeFromSuperview];
                [self.displayingCells removeObjectForKey:@(i)];

                // 存放进缓存池
                [self.reusableCells addObject:cell];
            }
        }
    }
}

- (id)dequeueReusableCellWithIdentifier:(NSString *)identifier
{
    __block iCocosWaterflowViewCell *reusableCell = nil;

    [self.reusableCells enumerateObjectsUsingBlock:^(iCocosWaterflowViewCell *cell, BOOL *stop) {
        if ([cell.identifier isEqualToString:identifier]) {
            reusableCell = cell;
            *stop = YES;
        }
    }];

    if (reusableCell) { // 从缓存池中移除
        [self.reusableCells removeObject:reusableCell];
    }
    return reusableCell;
}

#pragma mark - 私有方法
/**
 *  判断一个frame有无显示在屏幕上
 */
- (BOOL)isInScreen:(CGRect)frame
{
    return (CGRectGetMaxY(frame) &gt; self.contentOffset.y) &amp;&amp;
    (CGRectGetMinY(frame) &lt; self.contentOffset.y + self.bounds.size.height);
}

/**
 *  间距
 */
- (CGFloat)marginForType:(iCocosWaterflowViewMarginType)type
{
    if ([self.delegate respondsToSelector:@selector(waterflowView:marginForType:)]) {
        return [self.delegate waterflowView:self marginForType:type];
    } else {
        return iCocosWaterflowViewDefaultMargin;
    }
}
/**
 *  总列数
 */
- (NSUInteger)numberOfColumns
{
    if ([self.dataSource respondsToSelector:@selector(numberOfColumnsInWaterflowView:)]) {
        return [self.dataSource numberOfColumnsInWaterflowView:self];
    } else {
        return iCocosWaterflowViewDefaultNumberOfColumns;
    }
}
/**
 *  index位置对应的高度
 */
- (CGFloat)heightAtIndex:(NSUInteger)index
{
    if ([self.delegate respondsToSelector:@selector(waterflowView:heightAtIndex:)]) {
        return [self.delegate waterflowView:self heightAtIndex:index];
    } else {
        return iCocosWaterflowViewDefaultCellH;
    }
}

#pragma mark - 事件处理
- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event
{
    if (![self.delegate respondsToSelector:@selector(waterflowView:didSelectAtIndex:)]) return;

    // 获得触摸点
    UITouch *touch = [touches anyObject];
    //    CGPoint point = [touch locationInView:touch.view];
    CGPoint point = [touch locationInView:self];

    __block NSNumber *selectIndex = nil;
    [self.displayingCells enumerateKeysAndObjectsUsingBlock:^(id key, iCocosWaterflowViewCell *cell, BOOL *stop) {
        if (CGRectContainsPoint(cell.frame, point)) {
            selectIndex = key;
            *stop = YES;
        }
    }];

    if (selectIndex) {
        [self.delegate waterflowView:self didSelectAtIndex:selectIndex.unsignedIntegerValue];
    }
}
</code></pre>

<p>复制代码</p>

<p>Cell.h文件</p>

<pre><code> #import &lt;UIKit/UIKit.h&gt;

 @interface iCocosWaterflowViewCell : UIView
 @property (nonatomic, copy) NSString *identifier;
 @end
</code></pre>

<p>使用方法：</p>

<p>1:新建一个Cell模型</p>

<pre><code>#import &lt;Foundation/Foundation.h&gt;

@interface iCocosShop : NSObject
@property (nonatomic, assign) CGFloat w;
@property (nonatomic, assign) CGFloat h;
@property (nonatomic, copy) NSString *img;
@property (nonatomic, copy) NSString *price;
@end
</code></pre>

<p>2：定义一个集成自上面的Cell的Cell</p>

<pre><code>#import "iCocosWaterflowViewCell.h"
@class iCocosWaterflowView, iCocosShop;

@interface iCocosShopCell : iCocosWaterflowViewCell
+ (instancetype)cellWithWaterflowView:(iCocosWaterflowView *)waterflowView;

@property (nonatomic, strong) iCocosShop *shop;
@end
</code></pre>

<p>实现这个Cell：</p>

<pre><code>#import "iCocosShopCell.h"
#import "iCocosWaterflowView.h"
#import "UIImageView+WebCache.h"
#import "iCocosShop.h"

@interface iCocosShopCell()
@property (weak, nonatomic) UIImageView *imageView;
@property (weak, nonatomic) UILabel *priceLabel;
@end

@implementation iCocosShopCell


+ (instancetype)cellWithWaterflowView:(iCocosWaterflowView *)waterflowView
{
    static NSString *ID = @"SHOP";
    iCocosShopCell *cell = [waterflowView dequeueReusableCellWithIdentifier:ID];
    if (cell == nil) {
        cell = [[iCocosShopCell alloc] init];
        cell.identifier = ID;
    }
    return cell;
}

- (id)initWithFrame:(CGRect)frame
{
    self = [super initWithFrame:frame];
    if (self) {

        UIImageView *imageView = [[UIImageView alloc] init];
        [self addSubview:imageView];
        self.imageView = imageView;

        UILabel *priceLabel = [[UILabel alloc] init];
        priceLabel.backgroundColor = [UIColor colorWithRed:0 green:0 blue:0 alpha:0.3];
        priceLabel.textAlignment = NSTextAlignmentCenter;
        priceLabel.textColor = [UIColor whiteColor];
        [self addSubview:priceLabel];
        self.priceLabel = priceLabel;
    }
    return self;
}

- (void)setShop:(iCocosShop *)shop
{
    _shop = shop;

    self.priceLabel.text = shop.price;
    [self.imageView sd_setImageWithURL:[NSURL URLWithString:shop.img] placeholderImage:[UIImage imageNamed:@"loading"]];
}

- (void)layoutSubviews
{
    [super layoutSubviews];

    self.imageView.frame = self.bounds;

    CGFloat priceX = 0;
    CGFloat priceH = 25;
    CGFloat priceY = self.bounds.size.height - priceH;
    CGFloat priceW = self.bounds.size.width;
    self.priceLabel.frame = CGRectMake(priceX, priceY, priceW, priceH);
}
</code></pre>

<p>3:在控制器中直接使用：</p>

<pre><code>    #import "iCocosShopsViewController.h"
    #import "iCocosShopCell.h"
    #import "iCocosWaterflowView.h"
    #import "iCocosShop.h"
    #import "MJExtension.h"
    #import "MJRefresh.h"

    @interface iCocosShopsViewController ()&lt;iCocosWaterflowViewDataSource, iCocosWaterflowViewDelegate&gt;
    @property (nonatomic, strong) NSMutableArray *shops;
    @property (nonatomic, weak) iCocosWaterflowView *waterflowView;
    @end

    @implementation iCocosShopsViewController

    - (NSMutableArray *)shops
    {
        if (_shops == nil) {
            self.shops = [NSMutableArray array];
        }
        return _shops;
    }

    - (void)viewDidLoad
    {
        [super viewDidLoad];

        // 0.初始化数据
        NSArray *newShops = [iCocosShop objectArrayWithFilename:@"2.plist"];
        [self.shops addObjectsFromArray:newShops];

        // 1.瀑布流控件
        iCocosWaterflowView *waterflowView = [[iCocosWaterflowView alloc] init];
        waterflowView.backgroundColor = [UIColor redColor];
        // 跟随着父控件的尺寸而自动伸缩
        waterflowView.autoresizingMask = UIViewAutoresizingFlexibleHeight | UIViewAutoresizingFlexibleWidth;
        waterflowView.frame = self.view.bounds;
        waterflowView.dataSource = self;
        waterflowView.delegate = self;
        [self.view addSubview:waterflowView];
        self.waterflowView = waterflowView;

        // 2.继承刷新控件
    //    [waterflowView addFooterWithCallback:^{
    //        NSLog(@"进入上拉加载状态");
    //    }];

    //    [waterflowView addHeaderWithCallback:^{
    //        NSLog(@"进入下拉加载状态");
        //    }];

        [waterflowView addHeaderWithTarget:self action:@selector(loadNewShops)];
        [waterflowView addFooterWithTarget:self action:@selector(loadMoreShops)];
    }

    - (void)didRotateFromInterfaceOrientation:(UIInterfaceOrientation)fromInterfaceOrientation
    {
    //    NSLog(@"屏幕旋转完毕");
        [self.waterflowView reloadData];
    }

    - (void)loadNewShops
    {
        static dispatch_once_t onceToken;
        dispatch_once(&amp;onceToken, ^{
            // 加载1.plist
            NSArray *newShops = [iCocosShop objectArrayWithFilename:@"1.plist"];
            [self.shops insertObjects:newShops atIndexes:[NSIndexSet indexSetWithIndexesInRange:NSMakeRange(0, newShops.count)]];
        });

        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
            // 刷新瀑布流控件
            [self.waterflowView reloadData];

            // 停止刷新
            [self.waterflowView headerEndRefreshing];
        });
    }

    - (void)loadMoreShops
    {
        static dispatch_once_t onceToken;
        dispatch_once(&amp;onceToken, ^{
            // 加载3.plist
            NSArray *newShops = [iCocosShop objectArrayWithFilename:@"3.plist"];
            [self.shops addObjectsFromArray:newShops];
        });

        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{

            // 刷新瀑布流控件
            [self.waterflowView reloadData];

            // 停止刷新
            [self.waterflowView footerEndRefreshing];
        });
    }

    #pragma mark - 数据源方法
    - (NSUInteger)numberOfCellsInWaterflowView:(iCocosWaterflowView *)waterflowView
    {
        return self.shops.count;
    }

    - (iCocosWaterflowViewCell *)waterflowView:(iCocosWaterflowView *)waterflowView cellAtIndex:(NSUInteger)index
    {
        iCocosShopCell *cell = [iCocosShopCell cellWithWaterflowView:waterflowView];

        cell.shop = self.shops[index];

        return cell;
    }

    - (NSUInteger)numberOfColumnsInWaterflowView:(iCocosWaterflowView *)waterflowView
    {
        if (UIInterfaceOrientationIsPortrait(self.interfaceOrientation)) {
            // 竖屏
            return 3;
        } else {
            return 5;
        }
    }

    #pragma mark - 代理方法
    - (CGFloat)waterflowView:(iCocosWaterflowView *)waterflowView heightAtIndex:(NSUInteger)index
    {
        iCocosShop *shop = self.shops[index];
        // 根据cell的宽度 和 图片的宽高比 算出 cell的高度
        return waterflowView.cellWidth * shop.h / shop.w;
    }
</code></pre>

<p>注：这里还需要引入第三方库和相应的工具类</p>
</div>
  
  




| <a href="/blog/2014/10/22/collectionview/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/08/28/protocol/">不平的条约（协议）</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><p>协议声明类需要实现的的方法，为不同的类提供公用方法，一个类可以有多个协议，但只能有一个父类，即单继承。它类似java中的接口。</p>

<h2>正式协议（formal protocol）</h2>

<p>声明正式协议使用@protocol指令，以@end结尾。</p>

<pre><code>@protocol MyXMLSupport
- initFromXMLRepresentation:(NSXMLElement *)XMLElement;
- (NSXMLElement *)XMLRepresentation;
@end
</code></pre>

<p>可以在协议声明中使用@optional和@required指令来指定协议中的方法是否必须要实现。如果没有为方法指定任何指令，@required是协议中默认的指令。</p>

<pre><code>@protocol MyProtocol
- (void)requiredMethod;
@optional
- (void)anOptionalMethod;
- (void)anotherOptionalMethod;
@required
- (void)anotherRequiredMethod; 
@end
</code></pre>

<h2>非正式协议（informal protocol）</h2>

<p>非正式协议通过分类（category）来实现，不过在Mac OS X v10.6+中可以在协议中通过@optional指令来取代这个别扭的方案。</p>

<pre><code>@interface NSObject ( MyXMLSupport )
- initFromXMLRepresentation:(NSXMLElement *)XMLElement;
- (NSXMLElement *)XMLRepresentation;
@end
</code></pre>

<h2>协议对象（protocol objects）</h2>

<p>Objective C中定义了协议对象，通过@protocol指令可以获取protocol实例。</p>

<pre><code>Protocol *myXMLSupportProtocol = @protocol(MyXMLSupport);
</code></pre>

<p>当类采用（adopt）接口或在代码中通过@protocol（XX）指令时，编译器会创建protocol实例。</p>

<h2>协议的使用</h2>

<p>协议的采用（adopt）和声明父类类似，可以在父类后面用尖括号将要采用的协议括起来，多个协议用逗号（comma）隔开。
类和分类都可以采用协议。</p>

<pre><code>@interface ClassName : ItsSuperclass &lt; protocol list &gt;
@interface ClassName ( CategoryName ) &lt; protocol list &gt;
</code></pre>

<p>在接口部分不需要重新声明协议中的方法。但在类的实现部分需要实现协议中的@required方法。</p>

<h2>是否遵循某协议</h2>

<p>检查一个类或实例对象是否遵循某协议可以用NSObject类的类方法conformsToProtocol和实例方法conformsToProtocol</p>

<pre><code>if ( ! [receiver conformsToProtocol:@protocol(MyXMLSupport)]  ) {
    // Object does not conform to MyXMLSupport protocol
    // If you are expecting receiver to implement methods declared in the
    //  MyXMLSupport protocol, this is probably an error
}
</code></pre>

<h2>使用协议进行类型声明</h2>

<p>声明对象类型时可以在声明中指定协议，这样可以让编译器在编译阶段强制对象遵循某协议。</p>

<pre><code>- (id &lt;Formatting&gt;)formattingService;
id &lt;MyXMLSupport&gt; anObject;
</code></pre>

<h2>协议的继承</h2>

<p>协议也可以继承或采用其他的协议，需要采用某协议的类必须实现该协议的required方法和该协议继承的协议中的required方法。
    @protocol ProtocolName &lt; protocol list ></p>

<h2>在协议中使用其它的协议</h2>

<p>在一个大型的应用中，你可能会遇到如下代码：</p>

<pre><code>#import "B.h"
@protocol A
- foo:(id &lt;B&gt;)anObject;
@end


#import "A.h"
@protocol B
- bar:(id &lt;A&gt;)anObject;
@end
</code></pre>

<p>A、B协议在互相引用，如果这里都用import来引入协议文件，编译器会报错。需要改为如下方式：</p>

<pre><code>@protocol B;
@protocol A
- foo:(id &lt;B&gt;)anObject;
@end
</code></pre>

<p>@protocol B只是简单告诉编译器B是一个协议，不会引入B的文件。
NScoder  和 NScoding 有将自己定义的类的对象写入磁盘的作用
NScoding 是一个协议，主要有下面两个方法</p>

<pre><code>-(id)initWithCoder:(NSCoder *)coder;//从coder中读取数据，保存到相应的变量中，即反序列化数据
-(void)encodeWithCoder:(NSCoder *)coder;// 读取实例变量，并把这些数据写到coder中去。序列化数据
</code></pre>

<p>NSCoder 是一个抽象类，抽象类不能被实例话，只能提供一些想让子类继承的方法。</p>

<p>NSKeyedUnarchiver   从二进制流读取对象。
NSKeyedArchiver       把对象写到二进制流中去。
4一个简单的例子</p>

<p>一般是在自己定义的类中需要在.h 文件中加入<NScoding></p>

<p>在.m 文件众实现他的的两个代理方法，这个代理方法将会被自动调用</p>

<pre><code>1 - (void)encodeWithCoder:(NSCoder *)aCoder 
2 {
3     [aCoder encodeObject:self.InsureSolutionID forKey:@"personName"];
4     [aCoder encodeObject:self.InsureSolutionName forKey:@"personAge"];
5 }
</code></pre>

<p>encodeWithCoder 可以调用的方法：</p>

<p>1）、如果是类 就用encodeObject: forKey：</p>

<p>2）、如果是普通的数据类型就用   eg、encodeInt： forKey：</p>

<pre><code>- (id)initWithCoder:(NSCoder *)aDecoder 

{
    self = [super init];
    if (self) 
    {
        self.InsureSolutionID = [aDecoder decodeObjectForKey:@"personName"];
        self.InsureSolutionName = [aDecoder decodeObjectForKey:@"personAge"];
    }
    return self;
}
</code></pre>

<p>initWithCoder 可以调用的方法：</p>

<p>1）、如果是类 就用decodeObjectForKey：</p>

<p>2）、如果是普通的数据类型就用   eg、decodeIntForKey：</p>

<p>以下是对该类序列化和反序列化。</p>

<pre><code>1 NSData *archiveCarPriceData = [NSKeyedArchiver archivedDataWithRootObject:self.DataArray];
2     [[NSUserDefaults standardUserDefaults] setObject:archiveCarPriceData forKey:@"DataArray"];
3  
4 
5  NSData *myEncodedObject = [[NSUserDefaults standardUserDefaults] objectForKey:@"DataArray"];
6      self.dataList = [NSKeyedUnarchiver unarchiveObjectWithData: myEncodedObject];
</code></pre>

<p>nscopying协议蛮好用的。</p>

<p>一个方法：
zone是一个内存区域，通常object，指向指针，所以copywithzone重要。</p>

<pre><code>- (id)copyWithZone:(NSZone *)zone

{

    FourLines *copy = [[[self class] allocWithZone:zone] init];

    copy.field1 = [self.field1 copyWithZone:zone];

    copy.field2 = [self.field2 copyWithZone:zone];

    copy.field3 = [self.field3 copyWithZone:zone];

    copy.field4 = [self.field4 copyWithZone:zone];

    return copy;

}
</code></pre>
</div>
  
  




| <a href="/blog/2014/08/28/protocol/#comments">更多评论</a>

    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/6">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/4">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
    <h1>文章分类</h1>
    <ul id="categories">
        <li class='category'><a href='/blog/categories/全栈工程师必备/'>全栈工程师必备 (2)</a></li>
<li class='category'><a href='/blog/categories/底层开发/'>底层开发 (4)</a></li>
<li class='category'><a href='/blog/categories/开发工具/'>开发工具 (2)</a></li>
<li class='category'><a href='/blog/categories/性能相关/'>性能相关 (7)</a></li>
<li class='category'><a href='/blog/categories/性能问题/'>性能问题 (4)</a></li>
<li class='category'><a href='/blog/categories/新技术/'>新技术 (1)</a></li>
<li class='category'><a href='/blog/categories/欢迎来到ios梦工厂/'>欢迎来到ios梦工厂 (1)</a></li>
<li class='category'><a href='/blog/categories/程序员必备/'>程序员必备 (7)</a></li>
<li class='category'><a href='/blog/categories/适配问题/'>适配问题 (1)</a></li>
<li class='category'><a href='/blog/categories/面试总结-技术/'>面试总结＋技术 (1)</a></li>
<li class='category'><a href='/blog/categories/面试汇总/'>面试汇总 (1)</a></li>
<li class='category'><a href='/blog/categories/项目实战/'>项目实战 (17)</a></li>
<li class='category'><a href='/blog/categories/高级开发/'>高级开发 (25)</a></li>

    </ul>
</section><section>
  <h1>最新文章</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/12/11/anquan/">安全机制</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/12/11/java/">爬虫必备-java抓包</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/12/11/pa-chong-bi-bei-phthonzhua-bao/">爬虫必备-Phthon抓包</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/12/11/zhengze/">爬虫必备-正则表达式抓包</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/12/11/qinghuaci/">爬虫必备-青花瓷</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/al1020119">@al1020119</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'al1020119',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>




<section>
<h1>扫一扫<abbr title="The word '扫一扫' is a registered trademark of DENSO WAVE INCORPORATED. It applies only for the word '扫一扫', not for image.">&trade;</abbr></h1>
<a href="http://al1020119.github.io/posts/5/index.html"><img src="http://chart.apis.google.com/chart?chs=150x150&cht=qr&chld=|0&chco=165B94&chl=http://al1020119.github.io/posts/5/index.html" alt="post-qrcode"></a></section>
<section>
    <h1>访客统计</h1>
    <br/>
    <a href="http://s07.flagcounter.com/more/2SH"><img src="http://s07.flagcounter.com/count/2SH/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_1/flags_0/" alt="Flag Counter" border="0"></a>
</section><section>
    <h1>新浪微博</h1>
    <ul id="weibo">
        <li>
            
            <!-- 在此插入获得的微博秀代码 -->
            <iframe width="100%" height="550" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=550&fansRow=2&ptype=1&speed=0&skin=1&isTitle=1&noborder=1&isWeibo=1&isFans=1&uid=3288975567&verifier=20ffcedd&dpc=1"></iframe>
            
        </li>
    </ul>
</section>
  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - iCocos -
<span class="credit">Preview in <a href="http://al1020119.github.io">[曹#黎]</a></span>
</p>

</footer>
  






<!--
--->



</body>
</html>
