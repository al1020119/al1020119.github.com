
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>iOS梦工厂</title>
  <meta name="author" content="iCocos">

  
  <meta name="description" content="你是怎么退出键盘的？ ordinal iOS开发中键盘的退出方法用很多中我们应该在合适的地方使用合适的方法才能更好的提高开发的效率和应用的性能 下面给大家介绍几种最常用的键盘退出方法，基本上iOS开发中的键盘退出方法都是这几种中的一种活着几种。 一：textView // &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://al1020119.github.io/posts/6/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="iOS梦工厂" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//libs.baidu.com/jquery/1.7.2/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <script>
function addBlankTargetForLinks () {
    $('a[href^="http"]').each(function(){
                              $(this).attr('target', '_blank');
                              });
}
$(document).bind('DOMNodeInserted', function(event) {
             addBlankTargetForLinks();
             });
</script>
  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">iOS梦工厂</a></h1>
  
    <h2>不战胜自己，何以改变未来！</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="al1020119.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">首页</a></li>
  <li><a href="/blog/archives">归档</a></li>
  <li><a href="/icocos">iCocos</a></li>
  <li><a href="/other">其他</a></li>
  <li><a href="/about">关于</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/07/12/popkeyboard/">你是怎么退出键盘的？</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><p>iOS开发中键盘的退出方法用很多中我们应该在合适的地方使用合适的方法才能更好的提高开发的效率和应用的性能</p>

<p>下面给大家介绍几种最常用的键盘退出方法，基本上iOS开发中的键盘退出方法都是这几种中的一种活着几种。</p>

<p>一：textView</p>

<pre><code>//通过委托来实现放弃第一响应者
#pragma mark - UITextView Delegate  Method
-(BOOL)textView:(UITextView *)textView shouldChangeTextInRange:(NSRange)range replacementText:(NSString *)text
{
    if([text isEqualToString:@"\n"]) {
        [textView resignFirstResponder];
        return NO;
    }
    return YES;
}
</code></pre>

<p>二：textFiled</p>

<pre><code>//通过委托来实现放弃第一响应者
#pragma mark - UITextField Delegate Method
- (BOOL)textFieldShouldReturn:(UITextField *)textField
{
    [textField resignFirstResponder];
    return YES;
}
</code></pre>

<p>三：触摸屏幕</p>

<pre><code>1 ／／所有的界面都可以实现
2 -(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event
3 {
4     [self.view endEditing:YES];
5 }
</code></pre>

<p>四：ScrollView拖拽</p>

<pre><code> 1 -(void)scrollViewWillBeginDragging:(UIScrollView *)scrollView 
 2 { 
 3      [self.view endEditing:YES]; 
 4 } 
</code></pre>

<blockquote><p>注：结合使用endEditing和resignFirstResponder</p></blockquote>

<p>五：通知方式</p>

<p>注册与移除通知</p>

<pre><code>-(void) viewWillAppear:(BOOL)animated {

    //注册键盘出现通知
    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector (keyboardDidShow:)
                                                 name: UIKeyboardDidShowNotification object:nil];
    //注册键盘隐藏通知
    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector (keyboardDidHide:)
                                                 name: UIKeyboardDidHideNotification object:nil];
    [super viewWillAppear:animated];
}


-(void) viewWillDisappear:(BOOL)animated {
    //解除键盘出现通知
    [[NSNotificationCenter defaultCenter] removeObserver:self
                                                    name: UIKeyboardDidShowNotification object:nil];
    //解除键盘隐藏通知
    [[NSNotificationCenter defaultCenter] removeObserver:self
                                                    name: UIKeyboardDidHideNotification object:nil];

    [super viewWillDisappear:animated];
}
</code></pre>

<p>实现通知的方法：</p>

<pre><code>-(void) keyboardDidShow: (NSNotification *)notif {

    if (keyboardVisible) {//键盘已经出现要忽略通知
        return;
    }
    // 获得键盘尺寸
    NSDictionary* info = [notif userInfo];
    NSValue* aValue = [info objectForKey:UIKeyboardFrameEndUserInfoKey];
    CGSize keyboardSize = [aValue CGRectValue].size;

    //重新定义ScrollView的尺寸
    CGRect viewFrame = self.scrollView.frame;
    viewFrame.size.height -= (keyboardSize.height);
    self.scrollView.frame = viewFrame;

    //滚动到当前文本框
    CGRect textFieldRect = [self.textField frame];
    [self.scrollView scrollRectToVisible:textFieldRect animated:YES];

    keyboardVisible = YES;
}

-(void) keyboardDidHide: (NSNotification *)notif {

    NSDictionary* info = [notif userInfo];
    NSValue* aValue = [info objectForKey:UIKeyboardFrameEndUserInfoKey];
    CGSize keyboardSize = [aValue CGRectValue].size;

    CGRect viewFrame = self.scrollView.frame;
    viewFrame.size.height += keyboardSize.height;
    self.scrollView.frame = viewFrame;

    if (!keyboardVisible) {
        return;
    }

    keyboardVisible = NO;

}
</code></pre>
</div>
  
  




| <a href="/blog/2014/07/12/popkeyboard/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/25/data%20model/">数据与模型</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><p>/******************************************************************************/</p>

<h3>一:简单plist读取</h3>

<p>1:定义一个数组用来保存读取出来的plist数据</p>

<pre><code> 1 @property (nonatomic, strong) NSArray *shops; 
</code></pre>

<p>2:使用懒加载的方式加载plist文件，并且放到数组中</p>

<pre><code>// 懒加载

// 1.第一次用到时再去加载

// 2.只会加载一次

- (NSArray *)shops

{

    if (_shops == nil) {

        // 获得plist文件的全路径

        NSString *file = [[NSBundle mainBundle] pathForResource:@"shops.plist" ofType:nil];



        // 从plist文件中加载一个数组对象

        _shops = [NSArray arrayWithContentsOfFile:file];

    }

    return _shops;

}
</code></pre>

<p>3:使用数组中的数据</p>

<pre><code>// 设置数据

1 NSDictionary *shop = self.shops[index];
2 
3 iconView.image = [UIImage imageNamed:shop[@"icon"]];
4 
5 nameLabel.text = shop[@"name"];
</code></pre>

<p>/******************************************************************************/</p>

<h3>二：字典转模型</h3>

<h6>1:创建一个model类并且在里面创建对应的模型属性</h6>

<pre><code>/** 名字 */

 1 @property (nonatomic, strong) NSString *name; 

/** 图标 */

 1 @property (nonatomic, strong) NSString *icon; 
</code></pre>

<h6>2:定义一个数组用来保存读取出来的plist数据</h6>

<pre><code> 1 @property (nonatomic, strong) NSMutableArray *shops; 
</code></pre>

<h6>3:使用懒加载的方式加载plist文件，并且放到模型中</h6>

<pre><code>// 懒加载

// 1.第一次用到时再去加载

// 2.只会加载一次

- (NSMutableArray *)shops

{

    if (_shops == nil) {

        // 创建"模型数组"

        _shops = [NSMutableArray array];



        // 获得plist文件的全路径

        NSString *file = [[NSBundle mainBundle] pathForResource:@"shops.plist" ofType:nil];



        // 从plist文件中加载一个数组对象(这个数组中存放的都是NSDictionary对象)

        NSArray *dictArray = [NSArray arrayWithContentsOfFile:file];



        // 将 “字典数组” 转换为 “模型数据”

        for (NSDictionary *dict in dictArray) { // 遍历每一个字典

            // 将 “字典” 转换为 “模型”

            Shop *shop = [[Shop alloc] init];

            shop.name = dict[@"name"];

            shop.icon = dict[@"icon"];



            // 将 “模型” 添加到 “模型数组中”

            [_shops addObject:shop];

        }

    }

    return _shops;

}
</code></pre>

<p>4:使用模型中的数据</p>

<pre><code>// 设置数据 
Shop *shop = self.shops[index];

iconView.image = [UIImage imageNamed:shop.icon];

nameLabel.text = shop.name;
</code></pre>

<p>/******************************************************************************/</p>

<h3>三：字典转模型封装</h3>

<h6>1:创建一个model类并且在里面创建对应的模型属性，定义两个模型方法</h6>

<pre><code>/** 名字 */

@property (nonatomic, copy) NSString *name;

/** 图标 */

@property (nonatomic, copy) NSString *icon;



/** 通过一个字典来初始化模型对象 */

- (instancetype)initWithDict:(NSDictionary *)dict;



/** 通过一个字典来创建模型对象 */

+ (instancetype)shopWithDict:(NSDictionary *)dict;
</code></pre>

<h6>2:模型方法的实现</h6>

<pre><code>- (instancetype)initWithDict:(NSDictionary *)dict

{

    if (self = [super init]) {

        self.name = dict[@"name"];

        self.icon = dict[@"icon"];

    }

    return self;

}



+ (instancetype)shopWithDict:(NSDictionary *)dict

{

    // 这里要用self

    return [[self alloc] initWithDict:dict];

} 
</code></pre>

<h6>3:定义一个数组用来保存读取出来的plist数据</h6>

<pre><code> 1 @property (nonatomic, strong) NSMutableArray *shops; 
</code></pre>

<h6>4:使用懒加载的方式加载plist文件，并且放到模型中</h6>

<pre><code>// 懒加载

// 1.第一次用到时再去加载

// 2.只会加载一次
- (NSMutableArray *)shops

{

    if (_shops == nil) {

        // 创建"模型数组"

        _shops = [NSMutableArray array];



        // 获得plist文件的全路径

        NSString *file = [[NSBundle mainBundle] pathForResource:@"shops.plist" ofType:nil];



        // 从plist文件中加载一个数组对象(这个数组中存放的都是NSDictionary对象)

        NSArray *dictArray = [NSArray arrayWithContentsOfFile:file];



        // 将 “字典数组” 转换为 “模型数据”

        for (NSDictionary *dict in dictArray) { // 遍历每一个字典

            // 将 “字典” 转换为 “模型”

            XMGShop *shop = [XMGShop shopWithDict:dict];



            // 将 “模型” 添加到 “模型数组中”

            [_shops addObject:shop];

        }

    }

    return _shops;

}
</code></pre>

<h6>5:使用模型中的数据</h6>

<pre><code>// 设置数据

XMGShop *shop = self.shops[index];

iconView.image = [UIImage imageNamed:shop.icon];

nameLabel.text = shop.name;
</code></pre>

<p>/******************************************************************************/</p>

<h3>四：自定义View</h3>

<h6>1:创建一个model类并且在里面创建对应的模型属性，定义两个模型方法</h6>

<pre><code>/** 名字 */

@property (nonatomic, copy) NSString *name;

/** 图标 */

@property (nonatomic, copy) NSString *icon;



/** 通过一个字典来初始化模型对象 */

- (instancetype)initWithDict:(NSDictionary *)dict;



/** 通过一个字典来创建模型对象 */

+ (instancetype)shopWithDict:(NSDictionary *)dict;
</code></pre>

<h6>2:模型方法的实现</h6>

<pre><code>- (instancetype)initWithDict:(NSDictionary *)dict

{

    if (self = [super init]) {

        self.name = dict[@"name"];

        self.icon = dict[@"icon"];

    }

    return self;

}



+ (instancetype)shopWithDict:(NSDictionary *)dict

{

    // 这里要用self

    return [[self alloc] initWithDict:dict];

}
</code></pre>

<h6>3:自定义一个View，引入模型类，并且创建模型类的属性</h6>

<pre><code>@class XMGShop;



/** 商品模型 */

@property (nonatomic, strong) XMGShop *shop;
</code></pre>

<h6>4:实现文件中，定义相应的控件属性</h6>

<pre><code>/** 图片 */

@property (nonatomic, weak) UIImageView *iconView;



/** 名字 */

@property (nonatomic, weak) UILabel *nameLabel;
</code></pre>

<h6>5:实现自定义View的相应方法</h6>

<pre><code>- (instancetype)init

{

    if (self = [super init]) {

        // 添加一个图片

        UIImageView *iconView = [[UIImageView alloc] init];

        [self addSubview:iconView];

        self.iconView = iconView;



        // 添加一个文字

        UILabel *nameLabel = [[UILabel alloc] init];

        nameLabel.textAlignment = NSTextAlignmentCenter;

        [self addSubview:nameLabel];

        self.nameLabel = nameLabel;

    }

    return self;

}



/**

 * 这个方法专门用来布局子控件，设置子控件的frame

 */

- (void)layoutSubviews

{

    // 一定要调用super方法

    [super layoutSubviews];



    CGFloat shopW = self.frame.size.width;

    CGFloat shopH = self.frame.size.height;



    self.iconView.frame = CGRectMake(0, 0, shopW, shopW);

    self.nameLabel.frame = CGRectMake(0, shopW, shopW, shopH - shopW);

}



-(void)setShop:(XMGShop *)shop

{

    _shop = shop;



    self.iconView.image = [UIImage imageNamed:shop.icon];

    self.nameLabel.text = shop.name;

}
</code></pre>

<h6>6:定义一个数组用来保存读取出来的plist数据</h6>

<pre><code> 1 @property (nonatomic, strong) NSMutableArray *shops; 
</code></pre>

<h6>7:使用懒加载的方式加载plist文件，并且放到模型中</h6>

<pre><code>// 懒加载

// 1.第一次用到时再去加载

// 2.只会加载一次

- (NSMutableArray *)shops

{

    if (_shops == nil) {

        // 创建"模型数组"

        _shops = [NSMutableArray array];



        // 获得plist文件的全路径

        NSString *file = [[NSBundle mainBundle] pathForResource:@"shops.plist" ofType:nil];



        // 从plist文件中加载一个数组对象(这个数组中存放的都是NSDictionary对象)

        NSArray *dictArray = [NSArray arrayWithContentsOfFile:file];



        // 将 “字典数组” 转换为 “模型数据”

        for (NSDictionary *dict in dictArray) { // 遍历每一个字典

            // 将 “字典” 转换为 “模型”

            XMGShop *shop = [XMGShop shopWithDict:dict];



            // 将 “模型” 添加到 “模型数组中”

            [_shops addObject:shop];

        }

    }

    return _shops;

} 
</code></pre>

<h6>8:使用View</h6>

<pre><code>// 创建一个商品父控件

XMGShopView *shopView = [[XMGShopView alloc] init];

shopView.frame = CGRectMake(shopX, shopY, shopW, shopH);

// 将商品父控件添加到shopsView中

[self.shopsView addSubview:shopView];




/**



NSDictionary *dict = nil; // 从其他地方加载的字典



 XMGShop *shop = [XMGShop shopWithDict:dict];



 XMGShopView *shopView = [[XMGShopView alloc] init];

 shopView.shop = shop;

 shopView.frame = CGRectMake(0, 0, 70, 100);

 [self.view addSubview:shopView];






 // 扩展性差

 // 扩展好的体现：即使改变了需求。我们也不需要动大刀子

 */
</code></pre>

<p>/******************************************************************************/</p>

<h3>五：initWithFrame</h3>

<p>1:在上一步的基础上只要修改init方法为</p>

<pre><code>/** init方法内部会自动调用initWithFrame:方法 */

- (instancetype)initWithFrame:(CGRect)frame

{

    if (self = [super initWithFrame:frame]) {

        // 添加一个图片

        UIImageView *iconView = [[UIImageView alloc] init];

        [self addSubview:iconView];

        self.iconView = iconView;



        // 添加一个文字

        UILabel *nameLabel = [[UILabel alloc] init];

        nameLabel.textAlignment = NSTextAlignmentCenter;

        [self addSubview:nameLabel];

        self.nameLabel = nameLabel;

    }

    return self;

}
</code></pre>

<p>2:最后设置数据的时候也可以使用下面的方法实现View的创建</p>

<pre><code> 1 XMGShopView *shopView = [[XMGShopView alloc] initWithFrame:CGRectMake(shopX, shopY, shopW, shopH)]; 
</code></pre>

<p>/******************************************************************************/</p>

<h3>六：MVC</h3>

<h6>1:model</h6>

<pre><code>@interface XMGShop : NSObject

/** 名字 */

@property (nonatomic, copy) NSString *name;

/** 图标 */

@property (nonatomic, copy) NSString *icon;

/** 通过一个字典来初始化模型对象 */

- (instancetype)initWithDict:(NSDictionary *)dict;



/** 通过一个字典来创建模型对象 */

+ (instancetype)shopWithDict:(NSDictionary *)dict;

@end






@implementation XMGShop



- (instancetype)initWithDict:(NSDictionary *)dict

{

    if (self = [super init]) {

        self.name = dict[@"name"];

        self.icon = dict[@"icon"];

    }

    return self;

}



+ (instancetype)shopWithDict:(NSDictionary *)dict

{

    // 这里要用self

    return [[self alloc] initWithDict:dict];

}



@end
</code></pre>

<h6>2:view</h6>

<pre><code>@class XMGShop;



@interface XMGShopView : UIView

/** 商品模型 */

@property (nonatomic, strong) XMGShop *shop;



- (instancetype)initWithShop:(XMGShop *)shop;

+ (instancetype)shopViewWithShop:(XMGShop *)shop;

+ (instancetype)shopView;

@end






@interface XMGShopView()

/** 图片 */

@property (nonatomic, weak) UIImageView *iconView;



/** 名字 */

@property (nonatomic, weak) UILabel *nameLabel;

@end



@implementation XMGShopView



- (instancetype)initWithShop:(XMGShop *)shop

{

    if (self = [super init]) {

        self.shop = shop;

    }

    return self;

}



+ (instancetype)shopViewWithShop:(XMGShop *)shop

{

    return [[self alloc] initWithShop:shop];

}



+ (instancetype)shopView

{

    return [[self alloc] init];

}



/** init方法内部会自动调用initWithFrame:方法 */

- (instancetype)initWithFrame:(CGRect)frame

{

    if (self = [super initWithFrame:frame]) {

        // 添加一个图片

        UIImageView *iconView = [[UIImageView alloc] init];

        [self addSubview:iconView];

        self.iconView = iconView;



        // 添加一个文字

        UILabel *nameLabel = [[UILabel alloc] init];

        nameLabel.textAlignment = NSTextAlignmentCenter;

        [self addSubview:nameLabel];

        self.nameLabel = nameLabel;

    }

    return self;

}



/**

 * 当前控件的frame发生改变的时候就会调用

 * 这个方法专门用来布局子控件，设置子控件的frame

 */

- (void)layoutSubviews

{

    // 一定要调用super方法

    [super layoutSubviews];



    CGFloat shopW = self.frame.size.width;

    CGFloat shopH = self.frame.size.height;



    self.iconView.frame = CGRectMake(0, 0, shopW, shopW);

    self.nameLabel.frame = CGRectMake(0, shopW, shopW, shopH - shopW);

}



- (void)setShop:(XMGShop *)shop

{

    _shop = shop;



    self.iconView.image = [UIImage imageNamed:shop.icon];

    self.nameLabel.text = shop.name;

}



@end
</code></pre>

<h6>controller</h6>

<pre><code>@property (nonatomic, strong) NSMutableArray *shops;







// 懒加载

// 1.第一次用到时再去加载

// 2.只会加载一次

- (NSMutableArray *)shops

{

    if (_shops == nil) {

        // 创建"模型数组"

        _shops = [NSMutableArray array];



        // 获得plist文件的全路径

        NSString *file = [[NSBundle mainBundle] pathForResource:@"shops.plist" ofType:nil];



        // 从plist文件中加载一个数组对象(这个数组中存放的都是NSDictionary对象)

        NSArray *dictArray = [NSArray arrayWithContentsOfFile:file];



        // 将 “字典数组” 转换为 “模型数据”

        for (NSDictionary *dict in dictArray) { // 遍历每一个字典

            // 将 “字典” 转换为 “模型”

            XMGShop *shop = [XMGShop shopWithDict:dict];



            // 将 “模型” 添加到 “模型数组中”

            [_shops addObject:shop];

        }

    }

    return _shops;

}



// 创建一个商品父控件

XMGShopView *shopView = [XMGShopView shopViewWithShop:self.shops[index]];

// 设置frame

shopView.frame = CGRectMake(shopX, shopY, shopW, shopH);

// 将商品父控件添加到shopsView中

[self.shopsView addSubview:shopView];
</code></pre>

<p>/******************************************************************************/</p>

<h3>七：XIB</h3>

<p>1:xibView中</p>

<pre><code>/** 商品模型 */

@property (nonatomic, strong) XMGShop *shop;

+ (instancetype)shopViewWithShop:(XMGShop *)shop;



+ (instancetype)shopViewWithShop:(XMGShop *)shop

{

    // self == XMGShopView

    // NSStringFromClass(self) == @"XMGShopView"

    XMGShopView *shopView = [[[NSBundle mainBundle] loadNibNamed:NSStringFromClass(self) owner:nil options:nil] lastObject];

    shopView.shop = shop;

    return shopView;

}



- (void)setShop:(XMGShop *)shop

{

    _shop = shop;



    UIImageView *iconView = (UIImageView *)[self viewWithTag:1];

    iconView.image = [UIImage imageNamed:shop.icon];



    UILabel *nameLabel = (UILabel *)[self viewWithTag:2];

    nameLabel.text = shop.name;

}
</code></pre>

<h6>2:控制器中设置数据</h6>

<pre><code>// 从xib中加载一个商品控件

XMGShopView *shopView = [XMGShopView shopViewWithShop:self.shops[index]];

// 设置frame

shopView.frame = CGRectMake(shopX, shopY, shopW, shopH);

// 添加商品控件

[self.shopsView addSubview:shopView];
</code></pre>

<p>/******************************************************************************/</p>

<h3>八：MJExtension</h3>

<h6>1:是一套“字典和模型之间互相转换”的轻量级框架，模型属性</h6>

<pre><code>/**

 *  微博文本内容

 */

@property (copy, nonatomic) NSString *text;



/**

 *  微博作者

 */

@property (strong, nonatomic) User *user;



/**

 *  转发的微博

 */

@property (strong, nonatomic) Status *retweetedStatus;



/**

 *  存放着某一页微博数据（里面都是Status模型）

 */

@property (strong, nonatomic) NSMutableArray *statuses;



/**

 *  总数

 */

@property (assign, nonatomic) NSNumber *totalNumber;



/**

 *  上一页的游标

 */

@property (assign, nonatomic) long long previousCursor;



/**

 *  下一页的游标

 */

@property (assign, nonatomic) long long nextCursor;





/**

 *  名称

 */

@property (copy, nonatomic) NSString *name;



/**

 *  头像

 */

@property (copy, nonatomic) NSString *icon;
</code></pre>

<h6>2:对应方法的实现</h6>

<ul>
<li><p>1.MJExtension是一套“字典和模型之间互相转换”的轻量级框架</p></li>
<li><p>2.MJExtension能完成的功能</p>

<ul>
<li><p>字典 &ndash;> 模型</p></li>
<li><p>模型 &ndash;> 字典</p></li>
<li><p>字典数组 &ndash;> 模型数组</p></li>
<li><p>模型数组 &ndash;> 字典数组</p></li>
</ul>
</li>
<li><p>3.具体用法主要参考 main.m中各个函数 以及 &ldquo;NSObject+MJKeyValue.h&rdquo;</p></li>
<li><p>4.希望各位大神能用得爽</p>

<pre><code> #import &lt;Foundation/Foundation.h&gt;

 #import "MJExtension.h"

 #import "User.h"

 #import "Status.h"

 #import "StatusResult.h"



 /**

  *  简单的字典 -&gt; 模型

  */

 void keyValues2object()

 {

     // 1.定义一个字典

     NSDictionary *dict = @{

                            @"name" : @"Jack",

                            @"icon" : @"lufy.png",

                            };



     // 2.将字典转为User模型

     User *user = [User objectWithKeyValues:dict];



     // 3.打印User模型的属性

     NSLog(@"name=%@, icon=%@", user.name, user.icon);

 }



 /**

  *  复杂的字典 -&gt; 模型 (模型里面包含了模型)

  */

 void keyValues2object2()

 {

     // 1.定义一个字典

     NSDictionary *dict = @{

                            @"text" : @"是啊，今天天气确实不错！",



                            @"user" : @{

                                    @"name" : @"Jack",

                                    @"icon" : @"lufy.png"

                                    },



                            @"retweetedStatus" : @{

                                    @"text" : @"今天天气真不错！",



                                    @"user" : @{

                                            @"name" : @"Rose",

                                            @"icon" : @"nami.png"

                                            }

                                    }

                            };



     // 2.将字典转为Status模型

     Status *status = [Status objectWithKeyValues:dict];



     // 3.打印status的属性

     NSString *text = status.text;

     NSString *name = status.user.name;

     NSString *icon = status.user.icon;

     NSLog(@"text=%@, name=%@, icon=%@", text, name, icon);



     // 4.打印status.retweetedStatus的属性

     NSString *text2 = status.retweetedStatus.text;

     NSString *name2 = status.retweetedStatus.user.name;

     NSString *icon2 = status.retweetedStatus.user.icon;

     NSLog(@"text2=%@, name2=%@, icon2=%@", text2, name2, icon2);

 }



 /**

  *  复杂的字典 -&gt; 模型 (模型的数组属性里面又装着模型)

  */

 void keyValues2object3()

 {

     // 1.定义一个字典

     NSDictionary *dict = @{

                            @"statuses" : @[

                                    @{

                                        @"text" : @"今天天气真不错！",



                                        @"user" : @{

                                                @"name" : @"Rose",

                                                @"icon" : @"nami.png"

                                                }

                                        },



                                    @{

                                        @"text" : @"明天去旅游了",



                                        @"user" : @{

                                                @"name" : @"Jack",

                                                @"icon" : @"lufy.png"

                                                }

                                        },



                                    @{

                                        @"text" : @"嘿嘿，这东西不错哦！",



                                        @"user" : @{

                                                @"name" : @"Jim",

                                                @"icon" : @"zero.png"

                                                }

                                        }



                                    ],



                            @"totalNumber" : @"2014",



                            @"previousCursor" : @"13476589",



                            @"nextCursor" : @"13476599"

                            };



     // 2.将字典转为StatusResult模型

     StatusResult *result = [StatusResult objectWithKeyValues:dict];



     // 3.打印StatusResult模型的简单属性

     NSLog(@"totalNumber=%d, previousCursor=%lld, nextCursor=%lld", result.totalNumber, result.previousCursor, result.nextCursor);



     // 4.打印statuses数组中的模型属性

     for (Status *status in result.statuses) {

         NSString *text = status.text;

         NSString *name = status.user.name;

         NSString *icon = status.user.icon;

         NSLog(@"text=%@, name=%@, icon=%@", text, name, icon);

     }

 }



 /**

  *  字典数组 -&gt; 模型数组

  */

 void keyValuesArray2objectArray()

 {

     // 1.定义一个字典数组

     NSArray *dictArray = @[

                            @{

                                @"name" : @"Jack",

                                @"icon" : @"lufy.png",

                                },



                            @{

                                @"name" : @"Rose",

                                @"icon" : @"nami.png",

                                },



                            @{

                                @"name" : @"Jim",

                                @"icon" : @"zero.png",

                                }

                            ];



     // 2.将字典数组转为User模型数组

     NSArray *userArray = [User objectArrayWithKeyValuesArray:dictArray];



     // 3.打印userArray数组中的User模型属性

     for (User *user in userArray) {

         NSLog(@"name=%@, icon=%@", user.name, user.icon);

     }

 }



 /**

  *  模型 -&gt; 字典

  */

 void object2keyValues()

 {

     // 1.新建模型

     User *user = [[User alloc] init];

     user.name = @"Jack";

     user.icon = @"lufy.png";



     Status *status = [[Status alloc] init];

     status.user = user;

     status.text = @"今天的心情不错！";



     // 2.将模型转为字典

     //    NSDictionary *dict = [status keyValues];

     NSDictionary *dict = status.keyValues;

     NSLog(@"%@", dict);

 }



 /**

  *  模型数组 -&gt; 字典数组

  */

 void objectArray2keyValuesArray()

 {

     // 1.新建模型数组

     User *user1 = [[User alloc] init];

     user1.name = @"Jack";

     user1.icon = @"lufy.png";



     User *user2 = [[User alloc] init];

     user2.name = @"Rose";

     user2.icon = @"nami.png";



     User *user3 = [[User alloc] init];

     user3.name = @"Jim";

     user3.icon = @"zero.png";



     NSArray *userArray = @[user1, user2, user3];



     // 2.将模型数组转为字典数组

     NSArray *dictArray = [User keyValuesArrayWithObjectArray:userArray];

     NSLog(@"%@", dictArray);

 }



 int main(int argc, const char * argv[])

 {

     @autoreleasepool {

         // 简单的字典 -&gt; 模型

         keyValues2object();



         // 复杂的字典 -&gt; 模型 (模型里面包含了模型)

         keyValues2object2();



         // 复杂的字典 -&gt; 模型 (模型的数组属性里面又装着模型)

         keyValues2object3();



         // 字典数组 -&gt; 模型数组

         keyValuesArray2objectArray();



         // 模型转字典

         object2keyValues();



         // 模型数组 -&gt; 字典数组

         objectArray2keyValuesArray();

     }

     return 0;

 }
</code></pre></li>
</ul>

</div>
  
  




| <a href="/blog/2014/06/25/data%20model/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/16/runtime/">玩转运行时</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><p>运行时（Runtime）机制</p>

<p>本文将会以笔者个人的小小研究为例总结一下关于iOS开发中运行时的使用和常用方法的介绍，关于跟多运行时相关技术请查看笔者之前写的运行时高级用法及相关语法或者查看响应官方文档。</p>

<p>下面就来看看什么是运行时，我们要怎么在iOS开发中去使用它。</p>

<p>官方介绍：</p>

<p><img src="/images/runtime001.png" title="Caption" ></p>

<p><img src="/images/runtime002.png" title="Caption" ></p>

<p>这里我们主要关注的是最后一种！</p>

<p>下面来看看Runtime的相关总结</p>

<p><img src="/images/runtime003.png" title="Caption" ></p>
</div>
  
  




| <a href="/blog/2014/06/16/runtime/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/03/data%20cache/">玩转数据持久化</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><p>概论</p>

<p>所谓的持久化，就是将数据保存到硬盘中，使得在应用程序或机器重启后可以继续访问之前保存的数据。在iOS开发中，有很多数据持久化的方案，接下来我将尝试着介绍一下5种方案：</p>

<ul>
<li>plist文件（属性列表）</li>
<li>preference（偏好设置）</li>
<li>NSKeyedArchiver（归档）</li>
<li>SQLite 3</li>
<li>CoreData</li>
</ul>


<h4>沙盒</h4>

<p>在介绍各种存储方法之前，有必要说明以下沙盒机制。iOS程序默认情况下只能访问程序自己的目录，这个目录被称为“沙盒”。</p>

<h6>#1.结构</h6>

<p>既然沙盒就是一个文件夹，那就看看里面有什么吧。沙盒的目录结构如下：</p>

<pre><code>"应用程序包"
Documents
Library
    Caches
    Preferences
tmp
</code></pre>

<h6>#2.目录特性</h6>

<p>虽然沙盒中有这么多文件夹，但是没有文件夹都不尽相同，都有各自的特性。所以在选择存放目录时，一定要认真选择适合的目录。</p>

<p>&ldquo;应用程序包&rdquo;: 这里面存放的是应用程序的源文件，包括资源文件和可执行文件。</p>

<pre><code>  NSString *path = [[NSBundle mainBundle] bundlePath];
  NSLog(@"%@", path);
Documents: 最常用的目录，iTunes同步该应用时会同步此文件夹中的内容，适合存储重要数据。

  NSString *path = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject;
  NSLog(@"%@", path);
Library/Caches: iTunes不会同步此文件夹，适合存储体积大，不需要备份的非重要数据。

  NSString *path = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES).firstObject;
  NSLog(@"%@", path);
</code></pre>

<p>Library/Preferences: iTunes同步该应用时会同步此文件夹中的内容，通常保存应用的设置信息。</p>

<p>tmp: iTunes不会同步此文件夹，系统可能在应用没运行时就删除该目录下的文件，所以此目录适合保存应用中的一些临时文件，用完就删除。</p>

<pre><code>  NSString *path = NSTemporaryDirectory();
  NSLog(@"%@", path);
</code></pre>

<h4>plist文件</h4>

<p>plist文件是将某些特定的类，通过XML文件的方式保存在目录中。</p>

<p>可以被序列化的类型只有如下几种：</p>

<pre><code>NSArray;
NSMutableArray;
NSDictionary;
NSMutableDictionary;
NSData;
NSMutableData;
NSString;
NSMutableString;
NSNumber;
NSDate;
</code></pre>

<p>1.获得文件路径</p>

<pre><code>NSString *path = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject;
NSString *fileName = [path stringByAppendingPathComponent:@"123.plist"];
</code></pre>

<p>2.存储</p>

<pre><code>NSArray *array = @[@"123", @"456", @"789"];
[array writeToFile:fileName atomically:YES];
3.读取

NSArray *result = [NSArray arrayWithContentsOfFile:fileName];
NSLog(@"%@", result);
</code></pre>

<p>4.注意</p>

<p>只有以上列出的类型才能使用plist文件存储。
存储时使用writeToFile: atomically:方法。 其中atomically表示是否需要先写入一个辅助文件，再把辅助文件拷贝到目标文件地址。这是更安全的写入文件方法，一般都写YES。
读取时使用arrayWithContentsOfFile:方法。</p>

<h4>Preference</h4>

<h6>#1.使用方法</h6>

<pre><code>//1.获得NSUserDefaults文件
NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults];
//2.向文件中写入内容
[userDefaults setObject:@"AAA" forKey:@"a"];
[userDefaults setBool:YES forKey:@"sex"];
[userDefaults setInteger:21 forKey:@"age"];
//2.1立即同步
[userDefaults synchronize];
//3.读取文件
NSString *name = [userDefaults objectForKey:@"a"];
BOOL sex = [userDefaults boolForKey:@"sex"];
NSInteger age = [userDefaults integerForKey:@"age"];
NSLog(@"%@, %d, %ld", name, sex, age);
</code></pre>

<h6>#2.注意</h6>

<p>偏好设置是专门用来保存应用程序的配置信息的，一般不要在偏好设置中保存其他数据。
如果没有调用synchronize方法，系统会根据I/O情况不定时刻地保存到文件中。所以如果需要立即写入文件的就必须调用synchronize方法。
偏好设置会将所有数据保存到同一个文件中。即preference目录下的一个以此应用包名来命名的plist文件。</p>

<h4>NSKeyedArchiver</h4>

<p>归档在iOS中是另一种形式的序列化，只要遵循了NSCoding协议的对象都可以通过它实现序列化。由于决大多数支持存储数据的Foundation和Cocoa Touch类都遵循了NSCoding协议，因此，对于大多数类来说，归档相对而言还是比较容易实现的。</p>

<h6>#1.遵循NSCoding协议</h6>

<p>NSCoding协议声明了两个方法，这两个方法都是必须实现的。一个用来说明如何将对象编码到归档中，另一个说明如何进行解档来获取一个新对象。</p>

<p>遵循协议和设置属性</p>

<pre><code>  //1.遵循NSCoding协议 
  @interface Person : NSObject   //2.设置属性
  @property (strong, nonatomic) UIImage *avatar;
  @property (copy, nonatomic) NSString *name;
  @property (assign, nonatomic) NSInteger age;
  @end
</code></pre>

<p>实现协议方法</p>

<pre><code>  //解档
  - (id)initWithCoder:(NSCoder *)aDecoder {
      if ([super init]) {
          self.avatar = [aDecoder decodeObjectForKey:@"avatar"];
          self.name = [aDecoder decodeObjectForKey:@"name"];
          self.age = [aDecoder decodeIntegerForKey:@"age"];
      }
      return self;
  }
  //归档
  - (void)encodeWithCoder:(NSCoder *)aCoder {
      [aCoder encodeObject:self.avatar forKey:@"avatar"];
      [aCoder encodeObject:self.name forKey:@"name"];
      [aCoder encodeInteger:self.age forKey:@"age"];
  }
</code></pre>

<p>特别注意
如果需要归档的类是某个自定义类的子类时，就需要在归档和解档之前先实现父类的归档和解档方法。即 [super encodeWithCoder:aCoder] 和 [super initWithCoder:aDecoder] 方法;</p>

<h6>#2.使用</h6>

<p>需要把对象归档是调用NSKeyedArchiver的工厂方法 archiveRootObject: toFile: 方法。</p>

<pre><code>  NSString *file = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject stringByAppendingPathComponent:@"person.data"];
  Person *person = [[Person alloc] init];
  person.avatar = self.avatarView.image;
  person.name = self.nameField.text;
  person.age = [self.ageField.text integerValue];
  [NSKeyedArchiver archiveRootObject:person toFile:file];
</code></pre>

<p>需要从文件中解档对象就调用NSKeyedUnarchiver的一个工厂方法 unarchiveObjectWithFile: 即可。</p>

<pre><code>  NSString *file = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject stringByAppendingPathComponent:@"person.data"];
  Person *person = [NSKeyedUnarchiver unarchiveObjectWithFile:file];
  if (person) {
     self.avatarView.image = person.avatar;
     self.nameField.text = person.name;
     self.ageField.text = [NSString stringWithFormat:@"%ld", person.age];
  }
</code></pre>

<h6>#3.注意</h6>

<p>必须遵循并实现NSCoding协议
保存文件的扩展名可以任意指定
继承时必须先调用父类的归档解档方法</p>

<h4>SQLite3</h4>

<p>之前的所有存储方法，都是覆盖存储。如果想要增加一条数据就必须把整个文件读出来，然后修改数据后再把整个内容覆盖写入文件。所以它们都不适合存储大量的内容。</p>

<h6>#1.字段类型</h6>

<p>表面上SQLite将数据分为以下几种类型：</p>

<pre><code>integer : 整数
real : 实数（浮点数）
text : 文本字符串
blob : 二进制数据，比如文件，图片之类的
</code></pre>

<p>实际上SQLite是无类型的。即不管你在创表时指定的字段类型是什么，存储是依然可以存储任意类型的数据。而且在创表时也可以不指定字段类型。SQLite之所以什么类型就是为了良好的编程规范和方便开发人员交流，所以平时在使用时最好设置正确的字段类型！主键必须设置成integer</p>

<h6>#2. 准备工作</h6>

<p>准备工作就是导入依赖库啦，在iOS中要使用SQLite3，需要添加库文件：libsqlite3.dylib并导入主头文件，这是一个C语言的库，所以直接使用SQLite3还是比较麻烦的。</p>

<h6>#3.使用</h6>

<p>创建数据库并打开
操作数据库之前必须先指定数据库文件和要操作的表，所以使用SQLite3，首先要打开数据库文件，然后指定或创建一张表。</p>

<pre><code>/**
*  打开数据库并创建一个表
*/
- (void)openDatabase {
   //1.设置文件名
   NSString *filename = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject stringByAppendingPathComponent:@"person.db"];
   //2.打开数据库文件，如果没有会自动创建一个文件
   NSInteger result = sqlite3_open(filename.UTF8String, &amp;_sqlite3);
   if (result == SQLITE_OK) {
       NSLog(@"打开数据库成功！");
       //3.创建一个数据库表
       char *errmsg = NULL;
       sqlite3_exec(_sqlite3, "CREATE TABLE IF NOT EXISTS t_person(id integer primary key autoincrement, name text, age integer)", NULL, NULL, &amp;errmsg);
       if (errmsg) {
           NSLog(@"错误：%s", errmsg);
       } else {
           NSLog(@"创表成功！");
       }
   } else {
       NSLog(@"打开数据库失败！");
   }
}
</code></pre>

<p>执行指令
使用 sqlite3_exec() 方法可以执行任何SQL语句，比如创表、更新、插入和删除操作。但是一般不用它执行查询语句，因为它不会返回查询到的数据。</p>

<pre><code>/**
*  往表中插入1000条数据
*/
- (void)insertData {
NSString *nameStr;
NSInteger age;
for (NSInteger i = 0; i &lt; 1000; i++) {
  nameStr = [NSString stringWithFormat:@"Bourne-%d", arc4random_uniform(10000)];
  age = arc4random_uniform(80) + 20;
  NSString *sql = [NSString stringWithFormat:@"INSERT INTO t_person (name, age) VALUES('%@', '%ld')", nameStr, age];
  char *errmsg = NULL;
  sqlite3_exec(_sqlite3, sql.UTF8String, NULL, NULL, &amp;errmsg);
  if (errmsg) {
      NSLog(@"错误：%s", errmsg);
  }
}
NSLog(@"插入完毕！");
}
</code></pre>

<p>查询指令
前面说过一般不使用 sqlite3_exec() 方法查询数据。因为查询数据必须要获得查询结果，所以查询相对比较麻烦。示例代码如下：</p>

<pre><code>sqlite3_prepare_v2() : 检查sql的合法性
sqlite3_step() : 逐行获取查询结果，不断重复，直到最后一条记录
sqlite3_coloum_xxx() : 获取对应类型的内容，iCol对应的就是SQL语句中字段的顺序，从0开始。根据实际查询字段的属性，使用sqlite3_column_xxx取得对应的内容即可。
sqlite3_finalize() : 释放stmt
/**
*  从表中读取数据到数组中
*/
- (void)readData {
   NSMutableArray *mArray = [NSMutableArray arrayWithCapacity:1000];
   char *sql = "select name, age from t_person;";
   sqlite3_stmt *stmt;
   NSInteger result = sqlite3_prepare_v2(_sqlite3, sql, -1, &amp;stmt, NULL);
   if (result == SQLITE_OK) {
       while (sqlite3_step(stmt) == SQLITE_ROW) {
           char *name = (char *)sqlite3_column_text(stmt, 0);
           NSInteger age = sqlite3_column_int(stmt, 1);
           //创建对象
           Person *person = [Person personWithName:[NSString stringWithUTF8String:name] Age:age];
           [mArray addObject:person];
       }
       self.dataList = mArray;
   }
   sqlite3_finalize(stmt);
}
</code></pre>

<h6>#4.总结</h6>

<p>总得来说，SQLite3的使用还是比较麻烦的，因为都是些c语言的函数，理解起来有些困难。不过在一般开发过程中，使用的都是第三方开源库 FMDB，封装了这些基本的c语言方法，使得我们在使用时更加容易理解，提高开发效率。</p>

<h4>FMDB</h4>

<h6>1.简介</h6>

<p>FMDB是iOS平台的SQLite数据库框架，它是以OC的方式封装了SQLite的C语言API，它相对于cocoa自带的C语言框架有如下的优点:</p>

<p>使用起来更加面向对象，省去了很多麻烦、冗余的C语言代码</p>

<p>对比苹果自带的Core Data框架，更加轻量级和灵活</p>

<p>提供了多线程安全的数据库操作方法，有效地防止数据混乱</p>

<blockquote><p>注：FMDB的gitHub地址</p></blockquote>

<h6>2.核心类</h6>

<p>FMDB有三个主要的类：</p>

<ul>
<li><p>FMDatabase</p>

<p>  一个FMDatabase对象就代表一个单独的SQLite数据库，用来执行SQL语句</p></li>
<li><p>FMResultSet</p>

<p>  使用FMDatabase执行查询后的结果集</p></li>
<li><p>FMDatabaseQueue</p>

<p>  用于在多线程中执行多个查询或更新，它是线程安全的</p></li>
</ul>


<h6>3.打开数据库</h6>

<p>和c语言框架一样，FMDB通过指定SQLite数据库文件路径来创建FMDatabase对象，但FMDB更加容易理解，使用起来更容易，使用之前一样需要导入sqlite3.dylib。打开数据库方法如下：</p>

<pre><code>NSString *path = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject stringByAppendingPathComponent:@"person.db"];
FMDatabase *database = [FMDatabase databaseWithPath:path];    
if (![database open]) {
    NSLog(@"数据库打开失败！");
}
</code></pre>

<p>值得注意的是，Path的值可以传入以下三种情况：</p>

<p>具体文件路径，如果不存在会自动创建
空字符串@&ldquo;"，会在临时目录创建一个空的数据库，当FMDatabase连接关闭时，数据库文件也被删除
nil，会创建一个内存中临时数据库，当FMDatabase连接关闭时，数据库会被销毁</p>

<h6>4.更新</h6>

<p>在FMDB中，除查询以外的所有操作，都称为“更新”, 如：create、drop、insert、update、delete等操作，使用executeUpdate:方法执行更新：</p>

<pre><code>//常用方法有以下3种：   
- (BOOL)executeUpdate:(NSString*)sql, ...
- (BOOL)executeUpdateWithFormat:(NSString*)format, ...
- (BOOL)executeUpdate:(NSString*)sql withArgumentsInArray:(NSArray *)arguments
//示例
[database executeUpdate:@"CREATE TABLE IF NOT EXISTS t_person(id integer primary key autoincrement, name text, age integer)"];   
//或者  
[database executeUpdate:@"INSERT INTO t_person(name, age) VALUES(?, ?)", @"Bourne", [NSNumber numberWithInt:42]];
</code></pre>

<h6>5.查询</h6>

<p>查询方法也有3种，使用起来相当简单：</p>

<pre><code>- (FMResultSet *)executeQuery:(NSString*)sql, ...
- (FMResultSet *)executeQueryWithFormat:(NSString*)format, ...
- (FMResultSet *)executeQuery:(NSString *)sql withArgumentsInArray:(NSArray *)arguments
</code></pre>

<p>查询示例：</p>

<pre><code>//1.执行查询
FMResultSet *result = [database executeQuery:@"SELECT * FROM t_person"];
//2.遍历结果集
while ([result next]) {
    NSString *name = [result stringForColumn:@"name"];
    int age = [result intForColumn:@"age"];
}
</code></pre>

<h6>6.线程安全</h6>

<p>在多个线程中同时使用一个FMDatabase实例是不明智的。不要让多个线程分享同一个FMDatabase实例，它无法在多个线程中同时使用。 如果在多个线程中同时使用一个FMDatabase实例，会造成数据混乱等问题。所以，请使用 FMDatabaseQueue，它是线程安全的。以下是使用方法：</p>

<p>创建队列。</p>

<pre><code>FMDatabaseQueue *queue = [FMDatabaseQueue databaseQueueWithPath:aPath];
使用队列
[queue inDatabase:^(FMDatabase *database) {    
          [database executeUpdate:@"INSERT INTO t_person(name, age) VALUES (?, ?)", @"Bourne_1", [NSNumber numberWithInt:1]];    
          [database executeUpdate:@"INSERT INTO t_person(name, age) VALUES (?, ?)", @"Bourne_2", [NSNumber numberWithInt:2]];    
          [database executeUpdate:@"INSERT INTO t_person(name, age) VALUES (?, ?)", @"Bourne_3", [NSNumber numberWithInt:3]];      
          FMResultSet *result = [database executeQuery:@"select * from t_person"];    
         while([result next]) {   
         }    
}];
</code></pre>

<p>而且可以轻松地把简单任务包装到事务里：</p>

<pre><code>[queue inTransaction:^(FMDatabase *database, BOOL *rollback) {    
          [database executeUpdate:@"INSERT INTO t_person(name, age) VALUES (?, ?)", @"Bourne_1", [NSNumber numberWithInt:1]];    
          [database executeUpdate:@"INSERT INTO t_person(name, age) VALUES (?, ?)", @"Bourne_2", [NSNumber numberWithInt:2]];    
          [database executeUpdate:@"INSERT INTO t_person(name, age) VALUES (?, ?)", @"Bourne_3", [NSNumber numberWithInt:3]];      
          FMResultSet *result = [database executeQuery:@"select * from t_person"];    
             while([result next]) {   
             }   
           //回滚
           *rollback = YES;  
    }];
</code></pre>

<p>FMDatabaseQueue 后台会建立系列化的G-C-D队列，并执行你传给G-C-D队列的块。这意味着 你从多线程同时调用调用方法，GDC也会按它接收的块的顺序来执行。</p>

<h4>CoreData</h4>

<p>详见我的另一篇笔记：我要娶你做我的CoreData！</p>

<p>声明：</p>

<p>以上内容属于本人整理的笔记，如有错误的地方希望能告诉我，大家共同进步。
以上内容有些段落或语句可能是本人从其他地方Copy而来，如有侵权，请及时告诉我。</p>
</div>
  
  




| <a href="/blog/2014/06/03/data%20cache/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/29/animation/">三维动画初探</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><p>实现三位旋转动画的方法有很多种，这里介绍三种</p>

<p>一：UIView</p>

<pre><code>[UIView animateWithDuration:1.0 animations:^{
        self.iconView.layer.transform = CATransform3DMakeRotation(M_PI_2, 0, 1, 0);
    } completion:^(BOOL finished) {
        self.iconView.image = [UIImage imageNamed:@"user_defaultgift"];

        [UIView animateWithDuration:1.0 animations:^{
            self.iconView.layer.transform = CATransform3DMakeRotation(M_PI, 0, 1, 0);
        }];
    }];
</code></pre>

<p>二：CATransition自定义</p>

<pre><code> CATransition
  CATransition *anim = [CATransition animation];
 anim.duration = 1.0;
 anim.type = @"rippleEffect";
 [self.iconView.layer addAnimation:anim forKey:nil];
</code></pre>

<p>三：CATransition</p>

<pre><code>[UIView transitionWithView:self.iconView duration:1.0 options:UIViewAnimationOptionTransitionFlipFromLeft animations:^{
        self.iconView.image = [UIImage imageNamed:@"user_defaultgift"];
    } completion:^(BOOL finished) {
        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
            [UIView transitionWithView:self.iconView duration:1.0 options:UIViewAnimationOptionTransitionFlipFromRight animations:^{
                self.iconView.image = [UIImage imageNamed:@"default_avatar"];
            } completion:nil];
        });
    }];
}
</code></pre>
</div>
  
  




| <a href="/blog/2014/05/29/animation/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/20/sign/">签名机制</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><p>最近看了objc.io上第17期中的文章 《Inside Code Signing》 对应的中文翻译版 《代码签名探析》 ，受益颇深，对iOS代码签名机制有了进一步的认识。想了解详细内容建议大家还是去看原文好了。</p>

<p>下面是对此文章的理解再结合自己之前对该部分的认识写出的学习笔记。本文的前提是已经对非对称加密有了一定的了解。</p>

<h4>一、数字签名（digital signature）</h4>

<p>对指定信息使用哈希算法，得到一个固定长度的信息摘要，然后再使用 私钥 （注意必须是私钥）对该摘要加密，就得到了数字签名。所谓的代码签名就是这个意思。</p>

<h4>二、数字证书（digital certificate）</h4>

<p>证书生成</p>

<p>开 发者在申请iOS开发证书时，需要通过keychain生成一个CSR文件（Certificate Signing Request），提交给苹果的 Apple Worldwide Developer Relations Certification Authority(WWDR)证书认证中心进行签名，最后从苹果官网下载并安装使用。这个过程中还会产生一个私钥，证书和私钥在keychain中得位 置如图：</p>

<p>iphone-developer-keychain.png</p>

<p>证书组成</p>

<p>经过WWDR数字签名后的数字证书长这个样子：</p>

<p>20130603170838968.png</p>

<p>其中包含两大部分：</p>

<p>· 证书本身</p>

<p>包含用户的公钥、用户个人信息、证书颁发机构信息、证书有效期等信息。</p>

<p>· 证书签名</p>

<p>WWDR将上述证书本身内容的使用哈希算法得到一个固定长度的信息摘要，然后使用自己的私钥对该信息摘要加密生成数字签名，整个过程如图所示：</p>

<p>20130603170752859.png</p>

<p>证书使用</p>

<p>iOS 系统原本就持有WWDR的公钥，系统首先会对证书内容通过指定的哈希算法计算得到一个信息摘要；然后使用WWDR的公钥对证书中包含的数字签名解密，从而 得到经过WWDR的私钥加密过的信息摘要；最后对比两个信息摘要，如果内容相同就说明该证书可信。整个过程如图所示：</p>

<p>20130603170924312.png</p>

<p>在验证了证书是可信的以后，iOS系统就可以获取到证书中包含的开发者的公钥，并使用该公钥来判断代码签名的可用性了。</p>

<p>证书存在的意义</p>

<p>通过证书使用过程可以看出，证书本身只是一个中间媒介，iOS系统对证书并不关心，它其实只想要证书中包含的开发者的公钥！！</p>

<p>但是开发者怎么才能证明公钥是自己的呢？iOS安全系统怎么才能相信这个公钥就是这个开发者的呢？</p>

<p>不 管是哪一个开发者对iOS的安全系统说，这个公钥就是我的，系统是都不相信的，即系统对开发者有着百分之百的不信任感。但是iOS安全系统对自家的 WWDR是可信任的，苹果将WWDR的公钥内置在了iOS系统中。有了证书，iOS安全系统只需要通过WWDR的公钥就可以获取到任何一个开发者的可信任 的公钥了，这就是证书存在的意义！！</p>

<h4>三、公钥（public key）</h4>

<p>公钥被包含在数字证书里，数字证书又被包含在描述文件(Provisioning File)中，描述文件在应用被安装的时候会被拷贝到iOS设备中。</p>

<p>iOS安全系统通过证书就能够确定开发者身份，就能够通过从证书中获取到的公钥来验证开发者用该公钥对应的私钥签名后的代码、资源文件等有没有被更改破坏，最终确定应用能否合法的在iOS设备上合法运行。</p>

<h4>四、私钥（private key）</h4>

<p>每个证书（其实是公钥）都对应有一个私钥，</p>

<p>私钥会被用来对代码、资源文件等签名。只有开发证书和描述文件是没办法正常调试的，因为没有私钥根本无法签名。</p>

<p>此后的内容基本都是从《代码签名探析》摘抄过来的笔记，建议大家看原文好了。</p>

<h4>五、签名相关命令</h4>

<p>快捷查看系统中能用来对代码进行签名的证书</p>

<p>可以使用如下命令：</p>

<pre><code>1 $security find-identity -v -p codesigning  
2   1) F10B42FFDE18DF28BA21190121439F2E04BEE4B8 "iPhone Developer: weizheng li (P7QJ74LFSA)"
3      1 valid identities found
</code></pre>

<p>这就说明当前有一个同时有公钥和私钥的可用证书。</p>

<p>对未签名app手动签名</p>

<p>使用如下命令：</p>

<pre><code> 1 $ codesign -s 'iPhone Developer: Thomas Kollbach (7TPNXN7G6K)' Example.app 
</code></pre>

<p>对已签名app重新签名</p>

<p>为了重新设置签名，你必须带上 -f 参数，有了这个参数，codesign 会用你选择的签名替换掉已经存在的那一个：</p>

<pre><code> 1 $ codesign -f -s 'iPhone Developer: Thomas Kollbach (7TPNXN7G6K)' Example.app 
</code></pre>

<p>查看指定app的签名信息</p>

<p>codesign 还可以为你提供有关一个可执行文件签名状态的信息，这些信息在出现不明错误时会提供巨大的帮助：</p>

<pre><code> 1 $ codesign -vv -d Example.app 
</code></pre>

<p>会列出以下有关 Example.app 的签名信息：</p>

<pre><code> 1 Executable=/Users/toto/Library/Developer/Xcode/DerivedData/Example-cfsbhbvmswdivqhekxfykvkpngkg/Build/Products/Debug-iphoneos/Example.app/Example  
 2 Identifier=ch.kollba.example  
 3 Format=bundle with Mach-O thin (arm64)  
 4 CodeDirectory v=20200 size=26663 flags=0x0(none) hashes=1324+5 location=embedded  
 5 Signature size=4336  
 6 Authority=iPhone Developer: Thomas Kollbach (7TPNXN7G6K)  
 7 Authority=Apple Worldwide Developer Relations Certification Authority  
 8 Authority=Apple Root CA  
 9 Signed Time=29.09.2014 22:29:07  
10 Info.plist entries=33  
11 TeamIdentifier=DZM8538E3E  
12 Sealed Resources version=2 rules=4 files=120  
13 Internal requirements count=1 size=184
</code></pre>

<p>验证签名文件的完整性</p>

<p>检查已签名的文件是否完整可以使用如下命令：</p>

<pre><code> 1 $ codesign --verify Example.app 
</code></pre>

<p>就像大多数 UNIX 工具一样，没有任何输出代表签名是完好的。如果修改一下这个二进制文件：</p>

<pre><code> 1 $ echo 'lol' &gt;&gt; Example.app/Example 2 $ codesign --verify Example.app 3 Example.app: main executable failed strict validation 
</code></pre>

<p>和预料中的一样，修改已经签名的应用会导致数字签名验证不通过。</p>

<h4>六、资源文件签名</h4>

<p>iOS 和 OS X 的应用和框架则是包含了它们所需要的资源在其中的。这些资源包括图片和不同的语言文件，资源中也包括很重要的应用组成部分例如 XIB/NIB 文件，存档文件(archives)，甚至是证书文件。所以为一个程序包设置签名时，这个包中的所有资源文件也都会被设置签名。</p>

<p>为了达到为 所有文件设置签名的目的，签名的过程中会在程序包（即Example.app）中新建一个叫做 _CodeSignatue/CodeResources 的文件，这个文件中存储了被签名的程序包中所有文件的签名。你可以自己去查看这个签名列表文件，它仅仅是一个 plist 格式文件。</p>

<blockquote><p>这个列表文件中不光包含了文件和它们的签名的列表，还包含了一系列规则，这些规则决定了哪些资源文件应当被设置签名。伴随 OS X 10.10 DP 5 和 10.9.5 版本的发布，苹果改变了代码签名的格式，也改变了有关资源的规则。如果你使用10.9.5或者更高版本的 codesign 工具，在 CodeResources 文件中会有4个不同区域，其中的 rules 和 files 是为老版本准备的，而 files2 和 rules2 是为新的第二版的代码签名准备的。最主要的区别是在新版本中你无法再将某些资源文件排除在代码签名之外，在过去你是可以的，只要在被设置签名的程序包中添 加一个名为 ResourceRules.plist 的文件，这个文件会规定哪些资源文件在检查代码签名是否完好时应该被忽略。但是在新版本的代码签名中，这种做法不再有效。所有的代码文件和资源文件都必须 设置签名，不再可以有例外。在新版本的代码签名规定中，一个程序包中的可执行程序包，例如扩展 (extension)，是一个独立的需要设置签名的个体，在检查签名是否完整时应当被单独对待。</p></blockquote>

<h4>七、授权文件（entitlements）</h4>

<p>在 iOS 上你的应用能做什么依然是沙盒限制的，这些限制大多情况下都由授权文件（entitlements）来决定。授权机制决定了哪些系统资源在什么情况下允许被一个应用使用，简单的说它就是一个沙盒的配置列表。</p>

<p>运行如下命令：</p>

<pre><code> 1 $ codesign -d --entitlements - Example.app 
</code></pre>

<p>会得到类似的结果：</p>

<pre><code> 1 &lt;!--?xml version="1.0" encoding="UTF-8"?--&gt;  
 2    
 3 &lt;plist version="1.0"&gt;  
 4 &lt;dict&gt;  
 5         &lt;key&gt;application-identifier&lt;/key&gt;
 6         &lt;string&gt;7TPNXN7G6K.ch.kollba.example&lt;/string&gt;
 7         &lt;key&gt;aps-environment&lt;/key&gt;
 8         &lt;string&gt;development&lt;/string&gt;
 9         &lt;key&gt;com.apple.developer.team-identifier&lt;/key&gt;
10         &lt;string&gt;7TPNXN7G6K&lt;/string&gt;
11         &lt;key&gt;com.apple.developer.ubiquity-container-identifiers&lt;/key&gt;
12         &lt;array&gt;
13                 &lt;string&gt;7TPNXN7G6K.ch.kollba.example&lt;/string&gt;
14         &lt;/array&gt;
15         &lt;key&gt;com.apple.developer.ubiquity-kvstore-identifier&lt;/key&gt;
16         &lt;string&gt;7TPNXN7G6K.ch.kollba.example&lt;/string&gt;
17         &lt;key&gt;com.apple.security.application-groups&lt;/key&gt;
18         &lt;array&gt;
19                 &lt;string&gt;group.ch.kollba.example&lt;/string&gt;
20         &lt;/array&gt;
21         &lt;key&gt;get-task-allow&lt;/key&gt;
22         &lt;true&gt;
23 &lt;/true&gt;&lt;/dict&gt;  
24 &lt;/plist version="1.0"&gt;
</code></pre>

<p>在 Xcode 的 Capabilities 选项卡下选择一些选项之后，Xcode 就会生成这样一段 XML。 Xcode 会自动生成一个 .entitlements 文件，然后在需要的时候往里面添加条目。当构建整个应用时，这个文件也会提交给 codesign 作为应用所需要拥有哪些授权的参考。这些授权信息必须都在开发者中心的 App ID 中启用，并且包含在后文介绍的描述文件中。在构建应用时需要使用的授权文件可以在 Xcode build setting 中的 code signing entitlements中设置。</p>

<p>在新版本的 Xcode 6 之后，授权信息列表会以 Example.app.xcent 这样的名字的文件形式包含在应用包中。这么做或许是为了在出现配置错误时提供更加有用的错误信息。</p>

<h4>八、描述文件（provisioning file）</h4>

<p>在整个代码签名和沙盒机制中有一个组成部分将签名，授权和沙盒联系了起来，那就是描述文件 (provisioning profiles)。</p>

<p>OS X中保存目录</p>

<p>Xcode 将从开发者中心下载的全部配置文件都放在了这里：</p>

<pre><code> 1 ~/Library/MobileDevice/Provisioning Profiles 
</code></pre>

<p>文件格式</p>

<p>描述文件并不是一个普通的plist文件，它是一个根据密码讯息语法 (Cryptographic Message Syntax) 加密的文件。</p>

<p>以XML格式查看该文件的命令：</p>

<pre><code> 1 $ security cms -D -i example.mobileprovision 
</code></pre>

<p>文件内容</p>

<p>描述文件主要包含以下内容：</p>

<ul>
<li>UUID</li>
</ul>


<p>每一个配置文件都有它自己的 UUID 。Xcode 会用这个 UUID 来作为标识，记录你在 build settings 中选择了哪一个配置文件。</p>

<ul>
<li>ProvisionedDevices</li>
</ul>


<p>记录所有可用于调试的设备ID。</p>

<ul>
<li>DeveloperCertificates</li>
</ul>


<p>包含了可以为使用这个配置文件的应用签名的所有证书。所有的证书都是基于 Base64 编码符合 PEM (Privacy Enhanced Mail, RFC 1848) 格式的。</p>

<ul>
<li>Entitlements</li>
</ul>


<p>有关前面讲到的配置文件的所有内容都会被保存在这里。</p>
</div>
  
  




| <a href="/blog/2014/05/20/sign/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/20/paixu/">排序算法精髓</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><h2>1、序言</h2>

<p>ios开发中涉及到算法的地方还真不多，除非你的应用程序真的非常大，或者你想你的应用程序性能非常好才会去想到关于算法方面的性能优化，而在ios开发中真的能用得到的也就是关于排序的，当然如果你是做游戏的话那么你可能会涉及到不少的算法或者优化问题，但是这不是本篇文章讨论的范围。</p>

<p>后面的文章中，我将会给大家详细介绍八大算法。</p>

<h2>2、冒泡排序</h2>

<h5>2.1 引出</h5>

<p>前面的两篇博客里讲的插入排序是基于“逐个记录插入”，选择排序是基于“选择”，那么冒泡排序其实是基于“交换”。每次从第一个记录开始，一、二两个记录比较，大的往后放，二三两个记录比较&hellip;依次类推，这就是一趟冒泡排序。每一趟冒泡排序后，无序序列中值最大的记录冒到序列末尾，所以称之为冒泡排序。</p>

<h5>2.2 代码</h5>

<pre><code>//冒泡排序
void bubbleSort(int *a,int n)
{
    int i,j;
    for(i=1;i&lt;n;i++)
        for(j=1;j&lt;n-i+1;j++){
            if(a[j+1]&lt;a[j]){
                a[j]=a[j]+a[j+1];
                a[j+1]=a[j]-a[j+1];
                a[j]=a[j]-a[j+1];
            }
        }
}
</code></pre>

<p> 冒泡排序算法：
冒泡排序代码</p>

<pre><code> static void Main(string[] args)
        {
            ////五次比较
             for (int i = 1; i &lt;= 5; i++)
            {
                List&lt;int&gt; list = new List&lt;int&gt;();
                //插入2k个随机数到数组中
                for (int j = 0; j &lt; 2000; j++)
                {
                    Thread.Sleep(1);
                    list.Add(new Random((int)DateTime.Now.Ticks).Next(0, 100000));
                }
                Console.WriteLine("\n第" + i + "次比较：");
                Stopwatch watch = new Stopwatch();
                watch.Start();
                var result = list.OrderBy(single =&gt; single).ToList();
                watch.Stop();
                Console.WriteLine("\n快速排序耗费时间：" + watch.ElapsedMilliseconds);
                Console.WriteLine("输出前是十个数:" + string.Join(",", result.Take(10).ToList()));
                watch.Start();
                result = BubbleSort(list);
                watch.Stop();
                Console.WriteLine("\n冒泡排序耗费时间：" + watch.ElapsedMilliseconds);
                Console.WriteLine("输出前是十个数:" + string.Join(",", result.Take(10).ToList()));
                Console.ReadKey();
            }

      }

 //冒泡排序算法
        private static List&lt;int&gt; BubbleSort(List&lt;int&gt; list)
        {
            int temp;
            //第一层循环： 表明要比较的次数，比如list.count个数，肯定要比较count-1次
            for (int i = 0; i &lt; list.Count - 1;i++ ) 
            {
                //list.count-1：取数据最后一个数下标，47 
                //j&gt;i: 从后往前的的下标一定大于从前往后的下标，否则就超越了。
                for (var j = list.Count-1; j &gt; i;j-- )
                {
                    //如果前面一个数大于后面一个数则交换
                    if (list[j - 1] &gt; list[j])
                    {
                        temp = list[j - 1];
                        list[j - 1] = list[j];
                        list[j] = temp;
                    }
                }

            }
            return list;
        } 
</code></pre>

<h5>2.3 效率分析</h5>

<p>相对于简单选择排序，冒泡排序交换次数明显更多。它是通过不断地交换把最大的数冒出来。冒泡排序平均时间和最坏情况下（逆序）时间为o（n<sup>2</sup>）。最佳情况下虽然不用交换，但比较的次数没有减少，时间复杂度仍为o（n<sup>2</sup>）。此外冒泡排序是稳定的。</p>

<h2>3、快速排序</h2>

<h5>3.1 引出</h5>

<pre><code>快速排序是冒泡排序的一种改进，冒泡排序排完一趟是最大值冒出来了，那么可不可以先选定一个值，然后扫描待排序序列，把小于该值的记录和大于该值的记录分成两个单独的序列，然后分别对这两个序列进行上述操作。这就是快速排序，我们把选定的那个值称为枢纽值，如果枢纽值为序列中的最大值，那么一趟快速排序就变成了一趟冒泡排序。
</code></pre>

<h5>3.2 代码</h5>

<pre><code>两种版本，第一种是参考《数据结构》，在网上这种写法很流行。第二种是参考《算法导论》，实现起来较复杂。

//快速排序（两端交替着向中间扫描）
void quickSort1(int *a,int low,int high)
{
    int pivotkey=a[low];//以a[low]为枢纽值
    int i=low,j=high;
    if(low&gt;=high)
        return;
    //一趟快速排序
    while(i&lt;j){//双向扫描
        while(i &lt; j &amp;&amp; a[j] &gt;= pivotkey)
            j--;
        a[i]=a[j];
        while(i &lt; j &amp;&amp; a[i] &lt;= pivotkey)
            i++;
        a[j]=a[i];
    }
    a[i]=pivotkey;//放置枢纽值
    //分别对左边、右边排序
    quickSort1(a,low,i-1); 
    quickSort1(a,i+1,high); 
}

//快速排序（以最后一个记录的值为枢纽值，单向扫描数组）
void quickSort2(int *a,int low,int high)
{
    int pivotkey=a[high];//以a[high]为枢纽值
    int i=low-1,temp,j;
    if(low&gt;=high)
        return;
    //一趟快速排序
    for(j=low;j&lt;high;j++){
        if(a[j]&lt;=pivotkey){
            i++;
            temp=a[i];
            a[i]=a[j];
            a[j]=temp;
        }
    }
    i++;
    //放置枢纽值
    temp=a[i];
    a[i]=pivotkey;
    a[high]=temp;
    //分别对左边、右边排序
    quickSort2(a,low,i-1); 
    quickSort2(a,i+1,high); 
}
</code></pre>

<p>快速排序算法：</p>

<p>快速排序法</p>

<pre><code> static void Main(string[] args)
        {

            //5次比较
            for (int i = 1; i &lt;= 5; i++)
            {
                List&lt;int&gt; list = new List&lt;int&gt;();
                //插入200个随机数到数组中 
                for (int j = 0; j &lt; 200; j++)
                {
                    Thread.Sleep(1);
                    list.Add(new Random((int)DateTime.Now.Ticks).Next(0, 10000));
                }
                Console.WriteLine("\n第" + i + "次比较：");
                Stopwatch watch = new Stopwatch();
                watch.Start();
                var result = list.OrderBy(single =&gt; single).ToList();
                watch.Stop();
                Console.WriteLine("\n系统定义的快速排序耗费时间：" + watch.ElapsedMilliseconds);
                Console.WriteLine("输出前是十个数:" + string.Join(",", result.Take(10).ToList()));
                watch.Start();
                new QuickSortClass().QuickSort(list, 0, list.Count - 1);
                watch.Stop();
                Console.WriteLine("\n俺自己写的快速排序耗费时间：" + watch.ElapsedMilliseconds);
                Console.WriteLine("输出前是十个数:" + string.Join(",", list.Take(10).ToList()));
                Console.ReadKey();
            }
        }

 public class QuickSortClass
    {

        ///&lt;summary&gt; 
        ////// 分割函数 
        ///&lt;/summary&gt; 
        //////&lt;param name="list"&gt;待排序的数组&lt;/param&gt; 
        ///&lt;param name="left"&gt;数组的左下标&lt;/param&gt; 
        //////&lt;param name="right"&gt;&lt;/param&gt; 
        ///&lt;returns&gt;&lt;/returns&gt;
         public int Division(List&lt;int&gt; list, int left, int right) 
         { 
             //首先挑选一个基准元素 
             int baseNum = list[left]; 
             while (left &lt; right) 
             { 
                 //从数组的右端开始向前找，一直找到比base小的数字为止(包括base同等数) 
                 while (left &lt; right &amp;&amp; list[right] &gt;= baseNum) 
                     right = right - 1; 
                 //最终找到了比baseNum小的元素，要做的事情就是此元素放到base的位置 
                 list[left] = list[right]; 
                 //从数组的左端开始向后找，一直找到比base大的数字为止（包括base同等数）
                 while (left &lt; right &amp;&amp; list[left] &lt;= baseNum) 
                     left = left + 1; 
                 //最终找到了比baseNum大的元素，要做的事情就是将此元素放到最后的位置 
                 list[right] = list[left];
             }
             //最后就是把baseNum放到该left的位置 
             list[left] = baseNum;
             //最终，我们发现left位置的左侧数值部分比left小，left位置右侧数值比left大 
             //至此，我们完成了第一篇排序 
             return left;
         }
        public void QuickSort(List&lt;int&gt; list, int left, int right)
        { 
            //左下标一定小于右下标，否则就超越了 
            if (left &lt; right) 
            { 
                //对数组进行分割，取出下次分割的基准标号 
                int i = Division(list, left, right);
                //对“基准标号“左侧的一组数值进行递归的切割，以至于将这些数值完整的排序 
                QuickSort(list, left, i - 1); 
                //对“基准标号“右侧的一组数值进行递归的切割，以至于将这些数值完整的排序
                QuickSort(list, i + 1, right);
            }
        }
    }
</code></pre>

<h5>3.3 效率分析</h5>

<p> 快速排序时间与划分是否对称有关。快速排序的平均时间复杂度为o（n<em>logn），至于为什么是o（n</em>logn），请参考《算法导论》第7章，书中用递归树的方法阐述了快速排序平均时间。且常数因子很小，所以就平均时间而言，快速排序是很好的内部排序方法。最佳情况下（每次划分都对称）时间复杂度o（n*logn）。最坏情况下（每次划分都不对称，如输入的序列有序或者逆序时）时间复杂度为o(n<sup>2</sup>)，所以在待排序序列有序或逆序时不宜选用快速排序。此外，快速排序是不稳定的。</p>

<p> 最佳情况下，每次划分都是对称的，由于枢纽值不再考虑，所以得到的两个子问题的大小不可能大于n/2，同时一趟快速排序时间为o（n），所以运行时间递归表达式：</p>

<pre><code>T（n）&lt;=2T(n/2)+o(n)。
</code></pre>

<p>这个递归式的解法请参考下一篇博客中归并排序效率分析。其解为T（n）=o（n*logn）。</p>

<p> 最坏情况下，每次划分都很不对称，T(n)=T(n-1)+o(n),可以用递归树来解，第i层的代价为n-i+1.总共有n层。把每一层代价加起来有n-1个n相加。所以这个递归式的解为T（n）=o（n<sup>2</sup>）,此时就是冒泡排序。</p>
</div>
  
  




| <a href="/blog/2014/05/20/paixu/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/05/keyoc/">常用关键字汇总</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><p>在做iOS开发中，系统的各个关键字处处都是，但是未必每一个关键字都是那么的明白，所以罗列出一些关键字供大家互相学习，有不完善之处请指正，谢谢</p>

<table>
<thead>
<tr>
<th> 关键字 </th>
<th style="text-align:center;"> 总结</th>
</tr>
</thead>
<tbody>
<tr>
<td> atomic    </td>
<td style="text-align:center;"> atomic是Objc使用的一种线程保护技术，基本上来讲，是防止在写未完成的时候被另外一个线程读取，造成数据错误。而这种机制是耗费系统资源的，所以在iPhone这种小型设备上，如果没有使用多线程间的通讯编程，那么nonatomic是一个非常好的选择。</td>
</tr>
<tr>
<td> super </td>
<td style="text-align:center;"> 调用父类的方法</td>
</tr>
<tr>
<td> readonly  </td>
<td style="text-align:center;"> 说明属性是只读的，默认的标记是读写</td>
</tr>
<tr>
<td> readwrite </td>
<td style="text-align:center;"> 说明属性会被当成读写的，这也是默认属性</td>
</tr>
<tr>
<td> retain    </td>
<td style="text-align:center;"> 释放旧的对象，将旧对象的值赋予输入对象，再提高输入对象的索引计数为1</td>
</tr>
<tr>
<td> self</td>
<td style="text-align:center;">     是隐藏参数，指向当前调用方法的类</td>
</tr>
<tr>
<td> setter    </td>
<td style="text-align:center;"> 设置指定的set方法</td>
</tr>
<tr>
<td> getter    </td>
<td style="text-align:center;"> 设置指定的get方法</td>
</tr>
<tr>
<td> property</td>
<td style="text-align:center;">     设置成员变量的属性（有读／写，赋值assign,retain,copy ,以及对多线程的支持 nonatomic）</td>
</tr>
<tr>
<td> end   </td>
<td style="text-align:center;"> 类的头文件或者实现文件的结束</td>
</tr>
<tr>
<td> copy</td>
<td style="text-align:center;">     建立一个索引计数为1的对象，然后释放旧对象 </td>
</tr>
<tr>
<td> assign    </td>
<td style="text-align:center;"> 简单赋值，不更改引用计数</td>
</tr>
<tr>
<td> synthesize    </td>
<td style="text-align:center;"> 根据@property设置，自动生成成员变量相应的存取方法，从而可以使用点操作符来方便的存取该成员变量</td>
</tr>
<tr>
<td> import    </td>
<td style="text-align:center;"> 告诉预处理器,将头文件的内容包含到本文件中</td>
</tr>
<tr>
<td> dynamic   </td>
<td style="text-align:center;"> 告诉编译器由我们自己来实现访问方法</td>
</tr>
<tr>
<td> nonatomic </td>
<td style="text-align:center;"> 非原子性访问，对属性赋值的时候不加锁，多线程并发访问会提高性能</td>
</tr>
<tr>
<td> implementation</td>
<td style="text-align:center;">   表明类的实现</td>
</tr>
<tr>
<td> strong    </td>
<td style="text-align:center;"> 强引用，只要最后一个strong型指针不再指向对象，那么对象就会被释放，同时所有的weak型指针都将会被清除</td>
</tr>
<tr>
<td> weak  </td>
<td style="text-align:center;"> 弱引用</td>
</tr>
<tr>
<td> __strong  </td>
<td style="text-align:center;"> 是缺省的关键词</td>
</tr>
<tr>
<td> __weak    </td>
<td style="text-align:center;"> 声明了一个可以自动nil化的弱引用</td>
</tr>
<tr>
<td> __unsafe_unretained</td>
<td style="text-align:center;">  声明一个弱应用，但是不会自动nil化，也就是说，如果所指向的内存区域被释放了，这个指针就是一个野指针了</td>
</tr>
<tr>
<td> __autoreleasing   </td>
<td style="text-align:center;"> 用来修饰一个函数的参数，这个参数会在函数返回的时候被自动释放</td>
</tr>
<tr>
<td> unsafe_unretained 弱引用，容易生成野指针，尽量少用unsafe_unretained关键字</td>
<td></td>
</tr>
<tr>
<td> synchronized  </td>
<td style="text-align:center;"> 方法加锁</td>
</tr>
</tbody>
</table>

</div>
  
  




| <a href="/blog/2014/05/05/keyoc/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/04/14/nscache%20nsdictionary/">NSCache&NSDcitionary你了解多少？</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><p>NSCache</p>

<p>NSCache是系统提供的一种类似于集合（NSMutableDictionary）的缓存，它与集合的不同如下：</p>

<ol>
<li><p>NSCache具有自动删除的功能，以减少系统占用的内存；</p></li>
<li><p>NSCache是线程安全的，不需要加线程锁；</p></li>
<li><p>键对象不会像 NSMutableDictionary 中那样被复制。（键不需要实现 NSCopying 协议）。</p></li>
</ol>


<h5>NSCache的属性以及方法介绍：</h5>

<pre><code>@property NSUInteger totalCostLimit;
</code></pre>

<p>设置缓存占用的内存大小，并不是一个严格的限制，当总数超过了totalCostLimit设定的值，系统会清除一部分缓存，直至总消耗低于totalCostLimit的值。</p>

<pre><code>@property NSUInteger countLimit;
</code></pre>

<p>设置缓存对象的大小，这也不是一个严格的限制。</p>

<pre><code>- (id)objectForKey:(id)key;
</code></pre>

<p>获取缓存对象，基于key-value对</p>

<pre><code>- (void)setObject:(id)obj forKey:(id)key; // 0 cost
</code></pre>

<p>存储缓存对象，考虑缓存的限制属性；</p>

<pre><code>- (void)setObject:(id)obj forKey:(id)key cost:(NSUInteger)g;
</code></pre>

<p>存储缓存对象，cost是提前知道该缓存对象占用的字节数，也会考虑缓存的限制属性，建议直接使用  - (void)setObject:(id)obj forKey:(id)key;</p>

<h5>NSCacheDelegate代理</h5>

<p>代理属性声明如下：</p>

<pre><code>@property (assign) id&lt;NSCacheDelegate&gt;delegate;
</code></pre>

<p>实现了NSCacheDelegate代理的对象，在缓存对象即将被清理的时候，系统回调代理方法如下：</p>

<pre><code>- (void)cache:(NSCache *)cache willEvictObject:(id)obj;
</code></pre>

<p>第一个参数是当前缓存（NSCache），不要修改该对象；</p>

<p>第二个参数是当前将要被清理的对象，如果需要存储该对象，可以在此操作（存入Sqlite or CoreData）;</p>

<p>该代理方法的调用会在缓存对象即将被清理的时候调用，如下场景会调用：</p>

<ol>
<li><ul>
<li>(void)removeObjectForKey:(id)key; 手动删除对象；</li>
</ul>
</li>
<li><p>缓存对象超过了NSCache的属性限制；（countLimit 和 totalCostLimit ）</p></li>
<li><p>App进入后台会调用；</p></li>
<li><p>系统发出内存警告；</p></li>
</ol>


<h5>NSDiscardableContent协议</h5>

<p>NSDiscardableContent是一个协议，实现这个协议的目的是为了让我们的对象在不被使用时，可以将其丢弃，以让程序占用更少的内存。</p>

<p>一个NSDiscardableContent对象的生命周期依赖于一个“counter”变量。一个NSDiscardableContent对象实际是一个可清理内存块，这个内存记录了对象当前是否被其它对象使用。如果这块内存正在被读取，或者仍然被需要，则它的counter变量是大于或等于1的；当它不再被使用时，就可以丢弃，此时counter变量将等于0。当counter变量等于0时，如果当前时间点内存比较紧张的话，内存块就可能被丢弃。这点类似于MRC&amp;ARC，对象内存回收机制。</p>

<pre><code>- (void)discardContentIfPossible
</code></pre>

<p>当counter等于0的时候，为了丢弃这些对象，会调用这个方法。</p>

<p>默认情况下，NSDiscardableContent对象的counter变量初始值为1，以确保对象不会被内存管理系统立即释放。</p>

<pre><code>- (BOOL)beginContentAccess    (counter++)
</code></pre>

<p>调用该方法，对象的counter会加1；</p>

<p>与beginContentAccess相对应的是endContentAccess。如果可丢弃内存不再被访问时调用。其声明如下：</p>

<pre><code>- (void)endContentAccess  （counter--）
</code></pre>

<p>该方法会减少对象的counter变量，通常是让对象的counter值变回为0，这样在对象的内容不再被需要时，就要以将其丢弃。</p>

<p>NSCache类提供了一个属性，来标识缓存是否自动舍弃那些内存已经被丢弃的对象(默认该属性为YES)，其声明如下：</p>

<pre><code>@property BOOL evictsObjectsWithDiscardedContent
</code></pre>

<p>如果设置为YES，则在对象的内存被丢弃时舍弃对象。</p>

<p>个人建议：如果需要使用缓存，直接用系统的NSCache就OK了，不要做死。</p>

<h4>区别：</h4>

<p>NSCache</p>

<ul>
<li>(1)可以存储(当然是使用内存)</li>
<li>(2)保持强应用, 无视垃圾回收. =>这一点同 NSMutableDictionary</li>
<li>(3)有固定客户.</li>
</ul>


<hr />

<pre><code>+---------------------------+------------------------------+
| NSCache | NSMutableDictionary |
+---------------------------+------------------------------+
| NSDiscardableContent | NSObject |
+---------------------------+------------------------------+
</code></pre>

<p>下面是 UIImageView+AFNetworking的使用:</p>

<pre><code>@interface AFImageCache :NSCache
- (UIImage *)cachedImageForRequest:(NSURLRequest *)request;
- (void)cacheImage:(UIImage *)image
forRequest:(NSURLRequest *)request;
@end
</code></pre>

<p>NSURLCache</p>

<p>iOS5 之前是不能通过NSURLCache使用硬盘缓存的,所以有SDURLCache这样的library来实现硬盘缓存. iOS5可以使用NSURLCache的硬盘缓存, 只要符合http-cache-control-header即可.
这里有详细的说明:here
这也就是说不用做任何操作, 系统将自动完成满足缓存条件的request.</p>

<p>映射关系:</p>

<pre><code>+---------------------------+---------------------------------+
| NSURLRequest ----|----&gt; NSCachedURLResponse |
+---------------------------+---------------------------------+
</code></pre>

<p>通过这样的映射关系实现缓存. 这里存的是NSCachedURLResponse. 也就是说这里的NSURLCache也是一个类似于NSCache的容器.
只不过data是NSCachedURLResponse对象. 并不是类似于image这样的data.</p>

<p>这篇文章可以的: NSURLCache使用心得here
我测试了一下UIImage->NSData->URL,NSURLConnection, UIWebView不同时候调用</p>

<pre><code>- (NSCachedURLResponse *)cachedResponseForRequest:(NSURLRequest *)request;
-(void)storeCachedResponse:(NSCachedURLResponse *)cachedResponse forRequest:(NSURLRequest *)request;
</code></pre>

<p>的情况:</p>

<pre><code>+-------------+---------------------+----------------------+------------------+
| | UIImage-&gt;URL | NSURLConnection | UIWebView |
+---------+---+---------------------+----------------------+------------------+
| | c | X | first called | first called | 
|1’s time |---+---------------------+----------------------+------------------+
| | s | first called | second called | second called | 
+---------+---+---------------------+----------------------+------------------+
| | c | X | first called | first called | 
|2’s time +---+---------------------+----------------------+------------------+
| | s | first called | X | X | 
+---------+---+---------------------+----------------------+------------------+
</code></pre>

<blockquote><p>注意</p></blockquote>

<pre><code>* c 表示 cachedResponseForRequest
* s 表示 storeCachedResponse
* X 表示不被调用
</code></pre>

<p>结果显示: UIImage->URL 是同步的请求. 因为cachedResponseForRequest不能发起同步请求来请求网络.</p>
</div>
  
  




| <a href="/blog/2014/04/14/nscache%20nsdictionary/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/04/11/fu-wu-qi-da-jian/">服务器搭建</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><h3>一、简单说明</h3>

<p>说明：提前下载好相关软件，且安装目录最好安装在全英文路径下。如果路径有中文名，那么可能会出现一些莫名其妙的问题。</p>

<p>提示：提前准备好的软件</p>

<ul>
<li><p>apache-tomcat-6.0.41.tar</p></li>
<li><p>eclipse-jee-kepler-SR2-macosx-cocoa-x86_64.tar.gz</p></li>
<li><p>jdk-8u5-macosx-x64.dmg</p></li>
</ul>


<h3>二、安装和配置本地服务器环境（java）步骤：</h3>

<ul>
<li>(1)在文档路径下，新建一个文件夹（NetWord），解压eclipse压缩包文件</li>
</ul>


<p><img src="/images/fuwuqi001.png" title="Caption" ></p>

<ul>
<li>(2)先安装jdk</li>
</ul>


<p><img src="/images/fuwuqi002.png" title="Caption" ></p>

<ul>
<li>(3)点击安装eclipse，设置工作空间，点击确定。</li>
</ul>


<p><img src="/images/fuwuqi003.png" title="Caption" ></p>

<p>设置工作空间
<img src="/images/fuwuqi004.png" title="Caption" ></p>

<p><img src="/images/fuwuqi0004.png" title="Caption" ></p>

<ul>
<li>(4)把提前写好的服务器代码，拷贝到工作空间中。</li>
</ul>


<p> <img src="/images/fuwuqi005.png" title="Caption" ></p>

<p> <img src="/images/fuwuqi006.png" title="Caption" ></p>

<ul>
<li><p>(5)导入项目，导入已经存在的项目到工作空间中。
<img src="/images/fuwuqi007.png" title="Caption" ><br/>
<img src="/images/fuwuqi008.png" title="Caption" ><br/>
<img src="/images/fuwuqi009.png" title="Caption" ></p></li>
<li><p>(6)导入项目之后，项目报错且格式乱码，下面进行调整。</p></li>
</ul>


<p><img src="/images/fuwuqi010.png" title="Caption" ><br/>
<img src="/images/fuwuqi011.png" title="Caption" ><br/>
<img src="/images/fuwuqi012.png" title="Caption" ></p>

<ul>
<li><p>(7)配置容器，apache-tomcat.</p>

<p> <img src="/images/fuwuqi013.png" title="Caption" >    <br/>
<img src="/images/fuwuqi014.png" title="Caption" ></p></li>
</ul>


<p> <img src="/images/fuwuqi015.png" title="Caption" ></p>

<p>点击ok。创建一个新的容器</p>

<p><img src="/images/fuwuqi016.png" title="Caption" ></p>

<p>选择容器的路径</p>

<p><img src="/images/fuwuqi017.png" title="Caption" ></p>

<p>安装好后显示如下：</p>

<p><img src="/images/fuwuqi018.png" title="Caption" ></p>

<ul>
<li>(8)启动服务器。以debug的方式启动，方便做一些调试</li>
</ul>


<p><img src="/images/fuwuqi019.png" title="Caption" ></p>

<p>测试：server已经成功启动。</p>

<p><img src="/images/fuwuqi020.png" title="Caption" ></p>

<ul>
<li>(9)部署程序</li>
</ul>


<p><img src="/images/fuwuqi021.png" title="Caption" ></p>

<p><img src="/images/fuwuqi022.png" title="Caption" ></p>

<p><img src="/images/fuwuqi023.png" title="Caption" ></p>

<ul>
<li>(10)在火狐浏览器中输入服务器的地址，访问项目</li>
</ul>


<p><img src="/images/fuwuqi024.png" title="Caption" ></p>

<p>至此本地服务器环境搭建完成。</p>

<h3>访问服务器的资源</h3>

<p><img src="/images/fuwuqi025.png" title="Caption" ></p>

<p><img src="/images/fuwuqi026.png" title="Caption" ></p>

<p>使用模拟器上的浏览器也可以访问本地服务器。输入地址192.168.1.53：8080/MJServer</p>

<p>补充：浏览器打开页面，文字乱码调整。</p>

<p><img src="/images/fuwuqi027.png" title="Caption" ></p>
</div>
  
  




| <a href="/blog/2014/04/11/fu-wu-qi-da-jian/#comments">更多评论</a>

    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/7">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/5">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
    <h1>文章分类</h1>
    <ul id="categories">
        <li class='category'><a href='/blog/categories/全栈工程师必备/'>全栈工程师必备 (2)</a></li>
<li class='category'><a href='/blog/categories/底层开发/'>底层开发 (4)</a></li>
<li class='category'><a href='/blog/categories/开发工具/'>开发工具 (2)</a></li>
<li class='category'><a href='/blog/categories/性能相关/'>性能相关 (6)</a></li>
<li class='category'><a href='/blog/categories/性能问题/'>性能问题 (4)</a></li>
<li class='category'><a href='/blog/categories/新技术/'>新技术 (1)</a></li>
<li class='category'><a href='/blog/categories/欢迎来到ios梦工厂/'>欢迎来到ios梦工厂 (1)</a></li>
<li class='category'><a href='/blog/categories/程序员必备/'>程序员必备 (3)</a></li>
<li class='category'><a href='/blog/categories/适配问题/'>适配问题 (1)</a></li>
<li class='category'><a href='/blog/categories/面试总结-技术/'>面试总结＋技术 (1)</a></li>
<li class='category'><a href='/blog/categories/面试汇总/'>面试汇总 (1)</a></li>
<li class='category'><a href='/blog/categories/项目实战/'>项目实战 (17)</a></li>
<li class='category'><a href='/blog/categories/高级开发/'>高级开发 (25)</a></li>

    </ul>
</section><section>
  <h1>最新文章</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/12/10/h5ying-yong-shi-zhan/">H5应用实战</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/12/10/core-image-chu-tan/">Core Image 初探</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/12/09/wan-zheng-ding-shi-qi/">玩转定时器</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/12/09/shi-jian-chu-li-yu-tu-xiang-xuan-ran-shen-jiu/">事件处理与图像渲染深究</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/12/08/watch-os2-chu-tan/">Watch OS2 初探</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/al1020119">@al1020119</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'al1020119',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>




<section>
<h1>扫一扫<abbr title="The word '扫一扫' is a registered trademark of DENSO WAVE INCORPORATED. It applies only for the word '扫一扫', not for image.">&trade;</abbr></h1>
<a href="http://al1020119.github.io/posts/6/index.html"><img src="http://chart.apis.google.com/chart?chs=150x150&cht=qr&chld=|0&chco=165B94&chl=http://al1020119.github.io/posts/6/index.html" alt="post-qrcode"></a></section>
<section>
    <h1>访客统计</h1>
    <br/>
    <a href="http://s07.flagcounter.com/more/2SH"><img src="http://s07.flagcounter.com/count/2SH/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_1/flags_0/" alt="Flag Counter" border="0"></a>
</section><section>
    <h1>新浪微博</h1>
    <ul id="weibo">
        <li>
            
            <!-- 在此插入获得的微博秀代码 -->
            <iframe width="100%" height="550" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=550&fansRow=2&ptype=1&speed=0&skin=1&isTitle=1&noborder=1&isWeibo=1&isFans=1&uid=3288975567&verifier=20ffcedd&dpc=1"></iframe>
            
        </li>
    </ul>
</section>
  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - iCocos -
<span class="credit">Preview in <a href="http://al1020119.github.io">[曹#黎]</a></span>
</p>

</footer>
  






<!--
--->



</body>
</html>
