
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>iOS梦工厂</title>
  <meta name="author" content="iCocos">

  
  <meta name="description" content="独一无二 ordinal WWDC 2013已经闭幕，IOS7 Beta随即发布，界面之难看无以言表&hellip;,简直就是山寨Android。 更让IOS程序猿悲催的是，设备唯一标识的MAC Address在IOS7中也失效了。 IOS系统中，获取设备唯一标识的方法有很多： 一.UDID( &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://al1020119.github.io/posts/6/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="iOS梦工厂" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//libs.baidu.com/jquery/1.7.2/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <script>
function addBlankTargetForLinks () {
    $('a[href^="http"]').each(function(){
                              $(this).attr('target', '_blank');
                              });
}
$(document).bind('DOMNodeInserted', function(event) {
             addBlankTargetForLinks();
             });
</script>
  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">iOS梦工厂</a></h1>
  
    <h2>不战胜自己，何以改变未来！</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="al1020119.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">首页</a></li>
  <li><a href="/blog/archives">归档</a></li>
  <li><a href="/icocos">iCocos</a></li>
  <li><a href="/other">其他</a></li>
  <li><a href="/about">关于</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/08/14/unio/">独一无二</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><p>WWDC 2013已经闭幕，IOS7 Beta随即发布，界面之难看无以言表&hellip;,简直就是山寨Android。</p>

<p>更让IOS程序猿悲催的是，设备唯一标识的MAC Address在IOS7中也失效了。</p>

<p>IOS系统中，获取设备唯一标识的方法有很多：</p>

<h5>一.UDID(Unique Device Identifier)</h5>

<pre><code> UDID的全称是Unique Device Identifier，顾名思义，它就是苹果IOS设备的唯一识别码，它由40个字符的字母和数字组成。
</code></pre>

<h5>二.UUID(Universally Unique Identifier)</h5>

<pre><code>UUID是Universally Unique Identifier的缩写,中文意思是通用唯一识别码.
</code></pre>

<h5>三.MAC Address</h5>

<h5>四.OPEN UDID</h5>

<h5>五.广告标示符（IDFA-identifierForIdentifier）</h5>

<h5>六.Vindor标示符 (IDFV-identifierForVendor)</h5>

<p>Vendor是CFBundleIdentifier（反转DNS格式）的前两部分。来自同一个运营商的应用运行在同一个设备上，此属性的值是相同的；不同的运营商应用运行在同一个设备上值不同。</p>

<p>经测试，只要设备上有一个tencent的app，重新安装后的identifierForVendor值不变，如果tencent的app全部删除，重新安装后的identifierForVendor值改变。</p>

<p>但是很不幸，上面所有这些表示设备唯一号的标识，在IOS7中要么被禁止使用，要么重新安装程序后两次获取的标识符不一样。</p>

<p>由于IOS系统存储的数据都是在sandBox里面，一旦删除App，sandBox也不复存在。好在有一个例外，那就是keychain（钥匙串）。</p>

<p>通常情况下，IOS系统用NSUserDefaults存储数据信息，但是对于一些私密信息，比如密码、证书等等，就需要使用更为安全的keychain了。</p>

<p>keychain里保存的信息不会因App被删除而丢失。所以，可以利用这个keychain这个特点来保存设备唯一标识。</p>

<p>那么，如何在应用里使用使用keyChain呢，我们需要导入Security.framework ，keychain的操作接口声明在头文件SecItem.h里。</p>

<p>直接使用SecItem.h里方法操作keychain，需要写的代码较为复杂，我们可以使用已经封装好了的工具类KeychainItemWrapper来对keychain进行操作。</p>

<p>KeychainItemWrapper是apple官方例子“GenericKeychain”里一个访问keychain常用操作的封装类，在官网上下载了GenericKeychain项目后，</p>

<p>只需要把“KeychainItemWrapper.h”和“KeychainItemWrapper.m”拷贝到我们项目，并导入Security.framework 。KeychainItemWrapper的用法：</p>

<pre><code>/** 初始化一个保存用户帐号的KeychainItemWrapper */
KeychainItemWrapper *wrapper = [[KeychainItemWrapper alloc] initWithIdentifier:@"Account Number"
                                                                   accessGroup:@"YOUR_APP_ID_HERE.com.yourcompany.AppIdentifier"];  

//保存数据
[wrapper setObject:@"&lt;帐号&gt;" forKey:(id)kSecAttrAccount];    

[wrapper setObject:@"&lt;帐号密码&gt;" forKey:(id)kSecValueData];    

//从keychain里取出帐号密码
NSString *password = [wrapper objectForKey:(id)kSecValueData];      

//清空设置
[wrapper resetKeychainItem];
</code></pre>

<p>其中方法“- (void)setObject:(id)inObject forKey:(id)key;”里参数“forKey”的值应该是Security.framework 里头文件“SecItem.h”里定义好的key，用其他字符串做key程序会出错！</p>
</div>
  
  




| <a href="/blog/2014/08/14/unio/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/07/25/netall/">网络开发总结</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><h3>一、一个HTTP请求的基本要素</h3>

<p>1.请求URL：客户端通过哪个路径找到服务器</p>

<p>2.请求参数：客户端发送给服务器的数据</p>

<ul>
<li>比如登录时需要发送的用户名和密码</li>
</ul>


<p>3.返回结果：服务器返回给客户端的数据</p>

<ul>
<li>一般是JSON数据或者XML数据</li>
</ul>


<h3>二、基本的HTTP请求的步骤（移动客户端）</h3>

<p>1.拼接"请求URL" + &ldquo;?&rdquo; + &ldquo;请求参数&rdquo;</p>

<ul>
<li>请求参数的格式：参数名=参数值</li>
<li>多个请求参数之间用&amp;隔开：参数名1=参数值1&amp;参数名2=参数值2</li>
<li>比如：<a href="http://localhost:8080/MJServer/login?username=123&amp;pwd=456">http://localhost:8080/MJServer/login?username=123&amp;pwd=456</a></li>
</ul>


<p>2.发送请求</p>

<p>3.解析服务器返回的数据</p>

<h3>三、JSON解析</h3>

<p>1.利用NSJSONSerialization类解析</p>

<ul>
<li>JSON数据（NSData） &ndash;> Foundation-OC对象（NSDictionary、NSArray、NSString、NSNumber）</li>
<li>(id)JSONObjectWithData:(NSData *)data options:(NSJSONReadingOptions)opt error:(NSError **)error;</li>
</ul>


<p>2.JSON解析规律</p>

<ul>
<li>{ } &ndash;> NSDictionary @{ }</li>
<li>[ ] &ndash;> NSArray @[ ]</li>
<li>&ldquo; &rdquo; &ndash;> NSString @&ldquo; &rdquo;</li>
<li>10 &ndash;> NSNumber @10</li>
</ul>


<h3>四、NSURLConnection</h3>

<p>1.发布异步请求01&ndash;block回调</p>

<pre><code>+ (void)sendAsynchronousRequest:(NSURLRequest*) request
    queue:(NSOperationQueue*) queue
    completionHandler:(void (^)(NSURLResponse* response, NSData* data, NSError* connectionError)) handler
</code></pre>

<ul>
<li>request : 需要发送的请求</li>
<li>queue : 一般用主队列，存放handler这个任务</li>
<li>handler : 当请求完毕后，会自动调用这个block</li>
</ul>


<p>2.利用NSURLConnection发送请求的基本步骤
1> 创建URL</p>

<pre><code>NSURL *url = [NSURL URLWithString:@"http://4234324/5345345"];
</code></pre>

<p>2> 创建request</p>

<pre><code>NSURLRequest *request = [NSURLRequest requestWithURL:url];
</code></pre>

<p>3> 发送请求</p>

<pre><code>[NSURLConnection sendAsynchronousRequest:request queue:queue completionHandler:
 ^(NSURLResponse *response, NSData *data, NSError *connectionError) {
4&gt; 处理服务器返回的数据

 }];
</code></pre>

<h3>五、XML</h3>

<p>1.语法
1> 文档声明</p>

<pre><code>&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
</code></pre>

<p>2> 元素
3> 属性</p>

<pre><code>&lt;videos&gt;
    &lt;video name="小黄人 第01部" length="10"/&gt;
    &lt;video name="小黄人 第01部" length="10"/&gt;
&lt;/videos&gt;
</code></pre>

<ul>
<li>videos和video是元素（节点）</li>
<li>name和length叫做元素的属性</li>
<li>video元素是videos元素的子元素</li>
</ul>


<p>2.解析
1> SAX解析：逐个元素往下解析，适合大文件</p>

<ul>
<li>NSXMLParser</li>
</ul>


<p>2> DOM解析：一口气将整个XML文档加载进内存，适合小文件，使用最简单</p>

<ul>
<li>GDataXML</li>
</ul>


<h3>六、HTTP的通信过程</h3>

<p>1.请求
1> 请求行 : 请求方法、请求路径、HTTP协议的版本</p>

<pre><code>GET /MJServer/resources/images/1.jpg HTTP/1.1
</code></pre>

<p>2> 请求头 : 客户端的一些描述信息</p>

<ul>
<li>User-Agent : 客户端的环境（软件环境）</li>
</ul>


<p>3> 请求体 : POST请求才有这个东西</p>

<ul>
<li>请求参数，发给服务器的数据</li>
</ul>


<p>2.响应
1> 状态行（响应行）: HTTP协议的版本、响应状态码、响应状态描述</p>

<p>HTTP/1.1 200 OK</p>

<p>2> 响应头：服务器的一些描述信息</p>

<ul>
<li>Content-Type : 服务器返回给客户端的内容类型</li>
<li>Content-Length : 服务器返回给客户端的内容的长度（比如文件的大小）</li>
</ul>


<p>3> 实体内容（响应体）</p>

<ul>
<li>服务器返回给客户端具体的数据，比如文件数据</li>
</ul>


<p>七、HTTP的请求方法
1.GET
1> 特点</p>

<ul>
<li>所有请求参数都拼接在url后面</li>
</ul>


<p>2> 缺点</p>

<ul>
<li>在url中暴露了所有的请求数据，不太安全</li>
<li>url的长度有限制，不能发送太多的参数</li>
</ul>


<p>3> 使用场合</p>

<ul>
<li>如果仅仅是向服务器索要数据，一般用GET请求</li>
</ul>


<p>4> 如何发送一个GET请求</p>

<pre><code>* 默认就是GET请求
// 1.URL

NSURL *url = [NSURL URLWithString:@"http://www.baidu.com"];
// 2.请求

NSURLRequest *request = [NSURLRequest requestWithURL:url];
// 3.发送请求

[NSURLConnection sendAsynchronousRequest:request queue:[NSOperationQueue mainQueue] completionHandler:^(NSURLResponse *response, NSData *data, NSError *connectionError) {
}];
</code></pre>

<p>2.POST
1> 特点</p>

<ul>
<li>把所有请求参数放在请求体（HTTPBody）中</li>
<li>理论上讲，发给服务器的数据的大小是没有限制</li>
</ul>


<p>2> 使用场合</p>

<ul>
<li>除开向服务器索要数据以外的请求，都可以用POST请求</li>
<li>如果发给服务器的数据是一些隐私、敏感的数据，绝对要用POST请求</li>
</ul>


<p>3> 如何发送一个POST请求
    // 1.创建一个URL ： 请求路径</p>

<pre><code>NSURL *url = [NSURL URLWithString:@"http://localhost:8080/MJServer/login"];

// 2.创建一个请求

NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url];
// 设置请求方法
request.HTTPMethod = @"POST";
// 设置请求体 : 请求参数
NSString *param = [NSString stringWithFormat:@"username=%@&amp;pwd=%@", usernameText, pwdText];
// NSString --&gt; NSData
request.HTTPBody = [param dataUsingEncoding:NSUTF8StringEncoding];
</code></pre>

<h3>八、NSMutableURLRequest的常用方法</h3>

<p>1.设置超时
    request.timeoutInterval = 5;
    // NSURLRequest是不能设置超时的，因为这个对象是不可变的</p>

<h3>九、URL转码</h3>

<p>1.URL中不能包含中文，得对中文进行转码(加上一堆的%)</p>

<pre><code>NSString *urlStr = [NSString stringWithFormat:@"http://localhost/login?username=喝喝&amp;pwd=123"];
urlStr = [urlStr stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];
// urlStr == @"http://localhost/login?username=%E5%96%9D%E5%96%9D&amp;pwd=123"
</code></pre>

<h3>十、数据安全</h3>

<p>1.网络数据加密
1> 加密对象：隐私数据，比如密码、银行信息
2> 加密方案</p>

<ul>
<li>提交隐私数据，必须用POST请求</li>
<li><p>使用加密算法对隐私数据进行加密，比如MD5
3> 加密增强：为了加大破解的难度</p></li>
<li><p>对明文进行2次MD5 ： MD5(MD5($pass))</p></li>
<li>先对明文撒盐，再进行MD5 ： MD5($pass.$salt)</li>
</ul>


<p>2.本地存储加密</p>

<p>1> 加密对象：重要的数据，比如游戏数据</p>

<p>3.代码安全问题</p>

<p>1> 现在已经有工具和技术能反编译出源代码：逆向工程</p>

<ul>
<li>反编译出来的都是纯C语言的，可读性不高</li>
<li>最起码能知道源代码里面用的是哪些框架</li>
</ul>


<p>2> 参考书籍：《iOS逆向工程》</p>

<p>3> 解决方案：发布之前对代码进行混淆</p>

<p> 混淆之前</p>

<pre><code>@interface iCocosPerson :NSObject
- (void)run;
- (void)eat;
@end
</code></pre>

<p> 混淆之后</p>

<pre><code>@interface A :NSObject
- (void)a;
- (void)b;
@end
</code></pre>

<p>十一、监测网络状态</p>

<p>1.主动监测监测网络状态</p>

<pre><code>// 是否WIFI

+ (BOOL)isEnableWIFI {
    return ([[Reachability reachabilityForLocalWiFi] currentReachabilityStatus] != NotReachable);
}


// 是否3G

+ (BOOL)isEnable3G {
    return ([[Reachability reachabilityForInternetConnection] currentReachabilityStatus] != NotReachable);
}
</code></pre>

<p>2.监控网络状态</p>

<p>1> 监听通知</p>

<pre><code>[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(networkStateChange) name:kReachabilityChangedNotification object:nil];
</code></pre>

<p>2> 开始监听网络状态</p>

<pre><code>// 获得Reachability对象
self.reachability = [Reachability reachabilityForInternetConnection];
// 开始监控网络
[self.reachability startNotifier];
</code></pre>

<p>3> 移除监听</p>

<pre><code>[self.reachability stopNotifier];
[[NSNotificationCenter defaultCenter] removeObserver:self];
</code></pre>

<p>————————————————————————————————————————————————————————————————————————————————————————</p>

<h3>一、大文件下载</h3>

<p>1.方案：利用NSURLConnection和它的代理方法
1> 发送一个请求</p>

<pre><code>// 1.URL

NSURL *url = [NSURL URLWithString:@"http://localhost:8080/MJServer/resources/videos.zip"];
// 2.请求

NSURLRequest *request = [NSURLRequest requestWithURL:url];
// 3.下载(创建完conn对象后，会自动发起一个异步请求)

[NSURLConnection connectionWithRequest:request delegate:self];
</code></pre>

<p>2> 在代理方法中处理服务器返回的数据</p>

<pre><code>/**
 在接收到服务器的响应时：
 1.创建一个空的文件
 2.用一个句柄对象关联这个空的文件，目的是：方便后面用句柄对象往文件后面写数据
 */

- (void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response

{

    // 文件路径

    NSString *caches = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject];

    NSString *filepath = [caches stringByAppendingPathComponent:@"videos.zip"];



    // 创建一个空的文件 到 沙盒中

    NSFileManager *mgr = [NSFileManager defaultManager];

    [mgr createFileAtPath:filepath contents:nil attributes:nil];



    // 创建一个用来写数据的文件句柄

    self.writeHandle = [NSFileHandle fileHandleForWritingAtPath:filepath];

}


/**
 在接收到服务器返回的文件数据时，利用句柄对象往文件的最后面追加数据
 */

- (void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data

{

    // 移动到文件的最后面

    [self.writeHandle seekToEndOfFile];



    // 将数据写入沙盒

    [self.writeHandle writeData:data];

}


/**
 在所有数据接收完毕时，关闭句柄对象
 */

- (void)connectionDidFinishLoading:(NSURLConnection *)connection

{

    // 关闭文件

    [self.writeHandle closeFile];

    self.writeHandle = nil;

}
</code></pre>

<p>2.注意点：千万不能用NSMutableData来拼接服务器返回的数据</p>

<h3>二、NSURLConnection发送异步请求的方法</h3>

<p>1.block形式 - 除开大文件下载以外的操作，都可以用这种形式</p>

<pre><code>[NSURLConnection sendAsynchronousRequest:&lt;#(NSURLRequest *)#&gt; queue:&lt;#(NSOperationQueue *)#&gt; completionHandler:^(NSURLResponse *response, NSData *data, NSError *connectionError) {
}];
</code></pre>

<p>2.代理形式 - 一般用在大文件下载</p>

<pre><code>// 1.URL

NSURL *url = [NSURL URLWithString:@"http://localhost:8080/MJServer/login?username=123&amp;pwd=123"];
// 2.请求

NSURLRequest *request = [NSURLRequest requestWithURL:url];
// 3.下载(创建完conn对象后，会自动发起一个异步请求)

[NSURLConnection connectionWithRequest:request delegate:self];
</code></pre>

<h3>三、NSURLSession</h3>

<p>1.使用步骤</p>

<p>1> 获得NSURLSession对象
2> 利用NSURLSession对象创建对应的任务（Task）
3> 开始任务（[task resume]）</p>

<p>2.获得NSURLSession对象</p>

<p>1> [NSURLSession sharedSession]</p>

<p>2></p>

<pre><code>NSURLSessionConfiguration *cfg = [NSURLSessionConfiguration defaultSessionConfiguration];
self.session = [NSURLSession sessionWithConfiguration:cfg delegate:self delegateQueue:[NSOperationQueue mainQueue]];
</code></pre>

<p>3.任务类型</p>

<h6>1> NSURLSessionDataTask</h6>

<p>用途：用于非文件下载的GET\POST请求</p>

<pre><code>NSURLSessionDataTask *task = [self.session dataTaskWithRequest:request];
NSURLSessionDataTask *task = [self.session dataTaskWithURL:url];
NSURLSessionDataTask *task = [self.session dataTaskWithURL:url completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
}];
</code></pre>

<h6>2> NSURLSessionDownloadTask</h6>

<p>用途：用于文件下载（小文件、大文件）</p>

<pre><code>NSURLSessionDownloadTask *task = [self.session downloadTaskWithRequest:request];
NSURLSessionDownloadTask *task = [self.session downloadTaskWithURL:url];
NSURLSessionDownloadTask *task = [self.session downloadTaskWithURL:url completionHandler:^(NSURL *location, NSURLResponse *response, NSError *error) {   
}];
</code></pre>

<p> ————————————————————————————————————————————————————————————————</p>

<h2>AFN与ASI的区别（面试用）</h2>

<h3>一、底层实现</h3>

<p>1> AFN的底层基于OC的NSURLConnection和NSURLSession
2> ASI的底层基于纯C语言的CFNetwork框架
3> ASI的运行性能 高于 AFN</p>

<h3>二、对服务器返回的数据处理</h3>

<p>1> ASI没有直接提供对服务器数据处理的方式，直接返回data\string
2> AFN提供了多种对服务器数据处理的方式</p>

<ul>
<li>JSON处理</li>
<li>XML处理</li>
<li>其他处理</li>
</ul>


<h3>三、监听请求的过程</h3>

<p>1> AFN提供了success和failure两个block来监听请求的过程（只能监听成功和失败）</p>

<ul>
<li>success : 请求成功后调用</li>
<li>failure : 请求失败后调用</li>
</ul>


<p>2> ASI提供了3套方案，每一套方案都能监听请求的完整过程
（监听请求开始、接收到响应头信息、接受到具体数据、接受完毕、请求失败）</p>

<ul>
<li>成为代理，遵守协议，实现协议中的代理方法</li>
<li>成为代理，不遵守协议，自定义代理方法</li>
<li>设置block</li>
</ul>


<h3>四、在文件下载和文件上传的使用难易度</h3>

<p>1> AFN</p>

<ul>
<li>不容易监听下载进度和上传进度</li>
<li>不容易实现断点续传</li>
<li>一般只用来下载不大的文件</li>
</ul>


<p>2> ASI</p>

<ul>
<li>非常容易实现下载和上传</li>
<li>非常容易监听下载进度和上传进度</li>
<li>非常容易实现断点续传</li>
<li>下载或大或小的文件都行</li>
</ul>


<h3>五、ASI提供了更多的实用功能</h3>

<p>1> 控制圈圈要不要在请求过程中转
2> 可以轻松地设置请求之间的依赖：每一个请求都是一个NSOperation对象
3> 可以统一管理所有请求（还专门提供了一个叫做ASINetworkQueue来管理所有的请求对象）</p>

<ul>
<li>暂停\恢复\取消所有的请求</li>
<li>监听整个队列中所有请求的下载进度和上传进度</li>
</ul>

</div>
  
  




| <a href="/blog/2014/07/25/netall/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/07/23/netuse/">网络请求初探</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><p>今天来说说关于iOS开发过程中的网络请求。</p>

<p>关于网络请求的重要性我想不用多说了吧。对于移动客户端来说，网络的重要性不言而喻。常见的网络请求有同步GET， 同步POST， 异步GET， 异步POST。今天来看一下四种网络请求的实现方式。</p>

<p>一、同步GET</p>

<pre><code>// 1.将网址初始化成一个OC字符串对象
NSString *urlStr = [NSString stringWithFormat:@"%@?query=%@®ion=%@&amp;output=json&amp;ak=6E823f587c95f0148c19993539b99295", kBusinessInfoURL, @"银行", @"济南"];
// 如果网址中存在中文,进行URLEncode
NSString *newUrlStr = [urlStr stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];
// 2.构建网络URL对象, NSURL
NSURL *url = [NSURL URLWithString:newUrlStr];
// 3.创建网络请求
NSURLRequest *request = [NSURLRequest requestWithURL:url cachePolicy:NSURLRequestReloadIgnoringLocalCacheData timeoutInterval:10];
// 创建同步链接
NSURLResponse *response = nil;
NSError *error = nil;
NSData *data = [NSURLConnection sendSynchronousRequest:request returningResponse:&amp;response error:&amp;error];
</code></pre>

<p>当创建好同步链接以后， 就可以采用相应的方法进行解析。下面创建异步连接也是一样的。</p>

<p>二、同步POST</p>

<pre><code>// 1.根据网址初始化OC字符串对象
    NSString *urlStr = [NSString stringWithFormat:@"%@", kVideoURL];
    // 2.创建NSURL对象
    NSURL *url = [NSURL URLWithString:urlStr];
    // 3.创建请求
    NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url];
    // 4.创建参数字符串对象
    NSString *parmStr = @"method=album.channel.get&amp;appKey=myKey&amp;format=json&amp;channel=t&amp;pageNo=1&amp;pageSize=10";
    // 5.将字符串转为NSData对象
    NSData *pramData = [parmStr dataUsingEncoding:NSUTF8StringEncoding];
    // 6.设置请求体
    [request setHTTPBody:pramData];
    // 7.设置请求方式
    [request setHTTPMethod:@"POST"];

    // 创建同步链接
    NSData *data = [NSURLConnection sendSynchronousRequest:request returningResponse:nil error:nil];
三、异步GET

    NSString *urlStr = [NSString stringWithFormat:@"http://image.zcool.com.cn/56/13/1308200901454.jpg"];
    NSString *newStr = [urlStr stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];
    NSURL *url = [NSURL URLWithString:newStr];
    NSURLRequest *requst = [NSURLRequest requestWithURL:url cachePolicy:NSURLRequestReloadIgnoringLocalCacheData timeoutInterval:10];
    //异步链接(形式1,较少用)
    [NSURLConnection sendAsynchronousRequest:requst queue:[NSOperationQueue mainQueue] completionHandler:^(NSURLResponse *response, NSData *data, NSError *connectionError) {
        self.imageView.image = [UIImage imageWithData:data];
        // 解析
        NSDictionary *dic = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableContainers error:nil];
        NSLog(@"%@", dic);
    }];
</code></pre>

<p>四、异步POST</p>

<pre><code>// POST请求
    NSString *urlString = [NSString stringWithFormat:@"%@",kVideoURL];
    //创建url对象
    NSURL *url = [NSURL URLWithString:urlString];
    //创建请求
    NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url cachePolicy:NSURLRequestReloadIgnoringLocalCacheData timeoutInterval:10];
    //创建参数字符串对象
    NSString *parmStr = [NSString stringWithFormat:@"method=album.channel.get&amp;appKey=myKey&amp;format=json&amp;channel=t&amp;pageNo=1&amp;pageSize=10"];
    //将字符串转换为NSData对象
    NSData *data = [parmStr dataUsingEncoding:NSUTF8StringEncoding];
    [request setHTTPBody:data];
    [request setHTTPMethod:@"POST"];
    //创建异步连接（形式二）
    [NSURLConnection connectionWithRequest:request delegate:self];
</code></pre>

<p>一般的，当创建异步连接时， 很少用到第一种方式，经常使用的是代理方法。关于NSURLConnectionDataDelegate，我们经常使用的协议方法为一下几个：</p>

<pre><code>// 服务器接收到请求时
- (void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response
{
}
// 当收到服务器返回的数据时触发, 返回的可能是资源片段
- (void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data
{
}
// 当服务器返回所有数据时触发, 数据返回完毕
- (void)connectionDidFinishLoading:(NSURLConnection *)connection
{
}
// 请求数据失败时触发
- (void)connection:(NSURLConnection *)connection didFailWithError:(NSError *)error
{
    NSLog(@"%s", __FUNCTION__);
}
</code></pre>

<p>最后，分析一下这几种呢网络请求的区别。</p>

<h6>GET请求和POST请求的区别：</h6>

<ol>
<li><p>GET请求的接口会包含参数部分，参数会作为网址的一部分，服务器地址与参数之间通过 ? 来间隔。POST请求会将服务器地址与参数分开，请求接口中只有服务器地址，而参数会作为请求的一部分，提交后台服务器。</p></li>
<li><p>GET请求参数会出现在接口中，不安全。而POST请求相对安全。</p></li>
<li><p>虽然GET请求和POST请求都可以用来请求和提交数据，但是一般的GET多用于从后台请求数据，POST多用于向后台提交数据。</p></li>
</ol>


<h6>同步和异步的区别：</h6>

<ul>
<li><p>同步链接：主线程去请求数据，当数据请求完毕之前，其他线程一律不响应，会造成程序就假死现象。</p></li>
<li><p>异步链接：会单独开一个线程去处理网络请求，主线程依然处于可交互状态,程序运行流畅。</p></li>
</ul>

</div>
  
  




| <a href="/blog/2014/07/23/netuse/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/07/19/uiview-calayer-uiscreenuiwindow/">面试会问到的？</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><h4>1、UIScreen可以获取设备屏幕的大小。</h4>

<pre><code>// 整个屏幕的大小
CGRect bounds = [UIScreen mainScreen].bounds;
NSLog(@"UIScreen bounds: %@", NSStringFromCGRect(bounds));
</code></pre>

<p><code>{0, 0, 320, 480}</code></p>

<pre><code>// 应用程序窗口大小 
CGRect applicationFrame = [UIScreen mainScreen].applicationFrame;
NSLog(@"UIScreen applicationFrame: %@", NSStringFromCGRect(applicationFrame));
</code></pre>

<p><code>{0, 20, 320, 460}</code></p>

<h4>2、UIView对象定义了一个屏幕上的一个矩形区域，同时处理该区域的绘制和触屏事件。</h4>

<p>可以在这个区域内绘制图形和文字，还可以接收用户的操作。一个UIView的实例可以包含和管理若干个子UIView。</p>

<p>ViewController.m</p>

<pre><code>-(void)viewDidAppear:(BOOL)animated

{

    [super
 viewDidAppear:animated];

    UIView*
 myView = [[UIView alloc] initWithFrame:CGRectMake(10, 10, 100, 100)];

    myView.backgroundColor=[UIColor
 redColor];

    [self.view
 addSubview:myView];

}
</code></pre>

<h4>3、UIWindow对象是所有UIView的根，管理和协调的应用程序的显示</h4>

<p>UIWindow类是UIView的子类，可以看作是特殊的UIView。一般应用程序只有一个UIWindow对象，即使有多个UIWindow对象，也只有一个UIWindow可以接受到用户的触屏事件。</p>

<p>AppDelegate.m</p>

<pre><code>-
 (BOOL)application:(UIApplication
 *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions

{

    UIWindow
 *myWindow = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];

    myWindow.backgroundColor=[UIColor
 whiteColor];

    [myWindow
 makeKeyAndVisible];

    _window
 = myWindow;

    return

YES;

}
</code></pre>

<p> ####4、UIViewController对象负责管理所有UIView的层次结构，并响应设备的方向变化。</p>

<p>AppDelegate.m</p>

<pre><code>-
 (BOOL)application:(UIApplication
 *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions

{

    UIWindow
 *myWindow = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];

    myWindow.backgroundColor=[UIColor
 whiteColor];

    UIViewController
 *myViewController = [[UIViewController alloc] initWithNibName:nil bundle:nil];

    myWindow.rootViewController
 = myViewController;

    [myWindow
 makeKeyAndVisible];

    _window
 = myWindow;

    return

YES;

}
</code></pre>

<h4>CALayer是在/System/Library/Frameworks/QuartzCore.framework定义的。而且CALayer作为一个低级的，可以承载绘制内容的底层对象出现在该框架中。</h4>

<p>现在比较一下uiview和calayer都可以显示图片文字等信息。难道apple提供了，两套绘图机制吗？不会。</p>

<p> UIView相比CALayer最大区别是UIView可以响应用户事件，而CALayer不可以。UIView侧重于对显示内容的管理，CALayer侧重于对内容的绘制。</p>

<p> 大家都知道QuartzCore是IOS中提供图像绘制的基础库。并且CALayer是定义该框架中。难道UIView的底层实现是CALayer？？</p>

<p>官方做出了明确的解释：</p>

<pre><code>Core Animation doesn't provide a means for actually displaying layers in a window, they must be hosted by a view. When paired with a view, the view must provide event-handling for the underlying layers, while the layers provide display of the content.

The view system in iOS is built directly on top of Core Animation layers. Every instance of UIView automatically creates an instance of a CALayer class and sets it as the value of the view’s layer property. You can add sublayers to the view’s layer as needed.

On Mac OS X you must configure an NSView instance in such a way that it can host a layer.
</code></pre>

<p>由此可见UIView是基于CALayer的高层封装。The view system in iOS is built directly on top of Core Animation layers.</p>

<blockquote><p>结论：
 UIView来自CALayer，高于CALayer，是CALayer高层实现与封装。UIView的所有特性来源于CALayer支持。</p></blockquote>
</div>
  
  




| <a href="/blog/2014/07/19/uiview-calayer-uiscreenuiwindow/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/07/12/popkeyboard/">你是怎么退出键盘的？</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><p>iOS开发中键盘的退出方法用很多中我们应该在合适的地方使用合适的方法才能更好的提高开发的效率和应用的性能</p>

<p>下面给大家介绍几种最常用的键盘退出方法，基本上iOS开发中的键盘退出方法都是这几种中的一种活着几种。</p>

<p>一：textView</p>

<pre><code>//通过委托来实现放弃第一响应者
#pragma mark - UITextView Delegate  Method
-(BOOL)textView:(UITextView *)textView shouldChangeTextInRange:(NSRange)range replacementText:(NSString *)text
{
    if([text isEqualToString:@"\n"]) {
        [textView resignFirstResponder];
        return NO;
    }
    return YES;
}
</code></pre>

<p>二：textFiled</p>

<pre><code>//通过委托来实现放弃第一响应者
#pragma mark - UITextField Delegate Method
- (BOOL)textFieldShouldReturn:(UITextField *)textField
{
    [textField resignFirstResponder];
    return YES;
}
</code></pre>

<p>三：触摸屏幕</p>

<pre><code>1 ／／所有的界面都可以实现
2 -(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event
3 {
4     [self.view endEditing:YES];
5 }
</code></pre>

<p>四：ScrollView拖拽</p>

<pre><code> 1 -(void)scrollViewWillBeginDragging:(UIScrollView *)scrollView 
 2 { 
 3      [self.view endEditing:YES]; 
 4 } 
</code></pre>

<blockquote><p>注：结合使用endEditing和resignFirstResponder</p></blockquote>

<p>五：通知方式</p>

<p>注册与移除通知</p>

<pre><code>-(void) viewWillAppear:(BOOL)animated {

    //注册键盘出现通知
    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector (keyboardDidShow:)
                                                 name: UIKeyboardDidShowNotification object:nil];
    //注册键盘隐藏通知
    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector (keyboardDidHide:)
                                                 name: UIKeyboardDidHideNotification object:nil];
    [super viewWillAppear:animated];
}


-(void) viewWillDisappear:(BOOL)animated {
    //解除键盘出现通知
    [[NSNotificationCenter defaultCenter] removeObserver:self
                                                    name: UIKeyboardDidShowNotification object:nil];
    //解除键盘隐藏通知
    [[NSNotificationCenter defaultCenter] removeObserver:self
                                                    name: UIKeyboardDidHideNotification object:nil];

    [super viewWillDisappear:animated];
}
</code></pre>

<p>实现通知的方法：</p>

<pre><code>-(void) keyboardDidShow: (NSNotification *)notif {

    if (keyboardVisible) {//键盘已经出现要忽略通知
        return;
    }
    // 获得键盘尺寸
    NSDictionary* info = [notif userInfo];
    NSValue* aValue = [info objectForKey:UIKeyboardFrameEndUserInfoKey];
    CGSize keyboardSize = [aValue CGRectValue].size;

    //重新定义ScrollView的尺寸
    CGRect viewFrame = self.scrollView.frame;
    viewFrame.size.height -= (keyboardSize.height);
    self.scrollView.frame = viewFrame;

    //滚动到当前文本框
    CGRect textFieldRect = [self.textField frame];
    [self.scrollView scrollRectToVisible:textFieldRect animated:YES];

    keyboardVisible = YES;
}

-(void) keyboardDidHide: (NSNotification *)notif {

    NSDictionary* info = [notif userInfo];
    NSValue* aValue = [info objectForKey:UIKeyboardFrameEndUserInfoKey];
    CGSize keyboardSize = [aValue CGRectValue].size;

    CGRect viewFrame = self.scrollView.frame;
    viewFrame.size.height += keyboardSize.height;
    self.scrollView.frame = viewFrame;

    if (!keyboardVisible) {
        return;
    }

    keyboardVisible = NO;

}
</code></pre>
</div>
  
  




| <a href="/blog/2014/07/12/popkeyboard/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/25/data%20model/">数据与模型</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><p>/******************************************************************************/</p>

<h3>一:简单plist读取</h3>

<p>1:定义一个数组用来保存读取出来的plist数据</p>

<pre><code> 1 @property (nonatomic, strong) NSArray *shops; 
</code></pre>

<p>2:使用懒加载的方式加载plist文件，并且放到数组中</p>

<pre><code>// 懒加载

// 1.第一次用到时再去加载

// 2.只会加载一次

- (NSArray *)shops

{

    if (_shops == nil) {

        // 获得plist文件的全路径

        NSString *file = [[NSBundle mainBundle] pathForResource:@"shops.plist" ofType:nil];



        // 从plist文件中加载一个数组对象

        _shops = [NSArray arrayWithContentsOfFile:file];

    }

    return _shops;

}
</code></pre>

<p>3:使用数组中的数据</p>

<pre><code>// 设置数据

1 NSDictionary *shop = self.shops[index];
2 
3 iconView.image = [UIImage imageNamed:shop[@"icon"]];
4 
5 nameLabel.text = shop[@"name"];
</code></pre>

<p>/******************************************************************************/</p>

<h3>二：字典转模型</h3>

<h6>1:创建一个model类并且在里面创建对应的模型属性</h6>

<pre><code>/** 名字 */

 1 @property (nonatomic, strong) NSString *name; 

/** 图标 */

 1 @property (nonatomic, strong) NSString *icon; 
</code></pre>

<h6>2:定义一个数组用来保存读取出来的plist数据</h6>

<pre><code> 1 @property (nonatomic, strong) NSMutableArray *shops; 
</code></pre>

<h6>3:使用懒加载的方式加载plist文件，并且放到模型中</h6>

<pre><code>// 懒加载

// 1.第一次用到时再去加载

// 2.只会加载一次

- (NSMutableArray *)shops

{

    if (_shops == nil) {

        // 创建"模型数组"

        _shops = [NSMutableArray array];



        // 获得plist文件的全路径

        NSString *file = [[NSBundle mainBundle] pathForResource:@"shops.plist" ofType:nil];



        // 从plist文件中加载一个数组对象(这个数组中存放的都是NSDictionary对象)

        NSArray *dictArray = [NSArray arrayWithContentsOfFile:file];



        // 将 “字典数组” 转换为 “模型数据”

        for (NSDictionary *dict in dictArray) { // 遍历每一个字典

            // 将 “字典” 转换为 “模型”

            Shop *shop = [[Shop alloc] init];

            shop.name = dict[@"name"];

            shop.icon = dict[@"icon"];



            // 将 “模型” 添加到 “模型数组中”

            [_shops addObject:shop];

        }

    }

    return _shops;

}
</code></pre>

<p>4:使用模型中的数据</p>

<pre><code>// 设置数据 
Shop *shop = self.shops[index];

iconView.image = [UIImage imageNamed:shop.icon];

nameLabel.text = shop.name;
</code></pre>

<p>/******************************************************************************/</p>

<h3>三：字典转模型封装</h3>

<h6>1:创建一个model类并且在里面创建对应的模型属性，定义两个模型方法</h6>

<pre><code>/** 名字 */

@property (nonatomic, copy) NSString *name;

/** 图标 */

@property (nonatomic, copy) NSString *icon;



/** 通过一个字典来初始化模型对象 */

- (instancetype)initWithDict:(NSDictionary *)dict;



/** 通过一个字典来创建模型对象 */

+ (instancetype)shopWithDict:(NSDictionary *)dict;
</code></pre>

<h6>2:模型方法的实现</h6>

<pre><code>- (instancetype)initWithDict:(NSDictionary *)dict

{

    if (self = [super init]) {

        self.name = dict[@"name"];

        self.icon = dict[@"icon"];

    }

    return self;

}



+ (instancetype)shopWithDict:(NSDictionary *)dict

{

    // 这里要用self

    return [[self alloc] initWithDict:dict];

} 
</code></pre>

<h6>3:定义一个数组用来保存读取出来的plist数据</h6>

<pre><code> 1 @property (nonatomic, strong) NSMutableArray *shops; 
</code></pre>

<h6>4:使用懒加载的方式加载plist文件，并且放到模型中</h6>

<pre><code>// 懒加载

// 1.第一次用到时再去加载

// 2.只会加载一次
- (NSMutableArray *)shops

{

    if (_shops == nil) {

        // 创建"模型数组"

        _shops = [NSMutableArray array];



        // 获得plist文件的全路径

        NSString *file = [[NSBundle mainBundle] pathForResource:@"shops.plist" ofType:nil];



        // 从plist文件中加载一个数组对象(这个数组中存放的都是NSDictionary对象)

        NSArray *dictArray = [NSArray arrayWithContentsOfFile:file];



        // 将 “字典数组” 转换为 “模型数据”

        for (NSDictionary *dict in dictArray) { // 遍历每一个字典

            // 将 “字典” 转换为 “模型”

            XMGShop *shop = [XMGShop shopWithDict:dict];



            // 将 “模型” 添加到 “模型数组中”

            [_shops addObject:shop];

        }

    }

    return _shops;

}
</code></pre>

<h6>5:使用模型中的数据</h6>

<pre><code>// 设置数据

XMGShop *shop = self.shops[index];

iconView.image = [UIImage imageNamed:shop.icon];

nameLabel.text = shop.name;
</code></pre>

<p>/******************************************************************************/</p>

<h3>四：自定义View</h3>

<h6>1:创建一个model类并且在里面创建对应的模型属性，定义两个模型方法</h6>

<pre><code>/** 名字 */

@property (nonatomic, copy) NSString *name;

/** 图标 */

@property (nonatomic, copy) NSString *icon;



/** 通过一个字典来初始化模型对象 */

- (instancetype)initWithDict:(NSDictionary *)dict;



/** 通过一个字典来创建模型对象 */

+ (instancetype)shopWithDict:(NSDictionary *)dict;
</code></pre>

<h6>2:模型方法的实现</h6>

<pre><code>- (instancetype)initWithDict:(NSDictionary *)dict

{

    if (self = [super init]) {

        self.name = dict[@"name"];

        self.icon = dict[@"icon"];

    }

    return self;

}



+ (instancetype)shopWithDict:(NSDictionary *)dict

{

    // 这里要用self

    return [[self alloc] initWithDict:dict];

}
</code></pre>

<h6>3:自定义一个View，引入模型类，并且创建模型类的属性</h6>

<pre><code>@class XMGShop;



/** 商品模型 */

@property (nonatomic, strong) XMGShop *shop;
</code></pre>

<h6>4:实现文件中，定义相应的控件属性</h6>

<pre><code>/** 图片 */

@property (nonatomic, weak) UIImageView *iconView;



/** 名字 */

@property (nonatomic, weak) UILabel *nameLabel;
</code></pre>

<h6>5:实现自定义View的相应方法</h6>

<pre><code>- (instancetype)init

{

    if (self = [super init]) {

        // 添加一个图片

        UIImageView *iconView = [[UIImageView alloc] init];

        [self addSubview:iconView];

        self.iconView = iconView;



        // 添加一个文字

        UILabel *nameLabel = [[UILabel alloc] init];

        nameLabel.textAlignment = NSTextAlignmentCenter;

        [self addSubview:nameLabel];

        self.nameLabel = nameLabel;

    }

    return self;

}



/**

 * 这个方法专门用来布局子控件，设置子控件的frame

 */

- (void)layoutSubviews

{

    // 一定要调用super方法

    [super layoutSubviews];



    CGFloat shopW = self.frame.size.width;

    CGFloat shopH = self.frame.size.height;



    self.iconView.frame = CGRectMake(0, 0, shopW, shopW);

    self.nameLabel.frame = CGRectMake(0, shopW, shopW, shopH - shopW);

}



-(void)setShop:(XMGShop *)shop

{

    _shop = shop;



    self.iconView.image = [UIImage imageNamed:shop.icon];

    self.nameLabel.text = shop.name;

}
</code></pre>

<h6>6:定义一个数组用来保存读取出来的plist数据</h6>

<pre><code> 1 @property (nonatomic, strong) NSMutableArray *shops; 
</code></pre>

<h6>7:使用懒加载的方式加载plist文件，并且放到模型中</h6>

<pre><code>// 懒加载

// 1.第一次用到时再去加载

// 2.只会加载一次

- (NSMutableArray *)shops

{

    if (_shops == nil) {

        // 创建"模型数组"

        _shops = [NSMutableArray array];



        // 获得plist文件的全路径

        NSString *file = [[NSBundle mainBundle] pathForResource:@"shops.plist" ofType:nil];



        // 从plist文件中加载一个数组对象(这个数组中存放的都是NSDictionary对象)

        NSArray *dictArray = [NSArray arrayWithContentsOfFile:file];



        // 将 “字典数组” 转换为 “模型数据”

        for (NSDictionary *dict in dictArray) { // 遍历每一个字典

            // 将 “字典” 转换为 “模型”

            XMGShop *shop = [XMGShop shopWithDict:dict];



            // 将 “模型” 添加到 “模型数组中”

            [_shops addObject:shop];

        }

    }

    return _shops;

} 
</code></pre>

<h6>8:使用View</h6>

<pre><code>// 创建一个商品父控件

XMGShopView *shopView = [[XMGShopView alloc] init];

shopView.frame = CGRectMake(shopX, shopY, shopW, shopH);

// 将商品父控件添加到shopsView中

[self.shopsView addSubview:shopView];




/**



NSDictionary *dict = nil; // 从其他地方加载的字典



 XMGShop *shop = [XMGShop shopWithDict:dict];



 XMGShopView *shopView = [[XMGShopView alloc] init];

 shopView.shop = shop;

 shopView.frame = CGRectMake(0, 0, 70, 100);

 [self.view addSubview:shopView];






 // 扩展性差

 // 扩展好的体现：即使改变了需求。我们也不需要动大刀子

 */
</code></pre>

<p>/******************************************************************************/</p>

<h3>五：initWithFrame</h3>

<p>1:在上一步的基础上只要修改init方法为</p>

<pre><code>/** init方法内部会自动调用initWithFrame:方法 */

- (instancetype)initWithFrame:(CGRect)frame

{

    if (self = [super initWithFrame:frame]) {

        // 添加一个图片

        UIImageView *iconView = [[UIImageView alloc] init];

        [self addSubview:iconView];

        self.iconView = iconView;



        // 添加一个文字

        UILabel *nameLabel = [[UILabel alloc] init];

        nameLabel.textAlignment = NSTextAlignmentCenter;

        [self addSubview:nameLabel];

        self.nameLabel = nameLabel;

    }

    return self;

}
</code></pre>

<p>2:最后设置数据的时候也可以使用下面的方法实现View的创建</p>

<pre><code> 1 XMGShopView *shopView = [[XMGShopView alloc] initWithFrame:CGRectMake(shopX, shopY, shopW, shopH)]; 
</code></pre>

<p>/******************************************************************************/</p>

<h3>六：MVC</h3>

<h6>1:model</h6>

<pre><code>@interface XMGShop : NSObject

/** 名字 */

@property (nonatomic, copy) NSString *name;

/** 图标 */

@property (nonatomic, copy) NSString *icon;

/** 通过一个字典来初始化模型对象 */

- (instancetype)initWithDict:(NSDictionary *)dict;



/** 通过一个字典来创建模型对象 */

+ (instancetype)shopWithDict:(NSDictionary *)dict;

@end






@implementation XMGShop



- (instancetype)initWithDict:(NSDictionary *)dict

{

    if (self = [super init]) {

        self.name = dict[@"name"];

        self.icon = dict[@"icon"];

    }

    return self;

}



+ (instancetype)shopWithDict:(NSDictionary *)dict

{

    // 这里要用self

    return [[self alloc] initWithDict:dict];

}



@end
</code></pre>

<h6>2:view</h6>

<pre><code>@class XMGShop;



@interface XMGShopView : UIView

/** 商品模型 */

@property (nonatomic, strong) XMGShop *shop;



- (instancetype)initWithShop:(XMGShop *)shop;

+ (instancetype)shopViewWithShop:(XMGShop *)shop;

+ (instancetype)shopView;

@end






@interface XMGShopView()

/** 图片 */

@property (nonatomic, weak) UIImageView *iconView;



/** 名字 */

@property (nonatomic, weak) UILabel *nameLabel;

@end



@implementation XMGShopView



- (instancetype)initWithShop:(XMGShop *)shop

{

    if (self = [super init]) {

        self.shop = shop;

    }

    return self;

}



+ (instancetype)shopViewWithShop:(XMGShop *)shop

{

    return [[self alloc] initWithShop:shop];

}



+ (instancetype)shopView

{

    return [[self alloc] init];

}



/** init方法内部会自动调用initWithFrame:方法 */

- (instancetype)initWithFrame:(CGRect)frame

{

    if (self = [super initWithFrame:frame]) {

        // 添加一个图片

        UIImageView *iconView = [[UIImageView alloc] init];

        [self addSubview:iconView];

        self.iconView = iconView;



        // 添加一个文字

        UILabel *nameLabel = [[UILabel alloc] init];

        nameLabel.textAlignment = NSTextAlignmentCenter;

        [self addSubview:nameLabel];

        self.nameLabel = nameLabel;

    }

    return self;

}



/**

 * 当前控件的frame发生改变的时候就会调用

 * 这个方法专门用来布局子控件，设置子控件的frame

 */

- (void)layoutSubviews

{

    // 一定要调用super方法

    [super layoutSubviews];



    CGFloat shopW = self.frame.size.width;

    CGFloat shopH = self.frame.size.height;



    self.iconView.frame = CGRectMake(0, 0, shopW, shopW);

    self.nameLabel.frame = CGRectMake(0, shopW, shopW, shopH - shopW);

}



- (void)setShop:(XMGShop *)shop

{

    _shop = shop;



    self.iconView.image = [UIImage imageNamed:shop.icon];

    self.nameLabel.text = shop.name;

}



@end
</code></pre>

<h6>controller</h6>

<pre><code>@property (nonatomic, strong) NSMutableArray *shops;







// 懒加载

// 1.第一次用到时再去加载

// 2.只会加载一次

- (NSMutableArray *)shops

{

    if (_shops == nil) {

        // 创建"模型数组"

        _shops = [NSMutableArray array];



        // 获得plist文件的全路径

        NSString *file = [[NSBundle mainBundle] pathForResource:@"shops.plist" ofType:nil];



        // 从plist文件中加载一个数组对象(这个数组中存放的都是NSDictionary对象)

        NSArray *dictArray = [NSArray arrayWithContentsOfFile:file];



        // 将 “字典数组” 转换为 “模型数据”

        for (NSDictionary *dict in dictArray) { // 遍历每一个字典

            // 将 “字典” 转换为 “模型”

            XMGShop *shop = [XMGShop shopWithDict:dict];



            // 将 “模型” 添加到 “模型数组中”

            [_shops addObject:shop];

        }

    }

    return _shops;

}



// 创建一个商品父控件

XMGShopView *shopView = [XMGShopView shopViewWithShop:self.shops[index]];

// 设置frame

shopView.frame = CGRectMake(shopX, shopY, shopW, shopH);

// 将商品父控件添加到shopsView中

[self.shopsView addSubview:shopView];
</code></pre>

<p>/******************************************************************************/</p>

<h3>七：XIB</h3>

<p>1:xibView中</p>

<pre><code>/** 商品模型 */

@property (nonatomic, strong) XMGShop *shop;

+ (instancetype)shopViewWithShop:(XMGShop *)shop;



+ (instancetype)shopViewWithShop:(XMGShop *)shop

{

    // self == XMGShopView

    // NSStringFromClass(self) == @"XMGShopView"

    XMGShopView *shopView = [[[NSBundle mainBundle] loadNibNamed:NSStringFromClass(self) owner:nil options:nil] lastObject];

    shopView.shop = shop;

    return shopView;

}



- (void)setShop:(XMGShop *)shop

{

    _shop = shop;



    UIImageView *iconView = (UIImageView *)[self viewWithTag:1];

    iconView.image = [UIImage imageNamed:shop.icon];



    UILabel *nameLabel = (UILabel *)[self viewWithTag:2];

    nameLabel.text = shop.name;

}
</code></pre>

<h6>2:控制器中设置数据</h6>

<pre><code>// 从xib中加载一个商品控件

XMGShopView *shopView = [XMGShopView shopViewWithShop:self.shops[index]];

// 设置frame

shopView.frame = CGRectMake(shopX, shopY, shopW, shopH);

// 添加商品控件

[self.shopsView addSubview:shopView];
</code></pre>

<p>/******************************************************************************/</p>

<h3>八：MJExtension</h3>

<h6>1:是一套“字典和模型之间互相转换”的轻量级框架，模型属性</h6>

<pre><code>/**

 *  微博文本内容

 */

@property (copy, nonatomic) NSString *text;



/**

 *  微博作者

 */

@property (strong, nonatomic) User *user;



/**

 *  转发的微博

 */

@property (strong, nonatomic) Status *retweetedStatus;



/**

 *  存放着某一页微博数据（里面都是Status模型）

 */

@property (strong, nonatomic) NSMutableArray *statuses;



/**

 *  总数

 */

@property (assign, nonatomic) NSNumber *totalNumber;



/**

 *  上一页的游标

 */

@property (assign, nonatomic) long long previousCursor;



/**

 *  下一页的游标

 */

@property (assign, nonatomic) long long nextCursor;





/**

 *  名称

 */

@property (copy, nonatomic) NSString *name;



/**

 *  头像

 */

@property (copy, nonatomic) NSString *icon;
</code></pre>

<h6>2:对应方法的实现</h6>

<ul>
<li><p>1.MJExtension是一套“字典和模型之间互相转换”的轻量级框架</p></li>
<li><p>2.MJExtension能完成的功能</p>

<ul>
<li><p>字典 &ndash;> 模型</p></li>
<li><p>模型 &ndash;> 字典</p></li>
<li><p>字典数组 &ndash;> 模型数组</p></li>
<li><p>模型数组 &ndash;> 字典数组</p></li>
</ul>
</li>
<li><p>3.具体用法主要参考 main.m中各个函数 以及 &ldquo;NSObject+MJKeyValue.h&rdquo;</p></li>
<li><p>4.希望各位大神能用得爽</p>

<pre><code> #import &lt;Foundation/Foundation.h&gt;

 #import "MJExtension.h"

 #import "User.h"

 #import "Status.h"

 #import "StatusResult.h"



 /**

  *  简单的字典 -&gt; 模型

  */

 void keyValues2object()

 {

     // 1.定义一个字典

     NSDictionary *dict = @{

                            @"name" : @"Jack",

                            @"icon" : @"lufy.png",

                            };



     // 2.将字典转为User模型

     User *user = [User objectWithKeyValues:dict];



     // 3.打印User模型的属性

     NSLog(@"name=%@, icon=%@", user.name, user.icon);

 }



 /**

  *  复杂的字典 -&gt; 模型 (模型里面包含了模型)

  */

 void keyValues2object2()

 {

     // 1.定义一个字典

     NSDictionary *dict = @{

                            @"text" : @"是啊，今天天气确实不错！",



                            @"user" : @{

                                    @"name" : @"Jack",

                                    @"icon" : @"lufy.png"

                                    },



                            @"retweetedStatus" : @{

                                    @"text" : @"今天天气真不错！",



                                    @"user" : @{

                                            @"name" : @"Rose",

                                            @"icon" : @"nami.png"

                                            }

                                    }

                            };



     // 2.将字典转为Status模型

     Status *status = [Status objectWithKeyValues:dict];



     // 3.打印status的属性

     NSString *text = status.text;

     NSString *name = status.user.name;

     NSString *icon = status.user.icon;

     NSLog(@"text=%@, name=%@, icon=%@", text, name, icon);



     // 4.打印status.retweetedStatus的属性

     NSString *text2 = status.retweetedStatus.text;

     NSString *name2 = status.retweetedStatus.user.name;

     NSString *icon2 = status.retweetedStatus.user.icon;

     NSLog(@"text2=%@, name2=%@, icon2=%@", text2, name2, icon2);

 }



 /**

  *  复杂的字典 -&gt; 模型 (模型的数组属性里面又装着模型)

  */

 void keyValues2object3()

 {

     // 1.定义一个字典

     NSDictionary *dict = @{

                            @"statuses" : @[

                                    @{

                                        @"text" : @"今天天气真不错！",



                                        @"user" : @{

                                                @"name" : @"Rose",

                                                @"icon" : @"nami.png"

                                                }

                                        },



                                    @{

                                        @"text" : @"明天去旅游了",



                                        @"user" : @{

                                                @"name" : @"Jack",

                                                @"icon" : @"lufy.png"

                                                }

                                        },



                                    @{

                                        @"text" : @"嘿嘿，这东西不错哦！",



                                        @"user" : @{

                                                @"name" : @"Jim",

                                                @"icon" : @"zero.png"

                                                }

                                        }



                                    ],



                            @"totalNumber" : @"2014",



                            @"previousCursor" : @"13476589",



                            @"nextCursor" : @"13476599"

                            };



     // 2.将字典转为StatusResult模型

     StatusResult *result = [StatusResult objectWithKeyValues:dict];



     // 3.打印StatusResult模型的简单属性

     NSLog(@"totalNumber=%d, previousCursor=%lld, nextCursor=%lld", result.totalNumber, result.previousCursor, result.nextCursor);



     // 4.打印statuses数组中的模型属性

     for (Status *status in result.statuses) {

         NSString *text = status.text;

         NSString *name = status.user.name;

         NSString *icon = status.user.icon;

         NSLog(@"text=%@, name=%@, icon=%@", text, name, icon);

     }

 }



 /**

  *  字典数组 -&gt; 模型数组

  */

 void keyValuesArray2objectArray()

 {

     // 1.定义一个字典数组

     NSArray *dictArray = @[

                            @{

                                @"name" : @"Jack",

                                @"icon" : @"lufy.png",

                                },



                            @{

                                @"name" : @"Rose",

                                @"icon" : @"nami.png",

                                },



                            @{

                                @"name" : @"Jim",

                                @"icon" : @"zero.png",

                                }

                            ];



     // 2.将字典数组转为User模型数组

     NSArray *userArray = [User objectArrayWithKeyValuesArray:dictArray];



     // 3.打印userArray数组中的User模型属性

     for (User *user in userArray) {

         NSLog(@"name=%@, icon=%@", user.name, user.icon);

     }

 }



 /**

  *  模型 -&gt; 字典

  */

 void object2keyValues()

 {

     // 1.新建模型

     User *user = [[User alloc] init];

     user.name = @"Jack";

     user.icon = @"lufy.png";



     Status *status = [[Status alloc] init];

     status.user = user;

     status.text = @"今天的心情不错！";



     // 2.将模型转为字典

     //    NSDictionary *dict = [status keyValues];

     NSDictionary *dict = status.keyValues;

     NSLog(@"%@", dict);

 }



 /**

  *  模型数组 -&gt; 字典数组

  */

 void objectArray2keyValuesArray()

 {

     // 1.新建模型数组

     User *user1 = [[User alloc] init];

     user1.name = @"Jack";

     user1.icon = @"lufy.png";



     User *user2 = [[User alloc] init];

     user2.name = @"Rose";

     user2.icon = @"nami.png";



     User *user3 = [[User alloc] init];

     user3.name = @"Jim";

     user3.icon = @"zero.png";



     NSArray *userArray = @[user1, user2, user3];



     // 2.将模型数组转为字典数组

     NSArray *dictArray = [User keyValuesArrayWithObjectArray:userArray];

     NSLog(@"%@", dictArray);

 }



 int main(int argc, const char * argv[])

 {

     @autoreleasepool {

         // 简单的字典 -&gt; 模型

         keyValues2object();



         // 复杂的字典 -&gt; 模型 (模型里面包含了模型)

         keyValues2object2();



         // 复杂的字典 -&gt; 模型 (模型的数组属性里面又装着模型)

         keyValues2object3();



         // 字典数组 -&gt; 模型数组

         keyValuesArray2objectArray();



         // 模型转字典

         object2keyValues();



         // 模型数组 -&gt; 字典数组

         objectArray2keyValuesArray();

     }

     return 0;

 }
</code></pre></li>
</ul>

</div>
  
  




| <a href="/blog/2014/06/25/data%20model/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/16/runtime/">玩转运行时</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><p>运行时（Runtime）机制</p>

<p>本文将会以笔者个人的小小研究为例总结一下关于iOS开发中运行时的使用和常用方法的介绍，关于跟多运行时相关技术请查看笔者之前写的运行时高级用法及相关语法或者查看响应官方文档。</p>

<p>下面就来看看什么是运行时，我们要怎么在iOS开发中去使用它。</p>

<p>官方介绍：</p>

<p><img src="/images/runtime001.png" title="Caption" ></p>

<p><img src="/images/runtime002.png" title="Caption" ></p>

<p>这里我们主要关注的是最后一种！</p>

<p>下面来看看Runtime的相关总结</p>

<p><img src="/images/runtime003.png" title="Caption" ></p>
</div>
  
  




| <a href="/blog/2014/06/16/runtime/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/03/data%20cache/">玩转数据持久化</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><p>概论</p>

<p>所谓的持久化，就是将数据保存到硬盘中，使得在应用程序或机器重启后可以继续访问之前保存的数据。在iOS开发中，有很多数据持久化的方案，接下来我将尝试着介绍一下5种方案：</p>

<ul>
<li>plist文件（属性列表）</li>
<li>preference（偏好设置）</li>
<li>NSKeyedArchiver（归档）</li>
<li>SQLite 3</li>
<li>CoreData</li>
</ul>


<h4>沙盒</h4>

<p>在介绍各种存储方法之前，有必要说明以下沙盒机制。iOS程序默认情况下只能访问程序自己的目录，这个目录被称为“沙盒”。</p>

<h6>#1.结构</h6>

<p>既然沙盒就是一个文件夹，那就看看里面有什么吧。沙盒的目录结构如下：</p>

<pre><code>"应用程序包"
Documents
Library
    Caches
    Preferences
tmp
</code></pre>

<h6>#2.目录特性</h6>

<p>虽然沙盒中有这么多文件夹，但是没有文件夹都不尽相同，都有各自的特性。所以在选择存放目录时，一定要认真选择适合的目录。</p>

<p>&ldquo;应用程序包&rdquo;: 这里面存放的是应用程序的源文件，包括资源文件和可执行文件。</p>

<pre><code>  NSString *path = [[NSBundle mainBundle] bundlePath];
  NSLog(@"%@", path);
Documents: 最常用的目录，iTunes同步该应用时会同步此文件夹中的内容，适合存储重要数据。

  NSString *path = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject;
  NSLog(@"%@", path);
Library/Caches: iTunes不会同步此文件夹，适合存储体积大，不需要备份的非重要数据。

  NSString *path = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES).firstObject;
  NSLog(@"%@", path);
</code></pre>

<p>Library/Preferences: iTunes同步该应用时会同步此文件夹中的内容，通常保存应用的设置信息。</p>

<p>tmp: iTunes不会同步此文件夹，系统可能在应用没运行时就删除该目录下的文件，所以此目录适合保存应用中的一些临时文件，用完就删除。</p>

<pre><code>  NSString *path = NSTemporaryDirectory();
  NSLog(@"%@", path);
</code></pre>

<h4>plist文件</h4>

<p>plist文件是将某些特定的类，通过XML文件的方式保存在目录中。</p>

<p>可以被序列化的类型只有如下几种：</p>

<pre><code>NSArray;
NSMutableArray;
NSDictionary;
NSMutableDictionary;
NSData;
NSMutableData;
NSString;
NSMutableString;
NSNumber;
NSDate;
</code></pre>

<p>1.获得文件路径</p>

<pre><code>NSString *path = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject;
NSString *fileName = [path stringByAppendingPathComponent:@"123.plist"];
</code></pre>

<p>2.存储</p>

<pre><code>NSArray *array = @[@"123", @"456", @"789"];
[array writeToFile:fileName atomically:YES];
3.读取

NSArray *result = [NSArray arrayWithContentsOfFile:fileName];
NSLog(@"%@", result);
</code></pre>

<p>4.注意</p>

<p>只有以上列出的类型才能使用plist文件存储。
存储时使用writeToFile: atomically:方法。 其中atomically表示是否需要先写入一个辅助文件，再把辅助文件拷贝到目标文件地址。这是更安全的写入文件方法，一般都写YES。
读取时使用arrayWithContentsOfFile:方法。</p>

<h4>Preference</h4>

<h6>#1.使用方法</h6>

<pre><code>//1.获得NSUserDefaults文件
NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults];
//2.向文件中写入内容
[userDefaults setObject:@"AAA" forKey:@"a"];
[userDefaults setBool:YES forKey:@"sex"];
[userDefaults setInteger:21 forKey:@"age"];
//2.1立即同步
[userDefaults synchronize];
//3.读取文件
NSString *name = [userDefaults objectForKey:@"a"];
BOOL sex = [userDefaults boolForKey:@"sex"];
NSInteger age = [userDefaults integerForKey:@"age"];
NSLog(@"%@, %d, %ld", name, sex, age);
</code></pre>

<h6>#2.注意</h6>

<p>偏好设置是专门用来保存应用程序的配置信息的，一般不要在偏好设置中保存其他数据。
如果没有调用synchronize方法，系统会根据I/O情况不定时刻地保存到文件中。所以如果需要立即写入文件的就必须调用synchronize方法。
偏好设置会将所有数据保存到同一个文件中。即preference目录下的一个以此应用包名来命名的plist文件。</p>

<h4>NSKeyedArchiver</h4>

<p>归档在iOS中是另一种形式的序列化，只要遵循了NSCoding协议的对象都可以通过它实现序列化。由于决大多数支持存储数据的Foundation和Cocoa Touch类都遵循了NSCoding协议，因此，对于大多数类来说，归档相对而言还是比较容易实现的。</p>

<h6>#1.遵循NSCoding协议</h6>

<p>NSCoding协议声明了两个方法，这两个方法都是必须实现的。一个用来说明如何将对象编码到归档中，另一个说明如何进行解档来获取一个新对象。</p>

<p>遵循协议和设置属性</p>

<pre><code>  //1.遵循NSCoding协议 
  @interface Person : NSObject   //2.设置属性
  @property (strong, nonatomic) UIImage *avatar;
  @property (copy, nonatomic) NSString *name;
  @property (assign, nonatomic) NSInteger age;
  @end
</code></pre>

<p>实现协议方法</p>

<pre><code>  //解档
  - (id)initWithCoder:(NSCoder *)aDecoder {
      if ([super init]) {
          self.avatar = [aDecoder decodeObjectForKey:@"avatar"];
          self.name = [aDecoder decodeObjectForKey:@"name"];
          self.age = [aDecoder decodeIntegerForKey:@"age"];
      }
      return self;
  }
  //归档
  - (void)encodeWithCoder:(NSCoder *)aCoder {
      [aCoder encodeObject:self.avatar forKey:@"avatar"];
      [aCoder encodeObject:self.name forKey:@"name"];
      [aCoder encodeInteger:self.age forKey:@"age"];
  }
</code></pre>

<p>特别注意
如果需要归档的类是某个自定义类的子类时，就需要在归档和解档之前先实现父类的归档和解档方法。即 [super encodeWithCoder:aCoder] 和 [super initWithCoder:aDecoder] 方法;</p>

<h6>#2.使用</h6>

<p>需要把对象归档是调用NSKeyedArchiver的工厂方法 archiveRootObject: toFile: 方法。</p>

<pre><code>  NSString *file = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject stringByAppendingPathComponent:@"person.data"];
  Person *person = [[Person alloc] init];
  person.avatar = self.avatarView.image;
  person.name = self.nameField.text;
  person.age = [self.ageField.text integerValue];
  [NSKeyedArchiver archiveRootObject:person toFile:file];
</code></pre>

<p>需要从文件中解档对象就调用NSKeyedUnarchiver的一个工厂方法 unarchiveObjectWithFile: 即可。</p>

<pre><code>  NSString *file = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject stringByAppendingPathComponent:@"person.data"];
  Person *person = [NSKeyedUnarchiver unarchiveObjectWithFile:file];
  if (person) {
     self.avatarView.image = person.avatar;
     self.nameField.text = person.name;
     self.ageField.text = [NSString stringWithFormat:@"%ld", person.age];
  }
</code></pre>

<h6>#3.注意</h6>

<p>必须遵循并实现NSCoding协议
保存文件的扩展名可以任意指定
继承时必须先调用父类的归档解档方法</p>

<h4>SQLite3</h4>

<p>之前的所有存储方法，都是覆盖存储。如果想要增加一条数据就必须把整个文件读出来，然后修改数据后再把整个内容覆盖写入文件。所以它们都不适合存储大量的内容。</p>

<h6>#1.字段类型</h6>

<p>表面上SQLite将数据分为以下几种类型：</p>

<pre><code>integer : 整数
real : 实数（浮点数）
text : 文本字符串
blob : 二进制数据，比如文件，图片之类的
</code></pre>

<p>实际上SQLite是无类型的。即不管你在创表时指定的字段类型是什么，存储是依然可以存储任意类型的数据。而且在创表时也可以不指定字段类型。SQLite之所以什么类型就是为了良好的编程规范和方便开发人员交流，所以平时在使用时最好设置正确的字段类型！主键必须设置成integer</p>

<h6>#2. 准备工作</h6>

<p>准备工作就是导入依赖库啦，在iOS中要使用SQLite3，需要添加库文件：libsqlite3.dylib并导入主头文件，这是一个C语言的库，所以直接使用SQLite3还是比较麻烦的。</p>

<h6>#3.使用</h6>

<p>创建数据库并打开
操作数据库之前必须先指定数据库文件和要操作的表，所以使用SQLite3，首先要打开数据库文件，然后指定或创建一张表。</p>

<pre><code>/**
*  打开数据库并创建一个表
*/
- (void)openDatabase {
   //1.设置文件名
   NSString *filename = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject stringByAppendingPathComponent:@"person.db"];
   //2.打开数据库文件，如果没有会自动创建一个文件
   NSInteger result = sqlite3_open(filename.UTF8String, &amp;_sqlite3);
   if (result == SQLITE_OK) {
       NSLog(@"打开数据库成功！");
       //3.创建一个数据库表
       char *errmsg = NULL;
       sqlite3_exec(_sqlite3, "CREATE TABLE IF NOT EXISTS t_person(id integer primary key autoincrement, name text, age integer)", NULL, NULL, &amp;errmsg);
       if (errmsg) {
           NSLog(@"错误：%s", errmsg);
       } else {
           NSLog(@"创表成功！");
       }
   } else {
       NSLog(@"打开数据库失败！");
   }
}
</code></pre>

<p>执行指令
使用 sqlite3_exec() 方法可以执行任何SQL语句，比如创表、更新、插入和删除操作。但是一般不用它执行查询语句，因为它不会返回查询到的数据。</p>

<pre><code>/**
*  往表中插入1000条数据
*/
- (void)insertData {
NSString *nameStr;
NSInteger age;
for (NSInteger i = 0; i &lt; 1000; i++) {
  nameStr = [NSString stringWithFormat:@"Bourne-%d", arc4random_uniform(10000)];
  age = arc4random_uniform(80) + 20;
  NSString *sql = [NSString stringWithFormat:@"INSERT INTO t_person (name, age) VALUES('%@', '%ld')", nameStr, age];
  char *errmsg = NULL;
  sqlite3_exec(_sqlite3, sql.UTF8String, NULL, NULL, &amp;errmsg);
  if (errmsg) {
      NSLog(@"错误：%s", errmsg);
  }
}
NSLog(@"插入完毕！");
}
</code></pre>

<p>查询指令
前面说过一般不使用 sqlite3_exec() 方法查询数据。因为查询数据必须要获得查询结果，所以查询相对比较麻烦。示例代码如下：</p>

<pre><code>sqlite3_prepare_v2() : 检查sql的合法性
sqlite3_step() : 逐行获取查询结果，不断重复，直到最后一条记录
sqlite3_coloum_xxx() : 获取对应类型的内容，iCol对应的就是SQL语句中字段的顺序，从0开始。根据实际查询字段的属性，使用sqlite3_column_xxx取得对应的内容即可。
sqlite3_finalize() : 释放stmt
/**
*  从表中读取数据到数组中
*/
- (void)readData {
   NSMutableArray *mArray = [NSMutableArray arrayWithCapacity:1000];
   char *sql = "select name, age from t_person;";
   sqlite3_stmt *stmt;
   NSInteger result = sqlite3_prepare_v2(_sqlite3, sql, -1, &amp;stmt, NULL);
   if (result == SQLITE_OK) {
       while (sqlite3_step(stmt) == SQLITE_ROW) {
           char *name = (char *)sqlite3_column_text(stmt, 0);
           NSInteger age = sqlite3_column_int(stmt, 1);
           //创建对象
           Person *person = [Person personWithName:[NSString stringWithUTF8String:name] Age:age];
           [mArray addObject:person];
       }
       self.dataList = mArray;
   }
   sqlite3_finalize(stmt);
}
</code></pre>

<h6>#4.总结</h6>

<p>总得来说，SQLite3的使用还是比较麻烦的，因为都是些c语言的函数，理解起来有些困难。不过在一般开发过程中，使用的都是第三方开源库 FMDB，封装了这些基本的c语言方法，使得我们在使用时更加容易理解，提高开发效率。</p>

<h4>FMDB</h4>

<h6>1.简介</h6>

<p>FMDB是iOS平台的SQLite数据库框架，它是以OC的方式封装了SQLite的C语言API，它相对于cocoa自带的C语言框架有如下的优点:</p>

<p>使用起来更加面向对象，省去了很多麻烦、冗余的C语言代码</p>

<p>对比苹果自带的Core Data框架，更加轻量级和灵活</p>

<p>提供了多线程安全的数据库操作方法，有效地防止数据混乱</p>

<blockquote><p>注：FMDB的gitHub地址</p></blockquote>

<h6>2.核心类</h6>

<p>FMDB有三个主要的类：</p>

<ul>
<li><p>FMDatabase</p>

<p>  一个FMDatabase对象就代表一个单独的SQLite数据库，用来执行SQL语句</p></li>
<li><p>FMResultSet</p>

<p>  使用FMDatabase执行查询后的结果集</p></li>
<li><p>FMDatabaseQueue</p>

<p>  用于在多线程中执行多个查询或更新，它是线程安全的</p></li>
</ul>


<h6>3.打开数据库</h6>

<p>和c语言框架一样，FMDB通过指定SQLite数据库文件路径来创建FMDatabase对象，但FMDB更加容易理解，使用起来更容易，使用之前一样需要导入sqlite3.dylib。打开数据库方法如下：</p>

<pre><code>NSString *path = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject stringByAppendingPathComponent:@"person.db"];
FMDatabase *database = [FMDatabase databaseWithPath:path];    
if (![database open]) {
    NSLog(@"数据库打开失败！");
}
</code></pre>

<p>值得注意的是，Path的值可以传入以下三种情况：</p>

<p>具体文件路径，如果不存在会自动创建
空字符串@&ldquo;"，会在临时目录创建一个空的数据库，当FMDatabase连接关闭时，数据库文件也被删除
nil，会创建一个内存中临时数据库，当FMDatabase连接关闭时，数据库会被销毁</p>

<h6>4.更新</h6>

<p>在FMDB中，除查询以外的所有操作，都称为“更新”, 如：create、drop、insert、update、delete等操作，使用executeUpdate:方法执行更新：</p>

<pre><code>//常用方法有以下3种：   
- (BOOL)executeUpdate:(NSString*)sql, ...
- (BOOL)executeUpdateWithFormat:(NSString*)format, ...
- (BOOL)executeUpdate:(NSString*)sql withArgumentsInArray:(NSArray *)arguments
//示例
[database executeUpdate:@"CREATE TABLE IF NOT EXISTS t_person(id integer primary key autoincrement, name text, age integer)"];   
//或者  
[database executeUpdate:@"INSERT INTO t_person(name, age) VALUES(?, ?)", @"Bourne", [NSNumber numberWithInt:42]];
</code></pre>

<h6>5.查询</h6>

<p>查询方法也有3种，使用起来相当简单：</p>

<pre><code>- (FMResultSet *)executeQuery:(NSString*)sql, ...
- (FMResultSet *)executeQueryWithFormat:(NSString*)format, ...
- (FMResultSet *)executeQuery:(NSString *)sql withArgumentsInArray:(NSArray *)arguments
</code></pre>

<p>查询示例：</p>

<pre><code>//1.执行查询
FMResultSet *result = [database executeQuery:@"SELECT * FROM t_person"];
//2.遍历结果集
while ([result next]) {
    NSString *name = [result stringForColumn:@"name"];
    int age = [result intForColumn:@"age"];
}
</code></pre>

<h6>6.线程安全</h6>

<p>在多个线程中同时使用一个FMDatabase实例是不明智的。不要让多个线程分享同一个FMDatabase实例，它无法在多个线程中同时使用。 如果在多个线程中同时使用一个FMDatabase实例，会造成数据混乱等问题。所以，请使用 FMDatabaseQueue，它是线程安全的。以下是使用方法：</p>

<p>创建队列。</p>

<pre><code>FMDatabaseQueue *queue = [FMDatabaseQueue databaseQueueWithPath:aPath];
使用队列
[queue inDatabase:^(FMDatabase *database) {    
          [database executeUpdate:@"INSERT INTO t_person(name, age) VALUES (?, ?)", @"Bourne_1", [NSNumber numberWithInt:1]];    
          [database executeUpdate:@"INSERT INTO t_person(name, age) VALUES (?, ?)", @"Bourne_2", [NSNumber numberWithInt:2]];    
          [database executeUpdate:@"INSERT INTO t_person(name, age) VALUES (?, ?)", @"Bourne_3", [NSNumber numberWithInt:3]];      
          FMResultSet *result = [database executeQuery:@"select * from t_person"];    
         while([result next]) {   
         }    
}];
</code></pre>

<p>而且可以轻松地把简单任务包装到事务里：</p>

<pre><code>[queue inTransaction:^(FMDatabase *database, BOOL *rollback) {    
          [database executeUpdate:@"INSERT INTO t_person(name, age) VALUES (?, ?)", @"Bourne_1", [NSNumber numberWithInt:1]];    
          [database executeUpdate:@"INSERT INTO t_person(name, age) VALUES (?, ?)", @"Bourne_2", [NSNumber numberWithInt:2]];    
          [database executeUpdate:@"INSERT INTO t_person(name, age) VALUES (?, ?)", @"Bourne_3", [NSNumber numberWithInt:3]];      
          FMResultSet *result = [database executeQuery:@"select * from t_person"];    
             while([result next]) {   
             }   
           //回滚
           *rollback = YES;  
    }];
</code></pre>

<p>FMDatabaseQueue 后台会建立系列化的G-C-D队列，并执行你传给G-C-D队列的块。这意味着 你从多线程同时调用调用方法，GDC也会按它接收的块的顺序来执行。</p>

<h4>CoreData</h4>

<p>详见我的另一篇笔记：我要娶你做我的CoreData！</p>

<p>声明：</p>

<p>以上内容属于本人整理的笔记，如有错误的地方希望能告诉我，大家共同进步。
以上内容有些段落或语句可能是本人从其他地方Copy而来，如有侵权，请及时告诉我。</p>
</div>
  
  




| <a href="/blog/2014/06/03/data%20cache/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/29/animation/">三维动画初探</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><p>实现三位旋转动画的方法有很多种，这里介绍三种</p>

<p>一：UIView</p>

<pre><code>[UIView animateWithDuration:1.0 animations:^{
        self.iconView.layer.transform = CATransform3DMakeRotation(M_PI_2, 0, 1, 0);
    } completion:^(BOOL finished) {
        self.iconView.image = [UIImage imageNamed:@"user_defaultgift"];

        [UIView animateWithDuration:1.0 animations:^{
            self.iconView.layer.transform = CATransform3DMakeRotation(M_PI, 0, 1, 0);
        }];
    }];
</code></pre>

<p>二：CATransition自定义</p>

<pre><code> CATransition
  CATransition *anim = [CATransition animation];
 anim.duration = 1.0;
 anim.type = @"rippleEffect";
 [self.iconView.layer addAnimation:anim forKey:nil];
</code></pre>

<p>三：CATransition</p>

<pre><code>[UIView transitionWithView:self.iconView duration:1.0 options:UIViewAnimationOptionTransitionFlipFromLeft animations:^{
        self.iconView.image = [UIImage imageNamed:@"user_defaultgift"];
    } completion:^(BOOL finished) {
        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
            [UIView transitionWithView:self.iconView duration:1.0 options:UIViewAnimationOptionTransitionFlipFromRight animations:^{
                self.iconView.image = [UIImage imageNamed:@"default_avatar"];
            } completion:nil];
        });
    }];
}
</code></pre>
</div>
  
  




| <a href="/blog/2014/05/29/animation/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/20/sign/">签名机制</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><p>最近看了objc.io上第17期中的文章 《Inside Code Signing》 对应的中文翻译版 《代码签名探析》 ，受益颇深，对iOS代码签名机制有了进一步的认识。想了解详细内容建议大家还是去看原文好了。</p>

<p>下面是对此文章的理解再结合自己之前对该部分的认识写出的学习笔记。本文的前提是已经对非对称加密有了一定的了解。</p>

<h4>一、数字签名（digital signature）</h4>

<p>对指定信息使用哈希算法，得到一个固定长度的信息摘要，然后再使用 私钥 （注意必须是私钥）对该摘要加密，就得到了数字签名。所谓的代码签名就是这个意思。</p>

<h4>二、数字证书（digital certificate）</h4>

<p>证书生成</p>

<p>开 发者在申请iOS开发证书时，需要通过keychain生成一个CSR文件（Certificate Signing Request），提交给苹果的 Apple Worldwide Developer Relations Certification Authority(WWDR)证书认证中心进行签名，最后从苹果官网下载并安装使用。这个过程中还会产生一个私钥，证书和私钥在keychain中得位 置如图：</p>

<p>iphone-developer-keychain.png</p>

<p>证书组成</p>

<p>经过WWDR数字签名后的数字证书长这个样子：</p>

<p>20130603170838968.png</p>

<p>其中包含两大部分：</p>

<p>· 证书本身</p>

<p>包含用户的公钥、用户个人信息、证书颁发机构信息、证书有效期等信息。</p>

<p>· 证书签名</p>

<p>WWDR将上述证书本身内容的使用哈希算法得到一个固定长度的信息摘要，然后使用自己的私钥对该信息摘要加密生成数字签名，整个过程如图所示：</p>

<p>20130603170752859.png</p>

<p>证书使用</p>

<p>iOS 系统原本就持有WWDR的公钥，系统首先会对证书内容通过指定的哈希算法计算得到一个信息摘要；然后使用WWDR的公钥对证书中包含的数字签名解密，从而 得到经过WWDR的私钥加密过的信息摘要；最后对比两个信息摘要，如果内容相同就说明该证书可信。整个过程如图所示：</p>

<p>20130603170924312.png</p>

<p>在验证了证书是可信的以后，iOS系统就可以获取到证书中包含的开发者的公钥，并使用该公钥来判断代码签名的可用性了。</p>

<p>证书存在的意义</p>

<p>通过证书使用过程可以看出，证书本身只是一个中间媒介，iOS系统对证书并不关心，它其实只想要证书中包含的开发者的公钥！！</p>

<p>但是开发者怎么才能证明公钥是自己的呢？iOS安全系统怎么才能相信这个公钥就是这个开发者的呢？</p>

<p>不 管是哪一个开发者对iOS的安全系统说，这个公钥就是我的，系统是都不相信的，即系统对开发者有着百分之百的不信任感。但是iOS安全系统对自家的 WWDR是可信任的，苹果将WWDR的公钥内置在了iOS系统中。有了证书，iOS安全系统只需要通过WWDR的公钥就可以获取到任何一个开发者的可信任 的公钥了，这就是证书存在的意义！！</p>

<h4>三、公钥（public key）</h4>

<p>公钥被包含在数字证书里，数字证书又被包含在描述文件(Provisioning File)中，描述文件在应用被安装的时候会被拷贝到iOS设备中。</p>

<p>iOS安全系统通过证书就能够确定开发者身份，就能够通过从证书中获取到的公钥来验证开发者用该公钥对应的私钥签名后的代码、资源文件等有没有被更改破坏，最终确定应用能否合法的在iOS设备上合法运行。</p>

<h4>四、私钥（private key）</h4>

<p>每个证书（其实是公钥）都对应有一个私钥，</p>

<p>私钥会被用来对代码、资源文件等签名。只有开发证书和描述文件是没办法正常调试的，因为没有私钥根本无法签名。</p>

<p>此后的内容基本都是从《代码签名探析》摘抄过来的笔记，建议大家看原文好了。</p>

<h4>五、签名相关命令</h4>

<p>快捷查看系统中能用来对代码进行签名的证书</p>

<p>可以使用如下命令：</p>

<pre><code>1 $security find-identity -v -p codesigning  
2   1) F10B42FFDE18DF28BA21190121439F2E04BEE4B8 "iPhone Developer: weizheng li (P7QJ74LFSA)"
3      1 valid identities found
</code></pre>

<p>这就说明当前有一个同时有公钥和私钥的可用证书。</p>

<p>对未签名app手动签名</p>

<p>使用如下命令：</p>

<pre><code> 1 $ codesign -s 'iPhone Developer: Thomas Kollbach (7TPNXN7G6K)' Example.app 
</code></pre>

<p>对已签名app重新签名</p>

<p>为了重新设置签名，你必须带上 -f 参数，有了这个参数，codesign 会用你选择的签名替换掉已经存在的那一个：</p>

<pre><code> 1 $ codesign -f -s 'iPhone Developer: Thomas Kollbach (7TPNXN7G6K)' Example.app 
</code></pre>

<p>查看指定app的签名信息</p>

<p>codesign 还可以为你提供有关一个可执行文件签名状态的信息，这些信息在出现不明错误时会提供巨大的帮助：</p>

<pre><code> 1 $ codesign -vv -d Example.app 
</code></pre>

<p>会列出以下有关 Example.app 的签名信息：</p>

<pre><code> 1 Executable=/Users/toto/Library/Developer/Xcode/DerivedData/Example-cfsbhbvmswdivqhekxfykvkpngkg/Build/Products/Debug-iphoneos/Example.app/Example  
 2 Identifier=ch.kollba.example  
 3 Format=bundle with Mach-O thin (arm64)  
 4 CodeDirectory v=20200 size=26663 flags=0x0(none) hashes=1324+5 location=embedded  
 5 Signature size=4336  
 6 Authority=iPhone Developer: Thomas Kollbach (7TPNXN7G6K)  
 7 Authority=Apple Worldwide Developer Relations Certification Authority  
 8 Authority=Apple Root CA  
 9 Signed Time=29.09.2014 22:29:07  
10 Info.plist entries=33  
11 TeamIdentifier=DZM8538E3E  
12 Sealed Resources version=2 rules=4 files=120  
13 Internal requirements count=1 size=184
</code></pre>

<p>验证签名文件的完整性</p>

<p>检查已签名的文件是否完整可以使用如下命令：</p>

<pre><code> 1 $ codesign --verify Example.app 
</code></pre>

<p>就像大多数 UNIX 工具一样，没有任何输出代表签名是完好的。如果修改一下这个二进制文件：</p>

<pre><code> 1 $ echo 'lol' &gt;&gt; Example.app/Example 2 $ codesign --verify Example.app 3 Example.app: main executable failed strict validation 
</code></pre>

<p>和预料中的一样，修改已经签名的应用会导致数字签名验证不通过。</p>

<h4>六、资源文件签名</h4>

<p>iOS 和 OS X 的应用和框架则是包含了它们所需要的资源在其中的。这些资源包括图片和不同的语言文件，资源中也包括很重要的应用组成部分例如 XIB/NIB 文件，存档文件(archives)，甚至是证书文件。所以为一个程序包设置签名时，这个包中的所有资源文件也都会被设置签名。</p>

<p>为了达到为 所有文件设置签名的目的，签名的过程中会在程序包（即Example.app）中新建一个叫做 _CodeSignatue/CodeResources 的文件，这个文件中存储了被签名的程序包中所有文件的签名。你可以自己去查看这个签名列表文件，它仅仅是一个 plist 格式文件。</p>

<blockquote><p>这个列表文件中不光包含了文件和它们的签名的列表，还包含了一系列规则，这些规则决定了哪些资源文件应当被设置签名。伴随 OS X 10.10 DP 5 和 10.9.5 版本的发布，苹果改变了代码签名的格式，也改变了有关资源的规则。如果你使用10.9.5或者更高版本的 codesign 工具，在 CodeResources 文件中会有4个不同区域，其中的 rules 和 files 是为老版本准备的，而 files2 和 rules2 是为新的第二版的代码签名准备的。最主要的区别是在新版本中你无法再将某些资源文件排除在代码签名之外，在过去你是可以的，只要在被设置签名的程序包中添 加一个名为 ResourceRules.plist 的文件，这个文件会规定哪些资源文件在检查代码签名是否完好时应该被忽略。但是在新版本的代码签名中，这种做法不再有效。所有的代码文件和资源文件都必须 设置签名，不再可以有例外。在新版本的代码签名规定中，一个程序包中的可执行程序包，例如扩展 (extension)，是一个独立的需要设置签名的个体，在检查签名是否完整时应当被单独对待。</p></blockquote>

<h4>七、授权文件（entitlements）</h4>

<p>在 iOS 上你的应用能做什么依然是沙盒限制的，这些限制大多情况下都由授权文件（entitlements）来决定。授权机制决定了哪些系统资源在什么情况下允许被一个应用使用，简单的说它就是一个沙盒的配置列表。</p>

<p>运行如下命令：</p>

<pre><code> 1 $ codesign -d --entitlements - Example.app 
</code></pre>

<p>会得到类似的结果：</p>

<pre><code> 1 &lt;!--?xml version="1.0" encoding="UTF-8"?--&gt;  
 2    
 3 &lt;plist version="1.0"&gt;  
 4 &lt;dict&gt;  
 5         &lt;key&gt;application-identifier&lt;/key&gt;
 6         &lt;string&gt;7TPNXN7G6K.ch.kollba.example&lt;/string&gt;
 7         &lt;key&gt;aps-environment&lt;/key&gt;
 8         &lt;string&gt;development&lt;/string&gt;
 9         &lt;key&gt;com.apple.developer.team-identifier&lt;/key&gt;
10         &lt;string&gt;7TPNXN7G6K&lt;/string&gt;
11         &lt;key&gt;com.apple.developer.ubiquity-container-identifiers&lt;/key&gt;
12         &lt;array&gt;
13                 &lt;string&gt;7TPNXN7G6K.ch.kollba.example&lt;/string&gt;
14         &lt;/array&gt;
15         &lt;key&gt;com.apple.developer.ubiquity-kvstore-identifier&lt;/key&gt;
16         &lt;string&gt;7TPNXN7G6K.ch.kollba.example&lt;/string&gt;
17         &lt;key&gt;com.apple.security.application-groups&lt;/key&gt;
18         &lt;array&gt;
19                 &lt;string&gt;group.ch.kollba.example&lt;/string&gt;
20         &lt;/array&gt;
21         &lt;key&gt;get-task-allow&lt;/key&gt;
22         &lt;true&gt;
23 &lt;/true&gt;&lt;/dict&gt;  
24 &lt;/plist version="1.0"&gt;
</code></pre>

<p>在 Xcode 的 Capabilities 选项卡下选择一些选项之后，Xcode 就会生成这样一段 XML。 Xcode 会自动生成一个 .entitlements 文件，然后在需要的时候往里面添加条目。当构建整个应用时，这个文件也会提交给 codesign 作为应用所需要拥有哪些授权的参考。这些授权信息必须都在开发者中心的 App ID 中启用，并且包含在后文介绍的描述文件中。在构建应用时需要使用的授权文件可以在 Xcode build setting 中的 code signing entitlements中设置。</p>

<p>在新版本的 Xcode 6 之后，授权信息列表会以 Example.app.xcent 这样的名字的文件形式包含在应用包中。这么做或许是为了在出现配置错误时提供更加有用的错误信息。</p>

<h4>八、描述文件（provisioning file）</h4>

<p>在整个代码签名和沙盒机制中有一个组成部分将签名，授权和沙盒联系了起来，那就是描述文件 (provisioning profiles)。</p>

<p>OS X中保存目录</p>

<p>Xcode 将从开发者中心下载的全部配置文件都放在了这里：</p>

<pre><code> 1 ~/Library/MobileDevice/Provisioning Profiles 
</code></pre>

<p>文件格式</p>

<p>描述文件并不是一个普通的plist文件，它是一个根据密码讯息语法 (Cryptographic Message Syntax) 加密的文件。</p>

<p>以XML格式查看该文件的命令：</p>

<pre><code> 1 $ security cms -D -i example.mobileprovision 
</code></pre>

<p>文件内容</p>

<p>描述文件主要包含以下内容：</p>

<ul>
<li>UUID</li>
</ul>


<p>每一个配置文件都有它自己的 UUID 。Xcode 会用这个 UUID 来作为标识，记录你在 build settings 中选择了哪一个配置文件。</p>

<ul>
<li>ProvisionedDevices</li>
</ul>


<p>记录所有可用于调试的设备ID。</p>

<ul>
<li>DeveloperCertificates</li>
</ul>


<p>包含了可以为使用这个配置文件的应用签名的所有证书。所有的证书都是基于 Base64 编码符合 PEM (Privacy Enhanced Mail, RFC 1848) 格式的。</p>

<ul>
<li>Entitlements</li>
</ul>


<p>有关前面讲到的配置文件的所有内容都会被保存在这里。</p>
</div>
  
  




| <a href="/blog/2014/05/20/sign/#comments">更多评论</a>

    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/7">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/5">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
    <h1>文章分类</h1>
    <ul id="categories">
        <li class='category'><a href='/blog/categories/全栈工程师必备/'>全栈工程师必备 (2)</a></li>
<li class='category'><a href='/blog/categories/底层开发/'>底层开发 (4)</a></li>
<li class='category'><a href='/blog/categories/开发工具/'>开发工具 (2)</a></li>
<li class='category'><a href='/blog/categories/性能相关/'>性能相关 (6)</a></li>
<li class='category'><a href='/blog/categories/性能问题/'>性能问题 (4)</a></li>
<li class='category'><a href='/blog/categories/新技术/'>新技术 (1)</a></li>
<li class='category'><a href='/blog/categories/欢迎来到ios梦工厂/'>欢迎来到ios梦工厂 (1)</a></li>
<li class='category'><a href='/blog/categories/程序员必备/'>程序员必备 (6)</a></li>
<li class='category'><a href='/blog/categories/适配问题/'>适配问题 (1)</a></li>
<li class='category'><a href='/blog/categories/面试总结-技术/'>面试总结＋技术 (1)</a></li>
<li class='category'><a href='/blog/categories/面试汇总/'>面试汇总 (1)</a></li>
<li class='category'><a href='/blog/categories/项目实战/'>项目实战 (17)</a></li>
<li class='category'><a href='/blog/categories/高级开发/'>高级开发 (25)</a></li>

    </ul>
</section><section>
  <h1>最新文章</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/12/11/java/">爬虫必备-java抓包</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/12/11/zhengze/">爬虫必备-正则表达式</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/12/11/qinghuaci/">爬虫必备-青花瓷</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/12/10/h5ying-yong-shi-zhan/">H5应用实战</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/12/10/core-image-chu-tan/">Core Image 初探</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/al1020119">@al1020119</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'al1020119',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>




<section>
<h1>扫一扫<abbr title="The word '扫一扫' is a registered trademark of DENSO WAVE INCORPORATED. It applies only for the word '扫一扫', not for image.">&trade;</abbr></h1>
<a href="http://al1020119.github.io/posts/6/index.html"><img src="http://chart.apis.google.com/chart?chs=150x150&cht=qr&chld=|0&chco=165B94&chl=http://al1020119.github.io/posts/6/index.html" alt="post-qrcode"></a></section>
<section>
    <h1>访客统计</h1>
    <br/>
    <a href="http://s07.flagcounter.com/more/2SH"><img src="http://s07.flagcounter.com/count/2SH/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_1/flags_0/" alt="Flag Counter" border="0"></a>
</section><section>
    <h1>新浪微博</h1>
    <ul id="weibo">
        <li>
            
            <!-- 在此插入获得的微博秀代码 -->
            <iframe width="100%" height="550" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=550&fansRow=2&ptype=1&speed=0&skin=1&isTitle=1&noborder=1&isWeibo=1&isFans=1&uid=3288975567&verifier=20ffcedd&dpc=1"></iframe>
            
        </li>
    </ul>
</section>
  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - iCocos -
<span class="credit">Preview in <a href="http://al1020119.github.io">[曹#黎]</a></span>
</p>

</footer>
  






<!--
--->



</body>
</html>
