
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>iOS梦工厂</title>
  <meta name="author" content="iCocos">

  
  <meta name="description" content="签名机制 ordinal 最近看了objc.io上第17期中的文章 《Inside Code Signing》 对应的中文翻译版 《代码签名探析》 ，受益颇深，对iOS代码签名机制有了进一步的认识。想了解详细内容建议大家还是去看原文好了。 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://al1020119.github.io/posts/7/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="iOS梦工厂" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//libs.baidu.com/jquery/1.7.2/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <script>
function addBlankTargetForLinks () {
    $('a[href^="http"]').each(function(){
                              $(this).attr('target', '_blank');
                              });
}
$(document).bind('DOMNodeInserted', function(event) {
             addBlankTargetForLinks();
             });
</script>
  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">iOS梦工厂</a></h1>
  
    <h2>不战胜自己，何以改变未来！</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="al1020119.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">首页</a></li>
  <li><a href="/blog/archives">归档</a></li>
  <li><a href="/icocos">iCocos</a></li>
  <li><a href="/other">其他</a></li>
  <li><a href="/about">关于</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/20/sign/">签名机制</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><p>最近看了objc.io上第17期中的文章 《Inside Code Signing》 对应的中文翻译版 《代码签名探析》 ，受益颇深，对iOS代码签名机制有了进一步的认识。想了解详细内容建议大家还是去看原文好了。</p>

<p>下面是对此文章的理解再结合自己之前对该部分的认识写出的学习笔记。本文的前提是已经对非对称加密有了一定的了解。</p>

<h4>一、数字签名（digital signature）</h4>

<p>对指定信息使用哈希算法，得到一个固定长度的信息摘要，然后再使用 私钥 （注意必须是私钥）对该摘要加密，就得到了数字签名。所谓的代码签名就是这个意思。</p>

<h4>二、数字证书（digital certificate）</h4>

<p>证书生成</p>

<p>开 发者在申请iOS开发证书时，需要通过keychain生成一个CSR文件（Certificate Signing Request），提交给苹果的 Apple Worldwide Developer Relations Certification Authority(WWDR)证书认证中心进行签名，最后从苹果官网下载并安装使用。这个过程中还会产生一个私钥，证书和私钥在keychain中得位 置如图：</p>

<p>iphone-developer-keychain.png</p>

<p>证书组成</p>

<p>经过WWDR数字签名后的数字证书长这个样子：</p>

<p>20130603170838968.png</p>

<p>其中包含两大部分：</p>

<p>· 证书本身</p>

<p>包含用户的公钥、用户个人信息、证书颁发机构信息、证书有效期等信息。</p>

<p>· 证书签名</p>

<p>WWDR将上述证书本身内容的使用哈希算法得到一个固定长度的信息摘要，然后使用自己的私钥对该信息摘要加密生成数字签名，整个过程如图所示：</p>

<p>20130603170752859.png</p>

<p>证书使用</p>

<p>iOS 系统原本就持有WWDR的公钥，系统首先会对证书内容通过指定的哈希算法计算得到一个信息摘要；然后使用WWDR的公钥对证书中包含的数字签名解密，从而 得到经过WWDR的私钥加密过的信息摘要；最后对比两个信息摘要，如果内容相同就说明该证书可信。整个过程如图所示：</p>

<p>20130603170924312.png</p>

<p>在验证了证书是可信的以后，iOS系统就可以获取到证书中包含的开发者的公钥，并使用该公钥来判断代码签名的可用性了。</p>

<p>证书存在的意义</p>

<p>通过证书使用过程可以看出，证书本身只是一个中间媒介，iOS系统对证书并不关心，它其实只想要证书中包含的开发者的公钥！！</p>

<p>但是开发者怎么才能证明公钥是自己的呢？iOS安全系统怎么才能相信这个公钥就是这个开发者的呢？</p>

<p>不 管是哪一个开发者对iOS的安全系统说，这个公钥就是我的，系统是都不相信的，即系统对开发者有着百分之百的不信任感。但是iOS安全系统对自家的 WWDR是可信任的，苹果将WWDR的公钥内置在了iOS系统中。有了证书，iOS安全系统只需要通过WWDR的公钥就可以获取到任何一个开发者的可信任 的公钥了，这就是证书存在的意义！！</p>

<h4>三、公钥（public key）</h4>

<p>公钥被包含在数字证书里，数字证书又被包含在描述文件(Provisioning File)中，描述文件在应用被安装的时候会被拷贝到iOS设备中。</p>

<p>iOS安全系统通过证书就能够确定开发者身份，就能够通过从证书中获取到的公钥来验证开发者用该公钥对应的私钥签名后的代码、资源文件等有没有被更改破坏，最终确定应用能否合法的在iOS设备上合法运行。</p>

<h4>四、私钥（private key）</h4>

<p>每个证书（其实是公钥）都对应有一个私钥，</p>

<p>私钥会被用来对代码、资源文件等签名。只有开发证书和描述文件是没办法正常调试的，因为没有私钥根本无法签名。</p>

<p>此后的内容基本都是从《代码签名探析》摘抄过来的笔记，建议大家看原文好了。</p>

<h4>五、签名相关命令</h4>

<p>快捷查看系统中能用来对代码进行签名的证书</p>

<p>可以使用如下命令：</p>

<pre><code>1 $security find-identity -v -p codesigning  
2   1) F10B42FFDE18DF28BA21190121439F2E04BEE4B8 "iPhone Developer: weizheng li (P7QJ74LFSA)"
3      1 valid identities found
</code></pre>

<p>这就说明当前有一个同时有公钥和私钥的可用证书。</p>

<p>对未签名app手动签名</p>

<p>使用如下命令：</p>

<pre><code> 1 $ codesign -s 'iPhone Developer: Thomas Kollbach (7TPNXN7G6K)' Example.app 
</code></pre>

<p>对已签名app重新签名</p>

<p>为了重新设置签名，你必须带上 -f 参数，有了这个参数，codesign 会用你选择的签名替换掉已经存在的那一个：</p>

<pre><code> 1 $ codesign -f -s 'iPhone Developer: Thomas Kollbach (7TPNXN7G6K)' Example.app 
</code></pre>

<p>查看指定app的签名信息</p>

<p>codesign 还可以为你提供有关一个可执行文件签名状态的信息，这些信息在出现不明错误时会提供巨大的帮助：</p>

<pre><code> 1 $ codesign -vv -d Example.app 
</code></pre>

<p>会列出以下有关 Example.app 的签名信息：</p>

<pre><code> 1 Executable=/Users/toto/Library/Developer/Xcode/DerivedData/Example-cfsbhbvmswdivqhekxfykvkpngkg/Build/Products/Debug-iphoneos/Example.app/Example  
 2 Identifier=ch.kollba.example  
 3 Format=bundle with Mach-O thin (arm64)  
 4 CodeDirectory v=20200 size=26663 flags=0x0(none) hashes=1324+5 location=embedded  
 5 Signature size=4336  
 6 Authority=iPhone Developer: Thomas Kollbach (7TPNXN7G6K)  
 7 Authority=Apple Worldwide Developer Relations Certification Authority  
 8 Authority=Apple Root CA  
 9 Signed Time=29.09.2014 22:29:07  
10 Info.plist entries=33  
11 TeamIdentifier=DZM8538E3E  
12 Sealed Resources version=2 rules=4 files=120  
13 Internal requirements count=1 size=184
</code></pre>

<p>验证签名文件的完整性</p>

<p>检查已签名的文件是否完整可以使用如下命令：</p>

<pre><code> 1 $ codesign --verify Example.app 
</code></pre>

<p>就像大多数 UNIX 工具一样，没有任何输出代表签名是完好的。如果修改一下这个二进制文件：</p>

<pre><code> 1 $ echo 'lol' &gt;&gt; Example.app/Example 2 $ codesign --verify Example.app 3 Example.app: main executable failed strict validation 
</code></pre>

<p>和预料中的一样，修改已经签名的应用会导致数字签名验证不通过。</p>

<h4>六、资源文件签名</h4>

<p>iOS 和 OS X 的应用和框架则是包含了它们所需要的资源在其中的。这些资源包括图片和不同的语言文件，资源中也包括很重要的应用组成部分例如 XIB/NIB 文件，存档文件(archives)，甚至是证书文件。所以为一个程序包设置签名时，这个包中的所有资源文件也都会被设置签名。</p>

<p>为了达到为 所有文件设置签名的目的，签名的过程中会在程序包（即Example.app）中新建一个叫做 _CodeSignatue/CodeResources 的文件，这个文件中存储了被签名的程序包中所有文件的签名。你可以自己去查看这个签名列表文件，它仅仅是一个 plist 格式文件。</p>

<blockquote><p>这个列表文件中不光包含了文件和它们的签名的列表，还包含了一系列规则，这些规则决定了哪些资源文件应当被设置签名。伴随 OS X 10.10 DP 5 和 10.9.5 版本的发布，苹果改变了代码签名的格式，也改变了有关资源的规则。如果你使用10.9.5或者更高版本的 codesign 工具，在 CodeResources 文件中会有4个不同区域，其中的 rules 和 files 是为老版本准备的，而 files2 和 rules2 是为新的第二版的代码签名准备的。最主要的区别是在新版本中你无法再将某些资源文件排除在代码签名之外，在过去你是可以的，只要在被设置签名的程序包中添 加一个名为 ResourceRules.plist 的文件，这个文件会规定哪些资源文件在检查代码签名是否完好时应该被忽略。但是在新版本的代码签名中，这种做法不再有效。所有的代码文件和资源文件都必须 设置签名，不再可以有例外。在新版本的代码签名规定中，一个程序包中的可执行程序包，例如扩展 (extension)，是一个独立的需要设置签名的个体，在检查签名是否完整时应当被单独对待。</p></blockquote>

<h4>七、授权文件（entitlements）</h4>

<p>在 iOS 上你的应用能做什么依然是沙盒限制的，这些限制大多情况下都由授权文件（entitlements）来决定。授权机制决定了哪些系统资源在什么情况下允许被一个应用使用，简单的说它就是一个沙盒的配置列表。</p>

<p>运行如下命令：</p>

<pre><code> 1 $ codesign -d --entitlements - Example.app 
</code></pre>

<p>会得到类似的结果：</p>

<pre><code> 1 &lt;!--?xml version="1.0" encoding="UTF-8"?--&gt;  
 2    
 3 &lt;plist version="1.0"&gt;  
 4 &lt;dict&gt;  
 5         &lt;key&gt;application-identifier&lt;/key&gt;
 6         &lt;string&gt;7TPNXN7G6K.ch.kollba.example&lt;/string&gt;
 7         &lt;key&gt;aps-environment&lt;/key&gt;
 8         &lt;string&gt;development&lt;/string&gt;
 9         &lt;key&gt;com.apple.developer.team-identifier&lt;/key&gt;
10         &lt;string&gt;7TPNXN7G6K&lt;/string&gt;
11         &lt;key&gt;com.apple.developer.ubiquity-container-identifiers&lt;/key&gt;
12         &lt;array&gt;
13                 &lt;string&gt;7TPNXN7G6K.ch.kollba.example&lt;/string&gt;
14         &lt;/array&gt;
15         &lt;key&gt;com.apple.developer.ubiquity-kvstore-identifier&lt;/key&gt;
16         &lt;string&gt;7TPNXN7G6K.ch.kollba.example&lt;/string&gt;
17         &lt;key&gt;com.apple.security.application-groups&lt;/key&gt;
18         &lt;array&gt;
19                 &lt;string&gt;group.ch.kollba.example&lt;/string&gt;
20         &lt;/array&gt;
21         &lt;key&gt;get-task-allow&lt;/key&gt;
22         &lt;true&gt;
23 &lt;/true&gt;&lt;/dict&gt;  
24 &lt;/plist version="1.0"&gt;
</code></pre>

<p>在 Xcode 的 Capabilities 选项卡下选择一些选项之后，Xcode 就会生成这样一段 XML。 Xcode 会自动生成一个 .entitlements 文件，然后在需要的时候往里面添加条目。当构建整个应用时，这个文件也会提交给 codesign 作为应用所需要拥有哪些授权的参考。这些授权信息必须都在开发者中心的 App ID 中启用，并且包含在后文介绍的描述文件中。在构建应用时需要使用的授权文件可以在 Xcode build setting 中的 code signing entitlements中设置。</p>

<p>在新版本的 Xcode 6 之后，授权信息列表会以 Example.app.xcent 这样的名字的文件形式包含在应用包中。这么做或许是为了在出现配置错误时提供更加有用的错误信息。</p>

<h4>八、描述文件（provisioning file）</h4>

<p>在整个代码签名和沙盒机制中有一个组成部分将签名，授权和沙盒联系了起来，那就是描述文件 (provisioning profiles)。</p>

<p>OS X中保存目录</p>

<p>Xcode 将从开发者中心下载的全部配置文件都放在了这里：</p>

<pre><code> 1 ~/Library/MobileDevice/Provisioning Profiles 
</code></pre>

<p>文件格式</p>

<p>描述文件并不是一个普通的plist文件，它是一个根据密码讯息语法 (Cryptographic Message Syntax) 加密的文件。</p>

<p>以XML格式查看该文件的命令：</p>

<pre><code> 1 $ security cms -D -i example.mobileprovision 
</code></pre>

<p>文件内容</p>

<p>描述文件主要包含以下内容：</p>

<ul>
<li>UUID</li>
</ul>


<p>每一个配置文件都有它自己的 UUID 。Xcode 会用这个 UUID 来作为标识，记录你在 build settings 中选择了哪一个配置文件。</p>

<ul>
<li>ProvisionedDevices</li>
</ul>


<p>记录所有可用于调试的设备ID。</p>

<ul>
<li>DeveloperCertificates</li>
</ul>


<p>包含了可以为使用这个配置文件的应用签名的所有证书。所有的证书都是基于 Base64 编码符合 PEM (Privacy Enhanced Mail, RFC 1848) 格式的。</p>

<ul>
<li>Entitlements</li>
</ul>


<p>有关前面讲到的配置文件的所有内容都会被保存在这里。</p>
</div>
  
  




| <a href="/blog/2014/05/20/sign/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/20/paixu/">排序算法精髓</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><h2>1、序言</h2>

<p>ios开发中涉及到算法的地方还真不多，除非你的应用程序真的非常大，或者你想你的应用程序性能非常好才会去想到关于算法方面的性能优化，而在ios开发中真的能用得到的也就是关于排序的，当然如果你是做游戏的话那么你可能会涉及到不少的算法或者优化问题，但是这不是本篇文章讨论的范围。</p>

<p>后面的文章中，我将会给大家详细介绍八大算法。</p>

<h2>2、冒泡排序</h2>

<h5>2.1 引出</h5>

<p>前面的两篇博客里讲的插入排序是基于“逐个记录插入”，选择排序是基于“选择”，那么冒泡排序其实是基于“交换”。每次从第一个记录开始，一、二两个记录比较，大的往后放，二三两个记录比较&hellip;依次类推，这就是一趟冒泡排序。每一趟冒泡排序后，无序序列中值最大的记录冒到序列末尾，所以称之为冒泡排序。</p>

<h5>2.2 代码</h5>

<pre><code>//冒泡排序
void bubbleSort(int *a,int n)
{
    int i,j;
    for(i=1;i&lt;n;i++)
        for(j=1;j&lt;n-i+1;j++){
            if(a[j+1]&lt;a[j]){
                a[j]=a[j]+a[j+1];
                a[j+1]=a[j]-a[j+1];
                a[j]=a[j]-a[j+1];
            }
        }
}
</code></pre>

<p> 冒泡排序算法：
冒泡排序代码</p>

<pre><code> static void Main(string[] args)
        {
            ////五次比较
             for (int i = 1; i &lt;= 5; i++)
            {
                List&lt;int&gt; list = new List&lt;int&gt;();
                //插入2k个随机数到数组中
                for (int j = 0; j &lt; 2000; j++)
                {
                    Thread.Sleep(1);
                    list.Add(new Random((int)DateTime.Now.Ticks).Next(0, 100000));
                }
                Console.WriteLine("\n第" + i + "次比较：");
                Stopwatch watch = new Stopwatch();
                watch.Start();
                var result = list.OrderBy(single =&gt; single).ToList();
                watch.Stop();
                Console.WriteLine("\n快速排序耗费时间：" + watch.ElapsedMilliseconds);
                Console.WriteLine("输出前是十个数:" + string.Join(",", result.Take(10).ToList()));
                watch.Start();
                result = BubbleSort(list);
                watch.Stop();
                Console.WriteLine("\n冒泡排序耗费时间：" + watch.ElapsedMilliseconds);
                Console.WriteLine("输出前是十个数:" + string.Join(",", result.Take(10).ToList()));
                Console.ReadKey();
            }

      }

 //冒泡排序算法
        private static List&lt;int&gt; BubbleSort(List&lt;int&gt; list)
        {
            int temp;
            //第一层循环： 表明要比较的次数，比如list.count个数，肯定要比较count-1次
            for (int i = 0; i &lt; list.Count - 1;i++ ) 
            {
                //list.count-1：取数据最后一个数下标，47 
                //j&gt;i: 从后往前的的下标一定大于从前往后的下标，否则就超越了。
                for (var j = list.Count-1; j &gt; i;j-- )
                {
                    //如果前面一个数大于后面一个数则交换
                    if (list[j - 1] &gt; list[j])
                    {
                        temp = list[j - 1];
                        list[j - 1] = list[j];
                        list[j] = temp;
                    }
                }

            }
            return list;
        } 
</code></pre>

<h5>2.3 效率分析</h5>

<p>相对于简单选择排序，冒泡排序交换次数明显更多。它是通过不断地交换把最大的数冒出来。冒泡排序平均时间和最坏情况下（逆序）时间为o（n<sup>2</sup>）。最佳情况下虽然不用交换，但比较的次数没有减少，时间复杂度仍为o（n<sup>2</sup>）。此外冒泡排序是稳定的。</p>

<h2>3、快速排序</h2>

<h5>3.1 引出</h5>

<pre><code>快速排序是冒泡排序的一种改进，冒泡排序排完一趟是最大值冒出来了，那么可不可以先选定一个值，然后扫描待排序序列，把小于该值的记录和大于该值的记录分成两个单独的序列，然后分别对这两个序列进行上述操作。这就是快速排序，我们把选定的那个值称为枢纽值，如果枢纽值为序列中的最大值，那么一趟快速排序就变成了一趟冒泡排序。
</code></pre>

<h5>3.2 代码</h5>

<pre><code>两种版本，第一种是参考《数据结构》，在网上这种写法很流行。第二种是参考《算法导论》，实现起来较复杂。

//快速排序（两端交替着向中间扫描）
void quickSort1(int *a,int low,int high)
{
    int pivotkey=a[low];//以a[low]为枢纽值
    int i=low,j=high;
    if(low&gt;=high)
        return;
    //一趟快速排序
    while(i&lt;j){//双向扫描
        while(i &lt; j &amp;&amp; a[j] &gt;= pivotkey)
            j--;
        a[i]=a[j];
        while(i &lt; j &amp;&amp; a[i] &lt;= pivotkey)
            i++;
        a[j]=a[i];
    }
    a[i]=pivotkey;//放置枢纽值
    //分别对左边、右边排序
    quickSort1(a,low,i-1); 
    quickSort1(a,i+1,high); 
}

//快速排序（以最后一个记录的值为枢纽值，单向扫描数组）
void quickSort2(int *a,int low,int high)
{
    int pivotkey=a[high];//以a[high]为枢纽值
    int i=low-1,temp,j;
    if(low&gt;=high)
        return;
    //一趟快速排序
    for(j=low;j&lt;high;j++){
        if(a[j]&lt;=pivotkey){
            i++;
            temp=a[i];
            a[i]=a[j];
            a[j]=temp;
        }
    }
    i++;
    //放置枢纽值
    temp=a[i];
    a[i]=pivotkey;
    a[high]=temp;
    //分别对左边、右边排序
    quickSort2(a,low,i-1); 
    quickSort2(a,i+1,high); 
}
</code></pre>

<p>快速排序算法：</p>

<p>快速排序法</p>

<pre><code> static void Main(string[] args)
        {

            //5次比较
            for (int i = 1; i &lt;= 5; i++)
            {
                List&lt;int&gt; list = new List&lt;int&gt;();
                //插入200个随机数到数组中 
                for (int j = 0; j &lt; 200; j++)
                {
                    Thread.Sleep(1);
                    list.Add(new Random((int)DateTime.Now.Ticks).Next(0, 10000));
                }
                Console.WriteLine("\n第" + i + "次比较：");
                Stopwatch watch = new Stopwatch();
                watch.Start();
                var result = list.OrderBy(single =&gt; single).ToList();
                watch.Stop();
                Console.WriteLine("\n系统定义的快速排序耗费时间：" + watch.ElapsedMilliseconds);
                Console.WriteLine("输出前是十个数:" + string.Join(",", result.Take(10).ToList()));
                watch.Start();
                new QuickSortClass().QuickSort(list, 0, list.Count - 1);
                watch.Stop();
                Console.WriteLine("\n俺自己写的快速排序耗费时间：" + watch.ElapsedMilliseconds);
                Console.WriteLine("输出前是十个数:" + string.Join(",", list.Take(10).ToList()));
                Console.ReadKey();
            }
        }

 public class QuickSortClass
    {

        ///&lt;summary&gt; 
        ////// 分割函数 
        ///&lt;/summary&gt; 
        //////&lt;param name="list"&gt;待排序的数组&lt;/param&gt; 
        ///&lt;param name="left"&gt;数组的左下标&lt;/param&gt; 
        //////&lt;param name="right"&gt;&lt;/param&gt; 
        ///&lt;returns&gt;&lt;/returns&gt;
         public int Division(List&lt;int&gt; list, int left, int right) 
         { 
             //首先挑选一个基准元素 
             int baseNum = list[left]; 
             while (left &lt; right) 
             { 
                 //从数组的右端开始向前找，一直找到比base小的数字为止(包括base同等数) 
                 while (left &lt; right &amp;&amp; list[right] &gt;= baseNum) 
                     right = right - 1; 
                 //最终找到了比baseNum小的元素，要做的事情就是此元素放到base的位置 
                 list[left] = list[right]; 
                 //从数组的左端开始向后找，一直找到比base大的数字为止（包括base同等数）
                 while (left &lt; right &amp;&amp; list[left] &lt;= baseNum) 
                     left = left + 1; 
                 //最终找到了比baseNum大的元素，要做的事情就是将此元素放到最后的位置 
                 list[right] = list[left];
             }
             //最后就是把baseNum放到该left的位置 
             list[left] = baseNum;
             //最终，我们发现left位置的左侧数值部分比left小，left位置右侧数值比left大 
             //至此，我们完成了第一篇排序 
             return left;
         }
        public void QuickSort(List&lt;int&gt; list, int left, int right)
        { 
            //左下标一定小于右下标，否则就超越了 
            if (left &lt; right) 
            { 
                //对数组进行分割，取出下次分割的基准标号 
                int i = Division(list, left, right);
                //对“基准标号“左侧的一组数值进行递归的切割，以至于将这些数值完整的排序 
                QuickSort(list, left, i - 1); 
                //对“基准标号“右侧的一组数值进行递归的切割，以至于将这些数值完整的排序
                QuickSort(list, i + 1, right);
            }
        }
    }
</code></pre>

<h5>3.3 效率分析</h5>

<p> 快速排序时间与划分是否对称有关。快速排序的平均时间复杂度为o（n<em>logn），至于为什么是o（n</em>logn），请参考《算法导论》第7章，书中用递归树的方法阐述了快速排序平均时间。且常数因子很小，所以就平均时间而言，快速排序是很好的内部排序方法。最佳情况下（每次划分都对称）时间复杂度o（n*logn）。最坏情况下（每次划分都不对称，如输入的序列有序或者逆序时）时间复杂度为o(n<sup>2</sup>)，所以在待排序序列有序或逆序时不宜选用快速排序。此外，快速排序是不稳定的。</p>

<p> 最佳情况下，每次划分都是对称的，由于枢纽值不再考虑，所以得到的两个子问题的大小不可能大于n/2，同时一趟快速排序时间为o（n），所以运行时间递归表达式：</p>

<pre><code>T（n）&lt;=2T(n/2)+o(n)。
</code></pre>

<p>这个递归式的解法请参考下一篇博客中归并排序效率分析。其解为T（n）=o（n*logn）。</p>

<p> 最坏情况下，每次划分都很不对称，T(n)=T(n-1)+o(n),可以用递归树来解，第i层的代价为n-i+1.总共有n层。把每一层代价加起来有n-1个n相加。所以这个递归式的解为T（n）=o（n<sup>2</sup>）,此时就是冒泡排序。</p>
</div>
  
  




| <a href="/blog/2014/05/20/paixu/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/05/keyoc/">常用关键字汇总</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><p>在做iOS开发中，系统的各个关键字处处都是，但是未必每一个关键字都是那么的明白，所以罗列出一些关键字供大家互相学习，有不完善之处请指正，谢谢</p>

<table>
<thead>
<tr>
<th> 关键字 </th>
<th style="text-align:center;"> 总结</th>
</tr>
</thead>
<tbody>
<tr>
<td> atomic    </td>
<td style="text-align:center;"> atomic是Objc使用的一种线程保护技术，基本上来讲，是防止在写未完成的时候被另外一个线程读取，造成数据错误。而这种机制是耗费系统资源的，所以在iPhone这种小型设备上，如果没有使用多线程间的通讯编程，那么nonatomic是一个非常好的选择。</td>
</tr>
<tr>
<td> super </td>
<td style="text-align:center;"> 调用父类的方法</td>
</tr>
<tr>
<td> readonly  </td>
<td style="text-align:center;"> 说明属性是只读的，默认的标记是读写</td>
</tr>
<tr>
<td> readwrite </td>
<td style="text-align:center;"> 说明属性会被当成读写的，这也是默认属性</td>
</tr>
<tr>
<td> retain    </td>
<td style="text-align:center;"> 释放旧的对象，将旧对象的值赋予输入对象，再提高输入对象的索引计数为1</td>
</tr>
<tr>
<td> self</td>
<td style="text-align:center;">     是隐藏参数，指向当前调用方法的类</td>
</tr>
<tr>
<td> setter    </td>
<td style="text-align:center;"> 设置指定的set方法</td>
</tr>
<tr>
<td> getter    </td>
<td style="text-align:center;"> 设置指定的get方法</td>
</tr>
<tr>
<td> property</td>
<td style="text-align:center;">     设置成员变量的属性（有读／写，赋值assign,retain,copy ,以及对多线程的支持 nonatomic）</td>
</tr>
<tr>
<td> end   </td>
<td style="text-align:center;"> 类的头文件或者实现文件的结束</td>
</tr>
<tr>
<td> copy</td>
<td style="text-align:center;">     建立一个索引计数为1的对象，然后释放旧对象 </td>
</tr>
<tr>
<td> assign    </td>
<td style="text-align:center;"> 简单赋值，不更改引用计数</td>
</tr>
<tr>
<td> synthesize    </td>
<td style="text-align:center;"> 根据@property设置，自动生成成员变量相应的存取方法，从而可以使用点操作符来方便的存取该成员变量</td>
</tr>
<tr>
<td> import    </td>
<td style="text-align:center;"> 告诉预处理器,将头文件的内容包含到本文件中</td>
</tr>
<tr>
<td> dynamic   </td>
<td style="text-align:center;"> 告诉编译器由我们自己来实现访问方法</td>
</tr>
<tr>
<td> nonatomic </td>
<td style="text-align:center;"> 非原子性访问，对属性赋值的时候不加锁，多线程并发访问会提高性能</td>
</tr>
<tr>
<td> implementation</td>
<td style="text-align:center;">   表明类的实现</td>
</tr>
<tr>
<td> strong    </td>
<td style="text-align:center;"> 强引用，只要最后一个strong型指针不再指向对象，那么对象就会被释放，同时所有的weak型指针都将会被清除</td>
</tr>
<tr>
<td> weak  </td>
<td style="text-align:center;"> 弱引用</td>
</tr>
<tr>
<td> __strong  </td>
<td style="text-align:center;"> 是缺省的关键词</td>
</tr>
<tr>
<td> __weak    </td>
<td style="text-align:center;"> 声明了一个可以自动nil化的弱引用</td>
</tr>
<tr>
<td> __unsafe_unretained</td>
<td style="text-align:center;">  声明一个弱应用，但是不会自动nil化，也就是说，如果所指向的内存区域被释放了，这个指针就是一个野指针了</td>
</tr>
<tr>
<td> __autoreleasing   </td>
<td style="text-align:center;"> 用来修饰一个函数的参数，这个参数会在函数返回的时候被自动释放</td>
</tr>
<tr>
<td> unsafe_unretained 弱引用，容易生成野指针，尽量少用unsafe_unretained关键字</td>
<td></td>
</tr>
<tr>
<td> synchronized  </td>
<td style="text-align:center;"> 方法加锁</td>
</tr>
</tbody>
</table>

</div>
  
  




| <a href="/blog/2014/05/05/keyoc/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/04/14/nscache%20nsdictionary/">NSCache&NSDcitionary你了解多少？</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><p>NSCache</p>

<p>NSCache是系统提供的一种类似于集合（NSMutableDictionary）的缓存，它与集合的不同如下：</p>

<ol>
<li><p>NSCache具有自动删除的功能，以减少系统占用的内存；</p></li>
<li><p>NSCache是线程安全的，不需要加线程锁；</p></li>
<li><p>键对象不会像 NSMutableDictionary 中那样被复制。（键不需要实现 NSCopying 协议）。</p></li>
</ol>


<h5>NSCache的属性以及方法介绍：</h5>

<pre><code>@property NSUInteger totalCostLimit;
</code></pre>

<p>设置缓存占用的内存大小，并不是一个严格的限制，当总数超过了totalCostLimit设定的值，系统会清除一部分缓存，直至总消耗低于totalCostLimit的值。</p>

<pre><code>@property NSUInteger countLimit;
</code></pre>

<p>设置缓存对象的大小，这也不是一个严格的限制。</p>

<pre><code>- (id)objectForKey:(id)key;
</code></pre>

<p>获取缓存对象，基于key-value对</p>

<pre><code>- (void)setObject:(id)obj forKey:(id)key; // 0 cost
</code></pre>

<p>存储缓存对象，考虑缓存的限制属性；</p>

<pre><code>- (void)setObject:(id)obj forKey:(id)key cost:(NSUInteger)g;
</code></pre>

<p>存储缓存对象，cost是提前知道该缓存对象占用的字节数，也会考虑缓存的限制属性，建议直接使用  - (void)setObject:(id)obj forKey:(id)key;</p>

<h5>NSCacheDelegate代理</h5>

<p>代理属性声明如下：</p>

<pre><code>@property (assign) id&lt;NSCacheDelegate&gt;delegate;
</code></pre>

<p>实现了NSCacheDelegate代理的对象，在缓存对象即将被清理的时候，系统回调代理方法如下：</p>

<pre><code>- (void)cache:(NSCache *)cache willEvictObject:(id)obj;
</code></pre>

<p>第一个参数是当前缓存（NSCache），不要修改该对象；</p>

<p>第二个参数是当前将要被清理的对象，如果需要存储该对象，可以在此操作（存入Sqlite or CoreData）;</p>

<p>该代理方法的调用会在缓存对象即将被清理的时候调用，如下场景会调用：</p>

<ol>
<li><ul>
<li>(void)removeObjectForKey:(id)key; 手动删除对象；</li>
</ul>
</li>
<li><p>缓存对象超过了NSCache的属性限制；（countLimit 和 totalCostLimit ）</p></li>
<li><p>App进入后台会调用；</p></li>
<li><p>系统发出内存警告；</p></li>
</ol>


<h5>NSDiscardableContent协议</h5>

<p>NSDiscardableContent是一个协议，实现这个协议的目的是为了让我们的对象在不被使用时，可以将其丢弃，以让程序占用更少的内存。</p>

<p>一个NSDiscardableContent对象的生命周期依赖于一个“counter”变量。一个NSDiscardableContent对象实际是一个可清理内存块，这个内存记录了对象当前是否被其它对象使用。如果这块内存正在被读取，或者仍然被需要，则它的counter变量是大于或等于1的；当它不再被使用时，就可以丢弃，此时counter变量将等于0。当counter变量等于0时，如果当前时间点内存比较紧张的话，内存块就可能被丢弃。这点类似于MRC&amp;ARC，对象内存回收机制。</p>

<pre><code>- (void)discardContentIfPossible
</code></pre>

<p>当counter等于0的时候，为了丢弃这些对象，会调用这个方法。</p>

<p>默认情况下，NSDiscardableContent对象的counter变量初始值为1，以确保对象不会被内存管理系统立即释放。</p>

<pre><code>- (BOOL)beginContentAccess    (counter++)
</code></pre>

<p>调用该方法，对象的counter会加1；</p>

<p>与beginContentAccess相对应的是endContentAccess。如果可丢弃内存不再被访问时调用。其声明如下：</p>

<pre><code>- (void)endContentAccess  （counter--）
</code></pre>

<p>该方法会减少对象的counter变量，通常是让对象的counter值变回为0，这样在对象的内容不再被需要时，就要以将其丢弃。</p>

<p>NSCache类提供了一个属性，来标识缓存是否自动舍弃那些内存已经被丢弃的对象(默认该属性为YES)，其声明如下：</p>

<pre><code>@property BOOL evictsObjectsWithDiscardedContent
</code></pre>

<p>如果设置为YES，则在对象的内存被丢弃时舍弃对象。</p>

<p>个人建议：如果需要使用缓存，直接用系统的NSCache就OK了，不要做死。</p>

<h4>区别：</h4>

<p>NSCache</p>

<ul>
<li>(1)可以存储(当然是使用内存)</li>
<li>(2)保持强应用, 无视垃圾回收. =>这一点同 NSMutableDictionary</li>
<li>(3)有固定客户.</li>
</ul>


<hr />

<pre><code>+---------------------------+------------------------------+
| NSCache | NSMutableDictionary |
+---------------------------+------------------------------+
| NSDiscardableContent | NSObject |
+---------------------------+------------------------------+
</code></pre>

<p>下面是 UIImageView+AFNetworking的使用:</p>

<pre><code>@interface AFImageCache :NSCache
- (UIImage *)cachedImageForRequest:(NSURLRequest *)request;
- (void)cacheImage:(UIImage *)image
forRequest:(NSURLRequest *)request;
@end
</code></pre>

<p>NSURLCache</p>

<p>iOS5 之前是不能通过NSURLCache使用硬盘缓存的,所以有SDURLCache这样的library来实现硬盘缓存. iOS5可以使用NSURLCache的硬盘缓存, 只要符合http-cache-control-header即可.
这里有详细的说明:here
这也就是说不用做任何操作, 系统将自动完成满足缓存条件的request.</p>

<p>映射关系:</p>

<pre><code>+---------------------------+---------------------------------+
| NSURLRequest ----|----&gt; NSCachedURLResponse |
+---------------------------+---------------------------------+
</code></pre>

<p>通过这样的映射关系实现缓存. 这里存的是NSCachedURLResponse. 也就是说这里的NSURLCache也是一个类似于NSCache的容器.
只不过data是NSCachedURLResponse对象. 并不是类似于image这样的data.</p>

<p>这篇文章可以的: NSURLCache使用心得here
我测试了一下UIImage->NSData->URL,NSURLConnection, UIWebView不同时候调用</p>

<pre><code>- (NSCachedURLResponse *)cachedResponseForRequest:(NSURLRequest *)request;
-(void)storeCachedResponse:(NSCachedURLResponse *)cachedResponse forRequest:(NSURLRequest *)request;
</code></pre>

<p>的情况:</p>

<pre><code>+-------------+---------------------+----------------------+------------------+
| | UIImage-&gt;URL | NSURLConnection | UIWebView |
+---------+---+---------------------+----------------------+------------------+
| | c | X | first called | first called | 
|1’s time |---+---------------------+----------------------+------------------+
| | s | first called | second called | second called | 
+---------+---+---------------------+----------------------+------------------+
| | c | X | first called | first called | 
|2’s time +---+---------------------+----------------------+------------------+
| | s | first called | X | X | 
+---------+---+---------------------+----------------------+------------------+
</code></pre>

<blockquote><p>注意</p></blockquote>

<pre><code>* c 表示 cachedResponseForRequest
* s 表示 storeCachedResponse
* X 表示不被调用
</code></pre>

<p>结果显示: UIImage->URL 是同步的请求. 因为cachedResponseForRequest不能发起同步请求来请求网络.</p>
</div>
  
  




| <a href="/blog/2014/04/14/nscache%20nsdictionary/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/04/11/fu-wu-qi-da-jian/">服务器搭建</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><h3>一、简单说明</h3>

<p>说明：提前下载好相关软件，且安装目录最好安装在全英文路径下。如果路径有中文名，那么可能会出现一些莫名其妙的问题。</p>

<p>提示：提前准备好的软件</p>

<ul>
<li><p>apache-tomcat-6.0.41.tar</p></li>
<li><p>eclipse-jee-kepler-SR2-macosx-cocoa-x86_64.tar.gz</p></li>
<li><p>jdk-8u5-macosx-x64.dmg</p></li>
</ul>


<h3>二、安装和配置本地服务器环境（java）步骤：</h3>

<ul>
<li>(1)在文档路径下，新建一个文件夹（NetWord），解压eclipse压缩包文件</li>
</ul>


<p><img src="/images/fuwuqi001.png" title="Caption" ></p>

<ul>
<li>(2)先安装jdk</li>
</ul>


<p><img src="/images/fuwuqi002.png" title="Caption" ></p>

<ul>
<li>(3)点击安装eclipse，设置工作空间，点击确定。</li>
</ul>


<p><img src="/images/fuwuqi003.png" title="Caption" ></p>

<p>设置工作空间
<img src="/images/fuwuqi004.png" title="Caption" ></p>

<p><img src="/images/fuwuqi0004.png" title="Caption" ></p>

<ul>
<li>(4)把提前写好的服务器代码，拷贝到工作空间中。</li>
</ul>


<p> <img src="/images/fuwuqi005.png" title="Caption" ></p>

<p> <img src="/images/fuwuqi006.png" title="Caption" ></p>

<ul>
<li><p>(5)导入项目，导入已经存在的项目到工作空间中。
<img src="/images/fuwuqi007.png" title="Caption" ><br/>
<img src="/images/fuwuqi008.png" title="Caption" ><br/>
<img src="/images/fuwuqi009.png" title="Caption" ></p></li>
<li><p>(6)导入项目之后，项目报错且格式乱码，下面进行调整。</p></li>
</ul>


<p><img src="/images/fuwuqi010.png" title="Caption" ><br/>
<img src="/images/fuwuqi011.png" title="Caption" ><br/>
<img src="/images/fuwuqi012.png" title="Caption" ></p>

<ul>
<li><p>(7)配置容器，apache-tomcat.</p>

<p> <img src="/images/fuwuqi013.png" title="Caption" >    <br/>
<img src="/images/fuwuqi014.png" title="Caption" ></p></li>
</ul>


<p> <img src="/images/fuwuqi015.png" title="Caption" ></p>

<p>点击ok。创建一个新的容器</p>

<p><img src="/images/fuwuqi016.png" title="Caption" ></p>

<p>选择容器的路径</p>

<p><img src="/images/fuwuqi017.png" title="Caption" ></p>

<p>安装好后显示如下：</p>

<p><img src="/images/fuwuqi018.png" title="Caption" ></p>

<ul>
<li>(8)启动服务器。以debug的方式启动，方便做一些调试</li>
</ul>


<p><img src="/images/fuwuqi019.png" title="Caption" ></p>

<p>测试：server已经成功启动。</p>

<p><img src="/images/fuwuqi020.png" title="Caption" ></p>

<ul>
<li>(9)部署程序</li>
</ul>


<p><img src="/images/fuwuqi021.png" title="Caption" ></p>

<p><img src="/images/fuwuqi022.png" title="Caption" ></p>

<p><img src="/images/fuwuqi023.png" title="Caption" ></p>

<ul>
<li>(10)在火狐浏览器中输入服务器的地址，访问项目</li>
</ul>


<p><img src="/images/fuwuqi024.png" title="Caption" ></p>

<p>至此本地服务器环境搭建完成。</p>

<h3>访问服务器的资源</h3>

<p><img src="/images/fuwuqi025.png" title="Caption" ></p>

<p><img src="/images/fuwuqi026.png" title="Caption" ></p>

<p>使用模拟器上的浏览器也可以访问本地服务器。输入地址192.168.1.53：8080/MJServer</p>

<p>补充：浏览器打开页面，文字乱码调整。</p>

<p><img src="/images/fuwuqi027.png" title="Caption" ></p>
</div>
  
  




| <a href="/blog/2014/04/11/fu-wu-qi-da-jian/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/04/02/duoxianchengshiyong/">多线程详解</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><p>在这篇文章中，我将为你整理一下 iOS 开发中几种多线程方案，以及其使用方法和注意事项。当然也会给出几种多线程的案例，在实际使用中感受它们的区别。还有一点需要说明的是，这篇文章将会使用 Swift 和 Objective-c 两种语言讲解，双语幼儿园。OK，let&rsquo;t begin!</p>

<blockquote><p>概述:这篇文章中，我不会说多线程是什么、线程和进程的区别、多线程有什么用，当然我也不会说什么是串行、什么是并行等问题，这些我们应该都知道的。</p></blockquote>

<p>在 iOS 中其实目前有 4 套多线程方案，他们分别是：</p>

<ul>
<li>Pthreads</li>
<li>NSThread</li>
<li>GCD</li>
<li>NSOperation &amp; NSOperationQueue</li>
</ul>


<p>所以接下来，我会一一讲解这些方案的使用方法和一些案例。在将这些内容的时候，我也会顺带说一些多线程周边产品。比如： 线程同步、 延时执行、 单例模式 等等。</p>

<h3>Pthreads</h3>

<p>其实这个方案不用说的，只是拿来充个数，为了让大家了解一下就好了。百度百科里是这么说的：</p>

<p>POSIX线程（POSIX threads），简称Pthreads，是线程的POSIX标准。该标准定义了创建和操纵线程的一整套API。在类Unix操作系统（Unix、Linux、Mac OS X等）中，都使用Pthreads作为操作系统的线程。</p>

<p>简单地说，这是一套在很多操作系统上都通用的多线程API，所以移植性很强（然并卵），当然在 iOS 中也是可以的。不过这是基于 c语言 的框架，使用起来这酸爽！感受一下：</p>

<h6>OBJECTIVE-C</h6>

<p>当然第一步要包含头文件</p>

<pre><code>#import
//然后创建线程，并执行任务

- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event {
    pthread_t thread;
    //创建一个线程并自动执行
    pthread_create(&amp;thread, NULL, start, NULL);
}
void *start(void *data) {
    NSLog(@"%@", [NSThread currentThread]);
    return NULL;
}
</code></pre>

<p>打印输出：</p>

<pre><code>2015-07-27 23:57:21.689 testThread[10616:2644653] {number = 2, name = (null)}
</code></pre>

<p>看代码就会发现他需要 c语言函数，这是比较蛋疼的，更蛋疼的是你需要手动处理线程的各个状态的转换即管理生命周期，比如，这段代码虽然创建了一个线程，但并没有销毁。</p>

<h6>SWIFT</h6>

<blockquote><p>很遗憾，在我目前的 swift1.2 中无法执行这套方法，原因是这个函数需要传入一个函数指针 CFunctionPointer类型，但是目前 swift 无法将方法转换成此类型。听说 swift 2.0 引入一个新特性 @convention&copy;, 可以完成 Swift 方法转换成 c 语言指针的。在这里可以看到</p></blockquote>

<p>那么，Pthreads 方案的多线程我就介绍这么多，毕竟做 iOS 开发几乎不可能用到。但是如果你感兴趣的话，或者说想要自己实现一套多线程方案，从底层开始定制，那么可以去搜一下相关资料。</p>

<h3>NSThread</h3>

<p>这套方案是经过苹果封装后的，并且完全面向对象的。所以你可以直接操控线程对象，非常直观和方便。但是，它的生命周期还是需要我们手动管理，所以这套方案也是偶尔用用，比如 [NSThread currentThread]，它可以获取当前线程类，你就可以知道当前线程的各种属性，用于调试十分方便。下面来看看它的一些用法。</p>

<h5>创建并启动</h5>

<p>先创建线程类，再启动</p>

<h6>OBJECTIVE-C</h6>

<pre><code>  // 创建
  NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(run:) object:nil];
  // 启动
  [thread start];
</code></pre>

<h6>SWIFT</h6>

<pre><code>  //创建
  let thread = NSThread(target: self, selector: "run:", object: nil)
  //启动
  thread.start()
</code></pre>

<p>创建并自动启动</p>

<p> OBJECTIVE-C</p>

<pre><code>  [NSThread detachNewThreadSelector:@selector(run:) toTarget:self withObject:nil];
</code></pre>

<p>SWIFT</p>

<pre><code>  NSThread.detachNewThreadSelector("run:", toTarget: self, withObject: nil)
</code></pre>

<p>使用 NSObject 的方法创建并自动启动
OBJECTIVE-C</p>

<pre><code>  [self performSelectorInBackground:@selector(run:) withObject:nil];
</code></pre>

<p>SWIFT</p>

<p>很遗憾 too! 苹果认为 performSelector: 不安全，所以在 Swift 去掉了这个方法。</p>

<pre><code>Note: The performSelector: method and related selector-invoking methods are not imported in Swift because they are inherently unsafe.
</code></pre>

<p>其他方法</p>

<p>除了创建启动外，NSThread 还以很多方法，下面我列举一些常见的方法，当然我列举的并不完整，更多方法大家可以去类的定义里去看。</p>

<h6>OBJECTIVE-C</h6>

<pre><code>//取消线程
- (void)cancel;
//启动线程
- (void)start;
//判断某个线程的状态的属性
@property (readonly, getter=isExecuting) BOOL executing;
@property (readonly, getter=isFinished) BOOL finished;
@property (readonly, getter=isCancelled) BOOL cancelled;
//设置和获取线程名字
-(void)setName:(NSString *)n;
-(NSString *)name;
//获取当前线程信息
+ (NSThread *)currentThread;
//获取主线程信息
+ (NSThread *)mainThread;
//使当前线程暂停一段时间，或者暂停到某个时刻
+ (void)sleepForTimeInterval:(NSTimeInterval)time;
+ (void)sleepUntilDate:(NSDate *)date;
</code></pre>

<h6>SWIFT</h6>

<blockquote><p>Swift的方法名字和OC的方法名都一样，我就不浪费空间列举出来了。</p></blockquote>

<p>其实，NSThread 用起来也挺简单的，因为它就那几种方法。同时，我们也只有在一些非常简单的场景才会用 NSThread, 毕竟它还不够智能，不能优雅地处理多线程中的其他高级概念。所以接下来要说的内容才是重点。</p>

<h3>GCD</h3>

<p>Grand Central Dispatch，听名字就霸气。它是苹果为多核的并行运算提出的解决方案，所以会自动合理地利用更多的CPU内核（比如双核、四核），最重要的是它会自动管理线程的生命周期（创建线程、调度任务、销毁线程），完全不需要我们管理，我们只需要告诉干什么就行。同时它使用的也是 c语言，不过由于使用了 Block（Swift里叫做闭包），使得使用起来更加方便，而且灵活。所以基本上大家都使用 GCD 这套方案，老少咸宜，实在是居家旅行、杀人灭口，必备良药。不好意思，有点中二，咱们继续。</p>

<p>任务和队列</p>

<p>在 GCD 中，加入了两个非常重要的概念： 任务 和 队列。</p>

<p>任务：即操作，你想要干什么，说白了就是一段代码，在 GCD 中就是一个 Block，所以添加任务十分方便。任务有两种执行方式： 同步执行 和 异步执行，他们之间的区别是 是否会创建新的线程。
同步执行：只要是同步执行的任务，都会在当前线程执行，不会另开线程。</p>

<p>异步执行：只要是异步执行的任务，都会另开线程，在别的线程执行。</p>

<p>更新：</p>

<p>这里说的并不准确，同步（sync） 和 异步（async） 的主要区别在于会不会阻塞当前线程，直到 Block 中的任务执行完毕！</p>

<p>如果是 同步（sync） 操作，它会阻塞当前线程并等待 Block 中的任务执行完毕，然后当前线程才会继续往下运行。</p>

<p>如果是 异步（async）操作，当前线程会直接往下执行，它不会阻塞当前线程。</p>

<p>队列：用于存放任务。一共有两种队列， 串行队列 和 并行队列。
串行队列 中的任务会根据队列的定义 FIFO 的执行，一个接一个的先进先出的进行执行。</p>

<p>更新：放到串行队列的任务，GCD 会 FIFO（先进先出） 地取出来一个，执行一个，然后取下一个，这样一个一个的执行。</p>

<p>并行队列 中的任务根据同步或异步有不同的执行方式。虽然很绕，但请看下表：</p>

<p>更新：放到串行队列的任务，GCD 也会 FIFO的取出来，但不同的是，它取出来一个就会放到别的线程，然后再取出来一个又放到另一个的线程。这样由于取的动作很快，忽略不计，看起来，所有的任务都是一起执行的。不过需要注意，GCD 会根据系统资源控制并行的数量，所以如果任务很多，它并不会让所有任务同时执行。</p>

<p>blob.png</p>

<p>创建队列</p>

<p>主队列：这是一个特殊的 串行队列。什么是主队列，大家都知道吧，它用于刷新 UI，任何需要刷新 UI 的工作都要在主队列执行，所以一般耗时的任务都要放到别的线程执行。
  //OBJECTIVE-C
      dispatch_queue_t queue = ispatch_get_main_queue();
      //SWIFT
      let queue = ispatch_get_main_queue()
自己创建的队列：凡是自己创建的队列都是 串行队列。其中第一个参数是标识符，用于 DEBUG 的时候标识唯一的队列，可以为空。大家可以看xcode的文档查看参数意义。
更新：自己可以创建 串行队列, 也可以创建 并行队列。看下面的代码（代码已更新），它有两个参数，第一个上面已经说了，第二个才是最重要的。
第二个参数用来表示创建的队列是串行的还是并行的，传入 DISPATCH_QUEUE_SERIAL 或 NULL 表示创建串行队列。传入 DISPATCH_QUEUE_CONCURRENT 表示创建并行队列。</p>

<p>//OBJECTIVE-      C</p>

<pre><code>  dispatch_queue_t queue = dispatch_queue_create("tk.bourne.testQueue", NULL);
  //SWIFT
  let queue = dispatch_queue_create("tk.bourne.testQueue", nil);
全局并行队列：这应该是唯一一个并行队列，只要是并行任务一般都加入到这个队列。
  //OBJECTIVE-C
  dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
  //SWIFT
  let queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)
</code></pre>

<p>创建任务</p>

<p>同步任务：不会另开线程 (SYNC)
OBJECTIVE-C</p>

<pre><code>  dispatch_sync(, ^{
      //code here
      NSLog(@"%@", [NSThread currentThread]);
  });
SWIFT

  dispatch_sync(, { () -&gt; Void in
      //code here
      println(NSThread.currentThread())
  })
</code></pre>

<p>异步任务：会另开线程 (ASYNC)
OBJECTIVE-C</p>

<pre><code>  dispatch_async(, ^{
      //code here
      NSLog(@"%@", [NSThread currentThread]);
  });
SWIFT

  dispatch_async(, { () -&gt; Void in
      //code here
      println(NSThread.currentThread())
  })
</code></pre>

<p>更新：</p>

<p>为了更好的理解同步和异步，和各种队列的使用，下面看两个示例：</p>

<p>示例一：</p>

<p>以下代码在主线程调用，结果是什么？</p>

<pre><code>NSLog("之前 - %@", NSThread.currentThread())
dispatch_sync(dispatch_get_main_queue(), { () -&gt; Void in 
        NSLog("sync - %@", NSThread.currentThread())
})
NSLog("之后 - %@", NSThread.currentThread())
</code></pre>

<p>答案：</p>

<p>只会打印第一句：之前 - {number = 1, name = main} ，然后主线程就卡死了，你可以在界面上放一个按钮，你就会发现点不了了。</p>

<p>解释：</p>

<p>同步任务会阻塞当前线程，然后把 Block 中的任务放到指定的队列中执行，只有等到 Block 中的任务完成后才会让当前线程继续往下运行。</p>

<p>那么这里的步骤就是：打印完第一句后，dispatch_sync 立即阻塞当前的主线程，然后把 Block 中的任务放到 main_queue 中，可以 main_queue 中的任务会被取出来放到主线程中执行，但主线程这个时候已经被阻塞了，所以 Block 中的任务就不能完成，它不完成，dispatch_sync 就会一直阻塞主线程，这就是死锁现象。导致主线程一直卡死。</p>

<p>示例二：</p>

<p>以下代码会产生什么结果？</p>

<pre><code>let queue = dispatch_queue_create("myQueue", DISPATCH_QUEUE_SERIAL)
   NSLog("之前 - %@", NSThread.currentThread())
    dispatch_async(queue, { () -&gt; Void in
        NSLog("sync之前 - %@", NSThread.currentThread())
        dispatch_sync(queue, { () -&gt; Void in
             NSLog("sync - %@", NSThread.currentThread())
        })
        NSLog("sync之后 - %@", NSThread.currentThread())
   })
  NSLog("之后 - %@", NSThread.currentThread())
</code></pre>

<p>答案：</p>

<pre><code>2015-07-30 02:06:51.058 test[33329:8793087] 之前 - {number = 1, name = main}

2015-07-30 02:06:51.059 test[33329:8793356] sync之前 - {number = 2, name = (null)}

2015-07-30 02:06:51.059 test[33329:8793087] 之后 - {number = 1, name = main}
</code></pre>

<p>很明显 sync - %@ 和 sync之后 - %@ 没有被打印出来！这是为什么呢？我们再来分析一下：</p>

<p>分析：</p>

<p>我们按执行顺序一步步来哦：</p>

<p>使用 DISPATCH_QUEUE_SERIAL 这个参数，创建了一个 串行队列。
打印出 之前 - %@ 这句。
dispatch_async 异步执行，所以当前线程不会被阻塞，于是有了两条线程，一条当前线程继续往下打印出 之后 - %@这句, 另一台执行 Block 中的内容打印 sync之前 - %@ 这句。因为这两条是并行的，所以打印的先后顺序无所谓。
注意，高潮来了。现在的情况和上一个例子一样了。dispatch_sync同步执行，于是它所在的线程会被阻塞，一直等到 sync 里的任务执行完才会继续往下。于是 sync 就高兴的把自己 Block 中的任务放到 queue 中，可谁想 queue 是一个串行队列，一次执行一个任务，所以 sync 的 Block 必须等到前一个任务执行完毕，可万万没想到的是 queue 正在执行的任务就是被 sync 阻塞了的那个。于是又发生了死锁。所以 sync 所在的线程被卡死了。剩下的两句代码自然不会打印。
队列组</p>

<p>队列组可以将很多队列添加到一个组里，这样做的好处是，当这个组里所有的任务都执行完了，队列组会通过一个方法通知我们。下面是使用方法，这是一个很实用的功能。</p>

<p>OBJECTIVE-C</p>

<pre><code>//1.创建队列组
dispatch_group_t group = dispatch_group_create();
//2.创建队列
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
//3.多次使用队列组的方法执行任务, 只有异步方法
//3.1.执行3次循环
dispatch_group_async(group, queue, ^{
    for (NSInteger i = 0; i &lt; 3; i++) {
        NSLog(@"group-01 - %@", [NSThread currentThread]);
    }
});
//3.2.主队列执行8次循环
dispatch_group_async(group, dispatch_get_main_queue(), ^{
    for (NSInteger i = 0; i &lt; 8; i++) {
        NSLog(@"group-02 - %@", [NSThread currentThread]);
    }
});
//3.3.执行5次循环
dispatch_group_async(group, queue, ^{
    for (NSInteger i = 0; i &lt; 5; i++) {
        NSLog(@"group-03 - %@", [NSThread currentThread]);
    }
});
//4.都完成后会自动通知
dispatch_group_notify(group, dispatch_get_main_queue(), ^{
    NSLog(@"完成 - %@", [NSThread currentThread]);
});
</code></pre>

<p>SWIFT</p>

<pre><code>//1.创建队列组
let group = dispatch_group_create()
//2.创建队列
let queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)
//3.多次使用队列组的方法执行任务, 只有异步方法
//3.1.执行3次循环
dispatch_group_async(group, queue) { () -&gt; Void in
    for _ in 0.. Void in
    for _ in 0.. Void in
    for _ in 0.. Void in
    NSLog("完成 - %@", NSThread.currentThread())
}
</code></pre>

<p>打印结果</p>

<pre><code>2015-07-28 03:40:34.277 test[12540:3319271] group-03 - {number = 3, name = (null)}
2015-07-28 03:40:34.277 test[12540:3319146] group-02 - {number = 1, name = main}
2015-07-28 03:40:34.277 test[12540:3319146] group-02 - {number = 1, name = main}
2015-07-28 03:40:34.277 test[12540:3319271] group-03 - {number = 3, name = (null)}
2015-07-28 03:40:34.278 test[12540:3319146] group-02 - {number = 1, name = main}
2015-07-28 03:40:34.278 test[12540:3319271] group-03 - {number = 3, name = (null)}
2015-07-28 03:40:34.278 test[12540:3319271] group-03 - {number = 3, name = (null)}
2015-07-28 03:40:34.278 test[12540:3319146] group-02 - {number = 1, name = main}
2015-07-28 03:40:34.277 test[12540:3319273] group-01 - {number = 2, name = (null)}
2015-07-28 03:40:34.278 test[12540:3319271] group-03 - {number = 3, name = (null)}
2015-07-28 03:40:34.278 test[12540:3319146] group-02 - {number = 1, name = main}
2015-07-28 03:40:34.278 test[12540:3319273] group-01 - {number = 2, name = (null)}
2015-07-28 03:40:34.278 test[12540:3319146] group-02 - {number = 1, name = main}
2015-07-28 03:40:34.278 test[12540:3319273] group-01 - {number = 2, name = (null)}
2015-07-28 03:40:34.279 test[12540:3319146] group-02 - {number = 1, name = main}
2015-07-28 03:40:34.279 test[12540:3319146] group-02 - {number = 1, name = main}
2015-07-28 03:40:34.279 test[12540:3319146] 完成 - {number = 1, name = main}
</code></pre>

<p>这些就是 GCD 的基本功能，但是它的能力远不止这些，等讲完 NSOperation 后，我们再来看看它的一些其他方面用途。而且，只要你想象力够丰富，你可以组合出更好的用法。</p>

<p>更新：关于GCD，还有两个需要说的：</p>

<pre><code>func dispatch_barrier_async(_ queue: dispatch_queue_t, _ block: dispatch_block_t):
</code></pre>

<p>这个方法重点是你传入的 queue，当你传入的 queue 是通过 DISPATCH_QUEUE_CONCURRENT 参数自己创建的 queue 时，这个方法会阻塞这个 queue（注意是阻塞 queue ，而不是阻塞当前线程），一直等到这个 queue 中排在它前面的任务都执行完成后才会开始执行自己，自己执行完毕后，再会取消阻塞，使这个 queue 中排在它后面的任务继续执行。</p>

<p>如果你传入的是其他的 queue, 那么它就和 dispatch_async 一样了。</p>

<p>func dispatch_barrier_sync(_ queue: dispatch_queue_t, _ block: dispatch_block_t):</p>

<p>这个方法的使用和上一个一样，传入 自定义的并发队列（DISPATCH_QUEUE_CONCURRENT），它和上一个方法一样的阻塞 queue，不同的是 这个方法还会 阻塞当前线程。</p>

<p>如果你传入的是其他的 queue, 那么它就和 dispatch_sync 一样了。</p>

<h3>NSOperation和NSOperationQueue</h3>

<p>NSOperation 是苹果公司对 GCD 的封装，完全面向对象，所以使用起来更好理解。 大家可以看到 NSOperation 和 NSOperationQueue 分别对应 GCD 的 任务 和 队列 。操作步骤也很好理解：</p>

<p>将要执行的任务封装到一个 NSOperation 对象中。
将此任务添加到一个 NSOperationQueue 对象中。
然后系统就会自动在执行任务。至于同步还是异步、串行还是并行请继续往下看：</p>

<p>添加任务</p>

<p>值得说明的是，NSOperation 只是一个抽象类，所以不能封装任务。但它有 2 个子类用于封装任务。分别是：NSInvocationOperation 和 NSBlockOperation 。创建一个 Operation 后，需要调用 start 方法来启动任务，它会 默认在当前队列同步执行。当然你也可以在中途取消一个任务，只需要调用其 cancel 方法即可。</p>

<p>NSInvocationOperation : 需要传入一个方法名。
OBJECTIVE-C</p>

<pre><code>  //1.创建NSInvocationOperation对象
  NSInvocationOperation *operation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(run) object:nil];
  //2.开始执行
  [operation start];
</code></pre>

<p>SWIFT</p>

<p>在 Swift 构建的和谐社会里，是容不下 NSInvocationOperation 这种不是类型安全的败类的。苹果如是说。这里有相关解释</p>

<p>NSBlockOperation
OBJECTIVE-C</p>

<pre><code>  //1.创建NSBlockOperation对象
  NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^{
      NSLog(@"%@", [NSThread currentThread]);
  }];
  //2.开始任务
  [operation start];
SWIFT

  //1.创建NSBlockOperation对象
  let operation = NSBlockOperation { () -&gt; Void in
      println(NSThread.currentThread())
  }
  //2.开始任务
  operation.start()
</code></pre>

<p>之前说过这样的任务，默认会在当前线程执行。但是 NSBlockOperation 还有一个方法：addExecutionBlock: ，通过这个方法可以给 Operation 添加多个执行 Block。这样 Operation 中的任务 会并发执行，它会 在主线程和其它的多个线程 执行这些任务，注意下面的打印结果：</p>

<p>OBJECTIVE-C</p>

<pre><code>  //1.创建NSBlockOperation对象
  NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^{
      NSLog(@"%@", [NSThread currentThread]);
  }];
  //添加多个Block
  for (NSInteger i = 0; i &lt; 5; i++) {
      [operation addExecutionBlock:^{
          NSLog(@"第%ld次：%@", i, [NSThread currentThread]);
      }];
  }
  //2.开始任务
  [operation start];
</code></pre>

<p>SWIFT</p>

<pre><code>    //1.创建NSBlockOperation对象
    let operation = NSBlockOperation { () -&gt; Void in
        NSLog("%@", NSThread.currentThread())
    }
    //2.添加多个Block
    for i in 0.. Void in
            NSLog("第%ld次 - %@", i, NSThread.currentThread())
        }
    }
    //2.开始任务
    operation.start()
</code></pre>

<p>打印输出</p>

<pre><code>2015-07-28 17:50:16.585 test[17527:4095467] 第2次 -{number = 1, name = main}
2015-07-28 17:50:16.585 test[17527:4095666] 第1次 -{number = 4, name = (null)}
2015-07-28 17:50:16.585 test[17527:4095665]{number = 3, name = (null)}
2015-07-28 17:50:16.585 test[17527:4095662] 第0次 -{number = 2, name = (null)}
2015-07-28 17:50:16.586 test[17527:4095666] 第3次 -{number = 4, name = (null)}
2015-07-28 17:50:16.586 test[17527:4095467] 第4次 -{number = 1, name = main}
NOTE：addExecutionBlock 方法必须在 start() 方法之前执行，否则就会报错：

‘*** -[NSBlockOperation addExecutionBlock:]: blocks cannot be added after the operation has started executing or finished'
</code></pre>

<p>NOTE：大家可能发现了一个问题，为什么我在 Swift 里打印输出使用 NSLog() 而不是 println() 呢？原因是使用 print() / println() 输出的话，它会简单地使用 流（stream） 的概念，学过 C++ 的都知道。它会把需要输出的每个字符一个一个的输出到控制台。普通使用并没有问题，可是当多线程同步输出的时候问题就来了，由于很多 println() 同时打印，就会导致控制台上的字符混乱的堆在一起，而NSLog() 就没有这个问题。到底是什么样子的呢？你可以把上面 NSLog() 改为 println() ，然后一试便知。 更多 NSLog() 与 println() 的区别看这里</p>

<p>自定义Operation
除了上面的两种 Operation 以外，我们还可以自定义 Operation。自定义 Operation 需要继承 NSOperation 类，并实现其 main() 方法，因为在调用 start() 方法的时候，内部会调用 main() 方法完成相关逻辑。所以如果以上的两个类无法满足你的欲望的时候，你就需要自定义了。你想要实现什么功能都可以写在里面。除此之外，你还需要实现 cancel() 在内的各种方法。所以这个功能提供给高级玩家，我在这里就不说了，等我需要用到时在研究它，到时候可能会再做更新。</p>

<p>创建队列</p>

<p>看过上面的内容就知道，我们可以调用一个 NSOperation 对象的 start() 方法来启动这个任务，但是这样做他们默认是 同步执行 的。就算是 addExecutionBlock 方法，也会在 当前线程和其他线程 中执行，也就是说还是会占用当前线程。这是就要用到队列 NSOperationQueue 了。而且，按类型来说的话一共有两种类型：主队列、其他队列。只要添加到队列，会自动调用任务的 start() 方法</p>

<p>主队列
细心的同学就会发现，每套多线程方案都会有一个主线程（当然啦，说的是iOS中，像 pthread 这种多系统的方案并没有，因为 UI线程 理论需要每种操作系统自己定制）。这是一个特殊的线程，必须串行。所以添加到主队列的任务都会一个接一个地排着队在主线程处理。</p>

<p>//OBJECTIVE-C
    NSOperationQueue *queue = [NSOperationQueue mainQueue];
    //SWIFT
    let queue = NSOperationQueue.mainQueue()
其他队列
因为主队列比较特殊，所以会单独有一个类方法来获得主队列。那么通过初始化产生的队列就是其他队列了，因为只有这两种队列，除了主队列，其他队列就不需要名字了。</p>

<p>注意：其他队列的任务会在其他线程并行执行。</p>

<p>OBJECTIVE-C</p>

<pre><code>//1.创建一个其他队列    
NSOperationQueue *queue = [[NSOperationQueue alloc] init];
//2.创建NSBlockOperation对象
NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^{
    NSLog(@"%@", [NSThread currentThread]);
}];
//3.添加多个Block
for (NSInteger i = 0; i &lt; 5; i++) {
    [operation addExecutionBlock:^{
        NSLog(@"第%ld次：%@", i, [NSThread currentThread]);
    }];
}
//4.队列添加任务
[queue addOperation:operation];
</code></pre>

<p>SWIFT</p>

<pre><code>//1.创建其他队列
let queue = NSOperationQueue()
//2.创建NSBlockOperation对象
let operation = NSBlockOperation { () -&gt; Void in
    NSLog("%@", NSThread.currentThread())
}
//3.添加多个Block
for i in 0.. Void in
        NSLog("第%ld次 - %@", i, NSThread.currentThread())
    }
}
//4.队列添加任务
queue.addOperation(operation)
</code></pre>

<p>打印输出</p>

<pre><code>2015-07-28 20:26:28.463 test[18622:4443534]{number = 5, name = (null)}
2015-07-28 20:26:28.463 test[18622:4443536] 第2次 -{number = 2, name = (null)}
2015-07-28 20:26:28.463 test[18622:4443535] 第0次 -{number = 4, name = (null)}
2015-07-28 20:26:28.463 test[18622:4443533] 第1次 -{number = 3, name = (null)}
2015-07-28 20:26:28.463 test[18622:4443534] 第3次 -{number = 5, name = (null)}
2015-07-28 20:26:28.463 test[18622:4443536] 第4次 -{number = 2, name = (null)}
</code></pre>

<p>OK, 这时应该发问了，大家将 NSOperationQueue 与 GCD的队列 相比较就会发现，这里没有并行队列，那如果我想要10个任务在其他线程串行的执行怎么办？</p>

<p>这就是苹果封装的妙处，你不用管串行、并行、同步、异步这些名词。NSOperationQueue 有一个参数 maxConcurrentOperationCount 最大并发数，用来设置最多可以让多少个任务同时执行。当你把它设置为 1 的时候，他不就是串行了嘛！</p>

<p>NSOperationQueue 还有一个添加任务的方法，- (void)addOperationWithBlock:(void (^)(void))block; ，这是不是和 GCD 差不多？这样就可以添加一个任务到队列中了，十分方便。</p>

<p>NSOperation 有一个非常实用的功能，那就是添加依赖。比如有 3 个任务：A: 从服务器上下载一张图片，B：给这张图片加个水印，C：把图片返回给服务器。这时就可以用到依赖了:</p>

<p>OBJECTIVE-C</p>

<pre><code>//1.任务一：下载图片
NSBlockOperation *operation1 = [NSBlockOperation blockOperationWithBlock:^{
    NSLog(@"下载图片 - %@", [NSThread currentThread]);
    [NSThread sleepForTimeInterval:1.0];
}];
//2.任务二：打水印
NSBlockOperation *operation2 = [NSBlockOperation blockOperationWithBlock:^{
    NSLog(@"打水印   - %@", [NSThread currentThread]);
    [NSThread sleepForTimeInterval:1.0];
}];
//3.任务三：上传图片
NSBlockOperation *operation3 = [NSBlockOperation blockOperationWithBlock:^{
    NSLog(@"上传图片 - %@", [NSThread currentThread]);
    [NSThread sleepForTimeInterval:1.0];
}];
//4.设置依赖
[operation2 addDependency:operation1];      //任务二依赖任务一
[operation3 addDependency:operation2];      //任务三依赖任务二
//5.创建队列并加入任务
NSOperationQueue *queue = [[NSOperationQueue alloc] init];
[queue addOperations:@[operation3, operation2, operation1] waitUntilFinished:NO];
</code></pre>

<p>SWIFT</p>

<pre><code>//1.任务一：下载图片
let operation1 = NSBlockOperation { () -&gt; Void in
    NSLog("下载图片 - %@", NSThread.currentThread())
    NSThread.sleepForTimeInterval(1.0)
}
//2.任务二：打水印
let operation2 = NSBlockOperation { () -&gt; Void in
    NSLog("打水印   - %@", NSThread.currentThread())
    NSThread.sleepForTimeInterval(1.0)
}
//3.任务三：上传图片
let operation3 = NSBlockOperation { () -&gt; Void in
    NSLog("上传图片 - %@", NSThread.currentThread())
    NSThread.sleepForTimeInterval(1.0)
}
//4.设置依赖
operation2.addDependency(operation1)    //任务二依赖任务一
operation3.addDependency(operation2)    //任务三依赖任务二
//5.创建队列并加入任务
let queue = NSOperationQueue()
queue.addOperations([operation3, operation2, operation1], waitUntilFinished: false)
</code></pre>

<p>打印结果</p>

<pre><code>2015-07-28 21:24:28.622 test[19392:4637517] 下载图片 -{number = 2, name = (null)}
2015-07-28 21:24:29.622 test[19392:4637515] 打水印 -{number = 3, name = (null)}
2015-07-28 21:24:30.627 test[19392:4637515] 上传图片 -{number = 3, name = (null)}
</code></pre>

<p>注意：不能添加相互依赖，会死锁，比如 A依赖B，B依赖A。
可以使用 removeDependency 来解除依赖关系。
可以在不同的队列之间依赖，反正就是这个依赖是添加到任务身上的，和队列没关系。
其他方法</p>

<p>以上就是一些主要方法, 下面还有一些常用方法需要大家注意：</p>

<pre><code>NSOperation
BOOL executing; //判断任务是否正在执行
BOOL finished; //判断任务是否完成
void (^completionBlock)(void); //用来设置完成后需要执行的操作
- (void)cancel; //取消任务
- (void)waitUntilFinished; //阻塞当前线程直到此任务执行完毕
NSOperationQueue
NSUInteger operationCount; //获取队列的任务数
- (void)cancelAllOperations; //取消队列中所有的任务
- (void)waitUntilAllOperationsAreFinished; //阻塞当前线程直到此队列中的所有任务执行完毕
[queue setSuspended:YES]; // 暂停queue
[queue setSuspended:NO]; // 继续queue
</code></pre>

<p>好啦，到这里差不多就讲完了。当然，我讲的并不完整，可能有一些知识我并没有讲到，但作为常用方法，这些已经足够了。不过我在这里只是告诉你了一些方法的功能，只是怎么把他们用到合适的地方，就需要多多实践了。下面我会说一些关于多线程的案例，是大家更加什么地了解。</p>

<p>其他用法</p>

<p>在这部分，我会说一些和多线程知识相关的案例，可能有些很简单，大家早都知道的，不过因为这篇文章讲的是多线程嘛，所以应该尽可能的全面嘛。还有就是，我会尽可能的使用多种方法实现，让大家看看其中的区别。</p>

<p>线程同步</p>

<p>所谓线程同步就是为了防止多个线程抢夺同一个资源造成的数据安全问题，所采取的一种措施。当然也有很多实现方法，请往下看：</p>

<p>互斥锁 ：给需要同步的代码块加一个互斥锁，就可以保证每次只有一个线程访问此代码块。
OBJECTIVE-C</p>

<pre><code>@synchronized(self) {
    //需要执行的代码块
}
</code></pre>

<p>SWIFT</p>

<pre><code>objc_sync_enter(self)
//需要执行的代码块
objc_sync_exit(self)
</code></pre>

<p>同步执行 ：我们可以使用多线程的知识，把多个线程都要执行此段代码添加到同一个串行队列，这样就实现了线程同步的概念。当然这里可以使用 GCD 和 NSOperation 两种方案，我都写出来。
OBJECTIVE-C</p>

<pre><code>  //GCD
  //需要一个全局变量queue，要让所有线程的这个操作都加到一个queue中
  dispatch_sync(queue, ^{
      NSInteger ticket = lastTicket;
      [NSThread sleepForTimeInterval:0.1];
      NSLog(@"%ld - %@",ticket, [NSThread currentThread]);
      ticket -= 1;
      lastTicket = ticket;
  });
  //NSOperation &amp; NSOperationQueue
  //重点：1. 全局的 NSOperationQueue, 所有的操作添加到同一个queue中
  //       2. 设置 queue 的 maxConcurrentOperationCount 为 1
  //       3. 如果后续操作需要Block中的结果，就需要调用每个操作的waitUntilFinished，阻塞当前线程，一直等到当前操作完成，才允许执行后面的。waitUntilFinished 要在添加到队列之后！
  NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^{
      NSInteger ticket = lastTicket;
      [NSThread sleepForTimeInterval:1];
      NSLog(@"%ld - %@",ticket, [NSThread currentThread]);
      ticket -= 1;
      lastTicket = ticket;
  }];
  [queue addOperation:operation];
  [operation waitUntilFinished];
  //后续要做的事
</code></pre>

<p>SWIFT</p>

<p>这里的 swift 代码，我就不写了，因为每句都一样，只是语法不同而已，照着 OC 的代码就能写出 Swift 的。这篇文章已经老长老长了，我就不浪费篇幅了，又不是高中写作文。</p>

<p>延迟执行</p>

<p>所谓延迟执行就是延时一段时间再执行某段代码。下面说一些常用方法。</p>

<p>perform
OBJECTIVE-C</p>

<pre><code>  // 3秒后自动调用self的run:方法，并且传递参数：@"abc"
  [self performSelector:@selector(run:) withObject:@"abc" afterDelay:3];
</code></pre>

<p>SWIFT</p>

<p>之前就已经说过，Swift 里去掉了这个方法。</p>

<p>GCD
可以使用 GCD 中的 dispatch_after 方法，OC 和 Swift 都可以使用，这里只写 OC 的，Swift 的是一样的。</p>

<p>OBJECTIVE-C</p>

<pre><code>// 创建队列
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
// 设置延时，单位秒
double delay = 3; 
dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delay * NSEC_PER_SEC)), queue, ^{
    // 3秒后需要执行的任务
});
</code></pre>

<p>NSTimer
NSTimer 是iOS中的一个计时器类，除了延迟执行还有很多用法，不过这里直说延迟执行的用法。同样只写 OC 版的，Swift 也是相同的。</p>

<h6>OBJECTIVE-C</h6>

<pre><code>[NSTimer scheduledTimerWithTimeInterval:3.0 target:self selector:@selector(run:) userInfo:@"abc" repeats:NO];
</code></pre>

<p>单例模式</p>

<p>至于什么是单例模式，我也不多说，我只说说一般怎么实现。在 Objective-C 中，实现单例的方法已经很具体了，虽然有别的方法，但是一般都是用一个标准的方法了，下面来看看。</p>

<h6>OBJECTIVE-C</h6>

<pre><code>@interface Tool : NSObject
+ (instancetype)sharedTool;
@end
@implementation Tool
static id _instance;
+ (instancetype)sharedTool {
    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{
        _instance = [[Tool alloc] init];
    });
    return _instance;
}
@end
</code></pre>

<p>这里之所以将单例模式，是因为其中用到了 GCD 的 dispatch_once 方法。下面看 Swift 中的单例模式，在Swift中单例模式非常简单！想知道怎么从 OC 那么复杂的方法变成下面的写法的，请看这里</p>

<h6>SWIFT</h6>

<pre><code>class Tool: NSObject {
    static let sharedTool = Tool()
    // 私有化构造方法，阻止其他对象使用这个类的默认的'()'构造方法
    private override init() {}
}
</code></pre>

<p>从其他线程回到主线程的方法</p>

<p>我们都知道在其他线程操作完成后必须到主线程更新UI。所以，介绍完所有的多线程方案后，我们来看看有哪些方法可以回到主线程。</p>

<h6>NSThread</h6>

<pre><code>//Objective-C
[self performSelectorOnMainThread:@selector(run) withObject:nil waitUntilDone:NO];
//Swift
//swift 取消了 performSelector 方法。
GCD
//Objective-C
dispatch_async(dispatch_get_main_queue(), ^{
});
//Swift
dispatch_async(dispatch_get_main_queue(), { () -&gt; Void in
})
NSOperationQueue
//Objective-C
[[NSOperationQueue mainQueue] addOperationWithBlock:^{
}];
//Swift
NSOperationQueue.mainQueue().addOperationWithBlock { () -&gt; Void in
}
</code></pre>

<blockquote><p>总结:好的吧，总算写完了，纯手敲6k多字，感动死我了。花了两天，时间跨度有点大，所以可能有些地方上段不接下段或者有的地方不完整，如果你看着比较费力或者有什么地方有问题，都可以在评论区告诉我，我会及时修改的。当然啦，多线程的东西也不止这些，题目也就只是个题目，不要当真。想要了解更多的东西，还得自己去网上挖掘相关资料。多看看官方文档。实在是编不下去了，大家好好看~。对了，看我写的这么卖力，不打赏也得点个喜欢吧。</p></blockquote>

<hr />

<blockquote><p>更新：第一次放出来的时候，有很多地方有错误，很感谢有朋友提出来了。如果你看到有错误的地方，一定记得指出来，这样对大家都有帮助。还有一点对初学者来说，遇到不懂的方法，最好的办法就是查看官方文档，那里是最准确的，就算有几个单词不认识，查一下就好了，不会影响对整体的理解。</p></blockquote>
</div>
  
  




| <a href="/blog/2014/04/02/duoxianchengshiyong/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/04/01/duoxianchenghuizong/">多线程总结</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><h3>一、进程和线程</h3>

<h5>1.什么是进程</h5>

<p>进程是指在系统中正在运行的一个应用程序</p>

<p>每个进程之间是独立的，每个进程均运行在其专用且受保护的内存空间内</p>

<ul>
<li><p>比如同时打开QQ、Xcode，系统就会分别启动2个进程</p></li>
<li><p>通过“活动监视器”可以查看Mac系统中所开启的进程</p></li>
</ul>


<h5>2.什么是线程</h5>

<p>1个进程要想执行任务，必须得有线程（每1个进程至少要有1条线程）</p>

<p>线程是进程的基本执行单元，一个进程（程序）的所有任务都在线程中执行</p>

<p>比如使用酷狗播放音乐、使用迅雷下载电影，都需要在线程中执行</p>

<h5>3.线程的串行</h5>

<p>1个线程中任务的执行是串行的</p>

<p>如果要在1个线程中执行多个任务，那么只能一个一个地按顺序执行这些任务</p>

<p>也就是说，在同一时间内，1个线程只能执行1个任务</p>

<p>比如在1个线程中下载3个文件（分别是文件A、文件B、文件C）</p>

<h3>二、多线程</h3>

<h5>1.什么是多线程</h5>

<p>1个进程中可以开启多条线程，每条线程可以并行（同时）执行不同的任务</p>

<p>进程 ->车间，线程->车间工人</p>

<p>多线程技术可以提高程序的执行效率</p>

<p>比如同时开启3条线程分别下载3个文件（分别是文件A、文件B、文件C）</p>

<h5>2.多线程的原理</h5>

<p>同一时间，CPU只能处理1条线程，只有1条线程在工作（执行）
多线程并发（同时）执行，其实是CPU快速地在多条线程之间调度（切换）
如果CPU调度线程的时间足够快，就造成了多线程并发执行的假象
思考：如果线程非常非常多，会发生什么情况？
CPU会在N多线程之间调度，CPU会累死，消耗大量的CPU资源
每条线程被调度执行的频次会降低（线程的执行效率降低）</p>

<h5>3.多线程的优缺点</h5>

<ul>
<li>多线程的优点</li>
</ul>


<p>能适当提高程序的执行效率</p>

<p>能适当提高资源利用率（CPU、内存利用率）</p>

<ul>
<li>多线程的缺点</li>
</ul>


<p>开启线程需要占用一定的内存空间（默认情况下，主线程占用1M，子线程占用512KB），如果开启大量的线程，会占用大量的内存空间，降低程序的性能</p>

<p>线程越多，CPU在调度线程上的开销就越大</p>

<p>程序设计更加复杂：比如线程之间的通信、多线程的数据共享</p>

<h5>4.多线程在iOS开发中的应用</h5>

<p>主线程:一个iOS程序运行后，默认会开启1条线程，称为“主线程”或“UI线程”</p>

<p>主线程的主要作用</p>

<p>显示\刷新UI界面</p>

<p>处理UI事件（比如点击事件、滚动事件、拖拽事件等）</p>

<p>主线程的使用注意:别将比较耗时的操作放到主线程中。</p>

<p>耗时操作会卡住主线程，严重影响UI的流畅度，给用户一种“卡”的坏体验</p>

<h5>5.代码示例</h5>

<pre><code>//  YYViewController.m
//  01-阻塞主线程
//
//  Created by apple on 14-6-23.
//  Copyright (c) 2014年 itcase. All rights reserved.
//

#import "YYViewController.h"

@interface YYViewController ()
- (IBAction)btnClick;
@end


@implementation YYViewController


- (void)viewDidLoad
{
    [super viewDidLoad];
}


//按钮的点击事件
- (IBAction)btnClick {
    //1.获取当前线程
    NSThread *current=[NSThread currentThread];
    //2.使用for循环执行一些耗时操作
    for (int i=0; i&lt;10000; i++) {
        //3.输出线程
        NSLog(@"btnClick---%d---%@",i,current);
    }
}

@end
</code></pre>

<blockquote><p>说明：当点击执行的时候，textView点击无响应。</p></blockquote>

<p>执行分析：等待主线程串行执行。</p>

<p>开启子线程。</p>
</div>
  
  




| <a href="/blog/2014/04/01/duoxianchenghuizong/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/03/23/layoutsubviews%20drawrects/">layoutSubViews&drawRects会了吗？</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><p>首先两个方法都是异步执行。layoutSubviews方便数据计算，drawRect方便视图重绘。</p>

<h4>layoutSubviews在以下情况下会被调用：</h4>

<ul>
<li>1、init初始化不会触发layoutSubviews。</li>
<li>2、addSubview会触发layoutSubviews。</li>
<li>3、设置view的Frame会触发layoutSubviews，当然前提是frame的值设置前后发生了变化。</li>
<li>4、滚动一个UIScrollView会触发layoutSubviews。</li>
<li>5、旋转Screen会触发父UIView上的layoutSubviews事件。</li>
<li>6、改变一个UIView大小的时候也会触发父UIView上的layoutSubviews事件。</li>
<li>7、直接调用setLayoutSubviews。</li>
</ul>


<h4>drawRect在以下情况下会被调用：</h4>

<ul>
<li>1、如果在UIView初始化时没有设置rect大小，将直接导致drawRect不被自动调用。drawRect 掉用是在Controller->loadView, Controller->viewDidLoad 两方法之后掉用的.所以不用担心在 控制器中,这些View的drawRect就开始画了.这样可以在控制器中设置一些值给View(如果这些View draw的时候需要用到某些变量 值).</li>
<li>2、该方法在调用sizeToFit后被调用，所以可以先调用sizeToFit计算出size。然后系统自动调用drawRect:方法。</li>
<li>3、通过设置contentMode属性值为UIViewContentModeRedraw。那么将在每次设置或更改frame的时候自动调用drawRect:。</li>
<li>4、直接调用setNeedsDisplay，或者setNeedsDisplayInRect:触发drawRect:，但是有个前提条件是rect不能为0。</li>
</ul>


<blockquote><p>以上1,2推荐；而3,4不提倡</p></blockquote>

<h6>drawRect方法使用注意点：</h6>

<ul>
<li><p>1、 若使用UIView绘图，只能在drawRect：方法中获取相应的contextRef并绘图。如果在其他方法中获取将获取到一个invalidate 的ref并且不能用于画图。drawRect：方法不能手动显示调用，必须通过调用setNeedsDisplay 或 者 setNeedsDisplayInRect，让系统自动调该方法。</p></li>
<li><p>2、若使用calayer绘图，只能在drawInContext: 中（类似鱼drawRect）绘制，或者在delegate中的相应方法绘制。同样也是调用setNeedDisplay等间接调用以上方法
3、若要实时画图，不能使用gestureRecognizer，只能使用touchbegan等方法来掉用setNeedsDisplay实时刷新屏幕</p></li>
</ul>

</div>
  
  




| <a href="/blog/2014/03/23/layoutsubviews%20drawrects/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/03/21/mvc/">MVC初探+实战</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><p>这两天认真研究了一下MVC设计模式，在iOS开发中这个算是重点中的重点了，如果对MVC模式不理解或者说不会用，那么你iOS肯定学不好，或者写不出好的东西，当然本人目前也在学习中，不过既然能看到这篇文档，说明你已经开始着手学习并且想深入研究它了，个人也是研究很久才搞懂，就写下来希望对各位有用，也能方便自己以后开发中查看，好了废话不多说，下面就来详细介绍一下MVC，并且用实例验证一下在项目开发中怎么去使用它。</p>

<p>相信你对 MVC 设计模式 并不陌生，只是不能完全理解其中的含义或者不能很好的使用它。</p>

<p>从字面意思来理解， Modal , View , Controller ，其用意在于将数据与视图分离开来－－－－－－解藕。</p>

<p>在iOS cocoa touch 编程中， MVC机制被发挥得淋漓尽致。 MVC 示意图如下。 只有充分理解了MVC，才能在编写出优雅的iOS app。为充分理解 MVC， 相关的概念（比如： Delegate、 Protocol、 Notification 等）也要了然于胸。</p>

<pre><code> MVC 约定， Model 不允许与View 打交道。 Model 是管理数据的， 当Model中的数据发生变化时，与之对应的视图应更新。 这就需要一种机制来支持。为此 iOS 框架提供了两种支持机制： Notification 和KVO （Key-Value Observing）。
</code></pre>

<p>　　KVO 可简单理解为，为你所关注的 Key 对象注册一个监听器。 当有数据发生变化时，就会发出广播给所有的监听器。</p>

<pre><code>  MVC 也约定， View 不允许直接引用Modal， 它只能被Controller 所控制。 Controller 控制 View 显示什么数据。我们知道，View 所要显示的数据是来源于 Modal， View 上产生的事件 （ 比如 Touch事件）需要通知 Controller。 既然MVC 不允许直接打交道，就需要提供一种机制。 
</code></pre>

<p>  不错， iOS 确实提供了一种机制， 名曰： Delegate。 Delegate 这个词， 有人将它译为“委托”，也有人将它译为“代理”。名称上的差异没有什么，重要的是如何理解 Delegate。 Delegate设计模式的引入，就是为了解决UIView与Controller松耦合互动问题。</p>

<p>为便于理解， 这里截取一张来iOS MVC 示意图：</p>

<p>图片</p>

<p>我们在详细介绍下这张图的内涵：</p>

<ol>
<li>图中，绿色的箭头表示直接引用。 对View 的直接引用体现在 IBOutlet 上。 当引用一个View 时，比如Button。 需要在ViewController</li>
</ol>


<p>中声明一个  IBOutlet  UIButton * btn；</p>

<ol>
<li><p>然后，我们看View 是怎么向 Controller 通信的。对于这个，  iOS 有三种常见的模式：</p>

<ul>
<li><p> 设置View对应的Action Target。如设置UIButton的Touch up inside的Action Target。</p></li>
<li><p> 设置View的Delegate，如UIAlertViewDelegate, UIActionSheetDelegate，UITextFieldDelegate等。</p></li>
<li><p> 设置View的data source, 如UITableViewDataSource。</p></li>
</ul>


<p> 通过以上三种模式，View既能向Controller通信，又无需知道具体的Controller是谁，这样，View 就与Controller解耦了。</p>

<p>  除此之外， iOS 还提供了 Action-Target 模式来让Controller 监听View 触发的事件。 View 又是如何获取数据呢？ iOS提供了 Data source 的概念，其实也就是Protocol 的应用。</p></li>
</ol>


<blockquote><p>综上所述， 正是在iOS MVC框架的驱使下， 才需要深入理解 Delegate、Protocol等概念。</p></blockquote>

<p>下面来看看代码中是怎么实现的，</p>

<p>说到MVC我们一开始都是先从Model开始，然后再编写对应的View最后在控制器中做相应的控制</p>

<h3>一：Model</h3>

<p>1:首先我们先创建一个模型类，用于实现模型数据的读取</p>

<p>头文件中创建两个模型属性，和两个模型方法，</p>

<pre><code>#pragma mark 模型属性

//用于存储对应的数据

@property (nonatomic, copy) NSString *name;

@property (nonatomic, copy) NSString *icon;


#pragma mark 模型方法

//用于初始化模型数据

-(instancetype)initWithDict:(NSDictionary *)dict;

+(instancetype)shopWithDict:(NSDictionary *)dict;
</code></pre>

<p>实现文件中实现对应的模型方法，</p>

<pre><code>#pragma mark 模型方法de实现

-(instancetype)initWithDict:(NSDictionary *)dict{
    if (self == [super init]) {
        //创建模型并且通过字典的键获取里面的值放到模型属性中，方便后面用于数据处理直接食用
        shopsModel *shop = [[shopsModel alloc] init];
        shop.name = dict[@"name"];
        shop.icon = dict[@"icon"];
    }
    return self;
}

+(instancetype)shopWithDict:(NSDictionary *)dict
{
    return [[self alloc] initWithDict:dict];
}
</code></pre>

<h3>二：View</h3>

<p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>纯代码</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>************/</p>

<p>创建一个视图类，用于显示对应的视图（控件，数据）</p>

<p>头文件中通过模型定义一个属性，并且定义三个快速创建视图View的方法，这种方法是使用较多的，而且让人一看上去就知道怎么用</p>

<pre><code>//引入模型类
@class shopsModel;

@interface shopsView : UIView

@property (nonatomic, assign) shopsModel *shop;

//实例方法，使用模型快速创建视图View
-(instancetype)initWIthShop:(shopsModel *)shop;

//类方法，使用模型快速创建视图View
+(instancetype)shopWithShop:(shopsModel *)shop;

//用于创建View的一个类方法
+(instancetype)shopView;
</code></pre>

<p>实现文件中先导入模型类：</p>

<pre><code> 1 #import "shopsModel.h" 
</code></pre>

<p>然后实现对应的创建View的方法，</p>

<pre><code>-(instancetype)initWIthShop:(shopsModel *)shop
{
    if (self == [super init]) {
        self.shop = shop;
    }
    return self;
}

+(instancetype)shopWithShop:(shopsModel *)shop
{
    return [[self alloc] initWIthShop:shop];
}

+(instancetype)shopView
{
    return [[self alloc] init];
}
</code></pre>

<p>记得平时我们自定义View的时候，都是直接在init方法中做的，但是，这里有一个细节需要注意的，就是init方法内部会自动调用initWithFrame方法，我们要自定义View一般要做的就是设置View的布局和View的创建，而initWithFrame正好是控件布局之前创建控件的时候调用的，所以我们建议在这里设置他的Frame</p>

<p>这里我们先要在私有拓展中定义两个属性用于记录我们所创建的View的属性</p>

<pre><code>@property (nonatomic, weak) UIImageView *imageV;

@property (nonatomic, weak) UILabel *label;
</code></pre>

<p> 实现空间创建的View方法</p>

<p>//初始化View的方法
-(instancetype)initWithFrame:(CGRect)frame
{</p>

<pre><code>if (self == [super initWithFrame:frame]) {
    //创建UIImageView和UILabel把它加到自定义View上面，并且使用我们定义的属性纪录他，方便后面使用

    UIImageView *image = [[UIImageView alloc] init];
    [self addSubview:image];
    self.imageV = image;

    UILabel *label = [[UILabel alloc] init];
    [self addSubview:label];
    self.label = label;
}
return self;
</code></pre>

<p>}
在View中布局空间的时候就会调用下面的方法</p>

<p>//布局子控件方法
-(void)layoutSubviews
{
    [super layoutSubviews];</p>

<pre><code>//获取宽高
CGFloat W = self.frame.size.width;
CGFloat H = self.frame.size.height;

//设置自定义View中对应控件的Frame
self.imageV.frame = CGRectMake(0, 0, W, W);
self.label.frame = CGRectMake(0, W, W, H - W);
</code></pre>

<p>}
我们还有一个事情要做，就是重写通过模型创建的那个属性，将模型里面的属性设置到控件中对应的属性，</p>

<p>//重写Set方法，设置对应的数据
-(void)setSpView:(shopsModel *)shop
{
    _shop = shop;</p>

<pre><code>//使用模型中的数据设置控件对应的属性
self.imageV.image = [UIImage imageNamed:shop.icon];
self.label.text = shop.name;
</code></pre>

<p>}</p>

<p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>Xib</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>************/</p>

<p>关于Xib这里就不多做解释了</p>

<p>说一下怎么使用Xib创建一个我们自定义的View并且，在控制器里面显示</p>

<p>首先新建一个文件选中interface Builder中的空文件设置一个名字，就可以创建一个Xib文件</p>

<p>图片</p>

<p>————然后创建一个自定义View的类。</p>

<p>点击Xib会看到里面什么也没有，因为我需要自定View所以拖一个View到Xib内部，并且拖我们对应要实现的控件到View里面作为他的子控件，这里需要注意的我们需要设置Xib文件对应的类为我们创建的那个类的名字：</p>

<p>图片</p>

<p>然后我们要做的就是将我们放在View里面的属性设置对输出口（这里就是拖线）这里我们一般是拖到实现文件中的私有拓展中</p>

<pre><code>1 //控件输出口
2 
3 @property (weak, nonatomic) IBOutlet UIImageView *icon;
4 
5 @property (weak, nonatomic) IBOutlet UILabel *name;
</code></pre>

<p>再后面的操作之前我们还需要在头文件引入这个类，并且通过模型创建一个属性</p>

<pre><code> 1 //模型商品属性 
 2 @property (nonatomic, strong) shopsModel *shop; 
</code></pre>

<p>定义一个通过模型快速创建View的方法</p>

<pre><code> 1 //快速创建并且加载Xib文件的方法 
 2 +(instancetype)shopViewWithShop:(shopsModel *)shop; 
</code></pre>

<p>然后就是在实现文件中实现这个方法，我们是将Xib的加载封装在里面更好的实现解耦和不被外界知道</p>

<p>这里加载Xib文件的方式有两种</p>

<pre><code>/**
 *  便利创建自定义View的方法
 */
+(instancetype)shopViewWithShop:(shopsModel *)shop
{

    /**
     *  加载Xib文件
     */
    iCocosView *shops = [[[NSBundle mainBundle] loadNibNamed:@"shops.plist" owner:nil options:nil] lastObject];
    /**
     *  第二种方法
     */
//    UINib *nib = [UINib nibWithNibName:@"shops.plist" bundle:[NSBundle mainBundle]];
//    NSArray *arr = [nib instantiateWithOwner:nil options:nil].lastObject;

    shops.shop = shop;
    return shops;
}
</code></pre>

<p>这里同样需要实现重写那个通过模型创建的属性的Setter方法</p>

<pre><code>//重写Setter方法，设置View中对应的控件的属性为模型中的数据
-(void)setShop:(shopsModel *)shop
{
    _shop = shop;

    //设置模型属性
    self.icon.image = [UIImage imageNamed:shop.icon];
    self.name.text = shop.name;
}
</code></pre>

<h3>三：Controller</h3>

<p>完成上面之后，控制器里面实现久简单多了</p>

<p>定义一个可变数组用于存放我们的模型数据</p>

<p> 1 @property (nonatomic, strong) NSMutableArray *shops;</p>

<p> 使用懒加载的方式加载那个plist数据，并且转成模型放到一个数组中，方便后面的使用</p>

<pre><code>//懒加载
-(NSMutableArray *)shops
{
    if (_shops == nil) {
        //加载plist数据并且把他放到一个数组中
        NSArray *shopsArray = [NSArray arrayWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@"shops.plist" ofType:nil]];
        //初始化存放数据的可变模型数组
        _shops = [NSMutableArray array];

        //遍历那个存放好了plist数组的数组，把他放到一个字典中
        for (NSDictionary *arr in shopsArray) {

            //使用快速创建模型的方法创建一个模型对象，并且将他加到可变的模型数组中，方便后面使用
            shopsModel *shop = [shopsModel shopWithDict:arr];
            [_shops addObject:shop];
        }
    }
    return _shops;

}
</code></pre>

<p>最后我们就只需要在控制器里面控制并且使用上面的模型和View了，</p>

<p>先来看看纯代码是怎么实现的</p>

<pre><code>1     //使用快速创建方法去存放模型数据的数组中取出数据，通过View内部的实现显示到View上面
2     shopsView *shView = [shopsView shopWithShop:self.shops[count]];
3     //设置View的frame
4     shView.frame = CGRectMake(shopX, shopY, shopW, shopH);
5     //将自定义View加到界面中显示
6     [self.shopView addSubview:shView];
</code></pre>

<p>如果你使用的是Xib，方法和思路还是一样的</p>

<pre><code>//去存放模型数据的数组中取出数据
iCocosView *shop = self.shops[index];
//通过取出来的数据快速创建一个View放到view内部实现并且使用
iCocosView *shopView = [iCocosView shopViewWithShop:shop];
//设置View的Frame
shopView.frame = CGRectMake(shopX, shopY, shopW, shopH);
//将自定义的View添加到界面显示
[self.shopsView addSubview:shopView];
</code></pre>

<p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>Swift实现</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>********/</p>

<p>注：如果你没有一点Swift基础（基本语法都不知道，虽然和OC很相似，但看了也是没有用的），建议保留此文，后面学习的Swift过程中遇到的时候再拿来看看就完全不一样了。</p>

<p>最近swift被炒的很火，由于苹果今年做了一个很大的决定，就是Swift2.0将开源，9月份将会放出源码，就意味着我们可以知道这里面是怎么实现的，并且可以在Linux平台上写，我想好处远远不止这些。</p>

<p>笔者对swift也有些一些研究，平时在OC上面学习到一个好东西的时候都会使用实现一遍，所以这个就更不能例外了。</p>

<h3>一：Model</h3>

<p>第一步我们同样从模型下手，这里喝OC有些不同的是Swift只是在一个文件里面实现的</p>

<pre><code>import UIKit

class Shop: NSObject {

//定义变量字符串属性
var name:String!
var icon:String!

//初始化模型方法
init(dict:[String:String]) {
    super.init()

    //设置模型对应的属性
    self.name = dict["name"]
    self.icon = dict["icon"]

    //使用封装好的方法设置模型属性
    setValuesForKeysWithDictionary(dict)
}

}
</code></pre>

<h3>二：View</h3>

<p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>纯代码</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>**********/</p>

<p>自定义View中实现的方法也是差不多的，只是方法的形式和关键字不同而已</p>

<pre><code>import UIKit

class ShopView: UIView {

/// 懒加载控件
lazy var iconView:UIImageView = UIImageView()
lazy var nameView:UILabel = UILabel()


/**
初始化Frame
*/
override init(frame: CGRect) {
    super.init(frame: frame)

    //添加子控件到界面
    self.addSubview(iconView)
    self.addSubview(nameView)
    //设置Label的文字剧中
    nameView.textAlignment = NSTextAlignment.Center
}

/**
从文件中加载数据（Xib／StoryBoard）
*/
required init(coder aDecoder: NSCoder) {
    fatalError("init(coder:) has not been implemented")
}

/**
布局子控件方法
*/
override func layoutSubviews() {
    //获取宽高
    var W:CGFloat = self.frame.size.width
    var H:CGFloat = self.frame.size.height

    //设置UIImageView和UIlable的frame
    self.iconView.frame = CGRectMake(0, 0, W, W)
    self.nameView.frame = CGRectMake(0, W, W, H - W)
}
</code></pre>

<p>}</p>

<p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>Xib</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>**********/</p>

<p>使用Xib方式同样是先创建Xib，创建对应的类文件，设置Xib对应为我们创建的类，添加子控件，设置输出口，然后就实现对应的方法</p>

<pre><code>import UIKit

    class XMGShopView: UIView {

/** 图片 */
@IBOutlet weak var iconView: UIImageView!
/** 名字 */
@IBOutlet weak var nameLabel: UILabel!

var shop: Shop? {
    didSet {
        // 重写set方法
        iconView.image = UIImage(named: shop!.icon)
        nameLabel.text = shop!.name
    }
}
//加载Xib实现方法
class func shopView() -&gt; XMGShopView{
    return NSBundle.mainBundle().loadNibNamed("XMGShopView", owner: nil, options: nil).last as! XMGShopView
}
}
</code></pre>

<p>注：这里最值得注意的地方是didSet这个方法，其实在swift中海油一个方法叫willSet，他们是相对应的，使用来监听属性变化的，就相当于OC里面的KVO不过在这里叫做属性观察者，分别是在设置属性后和之前调用，这里由于需要只实现了设置之后观察属性的变化</p>

<h3>三：Conreoller</h3>

<p>关于控制器里面实现的代码和OC里面就有许多不同的地方了，特别是懒加载（lazy）这里，笔者也是搞了好久才搞明白</p>

<p>懒加载</p>

<pre><code>//使用lazy实现懒加载，这里使用的是一个叫做闭包返回值的东西来实现的
lazy var shops:NSMutableArray = {
    //从MainBundle中获取plist文件的路径
    let path:String = NSBundle.mainBundle().pathForResource("shops.plist", ofType: nil)!
    //加载plist文件放到一个可变数组里面，
    let tempArr:NSMutableArray = NSMutableArray(contentsOfFile: path)!
    //定义一个可变的数组，数组的大小就是上面那个存放plist数据的数组的大小
    let shopsArrM:NSMutableArray = NSMutableArray(capacity: tempArr.count)
    //遍历存放plist数据的那个数组，放到一个字典中去
    for dict in tempArr
    {
        //使用模型中实现的方法创建一个模型对象
        let shop: Shop = Shop(dict: dict as! [String : String])
        //将模型对象放到plist数组中
        shopsArrM.addObject(shop)
    }
    //返回那个存放模型数据的数组
    return shopsArrM
    }()下面就死创建并且显示View的实现
</code></pre>

<p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>纯代码</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>**********/</p>

<pre><code>    //创建一个自定义的View
    let shopView: ShopView = ShopView()
    //设置他的frame
    shopView.frame = CGRect(x: shopX, y: shopY, width: shopW, height: shopH)
    //取出模型数组中对应的数组设置到试图中（这里使用了？表示类型转换）
    shopView.shop = self.shops[index] as? Shop
    //添加并显示
    self.shopsView.addSubview(shopView)
</code></pre>

<p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>Xib</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>**********/</p>

<pre><code>//创建一个自定义的View
  let shopView: iCocosView = iCocosView.shopView()
  //设置他的frame
  shopView.frame = CGRect(x: shopX, y: shopY, width: shopW, height: shopH)
  //取出模型数组中对应的数组设置到试图中（这里使用了？表示类型转换）
  shopView.shop = self.shops[index] as? Shop
  //添加并显示
  self.shopsView.addSubview(shopView)
</code></pre>

<p>使用纯代码和Xib的方式没有什么不同，最主要是自定义View内部的实现。</p>

<p>mvc机制</p>

<p>说明：</p>

<ul>
<li><p>（1）在开发过程中，作为控制器处理的量级应该很轻，不该操心的不操心。协调好模型和视图就ok了，要学会当一个好老板。</p></li>
<li><p>（2）三个部分各司其职，数据模型只负责数据的处理，视图部分只负责把拿到的数据进行显示，两个部分都是被动的，等待着大管家控制器的调遣。</p></li>
<li><p>（3）在OC中，如果视图和数据模型之间有通道，那控制器是否处于失控状态呢？</p></li>
</ul>


<p>网上有人是这里理解MVC的：</p>

<p>MVC是Model-VIew-Controller，就是模型－视图－控制器，这些都是什么东西呢？MVC把软件系统分为三个部分：Model，View。controller。在cocoa中，你的程序中的每一个object（对象）都将明显地仅属于这三部分中的一个，而完全不属于另外两个。</p>

<p>　　　　　　Model = 你的程序是什么(而不是你的程序是如何显示的)</p>

<p>让我们举个例子，我们上中学的时候，我们的步步高电子词典中有个游戏叫“雷霆战机”，也就是“打飞机”的游戏，Model就是：你的小飞机的攻击力是多少？你的小飞机上装的是什么武器，炮弹，导弹，还是激光炮？你的小飞机还有多少血？等等。再概括点说，就是你的程序将要实现的功能，或者是它所能干的事情。</p>

<pre><code>              Controller = 如何使你的模型呈现给用户(程序逻辑)
</code></pre>

<p>Controller是程序内部的逻辑，大多情况下你将看不到它，它将Model和View捆绑在一起，它将处理用户的输入，例如，你按开炮的键子，Controller就会通过内部的逻辑来处理你的要求，并在屏幕上做出相应的显示，你将看到屏幕上的小飞机发出炮弹击中敌机。这也是Controller控制View的显示的例子。所以你可以把Controller看成是连接M和V的桥梁。</p>

<pre><code>              View ＝ 在屏幕上你所看到的（是你的Controller的“奴才”）
</code></pre>

<p>接着前面的小飞机，View就是：你的小飞机是什么样子的，有一个还是两个翅膀，有几挺枪炮；还有，你的飞机在屏幕上的位置等等。总之，你在屏幕上看到的组件都可以归类为View。</p>
</div>
  
  




| <a href="/blog/2014/03/21/mvc/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/03/21/init%20pic/">初始化图片</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><h3>一.读取图片</h3>

<h6>1.从资源(resource)读取</h6>

<pre><code>UIImage* image=[UIImage imageNamed:@"1.jpg"];  
</code></pre>

<h6>2.从网络读取</h6>

<pre><code>NSURL *url=[NSURL URLWithString:@"http://www.sinaimg.cn/qc/photo_auto/chezhan/2012/50/00/15/80046_950.jpg"];  
UIImage *imgFromUrl =[[UIImage alloc]initWithData:[NSData dataWithContentsOfURL:url]];  
</code></pre>

<h6>3.从手机本地读取</h6>

<p>读取本地图片非resource</p>

<pre><code>NSString *aPath3=[NSString stringWithFormat:@"%@/Documents/%@.jpg",NSHomeDirectory(),@"test"];  
UIImage *imgFromUrl3=[[UIImage alloc]initWithContentsOfFile:aPath3];  
UIImageView* imageView3=[[UIImageView alloc]initWithImage:imgFromUrl3];  
</code></pre>

<h6>4.从现有的context中获得图像</h6>

<pre><code>//add ImageIO.framework and #import     
CGImageSourceRef source = CGImageSourceCreateWithURL((CFURLRef)url, NULL);  
CGImageRef img= CGImageSourceCreateImageAtIndex(source,0,NULL);  
CGContextRef ctx=UIGraphicsGetCurrentContext();  
CGContextSaveGState(ctx);  
//transformCTM的2种方式  
//CGContextConcatCTM(ctx, CGAffineTransformMakeScale(.2, -0.2));  
//CGContextScaleCTM(ctx,1,-1);  
//注意坐标要反下,用ctx来作为图片源   
CGImageRef capture=CGBitmapContextCreateImage(ctx);  
CGContextDrawImage(ctx, CGRectMake(160, 0, 160, 230), [image CGImage]);  
CGContextDrawImage(ctx, CGRectMake(160, 230, 160, 230), img);  
CGImageRef capture2=CGBitmapContextCreateImage(ctx);  
</code></pre>

<h6>5.用Quartz的CGImageSourceRef来读取图片</h6>

<pre><code>CGImageSourceRef source = CGImageSourceCreateWithURL((CFURLRef)url, NULL);  
CGImageRef img= CGImageSourceCreateImageAtIndex(source,0,NULL);  
</code></pre>

<h3>二.保存图片</h3>

<h6>1.转换成NSData来保存图片（imgFromUrl是UIImage）</h6>

<p>保存图片 2种获取路径都可以</p>

<pre><code>//NSArray*paths=NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);  
//NSString*documentsDirectory=[paths objectAtIndex:0];    
//NSString*aPath=[documentsDirectory stringByAppendingPathComponent:[NSString stringWithFormat:@"%@.jpg",@"test"]];   
NSString *aPath=[NSString stringWithFormat:@"%@/Documents/%@.jpg",NSHomeDirectory(),@"test"];  
NSData *imgData = UIImageJPEGRepresentation(imgFromUrl,0);      
[imgData writeToFile:aPath atomically:YES];     
</code></pre>

<h6>2.用Quartz的CGImageDestinationRef来输出图片，这个方式不常见，所以不做介绍，详细可以看apple文档Quartz 2D Programming Guide</h6>

<h3>三.绘制图(draw|painting)</h3>

<h6>1.UIImageView方式加入到UIView层</h6>

<pre><code>UIImageView* imageView=[[UIImageView alloc]initWithImage:image];  
imageView.frame=CGRectMake(0, 0, 320, 480);  
[self addSubview:imageView];  
[imageView release];  
</code></pre>

<h6>2.[img drawAtPoint]系列方法</h6>

<pre><code>[image4 drawAtPoint:CGPointMake(100, 0)];    
</code></pre>

<h6>3.CGContextDrawImage</h6>

<pre><code>CGContextDrawImage(ctx, CGRectMake(160, 0, 160, 230), [image CGImage]);  
</code></pre>

<h6>4.CGLayer</h6>

<p>这个是apple推荐的一种offscreen的绘制方法，相比bitmapContext更好，因为它似乎会利用iphone硬件(drawing-card)加速</p>

<pre><code>CGLayerRef cg=CGLayerCreateWithContext(ctx, CGSizeMake(320, 480), NULL);  
//需要将CGLayerContext来作为缓存context，这个是必须的  
CGContextRef layerContext=CGLayerGetContext(cg);  
CGContextDrawImage(layerContext, CGRectMake(160, 230, 160, 230), img);   
CGContextDrawLayerAtPoint(ctx, CGPointMake(0, 0), cg);  
</code></pre>

<h6>5.CALayer的contents</h6>

<pre><code>UIImage* image=[UIImage imageNamed:@"1.jpg"];  
CALayer *ly=[CALayer layer];  
ly.frame=CGRectMake(0, 0, 320, 460);  
ly.contents=[image CGImage];  
[self.layer addSublayer:ly];  
</code></pre>

<h3>四.其它</h3>

<h6>1.CGImage和UIImage互换</h6>

<p>这样就可以随时切换UIKit和Quartz之间类型，并且选择您熟悉的方式来处理图片.</p>

<pre><code>CGImage cgImage=[uiImage CGImage];
UIImage* uiImage=[UIImage imageWithCGImage:cgImage];
</code></pre>
</div>
  
  




| <a href="/blog/2014/03/21/init%20pic/#comments">更多评论</a>

    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/8">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/6">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
    <h1>文章分类</h1>
    <ul id="categories">
        <li class='category'><a href='/blog/categories/全栈工程师必备/'>全栈工程师必备 (2)</a></li>
<li class='category'><a href='/blog/categories/底层开发/'>底层开发 (4)</a></li>
<li class='category'><a href='/blog/categories/开发工具/'>开发工具 (2)</a></li>
<li class='category'><a href='/blog/categories/性能相关/'>性能相关 (7)</a></li>
<li class='category'><a href='/blog/categories/性能问题/'>性能问题 (4)</a></li>
<li class='category'><a href='/blog/categories/新技术/'>新技术 (1)</a></li>
<li class='category'><a href='/blog/categories/欢迎来到ios梦工厂/'>欢迎来到ios梦工厂 (1)</a></li>
<li class='category'><a href='/blog/categories/程序员必备/'>程序员必备 (6)</a></li>
<li class='category'><a href='/blog/categories/适配问题/'>适配问题 (1)</a></li>
<li class='category'><a href='/blog/categories/面试总结-技术/'>面试总结＋技术 (1)</a></li>
<li class='category'><a href='/blog/categories/面试汇总/'>面试汇总 (1)</a></li>
<li class='category'><a href='/blog/categories/项目实战/'>项目实战 (17)</a></li>
<li class='category'><a href='/blog/categories/高级开发/'>高级开发 (25)</a></li>

    </ul>
</section><section>
  <h1>最新文章</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/12/11/anquan/">安全机制</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/12/11/java/">爬虫必备-java抓包</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/12/11/zhengze/">爬虫必备-正则表达式</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/12/11/qinghuaci/">爬虫必备-青花瓷</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/12/11/python/">Python</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/al1020119">@al1020119</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'al1020119',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>




<section>
<h1>扫一扫<abbr title="The word '扫一扫' is a registered trademark of DENSO WAVE INCORPORATED. It applies only for the word '扫一扫', not for image.">&trade;</abbr></h1>
<a href="http://al1020119.github.io/posts/7/index.html"><img src="http://chart.apis.google.com/chart?chs=150x150&cht=qr&chld=|0&chco=165B94&chl=http://al1020119.github.io/posts/7/index.html" alt="post-qrcode"></a></section>
<section>
    <h1>访客统计</h1>
    <br/>
    <a href="http://s07.flagcounter.com/more/2SH"><img src="http://s07.flagcounter.com/count/2SH/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_1/flags_0/" alt="Flag Counter" border="0"></a>
</section><section>
    <h1>新浪微博</h1>
    <ul id="weibo">
        <li>
            
            <!-- 在此插入获得的微博秀代码 -->
            <iframe width="100%" height="550" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=550&fansRow=2&ptype=1&speed=0&skin=1&isTitle=1&noborder=1&isWeibo=1&isFans=1&uid=3288975567&verifier=20ffcedd&dpc=1"></iframe>
            
        </li>
    </ul>
</section>
  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - iCocos -
<span class="credit">Preview in <a href="http://al1020119.github.io">[曹#黎]</a></span>
</p>

</footer>
  






<!--
--->



</body>
</html>
