<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Senior | iOS梦工厂]]></title>
  <link href="http://al1020119.github.io/blog/categories/senior/atom.xml" rel="self"/>
  <link href="http://al1020119.github.io/"/>
  <updated>2017-01-10T11:35:51+08:00</updated>
  <id>http://al1020119.github.io/</id>
  <author>
    <name><![CDATA[iCocos]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[重整之道（面试+技术+底层+高级）]]></title>
    <link href="http://al1020119.github.io/blog/2016/07/26/chongzhengzhidao/"/>
    <updated>2016-07-26T13:53:19+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/07/26/chongzhengzhidao</id>
    <content type="html"><![CDATA[<p>重整之道（面试+技术+底层+高级）</p>

<p>不要问我为什么写这篇文章。</p>

<p>我，就是这么有尿性。。。。。。。。。。</p>

<p>前面三部分已经基本上完成，后面部分会陆续更新，敬请期待。但是光靠一篇这么短的文章想将通这些事不可能的，这里主要正对面试族，或者健忘族，亦或者是装逼族。好了废话不多说，我们开始吧！</p>

<ul>
<li>运行时（底层）</li>
<li>RunLoop（底层）</li>
<li>多线程（底层与安全）</li>
</ul>


<hr />

<ul>
<li>网络（底层与安全）</li>
<li>数据持久化（各种使用与区别）（CoreData、SQLite）</li>
<li>Block（底层/__Block）</li>
<li>音视频</li>
<li>直播</li>
<li>安全</li>
<li>优化（性能、卡顿）</li>
<li>常见错误</li>
<li>常用技术</li>
<li>全栈相关</li>
<li>算法（常用、排序）</li>
<li>数据结构</li>
<li>设计模式（32中）</li>
<li>架构设计</li>
<li>逆向工程</li>
<li>实战应用</li>
</ul>


<!--more-->


<h3>运行时（底层）</h3>

<h6>介绍</h6>

<p>runtime是一个c和汇编写的动态库(感谢Lision的指正)，是一套比较底层的C语言API，属于一个C语言库，平时我们所写的OC代码，最终都会转成runtime的C语言代码去执行。</p>

<p>这个系统主要做两件事 ：</p>

<ol>
<li>封装C语言的结构体和函数，让开发者在运行时创建、检查或者修改类、对象和方法等等。</li>
<li>传递消息，找出方法的最终执行代码。</li>
</ol>


<h6>常用关键字</h6>

<p>要想全面了解 Runtime 机制，我们必须先了解 Runtime 的一些术语，他们都对应着数据结构。</p>

<p>SEL</p>

<pre><code>它是selector在 Objc 中的表示(Swift 中是 Selector 类)。selector 是方法选择器，其实作用就和名字一样，日常生活中，我们通过人名辨别谁是谁，注意 Objc 在相同的类中不会有命名相同的两个方法。selector 对方法名进行包装，以便找到对应的方法实现。它的数据结构是：

typedef struct objc_selector *SEL;

我们可以看出它是个映射到方法的 C 字符串，你可以通过 Objc 编译器器命令@selector() 或者 Runtime 系统的 sel_registerName 函数来获取一个 SEL 类型的方法选择器。

注意：
不同类中相同名字的方法所对应的 selector 是相同的，由于变量的类型不同，所以不会导致它们调用方法实现混乱。
</code></pre>

<p>id</p>

<pre><code>id 是一个参数类型，它是指向某个类的实例的指针。定义如下：

以上定义，看到 objc_object 结构体包含一个 isa 指针，根据 isa 指针就可以找到对象所属的类。

注意：
isa 指针在代码运行时并不总指向实例对象所属的类型，所以不能依靠它来确定类型，要想确定类型还是需要用对象的 -class 方法。

PS:KVO 的实现机理就是将被观察对象的 isa 指针指向一个中间类而不是真实类型，详见:KVO章节。
</code></pre>

<p>Class</p>

<pre><code>typedef struct objc_class *Class;

Class 其实是指向 objc_class 结构体的指针。

一个运行时类中关联了它的父类指针、类名、成员变量、方法、缓存以及附属的协议。


由此可见，我们可以动态修改 *methodList 的值来添加成员方法，这也是 Category 实现的原理，同样解释了 Category 不能添加属性的原因。这里可以参考下美团技术团队的文章：深入理解 Objective-C: Category。

objc_ivar_list 结构体用来存储成员变量的列表，而 objc_ivar 则是存储了单个成员变量的信息；同理，objc_method_list 结构体存储着方法数组的列表，而单个方法的信息则由 objc_method 结构体存储。

值得注意的时，objc_class 中也有一个 isa 指针，这说明 Objc 类本身也是一个对象。为了处理类和对象的关系，Runtime 库创建了一种叫做 Meta Class(元类) 的东西，类对象所属的类就叫做元类。Meta Class 表述了类对象本身所具备的元数据。

我们所熟悉的类方法，就源自于 Meta Class。我们可以理解为类方法就是类对象的实例方法。每个类仅有一个类对象，而每个类对象仅有一个与之相关的元类。

当你发出一个类似 [NSObject alloc](类方法) 的消息时，实际上，这个消息被发送给了一个类对象(Class Object)，这个类对象必须是一个元类的实例，而这个元类同时也是一个根元类(Root Meta Class)的实例。所有元类的 isa 指针最终都指向根元类。

所以当 [NSObject alloc] 这条消息发送给类对象的时候，运行时代码 objc_msgSend() 会去它元类中查找能够响应消息的方法实现，如果找到了，就会对这个类对象执行方法调用。



super_class 指针，虚线时 isa 指针。而根元类的父类是 NSObject，isa指向了自己。而 NSObject 没有父类。

最后 objc_class 中还有一个 objc_cache ，缓存，它的作用很重要，后面会提到。
</code></pre>

<p>Method</p>

<pre><code>Method 代表类中某个方法的类型

typedef struct objc_method *Method;

objc_method 存储了方法名，方法类型和方法实现：

方法名类型为 SEL
方法类型 method_types 是个 char 指针，存储方法的参数类型和返回值类型
method_imp 指向了方法的实现，本质是一个函数指针
</code></pre>

<p>Ivar</p>

<pre><code>Ivar 是表示成员变量的类型。

typedef struct objc_ivar *Ivar;


其中 ivar_offset 是基地址偏移字节
</code></pre>

<p>IMP</p>

<pre><code>IMP在objc.h中的定义是：

typedef id (*IMP)(id, SEL, ...);

它就是一个函数指针，这是由编译器生成的。当你发起一个 ObjC 消息之后，最终它会执行的那段代码，就是由这个函数指针指定的。而 IMP 这个函数指针就指向了这个方法的实现。

如果得到了执行某个实例某个方法的入口，我们就可以绕开消息传递阶段，直接执行方法，这在后面 Cache 中会提到。

你会发现 IMP 指向的方法与 objc_msgSend 函数类型相同，参数都包含 id 和 SEL 类型。每个方法名都对应一个 SEL 类型的方法选择器，而每个实例对象中的 SEL 对应的方法实现肯定是唯一的，通过一组 id和 SEL 参数就能确定唯一的方法实现地址。

而一个确定的方法也只有唯一的一组 id 和 SEL 参数。
</code></pre>

<p>Cache</p>

<pre><code>typedef struct objc_cache *Cache

Cache 为方法调用的性能进行优化，每当实例对象接收到一个消息时，它不会直接在 isa 指针指向的类的方法列表中遍历查找能够响应的方法，因为每次都要查找效率太低了，而是优先在 Cache 中查找。

Runtime 系统会把被调用的方法存到 Cache 中，如果一个方法被调用，那么它有可能今后还会被调用，下次查找的时候就会效率更高。就像计算机组成原理中 CPU 绕过主存先访问 Cache 一样。
</code></pre>

<p>Property
    typedef struct objc_property *objc_property_t;//这个更常用</p>

<pre><code>可以通过class_copyPropertyList 和 protocol_copyPropertyList 方法获取类和协议中的属性：

注意：
返回的是属性列表，列表中每个元素都是一个 objc_property_t 指针
</code></pre>

<h6>动态特性</h6>

<pre><code>Objective-C具有相当多的动态特性，基本的，也是经常被提到和用到的有

    动态类型（Dynamic typing）
    动态绑定（Dynamic binding）
    动态加载（Dynamic loading）

动态类型：程序直到执行时才能确定所属的类。

id 数据类型，id 通用的对象类型，可以存储任意类型的对象，id后面没有号，它本身就是个指针，类似于void ，但只可以指向对象类型

静态类型与动态类型

    编译期检查与运行时检查
    静态类型在编译期就能检查出错误
    静态类型声明代码可读性好
    动态类型只有在运行时才能发现错误

动态绑定：程序直到执行时才能确定实际要调用的方法。

动态绑定所做的，即是在实例所属类确定后，将某些属性和相应的方法绑定到实例上。

说明：objective-c 中的BOOL实际上是一种对带符号的字符类型（signed char）的类型定义（typedef），它使用8位的存储空间。通过#define指令把YES定义为1，NO定义为0。

动态加载：根据需求加载所需要的资源

这点很容易理解，对于iOS开发来说，基本就是根据不同的机型做适配。最经典的例子就是在Retina设备上加载@2x的图片，而在老一些的普通屏设备上加载原图。随着Retina iPad的推出，和之后可能的Retina Mac的出现，这个特性相信会被越来越多地使用。
多态的出现时为了让不同的类能使用同名的方法。这个让程序的可读性大大提高，也降低了编程难度。

动态类型与动态绑定是为了解决随多态的便利而引起的弊端，有了动态类型与动态绑定，不用去考虑输出中的方法是哪个类型的方法，会自动判定。

而id类型的出现就是为了更好的承接动态类型与动态方法出来的返回值。
</code></pre>

<h6>常用方法</h6>

<p>Ivar <em>ivars = class_copyIvarList([iCocosObject class], &amp;count);
Method </em>met = class_copyMethodList([iCocosObject class], &amp;meth);
objc_property_t *xsL = class_copyPropertyList([iCocosObject class], &amp;xs);
Method ic =  class_getInstanceMethod(NSClassFromString(@&ldquo;<em>NSArrayM&rdquo;), @selector(iCocosobject:));
Method add =  class_getInstanceMethod(NSClassFromString(@&ldquo;</em>NSArrayM&rdquo;), @selector(addObject:));</p>

<pre><code>objc_msgSend : 给对象发送消息
class_copyMethodList : 遍历某个类所有的方法
class_copyIvarList : 遍历某个类所有的成员变量
class_..... 这是我们学习runtime必须知道的函数！
</code></pre>

<h6>属性与成员变量</h6>

<p>Ivar: 实例变量类型，是一个指向objc_ivar结构体的指针。objc_property_t：声明的属性的类型，是一个指向objc_property结构体的指针</p>

<ol>
<li>属性变量 是已经设置了 setter getter方法的 OC已经自己给设置了</li>
<li>属性变量 你每次调用 self.属性变量 的时候 都要调用getter或者setter方法
封装</li>
</ol>


<p>如果成员变量是private，程序中的其它对象很难直接访问该成员变量。如果是属性，相对更容易用父类方法读写属性。</p>

<p>性能</p>

<pre><code>成员变量地址可以根据实例的内存地址偏移寻址。而属性的读写都需要函数调用，相对更慢。
</code></pre>

<p>非基础类型</p>

<pre><code>对于复杂的C++类型，往往设为成员变量更合适，也许这种类型不支持copy，或者完全复制很麻烦。
</code></pre>

<p>多线程</p>

<pre><code>多线程环境下，为保证数据一致性，在需要同步执行的代码段更应该使用成员变量。如果对需要同步更新的数据用getter/setter 方法，数据更新效率低，会带来更多的获取锁请求失败。
</code></pre>

<p>程序正确性</p>

<pre><code>成员变量可以做直观的内存管理。属性可以一层层继承，还可以复写。容易出错。
</code></pre>

<p>二进制文件的体积</p>

<pre><code>默认用属性，会生成不必要的getter/setter 方法，程序体积会变大。
</code></pre>

<p>1.如果只是单纯的private变量，最好声明在implementation里.
2.如果是类的public属性，就用property写在.h文件里
3.如果自己内部需要setter和getter来实现一些东西，就在.m文件的类目里用property来声明</p>

<h6>消息机制消息机制</h6>

<pre><code>[obj makeText];==objc_msgSend(obj, @selector (makeText));


首先通过obj的isa指针找到obj对应的class。

首先检测这个 selector 是不是要忽略。比如 Mac OS X 开发，有了垃圾回收就不理会 retain，release 这些函数。
检测这个 selector 的 target 是不是 nil，Objc 允许我们对一个 nil 对象执行任何方法不会 Crash，因为运行时会被忽略掉。
如果上面两步都通过了，那么就开始查找这个类的实现 IMP，
在Class中先去cache中 通过SEL查找对应函数method，找到就执行对应的实现。
若cache中未找到，再去methodList中查找，找到就执行对应的实现。
若methodlist中未找到，则取superClass中查找（重复执行以上两个步骤），直到找到最根的类为止。
若任何一部能找到，则将method加 入到cache中，以方便下次查找，并通过method中的函数指针跳转到对应的函数中去执行。
如果以上都不能找到，则会开始进行消息转发
</code></pre>

<h6>消息转发</h6>

<pre><code>1.动态方法解析：向当前类发送 resolveInstanceMethod: 信号，检查是否动态向该类添加了方法。（迷茫请搜索：@dynamic）
2.快速消息转发：检查该类是否实现了 forwardingTargetForSelector: 方法，若实现了则调用这个方法。若该方法返回值对象非nil或非self，则向该返回对象重新发送消息。
3.标准消息转发：runtime发送methodSignatureForSelector:消息获取Selector对应的方法签名。返回值非空则通过forwardInvocation:转发消息，返回值为空则向当前对象发送doesNotRecognizeSelector:消息，程序崩溃退出

总结就是：
在一个函数找不到时，OC提供了三种方式去补救：
1、调用resolveInstanceMethod给个机会让类添加这个实现这个函数
2、调用forwardingTargetForSelector让别的对象去执行这个函数
3、调用forwardInvocation（函数执行器）灵活的将目标函数以其他形式执行。
如果都不中，调用doesNotRecognizeSelector抛出异常。
</code></pre>

<h6>常见用途</h6>

<ul>
<li>增加，删除，修改一个类，属性，成员变量，方法</li>
</ul>


<h6>实际应用</h6>

<ul>
<li>关联对象</li>
<li>方法混淆</li>
<li>NSCoding(归档和解档, 利用runtime遍历模型对象的所有属性)</li>
<li>字典 &ndash;> 模型 (利用runtime遍历模型对象的所有属性, 根据属性名从字典中取出对应的值, 设置到模型的属性上)</li>
<li>KVO(利用runtime动态产生一个类)</li>
<li>用于封装框架(想怎么改就怎么改) 这就是我们runtime机制的只要运用方向</li>
</ul>


<h3>RunLoop（底层）</h3>

<h6>RunLoop 的简单概述</h6>

<p>RunLoop:</p>

<pre><code>   Runloop是事件接收和分发机制的一个实现。

   Runloop提供了一种异步执行代码的机制，不能并行执行任务。

   在主队列中，Main RunLoop直接配合任务的执行，负责处理UI事件、定时器以及其他内核相关事件。
</code></pre>

<p>主要目的：</p>

<pre><code>   保证程序执行的线程不会被系统终止。   
</code></pre>

<p>使用Runloop ？</p>

<pre><code>   当需要和该线程进行交互的时候才会使用Runloop.


   每一个线程都有其对应的RunLoop，但是默认非主线程的RunLoop是没有运行的，需要为RunLoop添加至少一个事件源，然后去run它。


   一般情况下我们是没有必要去启用线程的RunLoop的，除非你在一个单独的线程中需要长久的检测某个事件。
</code></pre>

<p>主线程默认有Runloop。当自己启动一个线程，如果只是用于处理单一的事件，则该线程在执行完之后就退出了。所以当我们需要让该线程监听某项事务
时，就得让线程一直不退出，runloop就是这么一个循环，没有事件的时候，一直卡着，有事件来临了，执行其对应的函数。</p>

<pre><code>   RunLoop,正如其名所示,是线程进入和被线程用来相应事件以及调用事件处理函数的地方.需要在代码中使用控制语句实现RunLoop的循环,也就是说,需要代码提供while或者for循环来驱动RunLoop.


   在这个循环中,使用一个runLoop对象[NSRunloop currentRunloop]执行接收消息,调用对应的处理函数.


    Runloop接收两种源事件:input sources和timer sources。


   input sources 传递异步事件，通常是来自其他线程和不同的程序中的消息；


   timer sources(定时器) 传递同步事件（重复执行或者在特定时间上触发）。


   除了处理input sources，Runloop
</code></pre>

<p>也会产生一些关于本身行为的notificaiton。注册成为Runloop的observer，可以接收到这些notification，做一些额外
的处理。（使用CoreFoundation来成为runloop的observer）。</p>

<p>Runloop工作的特点:</p>

<pre><code>   1&gt;当有时间发生时,Runloop会根据具体的事件类型通知应用程序作出相应;


   2&gt;当没有事件发生时,Runloop会进入休眠状态,从而达到省电的目的;


   3&gt;当事件再次发生时,Runloop会被重新唤醒,处理事件.
</code></pre>

<p>提示:一般在开发中很少会主动创建Runloop,而通常会把事件添加到Runloop中.</p>

<p>苹果提供了两个途径来获取分别是Cocoe里面定义的NSRunLoop以及CoreFoundation里面定义的CFRunLoopRef。</p>

<pre><code>CFRunLoopRef提供了纯C函数的API，所有这些API都是线程安全的。
NSRunLoop提供了面向对象的API，但这些API不是线程安全的。
</code></pre>

<h6>RunLoop 与线程的关系</h6>

<p>iOS 开发中能遇到两个线程对象: pthread_t 和 NSThread。过去苹果有份文档标明了 NSThread 只是 pthread_t 的封装，但那份文档已经失效了，现在它们也有可能都是直接包装自最底层的 mach thread。苹果并没有提供这两个对象相互转换的接口，但不管怎么样，可以肯定的是 pthread_t 和 NSThread 是一一对应的。比如，你可以通过 pthread_main_np() 或 [NSThread mainThread] 来获取主线程；也可以通过 pthread_self() 或 [NSThread currentThread] 来获取当前线程。CFRunLoop 是基于 pthread 来管理的。</p>

<p>苹果不允许直接创建 RunLoop，它只提供了两个自动获取的函数：CFRunLoopGetMain() 和 CFRunLoopGetCurrent()。</p>

<p>线程和 RunLoop 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 RunLoop（主线程除外）。</p>

<h6>RunLoop 的 Mode</h6>

<ol>
<li><p>kCFRunLoopDefaultMode: App的默认 Mode，通常主线程是在这个 Mode 下运行的。</p></li>
<li><p>UITrackingRunLoopMode: 界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响。</p></li>
<li><p>UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用。</p></li>
<li><p>GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到。</p></li>
<li><p>kCFRunLoopCommonModes: 这是一个占位的 Mode，没有实际作用。</p></li>
</ol>


<p>你可以在这里看到更多的苹果内部的 Mode，但那些 Mode 在开发中就很难遇到了。</p>

<p>一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。</p>

<h6>RunLoop 的底层实现(内部逻辑)</h6>

<p>RunLoop 的核心是基于 mach port 的，其进入休眠时调用的函数是 mach_msg()</p>

<p>RunLoop 的核心就是一个 mach_msg() (见上面代码的第7步)，RunLoop 调用这个函数去接收消息，如果没有别人发送 port 消息过来，内核会将线程置于等待状态。例如你在模拟器里跑起一个 iOS 的 App，然后在 App 静止时点击暂停，你会看到主线程调用栈是停留在 mach_msg_trap() 这个地方。</p>

<h6>应用</h6>

<ul>
<li><p>AutoreleasePool</p></li>
<li><p>事件响应</p></li>
<li><p>手势识别</p></li>
<li><p>界面更新</p></li>
<li><p>定时器</p></li>
<li><p>PerformSelecter</p></li>
<li><p>关于GCD</p></li>
<li><p>关于网络请求</p></li>
<li><p>AFNetworking</p></li>
<li><p>AsyncDisplayKit</p></li>
</ul>


<h3>多线程（底层与安全）</h3>

<p>线程：1个进程要想执行任务，必须得有线程.线程是进程的基本执行单元，一个进程（程序）的所有任务都在线程中执行</p>

<p>底层：Mach是第一个以多线程方式处理任务的系统，因此多线程的底层实现机制是基于Mach的线程。</p>

<pre><code> 1》C语言的POSIX接口：#include&lt;pthread.h&gt;POSIX线程（POSIX threads），简称Pthreads，是线程的POSIX标准。该标准定义了创建和操纵线程的一整套API。在类Unix操作系统（Unix、Linux、Mac OS X等）中，都使用Pthreads作为操作系统的线程
 2》OC的NSThread
 3》 C语言的GCD接口（性能最好，代码更精简）  
 4》  OC的NSOperation和NSOperationQueue（基于GCD）
</code></pre>

<p>好处：</p>

<pre><code>1、使用线程可以把程序中占据时间长的任务放到后台去处理，如图片、视频的下载

2、发挥多核处理器的优势，并发执行让系统运行的更快、更流畅，用户体验更好
</code></pre>

<p>缺点：</p>

<pre><code>1、大量的线程降低代码的可读性，

2、更多的线程需要更多的内存空间

3、当多个线程对同一个资源出现争夺的时候要注意线程安全的问题。
</code></pre>

<p>GCD内部怎么实现的</p>

<pre><code>  1》 iOS和OSX的核心是XNU内核（苹果电脑发展的操作系统内核），GCD是基于XNU内核实现的。
  2》GCD的API全部在libdispatch库中
  3》GCD的底层实现主要有：Dispatch Queue和Dispatch Source
    Dispatch Queue :管理block操作
    Dispatch Source：处理事件（比如说线程间的通信）
</code></pre>

<p>6.GCD和NSOperationQueue</p>

<pre><code>   1》GCD是纯C语言的API，NSOperationQueue是基于GCD的OC版本的封装
   2》GCD只支持FIFO的队列，NSOperationQueue可以很方便的调整执行顺序，可以添加依赖设置最大并发数量。
   3》GCD的执行速度比NSOperationQueue快
   4》NSOperationQueue支持KVO，可以检测Operation是否正在执行，是否结束，是否取消。
</code></pre>

<p>如何进行选择？
任务之间不太相互依赖，选用GCD；
任务之间有依赖，或者要监听任务的执行情况：NSOperationQueue</p>

<p>一、前言
     1》只在主线程刷新访问UI
     2》如果要防止资源抢夺，得用synchronize进行加锁保护。
     3》如果异步操作要保证线程安全等问题，尽量使用GCD。（GCD有些函数默认就是安全的）</p>

<p>前段时间看了几个开源项目，发现他们保持线程同步的方式各不相同，有@synchronized、NSLock、dispatch_semaphore、NSCondition、pthread_mutex、OSSpinLock。后来网上查了一下，发现他们的实现机制各不相同，性能也各不一样。不好意思，我们平常使用最多的@synchronized是性能最差的。下面我们先分别介绍每个加锁方式的使用，在使用一个案例来对他们进行性能对比。</p>

<p>二、介绍与使用</p>

<p>2.1、@synchronized</p>

<pre><code>NSObject *obj = [[NSObject alloc] init];
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    @synchronized(obj) {
       NSLog(@"需要线程同步的操作1 开始");
       sleep(3);
       NSLog(@"需要线程同步的操作1 结束");
    }
});
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    sleep(1);
    @synchronized(obj) {
       NSLog(@"需要线程同步的操作2");
    }
});
</code></pre>

<p>@synchronized(obj)指令使用的obj为该锁的唯一标识，只有当标识相同时，才为满足互斥，如果线程2中的@synchronized(obj)改为@synchronized(self),刚线程2就不会被阻塞，@synchronized指令实现锁的优点就是我们不需要在代码中显式的创建锁对象，便可以实现锁的机制，但作为一种预防措施，@synchronized块会隐式的添加一个异常处理例程来保护代码，该处理例程会在异常抛出的时候自动的释放互斥锁。所以如果不想让隐式的异常处理例程带来额外的开销，你可以考虑使用锁对象。</p>

<p>2.2、dispatch_semaphore</p>

<pre><code>dispatch_semaphore_t signal = dispatch_semaphore_create(1);
dispatch_time_t overTime = dispatch_time(DISPATCH_TIME_NOW, 3 * NSEC_PER_SEC);
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    dispatch_semaphore_wait(signal, overTime);
            NSLog(@"需要线程同步的操作1 开始");
            sleep(2);
            NSLog(@"需要线程同步的操作1 结束");
        dispatch_semaphore_signal(signal);
});
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        sleep(1);
        dispatch_semaphore_wait(signal, overTime);
            NSLog(@"需要线程同步的操作2");
        dispatch_semaphore_signal(signal);
});
</code></pre>

<p>dispatch_semaphore是GCD用来同步的一种方式，与他相关的共有三个函数，分别是dispatch_semaphore_create，dispatch_semaphore_signal，dispatch_semaphore_wait。</p>

<p>（1）dispatch_semaphore_create的声明为：</p>

<p>dispatch_semaphore_t dispatch_semaphore_create(long value);</p>

<p>传入的参数为long，输出一个dispatch_semaphore_t类型且值为value的信号量。</p>

<p>值得注意的是，这里的传入的参数value必须大于或等于0，否则dispatch_semaphore_create会返回NULL。</p>

<p>（2）dispatch_semaphore_signal的声明为：</p>

<p>long dispatch_semaphore_signal(dispatch_semaphore_t dsema);</p>

<p>这个函数会使传入的信号量dsema的值加1；</p>

<p>(3) dispatch_semaphore_wait的声明为：</p>

<p>long dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout);</p>

<p>这个函数会使传入的信号量dsema的值减1；这个函数的作用是这样的，如果dsema信号量的值大于0，该函数所处线程就继续执行下面的语句，并且将信号量的值减1；如果desema的值为0，那么这个函数就阻塞当前线程等待timeout（注意timeout的类型为dispatch_time_t，不能直接传入整形或float型数），如果等待的期间desema的值被dispatch_semaphore_signal函数加1了，且该函数（即dispatch_semaphore_wait）所处线程获得了信号量，那么就继续向下执行并将信号量减1。如果等待期间没有获取到信号量或者信号量的值一直为0，那么等到timeout时，其所处线程自动执行其后语句。</p>

<p>dispatch_semaphore 是信号量，但当信号总量设为 1 时也可以当作锁来。在没有等待情况出现时，它的性能比 pthread_mutex 还要高，但一旦有等待情况出现时，性能就会下降许多。相对于 OSSpinLock 来说，它的优势在于等待时不会消耗 CPU 资源。</p>

<p>如上的代码，如果超时时间overTime设置成>2，可完成同步操作。如果overTime&lt;2的话，在线程1还没有执行完成的情况下，此时超时了，将自动执行下面的代码。</p>

<p>2.3、NSLock</p>

<pre><code>NSLock *lock = [[NSLock alloc] init];
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    //[lock lock];
    [lock lockBeforeDate:[NSDate date]];
    NSLog(@"需要线程同步的操作1 开始");
    sleep(2);
    NSLog(@"需要线程同步的操作1 结束");
    [lock unlock];
});
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    sleep(1);
    if ([lock tryLock]) {//尝试获取锁，如果获取不到返回NO，不会阻塞该线程
        NSLog(@"锁可用的操作");
        [lock unlock];
    }else{
        NSLog(@"锁不可用的操作");
    }
    NSDate *date = [[NSDate alloc] initWithTimeIntervalSinceNow:3];
    if ([lock lockBeforeDate:date]) {//尝试在未来的3s内获取锁，并阻塞该线程，如果3s内获取不到恢复线程, 返回NO,不会阻塞该线程
        NSLog(@"没有超时，获得锁");
        [lock unlock];
    }else{
        NSLog(@"超时，没有获得锁");
    }
});
</code></pre>

<p>NSLock是Cocoa提供给我们最基本的锁对象，这也是我们经常所使用的，除lock和unlock方法外，NSLock还提供了tryLock和lockBeforeDate:两个方法，前一个方法会尝试加锁，如果锁不可用(已经被锁住)，刚并不会阻塞线程，并返回NO。lockBeforeDate:方法会在所指定Date之前尝试加锁，如果在指定时间之前都不能加锁，则返回NO。</p>

<pre><code>@protocol NSLocking
- (void)lock;
- (void)unlock;
@end
@interface NSLock : NSObject  {
@private
    void *_priv;
}
- (BOOL)tryLock;
- (BOOL)lockBeforeDate:(NSDate *)limit;
@property (nullable, copy) NSString *name NS_AVAILABLE(10_5, 2_0);
@end
</code></pre>

<p>2.4、NSRecursiveLock递归锁</p>

<pre><code>//NSLock *lock = [[NSLock alloc] init];
NSRecursiveLock *lock = [[NSRecursiveLock alloc] init];
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
       static void (^RecursiveMethod)(int);
       RecursiveMethod = ^(int value) {
       [lock lock];
         if (value &gt; 0) {
                NSLog(@"value = %d", value);
                sleep(1);
                RecursiveMethod(value - 1);
          }
         [lock unlock];
     };
     RecursiveMethod(5);
});
</code></pre>

<p>NSRecursiveLock实际上定义的是一个递归锁，这个锁可以被同一线程多次请求，而不会引起死锁。这主要是用在循环或递归操作中。</p>

<p>这段代码是一个典型的死锁情况。在我们的线程中，RecursiveMethod是递归调用的。所以每次进入这个block时，都会去加一次锁，而从第二次开始，由于锁已经被使用了且没有解锁，所以它需要等待锁被解除，这样就导致了死锁，线程被阻塞住了。调试器中会输出如下信息：</p>

<p>在这种情况下，我们就可以使用NSRecursiveLock。它可以允许同一线程多次加锁，而不会造成死锁。递归锁会跟踪它被lock的次数。每次成功的lock都必须平衡调用unlock操作。只有所有达到这种平衡，锁最后才能被释放，以供其它线程使用。</p>

<p>如果我们将NSLock代替为NSRecursiveLock，上面代码则会正确执行。</p>

<p>如果需要其他功能，源码定义如下：</p>

<pre><code>@interface NSRecursiveLock : NSObject  {
@private
    void *_priv;
}
- (BOOL)tryLock;
- (BOOL)lockBeforeDate:(NSDate *)limit;
@property (nullable, copy) NSString *name NS_AVAILABLE(10_5, 2_0);
@end
</code></pre>

<p>2.5、NSConditionLock条件锁</p>

<pre><code>NSMutableArray *products = [NSMutableArray array];
NSInteger HAS_DATA = 1;
NSInteger NO_DATA = 0;
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    while (1) {
        [lock lockWhenCondition:NO_DATA];
        [products addObject:[[NSObject alloc] init]];
        NSLog(@"produce a product,总量:%zi",products.count);
        [lock unlockWithCondition:HAS_DATA];
        sleep(1);
    }
});
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    while (1) {
       NSLog(@"wait for product");
        [lock lockWhenCondition:HAS_DATA];
       [products removeObjectAtIndex:0];
       NSLog(@"custome a product");
       [lock unlockWithCondition:NO_DATA];
    }
});
</code></pre>

<p>当我们在使用多线程的时候，有时一把只会lock和unlock的锁未必就能完全满足我们的使用。因为普通的锁只能关心锁与不锁，而不在乎用什么钥匙才能开锁，而我们在处理资源共享的时候，多数情况是只有满足一定条件的情况下才能打开这把锁：</p>

<p>在线程1中的加锁使用了lock，所以是不需要条件的，所以顺利的就锁住了，但在unlock的使用了一个整型的条件，它可以开启其它线程中正在等待这把钥匙的临界地，而线程2则需要一把被标识为2的钥匙，所以当线程1循环到最后一次的时候，才最终打开了线程2中的阻塞。但即便如此，NSConditionLock也跟其它的锁一样，是需要lock与unlock对应的，只是lock,lockWhenCondition:与unlock，unlockWithCondition:是可以随意组合的，当然这是与你的需求相关的。</p>

<p>如果你需要其他功能，源码定义如下：</p>

<pre><code>@interface NSConditionLock : NSObject  {
@private
    void *_priv;
}
- (instancetype)initWithCondition:(NSInteger)condition NS_DESIGNATED_INITIALIZER;
@property (readonly) NSInteger condition;
- (void)lockWhenCondition:(NSInteger)condition;
- (BOOL)tryLock;
- (BOOL)tryLockWhenCondition:(NSInteger)condition;
- (void)unlockWithCondition:(NSInteger)condition;
- (BOOL)lockBeforeDate:(NSDate *)limit;
- (BOOL)lockWhenCondition:(NSInteger)condition beforeDate:(NSDate *)limit;
@property (nullable, copy) NSString *name NS_AVAILABLE(10_5, 2_0);
@end
</code></pre>

<p>2.6、NSCondition</p>

<pre><code>NSCondition *condition = [[NSCondition alloc] init];
NSMutableArray *products = [NSMutableArray array];
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        while (1) {
            [condition lock];
            if ([products count] == 0) {
                NSLog(@"wait for product");
                [condition wait];
            }
            [products removeObjectAtIndex:0];
            NSLog(@"custome a product");
            [condition unlock];
        }
    });
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        while (1) {
            [condition lock];
            [products addObject:[[NSObject alloc] init]];
            NSLog(@"produce a product,总量:%zi",products.count);
            [condition signal];
            [condition unlock];
            sleep(1);
        }
});
</code></pre>

<p>一种最基本的条件锁。手动控制线程wait和signal。</p>

<p>[condition lock];一般用于多线程同时访问、修改同一个数据源，保证在同一时间内数据源只被访问、修改一次，其他线程的命令需要在lock 外等待，只到unlock ，才可访问</p>

<p>[condition unlock];与lock 同时使用</p>

<p>[condition wait];让当前线程处于等待状态</p>

<p>[condition signal];CPU发信号告诉线程不用在等待，可以继续执行</p>

<p>2.7、pthread_mutex</p>

<pre><code>__block pthread_mutex_t theLock;
pthread_mutex_init(&amp;theLock, NULL);
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        pthread_mutex_lock(&amp;theLock);
        NSLog(@"需要线程同步的操作1 开始");
        sleep(3);
        NSLog(@"需要线程同步的操作1 结束");
        pthread_mutex_unlock(&amp;theLock);
});
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        sleep(1);
        pthread_mutex_lock(&amp;theLock);
        NSLog(@"需要线程同步的操作2");
        pthread_mutex_unlock(&amp;theLock);
});
</code></pre>

<p>c语言定义下多线程加锁方式。</p>

<p>1：pthread_mutex_init(pthread_mutex_t mutex,const pthread_mutexattr_t attr);</p>

<p>初始化锁变量mutex。attr为锁属性，NULL值为默认属性。</p>

<p>2：pthread_mutex_lock(pthread_mutex_t mutex);加锁</p>

<p>3：pthread_mutex_tylock(<em>pthread_mutex_t </em>mutex);加锁，但是与2不一样的是当锁已经在使用的时候，返回为EBUSY，而不是挂起等待。</p>

<p>4：pthread_mutex_unlock(pthread_mutex_t *mutex);释放锁</p>

<p>5：pthread_mutex_destroy(pthread_mutex_t* mutex);使用完后释放</p>

<p>代码执行操作结果如下：</p>

<p>2.8、pthread_mutex(recursive)</p>

<pre><code> __block pthread_mutex_t theLock;
//pthread_mutex_init(&amp;theLock, NULL);
pthread_mutexattr_t attr;
pthread_mutexattr_init(&amp;attr);
pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE);
pthread_mutex_init(&amp;lock, &amp;attr);
pthread_mutexattr_destroy(&amp;attr);
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    static void (^RecursiveMethod)(int);
    RecursiveMethod = ^(int value) {
            pthread_mutex_lock(&amp;theLock);
            if (value &gt; 0) {
                NSLog(@"value = %d", value);
                sleep(1);
                RecursiveMethod(value - 1);
            }
            pthread_mutex_unlock(&amp;theLock);
     };
    RecursiveMethod(5);
});
</code></pre>

<p>这是pthread_mutex为了防止在递归的情况下出现死锁而出现的递归锁。作用和NSRecursiveLock递归锁类似。</p>

<p>如果使用pthread_mutex_init(&amp;theLock, NULL);初始化锁的话，上面的代码会出现死锁现象。如果使用递归锁的形式，则没有问题。</p>

<p>2.9、OSSpinLock</p>

<pre><code>__block OSSpinLock theLock = OS_SPINLOCK_INIT;
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    OSSpinLockLock(&amp;theLock);
    NSLog(@"需要线程同步的操作1 开始");
    sleep(3);
    NSLog(@"需要线程同步的操作1 结束");
    OSSpinLockUnlock(&amp;theLock);
});
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    OSSpinLockLock(&amp;theLock);
    sleep(1);
    NSLog(@"需要线程同步的操作2");
    OSSpinLockUnlock(&amp;theLock);
});
</code></pre>

<p>OSSpinLock 自旋锁，性能最高的锁。原理很简单，就是一直 do while 忙等。它的缺点是当等待时会消耗大量 CPU 资源，所以它不适用于较长时间的任务。 不过最近YY大神在自己的博客不再安全的 OSSpinLock中说明了OSSpinLock已经不再安全，请大家谨慎使用。</p>

<p>三、性能对比</p>

<pre><code>OSSpinLock和dispatch_semaphore的效率远远高于其他。

@synchronized和NSConditionLock效率较差。

鉴于OSSpinLock的不安全，所以我们在开发中如果考虑性能的话，建议使用dispatch_semaphore。

如果不考虑性能，只是图个方便的话，那就使用@synchronized。
</code></pre>

<h3>网络（底层与安全）</h3>

<h3>数据持久化（各种使用与区别）（CoreData、SQLite）</h3>

<h3>Block（底层/__Block）</h3>

<h3>音视频</h3>

<h3>直播</h3>

<h3>安全</h3>

<h3>优化（性能、卡顿）</h3>

<h3>常见错误</h3>

<h3>常用技术</h3>

<p>KVC</p>

<pre><code>KVC运用了一个isa-swizzling技术。isa-swizzling就是类型混合指针机制。KVC主要通过isa-swizzling，来实现其内部查找定位的。isa指针，如其名称所指，（就是is a kind of的意思），指向维护分发表的对象的类。该分发表实际上包含了指向实现类中的方法的指针，和其它数据
一个对象在调用setValue的时候，（1）首先根据方法名找到运行方法的时候所需要的环境参数。（2）他会从自己isa指针结合环境参数，找到具体的方法实现的接口。（3）再直接查找得来的具体的方法实现。
</code></pre>

<p>KVO</p>

<pre><code>观察者为一个对象的属性进行了注册，被观察对象的isa指针被修改的时候，isa指针就会指向一个中间类（setter/getter方法），而不是真实的类。所以isa指针其实不需要指向实例对象真实的类。所以我们的程序最好不要依赖于isa指针。在调用类的方法的时候，最好要明确对象实例的类名。
熟悉KVO的朋友都知道，只有当我们调用KVC去访问key值的时候KVO才会起作用。所以肯定确定的是，KVO是基于KVC实现的。其实看了上面我们的分析以后，关系KVO的架构的构思也就水到渠成了。
</code></pre>

<p>任何工程产品（注意是任何工程产品）都可以使用以下两种方法之一进行测试。
黑盒测试：已知产品的功能设计规格，可以进行测试证明每个实现了的功能是否符合要求。
白盒测试：已知产品的内部工作过程，可以通过测试证明每种内部操作是否符合设计规格要求，所有内部成分是否以经过检查。</p>

<h5>黑盒测试</h5>

<p>软件的黑盒测试意味着测试要在软件的接口处进行。这种方法是把测试对象看做一个黑盒子，测试人员完全不考虑程序内部的逻辑结构和内部特性，只依据程序的需求规格说明书，检查程序的功能是否符合它的功能说明。因此黑盒测试又叫功能测试或数据驱动测试。</p>

<pre><code>黑盒测试主要是为了发现以下几类错误：
1、是否有不正确或遗漏的功能？
2、在接口上，输入是否能正确的接受？能否输出正确的结果？
3、是否有数据结构错误或外部信息（例如数据文件）访问错误？
4、性能上是否能够满足要求？
5、是否有初始化或终止性错误？
</code></pre>

<h5>白盒测试</h5>

<p>软件的白盒测试是对软件的过程性细节做细致的检查。这种方法是把测试对象看做一个打开的盒子，它允许测试人员利用程序内部的逻辑结构及有关信息，设计或选择测试用例，对程序所有逻辑路径进行测试。通过在不同点检查程序状态，确定实际状态是否与预期的状态一致。因此白盒测试又称为结构测试或逻辑驱动测试。</p>

<pre><code>白盒测试主要是想对程序模块进行如下检查：
1、对程序模块的所有独立的执行路径至少测试一遍。
2、对所有的逻辑判定，取“真”与取“假”的两种情况都能至少测一遍。
3、在循环的边界和运行的界限内执行循环体。
4、测试内部数据结构的有效性，等等。
</code></pre>

<p>以上事实说明，软件测试有一个致命的缺陷，即测试的不完全、不彻底性。由于任何程序只能进行少量（相对于穷举的巨大数量而言）的有限的测试，在未发现错误时，不能说明程序中没有错误。</p>

<h5>灰盒测试</h5>

<p>灰盒测试，是介于白盒测试与黑盒测试之间的，可以这样理解，灰盒测试关注输出对于输入的正确性，同时也关注内部表现，但这种关注不象白盒那样详细、完整，只是通过一些表征性的现象、事件、标志来判断内部的运行状态，有时候输出是正确的，但内部其实已经错误了，这种情况非常多，如果每次都通过白盒测试来操作，效率会很低，因此需要采取这样的一种灰盒的方法。</p>

<h3>全栈相关</h3>

<h3>算法（常用、排序）</h3>

<h3>数据结构</h3>

<h3>设计模式（32中）</h3>

<h3>架构设计</h3>

<h3>逆向工程</h3>

<h3>实战应用</h3>

<pre><code>Q Q：2211523682/790806573

微信：18370997821/13148454507

微博WB:http://weibo.com/u/3288975567?is_hot=1

git博文：http://al1020119.github.io/

github：https://github.com/al1020119
</code></pre>

<p><img src="/images/iCocosCoder.jpg" title="Caption" ></p>

<p><img src="/images/iCocosPublic.jpg" title="Caption" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[多线程之葵花宝典]]></title>
    <link href="http://al1020119.github.io/blog/2016/07/10/duoxianc/"/>
    <updated>2016-07-10T14:59:42+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/07/10/duoxianc</id>
    <content type="html"><![CDATA[<h2>一、进程和线程</h2>

<h4>1.什么是进程</h4>

<pre><code>进程是指在系统中正在运行的一个应用程序

每个进程之间是独立的，每个进程均运行在其专用且受保护的内存空间内





比如同时打开QQ、Xcode，系统就会分别启动2个进程

通过“活动监视器”可以查看Mac系统中所开启的进程
</code></pre>

<!--more-->


<h4>2.什么是线程</h4>

<pre><code>1个进程要想执行任务，必须得有线程（每1个进程至少要有1条线程）

线程是进程的基本执行单元，一个进程（程序）的所有任务都在线程中执行

比如使用酷狗播放音乐、使用迅雷下载电影，都需要在线程中执行
</code></pre>

<p> 　　</p>

<h4>3.线程的串行</h4>

<pre><code>1个线程中任务的执行是串行的

如果要在1个线程中执行多个任务，那么只能一个一个地按顺序执行这些任务

也就是说，在同一时间内，1个线程只能执行1个任务

比如在1个线程中下载3个文件（分别是文件A、文件B、文件C）
</code></pre>

<h2>二、多线程</h2>

<h4>1.什么是多线程</h4>

<pre><code>1个进程中可以开启多条线程，每条线程可以并行（同时）执行不同的任务

进程 -&gt;车间，线程-&gt;车间工人

多线程技术可以提高程序的执行效率

比如同时开启3条线程分别下载3个文件（分别是文件A、文件B、文件C）
</code></pre>

<h4>2.多线程的原理</h4>

<pre><code>同一时间，CPU只能处理1条线程，只有1条线程在工作（执行）
多线程并发（同时）执行，其实是CPU快速地在多条线程之间调度（切换）
如果CPU调度线程的时间足够快，就造成了多线程并发执行的假象
思考：如果线程非常非常多，会发生什么情况？
CPU会在N多线程之间调度，CPU会累死，消耗大量的CPU资源
每条线程被调度执行的频次会降低（线程的执行效率降低）
</code></pre>

<h4>3.多线程的优缺点</h4>

<p>多线程的优点</p>

<pre><code>能适当提高程序的执行效率

能适当提高资源利用率（CPU、内存利用率）
</code></pre>

<p>多线程的缺点</p>

<pre><code>开启线程需要占用一定的内存空间（默认情况下，主线程占用1M，子线程占用512KB），如果开启大量的线程，会占用大量的内存空间，降低程序的性能

线程越多，CPU在调度线程上的开销就越大

程序设计更加复杂：比如线程之间的通信、多线程的数据共享
</code></pre>

<h4>4.多线程在iOS开发中的应用</h4>

<pre><code>主线程:一个iOS程序运行后，默认会开启1条线程，称为“主线程”或“UI线程”

主线程的主要作用

显示\刷新UI界面

处理UI事件（比如点击事件、滚动事件、拖拽事件等）
</code></pre>

<p>主线程的使用注意:别将比较耗时的操作放到主线程中。</p>

<p>耗时操作会卡住主线程，严重影响UI的流畅度，给用户一种“卡”的坏体验</p>

<h2>多线程的四中方式</h2>

<h4>1. Pthreads</h4>

<h4>2. NSThread</h4>

<h4>3. GCD</h4>

<h4>4. NSOperation &amp; NSOperationQueue</h4>

<h2>多线程的全解析-看了不信你还不会？</h2>

<p><img src="/images/multithread.png" title="Caption" ></p>

<pre><code>Q Q：2211523682/790806573

微信：18370997821/13148454507

微博WB:http://weibo.com/u/3288975567?is_hot=1

git博文：http://al1020119.github.io/

github：https://github.com/al1020119
</code></pre>

<p><img src="/images/iCocosCoder.jpg" title="Caption" ></p>

<p><img src="/images/iCocosPublic.jpg" title="Caption" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CoreData 😘 SQLite 😍 FMDB]]></title>
    <link href="http://al1020119.github.io/blog/2016/07/05/zsqlfmdbcoredata/"/>
    <updated>2016-07-05T14:59:42+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/07/05/zsqlfmdbcoredata</id>
    <content type="html"><![CDATA[<p>概览</p>

<p>在iOS开发中数据存储的方式可以归纳为两类：一类是存储为文件，另一类是存储到数据库。例如前面IOS开发系列—Objective-C之Foundation框架的文章中提到归档、plist文件存储，包括偏好设置其本质都是存储为文件，只是说归档或者plist文件存储可以选择保存到沙盒中，而偏好设置系统已经规定只能保存到沙盒的Library/Preferences目录。当然，文件存储并不作为本文的重点内容。本文重点还是说数据库存储，做过数据库开发的朋友应该知道，可以通过SQL直接访问数据库，也可以通过ORM进行对象关系映射访问数据库。这两种方式恰恰对应iOS中SQLite和Core Data的内容，在此将重点进行分析:</p>

<h3>1. SQLite</h3>

<h3>2. Core Data</h3>

<h3>3. FMDB</h3>

<!--more-->


<hr />

<h2>SQLite</h2>

<p>SQLite是目前主流的嵌入式关系型数据库，其最主要的特点就是轻量级、跨平台，当前很多嵌入式操作系统都将其作为数据库首选。虽然SQLite是一款轻型数据库，但是其功能也绝不亚于很多大型关系数据库。学习数据库就要学习其相关的定义、操作、查询语言，也就是大家日常说得SQL语句。和其他数据库相比，SQLite中的SQL语法并没有太大的差别，因此这里对于SQL语句的内容不会过多赘述，大家可以参考SQLite中其他SQL相关的内容，这里还是重点讲解iOS中如何使用SQLite构建应用程序。先看一下SQLite数据库的几个特点：</p>

<ol>
<li><p>基于C语言开发的轻型数据库</p></li>
<li><p>在iOS中需要使用C语言语法进行数据库操作、访问（无法使用ObjC直接访问，因为libqlite3框架基于C语言编写）</p></li>
<li><p>SQLite中采用的是动态数据类型，即使创建时定义了一种类型，在实际操作时也可以存储其他类型，但是推荐建库时使用合适的类型（特别是应用需要考虑跨平台的情况时）</p></li>
<li><p>建立连接后通常不需要关闭连接（尽管可以手动关闭）</p></li>
</ol>


<p>要使用SQLite很简单，如果在Mac OSX上使用可以考虑到SQLite官方网站下载命令行工具，也可以使用类似于SQLiteManager、Navicat for SQLite等工具。为了方便大家开发调试，建议在开发环境中安装上述工具。</p>

<p>在iOS中操作SQLite数据库可以分为以下几步（注意先在项目中导入libsqlite3框架）：</p>

<ol>
<li><p>打开数据库，利用sqlite3_open()打开数据库会指定一个数据库文件保存路径，如果文件存在则直接打开，否则创建并打开。打开数据库会得到一个sqlite3类型的对象，后面需要借助这个对象进行其他操作。</p></li>
<li><p>执行SQL语句，执行SQL语句又包括有返回值的语句和无返回值语句。</p></li>
<li><p>对于无返回值的语句（如增加、删除、修改等）直接通过sqlite3_exec()函数执行；</p></li>
<li><p>对于有返回值的语句则首先通过sqlite3_prepare_v2()进行sql语句评估（语法检测），然后通过sqlite3_step()依次取出查询结果的每一行数据，对于每行数据都可以通过对应的sqlite3_column_类型()方法获得对应列的数据，如此反复循环直到遍历完成。当然，最后需要释放句柄。</p></li>
</ol>


<p>在整个操作过程中无需管理数据库连接，对于嵌入式SQLite操作是持久连接（尽管可以通过sqlite3_close()关闭），不需要开发人员自己释放连接。纵观整个操作过程，其实与其他平台的开发没有明显的区别，较为麻烦的就是数据读取，在iOS平台中使用C进行数据读取采用了游标的形式，每次只能读取一行数据，较为麻烦。因此实际开发中不妨对这些操作进行封装：</p>

<p>KCDbManager.h
    //
    //  DbManager.h
    //  DataAccess
    //
    //  Created by Kenshin Cui on 14-3-29.
    //  Copyright &copy; 2014年 Kenshin Cui. All rights reserved.
    //
    #import &lt;Foundation/Foundation.h>
    #import &lt;sqlite3.h>
    #import &ldquo;KCSingleton.h&rdquo;
    @interface KCDbManager : NSObject
    singleton_interface(KCDbManager);
    #pragma mark - 属性
    #pragma mark 数据库引用，使用它进行数据库操作
    @property (nonatomic) sqlite3 <em>database;
    #pragma mark - 共有方法
    /**
     *  打开数据库
     *
     *  @param dbname 数据库名称
     </em>/
    -(void)openDb:(NSString <em>)dbname;
    /**
     *  执行无返回值的sql
     *
     *  @param sql sql语句
     </em>/
    -(void)executeNonQuery:(NSString <em>)sql;
    /**
     *  执行有返回值的sql
     *
     *  @param sql sql语句
     *
     *  @return 查询结果
     </em>/
    -(NSArray <em>)executeQuery:(NSString </em>)sql;
    @end</p>

<pre><code>KCDbManager.m
//
//  DbManager.m
//  DataAccess
//
//  Created by Kenshin Cui on 14-3-29.
//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.
//
#import "KCDbManager.h"
#import &lt;sqlite3.h&gt;
#import "KCSingleton.h"
#import "KCAppConfig.h"
#ifndef kDatabaseName
#define kDatabaseName @"myDatabase.db"
#endif
@interface KCDbManager()
@end
@implementation KCDbManager
singleton_implementation(KCDbManager)
#pragma mark 重写初始化方法
-(instancetype)init{
    KCDbManager *manager;
    if((manager=[super init]))
    {
        [manager openDb:kDatabaseName];
    }
    return manager;
}
-(void)openDb:(NSString *)dbname{
    //取得数据库保存路径，通常保存沙盒Documents目录
    NSString *directory=[NSSearchPathForDirectoriesInDomains(NSDocumentationDirectory, NSUserDomainMask, YES) firstObject];
    NSLog(@"%@",directory);
    NSString *filePath=[directory stringByAppendingPathComponent:dbname];
    //如果有数据库则直接打开，否则创建并打开（注意filePath是ObjC中的字符串，需要转化为C语言字符串类型）
    if (SQLITE_OK ==sqlite3_open(filePath.UTF8String, &amp;_database)) {
        NSLog(@"数据库打开成功!");
    }else{
        NSLog(@"数据库打开失败!");
    }
}
-(void)executeNonQuery:(NSString *)sql{
    char *error;
    //单步执行sql语句，用于插入、修改、删除
    if (SQLITE_OK!=sqlite3_exec(_database, sql.UTF8String, NULL, NULL,&amp;error)) {
        NSLog(@"执行SQL语句过程中发生错误！错误信息：%s",error);
    }
}
-(NSArray *)executeQuery:(NSString *)sql{
    NSMutableArray *rows=[NSMutableArray array];//数据行

    //评估语法正确性
    sqlite3_stmt *stmt;
    //检查语法正确性
    if (SQLITE_OK==sqlite3_prepare_v2(_database, sql.UTF8String, -1, &amp;stmt, NULL)) {
        //单步执行sql语句
        while (SQLITE_ROW==sqlite3_step(stmt)) {
            int columnCount= sqlite3_column_count(stmt);
            NSMutableDictionary *dic=[NSMutableDictionary dictionary];
            for (int i=0; i&lt;columnCount; i++) {
                const char *name= sqlite3_column_name(stmt, i);//取得列名
                const unsigned char *value= sqlite3_column_text(stmt, i);//取得某列的值
                dic[[NSString stringWithUTF8String:name]]=[NSString stringWithUTF8String:(const char *)value];
            }
            [rows addObject:dic];
        }
    }

    //释放句柄
    sqlite3_finalize(stmt);

    return rows;
}
@end
</code></pre>

<p>在上面的类中对于数据库操作进行了封装，封装之后数据操作更加方便，同时所有的语法都由C转换成了ObjC。</p>

<p>下面仍然以微博查看为例进行SQLite演示。当然实际开发中微博数据是从网络读取的，但是考虑到缓存问题，通常会选择将微博数据保存到本地，下面的Demo演示了将数据存放到本地数据库以及数据读取的过程。当然，实际开发中并不会在视图控制器中直接调用数据库操作方法，在这里通常会引入两个概念Model和Service。Model自不必多说，就是MVC中的模型。而Service指的是操作数据库的服务层，它封装了对于Model的基本操作方法，实现具体的业务逻辑。为了解耦，在控制器中是不会直接接触数据库的，控制器中只和模型（模型是领域的抽象）、服务对象有关系，借助服务层对模型进行各类操作，模型的操作反应到数据库中就是对表中数据的操作。具体关系如下：</p>

<p><img src="/images/CSR001.jpg" title="Caption" ></p>

<p>要完成上述功能，首先定义一个应用程序全局对象进行数据库、表的创建。为了避免每次都创建数据库和表出错，这里利用了偏好设置进行保存当前创建状态（其实这也是数据存储的一部分），如果创建过了数据库则不再创建，否则创建数据库和表。</p>

<p>KCDatabaseCreator.m</p>

<pre><code>//
//  KCDatabaseCreator.m
//  DataAccess
//
//  Created by Kenshin Cui on 14-3-29.
//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.
//
#import "KCDatabaseCreator.h"
#import "KCDbManager.h"
@implementation KCDatabaseCreator
+(void)initDatabase{
    NSString *key=@"IsCreatedDb";
    NSUserDefaults *defaults=[[NSUserDefaults alloc]init];
    if ([[defaults valueForKey:key] intValue]!=1) {
        [self createUserTable];
        [self createStatusTable];
        [defaults setValue:@1 forKey:key];
    }
}
+(void)createUserTable{
    NSString *sql=@"CREATE TABLE User (Id integer PRIMARY KEY AUTOINCREMENT,name text,screenName text, profileImageUrl text,mbtype text,city text)";
    [[KCDbManager sharedKCDbManager] executeNonQuery:sql];
}
+(void)createStatusTable{
    NSString *sql=@"CREATE TABLE Status (Id integer PRIMARY KEY AUTOINCREMENT,source text,createdAt date,\"text\" text,user integer REFERENCES User (Id))";
    [[KCDbManager sharedKCDbManager] executeNonQuery:sql];
}
@end
</code></pre>

<p>其次，定义数据模型，这里定义用户User和微博Status两个数据模型类。注意模型应该尽量保持其单纯性，仅仅是简单的POCO，不要引入视图、控制器等相关内容。</p>

<p>KCUser.h</p>

<pre><code>//
//  KCUser.h
//  UrlConnection
//
//  Created by Kenshin Cui on 14-3-22.
//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.
//
#import &lt;Foundation/Foundation.h&gt;
@interface KCUser : NSObject
#pragma mark 编号
@property (nonatomic,strong) NSNumber *Id;
#pragma mark 用户名
@property (nonatomic,copy) NSString *name;
#pragma mark 用户昵称
@property (nonatomic,copy) NSString *screenName;
#pragma mark 头像
@property (nonatomic,copy) NSString *profileImageUrl;
#pragma mark 会员类型
@property (nonatomic,copy) NSString *mbtype;
#pragma mark 城市
@property (nonatomic,copy) NSString *city;
#pragma mark - 动态方法
/**
 *  初始化用户
 *
 *  @param name 用户名
 *  @param city 所在城市
 *
 *  @return 用户对象
 */
-(KCUser *)initWithName:(NSString *)name screenName:(NSString *)screenName profileImageUrl:(NSString *)profileImageUrl mbtype:(NSString *)mbtype city:(NSString *)city;
/**
 *  使用字典初始化用户对象
 *
 *  @param dic 用户数据
 *
 *  @return 用户对象
 */
-(KCUser *)initWithDictionary:(NSDictionary *)dic;
#pragma mark - 静态方法
+(KCUser *)userWithName:(NSString *)name screenName:(NSString *)screenName profileImageUrl:(NSString *)profileImageUrl mbtype:(NSString *)mbtype city:(NSString *)city;
@end
</code></pre>

<p>KCUser.m</p>

<pre><code>//
//  KCUser.m
//  UrlConnection
//
//  Created by Kenshin Cui on 14-3-22.
//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.
//
#import "KCUser.h"
@implementation KCUser
-(KCUser *)initWithName:(NSString *)name screenName:(NSString *)screenName profileImageUrl:(NSString *)profileImageUrl mbtype:(NSString *)mbtype city:(NSString *)city{
    if (self=[super init]) {
        self.name=name;
        self.screenName=screenName;
        self.profileImageUrl=profileImageUrl;
        self.mbtype=mbtype;
        self.city=city;
    }
    return self;
}
-(KCUser *)initWithDictionary:(NSDictionary *)dic{
    if (self=[super init]) {
        [self setValuesForKeysWithDictionary:dic];
    }
    return self;
}
+(KCUser *)userWithName:(NSString *)name screenName:(NSString *)screenName profileImageUrl:(NSString *)profileImageUrl mbtype:(NSString *)mbtype city:(NSString *)city{
    KCUser *user=[[KCUser alloc]initWithName:name screenName:screenName profileImageUrl:profileImageUrl mbtype:mbtype city:city];
    return user;
}
</code></pre>

<p>@end</p>

<p>KCStatus.h</p>

<pre><code>//
//  KCStatus.h
//  UITableView
//
//  Created by Kenshin Cui on 14-3-1.
//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.
//
#import &lt;Foundation/Foundation.h&gt;
#import "KCUser.h"
@interface KCStatus : NSObject
#pragma mark - 属性
@property (nonatomic,strong) NSNumber *Id;//微博id
@property (nonatomic,strong) KCUser *user;//发送用户
@property (nonatomic,copy) NSString *createdAt;//创建时间
@property (nonatomic,copy) NSString *source;//设备来源
@property (nonatomic,copy) NSString *text;//微博内容
#pragma mark - 动态方法
/**
 *  初始化微博数据
 *
 *  @param createAt        创建日期
 *  @param source          来源
 *  @param text            微博内容
 *  @param user            发送用户
 *
 *  @return 微博对象
 */
-(KCStatus *)initWithCreateAt:(NSString *)createAt source:(NSString *)source text:(NSString *)text user:(KCUser *)user;
/**
 *  初始化微博数据
 *
 *  @param profileImageUrl 用户头像
 *  @param mbtype          会员类型
 *  @param createAt        创建日期
 *  @param source          来源
 *  @param text            微博内容
 *  @param userId          用户编号
 *
 *  @return 微博对象
 */
-(KCStatus *)initWithCreateAt:(NSString *)createAt source:(NSString *)source text:(NSString *)text userId:(int)userId;
/**
 *  使用字典初始化微博对象
 *
 *  @param dic 字典数据
 *
 *  @return 微博对象
 */
-(KCStatus *)initWithDictionary:(NSDictionary *)dic;
#pragma mark - 静态方法
/**
 *  初始化微博数据
 *
 *  @param createAt        创建日期
 *  @param source          来源
 *  @param text            微博内容
 *  @param user            发送用户
 *
 *  @return 微博对象
 */
+(KCStatus *)statusWithCreateAt:(NSString *)createAt source:(NSString *)source text:(NSString *)text user:(KCUser *)user;
/**
 *  初始化微博数据
 *
 *  @param profileImageUrl 用户头像
 *  @param mbtype          会员类型
 *  @param createAt        创建日期
 *  @param source          来源
 *  @param text            微博内容
 *  @param userId          用户编号
 *
 *  @return 微博对象
 */
+(KCStatus *)statusWithCreateAt:(NSString *)createAt source:(NSString *)source text:(NSString *)text userId:(int)userId;
@end
</code></pre>

<p>KCStatus.m</p>

<pre><code>//
//  KCStatus.m
//  UITableView
//
//  Created by Kenshin Cui on 14-3-1.
//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.
//
#import "KCStatus.h"
@implementation KCStatus
-(KCStatus *)initWithDictionary:(NSDictionary *)dic{
    if (self=[super init]) {
        [self setValuesForKeysWithDictionary:dic];
        self.user=[[KCUser alloc]init];
        self.user.Id=dic[@"user"];
    }
    return self;
}
-(KCStatus *)initWithCreateAt:(NSString *)createAt source:(NSString *)source text:(NSString *)text user:(KCUser *)user{
    if (self=[super init]) {
        self.createdAt=createAt;
        self.source=source;
        self.text=text;
        self.user=user;
    }
    return self;
}
-(KCStatus *)initWithCreateAt:(NSString *)createAt source:(NSString *)source text:(NSString *)text userId:(int)userId{
    if (self=[super init]) {
        self.createdAt=createAt;
        self.source=source;
        self.text=text;
        KCUser *user=[[KCUser alloc]init];
        user.Id=[NSNumber numberWithInt:userId];
        self.user=user;
    }
    return self;
}
-(NSString *)source{
    return [NSString stringWithFormat:@"来自 %@",_source];
}
+(KCStatus *)statusWithCreateAt:(NSString *)createAt source:(NSString *)source text:(NSString *)text user:(KCUser *)user{
    KCStatus *status=[[KCStatus alloc]initWithCreateAt:createAt source:source text:text user:user];
    return status;
}
+(KCStatus *)statusWithCreateAt:(NSString *)createAt source:(NSString *)source text:(NSString *)text userId:(int)userId{
    KCStatus *status=[[KCStatus alloc]initWithCreateAt:createAt source:source text:text userId:userId];
    return status;
}
@end
</code></pre>

<p>然后，编写服务类，进行数据的增、删、改、查操作，由于服务类方法同样不需要过多的配置，因此定义为单例，保证程序中只有一个实例即可。服务类中调用前面封装的数据库方法将对数据库的操作转换为对模型的操作。</p>

<p>KCUserService.h</p>

<pre><code>//
//  KCUserService.h
//  DataAccess
//
//  Created by Kenshin Cui on 14-3-29.
//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.
//
#import &lt;Foundation/Foundation.h&gt;
#import "KCUser.h"
#import "KCSingleton.h"
@interface KCUserService : NSObject
singleton_interface(KCUserService)
/**
 *  添加用户信息
 *
 *  @param user 用户对象
 */
-(void)addUser:(KCUser *)user;
/**
 *  删除用户
 *
 *  @param user 用户对象
 */
-(void)removeUser:(KCUser *)user;
/**
 *  根据用户名删除用户
 *
 *  @param name 用户名
 */
-(void)removeUserByName:(NSString *)name;
/**
 *  修改用户内容
 *
 *  @param user 用户对象
 */
-(void)modifyUser:(KCUser *)user;
/**
 *  根据用户编号取得用户
 *
 *  @param Id 用户编号
 *
 *  @return 用户对象
 */
-(KCUser *)getUserById:(int)Id;
/**
 *  根据用户名取得用户
 *
 *  @param name 用户名
 *
 *  @return 用户对象
 */
-(KCUser *)getUserByName:(NSString *)name;
@end
</code></pre>

<p>KCUserService.m</p>

<pre><code>//
//  KCUserService.m
//  DataAccess
//
//  Created by Kenshin Cui on 14-3-29.
//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.
//
#import "KCUserService.h"
#import "KCUser.h"
#import "KCDbManager.h"
@implementation KCUserService
singleton_implementation(KCUserService)
-(void)addUser:(KCUser *)user{
    NSString *sql=[NSString stringWithFormat:@"INSERT INTO User (name,screenName, profileImageUrl,mbtype,city) VALUES('%@','%@','%@','%@','%@')",user.name,user.screenName, user.profileImageUrl,user.mbtype,user.city];
    [[KCDbManager sharedKCDbManager] executeNonQuery:sql];
}
-(void)removeUser:(KCUser *)user{
    NSString *sql=[NSString stringWithFormat:@"DELETE FROM User WHERE Id='%@'",user.Id];
    [[KCDbManager sharedKCDbManager] executeNonQuery:sql];
}
-(void)removeUserByName:(NSString *)name{
    NSString *sql=[NSString stringWithFormat:@"DELETE FROM User WHERE name='%@'",name];
    [[KCDbManager sharedKCDbManager] executeNonQuery:sql];
}
-(void)modifyUser:(KCUser *)user{
    NSString *sql=[NSString stringWithFormat:@"UPDATE User SET name='%@',screenName='%@',profileImageUrl='%@',mbtype='%@',city='%@' WHERE Id='%@'",user.name,user.screenName,user.profileImageUrl,user.mbtype,user.city,user.Id];
    [[KCDbManager sharedKCDbManager] executeNonQuery:sql];
}
-(KCUser *)getUserById:(int)Id{
    KCUser *user=[[KCUser alloc]init];
    NSString *sql=[NSString stringWithFormat:@"SELECT name,screenName,profileImageUrl,mbtype,city FROM User WHERE Id='%i'", Id];
    NSArray *rows= [[KCDbManager sharedKCDbManager] executeQuery:sql];
    if (rows&amp;&amp;rows.count&gt;0) {
        [user setValuesForKeysWithDictionary:rows[0]];
    }
    return user;
}
-(KCUser *)getUserByName:(NSString *)name{
    KCUser *user=[[KCUser alloc]init];
    NSString *sql=[NSString stringWithFormat:@"SELECT Id, name,screenName,profileImageUrl,mbtype,city FROM User WHERE name='%@'", name];
    NSArray *rows= [[KCDbManager sharedKCDbManager] executeQuery:sql];
    if (rows&amp;&amp;rows.count&gt;0) {
        [user setValuesForKeysWithDictionary:rows[0]];
    }
    return user;
}
@end
</code></pre>

<p>KCStatusService.h</p>

<pre><code>//
//  KCStatusService.h
//  DataAccess
//
//  Created by Kenshin Cui on 14-3-29.
//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.
//
#import &lt;Foundation/Foundation.h&gt;
#import "KCSingleton.h"
@class KCStatus;
@interface KCStatusService : NSObject
singleton_interface(KCStatusService)
/**
 *  添加微博信息
 *
 *  @param status 微博对象
 */
-(void)addStatus:(KCStatus *)status;
/**
 *  删除微博
 *
 *  @param status 微博对象
 */
-(void)removeStatus:(KCStatus *)status;
/**
 *  修改微博内容
 *
 *  @param status 微博对象
 */
-(void)modifyStatus:(KCStatus *)status;
/**
 *  根据编号取得微博
 *
 *  @param Id 微博编号
 *
 *  @return 微博对象
 */
-(KCStatus *)getStatusById:(int)Id;
/**
 *  取得所有微博对象
 *
 *  @return 所有微博对象
 */
-(NSArray *)getAllStatus;
@end
</code></pre>

<p>KCStatusService.m</p>

<pre><code>//
//  KCStatusService.m
//  DataAccess
//
//  Created by Kenshin Cui on 14-3-29.
//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.
//
#import "KCStatusService.h"
#import "KCDbManager.h"
#import "KCStatus.h"
#import "KCUserService.h"
#import "KCSingleton.h"
@interface KCStatusService(){

}
@end
@implementation KCStatusService
singleton_implementation(KCStatusService)
-(void)addStatus:(KCStatus *)status{
    NSString *sql=[NSString stringWithFormat:@"INSERT INTO Status (source,createdAt,\"text\" ,user) VALUES('%@','%@','%@','%@')",status.source,status.createdAt,status.text,status.user.Id];
    [[KCDbManager sharedKCDbManager] executeNonQuery:sql];
}
-(void)removeStatus:(KCStatus *)status{
    NSString *sql=[NSString stringWithFormat:@"DELETE FROM Status WHERE Id='%@'",status.Id];
    [[KCDbManager sharedKCDbManager] executeNonQuery:sql];
}
-(void)modifyStatus:(KCStatus *)status{
    NSString *sql=[NSString stringWithFormat:@"UPDATE Status SET source='%@',createdAt='%@',\"text\"='%@' ,user='%@' WHERE Id='%@'",status.source,status.createdAt,status.text,status.user, status.Id];
    [[KCDbManager sharedKCDbManager] executeNonQuery:sql];
}
-(KCStatus *)getStatusById:(int)Id{
    KCStatus *status=[[KCStatus alloc]init];
    NSString *sql=[NSString stringWithFormat:@"SELECT Id, source,createdAt,\"text\" ,user FROM Status WHERE Id='%i'", Id];
    NSArray *rows= [[KCDbManager sharedKCDbManager] executeQuery:sql];
    if (rows&amp;&amp;rows.count&gt;0) {
        [status setValuesForKeysWithDictionary:rows[0]];
        status.user=[[KCUserService sharedKCUserService] getUserById:[(NSNumber *)rows[0][@"user"] intValue]] ;
    }
    return status;
}
-(NSArray *)getAllStatus{
    NSMutableArray *array=[NSMutableArray array];
    NSString *sql=@"SELECT Id, source,createdAt,\"text\" ,user FROM Status ORDER BY Id";
    NSArray *rows= [[KCDbManager sharedKCDbManager] executeQuery:sql];
    for (NSDictionary *dic in rows) {
        KCStatus *status=[self getStatusById:[(NSNumber *)dic[@"Id"] intValue]];
        [array addObject:status];
    }
    return array;
}
@end
</code></pre>

<p>最后，在视图控制器中调用相应的服务层进行各类数据操作，在下面的代码中分别演示了增、删、改、查四类操作。</p>

<pre><code>KCMainViewController.m
//
//  KCMainTableViewController.m
//  DataAccess
//
//  Created by Kenshin Cui on 14-3-29.
//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.
//
#import "KCMainTableViewController.h"
#import "KCDbManager.h"
#import "KCDatabaseCreator.h"
#import "KCUser.h"
#import "KCStatus.h"
#import "KCUserService.h"
#import "KCStatusService.h"
#import "KCStatusTableViewCell.h"
@interface KCMainTableViewController (){
    NSArray *_status;
    NSMutableArray *_statusCells;
}
@end
@implementation KCMainTableViewController
- (void)viewDidLoad {
    [super viewDidLoad];
    [KCDatabaseCreator initDatabase];

//    [self addUsers];
//    [self removeUser];
//    [self modifyUserInfo];

//    [self addStatus];

    [self loadStatusData];

}
-(void)addUsers{
    KCUser *user1=[KCUser userWithName:@"Binger" screenName:@"冰儿" profileImageUrl:@"binger.jpg" mbtype:@"mbtype.png" city:@"北京"];
    [[KCUserService sharedKCUserService] addUser:user1];
    KCUser *user2=[KCUser userWithName:@"Xiaona" screenName:@"小娜" profileImageUrl:@"xiaona.jpg" mbtype:@"mbtype.png" city:@"北京"];
    [[KCUserService sharedKCUserService] addUser:user2];
    KCUser *user3=[KCUser userWithName:@"Lily" screenName:@"丽丽" profileImageUrl:@"lily.jpg" mbtype:@"mbtype.png" city:@"北京"];
    [[KCUserService sharedKCUserService] addUser:user3];
    KCUser *user4=[KCUser userWithName:@"Qianmo" screenName:@"阡陌" profileImageUrl:@"qianmo.jpg" mbtype:@"mbtype.png" city:@"北京"];
    [[KCUserService sharedKCUserService] addUser:user4];
    KCUser *user5=[KCUser userWithName:@"Yanyue" screenName:@"炎月" profileImageUrl:@"yanyue.jpg" mbtype:@"mbtype.png" city:@"北京"];
    [[KCUserService sharedKCUserService] addUser:user5];
}
-(void)addStatus{
    KCStatus *status1=[KCStatus statusWithCreateAt:@"9:00" source:@"iPhone 6" text:@"一只雪猴在日本边泡温泉边玩iPhone的照片，获得了\"2014年野生动物摄影师\"大赛特等奖。一起来为猴子配个词" userId:1];
    [[KCStatusService sharedKCStatusService] addStatus:status1];
    KCStatus *status2=[KCStatus statusWithCreateAt:@"9:00" source:@"iPhone 6" text:@"一只雪猴在日本边泡温泉边玩iPhone的照片，获得了\"2014年野生动物摄影师\"大赛特等奖。一起来为猴子配个词" userId:1];
    [[KCStatusService sharedKCStatusService] addStatus:status2];
    KCStatus *status3=[KCStatus statusWithCreateAt:@"9:30" source:@"iPhone 6" text:@"【我们送iPhone6了 要求很简单】真心回馈粉丝，小编觉得现在最好的奖品就是iPhone6了。今起到12月31日，关注我们，转发微博，就有机会获iPhone6(奖品可能需要等待)！每月抽一台[鼓掌]。不费事，还是试试吧，万一中了呢" userId:2];
    [[KCStatusService sharedKCStatusService] addStatus:status3];
    KCStatus *status4=[KCStatus statusWithCreateAt:@"9:45" source:@"iPhone 6" text:@"重大新闻：蒂姆库克宣布出柜后，ISIS战士怒扔iPhone，沙特神职人员呼吁人们换回iPhone 4。[via Pan-Arabia Enquirer]" userId:3];
    [[KCStatusService sharedKCStatusService] addStatus:status4];
    KCStatus *status5=[KCStatus statusWithCreateAt:@"10:05" source:@"iPhone 6" text:@"小伙伴们，有谁知道怎么往Iphone4S里倒东西？倒入的东西又该在哪里找？用了Iphone这么长时间，还真的不知道怎么弄！有谁知道啊？谢谢！" userId:4];
    [[KCStatusService sharedKCStatusService] addStatus:status5];
    KCStatus *status6=[KCStatus statusWithCreateAt:@"10:07" source:@"iPhone 6" text:@"在音悦台iPhone客户端里发现一个悦单《Infinite 金明洙》，推荐给大家! " userId:1];
    [[KCStatusService sharedKCStatusService] addStatus:status6];
    KCStatus *status7=[KCStatus statusWithCreateAt:@"11:20" source:@"iPhone 6" text:@"如果sony吧mp3播放器产品发展下去，不贪图手头节目源的现实利益，就木有苹果的ipod，也就木有iphone。柯达类似的现实利益，不自我革命的案例也是一种巨头的宿命。" userId:2];
    [[KCStatusService sharedKCStatusService] addStatus:status7];
    KCStatus *status8=[KCStatus statusWithCreateAt:@"13:00" source:@"iPhone 6" text:@"【iPhone 7 Plus】新买的iPhone 7 Plus ，如何？够酷炫么？" userId:2];
    [[KCStatusService sharedKCStatusService] addStatus:status8];
    KCStatus *status9=[KCStatus statusWithCreateAt:@"13:24" source:@"iPhone 6" text:@"自拍神器#卡西欧TR500#，tr350S～价格美丽，行货，全国联保～iPhone6 iPhone6Plus卡西欧TR150 TR200 TR350 TR350S全面到货 招收各种代理！[给力]微信：39017366" userId:3];
    [[KCStatusService sharedKCStatusService] addStatus:status9];
    KCStatus *status10=[KCStatus statusWithCreateAt:@"13:26" source:@"iPhone 6" text:@"猜到猴哥玩手机时所思所想者，再奖iPhone一部。（奖品由“2014年野生动物摄影师”评委会颁发）" userId:3];
    [[KCStatusService sharedKCStatusService] addStatus:status10];
}
-(void)removeUser{
    //注意在SQLite中区分大小写
    [[KCUserService sharedKCUserService] removeUserByName:@"Yanyue"];
}
-(void)modifyUserInfo{
    KCUser *user1= [[KCUserService sharedKCUserService]getUserByName:@"Xiaona"];
    user1.city=@"上海";
    [[KCUserService sharedKCUserService] modifyUser:user1];

    KCUser *user2= [[KCUserService sharedKCUserService]getUserByName:@"Lily"];
    user2.city=@"深圳";
    [[KCUserService sharedKCUserService] modifyUser:user2];
}
#pragma mark 加载数据
-(void)loadStatusData{
    _statusCells=[[NSMutableArray alloc]init];
    _status=[[KCStatusService sharedKCStatusService]getAllStatus];
    [_status enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {
        KCStatusTableViewCell *cell=[[KCStatusTableViewCell alloc]init];
        cell.status=(KCStatus *)obj;
        [_statusCells addObject:cell];
    }];
    NSLog(@"%@",[_status lastObject]);
}
#pragma mark - Table view data source
- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView {
    return 1;
}
- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section {
    return _status.count;
}
- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {
    static NSString *identtityKey=@"myTableViewCellIdentityKey1";
    KCStatusTableViewCell *cell=[self.tableView dequeueReusableCellWithIdentifier:identtityKey];
    if(cell==nil){
        cell=[[KCStatusTableViewCell alloc]initWithStyle:UITableViewCellStyleValue1 reuseIdentifier:identtityKey];
    }
    cell.status=_status[indexPath.row];
    return cell;
}
-(CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath{
    return ((KCStatusTableViewCell *)_statusCells[indexPath.row]).height;
}
-(CGFloat)tableView:(UITableView *)tableView heightForHeaderInSection:(NSInteger)section{
    return 20.0f;
}
@end
</code></pre>

<p>项目目录结构：</p>

<p><img src="/images/CSR002.jpg" title="Caption" ></p>

<p>运行效果</p>

<p><img src="/images/CSR003.jpg" title="Caption" >
Core Data</p>

<p>基本概念</p>

<p>当前，各类应用开发中只要牵扯到数据库操作通常都会用到一个概念“对象关系映射（ORM）”。例如在Java平台使用Hibernate，在.NET平台使用Entity Framework、Linq、NHibernate等。在iOS中也不例外，iOS中ORM框架首选Core Data，这是官方推荐的，不需要借助第三方框架。无论是哪种平台、哪种技术，ORM框架的作用都是相同的，那就是将关系数据库中的表（准确的说是实体）转换为程序中的对象，其本质还是对数据库的操作（例如Core Data中如果存储类型配置为SQLite则本质还是操作的SQLite数据库）。细心的朋友应该已经注意到，在上面的SQLite中其实我们在KCMainViewController中进行的数据库操作已经转换为了对象操作，服务层中的方法中已经将对数据库的操作封装起来，转换为了对Model的操作，这种方式已经是面向对象的。上述通过将对象映射到实体的过程完全是手动完成的，相对来说操作比较复杂，就拿对KCStatus对象的操作来说：首先要手动创建数据库（Status表），其次手动创建模型KCStatus，接着创建服务层KCStatusService。Core Data正是为了解决这个问题而产生的，它将数据库的创建、表的创建、对象和表的转换等操作封装起来，简化了我们的操作（注意Core Data只是将对象关系的映射简化了，并不是把服务层替代了，这一点大家需要明白）。</p>

<p>使用Core Data进行数据库存取并不需要手动创建数据库，这个过程完全由Core Data框架完成，开发人员面对的是模型，主要的工作就是把模型创建起来，具体数据库如何创建则不用管。在iOS项目中添加“Data Model”文件。然后在其中创建实体和关系：</p>

<p><img src="/images/CSR004.jpg" title="Caption" >
<img src="/images/CSR005.jpg" title="Caption" ></p>

<p>模型创建的过程中需要注意：</p>

<p>1.实体对象不需要创建ID主键，Attributes中应该是有意义属性（创建过程中应该考虑对象的属性而不是数据库中表有几个字段，尽管多数属性会对应表的字段）。</p>

<p>2.所有的属性应该指定具体类型（尽管在SQLite中可以不指定），因为实体对象会对应生成ObjC模型类。</p>

<p>3.实体对象中其他实体对象类型的属性应该通过Relationships建立，并且注意实体之间的对应关系（例如一个用户有多条微博，而一条微博则只属于一个用户,用户和微博形成一对多的关系）。</p>

<p>以上模型创建后，接下来就是根据上面的模型文件（.xcdatamodeld文件）生成具体的实体类。在Xcode中添加“NSManagedObject Subclass”文件，按照步骤选择创建的模型及实体，Xcode就会根据所创建模型生成具体的实体类。</p>

<p>User.h</p>

<pre><code>//
//  User.h
//  CoreData
//
//  Created by Kenshin Cui on 14/03/27.
//  Copyright (c) 2014年 cmjstudio. All rights reserved.
//
#import &lt;Foundation/Foundation.h&gt;
#import &lt;CoreData/CoreData.h&gt;
@class Status;
@interface User : NSManagedObject
@property (nonatomic, retain) NSString * city;
@property (nonatomic, retain) NSString * mbtype;
@property (nonatomic, retain) NSString * name;
@property (nonatomic, retain) NSString * profileImageUrl;
@property (nonatomic, retain) NSString * screenName;
@property (nonatomic, retain) NSSet *statuses;
@end
@interface User (CoreDataGeneratedAccessors)
- (void)addStatusesObject:(Status *)value;
- (void)removeStatusesObject:(Status *)value;
- (void)addStatuses:(NSSet *)values;
- (void)removeStatuses:(NSSet *)values;
@end
</code></pre>

<p>User.m</p>

<pre><code>//
//  User.m
//  CoreData
//
//  Created by Kenshin Cui on 14/03/27.
//  Copyright (c) 2014年 cmjstudio. All rights reserved.
//
#import "User.h"
#import "Status.h"
@implementation User
@dynamic city;
@dynamic mbtype;
@dynamic name;
@dynamic profileImageUrl;
@dynamic screenName;
@dynamic statuses;
@end
</code></pre>

<p>Status.h</p>

<pre><code>//
//  Status.h
//  CoreData
//
//  Created by Kenshin Cui on 14/03/27.
//  Copyright (c) 2014年 cmjstudio. All rights reserved.
//
#import &lt;Foundation/Foundation.h&gt;
#import &lt;CoreData/CoreData.h&gt;
@interface Status : NSManagedObject
@property (nonatomic, retain) NSDate * createdAt;
@property (nonatomic, retain) NSString * source;
@property (nonatomic, retain) NSString * text;
@property (nonatomic, retain) NSManagedObject *user;
@end

Status.m


//
//  Status.m
//  CoreData
//
//  Created by Kenshin Cui on 14/03/27.
//  Copyright (c) 2014年 cmjstudio. All rights reserved.
//
#import "Status.h"
@implementation Status
@dynamic createdAt;
@dynamic source;
@dynamic text;
@dynamic user;
@end
</code></pre>

<p>很显然，通过模型生成类的过程相当简单，通常这些类也不需要手动维护，如果模型发生的变化只要重新生成即可。有几点需要注意：</p>

<p>1.所有的实体类型都继承于NSManagedObject，每个NSManagedObject对象对应着数据库中一条记录。</p>

<p>2.集合属性（例如User中的status）生成了访问此属性的分类方法。</p>

<p>3.使用@dynamic代表具体属性实现，具体实现细节不需要开发人员关心。</p>

<p>当然，了解了这些还不足以完成数据的操作。究竟Core Data具体的设计如何，要完成数据的存取我们还需要了解一下Core Data几个核心的类。</p>

<p><img src="/images/CSR006.jpg" title="Caption" ></p>

<ol>
<li><p>Persistent Object Store：可以理解为存储持久对象的数据库（例如SQLite，注意Core Data也支持其他类型的数据存储，例如xml、二进制数据等）。</p></li>
<li><p>Managed Object Model：对象模型，对应Xcode中创建的模型文件。</p></li>
<li><p>Persistent Store Coordinator：对象模型和实体类之间的转换协调器，用于管理不同存储对象的上下文。</p></li>
<li><p>Managed Object Context:对象管理上下文，负责实体对象和数据库之间的交互。</p></li>
</ol>


<p>Core Data使用</p>

<p>Core Data使用起来相对直接使用SQLite3的API而言更加的面向对象，操作过程通常分为以下几个步骤：</p>

<p>1.创建管理上下文</p>

<p>创建管理上下可以细分为：加载模型文件->指定数据存储路径->创建对应数据类型的存储->创建管理对象上下方并指定存储。</p>

<p>经过这几个步骤之后可以得到管理对象上下文NSManagedObjectContext，以后所有的数据操作都由此对象负责。同时如果是第一次创建上下文，Core Data会自动创建存储文件（例如这里使用SQLite3存储），并且根据模型对象创建对应的表结构。下图为第一次运行生成的数据库及相关映射文件：</p>

<p><img src="/images/CSR007.jpg" title="Caption" ></p>

<p>为了方便后面使用，NSManagedObjectContext对象可以作为单例或静态属性来保存，下面是创建的管理对象上下文的主要代码：</p>

<pre><code>-(NSManagedObjectContext *)createDbContext{
    NSManagedObjectContext *context;
    //打开模型文件，参数为nil则打开包中所有模型文件并合并成一个
    NSManagedObjectModel *model=[NSManagedObjectModel mergedModelFromBundles:nil];
    //创建解析器
    NSPersistentStoreCoordinator *storeCoordinator=[[NSPersistentStoreCoordinator alloc]initWithManagedObjectModel:model];
    //创建数据库保存路径
    NSString *dir=[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject];
    NSLog(@"%@",dir);
    NSString *path=[dir stringByAppendingPathComponent:@"myDatabase.db"];
    NSURL *url=[NSURL fileURLWithPath:path];
    //添加SQLite持久存储到解析器
    NSError *error;
    [storeCoordinator addPersistentStoreWithType:NSSQLiteStoreType configuration:nil URL:url options:nil error:&amp;error];
    if(error){
        NSLog(@"数据库打开失败！错误:%@",error.localizedDescription);
    }else{
        context=[[NSManagedObjectContext alloc]init];
        context.persistentStoreCoordinator=storeCoordinator;
        NSLog(@"数据库打开成功！");
    }
    return context;
}
</code></pre>

<p>2.查询数据</p>

<p>对于有条件的查询，在Core Data中是通过谓词来实现的。首先创建一个请求，然后设置请求条件，最后调用上下文执行请求的方法。</p>

<pre><code>-(void)addUserWithName:(NSString *)name screenName:(NSString *)screenName profileImageUrl:(NSString *)profileImageUrl mbtype:(NSString *)mbtype city:(NSString *)city{
    //添加一个对象
    User *us= [NSEntityDescription insertNewObjectForEntityForName:@"User" inManagedObjectContext:self.context];
    us.name=name;
    us.screenName=screenName;
    us.profileImageUrl=profileImageUrl;
    us.mbtype=mbtype;
    us.city=city;
    NSError *error;
    //保存上下文
    if (![self.context save:&amp;error]) {
        NSLog(@"添加过程中发生错误,错误信息：%@！",error.localizedDescription);
    }
}
</code></pre>

<p>如果有多个条件，只要使用谓词组合即可，那么对于关联对象条件怎么查询呢？这里分为两种情况进行介绍：</p>

<p>a.查找一个对象只有唯一一个关联对象的情况，例如查找用户名为“Binger”的微博（一个微博只能属于一个用户），通过keypath查询</p>

<pre><code>-(NSArray *)getStatusesByUserName:(NSString *)name{
    NSFetchRequest *request=[NSFetchRequest fetchRequestWithEntityName:@"Status"];
    request.predicate=[NSPredicate predicateWithFormat:@"user.name=%@",name];
    NSArray *array=[self.context executeFetchRequest:request error:nil];
    return  array;
}
</code></pre>

<p>此时如果跟踪Core Data生成的SQL语句会发现其实就是把Status表和User表进行了关联查询（JOIN连接）。</p>

<p>b.查找一个对象有多个关联对象的情况，例如查找发送微博内容中包含“Watch”并且用户昵称为“小娜”的用户（一个用户有多条微博），此时可以充分利用谓词进行过滤。</p>

<pre><code>-(NSArray *)getUsersByStatusText:(NSString *)text screenName:(NSString *)screenName{
    NSFetchRequest *request=[NSFetchRequest fetchRequestWithEntityName:@"Status"];
    request.predicate=[NSPredicate predicateWithFormat:@"text LIKE '*Watch*'",text];
    NSArray *statuses=[self.context executeFetchRequest:request error:nil];

    NSPredicate *userPredicate= [NSPredicate predicateWithFormat:@"user.screenName=%@",screenName];
    NSArray *users= [statuses filteredArrayUsingPredicate:userPredicate];
    return users;
}
</code></pre>

<p>注意：如果单纯查找微博中包含“Watch”的用户，直接查出对应的微博，然后通过每个微博的user属性即可获得用户，此时就不用使用额外的谓词过滤条件。</p>

<p>3.插入数据</p>

<p>插入数据需要调用实体描述对象NSEntityDescription返回一个实体对象，然后设置对象属性，最后保存当前上下文即可。这里需要注意，增、删、改操作完最后必须调用管理对象上下文的保存方法，否则操作不会执行。</p>

<pre><code>-(void)addUserWithName:(NSString *)name screenName:(NSString *)screenName profileImageUrl:(NSString *)profileImageUrl mbtype:(NSString *)mbtype city:(NSString *)city{
    //添加一个对象
    User *us= [NSEntityDescription insertNewObjectForEntityForName:@"User" inManagedObjectContext:self.context];
    us.name=name;
    us.screenName=screenName;
    us.profileImageUrl=profileImageUrl;
    us.mbtype=mbtype;
    us.city=city;
    NSError *error;
    //保存上下文
    if (![self.context save:&amp;error]) {
        NSLog(@"添加过程中发生错误,错误信息：%@！",error.localizedDescription);
    }
}
</code></pre>

<p>4.删除数据</p>

<p>删除数据可以直接调用管理对象上下文的deleteObject方法，删除完保存上下文即可。注意，删除数据前必须先查询到对应对象。</p>

<pre><code>-(void)removeUser:(User *)user{
    [self.context deleteObject:user];
    NSError *error;
    if (![self.context save:&amp;error]) {
        NSLog(@"删除过程中发生错误，错误信息：%@!",error.localizedDescription);
    }
}
</code></pre>

<p>5.修改数据</p>

<p>修改数据首先也是取出对应的实体对象，然后通过修改对象的属性，最后保存上下文。</p>

<pre><code>-(void)modifyUserWithName:(NSString *)name screenName:(NSString *)screenName profileImageUrl:(NSString *)profileImageUrl mbtype:(NSString *)mbtype city:(NSString *)city{
    User *us=[self getUserByName:name];
    us.screenName=screenName;
    us.profileImageUrl=profileImageUrl;
    us.mbtype=mbtype;
    us.city=city;
    NSError *error;
    if (![self.context save:&amp;error]) {
        NSLog(@"修改过程中发生错误,错误信息：%@",error.localizedDescription);
    }
}
</code></pre>

<p>调试</p>

<p>虽然Core Data（如果使用SQLite数据库）操作最终转换为SQL操作，但是调试起来却不想操作SQL那么方便。特别是对于初学者而言经常出现查询报错的问题，如果能看到最终生成的SQL语句自然对于调试很有帮助。事实上在Xcode中是支持Core Data调试的，具体操作：Product-Scheme-Edit Scheme-Run-Arguments中依次添加两个参数（注意参数顺序不能错）：-com.apple.CoreData.SQLDebug、1。然后在运行程序过程中如果操作了数据库就会将SQL语句打印在输出面板。</p>

<p><img src="/images/CSR008.jpg" title="Caption" ></p>

<p>注意：如果模型发生了变化，此时可以重新生成实体类文件，但是所生成的数据库并不会自动更新，这时需要考虑重新生成数据库并迁移原有的数据。</p>

<p>FMDB</p>

<p>基本使用</p>

<p>相比于SQLite3来说Core Data存在着诸多优势，它面向对象，开发人员不必过多的关心更多数据库操作知识，同时它基于ObjC操作，书写更加优雅等。但是它本身也存在着一定的限制，例如如果考虑到跨平台，则只能选择SQLite，因为无论是iOS还是Android都可以使用同一个数据库，降低了开发成本和维护成本。其次是当前多数ORM框架都存在的性能问题，因为ORM最终转化为SQL操作，其中牵扯到模型数据转化，其性能自然比不上直接使用SQL操作数据库。那么有没有更好的选择呢？答案就是对SQLite进行封装。</p>

<p>其实通过前面对于SQLite的分析，大家应该已经看到KCDbManager就是对于SQLite封装的结果，开发人员面对的只有SQL和ObjC方法，不用过多libsqlite3的C语言API。但它毕竟只是一个简单的封装，还有更多的细节没有考虑，例如如何处理并发安全性，如何更好的处理事务等。因此，这里推荐使用第三方框架FMDB，整个框架非常轻量级但又不失灵活性，也是很多企业开发的首选。</p>

<p>1.FMDB既然是对于libsqlite3框架的封装，自然使用起来也是类似的，使用前也要打开一个数据库，这个数据库文件存在则直接打开否则会创建并打开。这里FMDB引入了一个MFDatabase对象来表示数据库，打开数据库和后面的数据库操作全部依赖此对象。下面是打开数据库获得MFDatabase对象的代码：</p>

<pre><code>-(void)openDb:(NSString *)dbname{
    //取得数据库保存路径，通常保存沙盒Documents目录
    NSString *directory=[NSSearchPathForDirectoriesInDomains(NSDocumentationDirectory, NSUserDomainMask, YES) firstObject];
    NSLog(@"%@",directory);
    NSString *filePath=[directory stringByAppendingPathComponent:dbname];
    //创建FMDatabase对象
    self.database=[FMDatabase databaseWithPath:filePath];
    //打开数据上
    if ([self.database open]) {
        NSLog(@"数据库打开成功!");
    }else{
        NSLog(@"数据库打开失败!");
    }
}
</code></pre>

<p>注意：dataWithPath中的路径参数一般会选择保存到沙箱中的Documents目录中；如果这个参数设置为nil则数据库会在内存中创建；如果设置为@””则会在沙箱中的临时目录创建,应用程序关闭则文件删除。</p>

<p>2.对于数据库的操作跟前面KCDbManager的封装是类似的，在FMDB中FMDatabase类提供了两个方法executeUpdate:和executeQuery:分别用于执行无返回结果的查询和有返回结果的查询。当然这两个方法有很多的重载这里就不详细解释了。唯一需要指出的是，如果调用有格式化参数的sql语句时，格式化符号使用“?”而不是“%@”、等。下面是两种情况的代码片段：</p>

<p>a.无返回结果</p>

<p>-(void)executeNonQuery:(NSString *)sql{
    //执行更新sql语句，用于插入、修改、删除
    if (![self.database executeUpdate:sql]) {
        NSLog(@&ldquo;执行SQL语句过程中发生错误！&rdquo;);
    }
}</p>

<p>b.有返回结果</p>

<p>-(NSArray <em>)executeQuery:(NSString </em>)sql{
    NSMutableArray <em>array=[NSMutableArray array];
    //执行查询sql语句
    FMResultSet </em>result= [self.database executeQuery:sql];
    while (result.next) {
        NSMutableDictionary *dic=[NSMutableDictionary dictionary];
        for (int i=0; i&lt;result.columnCount; ++i) {
            dic[[result columnNameForIndex:i]]=[result stringForColumnIndex:i];
        }
        [array addObject:dic];
    }
    return array;
}</p>

<p>对于有返回结果的查询而言，查询完返回一个游标FMResultSet，通过遍历游标进行查询。而且FMDB中提供了大量intForColumn、stringForColumn等方法进行取值。</p>

<p>并发和事务</p>

<p>我们知道直接使用libsqlite3进行数据库操作其实是线程不安全的，如果遇到多个线程同时操作一个表的时候可能会发生意想不到的结果。为了解决这个问题建议在多线程中使用FMDatabaseQueue对象，相比FMDatabase而言，它是线程安全的。</p>

<p>创建FMDatabaseQueue的方法是类似的，调用databaseQueueWithPath:方法即可。注意这里不需要调用打开操作。</p>

<pre><code>-(void)openDb:(NSString *)dbname{
    //取得数据库保存路径，通常保存沙盒Documents目录
    NSString *directory=[NSSearchPathForDirectoriesInDomains(NSDocumentationDirectory, NSUserDomainMask, YES) firstObject];
    NSLog(@"%@",directory);
    NSString *filePath=[directory stringByAppendingPathComponent:dbname];
    //创建FMDatabaseQueue对象
    self.database=[FMDatabaseQueue databaseQueueWithPath:filePath];
}
</code></pre>

<p>然后所有的增删改查操作调用FMDatabaseQueue的inDatabase:方法在block中执行操作sql语句即可。</p>

<pre><code>-(void)executeNonQuery:(NSString *)sql{
    //执行更新sql语句，用于插入、修改、删除
    [self.database inDatabase:^(FMDatabase *db) {
        [db executeQuery:sql];
    }];
}
-(NSArray *)executeQuery:(NSString *)sql{
    NSMutableArray *array=[NSMutableArray array];
    [self.database inDatabase:^(FMDatabase *db) {
        //执行查询sql语句
        FMResultSet *result= [db executeQuery:sql];
        while (result.next) {
            NSMutableDictionary *dic=[NSMutableDictionary dictionary];
            for (int i=0; i&lt;result.columnCount; ++i) {
                dic[[result columnNameForIndex:i]]=[result stringForColumnIndex:i];
            }
            [array addObject:dic];
        }
    }];
    return array;
}
</code></pre>

<p>之所以将事务放到FMDB中去说并不是因为只有FMDB才支持事务，而是因为FMDB将其封装成了几个方法来调用，不用自己写对应的sql而已。其实在在使用libsqlite3操作数据库时也是原生支持事务的（因为这里的事务是基于数据库的，FMDB还是使用的SQLite数据库），只要在执行sql语句前加上“begin transaction;”执行完之后执行“commit transaction;”或者“rollback transaction;”进行提交或回滚即可。另外在Core Data中大家也可以发现，所有的增、删、改操作之后必须调用上下文的保存方法，其实本身就提供了事务的支持，只要不调用保存方法，之前所有的操作是不会提交的。在FMDB中FMDatabase有beginTransaction、commit、rollback三个方法进行开启事务、提交事务和回滚事务。</p>

<p>总结：</p>

<p>core data</p>

<p>core data 基于model-view-controller（mvc）模式下，为创建分解的cocoa应用程序提供了一个灵活和强大的数据模型框架。</p>

<p>core data可以使你以图形界面的方式快速的定义app的数据模型，同时在你的代码中容易获取到它。core data提供了基础结构去处理常用的功能，例如保存，恢复，撤销和重做，允许你在app中继续创建新的任务。在使用core data的时候，你不用安装额外的数据库系统，因为core data使用内置的sqlite数据库。</p>

<p>core data提供了一个通用的数据管理解决方案来处理那些所有需要数据模型的app(或大或小)。app使用core data来管理数据对象是很多的益处。</p>

<p>苹果的图形用户界面编译器-interface builder（IB），提供了对core data controller对象的预构建，从而来减少app的用户界面和它的数据模型之间的粘滞代码。在使用core data的时候你不需要考虑sql的语法问题，也不需要管理相关的逻辑树去追踪用户的行为，更不用建立新的永久机制。当你写你app的用户界面到它的 core data模型的时候，它已经为你把所有的东西都做好了。</p>

<p>core data将你app的模型层放入到一组定义在内存中的数据对象。core data会追踪这些对象的改变，同时可以根据需要做相反的改变，例如用户执行撤销命令。当core data在对你app数据的改变进行保存的时候，core data会把这些数据归档，并永久性保存。它保存的数据在一些常规的文件，你可以在Finder中可以进行管理，用spotlight进行搜索，备份到 cd，和email给朋友或者家人。</p>

<p>在使用core data框架的时候，你可以创建一个管理对象的模型，该模型提供了对模型对象的抽象定义，这也就是我们所知道的entities，它可以在我们的程序中使用。</p>

<p>core data是一个实体-关系模型，该模型是使用Xcode的数据模型设计工具来定义的，对数据实体以及他们的关系提供了丰富的环境。</p>

<p>sqlite</p>

<p>mac os x中sqlite库，它是一个轻量级功能强大的关系数据引擎，也很容易嵌入到应用程序。可以在多个平台使用，sqlite是一个轻量级的嵌入式sql数据库编程。与core data框架不同的是，sqlite是使用程序式的，sql的主要的API来直接操作数据表。</p>

<p>fmdb
FMDB框架其实只是一层很薄的封装，主要的类也就两个：FMDatabase和FMResultSet。在使用fmdb的时候还需要导入libsqlite3.0.dylib。</p>

<p>core data允许用户使用代表实体和实体间关系的高层对象来操作数据。它也可以管理串行化的数据，提供对象生存期管理与object_graph 管理，包括存储。Core Data直接与Sqlite交互，避免开发者使用原本的SQL语句.</p>

<p>上面的三种，都是在什么情况下使用呢？
在编写程序的时候尽量使用core data，这样才是最优的选择。
至于sqlite和fmdb的使用情况，这个看个人喜好了，个人觉得没什么标准。fmdb就是对sqlite的封装，使用起来有方便的接口，没那么麻烦而已。</p>

<pre><code>Q Q：2211523682/790806573

微信：18370997821/13148454507

微博WB:http://weibo.com/u/3288975567?is_hot=1

git博文：http://al1020119.github.io/

github：https://github.com/al1020119
</code></pre>

<p><img src="/images/iCocosCoder.jpg" title="Caption" ></p>

<p><img src="/images/iCocosPublic.jpg" title="Caption" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CoreData是什么？]]></title>
    <link href="http://al1020119.github.io/blog/2016/07/04/coredateashishemme/"/>
    <updated>2016-07-04T02:59:42+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/07/04/coredateashishemme</id>
    <content type="html"><![CDATA[<p>这段时间公司一直比较忙，和组里小伙伴一起把公司项目按照之前逻辑重写了一下。由于项目比较大，还要兼顾之前项目的迭代和其他项目，目前为止只写完第一阶段。</p>

<p>之前项目本地持久化方案主要用的是SQLite，这次重写项目打算换一种持久化方案，于是我们经过讨论选择了苹果的“亲儿子”CoreData。</p>

<p>在使用CoreData的过程中，我也是一边学习一边实践。在学习的过程中，一些写的质量比较高的博客对我的帮助也很大，例如objc.io等博客，在这里就不一一列举出来了，非常感谢这些作者。</p>

<!--more-->


<p>先不说项目中用不用得到，其实很多人都是不了解CoreData的，但是经过我的学习发现CoreData还是挺不错的。所以正如这系列文章的名字一样-认识CoreData，打算写这系列文章来认识一下CoreData。</p>

<p>这系列博客将从简单到复杂的来讲一下CoreData，其中除了基础使用还会包括多线程、批量数据处理等内容，这些很多都是我公司项目开发过程中接触到的，我们也设想了一些极端的情况，解决方案都会体现在这系列博客中。</p>

<p>本人接触CoreData时间并不长，只是专门花了一段时间学习CoreData。</p>

<p>本系列文章偏重于通过图形化界面使用CoreData，不会全部采取纯代码进行CoreData的所有操作，而且那样操作起来也确实比较麻烦，反而就失去了CoreData的优势和本质。</p>

<p>文章中如有疏漏或错误，还请各位及时提出，谢谢！</p>

<p>写在前面</p>

<p>在CoreData中有一些常用的类，称呼可能各不相同。所以这里先约定一些关键字，以便理解后面的一些内容，这些约定很多都是出现在苹果的官方文档中的。</p>

<pre><code>NSPersistentStoreCoordinator(Persistent Store Coordinator)，缩写为PSC。

NSManagedObjectContext(Managed Object Context)，缩写为MOC。

NSManagedObjectModel(Managed Object Model)，缩写为MOM。

NSManagedObject及其子类，根据英文翻译和其作用，称之为托管对象。

后缀名为.xcdatamodeld的文件，因为存储着所有实体的数据结构和表示，所以称之为模型文件。
</code></pre>

<p>什么是CoreData？</p>

<p>简单介绍一下</p>

<p>CoreData出现在iOS 3中，是苹果推出的一个数据存储框架。CoreData提供了一种对象关系映射(ORM)的存储关系，类似于Java的hibernate框架。CoreData可以将OC对象存储到数据库中，也可以将数据库中的数据转化为OC对象，在这个过程中不需要手动编写任何SQL语句，这是系统帮我们完成。</p>

<p>CoreData最大的优势就是使用过程中不需要编写任何SQL语句，CoreData封装了数据库的操作过程，以及数据库中数据和OC对象的转换过程。所以在使用CoreData的过程中，很多操作就像是对数据库进行操作一样，也有过滤条件、排序等操作。</p>

<p>这就相当于CoreData完成了Model层的大量工作，例如Model层的表示和持久化，有效的减少了开发的工作量，使Model层的设计更加面向对象。</p>

<p>CoreData好用吗？</p>

<p>之前听人说过，CoreData比较容易入手，但是很难学精。这也是很多人说CoreData不好用的原因之一，只是因为使用方式有问题，或者说并没有真正掌握CoreData。</p>

<p>如果从性能上来说，CoreData比SQLite确实略差一些。但是对于移动端来说，并不需要大型网站的高并发，所以这点性能差别几乎是没有影响的，所以这点可以忽略不计。在后面的文章中，将会给出CoreData的优点和缺点对比，以及详细的性能测评。</p>

<p>CoreData主要的几个类</p>

<pre><code>NSManagedObjectContext
</code></pre>

<p>托管对象上下文，进行数据操作时大多都是和这个类打交道。</p>

<pre><code>NSManagedObjectModel
</code></pre>

<p>托管对象模型，一个托管对象模型关联一个模型文件(.xcdatamodeld)，存储着数据库的数据结构。</p>

<pre><code>NSPersistentStoreCoordinator
</code></pre>

<p>持久化存储协调器，负责协调存储区和上下文之间的关系。</p>

<pre><code>NSManagedObject
</code></pre>

<p>托管对象类，所有CoreData中的托管对象都必须继承自当前类，根据实体创建托管对象类文件。</p>

<p>CoreData简单创建流程</p>

<p>模型文件操作</p>

<pre><code>1.1 创建模型文件，后缀名为.xcdatamodeld。创建模型文件之后，可以在其内部进行添加实体等操作(用于表示数据库文件的数据结构)

1.2 添加实体(表示数据库文件中的表结构)，添加实体后需要通过实体，来创建托管对象类文件。

1.3 添加属性并设置类型，可以在属性的右侧面板中设置默认值等选项。(每种数据类型设置选项是不同的)

1.4 创建获取请求模板、设置配置模板等。

1.5 根据指定实体，创建托管对象类文件(基于NSManagedObject的类文件)
</code></pre>

<p>实例化上下文对象</p>

<pre><code>2.1 创建托管对象上下文(NSManagedObjectContext)

2.2 创建托管对象模型(NSManagedObjectModel)

2.3 根据托管对象模型，创建持久化存储协调器(NSPersistentStoreCoordinator)

2.4 关联并创建本地数据库文件，并返回持久化存储对象(NSPersistentStore)

2.5 将持久化存储协调器赋值给托管对象上下文，完成基本创建。
</code></pre>

<p>CoreData结构</p>

<p>CoreData的结构构成</p>

<p>之前看到过几张介绍CoreData结构的图片，感觉其表示的结构比较清晰。可以通过这几张图片初步认识一下CoreData，在后面的文章中还会对这几个类进行详细解释。</p>

<p><img src="/images/1001.png" title="Caption" ></p>

<p>整体结构</p>

<p>上图中是初始化MOC所涉及到的一些类，由这些类实例化并最终构成可以使用的MOC。图中编号是实例化一个具备数据处理能力的MOC过程，这个过程和上面介绍过的实例化上下文对象相同。</p>

<p><img src="/images/1002.png" title="Caption" ></p>

<p>NSManagedObjectContext</p>

<p>在PSC创建并关联本地数据库，并设置为MOC的persistentStoreCoordinator属性后，MOC就具备对当前存储区所有托管对象操作的能力。但是需要注意的是，MOC对托管对象是懒加载的，在使用时才会被加载到MOC的缓存中。</p>

<p><img src="/images/1003.png" title="Caption" ></p>

<p>NSManagedObjectModel</p>

<p>MOM对象加载模型文件后，获取到模型文件中所有实体的构成结构。由于MOM中存储着模型文件的结构，PSC需要通过MOM对象实例化本地数据库。</p>

<p><img src="/images/1004.png" title="Caption" ></p>

<p>Entity</p>

<p>所有属性都存在Entity中，以及有关联关系的属性和请求模板，这都会在后面的章节中讲到。</p>

<p><img src="/images/1005.png" title="Caption" ></p>

<p>NSManagedObject</p>

<p>可以通过Entity创建继承自NSManagedObject类的文件，这个文件就是开发中使用的托管对象，具备模型对象的表示功能，CoreData的本地持久化都是通过这个类及其子类完成的。</p>

<p>持久化存储调度器</p>

<p>在CoreData的整体结构中，主要分为两部分。一个是NSManagedObjectContext管理的模型部分，管理着所有CoreData的托管对象。一个是SQLite实现的本地持久化部分，负责和SQL数据库进行数据交互，主要由NSPersistentStore类操作。这就构成了CoreData的大体结构。</p>

<p><img src="/images/1006.png" title="Caption" ></p>

<p>结构图</p>

<p>从图中可以看出，这两部分都是比较独立的，两部分的交互由一个持久化存储调度器(NSPersistentStoreCoordinator)来控制。上层NSManagedObjectContext存储的数据都是交给持久化调度器，由调度器调用具体的持久化存储对象(NSPersistentStore)来操作对应的数据库文件，NSPersistentStore负责存储的实现细节。这样就很好的将两部分实现了分离。</p>

<p>个人随想</p>

<p>对于CoreData的整体结构，因为CoreData底层存储本来就是用SQLite实现的，所以我用CoreData的结构和SQLite对比了一下，发现还是很多相似之处的。</p>

<p>.xcdatamodeld文件代表着数据库文件结构，通过.xcdatamodeld编译后的.momd文件生成数据库。每个实体代表一张数据表，实体之间的关联关系就是SQLite的外键。</p>

<p>下图就是CoreData底层存储的结构，用红圈圈住的部分指向关联表的主键下标。例如1就指向关联表的主键下标为1的行。</p>

<p><img src="/images/1007.png" title="Caption" ></p>

<p>外键</p>

<p>CoreData杂谈</p>

<p>CoreData数据存储安全</p>

<p>CoreData本质还是使用SQLite进行存储，并没有另外提供加密功能，具体的数据加解密还需要自己完成。</p>

<p>CoreData在硬盘上的数据存储结构：</p>

<p><img src="/images/1008.png" title="Caption" ></p>

<p>数据库存储结构</p>

<p>通过PSC指定创建SQLite目录后，会在指定的目录下生成一个数据库文件，同时还会生成两个同名但后缀不同的文件，其中只有后缀.sqlite的文件是存储数据的文件。</p>

<p>这个数据库文件中会默认生成三个表，Z_METADATA、Z_PRIMARYKEY、Z_MODELCACHE，其他我们自己的表也都是大写Z开头的。</p>

<p>在每个表中，系统还会默认生成三个字段，Z_PK、Z_ENT、Z_OPT三个字段，也都是大写Z开头并且带下划线的。其他字段就是我们自己的字段了，大写Z开头但不带下划线。</p>

<p>CoreData执行效率</p>

<p>现在市面上的大多数项目，都是使用SQLite作为持久化的方案，而CoreData的使用并不是很普遍。对于这个问题，我认为首先是很多项目开始的比较早，那时候好多iOS程序员都是从其他语言转过来的，更加熟悉SQLite，所以用SQLite比较多一些。后面如果不进行大的项目重构，就很难换其他的持久化方案了。</p>

<p>还有就是不熟悉CoreData，也不想去了解和深入学习CoreData，我认为这是很大的原因。所以项目中用CoreData的人并不多，而真正掌握CoreData技术的人更少。</p>

<p>之前听其他人说CoreData的执行效率不如SQLite高，这个如果深究的话，确实CoreData要比SQLite效率差一些，只不过并没有太大区别。CoreData本质也是在底层执行SQL语句，只是CoreData的SQL语句执行逻辑比较耗时，没有手动编写SQL语句更加直接。我们可以将CoreData的调试功能打开，具体看一下SQL语句的执行。</p>

<p>这里要说一点，客户端毕竟不是服务端，不需要像服务器那样大量的数据查询，所以CoreData是完全可以应对客户端的查询量的。如果从灵活性来说，CoreData确实没有SQLite的灵活性高，一些SQLite的复杂功能可能也不能实现，但是就目前大多数项目来说，CoreData已经能够满足项目持久化需求了。</p>

<p>导致执行效率差异的原因还体现在对象转换上，CoreData在执行SQL语句的基础上，还多了一层将数据映射给托管对象的操作，这样得到的就是OC的托管对象，而SQLite得到的则不是。如果给SQLite执行完成后，也加一层创建托管对象并赋值的操作，这时候对比性能两者的差距可能就会更小了。</p>

<p>性能评测</p>

<p>下面是一篇关于CoreData、FMDB、Realm性能测试结果的博客，最后的结果我也没有去验证，只是大致看了一下代码还是比价靠谱的。作者测试Demo和原文地址。</p>

<p>测试数据的数量是以K为单位，最少为1K的数据量。涉及到的操作主要是下面四种：</p>

<pre><code>新建数据库并插入1K条数据。

已有数据库，插入1K条数据。

查询总量为10K条数据，连续查询单次为1K数据。

10K条数据总量，更新其中1K条数据的部分字段性能。
</code></pre>

<p>性能评测结果：</p>

<p>根据测试结果可以发现，在前面两种插入操作，CoreData的性能比FMDB和Realm要快很多。</p>

<p>而对于查询操作，CoreData比其他两种操作耗时多很多，大概多出三四倍。这很可能和CoreData将查询结果的数据转为托管对象有关系，抛去CoreData这部分转换操作性能会比现在好很多。</p>

<p>而更新操作则直接基于SQLite封装的FMDB有绝对的优势，FMDB和其他两种操作差距大概是十倍左右，而其他两种操作性能差不多。当然CoreData也存在着上面提到的对象转换操作，CoreData抛去这步结果可能会比现在好很多。</p>

<p>测试图表</p>

<p>下面的测试数据中，取得是三次测试结果的平均值。</p>

<p><img src="/images/1009.png" title="Caption" ></p>

<p><img src="/images/1010.png" title="Caption" ></p>

<p>新建数据库并插入1K条数据</p>

<p><img src="/images/1011.png" title="Caption" ></p>

<p>已有数据库，插入1K条数据</p>

<p><img src="/images/1012.png" title="Caption" ></p>

<p>查询总量为10K条数据，连续查询单次为1K数据</p>

<p><img src="/images/1013.png" title="Caption" ></p>

<p>10K条数据总量，更新其中1K条数据的部分字段性能</p>

<p>CoreData调试</p>

<p>Xcode调试命令</p>

<p>CoreData本质上是对SQLite的一个封装，在内部将对象的持久化转化为SQL语句执行，可以在项目中将CoreData调试打开，从而可以看到CoreData的SQL语句执行和一些其他log信息。</p>

<p>打开Product，选择Edit Scheme.</p>

<p>选择Arguments，在下面的ArgumentsPassed On Launch中添加下面两个选项。</p>

<pre><code>(1)-com.apple.CoreData.SQLDebug

(2)1

    终端调试命令

    如果是在模拟器上调试程序，可以通过 sqlite3 /数据库路径/ 命令来查看和操作数据库。

    .tables 查看当前数据库文件中所有的表名

    select *from tableName 执行查询的SQL语句

    <img src="/images/1014.png" title="Caption" > 

    终端调试命令
</code></pre>

<hr />

<pre><code>Q Q：2211523682/790806573

微信：18370997821/13148454507

微博WB:http://weibo.com/u/3288975567?is_hot=1

git博文：http://al1020119.github.io/

github：https://github.com/al1020119
</code></pre>

<p><img src="/images/iCocosCoder.jpg" title="Caption" ></p>

<p><img src="/images/iCocosPublic.jpg" title="Caption" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[FMDB封装篇]]></title>
    <link href="http://al1020119.github.io/blog/2016/07/02/fmdbzfenghuznag/"/>
    <updated>2016-07-02T22:59:42+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/07/02/fmdbzfenghuznag</id>
    <content type="html"><![CDATA[<p>前言：</p>

<p>在自己开发中，每次用到数据库都会纠结是使用CoreData还是FMDB。CoreData虽然Api简单，但是调用栈非常复杂，要初始化一个Context需要至少20行代码。。。</p>

<p>显然，对于这种这么恶心的情况，我们的大Github必须有人会跳出来解决这种问题。于是就出现了MagicRecord这个对CoreData的封装库。一开始遇到这个库的时候，好用到几乎让我想把所有项目的数据库都换成CoreData了。两句话解决CoreData调用栈的初始化，一句话完成数据库版本升级和自动数据合并更新（虽然我们很少用到）。</p>

<p>然而这并不能解决一个根本性的问题，CoreData中的每个Object都要和一个context进行绑定，导致我们很多业务需求需要创建自己的私有context，然后再需要更新的时候保存到主context中。这又导致了我们在controller中或者在自己的业务类中维护多一个私有context属性。</p>

<!--more-->


<p>所以，最后还是选择了FMDB进行封装。</p>

<p>之前自己搞过Java后台，将FMDB进行Hibernate式的封装，使用runtime解析，不用继承任何基类（swift中要继承NSObject），只要实现一个持久化协议并实现方法即可，屏蔽基本的数据库和表操作。</p>

<p>项目简介：</p>

<h5>JRDB：一个对FMDB进行类Hibernate封装的iOS库，支持Objective-C 和 Swift。</h5>

<p>Description</p>

<pre><code>使用分类的模式，模仿Hibernate，对FMDB进行简易封装

支持pod 安装 『pod 'JRDB'』，Podfile需要添加 use_framework!

使用协议，不用继承基类，对任意NSObject可以进行入库操作

支持swift 和 Objective-C

支持数据类型：基本数据类型（int，double，等），String，NSData，NSNumber，NSDate
</code></pre>

<h5>注：Swift的基本数据类型，不支持Option类型，既不支持Int？Int！等，对象类型支持Option类型</h5>

<p>Installation（安装）</p>

<pre><code>use_frameworks!
pod 'JRDB'
@import JRDB;
</code></pre>

<p>Usage</p>

<p>。。。</p>

<p>Save（保存）</p>

<p>Objective-C</p>

<pre><code>Person *p = [[Person alloc] init];
p.a_int = 1;
p.b_unsigned_int = 2;
p.c_long = 3;
p.d_long_long = 4;
p.e_unsigned_long = 5;
p.f_unsigned_long_long = 6;
p.g_float = 7.0;
p.h_double = 8.0;
p.i_string = @"9";
p.j_number = @10;
p.k_data = [NSData data];
p.l_date = [NSDate date];
[p jr_save];
</code></pre>

<p>Swift</p>

<p>Swift中需要入库的类需要继承NSObject（使用到runtime）</p>

<pre><code>The Object that you want to persistent should inherit from NSObject

let p = Person()
p.name = "name"
p.age = 10
p.birthday = NSDate()
p.jr_save()
</code></pre>

<h5>Update（更新）</h5>

<pre><code>Person *p = [Person jr_findAll].firstObject;
p.name = @"abc";
[p jr_update columns:nil];
</code></pre>

<p>column: 需要更新的字段名，传入空为全量更新</p>

<h5>Delete（删除）</h5>

<pre><code>Person *p = [Person jr_findAll].firstObject;
[p jr_delete];
</code></pre>

<h5>Select（查找）</h5>

<h5>常规查找</h5>

<pre><code>Person *p = [Person jr_findByPrimaryKey:@"111"];
NSArray *list = [Person jr_findAll];
NSArray *list1 = [Person jr_findAllOrderBy:@"_age" isDesc:YES];
</code></pre>

<h5>条件查询</h5>

<pre><code>NSArray *condis = @[
     [JRQueryCondition condition:@"_l_date &lt; ?" args:@[[NSDate date]] type:JRQueryConditionTypeAnd],
     [JRQueryCondition condition:@"_a_int &gt; ?" args:@[@9] type:JRQueryConditionTypeAnd],];
NSArray *arr = [Person jr_findByConditions:condis
                      groupBy:@"_room"
                      orderBy:@"_age"
                      limit:@" limit 0,13 "
                      isDesc:YES];
</code></pre>

<p>SQL</p>

<pre><code>NSString *sql = @"select * from Person where age = ?";
NSArray *list = [Person jr_executeSql:sql args:@[@10]];
</code></pre>

<p>Other（其他）</p>

<p>协议：JRPersistent</p>

<pre><code>@protocol JRPersistent @required
- (void)setID:(NSString * _Nullable)ID;
- (NSString * _Nullable)ID;
@optional
/**
 *  返回不用入库的对象字段数组
 *  The full property names that you want to ignore for persistent
 *  @return array
 */
+ (NSArray * _Nullable)jr_excludePropertyNames;
/**
 *  返回自定义主键字段
 *  @return 字段全名
 */
+ (NSString * _Nullable)jr_customPrimarykey;
/**
 *  返回自定义主键值
 *  @return 主键值
 */
- (id _Nullable)jr_customPrimarykeyValue;
@end
</code></pre>

<p>主键</p>

<p>默认每个Object的主键为ID， UUID字符串。</p>

<p>可以实现 jr_customPrimarykey 以及 jr_customPrimarykeyValue 方法，自定义主键。</p>

<p>默认NSObject分类实现</p>

<pre><code>@interface NSObject (JRDB) (...methods)
@end
JRDBMgr
@interface JRDBMgr : NSObject
@property (nonatomic, strong) FMDatabase *defaultDB;
+ (instancetype)shareInstance;
+ (FMDatabase *)defaultDB;
- (FMDatabase *)createDBWithPath:(NSString *)path;
- (void)deleteDBWithPath:(NSString *)path;
/**
 *  在这里注册的类，使用本框架的数据库将全部建有这些表
 *  @param clazz 类名
 */
- (void)registerClazzForUpdateTable:(Class)clazz;
- (NSArray *)registedClazz;
/**
 * 更新默认数据库的表（或者新建没有的表）
 * 更新的表需要在本类先注册
 */
- (void)updateDefaultDB;
- (void)updateDB:(FMDatabase *)db;
@end
</code></pre>

<p>JRDBMgr持有一个默认数据库（~/Documents/jrdb/jrdb.sqlite），任何不指定数据库的操作，都在此数据库进行操作。默认数据库可以自行设置。</p>

<p>Method</p>

<pre><code>- (void)registerClazzForUpdateTable:(Class)clazz;
</code></pre>

<p>在JRDBMgr中注册的类，可以使用</p>

<pre><code>-(void)updateDB:(FMDatabase *)db
</code></pre>

<p>进行统一更新或者创建表。</p>

<p>Table Operation（表操作）</p>

<p>Create（建表）</p>

<pre><code>// FMDatabase+JRDB 方法
[[JRDBMgr defaultDB] createTable4Clazz:[Person class]];
[Person jr_createTable];
// 删除原有的表，重新创建
[[JRDBMgr defaultDB] truncateTable4Clazz:[Person class]];
[Person jr_truncateTable];
//保存时，若发现没有表，将自动创建
[person jr_save];
Update 【更新表】
[[JRDBMgr defaultDB] updateTable4Clazz:[Person class]];
[Person jr_updateTable];
</code></pre>

<p>更新表时，只会添加不存在的字段，不会修改字段属性，不会删除字段，若有需要，需要自行写sql语句进行修改</p>

<p>Drop（删表）</p>

<pre><code>[[JRDBMgr defaultDB] dropTable4Clazz:[Person class]];
[Person jr_dropTable];
</code></pre>

<p>Thread Operation（线程操作）</p>

<p>多线程操作使用FMDB自带的 FMDatabaseQueue</p>

<pre><code>[person jr_saveWithComplete:^(BOOL success) {
    NSLog(@"%d", success);
}];
</code></pre>

<p>任何带complete block的操作，都将放入到FMDatabaseQueue进行顺序执行</p>

<p>注：所有需要立刻返回结果，或者影响其他操作的数据库操作，都建议放在主线程进行更新，大批量更新以及多线程操作数据库时，请使用带complete block的操作。</p>

<pre><code>Q Q：2211523682/790806573

微信：18370997821/13148454507

微博WB:http://weibo.com/u/3288975567?is_hot=1

git博文：http://al1020119.github.io/

github：https://github.com/al1020119
</code></pre>

<p><img src="/images/iCocosCoder.jpg" title="Caption" ></p>

<p><img src="/images/iCocosPublic.jpg" title="Caption" ></p>
]]></content>
  </entry>
  
</feed>
