<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Architecture | iOS梦工厂]]></title>
  <link href="http://al1020119.github.io/blog/categories/architecture/atom.xml" rel="self"/>
  <link href="http://al1020119.github.io/"/>
  <updated>2017-01-10T11:35:51+08:00</updated>
  <id>http://al1020119.github.io/</id>
  <author>
    <name><![CDATA[iCocos]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[修行篇-ios开发中常见设计模式]]></title>
    <link href="http://al1020119.github.io/blog/2016/08/30/xiu-xing-pian-ioskai-fa-zhong-chang-jian-she-ji-mo-shi/"/>
    <updated>2016-08-30T13:10:04+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/08/30/xiu-xing-pian-ioskai-fa-zhong-chang-jian-she-ji-mo-shi</id>
    <content type="html"><![CDATA[<p>本文摘自：<a href="http://ios.jobbole.com/85360/">伯乐在线</a>,因为自己研究并学习ios设计模式的时候寻找了好多相关文章，最后发现这篇才是最适合ios开发的，当然你也可以自己通过C或者java设计模式的规范进行演变。</p>

<p>源码下载地址：<a href="https://github.com/al1020119/iCocosDesignPattern">https://github.com/al1020119/iCocosDesignPattern</a></p>

<h1>对象创建</h1>

<h4>原型（Prototype）</h4>

<p>使用原型实例指定创建对象的种类，并通过复制这个原型创建新的对象。</p>

<pre><code>NSArray *array = [[NSArray alloc] initWithObjects:@1, nil];
NSArray *array2 = array.copy;
</code></pre>

<p>array 就是原型了，array2 以 array 为原型，通过 copy 操作创建了 array2。</p>

<p>当创建的实例非常复杂且耗时，或者新实例和已存在的实例值相同，使用原型模式去复制已经存在的实例效率更高。</p>

<h4>工厂方法（Factory Method）</h4>

<pre><code>定义创建对象的接口，让子类决定实例化哪一个类。工厂方法使得类的实例化延迟到其子类。
</code></pre>

<p>工厂方法是针对每一种产品提供一个工厂类。通过不同的工厂类来创建不同的产品实例。</p>

<p><img src="/images/iosshejimoshi001.png" title="Caption" ></p>

<ul>
<li>如上图，+ create():Product 就是工厂方法，ConcreatFactoryA 与 ConcreateFactoryB 就是两个工厂类，ConcreateProductA 与 ConcreateProductB 就是两个工厂类对应的产品类，通过不同的工厂生产不同类型的产品，且两个产品类最终返回的是他们的父类 Product，隐藏了对象的具体类型。工厂方法模式让创建的对象拥有一组共同的接口，使我们无需关心做了不同类型接口的具体实现，只需要调用 Product 的接口就行。</li>
</ul>


<blockquote><p>工厂方法模式的扩展性也很好，新增的产品类并不需要修改客户端代码。但每新加一个产品类都需要新建一个工厂类，会造成项目中的类过多。</p></blockquote>

<p>而在 Cocoa Touch 框架中，以 NSNumber 举例，将原有的 alloc+init 拆开写：</p>

<pre><code> id obj1 = [NSNumber alloc];
    id obj2 = [NSNumber alloc];
    id obj3 = [obj1 initWithBool:YES];
</code></pre>

<p>发现 + alloc 后并非生成了我们期望的类实例，而是一个NSPlacehodlerNumber 的中间对象，后面的 – initWithXXXXX 消息都是发送给这个中间对象，再由它做工厂，生成真的对象。如 obj3 的实际类型为 NSCFBoolean，而 obj4 的实际类型为 NSCFNumber 。</p>

<h4>抽象工厂（Abstract Factory）</h4>

<pre><code>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。
</code></pre>

<p><img src="/images/iosshejimoshi002.png" title="Caption" ></p>

<ul>
<li>如上图，抽象工厂有一个产品族的概念，Factory1 与 Factory2 是继承 AbstractFactory 的两个产品族工厂类， 继承了父类创建 A，B 两个产品的方法，不同产品族工厂类会创建不同类型的产品，最终返回了不同的产品族对象，既 ProductA 和 ProductB。</li>
</ul>


<p>在 Cocoa Touch 框架中，类簇是抽象工厂模式在 iOS 下的一种实现，以 NSArray 举例，将原有的 alloc+init 拆开写：</p>

<pre><code>id obj1 = [NSArray alloc]; // __NSPlacehodlerArray *
id obj2 = [NSMutableArray alloc];  // __NSPlacehodlerArray *
id obj3 = [obj1 init];  // __NSArrayI *
id obj4 = [obj2 init];  // __NSArrayM *
</code></pre>

<p>发现 + alloc 后并非生成了我们期望的类实例，而是一个NSPlacehodlerArray 的中间对象，后面的 – init 或 – initWithXXXXX 消息都是发送给这个中间对象，再由它做工厂，生成真的对象。这里的 NSArrayI 和 __NSArrayM 分别对应 Immutable 和 Mutable（后面的 I 和 M 的意思）</p>

<blockquote><p>于是顺着思路猜实现，__NSPlacehodlerArray 必定用某种方式存储了它是由谁 alloc 出来的这个信息，才能在 init 的时候知道要创建的是可变数组还是不可变数组。</p></blockquote>

<p>抽象工厂将一系列的产品族统一到一起创建，增加产品族很方便，但增加产品很麻烦，需要改动太多的类的接口。</p>

<h4>生成器（Builder）</h4>

<p>将一个复杂对象的构建与它的表现分离，使得同样的构建过程可以创建不同的表现。
生成器可以将构建对象的过程分为，客户 – 指导者 – 生成器 的关系，</p>

<pre><code>CharacterBuilder *characterBuilder = [[StandarCharacterBuilder alloc] init];
ChasingGame *game = [[ChasingGame alloc] init];

Character *player = [chasingGame createPlayer:characterBuilder];
Character *enemy = [chasingGame createEnemy:characterBuilder];
</code></pre>

<p>characterBuilder 就是生成器了，而 game 就是指导者。指导者里声明了创建不同表现的对象的方法。而方法里由生成器 characterBuilder 来构建不同的 Character 类型的对象。</p>

<ul>
<li>生成器模式将复杂的生成对象的过程交给了生成器去完成，作为客户的我们只需要根据简单的接口去生成不同表现的对象。如上述代码中的 player 以及 enemy。玩家和敌人具体的属性数值我们不需要去设置，而是交给生成器去设置。</li>
</ul>


<h4>单例（Singleton）</h4>

<pre><code>保证一个类仅有一个实例，并提供一个访问它的全局访问点。
</code></pre>

<p>在 Cocoa Touch 框架中，最常见的使用了单例模式的就是 UIApplication 类了。每个应用程序有且仅有一个 UIApplication 的实例，它由 UIApplicationMain 函数在程序启动时创建为单例对象，之后，对同一 UIApplication 实例可以通过其 sharedApplication 类方法进行访问。</p>

<p>单例用来集中管理对类的对象所提供的资源，例如应用程序中需要用集中式的类来协调其服务，这个类就应该生成单一的实例。</p>

<ul>
<li>单例模式在多线程的应用场合下必须小心使用。如果当唯一实例尚未创建时，有两个线程同时调用创建方法，那么它们同时没有检测到唯一实例的存在，从而同时各自创建了一个实例，这样就有两个实例被构造出来，从而违反了单例模式中实例唯一的原则。 解决这个问题的办法是为指示类是否已经实例化的变量提供一个互斥锁。</li>
</ul>


<h1>接口适配</h1>

<h4>适配器（Adapter）</h4>

<pre><code>将一个类的接口转换成客户希望的另一个接口，适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
</code></pre>

<p>适配器模式分为类适配器模式和对象适配器模式。
<img src="/images/iosshejimoshi003.png" title="Caption" ></p>

<ul>
<li>上图是对象适配器模式，Adapter（适配器）遵守了 Target（目标接口）协议，拥有一个 Adaptee（被适配者）的对象 adaptee 的引用，当调用 Adapter 的 request 方法，request 方法里会去调用 adapteee 的 specificRequest 方法。</li>
</ul>


<h4>类适配模式</h4>

<p><img src="/images/iosshejimoshi004.png" title="Caption" ></p>

<p>类适配器模式中适配器和被适配者是继承关系。request 方法里会去调用 super 的 specificRequest 方法，达到将类的接口转换成客户希望的另一个接口。</p>

<p>适配器模式主要应用于“希望复用一些现存的类，但是接口又与复用环境要求不一致的情况”，在遗留代码复用、类库迁移等方面非常有用。</p>

<h4>桥接（Bridge）</h4>

<pre><code>将抽象部分与它的实现部分分离，使它们都可以独立地变化。
</code></pre>

<p>桥接模式是软件设计模式中最复杂的模式之一，在软件系统中，某些类型由于自身的逻辑，它具有两个或多个维度的变化。</p>

<p><img src="/images/iosshejimoshi005.png" title="Caption" ></p>

<ul>
<li>如上图，毛笔和颜色是两个维度的变化，可以选择新建 9 个类去实现不同颜色的不同毛笔，也可以如图所示，去组合两个维度。对于客户端而言，可以针对两个维度的抽象层编程，在程序运行的时候再动态确认两个维度的子类，动态组合对象，将两个独立变化的维度完全解耦，以便能够灵活地扩充任一维度而对另一维度不造成任何影响。比如增加一种毛笔并不需要去改动图中的实现部分，增加一种颜色也不需要去改变抽象部分。（抽象部分是面向我们编程的接口部分，我们绘图的时候是调用毛笔类的绘图方法）。</li>
</ul>


<p>桥接模式可以让抽象与实现之间不形成绑定关系，在运行时可以切换实现，也将抽象和实现完全解耦，可以独立扩展。</p>

<h4>外观（Facade）</h4>

<pre><code>为系统中的一组接口提供一个统一的接口。外观顶一个高层接口，让子系统更易于使用。
</code></pre>

<p>外观模式主要是使用一个外观类，为复杂的子系统提供一个简单的接口，而子系统的复杂调用交给外观类去做。</p>

<p><img src="/images/iosshejimoshi006.png" title="Caption" ></p>

<ul>
<li>如上图，数据的来源可能是不同数据库，获取数据可能非常的复杂，所以使用一个外观类提供简单的获取数据的接口，复杂的操作让外观类去做。做到让子系统更加的易用。</li>
</ul>


<h1>对象去耦</h1>

<h4>中介者（Mediator）</h4>

<pre><code>用一个对象来封装一系列对象的交互方式，中介者使各对象不需要显示地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。
</code></pre>

<p>我们开发的程序是由大量的类来组成的，随着程序功能的不断增加，类和类之间的依赖关系也跟着趋于复杂，而中介者模式便能解决这个问题，</p>

<p><img src="/images/iosshejimoshi007.png" title="Caption" ></p>

<ul>
<li>如图所示，6 个 VC 类之间的交互可能特别多，如果让他们相互依赖，然后管理这些 VC 之间的关系是一件非常繁琐的事情，我们要处理各个 VC 之间的关系，每当一个 VC 要跳转到另外个 VC，我们需要包含新的 VC 的头文件。而使用中介者模式，让 VC 之间的交互变成 VC 和中介者的交互，用中介者来管理多对多的复杂的对象群，降低了各个对象之间的耦合，减少了对象之间逻辑的复杂度，但也可能导致中介者类中的实现过于复杂。</li>
</ul>


<p>UINavigationController 就是一个中介者，如下图所示</p>

<p><img src="/images/iosshejimoshi008.png" title="Caption" ></p>

<p>视图控制器的切换都是与 UINavigationController 做交互。由 UINavigationController 去做集中管理。</p>

<h4>观察者（Observer）</h4>

<pre><code>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。
</code></pre>

<p>在 Cocoa Touch 框架中通知和 KVO 都实现了观察者模式。通知是由一个中心对象为所有观察者提供变更通知，KVO 是被观察的对象直接向观察者发送通知。</p>

<p><img src="/images/iosshejimoshi009.png" title="Caption" ></p>

<ul>
<li>如上图，Subject 的值改变时，通知观察者 ObserverA，ObserverB，ObserverC，我的数据改变了，依赖我的你们需要更新状态了。</li>
</ul>


<p>被观察者不需要知道有多少个观察者和观察者的更新细节，降低被观察者和观察者之间的耦合。</p>

<h1>抽象集合</h1>

<h4>组合（Composite）</h4>

<pre><code>将对象组合成树形结构以表示“部分-整体”的层次结构。组合使得用户对单个对象和组合对象的使用具有一致性。
</code></pre>

<p>在 Cocoa Touch 框架中，UIView 被组织成一个组合结构。每个 UIView 都可以将其它 UIView 设置为自己的子视图，形成一个树形结构，让客户端可以对单个 UIView 或者对 UIView 组合统一对待。</p>

<p>既平移一个 UIView，可以做到平移这一个 UIView 组合，且操作方法与平移单个 UIView 一致。</p>

<h4>迭代器（Iterator）</h4>

<pre><code>提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示，
</code></pre>

<p>在 Cocoa Touch 中的 NSEnumerator 就实现了迭代器模式，如以下代码</p>

<pre><code> NSArray *anArray = @[@"this", @"is", @"a", @"test"];
    NSEnumerator *itemEnumerator = [anArray objectEnumerator];

    NSString *item;
    while (item = [itemEnumerator nextObject]) {
        NSLog(@"%@", item);
    }
</code></pre>

<p>迭代器分为两种，上面使用了一个外部迭代器，外部迭代器让客户端直接操作迭代过程，如上面代码就是使用一个 while 循环去迭代。</p>

<p>下面是使用了内部迭代器，客户端不需要知道实现迭代的方式。</p>

<pre><code> NSArray *anArray = @[@"this", @"is", @"a", @"test"];
    NSString *string = @"a";
    [anArray enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
        NSLog(@"%@", obj);
        if ([obj isEqualToString:string]) {
            *stop = YES;
        }
    }];
</code></pre>

<p>客户端不需要手动实现迭代器，只要对每个元素进行处理就行。</p>

<h1>行为扩展</h1>

<h4>访问者（Visitor）</h4>

<pre><code>表示一个作用于某对象结构中的各元素的操作，它让我们可以在不改变各元素的类的前提下定义作用于这些元素的新操作。
</code></pre>

<p>当一个复杂的对象结构包含很多其他的对象，每个对象都有不同的接口，这个时候如果想添加新的接口进行新的操作，就得修改该对象的类，如果每个对象都需要添加新操作，就需要修改更多的类。而访问者模式就是用来不修改原有类添加新的操作。</p>

<p>访问者模式涉及两个关键元素，访问者和被访问对象。访问者遵从访问协议，访问协议里声明了访问方法。访问方法类似下面</p>

<pre><code>- (void)visitEngine:(NimoEngine *)engine;
- (void)visitWheel:(NimoWheel *)wheel;
</code></pre>

<p>访问者模式流程，直接调用访问者里的访问方法，访问方法里实现了新添加的操作，engine 与 wheel 既被访问对象，达到了将新操作集中在访问者里处理的效果。如果再需要新添加一系列对各个元素的操作，只需要再添加一个访问者类就行。</p>

<blockquote><p>访问者能访问复杂元素里的每一个元素，然后由访问者对这些元素进行行为扩展。</p>

<h4>装饰（Decorator）</h4></blockquote>

<pre><code>动态地给一个对象添加一些额外的职责。就扩展功能来说，装饰模式相比生成子类更为灵活。
</code></pre>

<p>Category 就是实现了装饰的设计模式。Category 是 Objective-C 的语言功能，通过它可以给类添加方法的接口与实现，而不必子类化。 从这个设计模式的描述联想到 Category，就没什么难理解了。
责任链（Chain of Responsibility）</p>

<pre><code>使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间发生耦合。此模式将这些对象连成一条链，并沿着这条链传递请求，直到有一个对象处理它为止。
</code></pre>

<p>Cocoa Touch 中的事件处理流程–响应者链就实现了责任链模式。以点击为例，首先通过 hit-test view 的流程找到被点击的视图，被点击的视图如果不处理点击事件，则沿着响应者链向上回溯，比如给父视图发消息，让父视图去处理，父视图不处理则继续沿着响应者链向上回溯，直到有对象处理它为止，如果都不处理，则该事件丢弃。</p>

<h1>算法封装</h1>

<h4>模板方法（Template Method）</h4>

<pre><code>定义一个操作中算法的骨架，而将一些步骤延迟到子类中。模板方法使子类可以重定义算法的某些特定步骤而不改变该算法的结构。
</code></pre>

<p>模板方法可以提高可扩展性与可复用性，比如 UIView 类中的定制绘图,UIView 的结构不改变，只是继承 UIView,再重载 – (void)drawRect:(CGRect)rect
方法。所以 – (void)drawRect:(CGRect)rect 就是模板方法，默认什么都不做或者只是做了部分操作，缺少特性操作，用来给子类选择重载与实现的方法。</p>

<h4>策略（Strategy）</h4>

<pre><code>定义一系列算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。
</code></pre>

<p>举一个常见的例子，验证 UITextField 输入是否有效。有两个算法分别是验证邮箱的和验证电话号码的。可以通过 if else 这样的判断代码来决定执行哪个算法。也可以通过策略模式，将算法封装起来，如下图
￼</p>

<p><img src="/images/iosshejimoshi010.png" title="Caption" ></p>

<p>Strategy 是这一系列算法的父类，ConcreteStrategyA, B, C。是三种算法，给 Context 对象添加一个 Strategy 类型的属性，里面存放着 ConcreteStrategyA 或者 B，C。然后 Context 对象就知道去执行哪个算法。也就知道自己需要执行什么策略。</p>

<blockquote><p>策略模式首先将算法都封装起来了，易于理解，且易于切换和扩展。</p>

<h4>命令（Command）</h4></blockquote>

<pre><code>将请求封装为一个对象，从而可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。
</code></pre>

<p>Cocoa Touch 框架中的 NSInvocation 就是实现了命令模式。</p>

<pre><code>NSMethodSignature*signature = [ViewController instanceMethodSignatureForSelector:@selector(sendMessageWithNumber:WithContent:)];
  //1、创建NSInvocation对象
  NSInvocation*invocation = [NSInvocation invocationWithMethodSignature:signature];
  invocation.target = self;
  //invocation中的方法必须和签名中的方法一致。
  invocation.selector = @selector(sendMessageWithNumber:WithContent:);
  /*第一个参数：需要给指定方法传递的值
         第一个参数需要接收一个指针，也就是传递值的时候需要传递地址*/
  //第二个参数：需要给指定方法的第几个参数传值
  NSString*number = @"1111";
  //注意：设置参数的索引时不能从0开始，因为0已经被self占用，1已经被_cmd占用
  [invocation setArgument:&amp;number atIndex:2];
  NSString*number2 = @"啊啊啊";
  [invocation setArgument:&amp;number2 atIndex:3];
  //2、调用NSInvocation对象的invoke方法
  //只要调用invocation的invoke方法，就代表需要执行NSInvocation对象中制定对象的指定方法，并且传递指定的参数
  [invocation invoke];
</code></pre>

<p>将行为封装成对象，而不是直接触发行为，因为是对象，所以可以很容易的设计一个命令队列，也可以方便的记录进日志里，以及实现行为的撤销。（因为行为对象可以记录进日志里，所以可以根据日志得知上一个操作做了什么，从而进行撤销）。</p>

<h1>性能与对象访问</h1>

<h2>享元（Flyweight）</h2>

<pre><code>利用共享技术有效地支持大量细粒度的对象。
</code></pre>

<p>tableViewCell 的重用机制就是实现了享元模式。在要使用一个 Cell 的时候，会先去重用池里看看 tableView 有没有可以重用的 cell，如果有重用该 cell，没有创建一个，这就是享元模式。</p>

<p>享元模式主要有两个关键组件，可共享的享元对象和保存它们的享元池。</p>

<blockquote><p>举另一个实现例子，画面上需要显示 100 个相同的图案，可以只生成一个包含该图案 image 的 imageView。其它 99 个只需要去享元池里去拿这个 imageView 实例的信息，然后在页面里直接绘制图案，这样就不需要生成 100 个图案实例。</p></blockquote>

<p>享元模式通过共享一部分必须的对象，减少对象的创建，节省大量的内存。</p>

<h4>代理（Proxy）</h4>

<pre><code>为其它对象提供一种代理以控制对这个对象的访问。
</code></pre>

<p>代理设计模式的英文名是 Proxy pattern，和我们常见的 delegate（委托） 没关系。</p>

<p>iOS 中常见的代理模式例子为引用计数，当一个复杂对象的多份副本须存在时，代理模式可以结合享元模式以减少内存用量。典型做法是创建一个复杂对象及多个代理者，每个代理者会引用到原本的复杂对象。而作用在代理者的运算会转送到原本对象。一旦所有的代理者都不存在时，复杂对象会被移除。</p>

<blockquote><p>当然，上面的代理模式中的代理者什么都没做，代理对象作为 A 和 C 中间的协调者，可以多做点操作，可以理解为 VPN 中的代理者可以对传输数据加密，而 A 和 C 中的代理者，也可以隐藏 C 的信息，做到对 C 的保护。</p></blockquote>

<h1>对象状态</h1>

<h4>备忘录（Memento）</h4>

<pre><code>在不破坏封装的情况下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可将该对象恢复到原先保存的状态。
</code></pre>

<p>Cocoa Touch 框架中归档可以实现备忘录模式，Cocoa 的归档是对对象及其属性还有同其他对象间的关系进行编码，形成一个文档，该文档可以保存于文件系统，也可在进程或网络间传输，最后又可以通过解档将文档解码成与该对象归档时状态一致的对象。</p>

<blockquote><p>既将对象保存一个备份放置到其它地方，可以随时使用备份将该对象恢复到原先保存的状态，用来储存关键对象的关键状态。</p></blockquote>

<h5>总结：（如果看了这么久您依然不知道上面在扯上面鬼，那么请结合ios开发中遇到的技术点简单粗略的体会一下下面的东西，再返回看看或许你就会明白很多）</h5>

<ul>
<li>备忘录-归档</li>
<li>代理-引用计数（非delegate）</li>
<li>享元-TableView重用机制</li>
<li>命令-NSInvocation</li>
<li>策略-文本有效</li>
<li>模板-drawRect</li>
<li>装饰-分类</li>
<li>责任链-响应者</li>
<li>迭代器-NSEnumerator</li>
<li>组合-UIView</li>
<li>观察者-通知、KVO</li>
<li>中介-导航</li>
<li>原型-.copy</li>
<li>工厂方法-initWithBool</li>
<li>抽象工厂-alloc]initWithXXX</li>
<li>单利-无处不在哈哈</li>
<li>适配器-网络请求接口</li>
</ul>


<hr />

<pre><code>Q Q：2211523682/790806573

微信：18370997821/13148454507

微博WB:http://weibo.com/u/3288975567?is_hot=1

git博文：http://al1020119.github.io/

github：https://github.com/al1020119
</code></pre>

<p><img src="/images/iCocosCoder.jpg" title="Caption" ></p>

<p><img src="/images/iCocosPublic.jpg" title="Caption" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[修行篇-23种设计模式]]></title>
    <link href="http://al1020119.github.io/blog/2016/08/23/xiu-xing-pian-23chong-she-ji-mo-shi/"/>
    <updated>2016-08-23T12:32:39+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/08/23/xiu-xing-pian-23chong-she-ji-mo-shi</id>
    <content type="html"><![CDATA[<h2>设计模式</h2>

<p>总体来说设计模式分为三大类：</p>

<ul>
<li><p>创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</p></li>
<li><p>结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</p></li>
<li><p>行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p>

<ul>
<li>其实还有两类：并发型模式和线程池模式。</li>
</ul>
</li>
</ul>


<!--more-->


<h2>创建型模式</h2>

<h3>工厂方法模式</h3>

<p>简单工厂模式的最大优点在于工厂类中包含了必要的逻辑判断，根据客户端输入的选择条件动态的实例化相关的类，对于客户端来说，去除了与具体产品的依赖。</p>

<p>但是简单工厂方法违背了开放——封闭模式。</p>

<h6>1、思想</h6>

<pre><code>工厂方法模式：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。
</code></pre>

<h6>2、核心思想</h6>

<pre><code> 核心工厂类不再负责所有产品的创建，而是将具体创建的工作交给了子类去做，成为一个抽象工厂角色，仅仅负责具体工厂类必须实现的接口，而不接触哪一个产品类应当被实例化的细节。
</code></pre>

<h6>3、优缺点分析</h6>

<p>GOOD：修正了简单工厂模式中不遵守开放－封闭原则。工厂方法模式把选择判断移到了客户端去实现，如果想添加新功能就不用修改原来的类，直接修改客户端即可，从而保持了封装对象创建过程的优点。使得更换对象时，不需要做大的改动就可以实现，降低了客户程序与产品对象的耦合。</p>

<p>BAD：每增加一个产品，就需要增加一个产品工厂类，即增加了额外的开发量</p>

<h3>抽象工厂模式</h3>

<h6>一、思想</h6>

<pre><code> 定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory使一个类的实例化延迟到其子类。（四人团）

实际上： 工厂模式主要就是用于创建对象。新添加类时，不会影响以前的系统代码。
</code></pre>

<h6>二、基本思想</h6>

<p>   核心思想：是用一个工厂来根据输入的条件产生不同的类，然后根据不同类的virtual函数得到不同的结果。</p>

<pre><code> 客户类和工厂类分开，消费者任何时候需要某种产品类对象，只需要向工厂类（有静态成员函数接收）提交参数和请求即可。消费者无需修改（直接用所有产品共同的父类指针指向）就可以接纳和使用新产品类的对象。
</code></pre>

<h6>三、优缺点分析</h6>

<p>GOOD: 适用于不同情况创建不同的类时</p>

<p>BAD：  客户端必须要知道基类和工厂类，耦合性差，而且当产品修改时，工厂类也要做相应修改（如：如何创建及如何向客户端提供）</p>

<h3>单例模式</h3>

<h6>1、思想</h6>

<pre><code>保证一个类仅有一个实例，并提供一个访问它的全局访问点
</code></pre>

<h6>2、核心思想</h6>

<p>确保某个类只有一个实例（类的静态成员变量），而且自行实例化并向整个系统提供这个实例单例模式。</p>

<p>直接将类的构造方法改成私有的（所有类都有构造方法，不编码则系统默认生成空的构造方法，若有显示定义的构造方法，默认的构造方法就会失效），然后在一个public的实例化函数中调用私有构造函数，完成仅有的一次实例化。</p>

<h6>3、优缺点分析</h6>

<p>GOOD:单例模式只应在有真正的“单一实例”的需求时才可使用。</p>

<p>单例模式因为Singleton类封装它的唯一实例，这样它可以严格地控制客户怎样访问它以及何时访问它，简单的说就是对唯一实例的受控访问。</p>

<h3>建造者模式</h3>

<h6>1、思想</h6>

<pre><code>建造者模式：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示
</code></pre>

<h6>2、核心思想</h6>

<pre><code> 将产品的内部表象和产品的生成过程分割开来，从而使一个建造过程生成具有不同的内部表象的产品对象。建造模式使得产品内部表象可以独立的变化，客户不必知道产品内部组成的细节。
</code></pre>

<p>即用户就只需要指定需要建造的类型就可以得到产品，而具体的建造过程和细节就不需要知道了。</p>

<p>建造模式可以强制实行一种分步骤进行的建造过程。</p>

<h6>3、优缺点分析</h6>

<p>GOOD：使得建造代码与表示代码分离，由于建造者隐藏了该产品是如何组装的，所以若需要改变一个产品的内部表示，只需要再定义一个具体的建造者就可以了。</p>

<h6>适用于：</h6>

<p>（1）在当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时适用。</p>

<p>就是说：主要用于创建一些复杂的对象，这些对象内部的构建顺序通常是稳定的，但是对象内部的具体各个构建方法通常面临着复杂的变化。</p>

<p>（2）当构造过程必须允许被构造的对象有不同的表示时。</p>

<h3>原型模式</h3>

<h6>1、思想</h6>

<pre><code>原型模式：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。
</code></pre>

<h6>2、核心思想</h6>

<pre><code> 通过给出一个原型对象来指明所要创建的对象的类型，然后用复制这个原型对象的方法创建出更多同类型的对象。原型模式允许动态的增加或减少产品类，产品类不需要非得有任何事先确定的等级结构。
</code></pre>

<h6>3、优缺点分析</h6>

<p>GOOD：</p>

<p>从一个对象再创建另外一个可定制的对象，而无需知道任何创建的细节。并能提高创建的性能。 说白了就COPY技术，把一个对象完整的COPY出一份。</p>

<p>一般在初始化的信息不发生变化的情况下，克隆是最好的办法。这既隐藏了对象创建的细节，又对性能是大大的提高。
BAD：</p>

<p>缺点是每一个类都必须配备一个复制方法。
必须注意：</p>

<p>浅复制和深复制的问题：如果字段是基本数据类型的，则用拷贝构造函数即可进行逐位复制，但如果字段是指针或引用类型的，则复制就不仅仅要复制指针和引用本身，还需要对其所指的实际数据对象进行复制。</p>

<h2>结构型模式</h2>

<h3>适配器模式</h3>

<h6>1、思想</h6>

<pre><code>把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不兼容而无法一起工作的两个类能够一起工作。
</code></pre>

<h6>2、优缺点分析</h6>

<p>适用情况：当系统的数据和行为都正确，但接口不符时，我们应该考虑使用适配器，目的是使控制范围之外的一个原有对象与某个接口匹配。适配器模式主要应用于希望复用一些现存的类，但是接口又与复用环境要求不一致的情况。
装饰器模式</p>

<h3>装饰模式</h3>

<h6>1、思想</h6>

<pre><code>装饰模式：动态的给一个对象添加一些额外的职责（不重要的功能，只是偶然一次要执行）。就增加功能来说，Decorator模式比使用继承生成子类更为灵活。

 建造过程不稳定，需要把所需的功能按正确的顺序串联起来进行控制。
</code></pre>

<h6>2、优缺点分析</h6>

<p>GOOD:当你向旧的类中添加新代码时，一般是为了添加核心职责或主要行为。而当需要加入的仅仅是一些特定情况下才会执行的特定的功能时（简单点就是不是核心应用的功能），就会增加类的复杂度。</p>

<pre><code>装饰模式就是把要添加的附加功能分别放在单独的类中，并让这个类包含它要装饰的对象，

当需要执行时，客户端就可以有选择地、按顺序地使用装饰功能包装对象。
</code></pre>

<h3>代理模式</h3>

<h6>一、思想</h6>

<pre><code>代理模式：为其他对象提供一种代理以控制对这个对象的访问
</code></pre>

<h6>二、基本思想</h6>

<pre><code> 代理模式实际就是在访问对象时引入一定程度的间接性，因为这种间接性，可以附加多种用途。
</code></pre>

<h6>三、优缺点分析</h6>

<p>GOOD：（适用场合）</p>

<p>远程代理：也就是为一个对象在不同的地址空间提供局部代表，这样可以隐藏一个对象在不同地址空间的事实。</p>

<pre><code>              例如：客户端程序调用代理就可以解决远程访问的问题
</code></pre>

<p>虚拟代理：是根据需要创建开销很大的对象，通过代理来存放实例化需要很长时间的真实对象，从而达到性能的最优化（例如浏览器使用代理模式来优化下载）。</p>

<pre><code>              例如：打开大网页时，未马上打开的图片就是通过虚拟代理来替代了真实的图片，而代理存储了真实图片的路径和尺寸。
</code></pre>

<p>安全代理：用来控制真实对象的访问权限</p>

<p>智能引用：当调用真实对象时，代理处理另外一些事</p>

<h3>外观模式</h3>

<h6>1、思想</h6>

<pre><code>外观模式：为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。
</code></pre>

<h6>2、核心思想</h6>

<pre><code> 外部与一个子系统的通信必须通过一个统一的外观对象进行。外观模式提供一个高层次的接口，使得子系统更易于使用。每一个子系统只有一个外观类，而且此外观类只有一个实例，也就是还说它是一个单例模式。但整个系统可以有多个外观类。
</code></pre>

<h6>3、优缺点分析</h6>

<p>GOOD：</p>

<p>为子系统的一组接口提供一个一致的界面。使用户使用起来更加方便。</p>

<pre><code>完美体现了依赖倒转原则和迪米特原则
</code></pre>

<p>适用情况：</p>

<pre><code>分三个阶段：

1、首先，在设计初期阶段，应该有意识的将不同的两个层分离，即在层与层之间建立外观Facade

2、其次，在开发阶段，子系统往往因为不断的重构演化，而变得越来越复杂，增加外观Facade可以提供一个简单的接口，减少它们之间的依赖。

3、在维护一个遗留的大型系统时，可能这个系统已经非常难以维护和扩展了，就可以为新系统开发一个外观Facade类，来提供设计粗糙或高度复杂的遗留代码的比较清晰简单的接口，让新系统与Facade对象交互，Facade与遗留代码交互所有复杂的工作。
</code></pre>

<h3>桥接模式</h3>

<h6>1、合成聚合原则</h6>

<p>缘由：对象的继承关系是在编译时就定义好了，所以无法在运行时改变从父类继承的实现。子类的实现与它的父类有非常紧密的依赖关系，以至于父类实现中的任何变化必然会导致子类发生变化。当你需要复用子类时，如果继承下来的实现不适合解决新的问题，则父类必须重写或被其他更适合的类替换。这种依赖关系限制了灵活性并最终限制了复用性。</p>

<p>原则：</p>

<pre><code>合成/聚合原则(CARP)：尽量使用合成/聚合，尽量不要使用类继承
</code></pre>

<ul>
<li><p>聚合：一种弱的’拥有’关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分</p></li>
<li><p>合成：一种强的’拥有’关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样。</p></li>
</ul>


<h6>合成聚合的好处：</h6>

<p>优先使用对象的合成/聚合将有助于你保持每个类被封装，并被集中在单个任务上，这样类和类继承层次会保持较小规模，并且不太可能增长为不可控制的庞然大物。</p>

<h6>2、桥模式思想</h6>

<pre><code>桥接模式(Bridge)：将抽象部分与它的实现部分分离，使它们都可以独立地变化
</code></pre>

<p>抽象与实现分离：指的是抽象类和它的派生类用来实现自己的对象</p>

<h6>3、核心思想</h6>

<p>桥模式就是将抽象化与实现化脱耦，使得二者可以独立的变化，也就是说将他们之间的强关联变成弱关联，也就是指在一个软件系统的抽象化与实现化之间使用组合/聚合关系而不是继承关系，从而让二者独立的变化。</p>

<h6>4、优缺点分析</h6>

<p>GOOD：</p>

<pre><code>将抽象部分与实现部分分离，使它们可以独立变化。

这里说的意思不是让抽象基类与具体类分离，而是现实系统可能有多角度分类，每一种分类都有可能变化，那么把这种多角度分离出来让它们独立变化，减少它们之间的耦合性，即如果继承不能实现“开放－封闭原则”的话，就应该考虑用桥接模式 
</code></pre>

<h3>组合模式</h3>

<h6>1、思想</h6>

<pre><code>组合模式：将对象组合成树形结构以表示“部分——整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性
</code></pre>

<h6>2、优缺点分析</h6>

<p>GOOD：</p>

<pre><code>整体和部分可以被一致对待（如WORD中复制一个文字、一段文字、一篇文章都是一样的操作）

用户不用关心到底是处理一个叶结点还是处理一个组合组件，也就不用为定义组合而写一些选择判断语句，即用户可以一致的使用组合结构和单个对象。
</code></pre>

<h6>适用情况：</h6>

<p>当需求中是体现部分与整体层次的结构时，以及希望用户可以忽略组合对象与单个对象的不同，统一地使用组合结构中的所有对象时，就应该考虑用组合模式</p>

<h3>享元模式。</h3>

<h6>1、思想</h6>

<pre><code>享元模式：运用共享技术有效地支持大量细粒度的对象
</code></pre>

<h6>2、核心思想</h6>

<pre><code>  享元模式以共享的方式高效的支持大量的细粒度对象。享元模式能做到共享的关键是区分内蕴状态和外蕴状态。

 内蕴状态存储在享元内部，不会随环境的改变而有所不同。外蕴状态是随环境的改变而改变的。外蕴状态不能影响内蕴状态，它们是相互独立的。

  将可以共享的状态和不可以共享的状态从常规类中区分开来，将不可以共享的状态从类里剔除出去。

  客户端不可以直接创建被共享的对象，而应当使用一个工厂对象负责创建被共享的对象。享元模式大幅度的降低内存中对象的数量。
</code></pre>

<h6>3、优缺点分析</h6>

<p>GOOD：</p>

<pre><code>（1）运用共享技术有效地支持大量细粒度的对象（对于C++来说就是共用一个内存块啦，对象指针指向同一个地方）。

（2）如果一个应用程序使用了大量的对象，而这些对象造成了很大的存储开销就应该考虑使用。

（3）还有就是对象的大多数状态可以外部状态，如果删除对象的外部状态，那么可以用较少的共享对象取代多组对象，此时可以考虑使用享元。 
</code></pre>

<h2>行为型模式</h2>

<h3>策略模式</h3>

<h6>一、思想</h6>

<pre><code> 定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换，本模式使得算法可独立于使用它的客户而变化——四人团
</code></pre>

<h6>二、基本思想</h6>

<pre><code>定义算法家族，分别封装起来，让它们之间可以互相替换，让算法的变化，不会影响到使用算法的用户。
</code></pre>

<h6>三、优缺点分析</h6>

<p>GOOD:</p>

<p>（1）策略模式是一种定义一系列算法的方法，从概念上看，所有这些算法完成的都是相同的工作，只是实现不同。</p>

<pre><code>   所以使用策略模式，就可以以相同的方式调用所有的算法，减少了各种算法类与使用算法类之间的耦合。
</code></pre>

<p>（2）策略模式的Strategy类层次为Context定义了一系列的可供重用的算法或行为。继承有助于析取出这些算法中的公共功能</p>

<p>（3）简化了单元测试（因为每个算法都有自己的类，可以通过自己的接口单独测试）</p>

<p>BUG:客户端要做出判断使用哪个具体算法（可通过在context中与工厂模式的结合来消除这个问题，虽然当新增加需求时，还是要改context中的代码，但是任何需求的变更本身就是需要成本的）
四、适用情况</p>

<pre><code> 策略模式和简单工厂基本相同，但简单工厂模式只能解决对象创建问题，对于类中的成员以方法为主，而且算法经常变动的类，应使用策略模式。

 在实践中，策略模式实际上可以封装几乎任何类型的规则，只要在分析过程中听到需要不同时间应用不同的业务规则，就可以考虑使用策略模式处理这种变化的可能性。
</code></pre>

<h3>模板方法模式</h3>

<h6>1、思想</h6>

<pre><code>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。template method使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤
</code></pre>

<h6>2、核心思想</h6>

<pre><code> 模板方法模式准备一个抽象类，将部分逻辑以具体方法以及具体构造子类的形式实现，然后声明一些抽象方法来迫使子类剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。先制定一个顶级逻辑框架，而将逻辑的细节留给具体的子类去实现。

 当要完成在某一细节层次一致的一个过程或一系列步骤，但其个别步骤在更详细的层次上的实现可能不同时，通常考虑用模板方法来处理。也就是说：有时候，我们遇到由一系列步骤构成的过程需要执行。这个过程从高层次上看是相同的，但从底层看有些具体步骤实现又可能不同，这时候，就要考虑使用模板方法模式。
</code></pre>

<h6>3、优缺点分析</h6>

<p>GOOD：</p>

<pre><code>把不变的代码部分都转移到父类中，将可变的代码用virtual留到子类重写，从而提供了一个很好的代码复用平台。
</code></pre>

<p>即当不变的和可变的行为在方法的子类实现中混合在一起的时候，不变的行为就会在子类中重复出现。我们就可以通过模板方法模式把这些行为搬移到单一的地方，这样就帮助子类摆脱重复的不变行为的纠缠。</p>

<h3>观察者模式</h3>

<h6>1、思想</h6>

<pre><code>定义对象间的一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生改变时，会通知所有观察者对象，使它们能够自动更新自己。
</code></pre>

<h6>2、核心思想</h6>

<pre><code> 观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使他们能够自动更新自己。
</code></pre>

<h6>使用动机：</h6>

<p>　　将一个系统分割成一系列相互协作的类有一个很不好的副作用，那就是需要维护相关对象间的一致性。我们不希望为了维持一致性而使各类紧密耦合，这样会给维护、扩展和重用都带来不便。</p>

<h6>本模式适用情况：</h6>

<p>（1）当一个对象的改变需要同时改变其他对象的时候，而且它不知道具体有多少对象有待改变时，应该考虑使用观察者模式。</p>

<p>（2）当一个抽象模型有两个方面，其中一方面依赖于另一方面，这时用观察者模式可以将这两者封装在独立的对象中，使它们各自独立地改变和复用。
总结：</p>

<pre><code>观察者模式所做的工作其实就是解除耦合，让耦合的双方都依赖于抽象，而不是依赖于具体。从而使得各自的变化都不会影响另一边的变化。

本模式是依赖倒置原则的最佳体现！

设计原则：为了交互对象之间的松耦合设计而奋斗到底！
</code></pre>

<h6>3、优缺点分析</h6>

<p>GOOD：</p>

<pre><code>定义了一种一对多的关系，让多个观察对象（公司员工）同时监听一个主题对象（秘书），主题对象状态发生变化时，会通知所有的观察者，使它们能够更新自己。
</code></pre>

<p>BAD:</p>

<pre><code>尽管使用了“依赖倒置原则”，但是“抽象通知者”还是依赖于“抽象观察者”。而且每个具体观察者不一定是“更新”方法需要调用。

在.net中可通过事件委托方法，使得通知者和观察者之间根本就互相不知道。  
</code></pre>

<h3>迭代子模式</h3>

<h6>1、思想</h6>

<pre><code>迭代器模式：提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。
</code></pre>

<h6>2、核心思想</h6>

<h6>3、优缺点分析</h6>

<p>适用情况：</p>

<p>（1）当需要访问一个聚集对象，而且不管这些对象是什么都需要遍历的时候，就应该考虑使用迭代器模式</p>

<p>（2）当需要对聚集有多种方式遍历时，可以考虑使用迭代器模式</p>

<p>GOOD：</p>

<pre><code>提供一种方法顺序访问一个聚敛对象的各个元素，而又不暴露该对象的内部表示。

为遍历不同的聚集结构提供如开始，下一个，是否结束，当前一项等统一接口。 
</code></pre>

<h3>责任链模式</h3>

<h6>1、思想</h6>

<pre><code>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系，将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。
</code></pre>

<h6>2、核心思想</h6>

<p>在责任链模式中，很多对象由每一个对象对其下家的引用而接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。客户并不知道链上具体的哪一个对象最终处理了这个请求，系统可以在不影响客户端的情况下，动态的重新组织链和分配责任。处理者有两个选择：承担责任或者把责任推给下家。一个请求可以最终不被任何接收端对象所接受。</p>

<h6>3、优缺点分析</h6>

<p>关键点：当客户提交一个请求时，请求是沿链传递直至有一个ConcreteHandler对象负责处理它。</p>

<p>GOOD：</p>

<pre><code>（1）这就使得接受者和发送者之间都没有对方明确的信息，且链中的对象自己也并不知道整个链的结构。结果是职责链可简化对象的相互连接，它们仅需保持一个指向其后继者的引用，而不需要保持它所有的候选接受者的引用。

（2）可以随时地增加或修改一个请求的结构，增强了给对象指派职责的灵活性

（3）一个请求极有可能到了链的末端都得不到处理，或者因为没有正确配置而得不到处理
</code></pre>

<h3>命令模式</h3>

<h6>1、思想</h6>

<pre><code>命令模式：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作
</code></pre>

<h6>2、核心思想</h6>

<p>命令模式：把一个请求或者操作封装到一个对象中，命令模式把发出命令的责任和执行命令的责任分割开来，委派给不同的对象。命令模式允许请求的一方和发送的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否执行，何时被执行以及是怎么被执行的。</p>

<h6>3、优缺点分析</h6>

<p>GOOD：</p>

<pre><code>一、能较容易地建立一个命令队列；

二、在需要的情况下，可以较容易地将命令记入日志；

三、允许接收请求的一方是否拒绝请求；

四、可以容易地实现对请求的撤销和重做，

五、由于加进新的具体命令类不影响其他的类，因此添加一个新命令类不影响其它类；
</code></pre>

<p>最关键的优点：命令模式把请求一个操作的对象与知道怎么操行一个操作的对象分开</p>

<p>适用原则：敏捷开发原则告诉我们，不要为代码添加基于猜测的、实际不需要的功能。如果不清楚一个系统是否需要命令模式，一般不要着急去实现它，事实上、在需要的时候通过重构实现这个模式并不困难，只有在真正需要如撤销、恢复等操作功能时，才把原有的代码重构为命令模式才有意义。</p>

<h3>备忘录模式</h3>

<h6>1、思想</h6>

<pre><code>在不破坏封装的条件下，将一个对象的状态捉住，并在该对象外部保存这个状态，从而可以在将来合适的时候把这个对象还原到存储起来的状态。
</code></pre>

<h6>2、核心思想</h6>

<pre><code> 备忘录对象是一个用来存储另外一个对象内部状态的快照的对象。
</code></pre>

<h6>3、优缺点分析</h6>

<p>适用于功能比较复杂的，但需要记录或维护属性历史的类；或者需要保存的属性只是众多属性中的一小部分时Originator可以根据保存的Memo还原到前一状态。</p>

<h3>状态模式</h3>

<h6>1、思想</h6>

<pre><code>状态模式：当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。
</code></pre>

<h6>2、核心思想</h6>

<pre><code> 状态模式允许一个对象在其内部状态改变的时候改变行为。这个对象看上去像是改变了它的类一样。状态模式把所研究的对象的行为包装在不同的状态对象里，每一个状态对象都属于一个抽象状态类的一个子类。状态模式的思想是让一个对象在其内部状态改变的时候，其行为也随之改变。状态模式需要对每一个系统可能取得的状态创立一个状态类的子类。当系统的状态变化时，系统便改变所选的子类。

 状态模式主要解决的是当控制一个对象状态转换的条件表达式过于复杂时的情况。把状态的判断逻辑转移到表示不同状态的一系列类当中，可以把复杂的判断逻辑简化。
</code></pre>

<h6>3、优缺点分析</h6>

<ul>
<li><p>优点：</p>

<ul>
<li><p>状态模式的好处是将与特定状态相关的行为局部化，并且将不同状态的行为分割开来。</p>

<pre><code>  即：将特定的状态相关的行为都放入一个对象中，由于所有与状态相关的代码都存在于某个ConcreteState中，所以通过定义新的子类可以很容易地增加新的状态和转换。
</code></pre></li>
<li><p>消除了庞大的条件分支语句，并且通过把各种状态转移逻辑分布到State的子类之间，来减少相互间的依赖。
适用情况：</p></li>
<li><p>当一个对象的行为取决于它的状态，并且它必须在运行时刻根据状态改变它的行为时，可考虑用到状态模式。</p></li>
</ul>
</li>
</ul>


<h3>中介者模式</h3>

<h6>1、思想</h6>

<pre><code>中介者模式：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互
</code></pre>

<h6>2、核心思想</h6>

<p>包装了一系列对象相互作用的方式，使得这些对象不必相互明显作用。从而使他们可以松散耦合。当某些对象之间的作用发生改变时，不会立即影响其他的一些对象之间的作用。保证这些作用可以彼此独立的变化。调停者模式将多对多的相互作用转化为一对多的相互作用。调停者模式将对象的行为和协作抽象化，把对象在小尺度的行为上与其他对象的相互作用分开处理。</p>

<h6>3、优缺点分析</h6>

<p>中介者模式很容易在系统中应用，也很容易在系统中误用。当系统中出现了’多对多’交互复杂的对象群时，不要急于使用中介者模式，而要反思你的系统在设计上是不是合理。</p>

<p>GOOD:</p>

<p>（1）Mediator的出现减少了各个Colleague的耦合，使得可以独立地改变和复用各个Colleague类和Mediator</p>

<p>（2）由于把对象如何协作进行了抽象，将中介作为一个独立的概念并将其封装在一个对象中，这样关注的对象就从对象各自本身的行为转移到了它们之间的交互上来，也就是站在一个更宏观的角度去看待系统。</p>

<p>BAD:</p>

<p>由于ConcreteMediator控制了集中化，于是就把交互复杂性变为了中介者的复杂性，这就使得中介者会变得比任何一个ConcreteColleague都复杂。</p>

<h6>适用场合：</h6>

<p>中介者模式一般应用于一组对象以定义良好但是复杂的方式进行通信的场合，以及想定义一个分布在多个类中的行为，而又不想生成太多的子类的场合。</p>

<h3>解释器模式</h3>

<h6>思想</h6>

<pre><code>Interpreter是一种特殊的设计模式，它建立一个解释器，对于特定的计算机程序设计语言，用来解释预先定义的文法。简单地说，Interpreter模式是一种简单的语法解释器构架。

给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。
</code></pre>

<h6>适用场景：</h6>

<pre><code>    1.当有一个语言需要解释执行，并且你可将该语言中的句子表示为一个抽象语法树，可以使用解释器模式。而当存在以下情况时该模式效果最好

    2.该文法的类层次结构变得庞大而无法管理。此时语法分析程序生成器这样的工具是最好的选择。他们无需构建抽象语法树即可解释表达式，这样可以节省空间而且还可能节省时间。

    3.效率不是一个关键问题，最高效的解释器通常不是通过直接解释语法分析树实现的，而是首先将他们装换成另一种形式，例如，正则表达式通常被装换成状态机，即使在这种情况下，转换器仍可用解释器模式实现，该模式仍是有用的
</code></pre>

<h6>优缺点：</h6>

<ul>
<li><p>优点： 1、可扩展性比较好，灵活。 2、增加了新的解释表达式的方式。 3、易于实现简单文法。</p></li>
<li><p>缺点： 1、可利用场景比较少。 2、对于复杂的文法比较难维护。 3、解释器模式会引起类膨胀。 4、解释器模式采用递归调用方法。</p></li>
</ul>


<h3>访问者模式</h3>

<h6>思想：</h6>

<pre><code>封装某些作用于某种数据结构中各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。
</code></pre>

<h6>优点</h6>

<pre><code>符合单一职责原则：凡是适用访问者模式的场景中，元素类中需要封装在访问者中的操作必定是与元素类本身关系不大且是易变的操作，使用访问者模式一方面符合单一职责原则，另一方面，因为被封装的操作通常来说都是易变的，所以当发生变化时，就可以在不改变元素类本身的前提下，实现对变化部分的扩展。
扩展性良好：元素类可以通过接受不同的访问者来实现对不同操作的扩展。
</code></pre>

<h6>访问者模式的适用场景</h6>

<pre><code>   假如一个对象中存在着一些与本对象不相干（或者关系较弱）的操作，为了避免这些操作污染这个对象，则可以使用访问者模式来把这些操作封装到访问者中去。

   假如一组对象中，存在着相似的操作，为了避免出现大量重复的代码，也可以将这些重复的操作封装到访问者中去。
</code></pre>

<hr />

<h4>其他：</h4>

<h3>单一职责原则</h3>

<pre><code>就一个类而言，应该仅有一个引起它变化的原因。
</code></pre>

<p>　　如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其它职责能力。这种耦合会导制脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏。</p>

<pre><code>软件设计真正要做的许多内容，就是发现职责并把那些职责相互分离。

如果你能够想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责。
</code></pre>

<h3>开放——封闭原则</h3>

<h6>一、基本概念</h6>

<pre><code>  OCP: 软件实体（类、模块、函数等）应该可以扩展，但是不可修改。

 解释：即对于扩展是开放的，对于修改是封闭的。
</code></pre>

<h6>二、实际技巧</h6>

<pre><code> 实际上，无论模式多么的‘封闭’，都会存在一些无法对之封闭的变化，既然不可能完全封闭，设计人员必须对于他设计的模块应该对哪种变化封闭做出选择。他必须先猜测出最有可能发生的变化种类，然后构造抽象来隔离那些变化。

 即：当变化发生时，我们就创建抽象来隔离以后发生同类的变化。（等到变化发生时立即采取行动）    

 面对需求，对程序的改动是通过增加代码来完成的，而不是改动现有的代码。（例如简单工厂模式思想）
</code></pre>

<h6>三、优点</h6>

<pre><code> 开放――封闭原则是面向对象的核心所在。这个原则所带来的优点就是可维护、可扩展、可复用、灵活型好。

 开发人员应该对程序中呈现出频繁变化的那部分做出抽象，拒绝对任何部分都刻意抽象及不成熟的抽象。
</code></pre>

<h3>里氏代换原则</h3>

<h6>一、基本概念</h6>

<pre><code>  抽象不应该依赖细节，细节应该依赖抽象。即针对接口编程，不要对实现编程。

A：高层模块不能依赖低层模块，两者都应依赖抽象。

B：抽象不应该依赖细节，细节应该依赖抽象。 
</code></pre>

<h6>二、里氏代换原则（LSP）</h6>

<pre><code>子类型必须能够替换掉它们的父类型
</code></pre>

<p>解释：一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且它察觉不出父类对象和子类对象的区别。</p>

<pre><code>   也就是说，在软件里面，把父类都替换成它的子类，程序的行为没有变化。

   只有当子类可以替换父类，软件单位的功能不受到影响时，父类才真正被复用，而子类也能够在父类的基础上增加新的行为。

   所以，正是由于子类型的可替换性才使得使用父类类型的模块在无需修改的情况下就可以扩展。
</code></pre>

<h3>最少知识原则</h3>

<h6>一、基本概念</h6>

<pre><code>迪米特法则：如果两个类不直接通信，那么这两个类就不应当发生直接的相互作用。如果一个类需要调用另一个类的某个方法的话，可以通过第三个类转发这个调用。
</code></pre>

<h6>二、核心思想</h6>

<pre><code> 在类的结构设计上，每一个类都应该尽量降低成员的访问权限。也就是说：一个类包装好自己的private状态，不需要让别的类知道的字段或行为就不要公开。

迪米特原则的根本思想：强调了类之间的松耦合。     

 类之间的耦合越弱，越有利于复用，一个处在弱耦合的类被修改，不会对有关系的类造成波及。

  该法则在后面的适配器模式、解释模式等中有强烈的体现。    
</code></pre>

<hr />

<hr />

<h2>总结：</h2>

<ul>
<li><p>1、当涉及到“维护”时，为了“复用”目的而使用继承，并不是最好的方法。</p></li>
<li><p>2、利用继承来提供对象的行为，会导致以下缺点：</p>

<ul>
<li><p>1）代码在多个子类中重复；</p></li>
<li><p>2）运行时的行为不容易改变；</p></li>
<li><p>3）很难知道所有子类的全部行为；</p></li>
<li><p>4）改变父类会牵一发而动全身，造成其他子类不想要的改变；</p></li>
</ul>
</li>
<li><p>3、使用接口（JAVA）或虚基类加多重继承（C++）方法，则会需要对需要维护的代码中的每个子类都分别考虑其特有方法的继承来源。</p></li>
<li><p>4、设计原则：找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。即：把会变化的部分取出并“封装”起来，以便以后可以轻易的改动或扩充此部分，而不影响不需要变化的部分。</p></li>
<li><p>5、设计原则：针对接口编程，而不是针对实现编程。</p></li>
</ul>


<p>将对象的行为放在分开的类中，此类专门提供某行为接口的实现，并且在对象类中包含可设定行为的方法，使得程序可在“运行时”动态的改变特定对象的行为。</p>

<ul>
<li>6、封装行为的大局观</li>
</ul>


<p>设计原则：多用组合，少用继承</p>

<ul>
<li><p>7、策略模型：定义了算法族，分别封装起来，让它们之间可以相互替换，此模式让算法的变化独立于使用算法的客户。</p></li>
<li><p>8、设计模式的名词使用主要为了程序员间交流方便</p></li>
</ul>


<hr />

<pre><code>Q Q：2211523682/790806573

微信：18370997821/13148454507

微博WB:http://weibo.com/u/3288975567?is_hot=1

git博文：http://al1020119.github.io/

github：https://github.com/al1020119
</code></pre>

<p><img src="/images/iCocosCoder.jpg" title="Caption" ></p>

<p><img src="/images/iCocosPublic.jpg" title="Caption" ></p>
]]></content>
  </entry>
  
</feed>
