<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 程序员必备 | iOS梦工厂]]></title>
  <link href="http://al1020119.github.io/blog/categories/cheng-xu-yuan-bi-bei/atom.xml" rel="self"/>
  <link href="http://al1020119.github.io/"/>
  <updated>2015-12-08T01:10:55+08:00</updated>
  <id>http://al1020119.github.io/</id>
  <author>
    <name><![CDATA[iCocos]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[爬虫必备-java抓包]]></title>
    <link href="http://al1020119.github.io/blog/2015/12/11/java/"/>
    <updated>2015-12-11T12:03:23+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/12/11/java</id>
    <content type="html"><![CDATA[<p>前面我们介绍了怎么使用青花瓷和正则表达式抓包，今天就来介绍一下最后一篇：使用java抓包</p>

<p>java是大家再熟悉不过了，所以不用太担心有多难，因为里面涉及的java技术几乎为0（有点夸张），所以想想看完这篇之后你就会知道怎么使用java快速抓包，还能根据自己的喜好选择对应的方式！</p>

<p>我们开始吧！</p>

<p>前提：熟悉java语法（能看懂就行）</p>

<ul>
<li>准备阶段：从网页中获取html代码</li>
<li>实战阶段：将对应的html代码使用java语言解析出来，最后保存到plist文件</li>
</ul>


<!--more-->


<h2>一:准备阶段－－》获取html代码</h2>

<h6>1:打开你对应想要获取数据的网页，使用firefox打开（因为他有一个自带的神器叫：firebug，关于firebug这里就多说了，反正对于网页开发来说她就是神器），这里我们使用的是dota首页英雄的介绍。</h6>

<p>首先来看看我们需要的数据</p>

<p><img src="/images/ava001.png" title="Caption" ></p>

<h6>2:由于在网页开发中也是分模块开发的，所以一定的区域在html中对应对应的html代码模块，所以我们选取界面中一个小的模块作为练习。</h6>

<p>找到对应的模块，点击右键在firebug中查看元素</p>

<p><img src="/images/ava002.png" title="Caption" ></p>

<p>（确保已安装firebug，没有安装的去火狐工具栏中工具标签里面的一个附加组件搜索并下载安装就可以）</p>

<p>这个时候网页的下面就会显示对应模块的html代码，我们需要找到我们想要获取的数据对应的html模块代码，点击右键拷贝我们需要的html。</p>

<p> <img src="/images/ava003.png" title="Caption" ></p>

<h6>3:在界面简一个html文件将拷贝好的html代码粘贴到文件中，然后就需要哪么一丢丢的html相关知识了，就是补充html中的数据，使他成为完整的html文件</h6>

<p><img src="/images/ava004.png" title="Caption" ></p>

<p>这里注意一下编码方式：开发中常用的都是utf－8的格式</p>

<h2>二:实战阶段－－》抓取html（网页数据）</h2>

<p>然后我们就要正式开工了，后面才是重点，前面那都是傻瓜是的操作（后面的才做中需要有那么一丢丢的java或者android开发的基础，当然不会耶没有关系，笔者会完整的介绍流程）</p>

<h6>1:代开Eclipse</h6>

<p><img src="/images/ava005.png" title="Caption" ></p>

<p>新建一个java项目，并且点击项目中的src新建一个class专门用来实现数据的解析</p>

<p><img src="/images/ava006.png" title="Caption" ></p>

<h6>2:新建好项目之后就要用到我们的一个java的jar包，专门用来抓取网络数据的包：关于包的下载后面笔者会给出下载链接</h6>

<p><img src="/images/ava007.png" title="Caption" ></p>

<p>将下载好的jar包导入到java工程项目中。</p>

<p>然后我们需要将他添加到build路径（这里是一个常识，java中的jar包没有添加到build路径是不能使用的，添加之后对应的咖啡图标会变成奶瓶）</p>

<p><img src="/images/ava008.png" title="Caption" ></p>

<p>成功之后的显示</p>

<p><img src="/images/ava009.png" title="Caption" ></p>

<p>下面开始使用java正式抓取并解析html（网页）数据</p>

<p>根据下面的图片在java工程项目中书写html数据解析的代码：（注意里面的步骤）</p>

<p><img src="/images/ava0010.png" title="Caption" ></p>

<p>java核心代码：</p>

<pre><code>try {

　　　　　　//文件路径

　　　　　　　　String path = " /Users/icocos/Desktop/iCocos.html";



　　　　　　　　//加载网页

　　　　　　　　Document doc = Jsoup.parse(new File(path), "UTF-8");



　　　　　　　　//解析网页

　　　　　　　　Elements lis = doc.select("li");



　　　　　　　 //遍历数组

　　　　　　　　for(int i = 0; i &lt; eles.size(); i++) {

　　　　　　　　//根据i获取对应的元素

　　　　　　　　Element li = lis.get(i);



　　　　　　　　//取图片

　　　　　　　　Element img = li.select("img").get(0);

　　　　　　　　// System.out.println(img.attr("src"));



　　　　　　　　//获取图片名

　　　　　　　　String imgName = img.attr("src");



　　　　　　　 Element p = li.select("p").get(0);

　　　　　　　　String personName = p.text();



　　　　　　　　//打印数据

　　　　　　　　System.out.println(imgName + "," + personName);



　　　　　　}

　　　　　} catch {

　　　　//错误（异常）处理

　　　　e.printStackTrace();

}
</code></pre>

<p>此时点击Run运行之后，Eclipse就会根据你的代码输出对应的信息</p>

<p><img src="/images/ava011.png" title="Caption" ></p>

<p>但是这个时候我并不能直接使用数据所以需要在java代码中做一些相应的修改，使得输出的数据可以直接拷贝并且读到plist中，其实就是数组或者字典数据</p>

<p>我们知道在ios开发中从plist文件中读取数据时最常见的，当然你也可以使用其他方式，但是没有比这更简单了。</p>

<p>下面我给java代码做一些调整</p>

<p>1:在for循环之前输入这一行代码，实现数据拼接并且数据</p>

<pre><code>System.out.println("NSArray *apps = @[");
</code></pre>

<p>2:接着就需要在for循环结束之后输入预知对应的拼接数组结尾标志</p>

<pre><code>System.out.println("]");
</code></pre>

<p>3:在for循环内部的最后面我们需要在每次循环的时候都要使用上面的代码进行拼接并且使用逗号做相应的分割</p>

<pre><code>System.out.println("@{@\"name\":@\"" + personName + "\", @\"icon\":@\""+ imgName + "\"},");
</code></pre>

<p>最后完整的java获取并且解析html数据如下；</p>

<pre><code>public class iCocos {

public static void main (String[] args) {

　　　 try {

　　　　　　//文件路径

　　　　　　String path = " /Users/icocos/Desktop/iCocos.html";

　　　　　　//加载网页
　　　　　　Document doc = Jsoup.parse(new File(path), "UTF-8");

　　　　　　//解析网页
　　　　　　Elements lis = doc.select("li");

　　　　　　System.out.println("NSArray *apps = @[");


　　　　　　//遍历数组

　　　　　　for(int i = 0; i &lt; eles.size(); i++) {

　　　　　　//根据i获取对应的元素

　　　　　　Element li = lis.get(i);


　　　　　　//取图片

　　　　　　Element img = li.select("img").get(0);

　　　　　　// System.out.println(img.attr("src"));

　　　　　　//获取图片名

　　　　　　String imgName = img.attr("src");

　　　　　　Element p = li.select("p").get(0);

　　　　　　String personName = p.text();

　　　　　　//打印数据
　　　　　　// System.out.println(imgName + "," + personName);

　　　　　　System.out.println("@{@\"name\":@\"" + personName + "\", @\"icon\":@\""+ imgName + "\"},");
　　　　　　}
　　　　　　System.out.println("]");

　　　　} catch {

　　　　　　//错误（异常）处理
　　　　　　e.printStackTrace();

　　　　}

　　}

}
</code></pre>

<p>这个时候回打印输出下面的代码，</p>

<p><img src="/images/ava012.png" title="Caption" ></p>

<p>下面我们就需要在xcode中做事情了，做什么事呢，就是将输出的以NSArray开头的所有数据在Xcode中转换为plist的数据，当然你也可以不转换，做少部分的修改之后直接使用JSON解析技术去解析，但是那样不是最好的办法。</p>

<p>在Xcode中新建一个项目工程，在ViewDidLoad中粘贴拷贝过来的代码，这个时候是不是看起来非常熟悉，对了，她就是我吗开发中常用到的数组数据。</p>

<p>下面我就使用循环遍历去讲NSArray数组数据写到plist文件中。</p>

<pre><code>- (void)viewDidLoad

{

    [super viewDidLoad];



    NSArray *apps = @[

  @{@"name":@"敌法师", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/dfss.jpg"},

  @{@"name":@"火枪", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/arjj.jpg"},

  @{@"name":@"德鲁伊", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/dlyy.jpg"},

  @{@"name":@"月骑", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/yzqs.jpg"},

  @{@"name":@"变体精灵", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/btjl.jpg"},

  @{@"name":@"娜迦海妖", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/njhy.gif"},

  @{@"name":@"猴子", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/hycm.jpg"},

  @{@"name":@"白虎", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/yzjs.jpg"},

  @{@"name":@"隐形刺客", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/yxck.jpg"},

  @{@"name":@"巨魔", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/jmzj.jpg"},

  @{@"name":@"直升机", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/arzs.jpg"},

  @{@"name":@"赏金猎人", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/Naka.gif"},

  @{@"name":@"骷髅射手", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/KLSS.gif"},

  @{@"name":@"育母蜘蛛", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/YMZZ.gif"},

  @{@"name":@"血魔", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/XM.gif"},

  @{@"name":@"黑暗游侠", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/Nbrn.gif"},

  @{@"name":@"虚空假面", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/EC45.gif"},

  @{@"name":@"蛇发女妖", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/H00V.gif"},

  @{@"name":@"地卜师", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/H00I.gif"},

  @{@"name":@"地穴刺客", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/DXCK.gif"},

  @{@"name":@"蚂蚁", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/DXBZ.gif"},

  @{@"name":@"幻影刺客", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/HYCK.gif"},

  @{@"name":@"闪电幽魂", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/E002.gif"},

  @{@"name":@"影魔", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/YM01.gif"},

  @{@"name":@"小鱼人", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/yryx.gif"},

  @{@"name":@"幽鬼", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/YG1.gif"},

  @{@"name":@"圣堂刺客", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/E01Y.gif"},

  @{@"name":@"灵魂守卫", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/LHSW.gif"},

  @{@"name":@"熊战士", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/Huth.gif"},

  @{@"name":@"剧毒术士", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/JDSS.gif"},

  @{@"name":@"冥界亚龙", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/MJYL.gif"},

  @{@"name":@"复仇之魂", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/Hvwd.jpg"},

  @{@"name":@"剑圣", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/jsjs.jpg"}

  ];



    [newApps writeToFile:@"/Users/icocos/Desktop/apps.plist" atomically:YES];
</code></pre>

<p>这个时候我吗的左面就有了这个plist文件，打开之后你会看到</p>

<p><img src="/images/ava013.png" title="Caption" ></p>

<p>最后的步骤就是图片的下载，</p>

<pre><code>//简单写入

//    for (NSDictionary *dict in apps) {

//        NSString *icon = dict[@"icon"];

//        

//        // 新建网络图片的URL路径

//        NSURL *url = [NSURL URLWithString:icon];

//        

//        // 下载图片的二进制数据

//        NSData *data = [NSData dataWithContentsOfURL:url];

//        

//        // 截取文件名

//        NSString *filename = [icon lastPathComponent];

//        

//        // 文件路径

//        NSString *iconPath = [NSString stringWithFormat:@"/Users/icocos/Desktop/Icons/%@", filename];

//        

//        [data writeToFile:iconPath atomically:YES];

//    }
</code></pre>

<p>由于plist中图片名使用的都是对应链接的最后一个名字，所以我们不能使用上面的方法，还需要做一些处理，才能真正使用</p>

<pre><code>NSMutableArray *newApps = [NSMutableArray array];

    for (NSDictionary *dict in apps) {

        NSMutableDictionary *newDict = [NSMutableDictionary dictionary];

        newDict[@"name"] = dict[@"name"];

        newDict[@"icon"] = [dict[@"icon"] lastPathComponent];

        [newApps addObject:newDict];

    }



    [newApps writeToFile:@"/Users/icocos/Desktop/apps.plist" atomically:YES];



}
</code></pre>

<p><img src="/images/ava014.png" title="Caption" ></p>

<p>图片下载完成之后你会回看到对应的文件夹中快速的出现了好多的图片</p>

<p><img src="/images/ava015.png" title="Caption" ></p>

<p>此时我们就得到了一份和网页想相对应比较完整的plist数据，后面我们要做的就是将我们的plist数据显示到界面，后面我就不介绍了，详细请看：plist文件读取</p>

<blockquote><p>最后总结一下，如果以后遇到了关于需要抓取网络数据实现网络爬虫的功能的时候，我们基本上想到的第一种方法就是使用java语言，当然公司一般不会有这样的要求，公司一般都是使用自己服务器的api来实现，特殊情况除外。</p></blockquote>

<p>当然你也可以使用正则表达式或者Python，关于正则表达式相对来说还是比较难的，主要是细节比较多。而Python本人还没有研究过，有机会尝试一下，如果您还有什么好的方法欢迎笔者联系，相互学习与讨论。</p>

<p>我们基本上可以按照上面的思路去实现，只需要做少部分的修改，这里大致说一下</p>

<ul>
<li>1:准备阶段根据你需要的数据会有不同的html产生</li>
<li>2:产生不同的html之后你html内部的结构就会做响应的变化，这个时候你就要去把java那段核心代码搞懂来就没问题了，最重要的还是这里。</li>
<li>3:根据对应的NSArray数据写入到plist文件中，这里是iOS开发中常用的技术我就不多说。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[爬虫必备-Phthon抓包]]></title>
    <link href="http://al1020119.github.io/blog/2015/12/11/pa-chong-bi-bei-phthonzhua-bao/"/>
    <updated>2015-12-11T11:03:23+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/12/11/pa-chong-bi-bei-phthonzhua-bao</id>
    <content type="html"><![CDATA[<p>由于最近都在研究网络爬虫技术，自己也总结了一些。接住一个朋友（boyXiong）的博文，了解到了python抓包技术，所以就整理到这里，希望你能喜欢！</p>

<h4>准备搭建环境</h4>

<p>因为是MAC电脑，所以自动安装了Python 2.7的版本</p>

<p>添加一个 库 Beautiful Soup ,方法这里说两种</p>

<ul>
<li>1.在终端输入 pip install BeautifulSoup</li>
<li>2.手动下载包后，终端切换到 解压的文件夹，输入 sudo python setup.py install 下载地址BeautifulSoup</li>
</ul>


<!--more-->


<h4>开始写代码吧</h4>

<p>先找一个想要抓取东西的网站，这里我就随便找一个吧 地址是：<a href="http://movie.douban.com/chart">http://movie.douban.com/chart</a>
好了在终端输入 vim 我知道这个东西，对于新手来说，就是一个挑战，这里我也建议使用轻量的Sublime
代码如下 (注意python是严格的缩进,以下代码要顶格写)</p>

<pre><code>#-*- coding:utf-8 -*-
import urllib2
import urllib
html=urllib2.urlopen("http://movie.douban.com/chart").read()
print html
</code></pre>

<p>输出的结果就是一个HTML的网页，这里我就看到自己想要抓取的图片和图片名的文字片段</p>

<pre><code>&lt;a class="nbg" href="http://movie.douban.com/subject/24879839/"  title="道士下山"&gt;
           &lt;img src="http://img3.douban.com/view/movie_poster_cover/ipst/public/p2251450614.jpg" alt="道士下山" class=""/&gt;
&lt;/a&gt;
</code></pre>

<p>分析我们想要的，一个是图片的名称，一个是图片的链接地址，直接上Python代码
    #-<em>- coding:utf-8 -</em>-
    import urllib2
    from bs4 import BeautifulSoup</p>

<pre><code>import sys  
reload(sys)  
sys.setdefaultencoding('utf8')

# 函数
def  printPlistCode():
    #1.得到这个网页的 html 代码 #
    html = urllib2.urlopen("http://movie.douban.com/chart").read()

    #2.转换 一种格式，方便查找
    soup = BeautifulSoup(html)
    #3.  得到 找到的所有 包含 a 属性是class = nbg 的代码块,数组
    liResutl = soup.findAll('a', attrs = {"class" : "nbg"})
    #4.用于拼接每个字典的字符串
    tmpDictM = ''

    #5. 遍历这个代码块  数组
    for li in liResutl:

        #5.1 找到 img 标签的代码块 数组
        imageEntityArray = li.findAll('img')

        #5.2 得到每个image 标签
        for image in imageEntityArray:
            #5.3 得到src 这个属性的 value  后面也一样 类似 key value
            link = image.get('src')
            imageName = image.get('alt')
            #拼接 由于 py中 {} 是一种数据处理格式，类似占位符
            tmpDict = '''@{0}@\"name\" : @\"{1}\", @\"imageUrl\" : @\"{2}\"{3},'''

            tmpDict =  tmpDict.format('{',imageName,link,'}')

            tmpDictM = tmpDictM + tmpDict

    #6.去掉最后一个 , 
    tmpDictM = tmpDictM[0:len(tmpDictM) - 1].decode('utf8')

    #7 拼接全部
    restultStr = '@[{0}];'.format(tmpDictM)

    print restultStr


if __name__ == '__main__':
    printPlistCode()
</code></pre>

<p>输出结果就是Objective-C的 数组</p>

<pre><code>@[@{@"name" : @"进击的巨人真人版：前篇", @"imageUrl" : @"http://img3.douban.com/view/movie_poster_cover/ipst/public/p2251690571.jpg"},@{@"name" : @"花与爱丽丝杀人事件", @"imageUrl" : @"http://img3.douban.com/view/movie_poster_cover/ipst/public/p2222398443.jpg"},@{@"name" : @"小黄人大眼萌", @"imageUrl" : @"http://img4.douban.com/view/movie_poster_cover/ipst/public/p2258235689.jpg"},@{@"name" : @"小森林 冬春篇", @"imageUrl" : @"http://img4.douban.com/view/movie_poster_cover/ipst/public/p2215147728.jpg"},@{@"name" : @"道士下山", @"imageUrl" : @"http://img3.douban.com/view/movie_poster_cover/ipst/public/p2251450614.jpg"},@{@"name" : @"深夜食堂 电影版", @"imageUrl" : @"http://img3.douban.com/view/movie_poster_cover/ipst/public/p2205014862.jpg"},@{@"name" : @"小男孩", @"imageUrl" : @"http://img4.douban.com/view/movie_poster_cover/ipst/public/p2230105606.jpg"},@{@"name" : @"头脑特工队", @"imageUrl" : @"http://img4.douban.com/view/movie_poster_cover/ipst/public/p2231021196.jpg"},@{@"name" : @"百元之恋", @"imageUrl" : @"http://img4.douban.com/view/movie_poster_cover/ipst/public/p2205471169.jpg"},@{@"name" : @"杀破狼2", @"imageUrl" : @"http://img4.douban.com/view/movie_poster_cover/ipst/public/p2246885606.jpg"}];
</code></pre>

<p>使用Xcode 写到Plist中去</p>

<pre><code>#import &lt;Foundation/Foundation.h&gt;

int main(int argc, const char * argv[]) {


NSArray *plistArray = @[@{@"name" : @"进击的巨人真人版：前篇", @"imageUrl" : @"http://img3.douban.com/view/movie_poster_cover/ipst/public/p2251690571.jpg"},@{@"name" : @"花与爱丽丝杀人事件", @"imageUrl" : @"http://img3.douban.com/view/movie_poster_cover/ipst/public/p2222398443.jpg"},@{@"name" : @"小黄人大眼萌", @"imageUrl" : @"http://img4.douban.com/view/movie_poster_cover/ipst/public/p2258235689.jpg"},@{@"name" : @"小森林 冬春篇", @"imageUrl" : @"http://img4.douban.com/view/movie_poster_cover/ipst/public/p2215147728.jpg"},@{@"name" : @"道士下山", @"imageUrl" : @"http://img3.douban.com/view/movie_poster_cover/ipst/public/p2251450614.jpg"},@{@"name" : @"深夜食堂 电影版", @"imageUrl" : @"http://img3.douban.com/view/movie_poster_cover/ipst/public/p2205014862.jpg"},@{@"name" : @"小男孩", @"imageUrl" : @"http://img4.douban.com/view/movie_poster_cover/ipst/public/p2230105606.jpg"},@{@"name" : @"头脑特工队", @"imageUrl" : @"http://img4.douban.com/view/movie_poster_cover/ipst/public/p2231021196.jpg"},@{@"name" : @"百元之恋", @"imageUrl" : @"http://img4.douban.com/view/movie_poster_cover/ipst/public/p2205471169.jpg"},@{@"name" : @"杀破狼2", @"imageUrl" : @"http://img4.douban.com/view/movie_poster_cover/ipst/public/p2246885606.jpg"}];
//路径可以自己选择
[plistArray writeToFile:@"/Users/xxx/Desktop/test/movie.plist" atomically:YES];

return 0;
</code></pre>

<p>到这里，就可以看到plist 文件可以用于测试了</p>

<p><img src="/images/python001.png" title="Caption" ></p>

<p>这里写图片描述
如果想要复制粘贴这里面的代码，那就选择Sublime编辑器</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[爬虫必备-正则表达式抓包]]></title>
    <link href="http://al1020119.github.io/blog/2015/12/11/zhengze/"/>
    <updated>2015-12-11T10:03:23+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/12/11/zhengze</id>
    <content type="html"><![CDATA[<p>第一篇我们有介绍到使用青花瓷抓包，也提到了后面会介绍java和python实现，本篇就介绍一下怎么使用python抓取网络数据。</p>

<p>先来看看网络爬虫的基本原理：</p>

<p>一个通用的网络爬虫的框架如图所示：</p>

<p><img src="/images/zhengze001.png" title="Caption" ></p>

<!--more-->


<h5>网络爬虫的基本工作流程如下：</h5>

<ol>
<li><p>首先选取一部分精心挑选的种子URL；</p></li>
<li><p>将这些URL放入待抓取URL队列；</p></li>
<li><p>从待抓取URL队列中取出待抓取在URL，解析DNS，并且得到主机的ip，并将URL对应的网页下载下来，存储进已下载网页库中。此外，将这些URL放进已抓取URL队列。</p></li>
<li><p>分析已抓取URL队列中的URL，分析其中的其他URL，并且将URL放入待抓取URL队列，从而进入下一个循环。</p></li>
</ol>


<p>以下内容均为本人个人理解。</p>

<p>网络数据抓取</p>

<ol>
<li>概念：网络数据抓取，也叫网络爬虫。是在我们iOS程序中，获取要抓取到的网页上的数据。</li>
<li>用处：如果要用到某网站的一些数据，这个时候我们就要用到抓取数据技术。</li>
<li>建议：建议抓取过程中，多利用分类，多写一些分类方法，有助于提高程序可读性，也可提高效率。</li>
</ol>


<p>今天先来介绍一下第一种：正则表达式</p>

<blockquote><p>注意点：其实网络抓取数据很简单，但是有用到正则表达式，这个有人说难，有人说很难，有人说非常难，其实我们抓取数据只会用到“.&ldquo; 、&rdquo;*&ldquo;、&rdquo;?&ldquo;这三个符号！</p></blockquote>

<p>正则表达式中：“.”是包括任何字符不包括换行符，“*”是任意多个的字符，“？”是指到最近的一个URL，如果没有就是到最远的一个！</p>

<pre><code> NSString *pantten = [NSString stringWithFormat:@"&lt;ul class=\"cs_list\"&gt;(.*?)&lt;/ul&gt;"];

 NSRegularExpression *regx = [NSRegularExpression regularExpressionWithPattern:pantten options:NSRegularExpressionCaseInsensitive |NSRegularExpressionDotMatchesLineSeparators error:NULL];
</code></pre>

<p>其中有两个参数需要大家了解一下，很重要</p>

<ul>
<li>NSRegularExpressionCaseinsensitive 不区分大小写</li>
<li>NSRegularExpressionDotMatcheLineSeparators 让“点”字符可以匹配换行符</li>
</ul>


<p>抓数据，其实主要会写匹配字符串就行</p>

<pre><code>(.*?)表示要抓到的内容
.*?表示要忽略的内容，爱是啥是啥
字符串转义双引号用\转义括号用\\
</code></pre>

<p>在开发项目的过程，很多情况下我们需要利用互联网上的一些数据，在这种情况下，我们可能要写一个爬虫来爬我们所需要的数据。一般情况下都是利用正则表达式来匹配Html,获取我们所需要的数据。一般情况下分以下三步。</p>

<ul>
<li>1、获取网页的html</li>
<li>2、利用正则表达式，获取我们所需要的数据</li>
<li>3、分析，使用获取到的数据，（例如，保存到数据库）</li>
</ul>


<p>接下来我们分析代码：</p>

<h3>1、获取网页的html</h3>

<p>　　对于一些网页，不需要提交Post提交数据时，我们可以简单的利用NSURL类来获取我们所需要的html，交将其转换中kCFStringEncodingGB_18030_2000格式，解决中文乱码问题。</p>

<p>　　</p>

<pre><code>+(NSString*) urlstring:(NSString*)strurl{
　　　　NSURL *url = [NSURL URLWithString:strurl];
　　　　NSData *data = [NSData dataWithContentsOfURL:url];

　　　　NSStringEncoding enc = CFStringConvertEncodingToNSStringEncoding(kCFStringEncodingGB_18030_2000); 
　　　　NSString *retStr = [[NSString alloc] initWithData:data encoding:enc];

　　　　//NSLog(@" html = %@",retStr);

　　　　return retStr;
　　}
</code></pre>

<p> 对于需要Post提交数据的网页，我们可以利用强大的ASIFormDataRequest类来实现，例如：</p>

<pre><code>+(void)getPostResult:(NSString*)startqi{
　　　　ASIFormDataRequest *request = [[ASIFormDataRequest alloc] initWithURL:[NSURL URLWithString:URLPost]];

　　　　[request setPostValue:startqi forKey:@"startqi"];
　　　　[request setPostValue:@"20990101001" forKey:@"endqi"];
　　　　[request setPostValue:@"qihao" forKey:@"searchType"];//网页的中的搜索方式
　　　　[request startSynchronous];

　　　　NSData* data = [request responseData];

　　if (data==nil) {
　　　　FCLOG(@"has not data");
　　}
　　else{
　　　　NSStringEncoding enc = CFStringConvertEncodingToNSStringEncoding(kCFStringEncodingGB_18030_2000); 
　　　　NSString *retStr = [[NSString alloc] initWithData:data encoding:enc];
　　　　FCLOG(@"html = %@",retStr); 
　　}
}
</code></pre>

<p>这样的话，我们就通过了两种方式获取了我们所需要的html</p>

<h3>2、分析html</h3>

<p>　　关于利用正则表达式匹配问题，我又对NSString类扩展了一个方法-(NSMutableArray <em>)substringByRegular:(NSString </em>)regular。根据传入的正则表达式，返回所有匹配的数组。</p>

<p>　　</p>

<pre><code>@implementation NSString(StringRegular)


-(NSMutableArray *)substringByRegular:(NSString *)regular{

  　　　　　NSString * reg=regular;

　　　　　　NSRange r= [self rangeOfString:reg options:NSRegularExpressionSearch];

　　　　　　NSMutableArray *arr=[NSMutableArray array];

　　　　　　if (r.length != NSNotFound &amp;&amp;r.length != 0) {

　　　　　　int i=0;

　　　　　　while (r.length != NSNotFound &amp;&amp;r.length != 0) {

　　　　　　FCLOG(@"index = %i regIndex = %d loc = %d",(++i),r.length,r.location);

　　　　　　NSString* substr = [self substringWithRange:r];

　　　　　　FCLOG(@"substr = %@",substr);

　　　　　　[arr addObject:substr];

　　　　　　NSRange startr=NSMakeRange(r.location+r.length, [self length]-r.location-r.length);

　　　　　　r=[self rangeOfString:reg options:NSRegularExpressionSearch range:startr];
　　　　}
　　}
　　return arr;
}
@end
</code></pre>

<p>在这种情况下，我们首先我得到我们要获取数据的正则表达式，关于正则表达式这种火星文我就不多说了，我也很纠结，我就不多说了，但是有一点就是，所写的正则表达式一定是我们所需要的数据，并且能够屏蔽无效信息的，有可能在一次匹配中无法获取，可以多次利用正则表达式来分段获取。下面是我的语句，在我的例子中，就是两次利用正则表达式。</p>

<pre><code>NSString *regstr = @"&lt;td class=\'z_bg_05\'&gt;\\w{11}&lt;/td&gt;&lt;td class=\'z_bg_13\'&gt;(\\w{2}\\s{0,1})*&lt;/td&gt;";
NSMutableArray *arr=[strhtml substringByRegular:regstr];
</code></pre>

<h3>3、分析或利用数据，在这里，我只是利用上一篇博客上所述方法简单的把这些数据保存到了数据库（sqlite3）中。</h3>

<p>其实在这个arr数组中一条就是对应我数据库表中的一条记录，但是像td class等这些信息我是不需要的，所以再次利用正则表达式来分析NSString</p>

<pre><code>if (arr!=nil&amp;&amp;[arr count]&gt;0) {

　　　　　　NSString *prereg=@"\\w{11}";
　　　　　　NSString *backreg=@"(\\w{2}\\s{0,1}){8}";

　　　　　　TicketResultService *service=[[TicketResultService alloc] init];
　　　　　　[[Sqlite3Helper Instance] openDB];
　　　　for (NSString *sub in arr) {

　　　　　　TicketResult* r=[[[TicketResult alloc] init] autorelease];

　　　　　　NSMutableArray* prearr=[sub substringByRegular:prereg];

　　　　　　if (prearr!=nil&amp;&amp;[prearr count]&gt;0) {
　　　　　　　　r.sectionID=(NSString*)[prearr objectAtIndex:0];
　　　　　　}
　　　　　　else{
　　　　　　　　continue;
　　　　　　}

　　　　　　NSMutableArray *backarr=[sub substringByRegular:backreg];
　　　　　　if (backarr!=nil&amp;&amp;[backarr count]&gt;0) {
　　　　　　r.result=[backarr objectAtIndex:0];
　　　　　　}
　　　　　　else{
　　　　　　　　continue;
　　　　　　}

　　　　　　if([service isExist:r.sectionID]){
　　　　　　　　continue;
　　　　　　}

　　　　r.type=[NSNumber numberWithInt:1];

　　　　[service addModel:r];

　　}
　　[[Sqlite3Helper Instance] closeDB];

　　[service release];
}
</code></pre>

<blockquote><p>以上爬虫才算正式完成，其实，在此之前还有一个第0步，即判断设备目前的网络状态，如果没有联网的就没有必要去爬虫了，因为你也爬不到任何的数据。判断网络状态我是利用Apple官方的一个例子Reachability，网上也有很多关于这个的例子，我就不再细说了，非常感谢网上的各位大牛们提供的很好的办法，让我能更快的写出这些。</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[爬虫必备-青花瓷抓包]]></title>
    <link href="http://al1020119.github.io/blog/2015/12/11/qinghuaci/"/>
    <updated>2015-12-11T09:03:23+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/12/11/qinghuaci</id>
    <content type="html"><![CDATA[<p>在之前个人学习ios开发的时候听过抓包相关的技术，但是自己没有实现，所以也只是当听听。</p>

<p>这段时间，由于公司新项目的原因，但是后台和UI都还没有，而又需要我先开始封装对应的工具或者一下大概的逻辑，我当时就蒙了，最后还是乖乖的来做。</p>

<p>网上找了一些接口，也找了不少类似的网站，但是发现再美我用不了有什么用呢？最后我想到了之前听别人说的网络爬虫，找了不少资料研究了一番。发现效果还不错，就在这里记录下来，希望对你有用！</p>

<p>关于网络数据抓取不仅仅在iOS开发中有，其他开发中也有，也叫网络爬虫，大致分为三种方式实现</p>

<ul>
<li>1: 青花瓷</li>
<li>2: 正则表达</li>
<li>3: 利用其他语言的工具包：java／Python</li>
</ul>


<p>写本文的契机主要是前段时间有次用青花瓷抓包有一步忘了，在网上查了半天也没找到写的完整的教程，于是待问题解决后抽时间截了图，自己写一遍封存在博客园中以便以后随时查阅。</p>

<!--more-->


<p>charles又名青花瓷，在iOS开发中的抓包中具有重要作用。最大的三点用处，一就是拦截别人软件的发送的请求和后端接口，练习开发。二是自己后端返回的response拦截修改后再接收以达到测试临界数据的作用。三写脚本重复拦截抓取别人的数据。(因为不太道德，本文不提第三点)</p>

<p>如果你不是在董铂然博客园看到本文，请点击查看原文。</p>

<h3>1.开始之前的准备工作</h3>

<p>首先安装一下这个软件</p>

<p>这个相信很多人电脑里应该都安装了，没安装的搜charles破解版也能很容易搜到。如果没安装java环境，首次进入charles会提示让你安装java包得，直接给你链接是苹果官网的，去下一个一键安装就行了。</p>

<p> <img src="/images/qinghuaci001.jpg" title="Caption" ></p>

<p>安装完成后先打开，在进行下面操作。</p>

<p>然后去自己电脑的系统偏好设置-》网络-》选中现在连着的网(大部分人应该都是WiFi吧)可以查到自己这个电脑在现在这个wifi里的IP地址，比如我现在这个就是192.168.0.105(建议最好用私人网络，用公司网络的话可能会有限制会出现没反应的问题)</p>

<p><img src="/images/qinghuaci002.jpg" title="Caption" ></p>

<p>然后找到自己手机也连着这个同名的wifi，然后选中右边的蓝色i。</p>

<p> <img src="/images/qinghuaci003.jpg" title="Caption" ></p>

<p><img src="/images/qinghuaci004.jpg" title="Caption" ></p>

<p>然后进入到了这个无线局域网的高级设置页面。进去之后拉到最下方，找到HTTP代理字样。然后选中手动代理，并在服务器中填自己电脑查到的ip地址，然后把端口调8888，最后点击左上角返回。返回值后系统会自动设置代理重新连接。</p>

<p>这时候你的手机上网的过程中就要经过你的电脑了。刚用手机打开一个联网的程序，你的电脑上应该会显示一个弹窗问你【allow】还是【deny】肯定不能拒绝啊就点allow吧。这个只有第一次才弹窗，图没截上，你到时候看见肯定能看懂的。点了同意之后你手机发出的每一个请求都会被拦截出痕迹。</p>

<h3>2.拦截某个软件的接口数据</h3>

<p>拿网易新闻举例，以前就练习这写过网易新闻的项目，其中网易的接口全是用charles拦截的。拦截到了网易发请求时发的是什么，然后在练习项目中需要获取数据的地方也把这一串链接直接拿过来用即可。</p>

<p><img src="/images/qinghuaci005.jpg" title="Caption" ></p>

<p>当然这上面拦到的比较多，如果有过开发经验的话应该能很快看出来右边哪个是真正返回json数据的接口。或者一个一个点看内容也行啊。</p>

<p>比如选中一个url然后右键点击copy。</p>

<p><img src="/images/qinghuaci006.jpg" title="Caption" ></p>

<p>放到浏览器地址栏里打一下。能看到</p>

<p><img src="/images/qinghuaci007.jpg" title="Caption" ></p>

<p>这就说明这个接口是对的了。可以获取到数据。然后可以给他转化一下看的更清楚。虽然很多人都是用bash看，但我还是推荐一个网址<a href="http://www.w3cschool.cc/jsontool">http://www.w3cschool.cc/jsontool</a>。转JSON之后看的非常清晰。大部分软件json整理后都是默认把大括号全都打开，而仅有这个网站是默认全给你把大括号关上。想点哪个再点开，而且能知道字典里有多少个键值对，所以看着非常清晰。</p>

<p><img src="/images/qinghuaci008.jpg" title="Caption" ></p>

<p>到此就已经完成了一次完整的，拉取接口，和获得数据。</p>

<p>这里有两点我想说下：</p>

<p>①就是如果这个App发的请求加密了或是RSA什么的，这个就算拦截了你也弄不到数据。网易是没有做任何加密，所以可以抓取到数据。以前试了拦截百度医生的就不行。他设置的是一分钟内能获取到数据，超过了1分钟这个复制过来的接口就取不到数据了。怀疑可能是用的HMAC方法加密，并且在里面加入了时间判断。32分和33分发出的请求经过编码后是不一样的，后台可能做了容错，会把32分和31分都和你判断下，只要有一个对上就让你过，但是超过了整整一分钟后是肯定获取不到数据了。</p>

<p>②就是很多比较大型的网站，一般会开放一个开发者平台，里面注册开发者账号后会向你公开一个接口文档，你不用再去费事的拦截了。像新浪微博和大众点评都有开发者平台。</p>

<h3>3.更改返回数据来测试临界情况</h3>

<p>这个是重点了。因为这种做法可以让一个iOS前端的开发人员独立完成测试而不用拉过来一个后端一起联调。并且各种特殊维度，或是临界的账号也不用再去辛苦找了，仅仅自己在青花瓷上改来改去就可以达到效果了。比如这个地方如果返回了nil程序会不会崩，直接改response就行了。下面是具体操作方案。</p>

<p>打开青花瓷切换成结构页面</p>

<p><img src="/images/qinghuaci009.jpg" title="Caption" ></p>

<p>这里可以看到断点和调试信息</p>

<p><img src="/images/qinghuaci010.jpg" title="Caption" ><br/>
<img src="/images/qinghuaci011.jpg" title="Caption" ></p>

<p>然后找一个我们公司的页面。这个页面本来应该返回是这样的：如上图右边</p>

<p>你先正常的打开这个页面把玩几下，这个青花瓷就会抓取很多接口和域名分类了。在这里找到你这个页面所属的域名分类应该不难。然后打上断点。这里要注意是在域名上打断点而不是在下面的单个请求上打断点。</p>

<p>再次用手机进入这个页面，就会通过你刚才打断点的那个域名来请求数据，就会被断点拦住，如下图所示。</p>

<p><img src="/images/qinghuaci012.jpg" title="Caption" ></p>

<p>右边的信息也很清晰，一开始可以编辑请求。如果点击单步执行，等一下相应回来了也可以编辑响应。</p>

<p><img src="/images/qinghuaci013.jpg" title="Caption" ></p>

<p><img src="/images/qinghuaci014.jpg" title="Caption" ></p>

<p>这里的有好几种查看的方式，但是推荐使用JSON Text看的比较清楚。 现在我们对拦截回来的数据进行修改，我把这些统计数据全改成999如下图</p>

<p> <img src="/images/qinghuaci015.jpg" title="Caption" ></p>

<p>然后再次点击下方的Execute单步执行，更改后的数据就会像正常返回回来的数据那样显示到，APP的页面上展示。</p>

<p><img src="/images/qinghuaci016.jpg" title="Caption" ></p>

<p>能来到这一步就说明已经完整的掌握了用青花瓷篡改返回数据测试App的技术。</p>

<p>如果你不是在董铂然博客园看到本文，请点击查看原文。</p>

<p>这么做的意义：</p>

<p>这里只是简单的更改了一些数字，在页面显示更加直观。实际的操作中，你可以经常用来把某些值改为临界情况以看到App在处理这些临界状况时的反应，这样比找那些临界数据的测试账号成本要低得多。也可以把一些可能不会反回数值的字段找到，直接将里面的值删成nil，看看会不会报异常等等。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[常用关键字总结]]></title>
    <link href="http://al1020119.github.io/blog/2015/11/03/chang-yong-guan-jian-zi-zong-jie/"/>
    <updated>2015-11-03T17:43:59+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/11/03/chang-yong-guan-jian-zi-zong-jie</id>
    <content type="html"><![CDATA[<table>
<thead>
<tr>
<th> Name  </th>
<th style="text-align:center;"> Typedef</th>
<th style="text-align:right;">  Header</th>
<th>     True Value  </th>
<th> False Value</th>
</tr>
</thead>
<tbody>
<tr>
<td> BOOL</td>
<td style="text-align:center;">     signed char objc.h</td>
<td style="text-align:right;">     YES</td>
<td>    NO</td>
<td></td>
</tr>
<tr>
<td> bool  </td>
<td style="text-align:center;"> _Bool (int)   </td>
<td style="text-align:right;"> stdbool.h true    </td>
<td> false</td>
<td></td>
</tr>
<tr>
<td> Boolean</td>
<td style="text-align:center;">  unsigned char</td>
<td style="text-align:right;">  MacTypes.h  TRUE    </td>
<td> FALSE</td>
<td></td>
</tr>
<tr>
<td> NSNumber</td>
<td style="text-align:center;">     __NSCFBoolean</td>
<td style="text-align:right;">  Foundation.h    </td>
<td> @(YES)</td>
<td>   @(NO)</td>
</tr>
<tr>
<td> CFBooleanRef</td>
<td style="text-align:center;">     struct</td>
<td style="text-align:right;">     CoreFoundation.h    </td>
<td> kCFBooleanTrue</td>
<td>   kCFBooleanFalse</td>
</tr>
</tbody>
</table>


<!--more-->


<table>
<thead>
<tr>
<th> 标志    </th>
<th style="text-align:center;"> 值</th>
<th style="text-align:right;">  含义</th>
</tr>
</thead>
<tbody>
<tr>
<td> NULL</td>
<td style="text-align:center;">     (void *)0   </td>
<td style="text-align:right;"> C指针的字面零值</td>
</tr>
<tr>
<td> nil   </td>
<td style="text-align:center;"> (id)0 </td>
<td style="text-align:right;"> Objective-C对象的字面零值</td>
</tr>
<tr>
<td> Nil   </td>
<td style="text-align:center;"> (Class)0  </td>
<td style="text-align:right;"> Objective-C类的字面零值</td>
</tr>
<tr>
<td> NSNull    </td>
<td style="text-align:center;"> [NSNull null] </td>
<td style="text-align:right;"> 用来表示零值的单独的对象</td>
</tr>
</tbody>
</table>

]]></content>
  </entry>
  
</feed>
