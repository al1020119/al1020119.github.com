<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Developer | iOS梦工厂]]></title>
  <link href="http://al1020119.github.io/blog/categories/developer/atom.xml" rel="self"/>
  <link href="http://al1020119.github.io/"/>
  <updated>2016-12-01T17:15:16+08:00</updated>
  <id>http://al1020119.github.io/</id>
  <author>
    <name><![CDATA[iCocos]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[修行篇-探程序之精华]]></title>
    <link href="http://al1020119.github.io/blog/2016/08/08/oneday/"/>
    <updated>2016-08-08T23:53:19+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/08/08/oneday</id>
    <content type="html"><![CDATA[<blockquote><p>做了这么久ios开发，由于最近发现自己在性能和底层相关方面，还有有待提高，一句话总结就是：知其然，而不知其所以然。</p></blockquote>

<p>最近也一直在研究相关方面的技术，包括ios相关技术的底层实现，但是这还是远远不够的，一个真正的程序员是必须做到“学无止境”。</p>

<p>经过这几年的开发与学习，包括和同行朋友的了解，作为一个程序员，必备的技术有以下四种。</p>

<ul>
<li>算法</li>
<li>数据结构

<ul>
<li>程序=算法+数据结构</li>
</ul>
</li>
<li>设计模式</li>
<li>数据库</li>
</ul>


<!--more-->


<p>当然可能还有其他的，比如操作系统，软件工程，当然C语音是不能再基础的基础，但是除了上面四点，笔者可能不会专门去研究，最多作为了解。</p>

<blockquote><p>从今天开始，我将从上面四点开始人生的第二次攀爬，希望能爬到一个属于我自己的高峰，也希望能对和我有意义心态的人有所帮助。</p></blockquote>

<h4>路线</h4>

<ol>
<li>算法，数据结构，设计模式，数据库，相关概念的介绍与理解(可能会有部分的软件工程和操作系统相关)</li>
<li>简单代码演示以便更加深刻理解</li>
<li>实际应用以便更加深入理解</li>
<li>举一反三</li>
<li>相关总结</li>
</ol>


<hr />

<p>更新中，敬请关注。。。。。。</p>

<pre><code>Q Q：2211523682/790806573

微信：18370997821/13148454507

微博WB:http://weibo.com/u/3288975567?is_hot=1

git博文：http://al1020119.github.io/

github：https://github.com/al1020119
</code></pre>

<p><img src="/images/iCocosCoder.jpg" title="Caption" ></p>

<p><img src="/images/iCocosPublic.jpg" title="Caption" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS开发各种底层实现--包你满意😘！]]></title>
    <link href="http://al1020119.github.io/blog/2016/08/01/gezhongdicenshixian/"/>
    <updated>2016-08-01T23:30:19+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/08/01/gezhongdicenshixian</id>
    <content type="html"><![CDATA[<p>iOS开发常用技术底层实现（精简概述）</p>

<p>本章将对ios开发技术底层实现的总结，其实关于ios开发中各种底层的实现，网上相关文章多到数不过来，而不且非常不错，我也没有自信我能比他们做的更好，因为毕竟每个人专研的东西不一样，本文主要正对三类用户！</p>

<ol>
<li>资深的ios开发者，对底层做过专门研究，但是没有一个系统整理，或者说不能很清楚的表达。</li>
<li>ios开发初学者，没有专门研究过底层或者相关源码的初学者，但是不太建议一开始就看，因为如果你没有过一点接触，看了也看不懂，或者看了也白看，最多就是留个印象在脑子了，对初学者来说，切记不能靠背或者了解，而且细细研究每一个技术点，再慢慢深入挖掘。</li>
<li>ios开发待业程序员（面试）专用，不管你有没有接触过ios开发相关的底层，只要你是在准备找工作的程序员，我相信你看了绝对有用，但是并不能正面你就真的理解了，所以希望这对你来说只是短暂的，后续得花大量时间去专门研究才能在这条路上走得更远，不然你永远只是个码农！</li>
</ol>


<p>好了，废话也不多说了，我们开始吧。。。。。</p>

<h6>系统篇</h6>

<ul>
<li>内存管理</li>
<li>Runtime</li>
</ul>


<h6>事件篇</h6>

<ul>
<li>事件传递</li>
<li>事件响应</li>
</ul>


<h6>代码篇</h6>

<ul>
<li>Block</li>
<li>__Block</li>
</ul>


<!--more-->


<h6>实战</h6>

<ul>
<li>KVO</li>
<li>KVC</li>
</ul>


<h6>高级</h6>

<ul>
<li>GCD</li>
</ul>


<h6>全栈篇</h6>

<ul>
<li>JSPatch</li>
<li>React Native</li>
</ul>


<h6>必备篇</h6>

<ul>
<li>多线程</li>
<li>网络</li>
<li>数据持久化</li>
</ul>


<h6>通用篇</h6>

<ul>
<li>数组</li>
<li>字典</li>
<li>集合</li>
</ul>


<h6>#写在最后</h6>

<hr />

<h1>系统篇</h1>

<hr />

<h3>内存管理</h3>

<ul>
<li><p>黄金法则</p>

<ul>
<li>如果一个对象使用了alloc，[mutable] copy，retain，那么你必须使用相应的release或autonrelease</li>
</ul>
</li>
</ul>


<p>MRC:</p>

<pre><code> 手动管理内存（retain, release, autorelease,不多说） 持有对象,retain +1 ,引用计数加1, 释放对象:release -1, 引用计数减1,当引用计数为0时,会自动释放内存.  autorelease对象内存的管理放到autoreleasepool中, 当pool drain时,回收内存. (这是基于 objective-c的运行时特性和垃圾回收机制)
</code></pre>

<p>ARC:</p>

<pre><code> 手动管理内存, 这是xcode4.x版本的特性,(4.1及以前没有,我从4.6开始的), 原理是:在编译代码的时候为你自动在合适的位置插入release 和 autorelease, (运行时处理垃圾回收就如何MRC一样).
</code></pre>

<p>总结: ARC机制拥有和MRC一样的效率, ARC通过在部分优化和在最合适的地方完成引用计数的维护,所以支持使用ARC.</p>

<p>规则</p>

<p>规则：</p>

<ul>
<li><p>1、Objective-C类中实现了引用计数器，对象知道自己当前被引用的次数</p></li>
<li><p>2、最初对象的计数器为1</p></li>
<li><p>3、如果需要引用对象，可以给对象发送一个retain消息，这样对象的计数器就加1</p></li>
<li><p>4、当不需要引用对象了，可以给对象发送release消息，这样对象计数器就减1</p></li>
<li><p>5、当计数器减到0，自动调用对象的dealloc函数，对象就会释放内存</p></li>
<li><p>6、计数器为0的对象不能再使用release和其他方法</p></li>
</ul>


<h3>Runtime</h3>

<p>一套纯低层的C语言库
平时我们编写的OC代码都会转成Runtime去执行</p>

<p>特性：</p>

<pre><code>动态类型：程序直到执行时才能确定所属的类。

动态绑定：程序直到执行时才能确定实际要调用的方法。

动态加载：根据需求加载所需要的资源
</code></pre>

<p>Runtime消息机制</p>

<p>首先通过obj的isa指针找到obj对应的class。</p>

<ul>
<li>首先检测这个 selector 是不是要忽略。比如 Mac OS X 开发，有了垃圾回收就不理会 retain，release 这些函数。</li>
<li>检测这个 selector 的 target 是不是 nil，Objc 允许我们对一个 nil 对象执行任何方法不会 Crash，因为运行时会被忽略掉。</li>
<li>如果上面两步都通过了，那么就开始查找这个类的实现 IMP，</li>
<li>在Class中先去cache中 通过SEL查找对应函数method，找到就执行对应的实现。</li>
<li>若cache中未找到，再去methodList中查找，找到就执行对应的实现。</li>
<li>若methodlist中未找到，则取superClass中查找（重复执行以上两个步骤），直到找到最根的类为止。</li>
<li>若任何一部能找到，则将method加 入到cache中，以方便下次查找，并通过method中的函数指针跳转到对应的函数中去执行。</li>
<li>如果以上都不能找到，则会开始进行消息转发</li>
</ul>


<p>消息转发</p>

<ul>
<li>1.动态方法解析：向当前类发送 resolveInstanceMethod: 信号，检查是否动态向该类添加了方法。（迷茫请搜索：@dynamic）</li>
<li>2.快速消息转发：检查该类是否实现了 forwardingTargetForSelector: 方法，若实现了则调用这个方法。若该方法返回值对象非nil或非self，则向该返回对象重新发送消息。</li>
<li>3.标准消息转发：runtime发送methodSignatureForSelector:消息获取Selector对应的方法签名。返回值非空则通过forwardInvocation:转发消息，返回值为空则向当前对象发送doesNotRecognizeSelector:消息，程序崩溃退出</li>
</ul>


<p>总结就是：
在一个函数找不到时，OC提供了三种方式去补救：</p>

<ul>
<li>1、调用resolveInstanceMethod给个机会让类添加这个实现这个函数</li>
<li>2、调用forwardingTargetForSelector让别的对象去执行这个函数</li>
<li>3、调用forwardInvocation（函数执行器）灵活的将目标函数以其他形式执行。
如果都不中，调用doesNotRecognizeSelector抛出异常。</li>
</ul>


<hr />

<h1>事件篇</h1>

<h3>应用如何找到最合适的控件来处理事件？</h3>

<pre><code>1.首先判断主窗口（keyWindow）自己是否能接受触摸事件
2.判断触摸点是否在自己身上
3.子控件数组中从后往前遍历子控件，重复前面的两个步骤（所谓从后往前遍历子控件，就是首先查找子控件数组中最后一个元素，然后执行1、2步骤）
4.view，比如叫做fitView，那么会把这个事件交给这个fitView，再遍历这个fitView的子控件，直至没有更合适的view为止。
5.如果没有符合条件的子控件，那么就认为自己最合适处理这个事件，也就是自己是最合适的view
</code></pre>

<h2>事件的传递和响应的区别：</h2>

<ul>
<li>事件的传递是从上到下（父控件到子控件），事件的响应是从下到上（顺着响应者链条向上传递：子控件到父控件。</li>
</ul>


<h3>事件响应</h3>

<h5>响应者链的事件传递过程:</h5>

<pre><code>1&gt;如果当前view是控制器的view，那么控制器就是上一个响应者，事件就传递给控制器；如果当前view不是控制器的view，那么父视图就是当前view的上一个响应者，事件就传递给它的父视图
2&gt;在视图层次结构的最顶级视图，如果也不能处理收到的事件或消息，则其将事件或消息传递给window对象进行处理
3&gt;如果window对象也不处理，则其将事件或消息传递给UIApplication对象
4&gt;如果UIApplication也不能处理该事件或消息，则将其丢弃
</code></pre>

<h3>事件传递</h3>

<h5>事件处理的整个流程总结：</h5>

<pre><code>　　1.触摸屏幕产生触摸事件后，触摸事件会被添加到由UIApplication管理的事件队列中（即，首先接收到事件的是UIApplication）。
　　2.UIApplication会从事件队列中取出最前面的事件，把事件传递给应用程序的主窗口（keyWindow）。
　　3.主窗口会在视图层次结构中找到一个最合适的视图来处理触摸事件。（至此，第一步已完成)
　　4.最合适的view会调用自己的touches方法处理事件
　　5.touches默认做法是把事件顺着响应者链条向上抛。
</code></pre>

<hr />

<h1>代码篇</h1>

<hr />

<h3>Block的底层实现</h3>

<p>一句话:</p>

<pre><code>栈地址和对地址值的拷贝

block就是一个里面存储了指向函数体中包含定义block时的代码块的函数指针，以及block外部上下文变量等信息的结构体。
</code></pre>

<p>Block结构体中含有isa指针，这就证明了Block其实就是对象，并具有一般对象的所有功能。这个isa指针被初始化为 <em>NSConcreteStackBlock 或者 </em>NSConcreteGlobalBlock 类的地址。在没有开启ARC的情况下，如果Block中包含有局部变量则isa被初始化为前者，否则就被初始化为后者。而当ARC开启后，如果Block中包含有局部变量则isa被初始化为 <em>NSConcreteMallocBlock ，否则就被初始化为 </em>NSConcreteGlobalBlock 。invoke是一个函数指针，它指向的是Block被转换成函数的地址。最后的imported variables部分是Block需要访问的外部的局部变量，他们在编译就会被拷贝到Block中，这样一来Block就是成为一个闭包了。</p>

<h3>__block底层实现</h3>

<pre><code>一句话：传值 和传址
</code></pre>

<p><strong>block打印C++源码可以看到</strong>Block_byref_a_0结构体，这个结构体中含有isa指针，所以也是一个对象，它是用来包装局部变量a的。当block被copy到堆中时，<strong>Person</strong>test_block_impl_0的拷贝辅助函数<strong>Person</strong>test_block_copy_0会将__Block_byref_a_0拷贝至堆中，所以即使局部变量所在堆被销毁，block依然能对堆中的局部变量进行操作</p>

<pre><code>这样做是为了保证操作的值始终是堆中的拷贝，而不是栈中的值。（处理在局部变量所在栈还没销毁，就调用block来改变局部变量值的情况，如果没有__forwarding指针，则修改无效）
</code></pre>

<hr />

<h1>实战篇</h1>

<hr />

<h2>KVO/KVC</h2>

<p>VC/KVO是观察者模式的一种实现，在Cocoa中是以被万物之源NSObject类实现的NSKeyValueCoding/NSKeyValueObserving非正式协议的形式被定义为基础框架的一部分。从协议的角度来说，KVC/KVO本质上是定义了一套让我们去遵守和实现的方法。
当然，KVC/KVO实现的根本是Objective-C的动态性和runtime，这在后文的原理部分会有详述。
另外，KVC/KVO机制离不开访问器方法的实现，这在后文中也有解释。</p>

<p>1、KVC简介</p>

<pre><code>全称是Key-value coding，翻译成键值编码。顾名思义，在某种程度上跟map的关系匪浅。它提供了一种使用字符串而不是访问器方法去访问一个对象实例变量的机制。
</code></pre>

<p>2、KVO简介</p>

<pre><code>全称是Key-value observing，翻译成键值观察。提供了一种当其它对象属性被修改的时候能通知当前对象的机制。再MVC大行其道的Cocoa中，KVO机制很适合实现model和controller类之间的通讯。
</code></pre>

<h3>KVO的底层实现（基于KVC-》运行时）</h3>

<p>当某个类的对象第一次被观察时，系统就会在运行期动态地创建该类的一个派生类，在这个派生类中重写基类中任何被观察属性的 setter 方法。</p>

<pre><code>派生类在被重写的 setter 方法实现真正的通知机制，就如前面手动实现键值观察那样。这么做是基于设置属性会调用 setter 方法，而通过重写就获得了 KVO 需要的通知机制。当然前提是要通过遵循 KVO 的属性设置方式来变更属性值，如果仅是直接修改属性对应的成员变量，是无法实现 KVO 的。

同时派生类还重写了 class 方法以“欺骗”外部调用者它就是起初的那个类。然后系统将这个对象的 isa 指针指向这个新诞生的派生类，因此这个对象就成为该派生类的对象了，因而在该对象上对 setter 的调用就会调用重写的 setter，从而激活键值通知机制。此外，派生类还重写了 dealloc 方法来释放资源
</code></pre>

<p>isa指针指向的其实是类的元类，如果之前的类名为：Person，那么被runtime更改以后的类名会变成：NSKVONotifying_Person。
新的NSKVONotifying_Person类会重写以下方法：
增加了监听的属性对应的set方法，class，dealloc，_isKVOA</p>

<h3>KVC的底层实现</h3>

<p>KVC运用了一个isa-swizzling技术。isa-swizzling就是类型混合指针机制。KVC主要通过isa-swizzling，来实现其内部查找定位的。isa指针，如其名称所指，（就是is a kind of的意思），指向维护分发表的对象的类。该分发表实际上包含了指向实现类中的方法的指针，和其它数据。</p>

<p>一个对象在调用setValue的时候，</p>

<ul>
<li>（1）首先根据方法名找到运行方法的时候所需要的环境参数。</li>
<li>（2）他会从自己isa指针结合环境参数，找到具体的方法实现的接口。</li>
<li>（3）再直接查找得来的具体的方法实现。</li>
</ul>


<hr />

<h1>高级</h1>

<hr />

<h3>GCD底层实现</h3>

<p>GCD内部是怎么实现的</p>

<ul>
<li>1 IOS和OS X的核心是XNU内核，GCD是基于XUN内核实现的</li>
<li>2 GCD的API全部在libdispatch库中</li>
<li><p>3 GCD的底层实现主要有Dispatch Queue 和Dispatch Source</p>

<ul>
<li>Dispatch Queue ：管理block操作</li>
<li>Dispatch Source :处理事件(比如线程间通信)</li>
</ul>
</li>
</ul>


<p>NSOperationQueue 和GCD的区别和类似的地方</p>

<ul>
<li>1 GCD是纯C语言的API， NSOperationQueue是基于GCD的OC版本封装</li>
<li>2 GCD只支持FIFO的队列，NSOperationQueue可以很方便地调整执行顺序 设置最大并发数量</li>
<li>3 NSOperationQueue 可以轻松地在operation 间设置依赖关系，而GCD需要写很多的代码</li>
<li>4 NSOperationQueue支持KVO，可以监测operation是否正在执行(is Executed),是否结束(is finished),是否取消( is canceld);</li>
<li>5 GCD的执行速度比NSOperationQueue快</li>
</ul>


<hr />

<h1>全栈篇</h1>

<hr />

<h3>JSpatch底层实现</h3>

<p>JSPatch 能做到通过 JS 调用和改写 OC 方法最根本的原因是 Objective-C 是动态语言，OC 上所有方法的调用/类的生成都通过 Objective-C Runtime 在运行时进行，我们可以通过类名/方法名反射得到相应的类和方法：</p>

<pre><code>Class class = NSClassFromString("UIViewController");
id viewController = [[class alloc] init];
SEL selector = NSSelectorFromString("viewDidLoad");
[viewController performSelector:selector];
</code></pre>

<p>也可以替换某个类的方法为新的实现：</p>

<pre><code>static void newViewDidLoad(id slf, SEL sel) {}
class_replaceMethod(class, selector, newViewDidLoad, @"");
</code></pre>

<p>还可以新注册一个类，为类添加方法：</p>

<pre><code>Class cls = objc_allocateClassPair(superCls, "JPObject", 0);
objc_registerClassPair(cls);
class_addMethod(cls, selector, implement, typedesc);
</code></pre>

<p>对于 Objective-C 对象模型和动态消息发送的原理已有很多文章阐述得很详细，这里就不详细阐述了。理论上你可以在运行时通过类名/方法名调用到任何 OC 方法，替换任何类的实现以及新增任意类。所以 JSPatch 的基本原理就是：JS 传递字符串给 OC，OC 通过 Runtime 接口调用和替换 OC 方法。这是最基础的原理，实际实现过程还有很多怪要打，接下来看看具体是怎样实现的。</p>

<h6>总结：</h6>

<p>使用JS利用OC的动态特性，执行我们想要执行的代码</p>

<h3>React Native</h3>

<p>RN主要的通信在于java与js之间，平常我们写的jsx代码最终会调用到原生的View。上一篇博客我们也了解到了要新建一个原生模块需要在java层和js层分别写一个Module</p>

<p>特点：</p>

<ul>
<li><p>可以基于 React Native使用 JavaScript 编写应用逻辑，UI 则可以保持全是原生的。这样的话就没有必要就 HTML5 的 UI 做出常见的妥协；</p></li>
<li><p>React 引入了一种与众不同的、略显激进但具备高可用性的方案来构建用户界面。长话短说，应用的 UI 简单通过一个基于应用目前状态的函数来表达。</p></li>
</ul>


<p>RN总共分为三层，java层，C++层，js层</p>

<ul>
<li>Java层：java层就是app原生代码，它通过启动C++层的javascript解析器javascriptCore来执行js代码，从而构建原生UI等。java层依赖于众多优秀开源库，在图片处理使用的是Fresco，网络通信使用的是okhttp，Json解析工具用jackson,动画库用NineOldAndroids等，在java层原生的功能均封装为Module，如Toast和Log等。</li>
<li>C++层：c++层最主要是封装了JavaScriptCore，它是一个全新的支持ES6的webKit。Bridge连接了java与js之间的通信。解析js文件是通过JSCExectutor进行的。</li>
<li>Js层：主要处理事件分发及UI Layout，平常开发最常用的。通用jsx来写业务代码，通过flexbox来实现布局。不依赖DOM。由于react有 DOM diff这个算法，所以它的效率非常高。
通信机制</li>
</ul>


<p>在Java层与Js层的bridge分别存有相同一份模块配置表，Java与Js互相通信时，通过将里配置表中的moduleID，methodID转换成json数据的形式传递给到C++层，C++层传送到js层，通过js层的的模块配置表找到对应的方法进行执行，如果有callback，则回传给java层。这里只是大概介绍。</p>

<p>总结：</p>

<ul>
<li>在程序启动的时候，首先会调用ReactActivity的onCreate函数中，我们会去创建一个ReactInstanceManagerImpl对象。通过ReactRootView的startReactApplication方法开启整个RN世界的大门。</li>
<li>在这个方法中，我们会通过一个AsyncTask去创建ReactContext</li>
<li>在创建ReactContext中，我们把我们自己注入和CoreModulesPackage通过processPackage方法将其中的各个modules注入到了对应的Registry中。最后通过CatalystInstanceImpl中的ReactBridge将NativeModule和JSModule注册表通过jni传输到了JS层。</li>
<li>java调用js时，会在ReactApplicationContext创建的时候存入注册表类JavaScriptModuleRegistry中，同时通过动态代理生成代理实例，并在代理拦截类JavaScriptModuleInvocationHandler中统一处理发向Javascript的所有通信请求。</li>
<li>JSCExecutor将所有来自Java层的通信请求封装成Javascript执行语句。</li>
<li>接着在js层中的MessageQueue里匹配ModuleId和MethodId。找到调用模块。</li>
<li>如果是js层调用java层，js最终都会调用<em>_nativeCall方法，通过flushedQueue将this.</em>queue返回给Bridger。</li>
<li>C++层调用PlatformBridgeCallback对象的onCallNativeModules方法，执行makeJavaCall方法，里面最终通过env->CallVoidMethod调用了Java层的方法。</li>
<li>调用Java层NativeModulesReactCallback的call方法，通过moduleID从保存在其内部的NativeModule映射表，匹配到需要被执行的NativeModule对象，再通过methodID匹配到所要调用的方法。通过invoke反射方式执行NativeModule的方法。</li>
</ul>


<hr />

<h1>必备篇</h1>

<hr />

<h5>多线程</h5>

<h5>网络</h5>

<h5>数据持久化</h5>

<hr />

<hr />

<h1>通用篇</h1>

<hr />

<h5>数组</h5>

<h5>字典</h5>

<h5>集合</h5>

<hr />

<p>更新中，敬请关注。。。。。。</p>

<pre><code>Q Q：2211523682/790806573

微信：18370997821/13148454507

微博WB:http://weibo.com/u/3288975567?is_hot=1

git博文：http://al1020119.github.io/

github：https://github.com/al1020119
</code></pre>

<p><img src="/images/iCocosCoder.jpg" title="Caption" ></p>

<p><img src="/images/iCocosPublic.jpg" title="Caption" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[第三方支付总结]]></title>
    <link href="http://al1020119.github.io/blog/2016/01/18/disanfangzhifu/"/>
    <updated>2016-01-18T11:35:08+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/01/18/disanfangzhifu</id>
    <content type="html"><![CDATA[<p>引言：
随着移动互联的发展，支付功能越来越流行，这也使得各大app公司不得不集成相关支付功能，文本就就此谈谈支付相关。</p>

<p>本文源码源码（封装）<a href="https://github.com/al1020119/iCocosPay">iCocosPay</a>（内集常见支付方案：成支付宝，微信，银联）</p>

<p>目录</p>

<ul>
<li>常见支付方案</li>
<li>第三方支付SDK</li>
<li>苹果官方支付方案</li>
<li>web支付方案</li>
</ul>


<!--more-->


<h2>一:常见支付方案</h2>

<p>先来看一组截图</p>

<p><img src="/images/zhifu001.png" title="Caption" ></p>

<p><img src="/images/zhifu002.png" title="Caption" ></p>

<p><img src="/images/zhifu003.png" title="Caption" ></p>

<p><img src="/images/zhifu004.png" title="Caption" ></p>

<p><img src="/images/zhifu005.png" title="Caption" ></p>

<ul>
<li><p>微信支付</p></li>
<li><p>支付宝支付</p></li>
<li><p>银联（快捷）支付</p></li>
<li><p>京东支付</p></li>
<li><p>百度钱包</p></li>
<li><p>web支付</p></li>
<li><p>QQ钱包支付</p></li>
<li><p>连连支付</p></li>
</ul>


<p>￼￼￼￼
整理图：</p>

<p><img src="/images/zhifu006.png" title="Caption" ></p>

<h2>二：最常见的三种支付方式</h2>

<ul>
<li>微信支付SDK</li>
<li>支付宝支付SDK</li>
<li>银联快捷支付SDK</li>
</ul>


<h4>微信</h4>

<h5>什么是微信支付</h5>

<p>微信支付是集成在微信客户端的支付功能，用户可以通过手机完成快速的支付流程。微信支付以绑定银行卡的快捷支付为基础，向用户提供安全、快捷、高效的支付服务。</p>

<h5>申请流程：</h5>

<p>第一阶段：</p>

<p><img src="/images/zhifu007.png" title="Caption" ></p>

<p>第二阶段：</p>

<p><img src="/images/zhifu008.png" title="Caption" ></p>

<p>第三阶段：</p>

<p><img src="/images/zhifu009.png" title="Caption" ></p>

<h5>应用场景：</h5>

<p>商户APP调用微信提供的SDK调用微信支付模块，商户APP会跳转到微信中完成支付，支付完后跳回到商户APP内，最后展示支付结果。</p>

<h5>支付流程</h5>

<p>App内提交订单（确认支付）
商品信息确认（立即支付）
输入密码（进行支付）
支付成功</p>

<h5>App接入步骤</h5>

<p><img src="/images/zhifu010.png" title="Caption" ></p>

<h4>支付宝</h4>

<h5>什么是支付宝支付：</h5>

<p>支付宝移动支付是一种程序式的支付方式，在手机、掌上电脑等无线设备的应用程序内，买家可通过支付宝进行付款购买特定服务或商品，资金即时到账。</p>

<h5>申请流程</h5>

<p><img src="/images/zhifu011.png" title="Caption" ></p>

<h5>支付流程：</h5>

<p>买家再手机应用中购买商品或者服务
买家选择支付宝方式支付
进入支付宝收银台进行支付
支付成功
交易完成买家可查看交易信息
返回对应的app界面</p>

<h5>App接入步骤</h5>

<p><img src="/images/zhifu012.png" title="Caption" ></p>

<h4>银联</h4>

<h5>什么值银联支付</h5>

<p><img src="/images/zhifu013.png" title="Caption" ></p>

<h5>申请流程：</h5>

<p><img src="/images/zhifu014.png" title="Caption" ></p>

<h5>支付流程：</h5>

<p><img src="/images/zhifu015.png" title="Caption" ></p>

<h5>接入流程：</h5>

<p><img src="/images/zhifu016.png" title="Caption" ></p>

<h5>最后整理一下具体步骤：</h5>

<ol>
<li>首先客户端浏览商品，点击下单，请求到达商户后台。</li>
<li>商户后台再提交订单信息到银联后台。</li>
<li>银联后台返回交易流水号。</li>
<li>商户后台将交易流水号返回给客户端。</li>
<li>客户端再通过交易流水号启动手机控件开始支付。</li>
<li>支付控件收集支付信息并请求银联后台，完成支付后银联后台通知商户后台支付结果。</li>
<li>银联后台通知支付控件支付结果。</li>
<li>支付控件通知客户端支付结果。</li>
<li>最后客户端将支付结果展示给用户。</li>
</ol>


<h2>三：苹果官方支付方案</h2>

<ul>
<li>IPA</li>
<li>Apple Pay</li>
</ul>


<h3>IPA</h3>

<h5>什么是IPA：</h5>

<p>In App Purchase属于iPhone SDK3.0的新特性，用于在应用程序中购买付费道具，增加新功能，订阅杂志。是应用程序除了植入广告外的另一种取得收益的方式。</p>

<h5>IPA支持的产品类型：</h5>

<p><img src="/images/zhifu017.png" title="Caption" ></p>

<p>IPA两种支付方式：
方式一：内置产品类型</p>

<p><img src="/images/zhifu018.png" title="Caption" >
方式二：服务器类型</p>

<p><img src="/images/zhifu019.png" title="Caption" ></p>

<h5>注意事项：</h5>

<ol>
<li>你必须提供电子类产品和服务。不要使用In App Purchase 去出售实物和实际服务。</li>
<li>不能提供代表中介货币的物品，因为让用户知晓他们购买的商品和服务是很重要的。</li>
</ol>


<h5>相关流程：</h5>

<ol>
<li>程序向服务器发送请求，获得一份产品列表。</li>
<li>服务器返回包含产品标识符的列表。</li>
<li>程序向App Store发送请求，得到产品的信息。</li>
<li>App Store返回产品信息。</li>
<li>程序把返回的产品信息显示给用户（App的store界面）</li>
<li>用户选择某个产品</li>
<li>程序向App Store发送支付请求</li>
<li>App Store处理支付请求并返回交易完成信息。</li>
<li>程序从信息中获得数据，并发送至服务器。</li>
<li>服务器纪录数据，并进行审(我们的)查。</li>
<li>服务器将数据发给App Store来验证该交易的有效性。</li>
<li>App Store对收到的数据进行解析，返回该数据和说明其是否有效的标识。</li>
<li>服务器读取返回的数据，确定用户购买的内容。</li>
<li>服务器将购买的内容传递给程序。</li>
</ol>


<h3>Apple Pay</h3>

<h5>什么是Apple Pay：</h5>

<p>Apple Pay与诸多传统移动支付系统不同，不但有Touch ID指纹识别技术护航，还能在Apple Watch上运作。</p>

<h5>相关流程：</h5>

<ol>
<li>程序通过bundle存储的plist文件得到产品标识符的列表。</li>
<li>程序向App Store发送请求，得到产品的信息。</li>
<li>App Store返回产品信息。</li>
<li>程序把返回的产品信息显示给用户（App的store界面）</li>
<li>用户选择某个产品</li>
<li>程序向App Store发送支付请求</li>
<li>App Store处理支付请求并返回交易完成信息。</li>
<li>App获取信息并提供内容给用户。</li>
</ol>


<h2>四：web支付方案</h2>

<h5>概述：</h5>

<p>iOS中通过UIWebView展示WAP或HTML5支付页面，从而完成支付功能，无需接入额外第三方SDK。
UIWebView是iOS SDK中一个最常用的控件，是内置的浏览器控件，我们可以用它来浏览网页、打开文档等等。</p>

<h5>类型界面：</h5>

<p><img src="/images/zhifu020.png" title="Caption" ></p>

<p>总结：</p>

<p>最后本人根据实际开发整理了一份关于支付的源码（封装）<a href="https://github.com/al1020119/iCocosPay">iCocosPay</a>，内集成了：支付宝支付，微信支付，银联快捷支付！</p>

<p>你是不是在找接口文档？</p>

<ul>
<li><a href="https://pay.weixin.qq.com/wiki/doc/api/index.html">微信支付</a></li>
<li><a href="https://b.alipay.com/order/productDetail.htm?productId=2015110218010538&amp;tabId=1#ps-tabinfo-hashhttp://doc.open.alipay.com/doc2/detail?treeId=59&amp;articleId=103563&amp;docType=1">支付宝支付</a></li>
<li><a href="https://open.unionpay.com/ajweb/index">银联</a></li>
<li><a href="https://b.alipay.com/order/productDetail.htm?productId=2015110218008816https://open.unionpay.com/ajweb/help/file/techFile?productId=66">Web支付</a></li>
<li><a href="https://developer.apple.com/in-app-purchase/">IAP</a></li>
<li><a href="https://developer.apple.com/apple-pay/">Apple Pay</a></li>
</ul>


<hr />

<pre><code>Q Q：2211523682/790806573

微信：18370997821/13148454507

微博WB:http://weibo.com/u/3288975567?is_hot=1

git博文：http://al1020119.github.io/

github：https://github.com/al1020119
</code></pre>

<p><img src="/images/iCocosCoder.jpg" title="Caption" ></p>

<p><img src="/images/iCocosPublic.jpg" title="Caption" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[重量级-MVC-MVVM-DC]]></title>
    <link href="http://al1020119.github.io/blog/2016/01/01/zhong-liang-ji/"/>
    <updated>2016-01-01T16:21:08+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/01/01/zhong-liang-ji</id>
    <content type="html"><![CDATA[<p>首先再这里祝大家新年快乐&hellip;&hellip;.</p>

<p>新的一年来点重量级的东西，那么是什么呢？</p>

<p>相信你既然能看到这篇文章，那么一定听说过MVC，什么没有听过？出门左转找度娘，不送！</p>

<p>如果你听说过MVC，那么或许你听说过MVVM，这里可能很多人对MVVM并不了解，或许只是听过，但是没有用过，有些就算用过还是不清楚里面的关系，只是搬砖而已。</p>

<p>对了，今天我们讨论的就是一个类MVVM的技术，也就是在MVVM上面的一个增强版的开发模式！</p>

<p>MVVM不正是MVC的增强版吗？</p>

<p>好了下面正式开始，新年不能耽误大家太多时间搬砖，，哈哈！</p>

<h2>Model-View-Controller</h2>

<!--more-->


<p>首先我们来看看MVC，这里MVC具体细节就不多说了。</p>

<ul>
<li>Model(M)：模型数据</li>
<li>View(V)：视图</li>
<li>Controller&copy;：控制器</li>
</ul>


<p><img src="/images/zhongliangji001.png" title="Caption" ></p>

<h6>有点：</h6>

<ul>
<li>易学习</li>
<li>易开发</li>
<li>同哟欧诺个成熟</li>
</ul>


<h6>缺点：</h6>

<ul>
<li>Massive View Controller</li>
</ul>


<h2>Model-View-ViewModel</h2>

<p>然后来看看现在比较热得话题（架构）MVVM
* Model（M）:模型
* View(V）:视图
* ViewModel（VM）:模型（逻辑）</p>

<p><img src="/images/zhongliangji002.png" title="Caption" ></p>

<h6>View与ViewModule连接可以通过下面的方式</h6>

<ul>
<li><p>Binding Data：实现数据的传递</p></li>
<li><p>Command：实现操作的调用</p></li>
<li><p>AttachBehavior：实现控件加载过程中的操作</p></li>
</ul>


<h5>View没有大量代码逻辑。</h5>

<ul>
<li><p>结合WPF、Silverlight绑定机制，MVP演变出了MVVM，充分利用了WPF、Silverlight的优势，将大量代码逻辑、状态转到ViewModel，可以说MVVM是专门为WPF、Silverlight打造的。</p></li>
<li><p>View绑定到ViewModel，然后执行一些命令在向它请求一个动作。而反过来，ViewModel跟Model通讯，告诉它更新来响应UI。这样便使得为应用构建UI非常的容易。往一个应用程序上贴一个界面越容易，外观设计师就越容易使用Blend来创建一个漂亮的界面。同时，当UI和功能越来越松耦合的时候，功能的可测试性就越来越强。</p></li>
</ul>


<h6>优点：</h6>

<ul>
<li>减轻ViewController的负担</li>
<li>提高了测试性</li>
<li>强大的绑定机制</li>
</ul>


<h6>缺点：</h6>

<ul>
<li>极高的学习成本和开发成本</li>
<li>数据绑定是的bug更难调试</li>
<li>View Model的职责任然很重</li>
<li>据本人了解，MVVM结合RAC使用能够发挥最大的效率</li>
</ul>


<p>总上我们可以得知：</p>

<ul>
<li>每个V都有一个对应的VM，V的数据展示盒样式都由其定制</li>
<li>不引入双想绑定机制或者观察机制，而是通过传统的代理回调或者通知将UI事件传给外界</li>
<li>VC只负责将VM装配给V，接受UI事件</li>
</ul>


<p>或许细心地能发现下面的好处</p>

<ul>
<li>View可以完全解耦，只需要确定好ViewModel和回调接口即可</li>
<li>View Controller层可以尽可能少得和View的具体表现打交道，将这不分职责转给了View Model，减轻了* View Controller的负担</li>
<li>使用回调的传统回调机制，学习成本低，数据和事件流入和流出易观察而且更易控制，降低维护和回调成本</li>
</ul>


<h2>Model-View-ViewModel-DataController-Model</h2>

<p>好了重量级的东西来了，MVVM-DM（MVVM Without Binding With Data Controller）</p>

<ul>
<li>Model（M）:模型</li>
<li>View(V）:视图</li>
<li>ViewModel（VM）:加工后的数据）</li>
<li>Data Controller：相关逻辑</li>
<li>Model：对应Data Controller</li>
</ul>


<p><img src="/images/zhongliangji003.png" title="Caption" ></p>

<p>或许有些人看到上面的文字就能知道我本文的含义了，对没错，就是为了解决MVVM中View Model臃肿情况！</p>

<h6>优点：</h6>

<ul>
<li>避免了传统的MVVM架构VM层有可能变得臃肿的情况，更加清晰的模块职责</li>
<li>业务逻辑解耦，数据的加工和处理都放在Data Controller中，View Controiller不用关心数据如何获得，如何处理，Data Controller不用关心界面如何展示，如何交互</li>
<li>Data Controller与界面无关，所以可以有更好的可测试性和可服用性</li>
</ul>


<h6>缺点：</h6>

<p>暂时没有发现（难度：一下比较难接受）</p>

<h4>具体思路是：</h4>

<ul>
<li>1.每个Viewcontroller会有一个对应的Data Controller（包含页面的所有相关逻辑：View Related data Controller） ，在View的ViewDidLoad方法中初始化View，layoutSubViews中布局</li>
<li>2.Viewcongtroller向Data Controller发送请求，Data Controller包含只是纯粹的Model相关逻辑（当然你也可以复用更小的Data Controller）如：网络请求，数据持久（请求），数据加工，其他。</li>
<li>3.Data Controller将请求到得数据加工返回给View Controller</li>
<li>4.View Controller将Data Controller返回的加工好的数据生成ViewModel（展示View所需要的数据），</li>
<li>5.View Controller协调控制并将生成的View Model装配到View（每个View都有一个对应的View Model，可以有子View Model）上面显示，这里相当于使用ViewModel数据来渲染界面</li>
</ul>


<p>综上：</p>

<ul>
<li>将处理数据和获取数据的职责从传统的MVVM的Vm中抽取出来，成为Data Controller</li>
<li>VC请求数据和将一些数据修改的事件（可以是UI事件触发）传递给Data Controller</li>
<li>Data Controller收到VC的请求后，向M获取数据和更新数据，并将加工后的数据返回</li>
<li>Data Controller还负责网络层和持久化层的逻辑</li>
</ul>


<blockquote><p>总结：</p>

<ul>
<li>层次清晰，职责明确。</li>
<li>耦合性低，复用性高</li>
<li>测试性高</li>
<li>低学习成本，低开发成本</li>
<li>高实施性，无需整体重构</li>
</ul>
</blockquote>

<p>本文借鉴猿题库客户端架构设计，最后附上<a href="blog.devtang.com">唐巧大V</a>得博客，以表敬意</p>

<p>参考：
<a href="https://mp.weixin.qq.com/s?__biz=MjM5NTIyNTUyMQ==&amp;mid=444322139&amp;idx=1&amp;sn=c7bef4d439f46ee539aa76d612023d43&amp;scene=1&amp;srcid=1230NOb8TaHKmwxS9l8H6ctl&amp;key=62bb001fdbc364e5a1bc589b94bd5aded40e489b2517710a1807b2d4f9e3f8a64fe2eed72590fd83cda13ebebec3002f&amp;ascene=0&amp;uin=MjMzNjU5MzYyMQ%3D%3D&amp;devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build%2814F27%29&amp;version=11020201&amp;pass_ticket=5ku6y9zhut5EyBt%2Bg%2FbjIWyq9HCDh4DuNn5XU5p4pwFMaKTtMfZYlkkNnlZDh11C">猿题库 iOS 客户端架构设计</a></p>

<hr />

<pre><code>Q Q：2211523682/790806573

微信：18370997821/13148454507

微博WB:http://weibo.com/u/3288975567?is_hot=1

git博文：http://al1020119.github.io/

github：https://github.com/al1020119
</code></pre>

<p><img src="/images/iCocosCoder.jpg" title="Caption" ></p>

<p><img src="/images/iCocosPublic.jpg" title="Caption" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[网络请求疯（封）装]]></title>
    <link href="http://al1020119.github.io/blog/2015/08/25/wang-shang-qing-qiu-feng-(feng-)zhuang/"/>
    <updated>2015-08-25T09:37:30+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/08/25/wang-shang-qing-qiu-feng-(feng-)zhuang</id>
    <content type="html"><![CDATA[<p>一直想总结一下关于iOS的离线数据缓存的方面的问题，然后最近也简单的对AFN进行了再次封装，所有想把这两个结合起来写一下。数据展示型的页面做离线缓存可以有更好的用户体验，用户在离线环境下仍然可以获取一些数据，这里的数据缓存首选肯定是SQLite，轻量级，对数据的存储读取相对于其他几种方式有优势，这里对AFN的封装没有涉及太多业务逻辑层面的需求，主要还是对一些方法再次封装方便使用，解除项目对第三方的耦合性，能够简单的快速的更换底层使用的网络请求代码。这篇主要写离线缓存思路，对AFN的封装只做简单的介绍。</p>

<p>关于XLNetworkApi</p>

<!--more-->


<p>XLNetworkApi的一些功能和说明：</p>

<p>使用XLNetworkRequest做一些GET、POST、PUT、DELETE请求，与业务逻辑对接部分直接以数组或者字典的形式返回。
以及网络下载、上传文件，以block的形式返回实时的下载、上传进度，上传文件参数通过模型XLFileConfig去存取。
通过继承于XLDataService来将一些数据处理，模型转化封装起来，于业务逻辑对接返回的是对应的模型，减少Controllor处理数据处理逻辑的压力。
自定义一些回调的block</p>

<pre><code>/**
请求成功block
*/
typedef void (^requestSuccessBlock)(id responseObj);
/**
请求失败block
*/
typedef void (^requestFailureBlock) (NSError *error);
/**
请求响应block
*/
typedef void (^responseBlock)(id dataObj, NSError *error);
/**
监听进度响应block
*/
typedef void (^progressBlock)(int64_t bytesWritten, int64_t totalBytesWritten, int64_t totalBytesExpectedToWrite);
XLNetworkRequest.m部分实现
#import "XLNetworkRequest.h"
#import "AFNetworking.h"
@implementation XLNetworkRequest
+ (void)getRequest:(NSString *)url params:(NSDictionary *)params success:(requestSuccessBlock)successHandler failure:(requestFailureBlock)failureHandler {
//网络不可用
  if (![self checkNetworkStatus]) {
      successHandler(nil);
      failureHandler(nil);
      return;
  }
  AFHTTPRequestOperationManager *manager = [self getRequstManager];
  [manager GET:url parameters:params success:^(AFHTTPRequestOperation * _Nonnull operation, id  _Nonnull responseObject) {
      successHandler(responseObject);
  } failure:^(AFHTTPRequestOperation * _Nullable operation, NSError * _Nonnull error) {
      XLLog(@"------请求失败-------%@",error);
      failureHandler(error);
  }];
}
</code></pre>

<p>下载部分代码</p>

<pre><code>    //下载文件，监听下载进度
    + (void)downloadRequest:(NSString *)url successAndProgress:(progressBlock)progressHandler complete:(responseBlock)completionHandler {
      if (![self checkNetworkStatus]) {
          progressHandler(0, 0, 0);
          completionHandler(nil, nil);
          return;
      }
      NSURLSessionConfiguration *sessionConfiguration = [NSURLSessionConfiguration defaultSessionConfiguration];
      AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:sessionConfiguration];
      NSURLRequest *request = [NSURLRequest requestWithURL:[NSURL URLWithString:url]];
      NSProgress *kProgress = nil;
      NSURLSessionDownloadTask *downloadTask = [manager downloadTaskWithRequest:request progress:&amp;kProgress destination:^NSURL * _Nonnull(NSURL * _Nonnull targetPath, NSURLResponse * _Nonnull response) {
          NSURL *documentUrl = [[NSFileManager defaultManager] URLForDirectory :NSDocumentDirectory inDomain:NSUserDomainMask appropriateForURL:nil create:NO error:nil];
          return [documentUrl URLByAppendingPathComponent:[response suggestedFilename]];
      } completionHandler:^(NSURLResponse * _Nonnull response, NSURL * _Nonnull filePath, NSError * _Nonnull error){
          if (error) {
              XLLog(@"------下载失败-------%@",error);
          }
          completionHandler(response, error);
      }];
      [manager setDownloadTaskDidWriteDataBlock:^(NSURLSession * _Nonnull session, NSURLSessionDownloadTask * _Nonnull downloadTask, int64_t bytesWritten, int64_t totalBytesWritten, int64_t totalBytesExpectedToWrite) {
          progressHandler(bytesWritten, totalBytesWritten, totalBytesExpectedToWrite);
      }];
      [downloadTask resume];
    }
</code></pre>

<p>上传部分代码</p>

<pre><code>//上传文件，监听上传进度
+ (void)updateRequest:(NSString *)url params:(NSDictionary *)params fileConfig:(XLFileConfig *)fileConfig successAndProgress:(progressBlock)progressHandler complete:(responseBlock)completionHandler {
  if (![self checkNetworkStatus]) {
      progressHandler(0, 0, 0);
      completionHandler(nil, nil);
      return;
  }
  NSMutableURLRequest *request = [[AFHTTPRequestSerializer serializer] multipartFormRequestWithMethod:@"POST" URLString:url parameters:params constructingBodyWithBlock:^(id  _Nonnull formData) {
      [formData appendPartWithFileData:fileConfig.fileData name:fileConfig.name fileName:fileConfig.fileName mimeType:fileConfig.mimeType];
  } error:nil];
  //获取上传进度
  AFHTTPRequestOperation *operation = [[AFHTTPRequestOperation alloc] initWithRequest:request];
  [operation setUploadProgressBlock:^(NSUInteger bytesWritten, long long totalBytesWritten, long long totalBytesExpectedToWrite) {
      progressHandler(bytesWritten, totalBytesWritten, totalBytesExpectedToWrite);
  }];
  [operation setCompletionBlockWithSuccess:^(AFHTTPRequestOperation * _Nonnull operation, id  _Nonnull responseObject) {
      completionHandler(responseObject, nil);
  } failure:^(AFHTTPRequestOperation * _Nonnull operation, NSError * _Nonnull error) {
      completionHandler(nil, error);
      if (error) {
          XLLog(@"------上传失败-------%@",error);
      }
  }];
  [operation start];
}
</code></pre>

<p>XLDataService.m部分实现</p>

<pre><code>+ (void)getWithUrl:(NSString *)url param:(id)param modelClass:(Class)modelClass responseBlock:(responseBlock)responseDataBlock {
      [XLNetworkRequest getRequest:url params:param success:^(id responseObj) {
      //数组、字典转化为模型数组
      dataObj = [self modelTransformationWithResponseObj:responseObj modelClass:modelClass];
      responseDataBlock(dataObj, nil);
  } failure:^(NSError *error) {
      responseDataBlock(nil, error);
  }];
}
</code></pre>

<p>（关键）下面这个方法提供给继承XLDataService的子类重写，将转化为模型的代码写在这里，相似业务的网络数据请求都可以用这个子类去请求数据，直接返回对应的模型数组。
    /<em>*
    数组、字典转化为模型
    </em>/
    + (id)modelTransformationWithResponseObj:(id)responseObj modelClass:(Class)modelClass {
         return nil;
    }
关于离线数据缓存</p>

<p>当用户进入程序的展示页面，有三个情况下可能涉及到数据库存取操作，简单画了个图来理解，思路比较简单，主要是一些存取的细节处理。</p>

<p>进入展示页面</p>

<p><img src="/images/net001.png" title="Caption" ></p>

<p>下拉刷新最新数据</p>

<p><img src="/images/net002.png" title="Caption" ></p>

<p>上拉加载更多数据</p>

<p><img src="/images/net003.png" title="Caption" ></p>

<p>需要注意的是，上拉加载更多的时候，每次从数据库返回一定数量的数据，而不是一次性将数据全部加载，否则会有内存问题，直到数据库中没有更多数据时再发生网络请求，再次将新数据存入数据库。这里存储数据的方式是将服务器返回每组数据的字典归档成二进制作为数据库字段直接存储，这样存储在模型属性比较多的情况下更有好处，避免每一个属性作为一个字段，另外增加了一个idStr字段用来判断数据的唯一性，避免重复存储。
首先定义一个工具类XLDataBase来做数据库相关的操作，这里用的是第三方的FMDB。</p>

<pre><code>#import "XLDataBase.h"
#import "FMDatabase.h"
#import "Item.h"
#import "MJExtension.h"
@implementation XLDataBase
static FMDatabase *_db;
+ (void)initialize {
    NSString *path = [NSString stringWithFormat:@"%@/Library/Caches/Data.db",NSHomeDirectory()];
    _db = [FMDatabase databaseWithPath:path];
    [_db open];
    [_db executeUpdate:@"CREATE TABLE IF NOT EXISTS t_item (id integer PRIMARY KEY, itemDict blob NOT NULL, idStr text NOT NULL)"];
}
//存入数据库
+ (void)saveItemDict:(NSDictionary *)itemDict {
    //此处把字典归档成二进制数据直接存入数据库，避免添加过多的数据库字段
    NSData *dictData = [NSKeyedArchiver archivedDataWithRootObject:itemDict];
    [_db executeUpdateWithFormat:@"INSERT INTO t_item (itemDict, idStr) VALUES (%@, %@)",dictData, itemDict[@"id"]];
}
//返回全部数据
+ (NSArray *)list {
    FMResultSet *set = [_db executeQuery:@"SELECT * FROM t_item"];
    NSMutableArray *list = [NSMutableArray array];
    while (set.next) {
        // 获得当前所指向的数据
        NSData *dictData = [set objectForColumnName:@"itemDict"];
        NSDictionary *dict = [NSKeyedUnarchiver unarchiveObjectWithData:dictData];
        [list addObject:[Item mj_objectWithKeyValues:dict]];
    }
    return list;
}
//取出某个范围内的数据
+ (NSArray *)listWithRange:(NSRange)range {
    NSString *SQL = [NSString stringWithFormat:@"SELECT * FROM t_item LIMIT %lu, %lu",range.location, range.length];
    FMResultSet *set = [_db executeQuery:SQL];
    NSMutableArray *list = [NSMutableArray array];
    while (set.next) {
        NSData *dictData = [set objectForColumnName:@"itemDict"];
        NSDictionary *dict = [NSKeyedUnarchiver unarchiveObjectWithData:dictData];
        [list addObject:[Item mj_objectWithKeyValues:dict]];
    }
    return list;
}
//通过一组数据的唯一标识判断数据是否存在
+ (BOOL)isExistWithId:(NSString *)idStr
{
    BOOL isExist = NO;
    FMResultSet *resultSet= [_db executeQuery:@"SELECT * FROM t_item where idStr = ?",idStr];
    while ([resultSet next]) {
        if([resultSet stringForColumn:@"idStr"]) {
            isExist = YES;
        }else{
            isExist = NO;
        }
    }
    return isExist;
}
@end
</code></pre>

<p>一些继承于XLDataService的子类的数据库存储和模型转换的逻辑代码</p>

<pre><code>#import "GetTableViewData.h"
#import "XLDataBase.h"
@implementation GetTableViewData
//重写父类方法
+ (id)modelTransformationWithResponseObj:(id)responseObj modelClass:(Class)modelClass {
    NSArray *lists = responseObj[@"data"][@"list"];
    NSMutableArray *array = [NSMutableArray array];
    for (NSDictionary *dict in lists) {
        [modelClass mj_setupReplacedKeyFromPropertyName:^NSDictionary *{
            return @{ @"ID" : @"id" };
        }];
        [array addObject:[modelClass mj_objectWithKeyValues:dict]];
        //通过idStr先判断数据是否存储过，如果没有，网络请求新数据存入数据库
        if (![XLDataBase isExistWithId:dict[@"id"]]) {
            //存数据库
            NSLog(@"存入数据库");
            [XLDataBase saveItemDict:dict];
        }
    }
    return array;
}
</code></pre>

<p>下面是一些控制器的代码实现：</p>

<pre><code>#import "ViewController.h"
#import "GetTableViewData.h"
#import "Item.h"
#import "XLDataBase.h"
#import "ItemCell.h"
#import "MJRefresh.h"
#define URL_TABLEVIEW @"https://api.108tian.com/mobile/v3/EventList?cityId=1&amp;step=10&amp;theme=0&amp;page=%lu"
@interface ViewController () {
    NSMutableArray *_dataArray;
    UITableView *_tableView;
    NSInteger _currentPage;//当前数据对应的page
}
@end
@implementation ViewController
#pragma mark Life cycle
- (void)viewDidLoad {
    [super viewDidLoad];
    // Do any additional setup after loading the view, typically from a nib.
    [self createTableView];
    _dataArray = [NSMutableArray array];
}
- (void)viewWillAppear:(BOOL)animated {
    [super viewWillAppear:animated];
    NSRange range = NSMakeRange(0, 10);
    //如果数据库有数据则读取，不发送网络请求
    if ([[XLDataBase listWithRange:range] count]) {
        [_dataArray addObjectsFromArray:[XLDataBase listWithRange:range]];
        NSLog(@"从数据库加载");
    }else{
        [self getTableViewDataWithPage:0];
    }
}
#pragma mark UI
- (void)createTableView {
    _tableView = [[UITableView alloc] initWithFrame:self.view.bounds];
    _tableView.delegate = self;
    _tableView.dataSource = self;
    _tableView.rowHeight = 100.0;
    [self.view addSubview:_tableView];
    _tableView.mj_header = [MJRefreshNormalHeader headerWithRefreshingBlock:^{
        [self loadNewData];
    }];
    _tableView.mj_footer = [MJRefreshAutoNormalFooter footerWithRefreshingBlock:^{
        [self loadMoreData];
    }];
}
#pragma mark GetDataSoure
- (void)getTableViewDataWithPage:(NSInteger)page {
    NSLog(@"发送网络请求！");
    NSString *url = [NSString stringWithFormat:URL_TABLEVIEW, page];
    [GetTableViewData getWithUrl:url param:nil modelClass:[Item class] responseBlock:^(id dataObj, NSError *error) {
        [_dataArray addObjectsFromArray:dataObj];
        [_tableView reloadData];
        [_tableView.mj_header endRefreshing];
        [_tableView.mj_footer endRefreshing];
    }];
}
- (void)loadNewData {
    NSLog(@"下拉刷新");
    _currentPage = 0;
    [_dataArray removeAllObjects];
    [self getTableViewDataWithPage:_currentPage];
}
- (void)loadMoreData {
    NSLog(@"上拉加载");
    _currentPage ++;
    NSRange range = NSMakeRange(_currentPage * 10, 10);
    if ([[XLDataBase listWithRange:range] count]) {
        [_dataArray addObjectsFromArray:[XLDataBase listWithRange:range]];
        [_tableView reloadData];
        [_tableView.mj_footer endRefreshing];
        NSLog(@"数据库加载%lu条更多数据",[[XLDataBase listWithRange:range] count]);
    }else{
        //数据库没更多数据时再网络请求
        [self getTableViewDataWithPage:_currentPage];
    }
}
#pragma mark UITableViewDataSource
- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section {
    return _dataArray.count;
}
- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {
    ItemCell *cell = [ItemCell itemCellWithTableView:tableView];
    cell.item = _dataArray[indexPath.row];
    return cell;
}
@end
</code></pre>

<p>最后附上代码的下载地址，重要的部分代码中都有相应的注释和文字打印，运行程序可以很直观的表现。</p>

<p><a href="https://github.com/ShelinShelin/OffLineCache.git">Demo</a></p>

<p>希望大家能提出一些意见，很乐意与大家互相交流。</p>

<!--more-->

]]></content>
  </entry>
  
</feed>
