<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 底层开发 | iOS梦工厂]]></title>
  <link href="http://al1020119.github.io/blog/categories/di-ceng-kai-fa/atom.xml" rel="self"/>
  <link href="http://al1020119.github.io/"/>
  <updated>2015-12-14T13:53:45+08:00</updated>
  <id>http://al1020119.github.io/</id>
  <author>
    <name><![CDATA[iCocos]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[粘包&amp;封包&amp;拆包]]></title>
    <link href="http://al1020119.github.io/blog/2015/12/09/nian-bao-and-feng-bao-and-chai-bao/"/>
    <updated>2015-12-09T18:11:05+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/12/09/nian-bao-and-feng-bao-and-chai-bao</id>
    <content type="html"><![CDATA[<p>今天偶尔看到了一个关于网络底层的技术，粘包，结果花了一段时间摸索了一下，找了一些资料并总结了一翻，希望有用！</p>

<h3>两个简单概念长连接与短连接：</h3>

<h6>1.长连接</h6>

<pre><code>Client方与Server方先建立通讯连接，连接建立后不断开， 然后再进行报文发送和接收。
</code></pre>

<h6>2.短连接</h6>

<pre><code>Client方与Server每进行一次报文收发交易时才进行通讯连接，交易完毕后立即断开连接。此种方式常用于一点对多点
</code></pre>

<p>通讯，比如多个Client连接一个Server.</p>

<h3>什么时候需要考虑粘包问题?</h3>

<!--more-->


<ul>
<li>1:如果利用tcp每次发送数据，就与对方建立连接，然后双方发送完一段数据后，就关闭连接，这样就不会出现粘包问题（因为只有一种包结构,类似于http协议）。关闭连接主要要双方都发送close连接（参考tcp关闭协议）。如：A需要发送一段字符串给B，那么A与B建立连接，然后发送双方都默认好的协议字符如"hello give me sth abour yourself"，然后B收到报文后，就将缓冲区数据接收,然后关闭连接，这样粘包问题不用考虑到，因为大家都知道是发送一段字符。</li>
<li>2：如果发送数据无结构，如文件传输，这样发送方只管发送，接收方只管接收存储就ok，也不用考虑粘包</li>
<li><p>3：如果双方建立连接，需要在连接后一段时间内发送不同结构数据，如连接后，有好几种结构：</p>

<pre><code>   1)"hello give me sth abour yourself"
   2)"Don't give me sth abour yourself"
</code></pre>

<p> 那这样的话，如果发送方连续发送这个两个包出去，接收方一次接收可能会是"hello give me sth abour yourselfDon&rsquo;t give me sth abour yourself" 这样接收方就傻了，到底是要干嘛？不知道，因为协议没有规定这么诡异的字符串，所以要处理把它分包，怎么分也需要双方组织一个比较好的包结构，所以一般可能会在头加一个数据长度之类的包，以确保接收。</p></li>
</ul>


<h3>粘包出现原因：</h3>

<p>在流传输中出现，UDP不会出现粘包，因为它有消息边界(参考Windows 网络编程)</p>

<ul>
<li>1 发送端需要等缓冲区满才发送出去，造成粘包</li>
<li>2 接收方不及时接收缓冲区的包，造成多个包接收</li>
</ul>


<h4>解决办法：</h4>

<p>为了避免粘包现象，可采取以下几种措施。一是对于发送方引起的粘包现象，用户可通过编程设置来避免，TCP提供了强制数据立即传送的操作指令push，TCP软件收到该操作指令后，就立即将本段数据发送出去，而不必等待发送缓冲区满；二是对于接收方引起的粘包，则可通过优化程序设计、精简接收进程工作量、提高接收进程优先级等措施，使其及时接收数据，从而尽量避免出现粘包现象；三是由接收方控制，将一包数据按结构字段，人为控制分多次接收，然后合并，通过这种手段来避免粘包。</p>

<blockquote><p>以上提到的三种措施，都有其不足之处。第一种编程设置方法虽然可以避免发送方引起的粘包，但它关闭了优化算法，降低了网络发送效率，影响应用程序的性能，一般不建议使用。第二种方法只能减少出现粘包的可能性，但并不能完全避免粘包，当发送频率较高时，或由于网络突发可能使某个时间段数据包到达接收方较快，接收方还是有可能来不及接收，从而导致粘包。第三种方法虽然避免了粘包，但应用程序的效率较低，对实时应用的场合不适合。</p></blockquote>

<h4>补充：封包和拆包</h4>

<h6>封包:</h6>

<ul>
<li>封包就是给一段数据加上包头,这样一来数据包就分为包头和包体两部分内容了(以后讲过滤非法包时封包会加入"包尾"内容).包头其实上是个大小固定的结构体,其中有个结构体成员变量表示包体的长度,这是个很重要的变量,其他的结构体成员可根据需要自己定义.根据包头长度固定以及包头中含有包体长度的变量就能正确的拆分出一个完整的数据包.</li>
</ul>


<h6>拆包</h6>

<p>目前我最常用的是以下两种方式.</p>

<ul>
<li><p>1.动态缓冲区暂存方式.之所以说缓冲区是动态的是因为当需要缓冲的数据长度超出缓冲区的长度时会增大缓冲区长度. 大概过程描述如下:</p>

<ul>
<li><p>A,为每一个连接动态分配一个缓冲区,同时把此缓冲区和SOCKET关联,常用的是通过结构体关联.</p></li>
<li><p>B,当接收到数据时首先把此段数据存放在缓冲区中.</p></li>
<li><p>C,判断缓存区中的数据长度是否够一个包头的长度,如不够,则不进行拆包操作.</p></li>
<li><p>D,根据包头数据解析出里面代表包体长度的变量.</p></li>
<li><p>E,判断缓存区中除包头外的数据长度是否够一个包体的长度,如不够,则不进行拆包操作.</p></li>
<li><p>F,取出整个数据包.这里的"取"的意思是不光从缓冲区中拷贝出数据包,而且要把此数据包从缓存区中删除掉.删除的办法就是把此包后面的数据移动到缓冲区的起始地址.</p></li>
</ul>
</li>
</ul>


<p>这种方法有两个缺点.</p>

<pre><code>    1. 为每个连接动态分配一个缓冲区增大了内存的使用.
    2. 有三个地方需要拷贝数据,一个地方是把数据存放在缓冲区,一个地方是把完整的数据包从缓冲区取出来,一个地方是把数据包从缓冲区中删除.
</code></pre>

<p>这种拆包的改进方法会解决和完善部分缺点.</p>

<ul>
<li>2.利用底层的缓冲区来进行拆包</li>
</ul>


<p>由于TCP也维护了一个缓冲区,所以我们完全可以利用TCP的缓冲区来缓存我们的数据,这样一来就不需要为每一个连接分配一个缓冲区了.另一方面我们知道recv或者wsarecv都有一个参数,用来表示我们要接收多长长度的数据.利用这两个条件我们就可以对第一种方法进行优化了.</p>

<blockquote><p>对于阻塞SOCKET来说,我们可以利用一个循环来接收包头长度的数据,然后解析出代表包体长度的那个变量,再用一个循环来接收包体长度的数据.</p></blockquote>

<h3>Socket通讯源码！</h3>

<p>客户端：
导入头文件：</p>

<pre><code>#import &lt;sys/socket.h&gt;
#import &lt;netinet/in.h&gt;
#import &lt;arpa/inet.h&gt;
#import &lt;unistd.h&gt;
</code></pre>

<p> 创建连接</p>

<pre><code>CFSocketContext sockContext = {0, // 结构体的版本，必须为0
self,  // 一个任意指针的数据，可以用在创建时CFSocket对象相关联。这个指针被传递给所有的上下文中定义的回调。
NULL, // 一个定义在上面指针中的retain的回调， 可以为NULL
NULL, NULL};

CFSocketRef _socket = (kCFAllocatorDefault, // 为新对象分配内存，可以为nil
PF_INET, // 协议族，如果为0或者负数，则默认为PF_INET
SOCK_STREAM, // 套接字类型，如果协议族为PF_INET,则它会默认为SOCK_STREAM
IPPROTO_TCP, // 套接字协议，如果协议族是PF_INET且协议是0或者负数，它会默认为IPPROTO_TCP
kCFSocketConnectCallBack, // 触发回调函数的socket消息类型，具体见Callback Types
TCPServerConnectCallBack, // 上面情况下触发的回调函数
&amp;sockContext // 一个持有CFSocket结构信息的对象，可以为nil
);

if (_socket != nil) {
    struct sockaddr_in addr4;   // IPV4
    memset(&amp;addr4, 0, sizeof(addr4));
    addr4.sin_len = sizeof(addr4);
    addr4.sin_family = AF_INET;
    addr4.sin_port = htons(8888);
    addr4.sin_addr.s_addr = inet_addr([strAddress UTF8String]);  // 把字符串的地址转换为机器可识别的网络地址

    // 把sockaddr_in结构体中的地址转换为Data
    CFDataRef address = CFDataCreate(kCFAllocatorDefault, (UInt8 *)&amp;addr4, sizeof(addr4));
    CFSocketConnectToAddress(_socket, // 连接的socket
address, // CFDataRef类型的包含上面socket的远程地址的对象
-1  // 连接超时时间，如果为负，则不尝试连接，而是把连接放在后台进行，如果_socket消息类型为kCFSocketConnectCallBack，将会在连接成功或失败的时候在后台触发回调函数
);

    CFRunLoopRef cRunRef = CFRunLoopGetCurrent();    // 获取当前线程的循环
    // 创建一个循环，但并没有真正加如到循环中，需要调用CFRunLoopAddSource
    CFRunLoopSourceRef sourceRef = CFSocketCreateRunLoopSource(kCFAllocatorDefault, _socket, 0);
    CFRunLoopAddSource(cRunRef, // 运行循环
    sourceRef,  // 增加的运行循环源, 它会被retain一次
    kCFRunLoopCommonModes  // 增加的运行循环源的模式
    );
    CFRelease(courceRef);
}
</code></pre>

<p> 设置回调函数</p>

<pre><code>// socket回调函数的格式：
static void TCPServerConnectCallBack(CFSocketRef socket, CFSocketCallBackType type, CFDataRef address, const void *data, void *info) ｛
    if (data != NULL) {
        // 当socket为kCFSocketConnectCallBack时，失败时回调失败会返回一个错误代码指针，其他情况返回NULL
        NSLog(@"连接失败");
        return;
    }
    TCPClient *client = (TCPClient *)info;
    // 读取接收的数据
    [info performSlectorInBackground:@selector(readStream) withObject:nil];
｝
</code></pre>

<p>接收发送数据</p>

<pre><code>// 读取接收的数据
- (void)readStream {
    char buffer[1024];
    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
    while (recv(CFSocketGetNative(_socket), //与本机关联的Socket 如果已经失效返回－1:INVALID_SOCKET
           buffer, sizeof(buffer), 0)) {
        NSLog(@"%@", [NSString stringWithUTF8String:buffer]);
    }
}

// 发送数据
- (void)sendMessage {
    NSString *stringTosend = @"你好";
    char *data = [stringTosend UTF8String];
    send(SFSocketGetNative(_socket), data, strlen(data) + 1, 0);
}
</code></pre>

<p>服务器端：</p>

<pre><code>CFSockteRef _socket;
CFWriteStreamRef outputStream = NULL;

int setupSocket() {
    _socket = CFSocketCreate(kCFAllocatorDefault, PF_INET, SOCK_STREAM, IPPROTO_TCP, kCFSocketAcceptCallBack, TCPServerAcceptCallBack, NULL);
    if (NULL == _socket) {
        NSLog(@"Cannot create socket!");
        return 0;
    }

    int optval = 1;
    setsockopt(CFSocketGetNative(_socket), SOL_SOCKET, SO_REUSEADDR, // 允许重用本地地址和端口
(void *)&amp;optval, sizeof(optval));

    struct sockaddr_in addr4;
    memset(&amp;addr4, 0, sizeof(addr4));
    addr4.sin_len = sizeof(addr4);
    addr4.sin_family = AF_INET;
    addr4.sin_port = htons(port);
    addr4.sin_addr.s_addr = htonl(INADDR_ANY);
    CFDataRef address = CFDataCreate(kCFAllocatorDefault, (UInt8 *)&amp;addr4, sizeof(addr4));

    if (kCFSocketSuccess != CFSocketSetAddress(_socket, address)) {
        NSLog(@"Bind to address failed!");
        if (_socket)
             CFRelease(_socket);
        _socket = NULL;
        return 0;
    }

    CFRunLoopRef cfRunLoop = CFRunLoopGetCurrent();
    CFRunLoopSourceRef source = CFSocketCreateRunLoopSource(kCFAllocatorDefault, _socket, 0);
    CFRunLoopAddSource(cfRunLoop, source, kCFRunLoopCommonModes);
    CFRelease(source);

    return 1;
}

// socket回调函数，同客户端
void TCPServerAcceptCallBack(CFSocketRef socket, CFSocketCallBackType type, CFDataRef address, const void *data, void *info) {
    if (kCFSocketAcceptCallBack == type) {
        // 本地套接字句柄
        CFSocketNativeHandle nativeSocketHandle = *(CFSocketNativeHandle *)data;
        uint8_t name[SOCK_MAXADDRLEN];      
        socklen_t nameLen = sizeof(name);
        if (0 != getpeername(nativeSocketHandle, (struct sockaddr *)name, &amp;nameLen)) {
            NSLog(@"error");
            exit(1);
        }
        NSLog(@"%@ connected.", inet_ntoa( ((struct sockaddr_in *)name)-&gt;sin_addr )):

        CFReadStreamRef iStream;
        CFWriteStreamRef oStream;
        // 创建一个可读写的socket连接
        CFStreamCreatePairWithSocket(kCFAllocatorDefault, nativeSocketHandle, &amp;iStream, &amp;oStream);
        if (iStream &amp;&amp; oStream) {
            CFStreamClientContext streamContext = {0, NULL, NULL, NULL};
            if (!CFReadStreamSetClient(iStream, kCFStreamEventHasBytesAvaiable,
                                       readStream, // 回调函数，当有可读的数据时调用
                                       &amp;streamContext)){
                exit(1);
            }

            if (!CFReadStreamSetClient(iStream, kCFStreamEventCanAcceptBytes, writeStream, &amp;streamContext)){
                exit(1);
            }

            CFReadStreamScheduleWithRunLoop(iStream, CFRunLoopGetCurrent(), kCFRunLoopCommomModes);
            CFWriteStreamScheduleWithRunLoop(wStream, CFRunLoopGetCurrent(), kCFRunLoopCommomModes);
            CFReadStreamOpen(iStream);
            CFWriteStreamOpen(wStream);
        } else {
             close(nativeSocketHandle);
        }
    }
}

// 读取数据
void readStream(CFReadStreamRef stream, CFStreamEventType eventType, void *clientCallBackInfo) {
    UInt8 buff[255];
    CFReadStreamRead(stream, buff, 255);
    printf("received: %s", buff);
}

void writeStream (CFWriteStreamRef stream, CFStreamEventType eventType, void *clientCallBackInfo) {
    outputStream = stream;
}

main {
    char *str = "nihao";

    if (outputStream != NULL) {
        CFWriteStreamWrite(outputStream, str, strlen(line) + 1);
    } else {
        NSLog(@"Cannot send data!");
    }
}

// 开辟一个线程线程函数中
void runLoopInThread() {
    int res = setupSocket();
    if (!res) {
        exit(1);
    }
    CFRunLoopRun();    // 运行当前线程的CFRunLoop对象
} 
</code></pre>

<h3>Socket常见问题</h3>

<h6>1.recv不等待是因为你使用的是非阻塞socket，换而你使用阻塞socket一样需要等待。</h6>

<p>recv的recvfrom是可以替换使用的，只是recvfrom多了两个参数，可以用来接收对端的地址信息，这个对于udp这种无连接的，可以很方便地进行回复。
而换过来如果你在udp当中也使用recv，那么就不知道该回复给谁了，如果你不需要回复的话，也是可以使用的。另外就是对于tcp是已经知道对端的，
就没必要每次接收还多收一个地址，没有意义，要取地址信息，在accept当中取得就可以加以记录了。</p>

<h6>2.在服务器端不能获取正确的发送方的IP地址</h6>

<p>Q.服务器端代码：</p>

<pre><code>n=recvfrom(sockfd,msg,MAX_MSG_SIZE,0,(structaddr*)&amp;addr,&amp;addrlen);
</code></pre>

<p>客户端向服务器端发送msg后，服务器端能收到，但是，在服务器端不能获取正确的发送方的IP地址。</p>

<p>A.几经努力，问题终于解决：</p>

<pre><code>n=recvfrom(sockfd,msg,MAX_MSG_SIZE,0,(structaddr*)&amp;addr,&amp;addrlen);
</code></pre>

<p>在调用recvfrom()之前，加上：addrlen = sizeof(struct sockaddr);即可（之前声明 int addrlen; ）。</p>

<h6>3.标志字符串结束</h6>

<p> 使用java开发socket通信时，当使用输出流的情况输出时，例如：</p>

<pre><code>PrintWriter os=new PrintWriter(socket.getOutputStream());
os.println(msg);//一定要用println才能标志字符串结束
os.flush();
</code></pre>

<p>最后一句不可省略，否则不会刷新缓存，客户端则不能接收到任何数据。若是不用println，用print则字符串不会结束，这样，接收端则会一直等待，直到字符串结束或连接断开才会说明本次字符串已传输完毕，因此在使用这种方法输出时，一定要注意传送字符串传送完毕的标志位。</p>

<p>此外，我在使用perl进行socket通信时，也出现了此类问题。用perl进行socket通信的编程时，发送的消息最后一定要加上\n，也就是换行符，这样，才被认为是通信结束。</p>

<h6>4.Socket中 设置连接超时</h6>

<p>设置connect超时很简单，CSDN上也有人提到过使用select，但却没有一个令人满意与完整的答案。偶所讲的也正是select函数，此函数集成在winsock1.1中，简单点讲，"作用使那些想避免在套接字调用过程中被锁定的应用程序，采取一种有序的方式，同时对多个套接字进行管理"(《Windows网络编程技术》原话)。使用方法与解释请见《Windows网络编程技术》。</p>

<blockquote><p>在使用此函数前，需先将socket设置为非阻塞模式，这样，在connect时，才会立马跳过，同时，通常也会产生一个WSAEWOULDBLOCK错误，这个错误没关系。再执行select则是真正的超时。</p></blockquote>

<h6>5.IOS Socket 如何判断接受完成　　</h6>

<p>　　
　　发送起始时传递文件的大小信息给接收方，接收方每读取一个数据块就缓存到nsdata或写入到存储器上，当接收块的size小于等于缓存buffer的大小时，说明接收到了最后一个块，把这个快也缓存到nsdata或写入到存储器上，接收就完成了，然后作check，检查接收到的内容（缓存用的nsdata或反复写入的那个临时磁盘文件）是否和发送方开始给过来的文件大小相等，相等就是对的，不相等就是错的，需要向发送端申请复发。ios里建议用asyncSocket类，异步+代理，收到数据块时自动进入事件委托过程。
　　
　　</p>

<h6>6.AsyncSocket接收到数据出现粘包问题该如何解决？</h6>

<p>　　发送的包里每个包前边加个长度的字段。 你收到的时候先将这个字段解析出来，然后读入接下来的data内容。 如果data内容过长，那可能是几个包粘在一块儿了，只读入当前包 的内容， 如果不足，证明出现断包的情况，缓存下来，等下次收到包的时候，肯定显示上次收到包的内容了，拼在一块儿解出来。
tcp的协议中，包的接收顺序就是包发送时候的顺序，你需要处理的就是当出现一个段包时，自己缓存直到这个包长度够了就完成了。完成这个的基础，一般的做法都是自己发送的每个包头添加一个长度字段</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[函数&amp;方法的奥秘]]></title>
    <link href="http://al1020119.github.io/blog/2015/02/08/han-shu-and-fang-fa-de-ao-mi/"/>
    <updated>2015-02-08T23:54:30+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/02/08/han-shu-and-fang-fa-de-ao-mi</id>
    <content type="html"><![CDATA[<p>首先问个问题，你知道函数与方法的区别吗？</p>

<p>什么？没有区别？那你就out了！</p>

<p>函数(function)，方法(method)，之前没细究它们的不同，随心所欲的想说哪个就说哪个，“这个初始化函数…”，“这个初始化方法…”，看着都差不多，没什么区别。
直到前几天，一个新来的同事，在看我整理的 Objective-C代码规范文档，里面有一段是这样的：</p>

<h5>初始化函数</h5>

<pre><code>- (void)init
{
…
} 
…
</code></pre>

<p>他看到后，疑惑的跟我说：“你这表达方式不对吧，你标题说的是函数，但是内容却说的是方法。”
哦？原来函数跟方法是不一样的。</p>

<h2>函数</h2>

<p>一个代码块，完成特定的功能，然后将结果返回给调用方，常见的函数的格式是这样的：</p>

<pre><code>&lt;return type&gt; &lt;function name&gt; (&lt;arg1 type&gt; &lt;arg1 name&gt;, &lt;arg2 type&gt; &lt;arg2 name&gt;, ... )
{
  // Code here
}
一个函数声明与调用的例子：

// 实现函数
int plus(int x, int y)
{
  return x * y;
}

int main (int argc, const char *argv[])
{
  int x = 2;
  int y = 3;
  // 调用函数
  int result = plus(x, y);

  return 0;
}
</code></pre>

<h2>方法</h2>

<p>也是一个代码块，不过方法是需要写在类里面的，调用时需要类或者对象才可以调用，一个 Objective-C 的方法例子如下：</p>

<pre><code>@implementation Person

// 实现方法
- (void)setName:(NSString *)name
{
  //code here
}

@end

int main (int argc, const char *argv[])
{
  // 使用对象调用方法
  [[Person new] setName:@"zhenby"];

  return 0;
}
</code></pre>

<hr />

<h1>有什么不同</h1>

<blockquote><p>那说到底，函数跟方法的不同就是：方法是属于类或者对象的，而函数则不一定，可以独立于类与对象之外，独立调用，所以可以说 函数 >= 方法，因此方法也可以叫 member function。</p></blockquote>

<h3>Objective-C中的函数</h3>

<p>Objective-C 中一般的函数是全局有效的(可在函数前加 static 关键字使得该函数只在该文件中有效)，即在一个文件中实现了一个函数，在同个项目中的其他代码中都可以直接调用此函数，所以定义函数时，函数名需要唯一，重复的函数名(不管参数是否一致)是编译不过的。
知道这个特性后，就可以把一些常用的代码块，比如获取当前时间戳这样的功能的整理成了一个函数，这样的好处是项目中的代码在需要时都可以直接调用，而不需要类或者对象，类似于 NSLog 函数。</p>

<p>而我在实现函数的时候，遇到了一个这样的警告“no previous prototype for function xxx ”，这个警告的意思是没找到一个前置的函数原型，在文件的顶端，或者头文件(如果有的话)加上你所加的函数原型就可以了，例如：</p>

<pre><code>// 函数原型
int plus(int, int);
/*
 如果参数为空的话，在函数原型中需要传 void，在函数原型中参数为空的话，
 在C中表示此函数可以接受任意个参数，在 Objective-C 中也有一样的规则
 */
long timestamp(void);


// 实现函数
int plus(int x, int y)
{
  return x * y;
}

long timestamp()
{
  // 返回当前的时间戳
    return (long)[[NSDate date] timeIntervalSince1970];
}
</code></pre>

<h3>Objective-C中的方法</h3>

<p>在 Objective-C 中，方法的调用是通过消息传递来进行的，需要在运行时才能确定方法的地址(只要知道一个类的方法名，不管这个方法是否公开，都可以调用到，这也是为啥苹果的私有 API 会被挖出来，所以也没有受保护方法这样的说法，方法要么是公开的，要么是不公开的，无论公不公开，通过方法名都可以调用到方法)，而消息传递就是通过id objc_msgSend(id theReceiver, SEL theSelector, &hellip;)这个函数来达到目的的，可以说 Objective-C 中的方法，其实相当于固定前两个参数的 objc_msgSend 函数。比如：</p>

<pre><code>@implementation Test

- (long)timestamp
{
  NSLog(@"in timestamp");
  // 返回当前时间戳   
    return (long)[[NSDate date] timeIntervalSince1970];
}

@end

// 调用 timestamp 方法
Test *test = [Test new];
[test timestamp];
[test release];

//----------------------------------------------------------

/*
 上面 [test timestamp] 这句代码就相当于以下的函数调用，
 直接执行下面的代码，也可以在控制台中打印出 in timestamp。
 */
#import &lt;objc/message.h&gt;

objc_msgSend(test, @selector(timestamp));
</code></pre>

<blockquote><p>如果你还不了解是什么回事，那么你可以看看swift，我记得在学习swift1.2版的时候，官方提到了函数与方法的区别和注意点！</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[底层开发之越狱开发]]></title>
    <link href="http://al1020119.github.io/blog/2014/12/29/yue-yu-kai-fa-xiang-jie/"/>
    <updated>2014-12-29T22:32:50+08:00</updated>
    <id>http://al1020119.github.io/blog/2014/12/29/yue-yu-kai-fa-xiang-jie</id>
    <content type="html"><![CDATA[<p>做越狱开发也有一些时间了，有很多东西想总结一下，希望给他人一些借鉴，也是自己对过去开发经历的一些总结。个人不推荐使用盗版，这里主要以技术介绍为主。</p>

<p>这个系列里面主要介绍怎样进行越狱开发，涉及到以下几个方面:</p>

<!--more-->


<ul>
<li>(1)主要涉及到越狱市场的建立，在App内部实现ipa的安装和卸载以及更新。参照的对象就是91助手，25pp，同步推那样的应用。建立一个盗版的App Store.当然了，如果通过299刀的企业证书的话，是不需要通过Cydia的，直接通过网页链接就可以实现app的推广，有一定的风险。这里面涉及到一些协议，后面会进行介绍。</li>
<li>(2)在App内部实现壁纸和铃声的替换。这个过程涉及到的东西很多，特别是铃声的替换，iPhone里面非常麻烦；</li>
<li>(3)一些越狱插件的开发，通过里面有些插件非常好用，合理，而且非常美观漂亮。
这里先从App内部安装ipa包开始讲，后面逐步把上面提到的3点全部讲完。</li>
</ul>


<p>一般情况下安装91助手，同步推这样的应用需要手机越狱，同时安装AppSync，这样才能使用，所以进行开发的必备条件也是如此。</p>

<p>上传的demo工程的地址，我的github链接：<a href="https://github.com/easonoutlook/IPAInstaller">https://github.com/easonoutlook/IPAInstaller</a></p>

<p>之前一直在fork别人的东西，也没做什么贡献，从现在开始，为开发为开源，做一点自己的贡献。</p>

<p>进入正题：</p>

<p>需要的工具和环境：</p>

<ol type="a">
<li>iPhone or iPad越狱，安装AppSync</li>
<li>Xcode安装 Command Line Tools</li>
<li>下载最新版本的ldid <a href="https://github.com/downloads/rpetrich/ldid/ldid.zip">https://github.com/downloads/rpetrich/ldid/ldid.zip</a></li>
</ol>


<p>1、修改SDKSettings.plist文件</p>

<p>我用的是Xcode4.6.3版本，iPhone的版本是6.1.2, 路径为：</p>

<pre><code>/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS6.1.sdk/
</code></pre>

<p>将这个目录下的 SDKSettings.plist里面的CODE_SIGNING_REQUIRED置为NO</p>

<p>执行命令为：</p>

<p>转到目录下</p>

<pre><code>cd /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS6.1.sdk
</code></pre>

<p>将原有文件备份</p>

<pre><code>sudo cp SDKSettings.plist SDKSettings.plist.orig
</code></pre>

<p>对SDKSettings.plist文件进行编辑</p>

<pre><code>sudo vim SDKSettings.plist
</code></pre>

<p>将下面对应的字段改为NO</p>

<pre><code>&lt;key&gt;CODE_SIGNING_REQUIRED&lt;/key&gt;
&lt;string&gt;YES&lt;/string&gt;  // 默认为YES, 需要改为NO
</code></pre>

<p>此操作参考的路径如下：</p>

<pre><code>http://kqwd.blog.163.com/blog/static/4122344820117191351263/
</code></pre>

<p>2、给工程添加相应的权限，iOS6里面需要赋予权限才可以，iOS5之前不需要此操作</p>

<p>新建一个plist文件，命名为entitlements.</p>

<pre><code>![Alt text](/iamges/yueyu001.jpg)
</code></pre>

<p><img src="/images/yueyu001.png" title="Caption" ></p>

<p>创建一个plist</p>

<pre><code>![Alt text](/iamges/yueyu002.jpg)
</code></pre>

<p><img src="/images/yueyu002.png" title="Caption" ></p>

<p>将plist文件改为：</p>

<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;
&lt;plist version="1.0"&gt;
&lt;dict&gt;
    &lt;key&gt;com.apple.private.mobileinstall.allowedSPI&lt;/key&gt;
    &lt;array&gt;
        &lt;string&gt;Install&lt;/string&gt;
        &lt;string&gt;Browse&lt;/string&gt;
        &lt;string&gt;Uninstall&lt;/string&gt;
        &lt;string&gt;Archive&lt;/string&gt;
        &lt;string&gt;RemoveArchive&lt;/string&gt;
    &lt;/array&gt;
&lt;/dict&gt;
&lt;/plist&gt;
</code></pre>

<p>将Code Signing 的Code Signing Entilements设置为刚刚创建的entitlements.plist文件</p>

<pre><code>![Alt text](/iamges/yueyu003.jpg)
</code></pre>

<p><img src="/images/yueyu003.png" title="Caption" ></p>

<p>后面还需要一个手续，将生产的app文件用ldid签名。后面再介绍。</p>

<p>3、实现越狱安装的代码：</p>

<pre><code>typedef NSDictionary *(*PMobileInstallationLookup)(NSDictionary *params, id callback_unknown_usage);
NSDictionary *IPAInstalledApps()
{
void *lib = dlopen("/System/Library/PrivateFrameworks/MobileInstallation.framework/MobileInstallation", RTLD_LAZY);
if (lib)
{
    PMobileInstallationLookup pMobileInstallationLookup = (PMobileInstallationLookup)dlsym(lib, "MobileInstallationLookup");
    if (pMobileInstallationLookup)
    {
        NSArray *wanted = nil;//[NSArray arrayWithObjects:@"com.celeware.IPADeploy",@"com.celeware.celedial",nil]; Lookup specified only
        NSDictionary *params = [NSDictionary dictionaryWithObjectsAndKeys:@"User", @"ApplicationType", wanted, @"BundleIDs",nil];
        NSDictionary *dict = pMobileInstallationLookup(params, NULL);
#ifdef DEBUG
        NSLog(@"%@", dict);
#endif
        return dict;
    }
}
return nil;
}
</code></pre>

<p>所有代码均在之前的github目录中，可以自行查看。</p>

<p>4、编译生成App文件</p>

<p>因为需要给APP签名加权限，所以不要生成IPA文件，而是生成APP文件。等把签名与权限加好后，再手动用APP制作IPA文件。</p>

<p> 在Xcode中选择设备（IOS Device）（图3），编译（Build）（图4）。编译完成后，在工程的Products文件夹中可以看到刚刚编译好的APP文件，右键Show in Finder（图5），就可以在文件夹中显示。将APP复制到一个别的文件夹中，什么地方都可以，后面需要用到。</p>

<pre><code>![Alt text](/iamges/yueyu004.jpg)
</code></pre>

<p><img src="/images/yueyu004.png" title="Caption" ></p>

<p>5、制作ipa文件</p>

<p>将之前提到的ldid下载好后，将ldid文件放到/usr/bin中。</p>

<p>比如在 Download 目录下， sudo -i</p>

<p>然后 cp ldid /usr/bin/即可将文件拷贝到/usr/bin中。</p>

<p>然后对之前生成的文件，进行ldid签名</p>

<pre><code>![Alt text](/iamges/yueyu005.jpg)
</code></pre>

<p><img src="/images/yueyu005.png" title="Caption" ></p>

<ul>
<li><p>这个命令中“ldid -S” ，“ldid”与“-S”之间有一个空格。“-S”与“entitlements.xml”之间没有空格。“entitlements.xml”就是上面说到的XML文件，如果你的XML不是这个名，请将命令修改为你的XML文件名即可。</p></li>
<li><p>“-Sentitlements.xm”与“ipainstall.app”之间有一个空格。“ipainstall”是刚刚生成的APP文件，如果你的名字不一样，请修改为你的名字。“/“后面和APP的名字是一样的。  如果没有输出错误信息或是卡住（就是敲回车后没反应）就是添加权限成功了。</p></li>
</ul>


<p>6、生成ipa文件，安装</p>

<p>新建一个文件夹，命名为“Payload”。将刚刚添加好权限的APP文件放到这个文件夹中。右键“压缩Payload”，得到一个“.zip”文件，将这个ZIP文件的后缀名改为“.ipa”。好了，IPA文件就制作完成了。</p>

<p>然后通过itools安装，测试刚刚生成的文件</p>

<pre><code>![Alt text](/iamges/yueyu006.jpg)
</code></pre>

<p><img src="/images/yueyu006.png" title="Caption" ></p>

<p>整合了很多资源，有些地方弄的比较凌乱，后面加以完善</p>

<h1>检查iphone时候越狱</h1>

<p>今天项目中要用到检查iPhone是否越狱的方法。</p>

<p>Umeng统计的Mobclick.h里面已经包含了越狱检测的代码，可以直接使用</p>

<p>复制代码
复制代码</p>

<pre><code>/*方法名:
 *        isJailbroken
*介绍:
*        类方法，判断设备是否越狱，判断方法根据 apt和Cydia.app的path来判断
*参数说明:
*        无
*        
*
*/

#pragma mark utils api
// 类方法，判断当前设备是否已经越狱
+ (BOOL)isJailbroken;
// 类方法，判断你的App是否被破解
+ (BOOL)isPirated;
</code></pre>

<p>apt和Cydia的方式来进行判断的，没看见源码</p>

<p>然后再介绍两种方法来查看是否已经越狱，知其然知其所以然、、、</p>

<h3>apt</h3>

<pre><code>- (BOOL) asAP
{
return [[NSFileManager defaultManager] fileExistsAtPath:@"/private/var/lib/at/"];
4 }`
</code></pre>

<h3>system</h3>

<pre><code>`1 - (BOOL) successCallSystem
2 {
3 return (system("ls") == 0) ? YES : NO;
4 }`
</code></pre>

<h3>示例代码</h3>

<pre><code>static const char* jailbreak_apps[] =

  {
      "/Applications/Cydia.app",
      "/Applications/limera1n.app",
      "/Applications/greenpois0n.app",
      "/Applications/blackra1n.app",
      "/Applications/blacksn0w.app",
      "/Applications/redsn0w.app",
     "/Applications/Absinthe.app",
     NULL,
 };

 - (BOOL) isJailBroken
 {
     // Now check for known jailbreak apps. If we encounter one, the device is jailbroken.
     for (int i = 0; jailbreak_apps[i] != NULL; ++i)
     {
         if ([[NSFileManager defaultManager] fileExistsAtPath:[NSString stringWithUTF8String:jailbreak_apps[i]]])
         {
             //NSLog(@"isjailbroken: %s", jailbreak_apps[i]);
             return YES;
         }
     }

               // TODO: Add more checks? This is an arms-race we're bound to lose.

     return NO;
 }
</code></pre>

<hr />

<pre><code>@interface UIDevice (Helper)  
 - (BOOL)isJailbroken;  
 @end
</code></pre>

<hr />

<pre><code>@implementation UIDevice (Helper)  
- (BOOL)isJailbroken {  
BOOL jailbroken = NO;  
NSString *cydiaPath = @"/Applications/Cydia.app";  
NSString *aptPath = @"/private/var/lib/apt/";  
if ([[NSFileManager defaultManager] fileExistsAtPath:cydiaPath]) {  
 jailbroken = YES;  
}  
if ([[NSFileManager defaultManager] fileExistsAtPath:aptPath]) {  
 jailbroken = YES;  
}  
return jailbroken;  
}  
@end
</code></pre>

<hr />

<p>参考资源链接：</p>

<p><a href="http://since2006.com/blog/240/ios6-mobileinstallationinstall">http://since2006.com/blog/240/ios6-mobileinstallationinstall</a>
<a href="http://blog.sina.com.cn/s/blog_9cd1705d0101l4bo.html">http://blog.sina.com.cn/s/blog_9cd1705d0101l4bo.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[方法缓存]]></title>
    <link href="http://al1020119.github.io/blog/2014/11/14/fang-fa-huan-cun/"/>
    <updated>2014-11-14T17:42:41+08:00</updated>
    <id>http://al1020119.github.io/blog/2014/11/14/fang-fa-huan-cun</id>
    <content type="html"><![CDATA[<blockquote><p>摘要
只要用到Objective-C，我们每天都会跟方法调用打交道。我们都知道Objective-C的方法决议是动态的，但是在底层一个方法究竟是怎么找到的，方法缓存又是怎么运作的却鲜为人知。本文主要从源码角度探究了Objective-C在runtime层的方法决议（Method resolving）过程和方法缓存（Method cache）的实现。</p></blockquote>

<p>简介
本文作者来自美团酒店旅游事业群iOS研发组。我们致力于创造价值、提升效率、追求卓越。欢迎大家加入我们（简历请发送到邮箱 <a href="&#109;&#97;&#x69;&#108;&#x74;&#111;&#x3a;&#109;&#x61;&#x6a;&#x69;&#97;&#48;&#51;&#x40;&#109;&#101;&#x69;&#116;&#x75;&#97;&#x6e;&#46;&#x63;&#111;&#x6d;">&#x6d;&#97;&#x6a;&#x69;&#x61;&#x30;&#x33;&#64;&#x6d;&#x65;&#x69;&#116;&#x75;&#97;&#110;&#46;&#x63;&#111;&#x6d;</a> ）。</p>

<p>本文系学习Objective-C的runtime源码时整理所成，主要剖析了Objective-C在runtime层的方法决议过程和方法缓存，内容包括：</p>

<ul>
<li>从消息决议说起</li>
<li>缓存为谁而生</li>
<li>追本溯源，何为方法缓存</li>
<li>缓存和散列</li>
<li>十万个为什么</li>
<li>缓存 - 性能优化的万金油？</li>
<li>优化，永无止境</li>
<li>从消息决议说起</li>
</ul>


<!--more-->


<p>我们都知道，在Objective-C里调用一个方法是这样的：</p>

<pre><code>[object methodA];
</code></pre>

<p>这表示我们想去调用object的methodA。
但是在Objective-C里面调用一个方法到底意味着什么呢，是否和C++一样，任何一个非虚方法都会被编译成一个唯一的符号，在调用的时候去查找符号表，找到这个方法然后调用呢？
答案是否定的。在Objective-C里面调用一个方法的时候，runtime层会将这个调用翻译成</p>

<pre><code>objc_msgSend(id self, SEL op, ...)
</code></pre>

<p>而objc_msgSend具体又是如何分发的呢？ 我们来看下runtime层objc_msgSend的源码。
在objc-msg-arm.s中，objc_msgSend的代码如下：
（ps：Apple为了高度优化objc_msgSend的性能，这个文件是汇编写成的，不过即使我们不懂汇编，详尽的注释也可以让我们一窥其真面目）</p>

<pre><code>ENTRY objc_msgSend
# check whether receiver is nil
teq     a1, #0
    beq     LMsgSendNilReceiver

# save registers and load receiver's class for CacheLookup
stmfd   sp!, {a4,v1}
ldr     v1, [a1, #ISA]

# receiver is non-nil: search the cache
CacheLookup a2, v1, LMsgSendCacheMiss

# cache hit (imp in ip) and CacheLookup returns with nonstret (eq) set, restore registers and call
ldmfd   sp!, {a4,v1}
bx      ip

# cache miss: go search the method lists
LMsgSendCacheMiss:
ldmfd sp!, {a4,v1}
b _objc_msgSend_uncached

LMsgSendNilReceiver:
    mov     a2, #0
    bx      lr

LMsgSendExit:
END_ENTRY objc_msgSend


STATIC_ENTRY objc_msgSend_uncached

# Push stack frame
stmfd sp!, {a1-a4,r7,lr}
add     r7, sp, #16

# Load class and selector
ldr a3, [a1, #ISA] /* class = receiver-&gt;isa  */
/* selector already in a2 */
/* receiver already in a1 */

# Do the lookup
MI_CALL_EXTERNAL(__class_lookupMethodAndLoadCache3)
MOVE    ip, a1

# Prep for forwarding, Pop stack frame and call imp
teq v1, v1 /* set nonstret (eq) */
ldmfd sp!, {a1-a4,r7,lr}
bx ip
</code></pre>

<p>从上述代码中可以看到，objc_msgSend（就arm平台而言）的消息分发分为以下几个步骤：</p>

<p>判断receiver是否为nil，也就是objc_msgSend的第一个参数self，也就是要调用的那个方法所属对象
从缓存里寻找，找到了则分发，否则
利用objc-class.mm中_class_lookupMethodAndLoadCache3（为什么有个这么奇怪的方法。本文末尾会解释）方法去寻找selector</p>

<p>如果支持GC，忽略掉非GC环境的方法（retain等）
从本class的method list寻找selector，如果找到，填充到缓存中，并返回selector，否则
寻找父类的method list，并依次往上寻找，直到找到selector，填充到缓存中，并返回selector，否则
调用_class_resolveMethod，如果可以动态resolve为一个selector，不缓存，方法返回，否则
转发这个selector，否则
报错，抛出异常
缓存为谁而生
从上面的分析中我们可以看到，当一个方法在比较“上层”的类中，用比较“下层”（继承关系上的上下层）对象去调用的时候，如果没有缓存，那么整个查找链是相当长的。就算方法是在这个类里面，当方法比较多的时候，每次都查找也是费事费力的一件事情。
考虑下面的一个调用过程：</p>

<pre><code>for ( int i = 0; i &lt; 100000; ++i) {
    MyClass *myObject = myObjects[i];
    [myObject methodA];
}
</code></pre>

<p>当我们需要去调用一个方法数十万次甚至更多地时候，查找方法的消耗会变的非常显著。
就算我们平常的非大规模调用，除非一个方法只会调用一次，否则缓存都是有用的。在运行时，那么多对象，那么多方法调用，节省下来的时间也是非常可观的。</p>

<p>追本溯源，何为方法缓存
本着源码面前，了无秘密的原则，我们看下源码中的方法缓存到底是什么，在objc-cache.mm中，objc_cache的定义如下：</p>

<pre><code>struct objc_cache {
    uintptr_t mask;            /* total = mask + 1 */
    uintptr_t occupied;       
    cache_entry *buckets[1];
};
</code></pre>

<p>嗯，objc_cache的定义看起来很简单，它包含了下面三个变量：</p>

<ul>
<li>1)、mask：可以认为是当前能达到的最大index（从0开始的），所以缓存的size（total）是mask+1</li>
<li>2)、occupied：被占用的槽位，因为缓存是以散列表的形式存在的，所以会有空槽，而occupied表示当前被占用的数目</li>
<li>3)、buckets：用数组表示的hash表，cache_entry类型，每一个cache_entry代表一个方法缓存
(buckets定义在objc_cache的最后，说明这是一个可变长度的数组)</li>
</ul>


<p>而cache_entry的定义如下：</p>

<pre><code>typedef struct {
    SEL name;     // same layout as struct old_method
    void *unused;
    IMP imp;  // same layout as struct old_method
} cache_entry;
</code></pre>

<p>cache_entry定义也包含了三个字段，分别是：</p>

<ul>
<li>1)、name，被缓存的方法名字</li>
<li>2)、unused，保留字段，还没被使用。</li>
<li>3)、imp，方法实现</li>
</ul>


<p>缓存和散列
缓存的存储使用了散列表。
为什么要用散列表呢？因为散列表检索起来更快，我们来看下是方法缓存如何散列和检索的：</p>

<pre><code>// Scan for the first unused slot and insert there.
// There is guaranteed to be an empty slot because the 
// minimum size is 4 and we resized at 3/4 full.
buckets = (cache_entry **)cache-&gt;buckets;
for (index = CACHE_HASH(sel, cache-&gt;mask); 
     buckets[index] != NULL; 
     index = (index+1) &amp; cache-&gt;mask)
{
    // empty
}
buckets[index] = entry;
</code></pre>

<p>这是往方法缓存里存放一个方法的代码片段，我们可以看到sel被散列后找到一个空槽放在buckets中，而CACHE_HASH的定义如下：</p>

<pre><code>#define CACHE_HASH(sel, mask) (((uintptr_t)(sel)&gt;&gt;2) &amp; (mask))
</code></pre>

<p>这段代码就是利用了sel的指针地址和mask做了一下简单计算得出的。
而从散列表取缓存则是利用汇编语言写成的（是为了高度优化objc_msgSend而使用汇编的）。我们看objc-msg-arm.mm 里面的CacheLookup方法：</p>

<pre><code>.macro CacheLookup /* selReg, classReg, missLabel */

 MOVE r9, $0, LSR #2          /* index = (sel &gt;&gt; 2) */
 ldr     a4, [$1, #CACHE]        /* cache = class-&gt;cache */
 add     a4, a4, #BUCKETS        /* buckets = &amp;cache-&gt;buckets */

/* search the cache */
/* a1=receiver, a2 or a3=sel, r9=index, a4=buckets, $1=method */
1:
 ldr     ip, [a4, #NEGMASK]      /* mask = cache-&gt;mask */
 and     r9, r9, ip              /* index &amp;= mask           */
 ldr     $1, [a4, r9, LSL #2]    /* method = buckets[index] */
 teq     $1, #0                  /* if (method == NULL)     */
 add     r9, r9, #1              /* index++                 */
 beq     $2                      /*     goto cacheMissLabel */

 ldr     ip, [$1, #METHOD_NAME]  /* load method-&gt;method_name        */
 teq     $0, ip                  /* if (method-&gt;method_name != sel) */
 bne     1b                      /*     retry                       */

/* cache hit, $1 == method triplet address */
/* Return triplet in $1 and imp in ip      */
 ldr     ip, [$1, #METHOD_IMP]   /* imp = method-&gt;method_imp */

.endmacro
</code></pre>

<p>虽然是汇编，但是注释太详尽了，理解起来并不难，还是求hash，去buckets里找，找不到按照hash冲突的规则继续向下，直到最后。</p>

<p>十万个为什么
了解了方法缓存的定义之后，我们提出几个问题并一一解答</p>

<p>方法缓存存在什么地方？
让我们去翻看类的定义，在Objective-C 2.0中，Class的定义大致是这样的（见objc-runtime.mm）</p>

<pre><code>  struct _class_t {
  struct _class_t *isa;
  struct _class_t *superclass;
  void *cache;
  void *vtable;
  struct _class_ro_t *ro;
  };
</code></pre>

<p>我们看到在类的定义里就有cache字段，没错，类的所有缓存都存在metaclass上，所以每个类都只有一份方法缓存，而不是每一个类的object都保存一份。
父类方法的缓存只存在父类么，还是子类也会缓存父类的方法？
在第一节对objc_msgSend的追溯中我们可以看到，即便是从父类取到的方法，也会存在类本身的方法缓存里。而当用一个父类对象去调用那个方法的时候，也会在父类的metaclass里缓存一份。
类的方法缓存大小有没有限制？
要回答这个问题，我们需要再看一下源码，在objc-cache.mm有一个变量定义如下：</p>

<pre><code>  /* When _class_slow_grow is non-zero, any given cache is actually grown
   * only on the odd-numbered times it becomes full; on the even-numbered
   * times, it is simply emptied and re-used.  When this flag is zero,
   * caches are grown every time. */
  static const int _class_slow_grow = 1;
</code></pre>

<p>其实不用再看进一步的代码片段，仅从注释我们就可以看到问题的答案。注释中说明，当<em>class_slow_grow是非0值的时候，只有当方法缓存第奇数次满（使用的槽位超过3/4）的时候，方法缓存的大小才会增长（会清空缓存，否则hash值就不对了）；当第偶数次满的时候，方法缓存会被清空并重新利用。 如果</em>class_slow_grow值为0，那么每一次方法缓存满的时候，其大小都会增长。
所以单就问题而言，答案是没有限制，虽然这个值被设置为1，方法缓存的大小增速会慢一点，但是确实是没有上限的。
为什么类的方法列表不直接做成散列表呢，做成list，还要单独缓存，多费事？
这个问题么，我觉得有以下三个原因：</p>

<p>散列表是没有顺序的，Objective-C的方法列表是一个list，是有顺序的；Objective-C在查找方法的时候会顺着list依次寻找，并且category的方法在原始方法list的前面，需要先被找到，如果直接用hash存方法，方法的顺序就没法保证。
list的方法还保存了除了selector和imp之外其他很多属性
散列表是有空槽的，会浪费空间
缓存 - 性能优化的万金油？
非也，就算有了有了Objective-C本身的方法缓存，我们还是有很多调用方法的优化空间，对于这件事情，这篇文章讲的非常详细，大家可以自行移步观摩<a href="http://www.mulle-kybernetik.com/artikel/Optimization/opti-3-imp-deluxe.html">http://www.mulle-kybernetik.com/artikel/Optimization/opti-3-imp-deluxe.html</a> （强烈推荐，虽然我们一般不会遇到需要这么强度优化的地方，但是这种精神和思想是值得我们学习的）</p>

<p>优化，永无止境
在文章末尾，我们再来回答一下第一节提出的问题：“为什么会有_class_lookupMethodAndLoadCache3这个方法？”
这个方法的实现如下所示：</p>

<pre><code>/***********************************************************************
* _class_lookupMethodAndLoadCache.
* Method lookup for dispatchers ONLY. OTHER CODE SHOULD USE lookUpImp().
* This lookup avoids optimistic cache scan because the dispatcher
* already tried that.
**********************************************************************/
IMP _class_lookupMethodAndLoadCache3(id obj, SEL sel, Class cls)
{
    return lookUpImpOrForward(cls, sel, obj, 
                              YES/*initialize*/, NO/*cache*/, YES/*resolver*/);
}
</code></pre>

<p>如果单纯看方法名，这个方法应该会从缓存和方法列表中查找一个方法，但是如第一节所讲，在调用这个方法之前，我们已经是从缓存无法找到这个方法了，所以这个方法避免了再去扫描缓存查找方法的过程，而是直接从方法列表找起。从Apple代码的注释，我们也完全可以了解这一点。不顾一切地追求完美和性能，是一种品质。</p>

<p>后记
本文是Objective-C runtime源码研究的第二篇，主要对Objective-C的方法决议和方法缓存做了剖析。runtime的源代码可以在 <a href="http://www.opensource.apple.com/tarballs/">http://www.opensource.apple.com/tarballs/</a> 下载。如有错误，敬请指正。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[玩转运行时]]></title>
    <link href="http://al1020119.github.io/blog/2014/06/16/runtime/"/>
    <updated>2014-06-16T13:53:19+08:00</updated>
    <id>http://al1020119.github.io/blog/2014/06/16/runtime</id>
    <content type="html"><![CDATA[<h2>运行时（Runtime）机制</h2>

<p>本文将会以笔者个人的小小研究为例总结一下关于iOS开发中运行时的使用和常用方法的介绍，关于跟多运行时相关技术请查看笔者之前写的运行时高级用法及相关语法或者查看响应官方文档。</p>

<p>下面就来看看什么是运行时，我们要怎么在iOS开发中去使用它。</p>

<p>官方介绍：</p>

<!--more-->


<p><img src="/images/runtime001.png" title="Caption" ></p>

<p><img src="/images/runtime002.png" title="Caption" ></p>

<p>这里我们主要关注的是最后一种！</p>

<p>下面来看看Runtime的相关总结</p>

<p><img src="/images/runtime003.png" title="Caption" ></p>

<h2>术语解释</h2>

<h3>Messages</h3>

<p>如果你是从动态语言如Ruby或Python转过来的，可能知道什么是消息，可以直接跳过进入下一节。那些从其他语言转过来的，继续看。</p>

<p>执行一个方法，有些语言，编译器会执行一些额外的优化和错误检查，因为调用关系很直接也很明显。但对于消息分发来说，就不那么明显了。在发消息前不必知道某个对象是否能够处理消息。你把消息发给它，它可能会处理，也可能转给其他的Object来处理。一个消息不必对应一个方法，一个对象可能实现一个方法来处理多条消息。</p>

<p>在Objective-C中，消息是通过objc_msgSend()这个runtime方法及相近的方法来实现的。这个方法需要一个target，selector，还有一些参数。理论上来说，编译器只是把消息分发变成objc_msgSend来执行。比如下面这两行代码是等价的。</p>

<pre><code>[array insertObject:foo atIndex:5];
objc_msgSend(array, @selector(insertObject:atIndex:), foo, 5);
</code></pre>

<hr />

<p>现在我们知道了objects,classes,selectors,IMPs以及消息分发，那么运行时到底能做什么呢？主要有两个作用：</p>

<ul>
<li>创建、修改、自省classes和objects</li>
<li>消息分发</li>
</ul>


<p>之前已经提过消息分发，不过这只是一小部分功能。所有的运行时方法都有特定的前缀。下面是一些有意思的方法：</p>

<h3>class</h3>

<p>class开头的方法是用来修改和自省classes。</p>

<ul>
<li>class_addIvar, class_addMethod, *class_addProperty和class_addProtocol允许重建classes。</li>
<li>class_copyIvarList, class_copyMethodList, class_copyProtocolList和class_copyPropertyList能拿到一个class的所有内容。</li>
<li>class_getClassMethod, class_getClassVariable, class_getInstanceMethod, class_getInstanceVariable, class_getMethodImplementation和class_getProperty返回单个内容。</li>
</ul>


<p>也有一些通用的自省方法，如class_conformsToProtocol, class_respondsToSelector, class_getSuperclass。最后，你可以使用class_createInstance来创建一个object。</p>

<h3>ivar</h3>

<p>这些方法能让你得到名字，内存地址和Objective-C type encoding。</p>

<h3>method</h3>

<p>这些方法主要用来自省，比如method_getName, method_getImplementation,  method_getReturnType等等。也有一些修改的方法，包括method_setImplementation和method_exchangeImplementations，这些我们后面会讲到。</p>

<h3>objc</h3>

<p>一旦拿到了object，你就可以对它做一些自省和修改。你可以get/set ivar, 使用object_copy和object_dispose来copy和free object的内存。最NB的不仅是拿到一个class，而是可以使用object_setClass来改变一个object的class。待会就能看到使用场景。</p>

<h3>property</h3>

<p>属性保存了很大一部分信息。除了拿到名字，你还可以使用property_getAttributes来发现property的更多信息，如返回值、是否为atomic、getter/setter名字、是否为dynamic、背后使用的ivar名字、是否为弱引用。</p>

<h3>protocol</h3>

<p>Protocols有点像classes，但是精简版的，运行时的方法是一样的。你可以获取method, property, protocol列表, 检查是否实现了其他的protocol。</p>

<h3>Cache</h3>

<p>在runtime.h中Cache的定义如下：</p>

<pre><code>   typedef struct objc_cache *Cache 
</code></pre>

<p> Cache为方法调用的性能进行优化，通俗地讲，每当实例对象接收到一个消息时，它不会直接在isa指向的类的方法列表中遍历查找能够响应消息的方法，因为这样效率太低了，而是优先在Cache中查找。Runtime 系统会把被调用的方法存到Cache中（理论上讲一个方法如果被调用，那么它有可能今后还会被调用），下次查找的时候效率更高。这根计算机组成原理中学过的 CPU 绕过主存先访问Cache的道理挺像，而我猜苹果为提高Cache命中率应该也做了努力吧。</p>

<h2>sel</h2>

<p>最后我们有一些方法可以处理 selectors，比如获取名字，注册一个selector等等。</p>

<h3>Methods, Selectors and IMPs</h3>

<p>我们知道了运行时会发消息给对象。我们也知道一个对象的class保存了方法列表。那么这些消息是如何映射到方法的，这些方法又是如何被执行的呢？</p>

<p>第一个问题的答案很简单。class的方法列表其实是一个字典，key为selectors，IMPs为value。一个IMP是指向方法在内存中的实现。很重要的一点是，selector和IMP之间的关系是在运行时才决定的，而不是编译时。这样我们就能玩出些花样。</p>

<p>IMP通常是指向方法的指针，第一个参数是self，类型为id，第二个参数是<em>cmd，类型为SEL，余下的是方法的参数。这也是self和</em>cmd被定义的地方。下面演示了Method和IMP</p>

<blockquote><p>Objective-C是一门简单的语言，95%是C。只是在语言层面上加了些关键字和语法。真正让Objective-C如此强大的是它的运行时。它很小但却很强大。它的核心是消息分发。</p></blockquote>

<h3>Objects, Classes, MetaClasses</h3>

<p>大多数面向对象的语言里有 classes 和 objects 的概念。Objects通过Classes生成。但是在Objective-C中，classes本身也是objects(译者注：这点跟python很像)，也可以处理消息，这也是为什么会有类方法和实例方法。具体来说，Objective-C中的Object是一个结构体(struct)，第一个成员是isa，指向自己的class。这是在objc/objc.h中定义的。</p>

<pre><code>typedef s   truct objc_object {
    Class isa;
} *id;
</code></pre>

<p>object的class保存了方法列表，还有指向父类的指针。但classes也是objects，也会有isa变量，那么它又指向哪儿呢？这里就引出了第三个类型: metaclasses。一个 metaclass被指向class，class被指向object。它保存了所有实现的方法列表，以及父类的metaclass。如果想更清楚地了解objects,classes以及metaclasses是如何一起工作地，可以阅读这篇文章。</p>

<h2>使用方式：</h2>

<h3>pragma mark 获取属性成员</h3>

<pre><code>/******************************************************************************

 *                                                                            *

 *                              Inquiry macros                                *

 *                                                                            *

 *                            iCocos--Description                             *

 *                                                                            *

 ******************************************************************************/

unsigned int count = 0;

Ivar *ivars = class_copyIvarList([iCocosObject class], &amp;count);

//    Ivar *ivars = class_copyMethodList(&lt;#__unsafe_unretained Class cls#&gt;, &lt;#unsigned int *outCount#&gt;)

//    Ivar *ivars = class_copyPropertyList(&lt;#__unsafe_unretained Class cls#&gt;, &lt;#unsigned int *outCount#&gt;);

//    Ivar *ivars = class_copyProtocolList(&lt;#__unsafe_unretained Class cls#&gt;, &lt;#unsigned int *outCount#&gt;)



for (int i = 0; i &lt; count; i++) {

    Ivar ivar = ivars[i];



    NSString *name = @(ivar_getName(ivar));

    NSLog(@"%@", name);



    NSLog(@"*****************");

    const char *iv = ivar_getName(ivar);





    NSLog(@"%s", iv);



    NSLog(@"*****************");

    const char *ivs =  ivar_getTypeEncoding(ivar);



    NSLog(@"%s", ivs);

}
</code></pre>

<h3>pragma mark 获取方法</h3>

<pre><code>/******************************************************************************

 *                                                                            *

 *                              Inquiry macros                                *

 *                                                                            *

 *                            iCocos--Description                             *

 *                                                                            *

 ******************************************************************************/

 unsigned int meth = 0;

Method *met = class_copyMethodList([iCocosObject class], &amp;meth);

for (int i = 0; i &lt; meth; i++) {

    Method m = met[i];



    SEL sel = method_getName(m);

    NSString *str = NSStringFromSelector(sel);



    NSLog(@"%@",str);

}
</code></pre>

<h3>pragma mark 获取协议</h3>

<pre><code>/******************************************************************************

 *                                                                            *

 *                              Inquiry macros                                *

 *                                                                            *

 *                            iCocos--Description                             *

 *                                                                            *

 ******************************************************************************/

 unsigned int pro = 0;

Protocol * __unsafe_unretained *proto =  class_copyProtocolList([iCocosObject class], &amp;pro);

for (int i = 0; i &lt; pro; i++) {

    Method p = (__bridge Method)(proto[i]);



    const char *pr = protocol_getName((__bridge Protocol *)(p));

//        NSString *str = NSStringFromSelector(pr);



    NSLog(@"%s",pr);

}
</code></pre>

<h3>pragma mark 获取属性</h3>

<pre><code>/******************************************************************************

 *                                                                            *

 *                              Inquiry macros                                *

 *                                                                            *

 *                            iCocos--Description                             *

 *                                                                            *

 ******************************************************************************/

 unsigned int xs = 0;

objc_property_t *xsL = class_copyPropertyList([iCocosObject class], &amp;xs);

for (int i = 0; i &lt; xs; i++) {

    objc_property_t xslist = xsL[i];



    const char *x = property_getName(xslist);

//        NSString *str = NSStringFromSelector(x);



    NSLog(@"%s",x);

}





//    objc_msgSend()

//    objc_getClass(&lt;#const char *name#&gt;);

//    sel_registerName(&lt;#const char *str#&gt;);



//     iCocosView *view = objc_msgSend(objc_msgSend(objc_getClass("iCocosView"), sel_registerName("alloc")), sel_registerName("init"));

Method one =  class_getClassMethod([iCocosObject class], @selector(iCocosMethos));

Method two =  class_getClassMethod([iCocosObject class], @selector(iCocosMetho));

method_exchangeImplementations(one, two);



Method o =  class_getInstanceMethod([iCocosObject class], @selector(iCocosMethos));

Method t =  class_getInstanceMethod([iCocosObject class], @selector(iCocosMetho));

method_exchangeImplementations(o, t);



//    class_getInstanceSize(&lt;#__unsafe_unretained Class cls#&gt;);

//    class_getInstanceVariable(&lt;#__unsafe_unretained Class cls#&gt;, &lt;#const char *name#&gt;);

//    class_getMethodImplementation_stret(&lt;#__unsafe_unretained Class cls#&gt;, &lt;#SEL name#&gt;);



//    class_getClassVariable(&lt;#__unsafe_unretained Class cls#&gt;, &lt;#const char *name#&gt;);

//    class_getSuperclass(&lt;#__unsafe_unretained Class cls#&gt;);



//    class_getProperty(&lt;#__unsafe_unretained Class cls#&gt;, &lt;#const char *name#&gt;);

//    class_getName(&lt;#__unsafe_unretained Class cls#&gt;);







//    class_replaceMethod(&lt;#__unsafe_unretained Class cls#&gt;, &lt;#SEL name#&gt;, &lt;#IMP imp#&gt;, &lt;#const char *types#&gt;);
</code></pre>

<h3>pragma mark 增加</h3>

<pre><code>/******************************************************************************

 *                                                                            *

 *                              Inquiry macros                                *

 *                                                                            *

 *                            iCocos--Description                             *

 *                                                                            *

 ******************************************************************************/
 //    class_addIvar(&lt;#__unsafe_unretained Class cls#&gt;, &lt;#const char *name#&gt;, &lt;#size_t size#&gt;, &lt;#uint8_t alignment#&gt;, &lt;#const char *types#&gt;);

//    class_addMethod(&lt;#__unsafe_unretained Class cls#&gt;, &lt;#SEL name#&gt;, &lt;#IMP imp#&gt;, &lt;#const char *types#&gt;);

//    class_addProperty(&lt;#__unsafe_unretained Class cls#&gt;, &lt;#const char *name#&gt;, &lt;#const objc_property_attribute_t *attributes#&gt;, &lt;#unsigned int attributeCount#&gt;);

//    class_addProtocol(&lt;#__unsafe_unretained Class cls#&gt;, &lt;#Protocol *protocol#&gt;);
</code></pre>

<h3>pragma mark 替换系统的addObject：（给数组或者其他类型做分类）</h3>

<pre><code>/******************************************************************************

 *                                                                            *

 *                              Inquiry macros                                *

 *                                                                            *

 *                            iCocos--Description                             *

 *                                                                            *

 ******************************************************************************/
 //在load中实现下面的代码

Method ic =  class_getInstanceMethod(NSClassFromString(@"_NSArrayM"), @selector(iCocosobject:));

Method add =  class_getInstanceMethod(NSClassFromString(@"_NSArrayM"), @selector(addObject:));

method_exchangeImplementations(ic, add);





//实现iCocosobject方法:(实现相应的功能，这里只是去掉非空)

//    if (object != nil) {

//        [self iCocosobject:object];

//    }
</code></pre>

<h2>实战</h2>

<h3>一：关联对象：给某一个类在运行的时候动态的增加一个成员变量</h3>

<pre><code>@interface NSObject(iCocos)



//头文件中声明一个属性

@property (nonatomic, assign) double height;



@end





@implementation NSObject(iCocos)



static double heightKey;//用来参考



-(void)setHeight:(double)height

{

    objc_setAssociatedObject(self, &amp;heightKey, @(height), OBJC_ASSOCIATION_ASSIGN);

}



-(double)height

{

    return [objc_getAssociatedObject(self, &amp;heightKey) doubleValue];

}
</code></pre>

<p>@end</p>

<h3>二：归档</h3>

<p><img src="/images/runtimedemo001.png" title="Caption" ></p>

<h3>三：字典转模型：</h3>

<p>之前使用的方法；</p>

<p><img src="/images/runtimedemo002.png" title="Caption" ></p>

<p>使用运行时</p>

<p>注意必须保证字典中的属性名和模型中的属性名一模一样</p>

<p><img src="/images/runtimedemo003.png" title="Caption" ></p>

<p>完善代码：</p>

<pre><code> @implementation NSObject (Model)



+ (instancetype)objcWithDict:(NSDictionary *)dict mapDict:(NSDictionary *)mapDict

{





    id objc = [[self alloc] init];



    unsigned int count = 0;

    Ivar *ivars = class_copyIvarList(self, &amp;count);



    for (int i = 0; i &lt; count; i++) {

        Ivar ivar = ivars[i];



        NSString *name = @(ivar_getName(ivar));



        name = [name substringFromIndex:1];



        id value = dict[name];



        if (value == nil) {



            if (mapDict) {

                NSString *mapName = mapDict[name];



                value = dict[mapName];

            }



        }



        [objc setValue:value forKeyPath:name];

    }





    return objc;

}



@end
</code></pre>

<h3>全屏返回</h3>

<pre><code>- (void)viewDidLoad {

    [super viewDidLoad];
    // 获取系统自带滑动手势的target对象
    id target = self.interactivePopGestureRecognizer.delegate;
    // 创建全屏滑动手势，调用系统自带滑动手势的target的action方法
    UIPanGestureRecognizer *pan = [[UIPanGestureRecognizer alloc] initWithTarget:target action:@selector(handleNavigationTransition:)];
    // 设置手势代理，拦截手势触发
    pan.delegate = self;
    // 给导航控制器的view添加全屏滑动手势
    [self.view addGestureRecognizer:pan];
    // 禁止使用系统自带的滑动手势
    self.interactivePopGestureRecognizer.enabled = NO;
    }
    // 什么时候调用：每次触发手势之前都会询问下代理，是否触发。
    // 作用：拦截手势触发
    - (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer
    {
        // 注意：只有非根控制器才有滑动返回功能，根控制器没有。
        // 判断导航控制器是否只有一个子控制器，如果只有一个子控制器，肯定是根控制器
        if (self.childViewControllers.count == 1) {
        // 表示用户在根控制器界面，就不需要触发滑动手势，
        return NO;
    }
    return YES;
}
</code></pre>

<hr />

<p>参考文章：</p>

<p><a href="http://www.cnblogs.com/iCocos/p/4782532.html">http://www.cnblogs.com/iCocos/p/4782532.html</a></p>

<p><a href="http://www.cnblogs.com/iCocos/p/4676679.html">http://www.cnblogs.com/iCocos/p/4676679.html</a></p>

<p><a href="http://www.cnblogs.com/iCocos/p/4734687.html">http://www.cnblogs.com/iCocos/p/4734687.html</a></p>

<p><a href="http://www.cnblogs.com/iCocos/p/4761600.html">http://www.cnblogs.com/iCocos/p/4761600.html</a></p>
]]></content>
  </entry>
  
</feed>
