<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Summary | iOS梦工厂]]></title>
  <link href="http://al1020119.github.io/blog/categories/summary/atom.xml" rel="self"/>
  <link href="http://al1020119.github.io/"/>
  <updated>2016-01-18T03:03:16+08:00</updated>
  <id>http://al1020119.github.io/</id>
  <author>
    <name><![CDATA[iCocos]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[第三方支付总结]]></title>
    <link href="http://al1020119.github.io/blog/2016/01/18/disanfangzhifu/"/>
    <updated>2016-01-18T11:35:08+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/01/18/disanfangzhifu</id>
    <content type="html"><![CDATA[<p>引言：
随着移动互联的发展，支付功能越来越流行，这也使得各大app公司不得不集成相关支付功能，文本就就此谈谈支付相关。</p>

<p>本文源码源码（封装）<a href="https://github.com/al1020119/iCocosPay">iCocosPay</a>（内集常见支付方案：成支付宝，微信，银联）</p>

<p>目录</p>

<ul>
<li>常见支付方案</li>
<li>第三方支付SDK</li>
<li>苹果官方支付方案</li>
<li>web支付方案</li>
</ul>


<h2>一:常见支付方案</h2>

<p>先来看一组截图</p>

<p><img src="/images/zhifu001.png" title="Caption" ></p>

<p><img src="/images/zhifu002.png" title="Caption" ></p>

<p><img src="/images/zhifu003.png" title="Caption" ></p>

<p><img src="/images/zhifu004.png" title="Caption" ></p>

<p><img src="/images/zhifu005.png" title="Caption" ></p>

<ul>
<li><p>微信支付</p></li>
<li><p>支付宝支付</p></li>
<li><p>银联（快捷）支付</p></li>
<li><p>京东支付</p></li>
<li><p>百度钱包</p></li>
<li><p>web支付</p></li>
<li><p>QQ钱包支付</p></li>
<li><p>连连支付</p></li>
</ul>


<p>￼￼￼￼
整理图：</p>

<p><img src="/images/zhifu006.png" title="Caption" ></p>

<h2>二：最常见的三种支付方式</h2>

<ul>
<li>微信支付SDK</li>
<li>支付宝支付SDK</li>
<li>银联快捷支付SDK</li>
</ul>


<h4>微信</h4>

<h5>什么是微信支付</h5>

<p>微信支付是集成在微信客户端的支付功能，用户可以通过手机完成快速的支付流程。微信支付以绑定银行卡的快捷支付为基础，向用户提供安全、快捷、高效的支付服务。</p>

<h5>申请流程：</h5>

<p>第一阶段：</p>

<p><img src="/images/zhifu007.png" title="Caption" ></p>

<p>第二阶段：</p>

<p><img src="/images/zhifu008.png" title="Caption" ></p>

<p>第三阶段：</p>

<p><img src="/images/zhifu009.png" title="Caption" ></p>

<h5>应用场景：</h5>

<p>商户APP调用微信提供的SDK调用微信支付模块，商户APP会跳转到微信中完成支付，支付完后跳回到商户APP内，最后展示支付结果。</p>

<h5>支付流程</h5>

<p>App内提交订单（确认支付）
商品信息确认（立即支付）
输入密码（进行支付）
支付成功</p>

<h5>App接入步骤</h5>

<p><img src="/images/zhifu010.png" title="Caption" ></p>

<h4>支付宝</h4>

<h5>什么是支付宝支付：</h5>

<p>支付宝移动支付是一种程序式的支付方式，在手机、掌上电脑等无线设备的应用程序内，买家可通过支付宝进行付款购买特定服务或商品，资金即时到账。</p>

<h5>申请流程</h5>

<p><img src="/images/zhifu011.png" title="Caption" ></p>

<h5>支付流程：</h5>

<p>买家再手机应用中购买商品或者服务
买家选择支付宝方式支付
进入支付宝收银台进行支付
支付成功
交易完成买家可查看交易信息
返回对应的app界面</p>

<h5>App接入步骤</h5>

<p><img src="/images/zhifu012.png" title="Caption" ></p>

<h4>银联</h4>

<h5>什么值银联支付</h5>

<p><img src="/images/zhifu013.png" title="Caption" ></p>

<h5>申请流程：</h5>

<p><img src="/images/zhifu014.png" title="Caption" ></p>

<h5>支付流程：</h5>

<p><img src="/images/zhifu015.png" title="Caption" ></p>

<h5>接入流程：</h5>

<p><img src="/images/zhifu016.png" title="Caption" ></p>

<h5>最后整理一下具体步骤：</h5>

<ol>
<li>首先客户端浏览商品，点击下单，请求到达商户后台。</li>
<li>商户后台再提交订单信息到银联后台。</li>
<li>银联后台返回交易流水号。</li>
<li>商户后台将交易流水号返回给客户端。</li>
<li>客户端再通过交易流水号启动手机控件开始支付。</li>
<li>支付控件收集支付信息并请求银联后台，完成支付后银联后台通知商户后台支付结果。</li>
<li>银联后台通知支付控件支付结果。</li>
<li>支付控件通知客户端支付结果。</li>
<li>最后客户端将支付结果展示给用户。</li>
</ol>


<h2>三：苹果官方支付方案</h2>

<ul>
<li>IPA</li>
<li>Apple Pay</li>
</ul>


<h3>IPA</h3>

<h5>什么是IPA：</h5>

<p>In App Purchase属于iPhone SDK3.0的新特性，用于在应用程序中购买付费道具，增加新功能，订阅杂志。是应用程序除了植入广告外的另一种取得收益的方式。</p>

<h5>IPA支持的产品类型：</h5>

<p><img src="/images/zhifu017.png" title="Caption" ></p>

<p>IPA两种支付方式：
方式一：内置产品类型</p>

<p><img src="/images/zhifu018.png" title="Caption" >
方式二：服务器类型</p>

<p><img src="/images/zhifu019.png" title="Caption" ></p>

<h5>注意事项：</h5>

<ol>
<li>你必须提供电子类产品和服务。不要使用In App Purchase 去出售实物和实际服务。</li>
<li>不能提供代表中介货币的物品，因为让用户知晓他们购买的商品和服务是很重要的。</li>
</ol>


<h5>相关流程：</h5>

<ol>
<li>程序向服务器发送请求，获得一份产品列表。</li>
<li>服务器返回包含产品标识符的列表。</li>
<li>程序向App Store发送请求，得到产品的信息。</li>
<li>App Store返回产品信息。</li>
<li>程序把返回的产品信息显示给用户（App的store界面）</li>
<li>用户选择某个产品</li>
<li>程序向App Store发送支付请求</li>
<li>App Store处理支付请求并返回交易完成信息。</li>
<li>程序从信息中获得数据，并发送至服务器。</li>
<li>服务器纪录数据，并进行审(我们的)查。</li>
<li>服务器将数据发给App Store来验证该交易的有效性。</li>
<li>App Store对收到的数据进行解析，返回该数据和说明其是否有效的标识。</li>
<li>服务器读取返回的数据，确定用户购买的内容。</li>
<li>服务器将购买的内容传递给程序。</li>
</ol>


<h3>Apple Pay</h3>

<h5>什么是Apple Pay：</h5>

<p>Apple Pay与诸多传统移动支付系统不同，不但有Touch ID指纹识别技术护航，还能在Apple Watch上运作。</p>

<h5>相关流程：</h5>

<ol>
<li>程序通过bundle存储的plist文件得到产品标识符的列表。</li>
<li>程序向App Store发送请求，得到产品的信息。</li>
<li>App Store返回产品信息。</li>
<li>程序把返回的产品信息显示给用户（App的store界面）</li>
<li>用户选择某个产品</li>
<li>程序向App Store发送支付请求</li>
<li>App Store处理支付请求并返回交易完成信息。</li>
<li>App获取信息并提供内容给用户。</li>
</ol>


<h2>四：web支付方案</h2>

<h5>概述：</h5>

<p>iOS中通过UIWebView展示WAP或HTML5支付页面，从而完成支付功能，无需接入额外第三方SDK。
UIWebView是iOS SDK中一个最常用的控件，是内置的浏览器控件，我们可以用它来浏览网页、打开文档等等。</p>

<h5>类型界面：</h5>

<p><img src="/images/zhifu020.png" title="Caption" ></p>

<p>总结：</p>

<p>最后本人根据实际开发整理了一份关于支付的源码（封装）<a href="https://github.com/al1020119/iCocosPay">iCocosPay</a>，内集成了：支付宝支付，微信支付，银联快捷支付！</p>

<p>你是不是在找接口文档？</p>

<ul>
<li><a href="https://pay.weixin.qq.com/wiki/doc/api/index.html">微信支付</a></li>
<li><a href="https://b.alipay.com/order/productDetail.htm?productId=2015110218010538&amp;tabId=1#ps-tabinfo-hashhttp://doc.open.alipay.com/doc2/detail?treeId=59&amp;articleId=103563&amp;docType=1">支付宝支付</a></li>
<li><a href="https://open.unionpay.com/ajweb/index">银联</a></li>
<li><a href="https://b.alipay.com/order/productDetail.htm?productId=2015110218008816https://open.unionpay.com/ajweb/help/file/techFile?productId=66">Web支付</a></li>
<li><a href="https://developer.apple.com/in-app-purchase/">IAP</a></li>
<li><a href="https://developer.apple.com/apple-pay/">Apple Pay</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[图片处理-异步缓存优化]]></title>
    <link href="http://al1020119.github.io/blog/2016/01/15/tupianyibuhuancun/"/>
    <updated>2016-01-15T02:35:08+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/01/15/tupianyibuhuancun</id>
    <content type="html"><![CDATA[<ol>
<li>引言</li>
</ol>


<p>过去的几年里，iOS 应用在视觉方面越来越吸引人。图像展示是其中很关键的部分，因为大部分图像展示都需要下载并且渲染。大部分开发者都要使用图像填充表格视图（table views）或者集合视图（collection views）。下载图片消耗一些资源（如蜂窝数据、电池以及 CPU 等）。为了减少资源消耗，一些缓存模型也应运而生。</p>

<p>为了获得良好的用户体验，当我们缓存和加载图像时，了解 iOS 底层如何处理是很重要的。此外，大多数使用了图片缓存的开源库也是个不错解决方案。</p>

<!--more-->


<ol>
<li><p>常用的解决途径</p>

<p> 异步下载图像
 处理图像（拉伸，去红眼，去边框）以便展示
 写入磁盘
 需要时从磁盘读取并展示</p>

<p> // 假设我们有一个 NSURL <em>imageUrl and UIImageView </em>imageView, 我们需要通过NSURL下载图片并在UIImageview上展示</p>

<pre><code> if ([self hasImageDataForURL:imageUrl] {
     NSData *data = [self imageDataForUrl:imageUrl];
     UIImage *image = [UIImage imageWithData:imageData];
     dispatch_async(dispatch_get_main_queue(), ^{
         imageView.image = image;
     });
 } else {
     [self downloadImageFromURL:imageUrl withCompletion:^(NSData *imageData, …) {
         [self storeImageData:imageData …];
         UIImage *image = [UIImage imageWithData:imageData];
         dispatch_async(dispatch_get_main_queue(), ^{
             imageView.image = image;
         });
     }];
 }
</code></pre></li>
</ol>


<p>FPS 简介</p>

<pre><code>UI 渲染理想情况 FPS=60
60FPS =&gt; 16.7ms 每帧，这就意味着如果任何主线程操作大于 16.7ms，动态 FPS 将会下降，因为 CPU 忙于处理其他事情，而不是渲染 UI。
</code></pre>

<ol>
<li><p>常用解决途径的缺点</p>

<p> 从磁盘加载图像或文件时间消耗昂贵（磁盘读取比内存读取慢大概 10-1000 倍，如果是 SSD 硬盘，则可能与内存读取速度更接近（大概慢 10 倍）。参考这里的比较：Introduction to RAM Disks
 如果使用 SSD，将获得接近内存的速度（大概比内存访问速度慢十倍），但目前还没有手机和平板集成 SSD 模块。
 创建 UIImage 实例将会在内存区生成一个图片的压缩版。但是压缩后的图像太小且无法渲染，如果我们从磁盘加载图像，图像甚至都没有加载到内存。解压图片同样也很消耗资源。
 设置 imageView 的 image 属性，这种情况下将会创建一个 CATransaction 并加入主循环中。在下一次循环迭代中，CATransaction 会对任何设置为 layer contents 的图像进行拷贝。</p></li>
</ol>


<p>拷贝图像包含以下过程：</p>

<pre><code>给文件 io 和解压缩分配缓冲区
读取磁盘数据到内存
解压图像数据（生成原位图） - 高 CPU 消耗
CoreAnimation 使用解压数据并渲染
</code></pre>

<p>字节位没有正确对齐的图像将被 CoreAnimation 拷贝，以修复字节位对齐并使之能被渲染。这一点在 Apple 文档里没有说明，但是使用 Instruments 表明 CA::Render::copy_image 会执行此操作，即使 Core Aniation 即使没有拷贝图像。</p>

<p>从 iOS7 开始，第三方应用不能使用JPEG硬件解码器。这意味着我们只能使用慢很多的软解码器。这一点在 FastImageCache 团队的 GitHub 主页以及 Nick Lockwood 的推文上都有指出。
4. 一个强大的 iOS 图像缓存需包含以下部分：</p>

<pre><code>异步下载图像，尽可能减少使用主线程队列
使用后台队列解压图像。这是个复杂的过程，请阅读 Avoiding Image Decompression Sickness
在内存和磁盘上缓存图像。在磁盘上缓存图像很重要，因为 App 可能因为内存不足而被强行关闭或者需要清理内存。这种情况下，重新从磁盘加载图像比下载会快很多。
备注：如果使用 NSCache 作为内存缓存，当有内存警告时，NSCache 会清空缓存内容。NSCache 相关细节请查看 nshipster 文章：NSCache
保存解压过的图片到硬盘以及内存中，以避免再次解压。
使用 GCD 和 blocks，这将使得代码更加高效和简单，如今 GCD 和 blocks 是异步操作时必需的。
最好使用 UIImageView 的分类以便集成
最好在下载后以及存入到缓存前能够处理图像
</code></pre>

<p>iOS图像优化</p>

<p>更多的成像相关以及 SDK 框架（CoreGraphics, ImageIO, CoreAnimation, CoreImage)工作原理，CPU vs GPU 等，请阅读 @rsebbe 的文章：Advanced Imaging on iOS
Core Data 是一个好的选择吗？</p>

<p>这有一篇文章&ndash;CoreData 对比 File System，实现图像缓存的基准测试，结果 File System 的表现更好。</p>

<p>看一看上面罗列的观点，自己实现图像缓存不仅复杂，耗时而且痛苦。这也是为什么我倾向于使用开源的图像缓存解决方案，你们大部分已经听说过 SDWebImage 或 new FastImageCache。</p>

<p>为了让你知道哪个开源库最适合你，我做了测试并且分析它们如何满足上述要求。
5. 基准测试</p>

<p>测试库：</p>

<pre><code>SDWebImage - version 3.5.4
FastImageCache - version 1.2
AFNetworking - version 2.2.1
TMCache - version 1.2.0
Haneke - version 0.0.5
</code></pre>

<p>注：AFNetworking 加入对比是由于其自iOS7后在磁盘缓存方面出色的表现（基于 NSURLCache 实现）
测试场景</p>

<p>对于每个库，我都会使用全新的测试app，然后启动app，等所有图像加载完后，慢慢滑动。然后以不同力度来回滑动（从慢到快）。接着关掉app强制应用从磁盘缓存中加载图像，最后重复以上测试场景。
关于测试 App 工程</p>

<pre><code>相关 demo 可以在 GitHub 找到并获取，名字是 ImageCachingBenchmark，同时还有本次实验的图表、结果数据表以及更多。

请注意，请注意 GitHub 上的工程和图像缓存库都需要做一些调整，以便能让我们看到每一张缓存的图片都能够被加载出来。由于我不想检查 Cocoapods 源码文件（不是个好习惯），所以需要对 Cocoapods clean 后重新编译工程代码，目前 GitHub 上的版本与我做测试的版本有些差别。

如果你们想重新跑一下测试，你需要编写相同 completionBlock 用于图像加载，所有库得要跟默认的 SDWebImage 一样返回 SDImageCacheType。
</code></pre>

<p>最快与最慢的设备对比结果</p>

<p>在 GitHub 工程上能看到完整的基准测试结果，由于这些表格很大，我只使用运行最快的设备 iPhone 5s 和运行最慢的 iPhone 4 来测试。</p>

<p>汇总：</p>

<p>表格名词解释：</p>

<pre><code>异步下载：库支持异步下载
后台解压：通过后台队列或线程执行图像解压
存储解压：存储解压后的图像版本
内存/磁盘缓存：支持内存/磁盘缓存
UIImageView 分类：库中含 UIImageView 类别
从内存/磁盘：从缓存（内存/磁盘）中读取的平均时间
</code></pre>

<ol>
<li><p>结论</p>

<p> 从头开始编写 iOS 图像缓存组件很困难</p>

<p> SDWebImage 和 AFNetworking 是稳定的工程。由于有很多贡献者，这样保证代码能够及时得到维护，FastImageCache 在维护方面更新很快。</p>

<p> 基于以上所有数据，我认为 SDWebImage 在目前是一个很好的解决方案。即使有些工程使用 AFNetworking 或 FastImageCache 更好，但是这些都依赖于项目需求。
tu</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[图片优化-总结]]></title>
    <link href="http://al1020119.github.io/blog/2016/01/15/tupianchuliyouhuajiqiao/"/>
    <updated>2016-01-15T01:21:08+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/01/15/tupianchuliyouhuajiqiao</id>
    <content type="html"><![CDATA[<p>主要针对问题</p>

<ul>
<li><p>图片文件比较大</p></li>
<li><p>图片文件比较多</p></li>
</ul>


<h4>网络图片显示大体步骤:</h4>

<ul>
<li>下载图片</li>
<li>图片处理（裁剪，边框等)</li>
<li>写入磁盘</li>
<li>从磁盘读取数据到内核缓冲区</li>
<li>从内核缓冲区复制到用户空间(内存级别拷贝)</li>
<li>解压缩为位图（耗cpu较高）</li>
<li>如果位图数据不是字节对齐的，CoreAnimation会copy一份位图数据并进行字节对齐</li>
<li>CoreAnimation渲染解压缩过的位图</li>
<li>以上4，5，6，7，8步是在UIImageView的setImage时进行的，所以默认在主线程进行(iOS UI操作必须在主线程执行)。</li>
</ul>


<!--more-->


<h4>一些优化思路：</h4>

<ul>
<li>异步下载图片</li>
<li>image解压缩放到子线程</li>
<li>使用缓存 (包括内存级别和磁盘级别)</li>
<li>存储解压缩后的图片，避免下次从磁盘加载的时候再次解压缩</li>
<li>减少内存级别的拷贝 （针对第5点和第7点）</li>
<li>良好的接口（比如SDWebImage使用category）</li>
<li>Core Data vs 文件存储</li>
<li>图片预下载</li>
</ul>


<p>在IOS下通过URL读一张网络图片并不像其他编程语言那样可以直接把图片路径放到图片路径的位置就ok，而是需要我们通过一段类似流的方式去加载网络图片，接着才能把图片放入图片路径显示。比如：</p>

<pre><code>-(UIImage *) getImageFromURL:(NSString *)fileURL {
  //NSLog(@"执行图片下载函数");    
  UIImage * result;    
  NSData * data = [NSData dataWithContentsOfURL:[NSURL URLWithString:fileURL]];
  result = [UIImage imageWithData:data];    
  return result;
}
</code></pre>

<p>加载网络图片可以说是网络应用中必备的。如果单纯的去下载图片，而不去做多线程、缓存等技术去优化，加载图片时的效果与用户体验就会很差。</p>

<p>优化思路为：</p>

<p>（1）本地缓存</p>

<p>（2）异步加载</p>

<p>（3）加载完毕前使用占位图片</p>

<h3>优化方法</h3>

<h5>方法1：用NSOperation开异步线程下载图片，当下载完成时替换占位图片</h5>

<pre><code>#import "XNViewController.h"
#import "XNApp.h"

@interface XNViewController ()
@property (nonatomic, strong) NSArray *appList;
@property (nonatomic, strong) NSOperationQueue *queue;
@end

@implementation XNViewController
#pragma mark - 懒加载

- (NSOperationQueue *)queue {
    if (!_queue) _queue = [[NSOperationQueue alloc] init];
    return _queue;
}

//可抽取出来写到模型中
- (NSArray *)appList {
    if (!_appList) {
        //1.加载plist到数组中
        NSURL *url = [[NSBundle mainBundle] URLForResource:@"apps.plist" withExtension:nil];
        NSArray *array = [NSArray arrayWithContentsOfURL:url];
        //2.遍历数组
        NSMutableArray *arrayM = [NSMutableArray array];
        [array enumerateObjectsUsingBlock: ^(id obj, NSUInteger idx, BOOL *stop) {
            [arrayM addObject:[XNApp appWithDict:obj]];  //数组中存放的是字典, 转换为app对象后再添加到数组
        }];
        _appList = [arrayM copy];
    }
    return _appList;
}

- (void)viewDidLoad {
    [super viewDidLoad];

    self.tableView.rowHeight = 88;

//    NSLog(@"appList-%@",_appList);
}

#pragma mark - 数据源方法
- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section {
    return self.appList.count;
}

- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {
    static NSString *ID = @"Cell";
    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:ID];

    //用模型来填充每个cell
    XNApp *app = self.appList[indexPath.row];
    cell.textLabel.text = app.name;  //设置文字

    //设置图像: 模型中图像为nil时用默认图像,并下载图像. 否则用模型中的内存缓存图像.
    if (!app.image) {
        cell.imageView.image = [UIImage imageNamed:@"user_default"];

        [self downloadImg:indexPath];
    }
    else {
        //直接用模型中的内存缓存
        cell.imageView.image = app.image;
    }
//  NSLog(@"cell--%p", cell);

    return cell;
}

/**始终记住, 通过模型来修改显示. 而不要试图直接修改显示*/
- (void)downloadImg:(NSIndexPath *)indexPath {
    XNApp *app  = self.appList[indexPath.row]; //取得改行对应的模型

    [self.queue addOperationWithBlock: ^{
        NSData *imgData = [NSData dataWithContentsOfURL:[NSURL URLWithString:app.icon]]; //得到图像数据
        UIImage *image = [UIImage imageWithData:imgData];

        //在主线程中更新UI
        [[NSOperationQueue mainQueue] addOperationWithBlock: ^{
            //通过修改模型, 来修改数据
            app.image = image;
            //刷新指定表格行
            [self.tableView reloadRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationNone];
        }];
    }];
}

@end
</code></pre>

<p>上述代码只是做了内存缓存，还没有做本地缓存，因为这里这种方法不是重点，也不是首选方法。上面代码每次重新进入应用时，还会从网上重新下载。如果要继续优化上面的代码，需要自己去实现本地缓存。</p>

<h5>方法2：使用第三方框架SDWebImage</h5>

<p>依赖的库很少，功能全面。</p>

<p>自动实现磁盘缓存：缓存图片名字是以MD5进行加密的后的名字进行命名.(因为加密那堆字串是唯一的)</p>

<p>加载网络图片时直接设置占位图片：</p>

<pre><code>[imageView sd_setImageWithURL:imageurl  placeholderImage:[UIImage imageNamed:@”xxxxx”]]。
</code></pre>

<p>就一个方法就实现了多线程\带缓冲等效果.(可用带参数的方法,具体可看头文件)</p>

<pre><code>#pragma mark - 数据源方法
- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section {
    return self.appList.count;
}

- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {
    static NSString *ID = @"Cell";
    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:ID];

    //用模型来填充每个cell
    XNApp *app = self.appList[indexPath.row];
    cell.textLabel.text = app.name;  //设置文字

//  //设置图像: 模型中图像为nil时用默认图像,并下载图像. 否则用模型中的内存缓存图像.
//  if (!cell.imageView.image) {
//      cell.imageView.image = [UIImage imageNamed:@"user_default"];
//
//      [self downloadImg:indexPath];
//  }
//  else {
//      //直接用模型中的内存缓存
//      cell.imageView.image = app.image;
//  }


    //使用SDWebImage来完成上面的功能. 针对ImageView.
    //一句话, 自动实现了异步下载. 图片本地缓存. 网络下载. 自动设置占位符.
    [cell.imageView sd_setImageWithURL:[NSURL URLWithString:app.icon] placeholderImage:[UIImage imageNamed:@"user_default"]];


    return cell;
}

/**始终记住, 通过模型来修改显示. 而不要试图直接修改显示*/
//- (void)downloadImg:(NSIndexPath *)indexPath {
//  XNApp *app  = self.appList[indexPath.row]; //取得改行对应的模型
//
//  [self.queue addOperationWithBlock: ^{
//      NSData *imgData = [NSData dataWithContentsOfURL:[NSURL URLWithString:app.icon]]; //得到图像数据
//      UIImage *image = [UIImage imageWithData:imgData];
//
//      //在主线程中更新UI
//      [[NSOperationQueue mainQueue] addOperationWithBlock: ^{
//          //通过修改模型, 来修改数据
//          app.image = image;
//          //刷新指定表格行
//          [self.tableView reloadRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationNone];
//      }];
//  }];
//}

@end
</code></pre>

<p>如果你觉得SDWebImage不好用那么你可以试试FastImageCache这个框架：</p>

<p>FastImageCache是Path团队开发的一个开源库，用于提升图片的加载和渲染速度，让基于图片的列表滑动起来更顺畅，来看看它是怎么做的。</p>

<p>优化点</p>

<p>iOS从磁盘加载一张图片，使用UIImageVIew显示在屏幕上，需要经过以下步骤：</p>

<ul>
<li>从磁盘拷贝数据到内核缓冲区</li>
<li>从内核缓冲区复制数据到用户空间</li>
<li>生成UIImageView，把图像数据赋值给UIImageView</li>
<li>如果图像数据为未解码的PNG/JPG，解码为位图数据</li>
<li>CATransaction捕获到UIImageView layer树的变化</li>
<li><p>主线程Runloop提交CATransaction，开始进行图像渲染</p>

<ul>
<li><p>6.1 如果数据没有字节对齐，Core Animation会再拷贝一份数据，进行字节对齐。</p></li>
<li><p>6.2 GPU处理位图数据，进行渲染。</p></li>
</ul>
</li>
</ul>


<p>FastImageCache分别优化了2,4,6.1三个步骤：</p>

<ul>
<li>使用mmap内存映射，省去了上述第2步数据从内核空间拷贝到用户空间的操作。</li>
<li>缓存解码后的位图数据到磁盘，下次从磁盘读取时省去第4步解码的操作。</li>
<li>生成字节对齐的数据，防止上述第6.1步CoreAnimation在渲染时再拷贝一份数据。</li>
</ul>


<h3>常用的开源库对比</h3>

<table>
<thead>
<tr>
<th>tip </th>
<th style="text-align:center;"> SDWebImage   </th>
<th style="text-align:right;">AFNetworking </th>
<th>    FastImageCache </th>
</tr>
</thead>
<tbody>
<tr>
<td>异步下载图片     </td>
<td style="text-align:center;">YES </td>
<td style="text-align:right;"> YES  </td>
<td>NO </td>
</tr>
<tr>
<td>子线程解压缩     </td>
<td style="text-align:center;">YES    </td>
<td style="text-align:right;">YES </td>
<td> YES </td>
</tr>
<tr>
<td>子线程图片处理(缩放，圆角等)  </td>
<td style="text-align:center;">YES </td>
<td style="text-align:right;"> YES </td>
<td>   YES </td>
</tr>
<tr>
<td>存储解压缩后的位图    </td>
<td style="text-align:center;">YES    </td>
<td style="text-align:right;">YES    </td>
<td>YES </td>
</tr>
<tr>
<td>内存级别缓存     </td>
<td style="text-align:center;">YES    </td>
<td style="text-align:right;">YES   YES</td>
<td></td>
</tr>
<tr>
<td>磁盘级别缓存     </td>
<td style="text-align:center;">YES </td>
<td style="text-align:right;"> YES </td>
<td>   YES </td>
</tr>
<tr>
<td>UIImageView category </td>
<td style="text-align:center;">    YES </td>
<td style="text-align:right;">   NO </td>
<td>    NO </td>
</tr>
<tr>
<td>减少内存级别的拷贝    </td>
<td style="text-align:center;">NO     </td>
<td style="text-align:right;">NO     </td>
<td>YES </td>
</tr>
<tr>
<td>接口易用性 </td>
<td style="text-align:center;"> *** </td>
<td style="text-align:right;">   *** </td>
<td>   * </td>
</tr>
</tbody>
</table>


<h3>总结</h3>

<ul>
<li><p>使用低分辨率图：仔细想想，其实没有必要第一时间加载全部图片的高清原图，事先存好每张图配套的低分辨率图，用空间换时间。
先加载所有的图片的低分辨率图, 当用户翻阅到某一张图片时, 即时的加载原始尺寸的高清无码大图. 过程优化为：</p></li>
<li><p>多线程任务：即使是这样，当照片数量达到一定量时，需要消耗的时间也并非毫秒级，体验无法领人满意,  页面跳转时仍然会出现卡顿现象。
于是考虑使用多线程来进一步拆分任务， 执行跳转的同时再后台执行加载低分辨率图的步骤.</p></li>
<li><p>优化快速翻阅体验：通过这样的拆分，可以实现立即跳转，体验满意。但是翻阅浏览时，当用户很快左右滑动时, 出现黑屏的几率很高, 因为加载低分辨率图任务的线程可能还在进行大量IO操作，不能及时跟上。 为了完善它，要把加载低分辨率图的步骤再次分解，精益求精。
在页面跳转时间允许的范围内，加载用户选定的那张图片的高清原图的同时，尽可能多的加载几张左右临近的图片的低分辨率图。</p></li>
</ul>


<blockquote><p>尽量减少内存占用.  因为原始图片要比低分辨率图大很多, 所以当用户从一张图片翻阅到另一张图片时,  当前图片加载为原始尺寸的高清大图, 而原来那张就被替换为低分辨率图了。 虽然读写次数增多了, 但内存确实省了不少。</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[图片处理-补充]]></title>
    <link href="http://al1020119.github.io/blog/2016/01/14/tupianchulibuchong/"/>
    <updated>2016-01-14T16:21:08+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/01/14/tupianchulibuchong</id>
    <content type="html"><![CDATA[<p>前面介绍了iOS开发中常见的图片处理方式，而在iOS开发中除了前面几个提到的，还有两个东西是最值得注意的东西，那就是选择什么格式的图片，和怎么去加载图片，下面就来补充一下！</p>

<ol>
<li><p>图片资源使用png还是jpg格式</p></li>
<li><p>如何选择图片加载方式imageNamed&amp;imageWithContentsOfFile</p></li>
</ol>


<h3>图片资源使用png还是jpg格式</h3>

<!--more-->


<p>对于iOS本地应用程序来说最简单的答案就是始终使用PNG，除非你有非常非常好的理由不用它。</p>

<p>当iOS应用构建的时候，Xcode会通过一种方式优化.png文件而不会优化其它文件格式。它优化得相当的好</p>

<p>他们之间有以下区别：</p>

<ol>
<li><p>同个分辨率的图片，保存为png要比jpg大；</p></li>
<li><p>png图片有alpha通道，因此它支持图片透明，这点在ios开发中尤为重要；而jpg不支持透明</p></li>
<li><p>xcode会对png格式进行特殊的优化处理，而对于其他图片不做处理</p></li>
</ol>


<p>总结一下有以下几点：</p>

<pre><code>1.如果你的图片都是xcode本地就有，那就用png；如果图片是从网络上下载的，考虑到流量以及速度，可以考虑用jpg因为它具有较高的压缩率

2.本地的png优化由xcode帮你做；其他格式的需要在程序运行时做优化，更耗性能

3.如果你的图片要求有较高的色彩饱和度、图像质量，那就用jpg
</code></pre>

<h3>如何选择图片加载方式imageNamed&amp;imageWithContentsOfFile</h3>

<p>IOS内存稀缺，而图片资源通常又是最占内存的部分之一，因此，选择如何加载图片，对于优化应用内存占用量，能起到立竿见影的效果。通常加载图片的方式有两种：</p>

<h5>一、imageNamed</h5>

<p>为什么有两种方法完成同样的事情呢？imageNamed的优点在于可以缓存已经加载的图片。苹果的文档中有如下说法：</p>

<pre><code>This method looks in the system caches for an image object with the specified name and returns that object if it exists. If a matching image object is not already in the cache, this method locates and loads the image data from disk or asset catelog, and then returns the resulting object. You can not assume that this method is thread safe.
</code></pre>

<p>这种方法会首先在系统缓存中根据指定的名字寻找图片，如果找到了就返回。如果没有在缓存中找到图片，该方法会从指定的文件中加载图片数据，并将其缓存起来，然后再把结果返回，下次再使用该名称图片的时候就省去了从硬盘中加载图片的过程。对于相同名称的图片，系统只会把它Cache到内存一次。</p>

<p>另外，在iOS4及以上系统中，如果是PNG格式的图片，使用该方法加载时不用再指定文件的.png后缀，即只写文件名称即可。</p>

<blockquote><p>最后，在iOS4及以上系统中，如果屏幕的scale是2（即高分辨率屏幕），该方法会自动使用加上@2x后缀的图片。比如在高分辨率屏幕设备上要加载名称为button的图片，该方法会自动使用名称为button@2x的图片；如果找不到该名称图片再去加载名称为button的图片。这就为开发者省去了适配高、低分辨率屏幕的时间。</p></blockquote>

<h5>二、imageWithContentsOfFile或者imageWithData</h5>

<p>而imageWithContentsOfFile方法只是简单的加载图片，并不会将图片缓存起来，图像会被系统以数据方式加载到程序。当你不需要重用该图像，或者你需要将图像以数据方式存储到数据库，又或者你要通过网络下载一个很大的图像时，可以使用这种方式。</p>

<h5>三、如何选择</h5>

<p>两种加载图片方法的使用方式：</p>

<pre><code>UIImage *img = [UIImage imageNamed:@"myImage"]; // caching    
// or    
UIImage *img = [UIImage imageWithContentsOfFile:@"myImage"]; // no caching  
</code></pre>

<p>那么该如何选择呢？</p>

<ul>
<li><p>如果加载一张很大的图片，并且只使用一次，那么就不需要缓存这个图片。这种情况imageWithContentsOfFile比较合适——系统不会浪费内存来缓存图片。</p></li>
<li><p>然而，如果在程序中经常需要重用的图片，比如用于UITableView的图片，那么最好是选择imageNamed方法。这种方法可以节省出每次都从磁盘加载图片的时间。</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[图片处理-高级篇]]></title>
    <link href="http://al1020119.github.io/blog/2016/01/14/tupianchuligaojijiqiao/"/>
    <updated>2016-01-14T12:21:08+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/01/14/tupianchuligaojijiqiao</id>
    <content type="html"><![CDATA[<h3>一：UIImage的加载方式</h3>

<p>上一篇文章的补充中也提到了这个，关于图片的加载方式，但是没有过多的涉及，这里就大概的总结一下，希望能有用！</p>

<p>显示关于图片加载问题，由于正在做的项目用到很多图片，加载后内存问题很是头疼，这里是我的经验，大概说一个下。
     一般加载图片的方式：
第一种：</p>

<pre><code>NSString * imagePath = [[NSBundle mainBundle] pathForResource:@"pic@.png" ofType:nil inDirectory:nil];  
UIImage * image = [UIImage imageWithContentsOfFile:imagePath];  
</code></pre>

<p>第二种：</p>

<pre><code>UIImage * image = [UIImage imageNamed:picName];  
</code></pre>

<!--more-->


<p>这两种是我经常用到的</p>

<ul>
<li>用imageWithContentOfFile 加载图片的时候，图片不会做缓存，这样在加载大的图片和使用率低的图片的时候就可以用到。我建议大家使用这种，对控制内存很有帮助。</li>
<li>用imageName的加载的时候，系统会件图像保存在内存中去，下次利用的时候，直接在内存中调用，速度很快，重复利用率高的图片有利于这样做，但是在释放内存的时候比较麻烦，只有程序结束的时候内存才释放，有时候会出现内存警告。。。</li>
</ul>


<h3>二：图片的混合模式</h3>

<p>接下来我们看看图片一下常用的混合模式，我觉得这个最好是先自己玩一玩photoshop，上面有很多混合模式可以自己试验，这里我们用代码进行尝试修改图片的混合模式，这样可以看到不同的图片效果。
这里我们就必须用到绘图。常用的方法是：</p>

<pre><code>[image drawInRect:CGRectMake(0,0,newSize.width,newSize.height) blendMode:blendMode alpha:alpha];  
</code></pre>

<p>先让大家看看这个代码：</p>

<pre><code>- (UIImage *)drawPiucureFrontImage:(UIImage *)personImage backImage:(UIImage *)hatImage blendMode:(CGBlendMode)blendMode alpha:(CGFloat)alpha  
{  
    CGSize newSize =[personImage size];  
    UIGraphicsBeginImageContext(newSize);  
    [personImage drawInRect:CGRectMake(0,0,newSize.width,newSize.height) blendMode:kCGBlendModeNormal alpha:1];  
    [hatImage drawInRect:CGRectMake(0,0,newSize.width,newSize.height) blendMode:blendMode alpha:alpha];  
    UIImage*newImage = UIGraphicsGetImageFromCurrentImageContext();  
    UIGraphicsEndImageContext();  
    _imageV.image = newImage;  
    num++;  
    return newImage;  
}  
</code></pre>

<p>kCGBlendModeNormal<br/>
这个是混合模式的效果  在ps中是正常，以下是常用的模式</p>

<pre><code>     kCGBlendModeNormal --ok  正常,
     kCGBlendModeMultiply,    正片叠底
     kCGBlendModeScreen,      滤色
     kCGBlendModeOverlay,     叠加
     kCGBlendModeDarken,      变暗
     kCGBlendModeLighten,     变亮
     kCGBlendModeColorDodge,  颜色减淡
     kCGBlendModeColorBurn,   颜色加深
     kCGBlendModeSoftLight,   柔光
     kCGBlendModeHardLight,   强光
     kCGBlendModeDifference,  差值
     kCGBlendModeExclusion,   排除
     kCGBlendModeHue,         色相
     kCGBlendModeSaturation,  保护度
     kCGBlendModeColor,       颜色
     kCGBlendModeLuminosity   明度,
</code></pre>

<p>这几个可以试试，每一种图片的模式都不一样。其中正片叠底 和叠加应该是我经常用到的混合模式。</p>

<h3>三：图片的滤镜</h3>

<p>上面我们介绍了图片的混合模式，接下来我们来看看图片滤镜，说道滤镜网上有很多的教程，在code4app中也有很多的教程，大家可以去看看看，这里我们使用一个第三方的类  ImageUtil.h，在后面有下载的链接</p>

<p>将这个类导入到自己的工程中 导入头文件：</p>

<pre><code>#import "ImageUtil.h"     
</code></pre>

<p>接下来直接调用里面的放大就可以了，在这个类中ColorMatrix.h的文件中，我们可以看见有13中特效可以自己使用，而且调用也十分简单</p>

<pre><code>[ImageUtil imageWithImage:_imageV.image withColorMatrix:colormatrix_heibai];  
</code></pre>

<p>colormatrix_heibai 这个就是他的调用样式，这里是黑白，大家可以替换修改在ColorMatrix.h名字，已达到自己想要的效过，这个方法同时也返回一个UIimage，这样就可以加载到自己想要的UIImageView上了。
下面是特效</p>

<pre><code>//LOMO  
const float colormatrix_lomo[] = {  
    1.7f,  0.1f, 0.1f, 0, -73.1f,  
    0,  1.7f, 0.1f, 0, -73.1f,  
    0,  0.1f, 1.6f, 0, -73.1f,  
    0,  0, 0, 1.0f, 0 };  

//黑白  
const float colormatrix_heibai[] = {  
    0.8f,  1.6f, 0.2f, 0, -163.9f,  
    0.8f,  1.6f, 0.2f, 0, -163.9f,  
    0.8f,  1.6f, 0.2f, 0, -163.9f,  
    0,  0, 0, 1.0f, 0 };  
//复古  
const float colormatrix_huajiu[] = {   
    0.2f,0.5f, 0.1f, 0, 40.8f,  
    0.2f, 0.5f, 0.1f, 0, 40.8f,   
    0.2f,0.5f, 0.1f, 0, 40.8f,   
    0, 0, 0, 1, 0 };  

//哥特  
const float colormatrix_gete[] = {   
    1.9f,-0.3f, -0.2f, 0,-87.0f,  
    -0.2f, 1.7f, -0.1f, 0, -87.0f,   
    -0.1f,-0.6f, 2.0f, 0, -87.0f,   
    0, 0, 0, 1.0f, 0 };  

//锐化  
const float colormatrix_ruise[] = {   
    4.8f,-1.0f, -0.1f, 0,-388.4f,  
    -0.5f,4.4f, -0.1f, 0,-388.4f,   
    -0.5f,-1.0f, 5.2f, 0,-388.4f,  
    0, 0, 0, 1.0f, 0 };  


//淡雅  
const float colormatrix_danya[] = {   
    0.6f,0.3f, 0.1f, 0,73.3f,  
    0.2f,0.7f, 0.1f, 0,73.3f,   
    0.2f,0.3f, 0.4f, 0,73.3f,  
    0, 0, 0, 1.0f, 0 };  

//酒红  
const float colormatrix_jiuhong[] = {   
    1.2f,0.0f, 0.0f, 0.0f,0.0f,  
    0.0f,0.9f, 0.0f, 0.0f,0.0f,   
    0.0f,0.0f, 0.8f, 0.0f,0.0f,  
    0, 0, 0, 1.0f, 0 };  

//清宁  
const float colormatrix_qingning[] = {   
    0.9f, 0, 0, 0, 0,   
    0, 1.1f,0, 0, 0,   
    0, 0, 0.9f, 0, 0,   
    0, 0, 0, 1.0f, 0 };  

//浪漫  
const float colormatrix_langman[] = {   
    0.9f, 0, 0, 0, 63.0f,   
    0, 0.9f,0, 0, 63.0f,   
    0, 0, 0.9f, 0, 63.0f,   
    0, 0, 0, 1.0f, 0 };  

//光晕  
const float colormatrix_guangyun[] = {   
    0.9f, 0, 0,  0, 64.9f,  
    0, 0.9f,0,  0, 64.9f,  
    0, 0, 0.9f,  0, 64.9f,  
    0, 0, 0, 1.0f, 0 };  

//蓝调  
const float colormatrix_landiao[] = {  
    2.1f, -1.4f, 0.6f, 0.0f, -31.0f,   
    -0.3f, 2.0f, -0.3f, 0.0f, -31.0f,  
    -1.1f, -0.2f, 2.6f, 0.0f, -31.0f,   
    0.0f, 0.0f, 0.0f, 1.0f, 0.0f  
};  

//梦幻  
const float colormatrix_menghuan[] = {  
    0.8f, 0.3f, 0.1f, 0.0f, 46.5f,   
    0.1f, 0.9f, 0.0f, 0.0f, 46.5f,   
    0.1f, 0.3f, 0.7f, 0.0f, 46.5f,   
    0.0f, 0.0f, 0.0f, 1.0f, 0.0f  
};  

//夜色  
const float colormatrix_yese[] = {  
    1.0f, 0.0f, 0.0f, 0.0f, -66.6f,  
    0.0f, 1.1f, 0.0f, 0.0f, -66.6f,   
    0.0f, 0.0f, 1.0f, 0.0f, -66.6f,   
    0.0f, 0.0f, 0.0f, 1.0f, 0.0f  
};  
</code></pre>

<h3>四：图片的饱和度，亮度，对比度。</h3>

<p>在做图片处理的时候，会遇到调节图片的饱和度的问题，这里就要用到Core Image这个框架，Core Image是一个很强大的框架。它可以让你简单地应用各种滤镜来处理图像，比如修改鲜艳程度, 色泽, 或者曝光。它利用GPU（或者CPU，取决于客户）来非常快速、甚至实时地处理图像数据和视频的帧。多个CoreImage滤镜可以叠加在一起，从而可以一次性地产生多重滤镜效果。这种多重滤镜的优点在于它可以生成一个改进的滤镜，从而一次性的处理图像达到目标效果，而不是对同一个图像顺序地多次应用单个滤镜。每一个滤镜都有属于它自己的参数。这些参数和滤镜信息，比如功能、输入参数等都可以通过程序来查询。用户也可以来查询系统从而得到当前可用的滤镜信息。到目前为止，Mac上只有一部分CoreImage滤镜可以在iOS上使用。但是随着这些可使用滤镜的数目越来越多，API可以用来发现新的滤镜属性。
下面是这个框架下的几个重要的类</p>

<ul>
<li>CIContext:所有的图像处理都是在一个CIContext中完成的。</li>
<li>CIImage 这个类保存图像数据，它可以从UIImage，图像文件或者是像素数据中构造出来。</li>
<li>CIFilter：滤镜类总保函一个字典结构，对各种滤镜定义了属于他们各自的属性，滤镜有很多种，比如鲜艳程度的滤镜，色彩反转滤镜，剪裁滤镜等等。</li>
</ul>


<p>用下面的我们来试试修改一张图片的饱和度，亮度，对比度。
首先用到的是CIFilter 我们可以通过字典来看看里面所有的</p>

<pre><code>NSArray *cifilter = [CIFilter filterNamesInCategory:kCICategoryBuiltIn];  

NSLog(@"FilterName:\n%@,,,===%ld", cifilter,cifilter.count);//显示所有过滤器名字  

for (NSString *filterName in cifilter) {  

    CIFilter *fltr = [CIFilter filterWithName:filterName];//用一个过滤器名字生成一个过滤器CIFilter对象  

    NSLog(@"%@:\n%@", filterName, [fltr attributes]);//这个过滤器支持的属性  

}  
</code></pre>

<p>可以看见多有的属性
今天我们用到是滤镜名称是CIColorControls</p>

<pre><code>/////////////////////////////////////
    CIAttributeFilterDisplayName = "Color Controls";
    CIAttributeFilterName = CIColorControls;
    inputBrightness =     {
        CIAttributeClass = NSNumber;
        CIAttributeDefault = 0;
        CIAttributeIdentity = 0;
        CIAttributeSliderMax = 1;
        CIAttributeSliderMin = "-1";
        CIAttributeType = CIAttributeTypeScalar;
    };
    inputContrast =     {
        CIAttributeClass = NSNumber;
        CIAttributeDefault = 1;
        CIAttributeIdentity = 1;
        CIAttributeSliderMax = 4;
        CIAttributeSliderMin = 0;
        CIAttributeType = CIAttributeTypeScalar;
    };
    inputImage =     {
        CIAttributeClass = CIImage;
        CIAttributeType = CIAttributeTypeImage;
    };
    inputSaturation =     {
        CIAttributeClass = NSNumber;
        CIAttributeDefault = 1;
        CIAttributeIdentity = 1;
        CIAttributeSliderMax = 2;
        CIAttributeSliderMin = 0;
        CIAttributeType = CIAttributeTypeScalar;
    };
/////////////////////////////////////
</code></pre>

<p>上面是这个滤镜的名称和属性
下面是具体的修改图片的饱和度亮度和对比度的代码</p>

<pre><code>CIImage *beginImage = [CIImage imageWithCGImage:image.CGImage];  
CIFilter * filter = [CIFilter filterWithName:@"CIColorControls"];  
[filter setValue:beginImage forKey:kCIInputImageKey];  
//  饱和度      0---2  
[filter setValue:[NSNumber numberWithFloat:0.5] forKey:@"inputSaturation"];  
//  亮度  10   -1---1  
[filter setValue:[NSNumber numberWithFloat:0.5] forKey:@"inputBrightness"];  
//  对比度 -11  0---4  
[filter setValue:[NSNumber numberWithFloat:2] forKey:@"inputContrast"];  

// 得到过滤后的图片  
CIImage *outputImage = [filter outputImage];  
// 转换图片, 创建基于GPU的CIContext对象  
CIContext *context = [CIContext contextWithOptions: nil nil];  
CGImageRef cgimg = [context createCGImage:outputImage fromRect:[outputImage extent]];  
UIImage *newImg = [UIImage imageWithCGImage:cgimg];  
// 显示图片  
[_imageV setImage:newImg];  
// 释放C对象  
CGImageRelease(cgimg);  
</code></pre>

<p>有兴趣的可以去看看关于CoreImage的源码</p>
]]></content>
  </entry>
  
</feed>
