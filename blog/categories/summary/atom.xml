<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Summary | iOS梦工厂]]></title>
  <link href="http://al1020119.github.io/blog/categories/summary/atom.xml" rel="self"/>
  <link href="http://al1020119.github.io/"/>
  <updated>2015-12-30T15:31:39+08:00</updated>
  <id>http://al1020119.github.io/</id>
  <author>
    <name><![CDATA[iCocos]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[重量级-MVC-MVVM-DC]]></title>
    <link href="http://al1020119.github.io/blog/2016/01/01/zhong-liang-ji/"/>
    <updated>2016-01-01T16:21:08+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/01/01/zhong-liang-ji</id>
    <content type="html"><![CDATA[<p>新的一年来的重量级的东西，那么是什么呢？</p>

<p>相信你既然能看到这篇文章，那么一定听说过MVC，什么没有听过？出门左转找度娘，不送！
如果你听说过MVC，那么或许你听说过MVVM，这里可能很多人对MVVM并不了解，或许只是听过，但是没有用过，有些就算用过还是不请求，里面的关系，只是搬砖而已。
对了，今天我们讨论的就是一个MVVM的技术，也就是在MVVM上面的一个增强版！
MVVM不正是MVC的增强版吗？</p>

<p>好了下面正式开始，新年不能耽误大家太多时间搬砖，，哈哈！</p>

<h2>Model-View-Controller</h2>

<p>首先我们来看看MVC，这里MVC具体细节就不多说了。</p>

<ul>
<li>Model(M)：模型数据</li>
<li>View(V)：视图</li>
<li>Controller&copy;：控制器</li>
</ul>


<p><img src="/images/zhongliangji001.png" title="Caption" ></p>

<h6>有点：</h6>

<ul>
<li>易学习</li>
<li>易开发</li>
<li>同哟欧诺个成熟</li>
</ul>


<h6>缺点：</h6>

<ul>
<li>Massive View Controller</li>
</ul>


<h2>Model-View-ViewModel</h2>

<p>然后来看看现在比较热得话题（架构）MVVM
* Model（M）:模型
* View(V）:视图
* ViewModel（VM）:模型（逻辑）</p>

<p><img src="/images/zhongliangji001.png" title="Caption" ></p>

<h6>View与ViewModule连接可以通过下面的方式</h6>

<ul>
<li><p>Binding Data：实现数据的传递</p></li>
<li><p>Command：实现操作的调用</p></li>
<li><p>AttachBehavior：实现控件加载过程中的操作</p></li>
</ul>


<h5>View没有大量代码逻辑。</h5>

<ul>
<li><p>结合WPF、Silverlight绑定机制，MVP演变出了MVVM，充分利用了WPF、Silverlight的优势，将大量代码逻辑、状态转到ViewModel，可以说MVVM是专门为WPF、Silverlight打造的。</p></li>
<li><p>View绑定到ViewModel，然后执行一些命令在向它请求一个动作。而反过来，ViewModel跟Model通讯，告诉它更新来响应UI。这样便使得为应用构建UI非常的容易。往一个应用程序上贴一个界面越容易，外观设计师就越容易使用Blend来创建一个漂亮的界面。同时，当UI和功能越来越松耦合的时候，功能的可测试性就越来越强。</p></li>
</ul>


<h6>优点：</h6>

<ul>
<li>减轻ViewController的负担</li>
<li>提高了测试性</li>
<li>强大的绑定机制</li>
</ul>


<h6>缺点：</h6>

<ul>
<li>极高的学习成本和开发成本</li>
<li>数据绑定是的bug更难调试</li>
<li>View Model的职责任然很重</li>
<li>据本人了解，MVVM结合RAC使用能够发挥最大的效率</li>
</ul>


<p>总上我们可以得知：</p>

<ul>
<li>每个V都有一个对应的VM，V的数据展示盒样式都由其定制</li>
<li>不引入双想绑定机制或者观察机制，而是通过传统的代理回调或者通知将UI事件传给外界</li>
<li>VC只负责将VM装配给V，接受UI事件</li>
</ul>


<p>或许细心地能发现下面的好处</p>

<ul>
<li>View可以完全解耦，只需要确定好ViewModel和回调接口即可</li>
<li>View Controller层可以尽可能少得和View的具体表现打交道，将这不分职责转给了View Model，减轻了* View Controller的负担</li>
<li>使用回调的传统回调机制，学习成本低，数据和事件流入和流出易观察而且更易控制，降低维护和回调成本</li>
</ul>


<h2>Model-View-ViewModel-DataController-Model</h2>

<p>好了重量级的东西来了，MVVM-DM（MVVM Without Binding With Data Controller）</p>

<ul>
<li>Model（M）:模型</li>
<li>View(V）:视图</li>
<li>ViewModel（VM）:加工后的数据）</li>
<li>Data Controller：相关逻辑</li>
<li>Model：对应Data Controller</li>
</ul>


<p><img src="/images/zhongliangji001.png" title="Caption" ></p>

<p>或许有些人看到上面的文字就能知道我本文的含义了，对没错，就是为了解决MVVM中View Model臃肿情况！</p>

<h6>优点：</h6>

<ul>
<li>避免了传统的MVVM架构VM层有可能变得臃肿的情况，更加清晰的模块职责</li>
<li>业务逻辑解耦，数据的加工和处理都放在Data Controller中，View Controiller不用关心数据如何获得，如何处理，Data Controller不用关心界面如何展示，如何交互</li>
<li>Data Controller与界面无关，所以可以有更好的可测试性和可服用性</li>
</ul>


<h6>缺点：</h6>

<p>暂时没有发现（难度：一下比较难接受）</p>

<h4>具体思路是：</h4>

<ul>
<li>1.每个Viewcontroller会有一个对应的Data Controller（包含页面的所有相关逻辑：View Related data Controller） ，在View的ViewDidLoad方法中初始化View，layoutSubViews中布局</li>
<li>2.Viewcongtroller向Data Controller发送请求，Data Controller包含只是纯粹的Model相关逻辑（当然你也可以复用更小的Data Controller）如：网络请求，数据持久（请求），数据加工，其他。</li>
<li>3.Data Controller将请求到得数据加工返回给View Controller</li>
<li>4.View Controller将Data Controller返回的加工好的数据生成ViewModel（展示View所需要的数据），</li>
<li>5.View Controller协调控制并将生成的View Model装配到View（每个View都有一个对应的View Model，可以有子View Model）上面显示，这里相当于使用ViewModel数据来渲染界面</li>
</ul>


<p>综上：</p>

<ul>
<li>将处理数据和获取数据的职责从传统的MVVM的Vm中抽取出来，成为Data Controller</li>
<li>VC请求数据和将一些数据修改的事件（可以是UI事件触发）传递给Data Controller</li>
<li>Data Controller收到VC的请求后，向M获取数据和更新数据，并将加工后的数据返回</li>
<li>Data Controller还负责网络层和持久化层的逻辑</li>
</ul>


<blockquote><p>总结：</p>

<ul>
<li>层次清晰，职责明确。</li>
<li>耦合性低，复用性高</li>
<li>测试性高</li>
<li>低学习成本，低开发成本</li>
<li>高实施性，无需整体重构</li>
</ul>
</blockquote>

<p>本文借鉴猿题库客户端架构设计，最后附上<a href="blog.devtang.com">唐巧大V</a>得博客，以表敬意</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[你还在等什么？]]></title>
    <link href="http://al1020119.github.io/blog/2015/12/30/ni-huan-zai-deng-shi-yao-%3F/"/>
    <updated>2015-12-30T16:21:08+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/12/30/ni-huan-zai-deng-shi-yao-?</id>
    <content type="html"><![CDATA[<p>最近，一直在寻找灵感，摸索新技术，提高个人的开发能力，比如swift开源代码，也在研究前端开发，但是偶尔看到一个问题，学了这么久，也做了这么久，突然发现很多东西都忘了，或者说搞不太清楚，就是有些相似的弄混了，最后网上到处找。看完之后我也颇有感受，也想了很久，觉得整理一份重要的总结。</p>

<p>宗旨内容如下：</p>

<ul>
<li>1：ios开发中常见技术的总结（主要是区别）</li>
<li>2：作为一个iOS程序员必备的常识问题</li>
<li>3：作为面试必备的一份宝典</li>
<li>4：初学者快速了解相关技术</li>
<li>5：老程序员快速回顾混淆，忘记的知识点</li>
</ul>


<p>后续我也会一直讲本文更新下去，有露点或者错误的地方望指出，或者联系<a href="http://al1020119.github.io/other/">我</a>，相互交流技术，谢谢！</p>

<p>好了开始吧。。。。。。。。。。。</p>

<!--more-->


<h1>一：weak&amp;strong</h1>

<ul>
<li><p>strong表示保留它指向的堆上的内存区域不再指向这块区域了。
也就是说我强力指向了一个区域，我们不再指向它的条件只有我们指向nil或者我自己也不在内存上，没有人strong指向我了。</p></li>
<li><p>weak表示如果还没有人指向它了，它就会被清除内存，同时被指向nil，因为我不能读取不存在的东西。</p></li>
</ul>


<blockquote><p>weak只在IOS5.0使用</p></blockquote>

<p>这并不是垃圾回收，我们用reference count表示堆上还有多少strong指针，当它变为0就马上释放。</p>

<p>本地变量都是strong，编辑器帮你计算.</p>

<h5>补充：</h5>

<ul>
<li>管理机制：使用了一种叫做引用计数的机制来管理内存中的对象。OC中每个对象都对应着他们自己的引用计数，引用计数可以理解为一个整数计数器，当使用alloc方法创建对象的时候，持有计数会自动设置为1。当你向一个对象发送retain消息 时，持有计数数值会增加1。相反，当你像一个对象发送release消息时，持有计数数值会减小1。当对象的持有计数变为0的时候，对象会释放自己所占用的内存。<em> retain(引用计数加1)->release（引用计数减1）</em> alloc（申请内存空间）->dealloc(释放内存空间)<em> readwrite: 表示既有getter，也有setter   (默认)</em> readonly: 表示只有getter，没有setter<em> nonatomic:不考虑线程安全</em> atomic:线程操作安全   （默认）
线程安全情况下的setter和getter：

<ul>
<li>(NSString*) value  {              @synchronized(self) {                   return [[_value retain] autorelease];  <br/>
       }
     }</li>
<li><p>  (void) setValue:(NSString*)aValue {            @synchronized(self) {               [aValue retain];                [<em>value release];               </em>value = aValue;   <br/>
 }     }</p></li>
<li><p> retain: release旧的对象，将旧对象的值赋予输入对象，再提高输入对象的索引计数为1<em> assign: 简单赋值，不更改索引计数    （默认）</em> copy: 其实是建立了一个相同的对象,地址不同（retain：指针拷贝  copy：内容拷贝）<em> strong:（ARC下的）和（MRC）retain一样    （默认）</em> weak:（ARC下的）和（MRC）assign一样， weak当指向的内存释放掉后自动nil化，防止野指针<em> unsafe_unretained 声明一个弱应用，但是不会自动nil化，也就是说，如果所指向的内存区域被释放了，这个指针就是一个野指针了。</em> autoreleasing 用来修饰一个函数的参数，这个参数会在函数返回的时候被自动释放。1、 类变量的@protected ,@private,@public,@package，声明各有什么含义？<em> @private：作用范围只能在自身类</em> @protected：作用范围在自身类和继承自己的子类  （默认）<em> @public：作用范围最大，可以在任何地方被访问。</em> @package：这个类型最常用于框架类的实例变量,同一包内能用，跨包就不能访问</p></li>
</ul>
</li>
</ul>


<h1>二：catagory&amp;extension</h1>

<h6>类别主要有3个作用：</h6>

<ul>
<li><p>(1)可以将类的实现分散到多个不同文件或多个不同框架中，方便代码管理。也可以对框架提供类的扩展（没有源码，不能修改）。</p></li>
<li><p>(2)创建对私有方法的前向引用：如果其他类中的方法未实现，在你访问其他类的私有方法时编译器报错这时使用类别，在类别中声明这些方法（不必提供方法实现），编译器就不会再产生警告</p></li>
<li><p>(3)向对象添加非正式协议：创建一个NSObject的类别称为“创建一个非正式协议”，因为可以作为任何类的委托对象使用。</p></li>
</ul>


<h6>他们的主要区别是：</h6>

<ul>
<li><p>1、形式上来看，extension是匿名的category。</p></li>
<li><p>2、extension里声明的方法需要在mainimplementation中实现，category不强制要求。</p></li>
<li><p>3、extension可以添加属性（变量），category不可以。</p></li>
</ul>


<h6>Category和Extension都是用来给已定义的类增加新的内容的。</h6>

<ul>
<li><p>Category和原有类的耦合更低一些，声明和实现都可以写在单独的文件里。但是只能为已定义类增加Method，而不能加入instance variable。</p></li>
<li><p>Extension耦合比较高，声明可以单独写，但是实现必须写在原有类的@implementation中。可以增加Method和instance variable。</p></li>
<li><p>Extension给人感觉更像是在编写类时为了封装之类的特性而设计，和类是同时编写的。而category则是在用到某一个framework中的类时临时增加的特性。</p></li>
<li><p>Extension的一个特性就是可以redeclare一个instance variable，将之从readonly改为对内readwrite.</p></li>
</ul>


<blockquote><p>使用Extension可以更好的封装类，在h文件中能看到的都是对外的接口，其余的instance variable和对内的@property等都可以写在Extension，这样类的结构更加清晰。</p></blockquote>

<h1>三：define&amp;const</h1>

<ul>
<li>define在预处理阶段进行替换，const常量在编译阶段使用<em> 宏不做类型检查，仅仅进行替换，const常量有数据类型，会执行类型检查</em> define不能调试，const常量可以调试<em> define定义的常量在替换后运行过程中会不断地占用内存，而const定义的常量存储在数据段只有一份copy，效率更高</em> define可以定义一些简单的函数，const不可以</li>
</ul>


<h1>四：synthesize&amp;denamic</h1>

<ul>
<li>1：通过@synthesize 指令告诉编译器在编译期间产生getter/setter方法。</li>
<li>2：通过@dynamic指令，自己实现方法。</li>
</ul>


<p>有些存取是在运行时动态创建的，如在CoreData的NSManagedObject类使用的某些。如果你想这些情况下，声明和使用属性，但要避免缺少方法在编译时的警告，你可以使用@dynamic动态指令，而不是@synthesize合成指令。</p>

<h1>五：UIView的setNeedsDisplay和setNeedsLayout方法</h1>

<ul>
<li><p>1、在Mac OS中NSWindow的父类是NSResponder，而在i OS 中UIWindow 的父类是UIVIew。程序一般只有一个窗口但是会又很多视图。</p></li>
<li><p>2、UIView的作用：描画和动画，视图负责对其所属的矩形区域描画、布局和子视图管理、事件处理、可以接收触摸事件、事件信息的载体、等等。</p></li>
<li><p>3、UIViewController 负责创建其管理的视图及在低内存的时候将他们从内存中移除。还为标准的系统行为进行响应。</p></li>
<li></li>
<li><p>4、layOutSubViews 可以在自己定制的视图中重载这个方法，用来调整子视图的尺寸和位置。</p></li>
<li><p>5、UIView的setNeedsDisplay和setNeedsLayout方法。首先两个方法都是异步执行的。而setNeedsDisplay会调用自动调用drawRect方法，这样可以拿到UIGraphicsGetCurrentContext，就可以画画了。而setNeedsLayout会默认调用layoutSubViews，就可以处理子视图中的一些数据。</p></li>
</ul>


<p>综上所述：setNeedsDisplay方便绘图，而layoutSubViews方便出来数据</p>

<p>setNeedDisplay告知视图它发生了改变，需要重新绘制自身，就相当于刷新界面.</p>

<h1>六：UILayer&amp;UIView</h1>

<p>UIView是iOS系统中界面元素的基础，所有的界面元素都继承自它。它本身完全是由CoreAnimation来实现的（Mac下似乎不是这样）。它真正的绘图部分，是由一个叫CALayer（Core Animation Layer）的类来管理。UIView本身，更像是一个CALayer的管理器，访问它的跟绘图和跟坐标有关的属性，例如frame，bounds等等，实际上内部都是在访问它所包含的CALayer的相关属性。</p>

<ol>
<li><p>UIView是iOS系统中界面元素的基础，所有的界面元素都是继承自它。它本身完全是由CoreAnimation来实现的。它真正的绘图部分，是由一个CALayer类来管理。UIView本身更像是一个CALayer的管理器，访问它的跟绘图和跟坐标有关的属性，例如frame，bounds等，实际上内部都是在访问它所包含的CALayer的相关属性。</p></li>
<li><p>UIView有个重要属性layer，可以返回它的主CALayer实例。</p></li>
<li><p>UIView的CALayer类似UIView的子View树形结构，也可以向它的layer上添加子layer，来完成某些特殊的表示。即CALayer层是可以嵌套的。</p></li>
<li><p>UIView的layer树形在系统内部，被维护着三份copy。分别是逻辑树，这里是代码可以操纵的；动画树，是一个中间层，系统就在这一层上更改属性，进行各种渲染操作；显示树，其内容就是当前正被显示在屏幕上得内容。</p></li>
<li><p>动画的运作：对UIView的subLayer（非主Layer）属性进行更改，系统将自动进行动画生成，动画持续时间的缺省值似乎是0.5秒。</p></li>
<li><p>坐标系统：CALayer的坐标系统比UIView多了一个anchorPoint属性，使用CGPoint结构表示，值域是0~1，是个比例值。</p></li>
<li><p>渲染：当更新层，改变不能立即显示在屏幕上。当所有的层都准备好时，可以调用setNeedsDisplay方法来重绘显示。</p></li>
<li><p>变换：要在一个层中添加一个3D或仿射变换，可以分别设置层的transform或affineTransform属性。</p></li>
<li><p>变形：Quartz Core的渲染能力，使二维图像可以被自由操纵，就好像是三维的。图像可以在一个三维坐标系中以任意角度被旋转，缩放和倾斜。CATransform3D的一套方法提供了一些魔术般的变换效果。</p></li>
</ol>


<h1>七：UITableView&amp;UICollection</h1>

<p>UICollectionView是iOS6新引进的API，用于展示集合视图，布局更加灵活，其用法类似于UITableView。而UICollectionView、UICollectionViewCell与UITableView、UITableViewCell在用法上有相似的也有不同的，下面是一些基本的使用方法：</p>

<p>对于UITableView，仅需要UITableViewDataSource,UITableViewDelegate这两个协议，使用UICollectionView需要实现UICollectionViewDataSource,
UICollectionViewDelegate，UICollectionViewDelegateFlowLayout这三个协议，这是因为UICollectionViewDelegateFlowLayout实际上是UICollectionViewDelegate的一个子协议，它继承了UICollectionViewDelegate，它的作用是提供一些定义UICollectionView布局模式的函数</p>

<h1>八：NSProxy&amp;NSObject</h1>

<h6>NSObjetc：</h6>

<p>NSObject协议组对所有的Object－C下的objects都生效。 如果objects遵从该协议，就会被看作是first－class objects（一级类）。 另外，遵从该协议的objects的retain，release，autorelease等方法也服从objects的管理和在Foundation中定义的释放方法。一些容器中的对象也可以管理这些objects，比如 说NSArray 和NSDictionary定义的对象。 Cocoa的根类也遵循该协议，所以所有继承NSObjects的objects都有遵循该协议的特性。</p>

<h6>NSProXY：</h6>

<p>NSProxy 是一个虚基类，它为一些表现的像是其它对象替身或者并不存在的对象定义一套API。一般的，发送给代理的消息被转发给一个真实的对象或者代理本身load(或者将本身转换成)一个真实的对象。NSProxy的基类可以被用来透明的转发消息或者耗费巨大的对象的lazy 初始化。</p>

<h1>九：layoutSubViews&amp;drawRects</h1>

<h6>layoutSubviews在以下情况下会被调用：</h6>

<ul>
<li>1、init初始化不会触发layoutSubviews。</li>
<li>2、addSubview会触发layoutSubviews。</li>
<li>3、设置view的Frame会触发layoutSubviews，当然前提是frame的值设置前后发生了变化。</li>
<li>4、滚动一个UIScrollView会触发layoutSubviews。</li>
<li>5、旋转Screen会触发父UIView上的layoutSubviews事件。</li>
<li>6、改变一个UIView大小的时候也会触发父UIView上的layoutSubviews事件。</li>
<li>7、直接调用setLayoutSubviews。</li>
</ul>


<h6>drawRect在以下情况下会被调用：</h6>

<ul>
<li>1、如果在UIView初始化时没有设置rect大小，将直接导致drawRect不被自动调用。drawRect 掉用是在Controller->loadView, Controller->viewDidLoad 两方法之后掉用的.所以不用担心在 控制器中,这些View的drawRect就开始画了.这样可以在控制器中设置一些值给View(如果这些View draw的时候需要用到某些变量 值).</li>
<li>2、该方法在调用sizeToFit后被调用，所以可以先调用sizeToFit计算出size。然后系统自动调用drawRect:方法。</li>
<li>3、通过设置contentMode属性值为UIViewContentModeRedraw。那么将在每次设置或更改frame的时候自动调用drawRect:。</li>
<li>4、直接调用setNeedsDisplay，或者setNeedsDisplayInRect:触发drawRect:，但是有个前提条件是rect不能为0。</li>
</ul>


<h6>drawRect方法使用注意点：</h6>

<ul>
<li><p>1、 若使用UIView绘图，只能在drawRect：方法中获取相应的contextRef并绘图。如果在其他方法中获取将获取到一个invalidate 的ref并且不能用于画图。drawRect：方法不能手动显示调用，必须通过调用setNeedsDisplay 或 者 setNeedsDisplayInRect，让系统自动调该方法。</p></li>
<li><p>2、若使用calayer绘图，只能在drawInContext: 中（类似鱼drawRect）绘制，或者在delegate中的相应方法绘制。同样也是调用setNeedDisplay等间接调用以上方法 3、若要实时画图，不能使用gestureRecognizer，只能使用touchbegan等方法来掉用setNeedsDisplay实时刷新屏幕</p></li>
</ul>


<h1>十：NSCache&amp;NSDcitionary</h1>

<p>NSCache与可变集合有几点不同：</p>

<ul>
<li>NSCache类结合了各种自动删除策略，以确保不会占用过多的系统内存。如果其它应用需要内存时，系统自动执行这些策略。当调用这些策略时，会从缓存中删除一些对象，以最大限度减少内存的占用。</li>
<li>NSCache是线程安全的，我们可以在不同的线程中添加、删除和查询缓存中的对象，而不需要锁定缓存区域。</li>
<li>不像NSMutableDictionary对象，一个缓存对象不会拷贝key对象。</li>
</ul>


<p>NSCache和NSDictionary类似，不同的是系统回收内存的时候它会自动删掉它的内容。</p>

<ul>
<li>(1)可以存储(当然是使用内存)</li>
<li>(2)保持强应用, 无视垃圾回收. =>这一点同 NSMutableDictionary</li>
<li>(3)有固定客户.

<h1>十一：AFnetworking&amp;ASIHttpRequest&amp;MKNetWorking</h1></li>
</ul>


<p> 一、底层实现</p>

<pre><code>1、AFN的底层实现基于OC的NSURLConnection和NSURLSession
2、ASI的底层实现基于纯C语言的CFNetwork框架
3、因为NSURLConnection和NSURLSession是在CFNetwork之上的一层封装，因此ASI的运行性能高于AFN
</code></pre>

<p>AFNetworking的下载地址: <a href="https://github.com/AFNetworking/AFNetworking">https://github.com/AFNetworking/AFNetworking</a>
二、对服务器返回的数据处理</p>

<pre><code>1、ASI没有直接提供对服务器数据处理的方式，直接返回的是NSData/NSString
2、AFN提供了多种对服务器数据处理的方式
(1)JSON处理-直接返回NSDictionary或者NSArray
(2)XML处理-返回的是xml类型数据，需对其进行解析
(3)其他类型数据处理
</code></pre>

<p>三、监听请求过程</p>

<pre><code>1、AFN提供了success和failure两个block来监听请求的过程（只能监听成功和失败）
* success : 请求成功后调用
* failure : 请求失败后调用
2、ASI提供了3套方案，每一套方案都能监听请求的完整过程
（监听请求开始、接收到响应头信息、接受到具体数据、接受完毕、请求失败）
* 成为代理，遵守协议，实现协议中的代理方法
* 成为代理，不遵守协议，自定义代理方法
* 设置block
</code></pre>

<p>四、在文件下载和文件上传的使用难易度</p>

<pre><code>1、AFN
*不容易实现监听下载进度和上传进度
*不容易实现断点续传
*一般只用来下载不大的文件
2、ASI
*非常容易实现下载和上传
*非常容易监听下载进度和上传进度
*非常容易实现断点续传
*下载大文件或小文件均可
3、实现下载上传推荐使用ASI
</code></pre>

<p>五、网络监控</p>

<pre><code>1、AFN自己封装了网络监控类，易使用
2、ASI使用的是Reachability，因为使用CocoaPods下载ASI时，会同步下载Reachability，但Reachability作为网络监控使用较为复杂（相对于AFN的网络监控类来说）
3、推荐使用AFN做网络监控-AFNetworkReachabilityManager
</code></pre>

<p>六、ASI提供的其他实用功能</p>

<pre><code>1、控制信号旁边的圈圈要不要在请求过程中转
2、可以轻松地设置请求之间的依赖：每一个请求都是一个NSOperation对象
3、可以统一管理所有请求（还专门提供了一个叫做ASINetworkQueue来管理所有的请求对象）
* 暂停/恢复/取消所有的请求
* 监听整个队列中所有请求的下载进度和上传进度
</code></pre>

<p>MKNetworkKit 是一个使用十分方便，功能又十分强大、完整的iOS网络编程代码库。它只有两个类, 它的目标是使用像AFNetworking这么简单，而功能像ASIHTTPRequest(已经停止维护)那么强大。它除了拥有AFNetworking和ASIHTTPRequest所有功能以外，还有一些新特色，包括：</p>

<ul>
<li><p>1、高度的轻量级，仅仅只有2个主类</p></li>
<li><p>2、自主操作多个网络请求</p></li>
<li><p>3、更加准确的显示网络活动指标</p></li>
<li><p>4、自动设置网络速度，实现自动的2G、3G、wifi切换</p></li>
<li><p>5、自动缓冲技术的完美应用，实现网络操作记忆功能，当你掉线了又上线后，会继续执行未完成的网络请求</p></li>
<li><p>6、可以实现网络请求的暂停功能</p></li>
<li><p>7、准确无误的成功执行一次网络请求，摒弃后台的多次请求浪费</p></li>
<li><p>8、支持图片缓冲</p></li>
<li><p>9、支持ARC机制</p></li>
<li><p>10、在整个app中可以只用一个队列（queue），队列的大小可以自动调整</p></li>
</ul>


<p><img src="/images/netqubiezongjie001.png" title="Caption" ></p>

<h1>十二：load&amp;initialize</h1>

<ul>
<li>(void)load;</li>
<li>(void)initialize;</li>
</ul>


<p>可以看到这两个方法都是以“+”开头的类方法，返回为空。通常情况下，我们在开发过程中可能不必关注这两个方法。如果有需要定制，我们可以在自定义的NSObject子类中给出这两个方法的实现，这样在类的加载和初始化过程中，自定义的方法可以得到调用。</p>

<h6>load和initialize的共同特点</h6>

<ul>
<li><p>在不考虑开发者主动使用的情况下，系统最多会调用一次</p></li>
<li><p>如果父类和子类都被调用，父类的调用一定在子类之前</p></li>
<li><p>都是为了应用运行提前创建合适的运行环境</p></li>
<li><p>在使用时都不要过重地依赖于这两个方法，除非真正必要</p></li>
</ul>


<blockquote><p>它们的相同点在于：方法只会被调用一次。（其实这是相对runtime来说的，后边会做进一步解释）。</p></blockquote>

<hr />

<pre><code>    The runtime sends initialize to each class in a program exactly one time just before the class, or any class that inherits from it, is sent its first message from within the program. (Thus the method may never be invoked if the class is not used.) The runtime sends the initialize message to classes in a thread-safe manner. Superclasses receive this message before their subclasses.
</code></pre>

<hr />

<pre><code>        The load message is sent to classes and categories that are both dynamically loaded and statically linked, but only if the newly loaded class or category implements a method that can respond.
</code></pre>

<ul>
<li>load是只要类所在文件被引用就会被调用，而initialize是在类或者其子类的第一个方法被调用前调用。所以如果类没有被引用进项目，就不会有load调用；但即使类文件被引用进来，但是没有使用，那么initialize也不会被调用。</li>
</ul>


<p>文档也明确阐述了方法调用的顺序：父类(Superclass)的方法优先于子类(Subclass)的方法，类中的方法优先于类别(Category)中的方法。</p>

<table>
<thead>
<tr>
<th>区别 </th>
<th style="text-align:center;">   +(void)load </th>
<th style="text-align:right;">   +(void)initialize</th>
</tr>
</thead>
<tbody>
<tr>
<td> 执行时机 </td>
<td style="text-align:center;">    在程序运行后立即执行 </td>
<td style="text-align:right;">    在类的方法第一次被调时执行</td>
</tr>
<tr>
<td> 若自身未定义，是否沿用父类的方法？ </td>
<td style="text-align:center;">     否 </td>
<td style="text-align:right;">   是</td>
</tr>
<tr>
<td> 类别中的定义</td>
<td style="text-align:center;">   全都执行，但后于类中的方法 </td>
<td style="text-align:right;">   覆盖类中的方法，只执行一个</td>
</tr>
</tbody>
</table>


<h1>十三：ARC-Block&amp;MRC-Block</h1>

<p>block虽然好用，但是里面也有不少坑，最大的坑莫过于循环引用问题。稍不注意，可能就会造成内存泄漏。这节，我将从源码的角度来分析造成循环引用问题的根本原因。并解释变量前加<strong>block，和</strong>weak的区别。</p>

<h5>明确两点</h5>

<p>1,Block可以访问Block函数以及语法作用域以内的外部变量。也就是说:一个函数里定义了个block，这个block可以访问该函数的内部变量(当然还包括静态，全局变量)-即block可以使用和本身定义范围相同的变量。
2,Block其实是特殊的Objective-C对象，可以使用copy,release等来管理内存,但和一般的NSObject的管理方式有些不同，稍后会说明。</p>

<h6>MRC:防止 block 对self的引用 解决办法</h6>

<pre><code>__block typeof(self) weakSelf = self;
</code></pre>

<h6>ARC:防止 block 对self的引用 解决办法</h6>

<pre><code>__weak typeof(self) weakSelf = self;
</code></pre>

<blockquote><p>对于非ARC下, 为了防止循环引用, 我们使用__block来修饰在Block中使用的对象:</p>

<p>对于ARC下, 为了防止循环引用, 我们使用<strong>weak来修饰在Block中使用的对象。原理就是:ARC中，Block中如果引用了</strong>strong修饰符的自动变量，则相当于Block对该变量的引用计数+1。</p></blockquote>

<h1>十四：MVC&amp;MVVM</h1>

<ul>
<li><p>在MVC里，View是可以直接访问Model的！从而，View里会包含Model信息，不可避免的还要包括一些业务逻辑。 MVC模型关注的是Model的不变，所以，在MVC模型里，Model不依赖于View，但是 View是依赖于Model的。不仅如此，因为有一些业务逻辑在View里实现了，导致要更改View也是比较困难的，至少那些业务逻辑是无法重用的。</p></li>
<li><p>MVVM在概念上是真正将页面与数据逻辑分离的模式，它把数据绑定工作放到一个JS里去实现，而这个JS文件的主要功能是完成数据的绑定，即把model绑定到UI的元素上。</p></li>
</ul>


<blockquote><p>有人做过测试：使用Angular（MVVM）代替Backbone（MVC）来开发，代码可以减少一半。</p></blockquote>

<p>此外，MVVM另一个重要特性，双向绑定。它更方便你同时维护页面上都依赖于某个字段的N个区域，而不用手动更新它们。</p>

<h6>MVVM小酌：</h6>

<ol>
<li><p>Model层是少不了的了，我们得有东西充当DTO(数据传输对象)，当然，用字典也是可以的，编程么，要灵活一些。Model层是比较薄的一层，如果学过Java的小伙伴的话，对JavaBean应该不陌生吧。</p></li>
<li><p>ViewModel层，就是View和Model层的粘合剂，他是一个放置用户输入验证逻辑，视图显示逻辑，发起网络请求和其他各种各样的代码的极好的地方。说白了，就是把原来ViewController层的业务逻辑和页面逻辑等剥离出来放到ViewModel层。</p></li>
<li><p>View层，就是ViewController层，他的任务就是从ViewModel层获取数据，然后显示。</p></li>
</ol>


<h6>总结：</h6>

<ul>
<li>优点：MVVM就是在MVC的基础上加入了一个视图模型viewModel，用于数据有效性的验证，视图的展示逻辑，网络数据请求及处理，其他的数据处理逻辑集合，并定下相关接口和协议。相比起MVC，MVVM中vc的职责和复杂度更小，对数据处理逻辑的测试更加方便，对bug的原因排查更加方便，代码可阅读性，重用性和可维护性更高。MVVM耦合性更低。MVVM不同层级的职责更加明确，更有利于代码的编写和团队的协作。
缺点：MVVM相比MVC代码量有所增加。MVVM相比MVC在代码编写之前需要有更清晰的模式思路。</li>
</ul>


<h1>十五：Object&amp;Swift</h1>

<p>Obejective-C复杂的语法，更加简单易用、有未来，让许多开发者心动不已，Swift明显的特点有：</p>

<ul>
<li><p>苹果宣称 Swift 的特点是：快速、现代、安全、互动，而且明显优于 Objective-C 语言</p></li>
<li><p>可以使用现有的 <code>Cocoa</code> 和 <code>Cocoa Touch</code> 框架</p></li>
<li><p>Swift 取消了 Objective C 的指针及其他不安全访问的使用</p></li>
<li><p>舍弃 Objective C 早期应用 <code>Smalltalk</code> 的语法，全面改为句点表示法</p></li>
<li><p>提供了类似 Java 的名字空间(namespace)、泛型(generic)、运算对象重载（operator overloading）</p></li>
<li><p>Swift 被简单的形容为 “没有 C 的 Objective-C”（Objective-C without the C）</p></li>
<li><p>为苹果开发工具带来了Xcode Playgrounds功能，该功能提供强大的互动效果，能让Swift源代码在撰写过程中实时显示出其运行结果；</p></li>
<li><p>基于C和Objective-C，而却没有C的一些兼容约束；</p></li>
<li><p>采用了安全的编程模式；</p></li>
<li><p>界面基于Cocoa和Cocoa Touch框架；</p></li>
<li><p>保留了Smalltalk的动态特性。</p></li>
</ul>


<h1>十六：TCP&amp;UDP</h1>

<ul>
<li><p>TCP（Transmission Control Protocol，传输控制协议）是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“对话”才能建立起来，其中的过程非常复杂，我们这里只做简单、形象的介绍，你只要做到能够理解这个过程即可。</p></li>
<li><p>UDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去！
UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境。</p></li>
</ul>


<table>
<thead>
<tr>
<th>  区别</th>
<th style="text-align:center;"> TCP</th>
<th style="text-align:right;">  UDP </th>
</tr>
</thead>
<tbody>
<tr>
<td> 是否连接  </td>
<td style="text-align:center;">面向连接  </td>
<td style="text-align:right;">面向非连接  </td>
</tr>
<tr>
<td> 传输可靠性  </td>
<td style="text-align:center;">可靠  </td>
<td style="text-align:right;">不可靠  </td>
</tr>
<tr>
<td> 应用场合  </td>
<td style="text-align:center;">传输大量数据  </td>
<td style="text-align:right;">少量数据  </td>
</tr>
<tr>
<td> 速度 </td>
<td style="text-align:center;"> 慢 </td>
<td style="text-align:right;"> 快 </td>
</tr>
</tbody>
</table>


<h1>十七：POST&amp;GET</h1>

<ol>
<li>get是从服务器上获取数据，post是向服务器传送数据。</li>
<li>get是把参数数据队列加到提交表单的ACTION属性所指的URL中，值和表单内各个字段一一对应，在URL中可以看到。post是通过HTTP post机制，将表单内各个字段与其内容放置在HTML HEADER内一起传送到ACTION属性所指的URL地址。用户看不到这个过程。</li>
<li>对于get方式，服务器端用Request.QueryString获取变量的值，对于post方式，服务器端用Request.Form获取提交的数据。</li>
<li>get传送的数据量较小，不能大于2KB。post传送的数据量较大，一般被默认为不受限制。但理论上，IIS4中最大量为80KB，IIS5中为100KB。</li>
<li>get安全性非常低，post安全性较高。但是执行效率却比Post方法好。</li>
</ol>


<p>建议：
1、get方式的安全性较Post方式要差些，包含机密信息的话，建议用Post数据提交方式；
2、在做数据查询时，建议用Get方式；而在做数据添加、修改或删除时，建议用Post方式；</p>

<h1>十八：长链接&amp;短链接</h1>

<ul>
<li>TCP短连接</li>
</ul>


<p>我们模拟一下TCP短连接的情况，client向server发起连接请求，server接到请求，然后双方建立连接。client向server 发送消息，server回应client，然后一次读写就完成了，这时候双方任何一个都可以发起close操作，不过一般都是client先发起 close操作。为什么呢，一般的server不会回复完client后立即关闭连接的，当然不排除有特殊的情况。从上面的描述看，短连接一般只会在 client/server间传递一次读写操作</p>

<ul>
<li>TCP长连接</li>
</ul>


<p>接下来我们再模拟一下长连接的情况，client向server发起连接，server接受client连接，双方建立连接。Client与server完成一次读写之后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。</p>

<h6>长连接短连接操作过程</h6>

<ul>
<li>短连接的操作步骤是：</li>
</ul>


<p>建立连接——数据传输——关闭连接…建立连接——数据传输——关闭连接</p>

<ul>
<li>长连接的操作步骤是：</li>
</ul>


<p>建立连接——数据传输…（保持连接）…数据传输——关闭连接</p>

<h6>什么时候用长连接，短连接？</h6>

<ul>
<li><p>长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况，。每个TCP连接都需要三步握手，这需要时间，如果每个操作都是先连接，再操作的话那么处理速度会降低很多，所以每个操作完后都不断开，次处理时直接发送数据包就OK了，不用建立TCP连接。例如：数据库的连接用长连接， 如果用短连接频繁的通信会造成socket错误，而且频繁的socket 创建也是对资源的浪费。</p></li>
<li><p>而像WEB网站的http服务一般都用短链接，因为长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以并发量大，但每个用户无需频繁操作情况下需用短连好。</p></li>
</ul>


<h6>长连接和短连接的优点和缺点</h6>

<p>由上可以看出，长连接可以省去较多的TCP建立和关闭的操作，减少浪费，节约时间。对于频繁请求资源的客户来说，较适用长连接。不过这里存在一个问题，存活功能的探测周期太长，还有就是它只是探测TCP连接的存活，属于比较斯文的做法，遇到恶意的连接时，保活功能就不够使了。在长连接的应用场景下，client端一般不会主动关闭它们之间的连接，Client与server之间的连接如果一直不关闭的话，会存在一个问题，随着客户端连接越来越多，server早晚有扛不住的时候，这时候server端需要采取一些策略，如关闭一些长时间没有读写事件发生的连接，这样可 以避免一些恶意连接导致server端服务受损；如果条件再允许就可以以客户端机器为颗粒度，限制每个客户端的最大长连接数，这样可以完全避免某个蛋疼的客户端连累后端服务。</p>

<ul>
<li><p>短连接对于服务器来说管理较为简单，存在的连接都是有用的连接，不需要额外的控制手段。但如果客户请求频繁，将在TCP的建立和关闭操作上浪费时间和带宽。</p></li>
<li><p>长连接和短连接的产生在于client和server采取的关闭策略，具体的应用场景采用具体的策略，没有十全十美的选择，只有合适的选择。</p></li>
</ul>


<h1>十九：内存泄露&amp;内存溢出</h1>

<ul>
<li><p>内存溢出 out of memory，是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个integer,但给它存了long才能存下的数，那就是内存溢出。</p></li>
<li><p>内存泄露 memory leak，是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。</p></li>
</ul>


<blockquote><p>memory leak会最终会导致out of memory！</p></blockquote>

<p>内存溢出就是你要求分配的内存超出了系统能给你的，系统不能满足需求，于是产生溢出。</p>

<h1>二十：CoreData&amp;SQLite3</h1>

<p>首先，coredata和sqlite的概念不同，core为对象周期管理，而sqlite为dbms。</p>

<ul>
<li>使用方便性。实际上，一个成熟的工程中一定是对数据持久化进行了封装的，因此底层使用的到底是core data还是sqlite，不应该被业务逻辑开发者关心。因此，即使习惯写SQL查询的人，也应该避免在业务逻辑中直接编写SQL语句。</li>
<li>存储性能，在写入性能上，因为都是使用的sqlite格式作为磁盘存储格式，因此其性能是一样的，如果你觉得用core data写的慢，很可能是你用sqlite的时候写的每条数据的内容没有core data时多，或者是你批量写入的时候每写入一条就调用了一次save。</li>
<li>查询性能，core data因为要兼容多种后端格式，因此查询时，其可用的语句比直接使用sqlite少，因此有些fetch实际上不是在sqlite中执行的。但这样未必会降低查询效率。因为iPhone的flash memory速度还是很快的。我的经验是大部分时候，在内存不是很紧张时，直接fetch一个entity的所有数据然后在内存中做filter往往比使用predicate在fetch时过滤更快。如果你觉的查询慢，很可能是查询方式有问题，可以把core data的debug模式打开，看一下到底执行了多少SQL语句，相信其中大部分是可以通过改写core data的调用方式避免的。</li>
<li>core data的一个比较大的痛点是多人合作开发的时候，管理coredata的模型需要很小心，尤其是合并的时候，他的data model是XML格式的，手动resolve比较烦心。</li>
<li>core data还有其他sql所不具备的优点，比如对undo的支持，多个context实现sketchbook类似的功能。为ManagedObject优化的row cash等。</li>
<li>另外core data是支持多线程的，但需要thread confinement的方式实现,使用了多线程之后可以最大化的防止阻塞主线程。</li>
</ul>


<h1>二十一：传值通知&amp;推送通知（本地&amp;远程）</h1>

<ul>
<li>传值通知：类似通知，代理，Block实现值得传递</li>
<li>推送通知：推送到用户手机对应的App上（主要是不再前台的情况）</li>
</ul>


<h6>本地通知。</h6>

<p>local notification，用于基于时间行为的通知，比如有关日历或者todo列表的小应用。另外，应用如果在后台执行，iOS允许它在受限的时间内运行，它也会发现本地通知有用。比如，一个应用，在后台运行，向应用的服务器端获取消息，当消息到达时，比如下载更新版本的提示消息，通过本地通知机制通知用户。</p>

<p>本地通知是UILocalNotification的实例，主要有三类属性：</p>

<ul>
<li>scheduled time，时间周期，用来指定iOS系统发送通知的日期和时间；</li>
<li>notification type，通知类型，包括警告信息、动作按钮的标题、应用图标上的badge（数字标记）和播放的声音；</li>
<li>自定义数据，本地通知可以包含一个dictionary类型的本地数据。</li>
</ul>


<p>对本地通知的数量限制，iOS最多允许最近本地通知数量是64个，超过限制的本地通知将被iOS忽略。</p>

<h6>远程通知（需要服务器）。</h6>

<p>流程大概是这样的</p>

<ul>
<li><p>1.生成CertificateSigningRequest.certSigningRequest文件</p></li>
<li><p>2.将CertificateSigningRequest.certSigningRequest上传进developer，导出.cer文件</p></li>
<li><p>3.利用CSR导出P12文件</p></li>
<li><p>4.需要准备下设备token值（无空格）</p></li>
<li><p>5.使用OpenSSL合成服务器所使用的推送证书</p></li>
</ul>


<p>一般使用极光推送，步骤是一样的，只是我们使用的服务器是极光的，不需要自己大服务器！</p>

<h1>二十二：第三方库&amp;第三方平台</h1>

<ul>
<li>第三方库:一般是指大牛封装好的一个框架（库），或者第三方给我们提供的一个库，这里比较笼统
*第三方平台：指第三方提供的一些服务，其实很多方面跟第三方库是一样的，但是还是存在一些区别。</li>
</ul>


<h6>区别：</h6>

<ul>
<li>库：AFN，ASI，Alomofire，MJRefresh，MJExtension，MBProgressHUD</li>
<li>平台：极光，百度，友盟，Mob，环信，

<h1>二十三：KVO&amp;KVC</h1></li>
</ul>


<h5>底层实现：</h5>

<ul>
<li><p>KVC运用了一个isa-swizzling技术。isa-swizzling就是类型混合指针机制。KVC主要通过isa- swizzling，来实现其内部查找定位的。isa指针，如其名称所指，（就是is a kind of的意思），指向维护分发表的对象的类。该分发表实际上包含了指向实现类中的方法的指针，和其它数据。</p></li>
<li><p>当观察者为一个对象的属性进行了注册，被观察对象的isa指针被修改的时候，isa指针就会指向一个中间类，而不是真实的类。所以isa指 针其实不需要指向实例对象真实的类。所以我们的程序最好不要依赖于isa指针。在调用类的方法的时候，最好要明确对象实例的类名。</p></li>
</ul>


<h6>KVO概述</h6>

<p>KVO,即：Key-Value Observing，它提供一种机制，当指定的对象的属性被修改后，则对象就会接受到通知。简单的说就是每次指定的被观察的对象的属性被修改后，KVO就会自动通知相应的观察者了。</p>

<h6>使用方法</h6>

<p>系统框架已经支持KVO，所以程序员在使用的时候非常简单。</p>

<ol>
<li><p>注册，指定被观察者的属性，</p></li>
<li><p>实现回调方法</p></li>
<li><p>移除观察</p></li>
</ol>


<h6>KVC概述</h6>

<p>KVC是KeyValueCoding的简称，它是一种可以直接通过字符串的名字(key)来访问类属性(实例变量)的机制。而不是通过调用Setter、Getter方法访问。</p>

<p>当使用KVO、Core Data、CocoaBindings、AppleScript(Mac支持)时，KVC是关键技术。</p>

<h6>使用方法</h6>

<p>关键方法定义在：NSKeyValueCodingprotocol</p>

<p>KVC支持类对象和内建基本数据类型。</p>

<ul>
<li><p>获取值</p>

<ul>
<li><p>valueForKey:，传入NSString属性的名字。</p></li>
<li><p>valueForKeyPath:，传入NSString属性的路径，xx.xx形式。</p></li>
<li><p>valueForUndefinedKey它的默认实现是抛出异常，可以重写这个函数做错误处理。</p></li>
</ul>
</li>
<li><p>修改值</p>

<ul>
<li><p>setValue:forKey:</p></li>
<li><p>setValue:forKeyPath:</p></li>
<li><p>setValue:forUndefinedKey:</p></li>
<li><p>setNilValueForKey:当对非类对象属性设置nil时，调用，默认抛出异常。</p></li>
</ul>
</li>
<li><p>一对多关系成员的情况</p>

<ul>
<li><p>mutableArrayValueForKey：有序一对多关系成员  NSArray</p></li>
<li><p>mutableSetValueForKey：无序一对多关系成员  NSSet</p></li>
</ul>
</li>
</ul>


<h6>补充：KVO与Notification之间的区别：</h6>

<ul>
<li><p>notification是需要一个发送notification的对象，一般是notificationCenter，来通知观察者。</p></li>
<li><p>KVO是直接通知到观察对象，并且逻辑非常清晰，实现步骤简单。</p></li>
</ul>


<h1>二十四：时间传递&amp;响应者链</h1>

<h6>事件的产生和传递过程：</h6>

<ul>
<li><p>1.发生触摸事件后，系统会将该事件加入到一个由UIApplication管理的队列事件中</p></li>
<li><p>2.UIApplication会从事件队列中取出最前面的事件，并将事件分发下去以便处理，通常会先发送事件给应用程序的主窗口(keyWindow)</p></li>
<li><p>3.主窗口会在视图层次结构中找到一个最合适的视图来处理触摸事件</p></li>
<li><p>4.找到合适的视图控件后，就会调用视图控件的touches方法来作事件的具体处理：touchesBegin&hellip; touchesMoved&hellip;touchesEnded等</p></li>
<li><p>5.这些touches方法默认的做法是将事件顺着响应者链条向上传递，将事件叫个上一个相应者进行处理</p></li>
</ul>


<blockquote><p>一般事件的传递是从父控件传递到子控件的</p>

<p>如果父控件接受不到触摸事件，那么子控件就不可能接收到触摸事件
UIView不能接收触摸事件的三种情况：</p></blockquote>

<ul>
<li><p>1.不接受用户交互：userInteractionEnabled = NO;</p></li>
<li><p>2.隐藏：hidden = YES;</p></li>
<li><p>3.透明：alpha = 0.0~0.01</p>

<pre><code>  用户的触摸事件首先会由系统截获，进行包装处理等。
  然后递归遍历所有的view，进行碰触测试(hitTest)，直到找到可以处理事件的view。
  - (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event;   // recursively calls -pointInside:withEvent:. point is in the receiver's coordinate system
  - (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event;   // default returns YES if point is in bounds
  大致的过程application –&gt; window –&gt; root view –&gt;……–&gt;lowest view 
</code></pre></li>
</ul>


<h6>响应者链</h6>

<p>响应者链条其实就是很多响应者对象(继承自UIResponder的对象)一起组合起来的链条称之为响应者链条</p>

<p>一般默认做法是控件将事件顺着响应者链条向上传递，将事件交给上一个响应者进行处理。那么如何判断当前响应者的上一个响应者是谁呢？有以下两个规则：</p>

<ul>
<li><p>1.判断当前是否是控制器的View，如果是控制器的View，上一个响应者就是控制器</p></li>
<li><p>2.如果不是控制器的View，上一个响应者就是父控件</p>

<p>  当有view能够处理触摸事件后，开始响应事件。
      系统会调用view的以下方法：</p>

<pre><code>  - (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event;
  - (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event;
  - (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event;
  - (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event;
  可以多对象共同响应事件。只需要在以上方法重载中调用super的方法。

  大致的过程initial view –&gt; super view –&gt; …..–&gt; view controller –&gt; window –&gt; Application

  需要特别注意的一点是，传递链中时没有controller的，因为controller本身不具有大小的概念。但是响应链中是有controller的，因为controller继承自UIResponder。
</code></pre></li>
</ul>


<blockquote><p>UIApplication&ndash;>UIWindow&ndash;>递归找到最合适处理的控件&ndash;>控件调用touches方法&ndash;>判断是否实现touches方法&ndash;>没有实现默认会将事件传递给上一个响应者&ndash;>找到上一个响应者&ndash;>找不到方法作废</p></blockquote>

<p>PS：利用响应者链条我们可以通过调用touches的super 方法，让多个响应者同时响应该事件。</p>

<h1>二十五：堆&amp;栈</h1>

<h6>一、堆栈空间分配区别：</h6>

<pre><code>* 1、栈（操作系统）：由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈；

* 2、堆（操作系统）： 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表。
</code></pre>

<h6>二、堆栈缓存方式区别：</h6>

<pre><code>* 1、栈使用的是一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放；

* 2、堆是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。
</code></pre>

<h6>三、堆栈数据结构区别：</h6>

<pre><code>* 堆（数据结构）：堆可以被看成是一棵树，如：堆排序；

* 栈（数据结构）：一种先进后出的数据结构。 
</code></pre>

<h6>内存其他补充：</h6>

<ul>
<li>全局区（静态区）（static）—，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。 - 程序结束后有系统释放</li>
<li>文字常量区—常量字符串就是放在这里的。 程序结束后由系统释放</li>
<li>程序代码区—存放函数体的二进制代码。</li>
</ul>


<h1>二十六：UDID&amp;UUID</h1>

<ul>
<li>UDID是Unique Device Identifier的缩写,中文意思是设备唯一标识.</li>
</ul>


<p>在很多需要限制一台设备一个账号的应用中经常会用到,在Symbian时代,我们是使用IMEI作为设备的唯一标识的,可惜的是Apple官方不允许开发者获得设备的IMEI.</p>

<pre><code>[UIDevice currentDevice] uniqueIdentifier]
</code></pre>

<p>但是我们需要注意的一点是,对于已越狱了的设备,UDID并不是唯一的.使用Cydia插件UDIDFaker,可以为每一个应用分配不同的UDID.
所以UDID作为标识唯一设备的用途已经不大了.</p>

<ul>
<li>UUID是Universally Unique Identifier的缩写,中文意思是通用唯一识别码.</li>
</ul>


<p>由网上资料显示,UUID是一个软件建构的标准,也是被开源软件基金会(Open Software Foundation,OSF)的组织在分布式计算环境(Distributed Computing Environment,DCE)领域的一部份.UUID的目的,是让分布式系统中的所有元素,都能有唯一的辨识资讯,而不需要透过中央控制端来做辨识资讯的指定.</p>

<h1>二十七：CPU&amp;GPU</h1>

<ul>
<li><p>CPU:中央处理器（英文Central Processing Unit）是一台计算机的运算核心和控制核心。CPU、内部存储器和输入/输出设备是电子计算机三大核心部件。其功能主要是解释计算机指令以及处理计算机软件中的数据。</p></li>
<li><p>GPU:英文全称Graphic Processing Unit，中文翻译为“图形处理器”。一个专门的图形核心处理器。GPU是显示卡的“大脑”，决定了该显卡的档次和大部分性能，同时也是2D显示卡和3D显示卡的区别依据。2D显示芯片在处理3D图像和特效时主要依赖CPU的处理能力，称为“软加速”。3D显示芯片是将三维图像和特效处理功能集中在显示芯片内，也即所谓的“硬件加速”功能。</p></li>
</ul>


<h1>二十八:点（pt）&amp;像素（px）</h1>

<ul>
<li><p>像素（pixels）是数码显示上最小的计算单位。在同一个屏幕尺寸，更高的PPI（每英寸的像素数目），就能显示更多的像素，同时渲染的内容也会更清晰。</p></li>
<li><p>点（points）是一个与分辨率无关的计算单位。根据屏幕的像素密度，一个点可以包含多个像素（例如，在标准Retina显示屏上1 pt里有2 x 2个像素）。</p></li>
</ul>


<p>当你为多种显示设备设计时，你应该以“点”为单位作参考，但设计还是以像素为单位设计的。这意味着仍然需要以3种不同的分辨率导出你的素材，不管你以哪种分辨率设计你的应用。</p>

<h1>二十九：属性&amp;成员变量：</h1>

<p>成员变量是不与外界接触的变量，应用于类的内部，如果你说那用@Public外部不就是可以访问了么。简单的说public只能适当使用，不要泛滥，否则就像你把钥匙插在你自己家门上了。谁来都可以开门。毫无安全性。</p>

<p>由于成员变量的私有性，为了解决外部访问的问题就有了属性变量。属性变量个人认为最大的好处就是让其他对象访问这个变量。而且你可以设置只读、可写等等属性，同时设置的方法我们也可以自己定义。记住一点，属性变量主要是用于与其他对象相互交互的变量。</p>

<p>如果对于上面所说还是含糊不清那就记住这几点吧！</p>

<ul>
<li>1.只有类内使用，属性为private，那么就定义成员变量。</li>
<li>2.如果你发现你需要的这个属性需要是public的，那么毫不犹豫就用属性在.h中定义。</li>
<li>3.当你自己内部需要setter实现一些功能的时候，用属性在.m中定义。</li>
<li>4.当你自己内部需要getter实现一些功能的时候，用属性在.m中定义。</li>
</ul>


<h1>三十：IBInspectable &amp; IBDesignable</h1>

<ul>
<li><p>IBInspectable 属性提供了访问旧功能的新方式：用户自定义的运行时属性。从目前的身份检查器（identity inspector）中访问，这些属性在 Interface Builder 被整合到 Xcode 之前就可用了。他们提供了一个强有力的机制来配置一个 NIB，XIB，或者 storyboard 实例中的任何键值编码（key-value coded）属性：</p></li>
<li><p>IBDesignable 自定义视图也在 Xcode 6 中亮相了。当应用到 UIView 或 NSView 子类中的时候，@ IBDesignable 让 Interface Builder 知道它应该在画布上直接渲染视图。你会看到你的自定义视图在每次更改后不必编译并运行你的应用程序就会显示。</p>

<ul>
<li>标记一个自定义视图为 IBDesignable，只需在类名前加上 @IBDesignable 的前缀（或是 Objective-C 里的 IB_DESIGNABLE 宏）。你的初始化、布置和绘制方法将被用来在画布上渲染你的自定义视图：</li>
</ul>
</li>
</ul>


<h1>三十一：串行(Serial) &amp; 并行(Concurrent)</h1>

<ul>
<li>串行和并行描述的是任务和任务之间的执行方式. 串行是任务A执行完了任务B才能执行, 它们俩只能顺序执行. 并行则是任务A和任务B可以同时执行.</li>
</ul>


<h1>三十二：同步(Synchronous) &amp; 异步(Asynchronous)</h1>

<ul>
<li>同步和异步描述的其实就是函数什么时候返回. 比如用来下载图片的函数A: {download image}, 同步函数只有在image下载结束之后才返回, 下载的这段时间函数A只能搬个小板凳在那儿坐等&hellip; 而异步函数, 立即返回. 图片会去下载, 但函数A不会去等它完成. So, 异步函数不会堵塞当前线程去执行下一个函数!</li>
</ul>


<h1>三十三：并发(Concurrency) &amp; 并行(Parallelism)</h1>

<p>这个更容易混淆了, 先用Ray大神的示意图和说明来解释一下: 并发是程序的属性(property of the program), 而并行是计算机的属性(property of the machine).
还是很抽象? 那我再来解释一下, 并行和并发都是用来让不同的任务可以"同时执行", 只是并行是伪同时, 而并发是真同时. 假设你有任务T1和任务T2(这里的任务可以是进程也可以是线程):</p>

<ul>
<li><ol type="a">
<li>首先如果你的CPU是单核的, 为了实现"同时"执行T1和T2, 那只能分时执行, CPU执行一会儿T1后马上再去执行T2, 切换的速度非常快(这里的切换也是需要消耗资源的, context switch), 以至于你以为T1和T2是同时执行了(但其实同一时刻只有一个任务占有着CPU).</li>
</ol>
</li>
<li><ol type="a">
<li>如果你是多核CPU, 那么恭喜你, 你可以真正同时执行T1和T2了, 在同一时刻CPU的核心core1执行着T1, 然后core2执行着T2, great!</li>
</ol>
</li>
</ul>


<blockquote><p>其实我们平常说的并发编程包括狭义上的"并行"和"并发", 你不能保证你的代码会被并行执行, 但你可以以并发的方式设计你的代码. 系统会判断在某一个时刻是否有可用的core(多核CPU核心), 如果有就并行(parallelism)执行, 否则就用context switch来分时并发(concurrency)执行. 最后再以Ray大神的话结尾: Parallelism requires Concurrency, but Concurrency does not guarantee Parallelism!</p></blockquote>

<h1>三十四：黑盒测试&amp;白盒测试</h1>

<p>首先纠正 这个问题不属于“硬件”类的</p>

<p>什么是黑盒测试和白盒测试？
任何工程产品（注意是任何工程产品）都可以使用以下两种方法之一进行测试。</p>

<ul>
<li>黑盒测试：已知产品的功能设计规格，可以进行测试证明每个实现了的功能是否符合要求。</li>
<li>白盒测试：已知产品的内部工作过程，可以通过测试证明每种内部操作是否符合设计规格要求，所有内部成分是否以经过检查。</li>
</ul>


<h5>黑盒测试(界面):</h5>

<p>软件的黑盒测试意味着测试要在软件的接口处进行。这种方法是把测试对象看做一个黑盒子，测试人员完全不考虑程序内部的逻辑结构和内部特性，只依据程序的需求规格说明书，检查程序的功能是否符合它的功能说明。因此黑盒测试又叫功能测试或数据驱动测试。黑盒测试主要是为了发现以下几类错误：</p>

<ul>
<li>1、是否有不正确或遗漏的功能？</li>
<li>2、在接口上，输入是否能正确的接受？能否输出正确的结果？</li>
<li>3、是否有数据结构错误或外部信息（例如数据文件）访问错误？</li>
<li>4、性能上是否能够满足要求？</li>
<li>5、是否有初始化或终止性错误？</li>
</ul>


<h5>白盒测试(代码：服务器):实现细节，覆盖率</h5>

<p>软件的白盒测试是对软件的过程性细节做细致的检查。这种方法是把测试对象看做一个打开的盒子，它允许测试人员利用程序内部的逻辑结构及有关信息，设计或选择测试用例，对程序所有逻辑路径进行测试。通过在不同点检查程序状态，确定实际状态是否与预期的状态一致。因此白盒测试又称为结构测试或逻辑驱动测试。白盒测试主要是想对程序模块进行如下检查：</p>

<ul>
<li>1、对程序模块的所有独立的执行路径至少测试一遍。</li>
<li>2、对所有的逻辑判定，取“真”与取“假”的两种情况都能至少测一遍。</li>
<li>3、在循环的边界和运行的界限内执行循环体。</li>
<li>4、测试内部数据结构的有效性，等等。</li>
</ul>


<p>以上事实说明，软件测试有一个致命的缺陷，即测试的不完全、不彻底性。由于任何程序只能进行少量（相对于穷举的巨大数量而言）的有限的测试，在未发现错误时，不能说明程序中没有错误。</p>

<blockquote><p>补充：</p>

<p>灰盒测试:不需要关注代码细节，只需关注接口和参数</p>

<p>灰盒测试，是介于白盒测试与黑盒测试之间的，可以这样理解，灰盒测试关注输出对于输入的正确性，同时也关注内部表现，但这种关注不象白盒那样详细、完整，只是通过一些表征性的现象、事件、标志来判断内部的运行状态，有时候输出是正确的，但内部其实已经错误了，这种情况非常多，如果每次都通过白盒测试来操作，效率会很低，因此需要采取这样的一种灰盒的方法。</p></blockquote>

<h2>三十五：const * &amp; *const</h2>

<ul>
<li><p>int * const a;</p>

<ul>
<li>a是一个指向整型数的常指针（也就是说，指针指向的整型数是可以修改的，但指针是不可修改的）。</li>
</ul>
</li>
<li><p>const int *a;</p>

<ul>
<li>a是一个指向常整型数的常指针（也就是说，指针指向的整型数是不可修改的，同时指针也是不可修改的）。</li>
</ul>
</li>
</ul>


<h5>结论：</h5>

<ul>
<li>1 关键字const的作用是为给读你代码的人传达非常有用的信息，实际上，声明一个参数为常量是为了告诉了用户这个参数的应用目的。如果
你曾花很多时间清理其它人留下的垃圾，你就会很快学会感谢这点多余的信息。（当然，懂得用const的程序员很少会留下的垃圾让别人来清
理的。）</li>
<li>2 通过给优化器一些附加的信息，使用关键字const也许能产生更紧凑的代码。</li>
<li>3 合理地使用关键字const可以使编译器很自然地保护那些不希望被改变的参数，防止其被无意的代码修改。简而言之，这样可以减少bug的出现。</li>
</ul>


<h6>欲阻止一个变量被改变，可以使用 const 关键字。</h6>

<ul>
<li>（1）在定义该 const 变量时，通常需要对它进行初
始化，因为以后就没有机会再去改变它了；</li>
<li>（2）对指针来说，可以指定指针本身为 const，也可以指定指针所指的数据为 const，或二者同时指
定为 const；</li>
<li>（3）在一个函数声明中，const 可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值；</li>
<li>（4）对于类的成员函数，若指定其为 const 类型，则表明其是一个常函数，不能修改类的成员变量；</li>
<li>（5）对于类的成员函数，有时候必须指定其返回值为 const 类型，以使得其返回值不为“左值”。</li>
</ul>


<h2>三十六：UIWebView&amp;WKWebView</h2>

<p>ios的webview有2个类，一个叫UIWebView，另一个是WKWebView。两者的基础方法都差不多，本文重点是后者，他是取代UIWebView出现的，在app开发者若不需要兼容ios8之前版本，都应该使用WKWebVIew。</p>

<ul>
<li><p>WKWebView 是苹果在 iOS 8 中引入的新组件，目的是给出一个新的高性能的 Web View 解决方案，摆脱过去 UIWebView 的老旧笨重特别是内存占用量巨大的问题，它使用Nitro JavaScript引擎，这意味着所有第三方浏览器运行JavaScript将会跟safari一样快.</p></li>
<li><p>新特性</p>

<ul>
<li>在性能、稳定性、功能方面有很大提升（最直观的体现就是加载网页是占用的内存，模拟器加载百度与开源中国网站时，WKWebView占用23M，而UIWebView占用85M）；</li>
<li>允许JavaScript的Nitro库加载并使用（UIWebView中限制）；</li>
<li>支持了更多的HTML5特性；</li>
<li>高达60fps的滚动刷新率以及内置手势；</li>
<li>将UIWebViewDelegate与UIWebView重构成了14类与3个协议</li>
</ul>
</li>
</ul>


<blockquote><p>ios9默认是不允许加载http请求的，对于webview，加载http网页也是不允许的。可以通过修改info.plist取消http限制</p></blockquote>

<ul>
<li>WKWebVIew是UIWebView的代替品，新的WebKit框架把原来的功能拆分成许多小类。本例中主要用到了WKNavigationDelegate,WKUIDelegate,WKScriptMessageHandler三个委托和配置类WKWebViewConfiguration去实现webView的request控制，界面控制，js交互，alert重写等功能。 使用WKWebView需要引入#import &lt;WebKit/WebKit.h></li>
</ul>


<h2>三十七：指针&amp;地址</h2>

<ul>
<li><p>区别:</p>

<ul>
<li><p>1指针意味着已经有一个指针变量存在,他的值是一个地址,指针变量本身也存放在一个长度为四个字节的地址当中,而地址概念本身并不代表有任何变量存在.</p></li>
<li><p>2 指针的值,如果没有限制,通常是可以变化的,也可以指向另外一个地址.</p></li>
</ul>
</li>
</ul>


<p>地址表示内存空间的一个位置点,他是用来赋给指针的,地址本身是没有大小概念,指针指向变量的大小,取决于地址后面存放的变量类型.</p>

<h2>三十八：通知&amp;协议</h2>

<ul>
<li>答案：协议有控制链(has-a)的关系，通知没有。</li>
</ul>


<p>首先我一开始也不太明白，什么叫控制链（专业术语了~）。但是简单分析下通知和代理的行为模式，我们大致可以有自己的理解</p>

<p>简单来说，通知的话，它可以一对多，一条消息可以发送给多个消息接受者。</p>

<p>代理按我们的理解，到不是直接说不能一对多，比如我们知道的明星经济代理人，很多时候一个经济人负责好几个明星的事务。</p>

<p>只是对于不同明星间，代理的事物对象都是不一样的，一一对应，不可能说明天要处理A明星要一个发布会，代理人发出处理发布会的消息后，别称B的
发布会了。但是通知就不一样，他只关心发出通知，而不关心多少接收到感兴趣要处理。</p>

<p>因此控制链（has-a从英语单词大致可以看出，单一拥有和可控制的对应关系。</p>

<p><br>
<br>
&hellip;..
&hellip;.
&hellip;
..
.</p>

<p><br>
<br></p>

<p>待续。。。。。。。。。。后续会陆续更新，想了解更多，请等待并查看本文，谢谢！</p>

<p><br>
<br>
<br>
<br>
<br>
<br></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[序列化&amp;反序列化深究]]></title>
    <link href="http://al1020119.github.io/blog/2015/09/20/xu-lie-hua-and-fan-xu-lie-hua-shen-jiu/"/>
    <updated>2015-09-20T09:36:37+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/09/20/xu-lie-hua-and-fan-xu-lie-hua-shen-jiu</id>
    <content type="html"><![CDATA[<blockquote><p>摘要
序列化和反序列化几乎是工程师们每天都要面对的事情，但是要精确掌握这两个概念并不容易：一方面，它们往往作为框架的一部分出现而湮没在框架之中；另一方面，它们会以其他更容易理解的概念出现，例如加密、持久化。然而，序列化和反序列化的选型却是系统设计或重构一个重要的环节，在分布式、大数据量系统设计里面更为显著。恰当的序列化协议不仅可以提高系统的通用性、强健性、安全性、优化系统性能，而且会让系统更加易于调试、便于扩展。本文从多个角度去分析和讲解“序列化和反序列化”，并对比了当前流行的几种序列化协议，期望对读者做序列化选型有所帮助。</p></blockquote>

<!--more-->


<h2>简介</h2>

<p>文章作者服务于美团推荐与个性化组，该组致力于为美团用户提供每天billion级别的高质量个性化推荐以及排序服务。从Terabyte级别的用户行为数据，到Gigabyte级别的Deal/Poi数据；从对实时性要求毫秒以内的用户实时地理位置数据，到定期后台job数据，推荐与重排序系统需要多种类型的数据服务。推荐与重排序系统客户包括各种内部服务、美团客户端、美团网站。为了提供高质量的数据服务，为了实现与上下游各系统进行良好的对接，序列化和反序列化的选型往往是我们做系统设计的一个重要考虑因素。</p>

<p>本文内容按如下方式组织：</p>

<ul>
<li>第一部分给出了序列化和反序列化的定义，以及其在通讯协议中所处的位置。</li>
<li>第二部分从使用者的角度探讨了序列化协议的一些特性。</li>
<li>第三部分描述在具体的实施过程中典型的序列化组件，并与数据库组建进行了类比。</li>
<li>第四部分分别讲解了目前常见的几种序列化协议的特性，应用场景，并对相关组件进行举例。</li>
<li>最后一部分，基于各种协议的特性，以及相关benchmark数据，给出了作者的技术选型建议。</li>
</ul>


<h4>一、定义以及相关概念</h4>

<p>互联网的产生带来了机器间通讯的需求，而互联通讯的双方需要采用约定的协议，序列化和反序列化属于通讯协议的一部分。通讯协议往往采用分层模型，不同模型每层的功能定义以及颗粒度不同，例如：TCP/IP协议是一个四层协议，而OSI模型却是七层协议模型。在OSI七层协议模型中展现层（Presentation Layer）的主要功能是把应用层的对象转换成一段连续的二进制串，或者反过来，把二进制串转换成应用层的对象&ndash;这两个功能就是序列化和反序列化。一般而言，TCP/IP协议的应用层对应与OSI七层协议模型的应用层，展示层和会话层，所以序列化协议属于TCP/IP协议应用层的一部分。本文对序列化协议的讲解主要基于OSI七层协议模型。</p>

<ul>
<li>序列化： 将数据结构或对象转换成二进制串的过程</li>
<li>反序列化：将在序列化过程中所生成的二进制串转换成数据结构或者对象的过程</li>
</ul>


<p>数据结构、对象与二进制串
不同的计算机语言中，数据结构，对象以及二进制串的表示方式并不相同。</p>

<p>数据结构和对象：对于类似Java这种完全面向对象的语言，工程师所操作的一切都是对象（Object），来自于类的实例化。在Java语言中最接近数据结构的概念，就是POJO（Plain Old Java Object）或者Javabean－－那些只有setter/getter方法的类。而在C++这种半面向对象的语言中，数据结构和struct对应，对象和class对应。</p>

<p>二进制串：序列化所生成的二进制串指的是存储在内存中的一块数据。C++语言具有内存操作符，所以二进制串的概念容易理解，例如，C++语言的字符串可以直接被传输层使用，因为其本质上就是以'\0'结尾的存储在内存中的二进制串。在Java语言里面，二进制串的概念容易和String混淆。实际上String 是Java的一等公民，是一种特殊对象（Object）。对于跨语言间的通讯，序列化后的数据当然不能是某种语言的特殊数据类型。二进制串在Java里面所指的是byte[]，byte是Java的8中原生数据类型之一（Primitive data types）。</p>

<h4>二、序列化协议特性</h4>

<p>每种序列化协议都有优点和缺点，它们在设计之初有自己独特的应用场景。在系统设计的过程中，需要考虑序列化需求的方方面面，综合对比各种序列化协议的特性，最终给出一个折衷的方案。</p>

<h6>通用性有两个层面的意义：</h6>

<ul>
<li>第一、技术层面，序列化协议是否支持跨平台、跨语言。如果不支持，在技术层面上的通用性就大大降低了。</li>
<li>第二、流行程度，序列化和反序列化需要多方参与，很少人使用的协议往往意味着昂贵的学习成本；另一方面，流行度低的协议，往往缺乏稳定而成熟的跨语言、跨平台的公共包。</li>
</ul>


<p>强健性/鲁棒性
以下两个方面的原因会导致协议不够强健：</p>

<ul>
<li>第一、成熟度不够，一个协议从制定到实施，到最后成熟往往是一个漫长的阶段。协议的强健性依赖于大量而全面的测试，对于致力于提供高质量服务的系统，采用处于测试阶段的序列化协议会带来很高的风险。</li>
<li>第二、语言/平台的不公平性。为了支持跨语言、跨平台的功能，序列化协议的制定者需要做大量的工作；但是，当所支持的语言或者平台之间存在难以调和的特性的时候，协议制定者需要做一个艰难的决定&ndash;支持更多人使用的语言/平台，亦或支持更多的语言/平台而放弃某个特性。当协议的制定者决定为某种语言或平台提供更多支持的时候，对于使用者而言，协议的强健性就被牺牲了。</li>
</ul>


<p>可调试性/可读性
序列化和反序列化的数据正确性和业务正确性的调试往往需要很长的时间，良好的调试机制会大大提高开发效率。序列化后的二进制串往往不具备人眼可读性，为了验证序列化结果的正确性，写入方不得同时撰写反序列化程序，或提供一个查询平台&ndash;这比较费时；另一方面，如果读取方未能成功实现反序列化，这将给问题查找带来了很大的挑战&ndash;难以定位是由于自身的反序列化程序的bug所导致还是由于写入方序列化后的错误数据所导致。对于跨公司间的调试，由于以下原因，问题会显得更严重：</p>

<ul>
<li>第一、支持不到位，跨公司调试在问题出现后可能得不到及时的支持，这大大延长了调试周期。</li>
<li>第二、访问限制，调试阶段的查询平台未必对外公开，这增加了读取方的验证难度。</li>
</ul>


<p>如果序列化后的数据人眼可读，这将大大提高调试效率， XML和JSON就具有人眼可读的优点。</p>

<h6>性能包括两个方面，时间复杂度和空间复杂度：</h6>

<ul>
<li>第一、空间开销（Verbosity）， 序列化需要在原有的数据上加上描述字段，以为反序列化解析之用。如果序列化过程引入的额外开销过高，可能会导致过大的网络，磁盘等各方面的压力。对于海量分布式存储系统，数据量往往以TB为单位，巨大的的额外空间开销意味着高昂的成本。</li>
<li>第二、时间开销（Complexity），复杂的序列化协议会导致较长的解析时间，这可能会使得序列化和反序列化阶段成为整个系统的瓶颈。</li>
</ul>


<p>可扩展性/兼容性
移动互联时代，业务系统需求的更新周期变得更快，新的需求不断涌现，而老的系统还是需要继续维护。如果序列化协议具有良好的可扩展性，支持自动增加新的业务字段，而不影响老的服务，这将大大提供系统的灵活度。</p>

<p>安全性/访问限制
在序列化选型的过程中，安全性的考虑往往发生在跨局域网访问的场景。当通讯发生在公司之间或者跨机房的时候，出于安全的考虑，对于跨局域网的访问往往被限制为基于HTTP/HTTPS的80和443端口。如果使用的序列化协议没有兼容而成熟的HTTP传输层框架支持，可能会导致以下三种结果之一：</p>

<ul>
<li>第一、因为访问限制而降低服务可用性。</li>
<li>第二、被迫重新实现安全协议而导致实施成本大大提高。</li>
<li>第三、开放更多的防火墙端口和协议访问，而牺牲安全性。</li>
</ul>


<h4>三、序列化和反序列化的组件</h4>

<p>典型的序列化和反序列化过程往往需要如下组件：</p>

<ul>
<li>IDL（Interface description language）文件：参与通讯的各方需要对通讯的内容需要做相关的约定（Specifications）。为了建立一个与语言和平台无关的约定，这个约定需要采用与具体开发语言、平台无关的语言来进行描述。这种语言被称为接口描述语言（IDL），采用IDL撰写的协议约定称之为IDL文件。</li>
<li>IDL Compiler：IDL文件中约定的内容为了在各语言和平台可见，需要有一个编译器，将IDL文件转换成各语言对应的动态库。</li>
<li>Stub/Skeleton Lib：负责序列化和反序列化的工作代码。Stub是一段部署在分布式系统客户端的代码，一方面接收应用层的参数，并对其序列化后通过底层协议栈发送到服务端，另一方面接收服务端序列化后的结果数据，反序列化后交给客户端应用层；Skeleton部署在服务端，其功能与Stub相反，从传输层接收序列化参数，反序列化后交给服务端应用层，并将应用层的执行结果序列化后最终传送给客户端Stub。</li>
<li>Client/Server：指的是应用层程序代码，他们面对的是IDL所生存的特定语言的class或struct。
底层协议栈和互联网：序列化之后的数据通过底层的传输层、网络层、链路层以及物理层协议转换成数字信号在互联网中传递。
序列化组件</li>
</ul>


<p>序列化组件与数据库访问组件的对比
数据库访问对于很多工程师来说相对熟悉，所用到的组件也相对容易理解。下表类比了序列化过程中用到的部分组件和数据库访问组件的对应关系，以便于大家更好的把握序列化相关组件的概念。</p>

<table>
<thead>
<tr>
<th> 序列化组件         </th>
<th style="text-align:center;"> 数据库组件          </th>
<th style="text-align:right;"> 说明  </th>
</tr>
</thead>
<tbody>
<tr>
<td> IDL           </td>
<td style="text-align:center;">   DDL              </td>
<td style="text-align:right;"> 用于建表或者模型的语言</td>
</tr>
<tr>
<td> DL            </td>
<td style="text-align:center;"> file DB Schema    </td>
<td style="text-align:right;"> 表创建文件或模型文件</td>
</tr>
<tr>
<td> Stub/Skeleton </td>
<td style="text-align:center;">  lib  O/R mapping </td>
<td style="text-align:right;">   将class和Table或者数据模型进行映射</td>
</tr>
</tbody>
</table>


<h4>四、几种常见的序列化和反序列化协议</h4>

<p>互联网早期的序列化协议主要有COM和CORBA。</p>

<p>COM主要用于Windows平台，并没有真正实现跨平台，另外COM的序列化的原理利用了编译器中虚表，使得其学习成本巨大（想一下这个场景， 工程师需要是简单的序列化协议，但却要先掌握语言编译器）。由于序列化的数据与编译器紧耦合，扩展属性非常麻烦。</p>

<p>CORBA是早期比较好的实现了跨平台，跨语言的序列化协议。COBRA的主要问题是参与方过多带来的版本过多，版本之间兼容性较差，以及使用复杂晦涩。这些政治经济，技术实现以及早期设计不成熟的问题，最终导致COBRA的渐渐消亡。J2SE 1.3之后的版本提供了基于CORBA协议的RMI-IIOP技术，这使得Java开发者可以采用纯粹的Java语言进行CORBA的开发。</p>

<p>这里主要介绍和对比几种当下比较流行的序列化协议，包括XML、JSON、Protobuf、Thrift和Avro。</p>

<p>一个例子
如前所述，序列化和反序列化的出现往往晦涩而隐蔽，与其他概念之间往往相互包容。为了更好了让大家理解序列化和反序列化的相关概念在每种协议里面的具体实现，我们将一个例子穿插在各种序列化协议讲解中。在该例子中，我们希望将一个用户信息在多个系统里面进行传递；在应用层，如果采用Java语言，所面对的类对象如下所示：</p>

<pre><code>class Address
{
    private String city;
    private String postcode;
    private String street;
}
public class UserInfo
{
    private Integer userid;
    private String name;
    private List&lt;Address&gt; address;
}
</code></pre>

<h6>XML&amp;SOAP</h6>

<ul>
<li><p>XML是一种常用的序列化和反序列化协议，具有跨机器，跨语言等优点。 XML历史悠久，其1.0版本早在1998年就形成标准，并被广泛使用至今。XML的最初产生目标是对互联网文档（Document）进行标记，所以它的设计理念中就包含了对于人和机器都具备可读性。 但是，当这种标记文档的设计被用来序列化对象的时候，就显得冗长而复杂（Verbose and Complex）。 XML本质上是一种描述语言，并且具有自我描述（Self-describing）的属性，所以XML自身就被用于XML序列化的IDL。 标准的XML描述格式有两种：DTD（Document Type Definition）和XSD（XML Schema Definition）。作为一种人眼可读（Human-readable）的描述语言，XML被广泛使用在配置文件中，例如O/R mapping、 Spring Bean Configuration File 等。</p></li>
<li><p>SOAP（Simple Object Access protocol） 是一种被广泛应用的，基于XML为序列化和反序列化协议的结构化消息传递协议。SOAP在互联网影响如此大，以至于我们给基于SOAP的解决方案一个特定的名称&ndash;Web service。SOAP虽然可以支持多种传输层协议，不过SOAP最常见的使用方式还是XML+HTTP。SOAP协议的主要接口描述语言（IDL）是WSDL（Web Service Description Language）。SOAP具有安全、可扩展、跨语言、跨平台并支持多种传输层协议。如果不考虑跨平台和跨语言的需求，XML的在某些语言里面具有非常简单易用的序列化使用方法，无需IDL文件和第三方编译器， 例如Java＋XStream。</p></li>
</ul>


<p>自我描述与递归
SOAP是一种采用XML进行序列化和反序列化的协议，它的IDL是WSDL. 而WSDL的描述文件是XSD，而XSD自身是一种XML文件。 这里产生了一种有趣的在数学上称之为“递归”的问题，这种现象往往发生在一些具有自我属性（Self-description）的事物上。</p>

<p>IDL文件举例
采用WSDL描述上述用户基本信息的例子如下：</p>

<pre><code>&lt;xsd:complexType name='Address'&gt;
     &lt;xsd:attribute name='city' type='xsd:string' /&gt;
     &lt;xsd:attribute name='postcode' type='xsd:string' /&gt;
     &lt;xsd:attribute name='street' type='xsd:string' /&gt;
&lt;/xsd:complexType&gt;
&lt;xsd:complexType name='UserInfo'&gt;
     &lt;xsd:sequence&gt;
     &lt;xsd:element name='address' type='tns:Address'/&gt;
     &lt;xsd:element name='address1' type='tns:Address'/&gt; 
     &lt;/xsd:sequence&gt;
     &lt;xsd:attribute name='userid' type='xsd:int' /&gt;
     &lt;xsd:attribute name='name' type='xsd:string' /&gt; 
&lt;/xsd:complexType&gt;
</code></pre>

<p>典型应用场景和非应用场景
SOAP协议具有广泛的群众基础，基于HTTP的传输协议使得其在穿越防火墙时具有良好安全特性，XML所具有的人眼可读（Human-readable）特性使得其具有出众的可调试性，互联网带宽的日益剧增也大大弥补了其空间开销大（Verbose）的缺点。对于在公司之间传输数据量相对小或者实时性要求相对低（例如秒级别）的服务是一个好的选择。</p>

<p>由于XML的额外空间开销大，序列化之后的数据量剧增，对于数据量巨大序列持久化应用常景，这意味着巨大的内存和磁盘开销，不太适合XML。另外，XML的序列化和反序列化的空间和时间开销都比较大，对于对性能要求在ms级别的服务，不推荐使用。WSDL虽然具备了描述对象的能力，SOAP的S代表的也是simple，但是SOAP的使用绝对不简单。对于习惯于面向对象编程的用户，WSDL文件不直观。</p>

<p>JSON（Javascript Object Notation）
JSON起源于弱类型语言Javascript， 它的产生来自于一种称之为"Associative array"的概念，其本质是就是采用"Attribute－value"的方式来描述对象。实际上在Javascript和PHP等弱类型语言中，类的描述方式就是Associative array。JSON的如下优点，使得它快速成为最广泛使用的序列化协议之一：</p>

<ul>
<li>1、这种Associative array格式非常符合工程师对对象的理解。</li>
<li>2、它保持了XML的人眼可读（Human-readable）的优点。</li>
<li>3、相对于XML而言，序列化后的数据更加简洁。 来自于的以下链接的研究表明：XML所产生序列化之后文件的大小接近JSON的两倍。<a href="http://www.codeproject.com/Articles/604720/JSON-vs-XML-Some-hard-numbers-about-verbosity">http://www.codeproject.com/Articles/604720/JSON-vs-XML-Some-hard-numbers-about-verbosity</a></li>
<li>4、它具备Javascript的先天性支持，所以被广泛应用于Web browser的应用常景中，是Ajax的事实标准协议。</li>
<li>5、与XML相比，其协议比较简单，解析速度比较快。</li>
<li>6、松散的Associative array使得其具有良好的可扩展性和兼容性。</li>
</ul>


<p>IDL悖论
JSON实在是太简单了，或者说太像各种语言里面的类了，所以采用JSON进行序列化不需要IDL。这实在是太神奇了，存在一种天然的序列化协议，自身就实现了跨语言和跨平台。然而事实没有那么神奇，之所以产生这种假象，来自于两个原因：</p>

<h6>第一</h6>

<p>Associative array在弱类型语言里面就是类的概念，在PHP和Javascript里面Associative array就是其class的实际实现方式，所以在这些弱类型语言里面，JSON得到了非常良好的支持。</p>

<h6>第二</h6>

<p>IDL的目的是撰写IDL文件，而IDL文件被IDL Compiler编译后能够产生一些代码（Stub/Skeleton），而这些代码是真正负责相应的序列化和反序列化工作的组件。 但是由于Associative array和一般语言里面的class太像了，他们之间形成了一一对应关系，这就使得我们可以采用一套标准的代码进行相应的转化。对于自身支持Associative array的弱类型语言，语言自身就具备操作JSON序列化后的数据的能力；对于Java这强类型语言，可以采用反射的方式统一解决，例如Google提供的Gson。</p>

<p>典型应用场景和非应用场景
JSON在很多应用场景中可以替代XML，更简洁并且解析速度更快。典型应用场景包括：</p>

<ul>
<li>1、公司之间传输数据量相对小，实时性要求相对低（例如秒级别）的服务。</li>
<li>2、基于Web browser的Ajax请求。</li>
<li>3、由于JSON具有非常强的前后兼容性，对于接口经常发生变化，并对可调式性要求高的场景，例如Mobile app与服务端的通讯。</li>
<li>4、由于JSON的典型应用场景是JSON＋HTTP，适合跨防火墙访问。</li>
</ul>


<p>总的来说，采用JSON进行序列化的额外空间开销比较大，对于大数据量服务或持久化，这意味着巨大的内存和磁盘开销，这种场景不适合。没有统一可用的IDL降低了对参与方的约束，实际操作中往往只能采用文档方式来进行约定，这可能会给调试带来一些不便，延长开发周期。 由于JSON在一些语言中的序列化和反序列化需要采用反射机制，所以在性能要求为ms级别，不建议使用。</p>

<p>IDL文件举例
以下是UserInfo序列化之后的一个例子：</p>

<pre><code>{"userid":1,"name":"messi","address":[{"city":"北京","postcode":"1000000","street":"wangjingdonglu"}]}
</code></pre>

<p>Thrift
Thrift是Facebook开源提供的一个高性能，轻量级RPC服务框架，其产生正是为了满足当前大数据量、分布式、跨语言、跨平台数据通讯的需求。 但是，Thrift并不仅仅是序列化协议，而是一个RPC框架。相对于JSON和XML而言，Thrift在空间开销和解析性能上有了比较大的提升，对于对性能要求比较高的分布式系统，它是一个优秀的RPC解决方案；但是由于Thrift的序列化被嵌入到Thrift框架里面，Thrift框架本身并没有透出序列化和反序列化接口，这导致其很难和其他传输层协议共同使用（例如HTTP）。</p>

<p>典型应用场景和非应用场景
对于需求为高性能，分布式的RPC服务，Thrift是一个优秀的解决方案。它支持众多语言和丰富的数据类型，并对于数据字段的增删具有较强的兼容性。所以非常适用于作为公司内部的面向服务构建（SOA）的标准RPC框架。</p>

<p>不过Thrift的文档相对比较缺乏，目前使用的群众基础相对较少。另外由于其Server是基于自身的Socket服务，所以在跨防火墙访问时，安全是一个顾虑，所以在公司间进行通讯时需要谨慎。 另外Thrift序列化之后的数据是Binary数组，不具有可读性，调试代码时相对困难。最后，由于Thrift的序列化和框架紧耦合，无法支持向持久层直接读写数据，所以不适合做数据持久化序列化协议。</p>

<p>IDL文件举例</p>

<pre><code>struct Address
{ 
    1: required string city;
    2: optional string postcode;
    3: optional string street;
} 
struct UserInfo
{ 
    1: required string userid;
    2: required i32 name;
    3: optional list&lt;Address&gt; address;
}
</code></pre>

<p>Protobuf
Protobuf具备了优秀的序列化协议的所需的众多典型特征：</p>

<ul>
<li>1、标准的IDL和IDL编译器，这使得其对工程师非常友好。</li>
<li>2、序列化数据非常简洁，紧凑，与XML相比，其序列化之后的数据量约为1/3到1/10。</li>
<li>3、解析速度非常快，比对应的XML快约20-100倍。</li>
<li>4、提供了非常友好的动态库，使用非常简介，反序列化只需要一行代码。</li>
</ul>


<p>Protobuf是一个纯粹的展示层协议，可以和各种传输层协议一起使用；Protobuf的文档也非常完善。 但是由于Protobuf产生于Google，所以目前其仅仅支持Java、C++、Python三种语言。另外Protobuf支持的数据类型相对较少，不支持常量类型。由于其设计的理念是纯粹的展现层协议（Presentation Layer），目前并没有一个专门支持Protobuf的RPC框架。</p>

<p>典型应用场景和非应用场景
Protobuf具有广泛的用户基础，空间开销小以及高解析性能是其亮点，非常适合于公司内部的对性能要求高的RPC调用。由于Protobuf提供了标准的IDL以及对应的编译器，其IDL文件是参与各方的非常强的业务约束，另外，Protobuf与传输层无关，采用HTTP具有良好的跨防火墙的访问属性，所以Protobuf也适用于公司间对性能要求比较高的场景。由于其解析性能高，序列化后数据量相对少，非常适合应用层对象的持久化场景。</p>

<p>它的主要问题在于其所支持的语言相对较少，另外由于没有绑定的标准底层传输层协议，在公司间进行传输层协议的调试工作相对麻烦。</p>

<p>IDL文件举例</p>

<pre><code>message Address
{
    required string city=1;
        optional string postcode=2;
        optional string street=3;
}
message UserInfo
{
    required string userid=1;
    required string name=2;
    repeated Address address=3;
}
</code></pre>

<p>Avro</p>

<pre><code>Avro的产生解决了JSON的冗长和没有IDL的问题，Avro属于Apache Hadoop的一个子项目。 Avro提供两种序列化格式：JSON格式或者Binary格式。Binary格式在空间开销和解析性能方面可以和Protobuf媲美，JSON格式方便测试阶段的调试。 Avro支持的数据类型非常丰富，包括C++语言里面的union类型。Avro支持JSON格式的IDL和类似于Thrift和Protobuf的IDL（实验阶段），这两者之间可以互转。Schema可以在传输数据的同时发送，加上JSON的自我描述属性，这使得Avro非常适合动态类型语言。 Avro在做文件持久化的时候，一般会和Schema一起存储，所以Avro序列化文件自身具有自我描述属性，所以非常适合于做Hive、Pig和MapReduce的持久化数据格式。对于不同版本的Schema，在进行RPC调用的时候，服务端和客户端可以在握手阶段对Schema进行互相确认，大大提高了最终的数据解析速度。
</code></pre>

<p>典型应用场景和非应用场景
Avro解析性能高并且序列化之后的数据非常简洁，比较适合于高性能的序列化服务。</p>

<p>由于Avro目前非JSON格式的IDL处于实验阶段，而JSON格式的IDL对于习惯于静态类型语言的工程师来说不直观。</p>

<p>IDL文件举例</p>

<pre><code>protocol Userservice {
  record Address {
   string city;
   string postcode;
   string street;
  }  
  record UserInfo {
   string name;
   int userid;
   array&lt;Address&gt; address = [];
  }
}
</code></pre>

<p>所对应的JSON Schema格式如下：</p>

<pre><code>{
  "protocol" : "Userservice",
  "namespace" : "org.apache.avro.ipc.specific",
  "version" : "1.0.5",
  "types" : [ {
    "type" : "record",
    "name" : "Address",
    "fields" : [ {
      "name" : "city",
      "type" : "string"
    }, {
      "name" : "postcode",
      "type" : "string"
    }, {
      "name" : "street",
      "type" : "string"
    } ]
  }, {
    "type" : "record",
    "name" : "UserInfo",
    "fields" : [ {
      "name" : "name",
      "type" : "string"
    }, {
      "name" : "userid",
      "type" : "int"
    }, {
      "name" : "address",
      "type" : {
        "type" : "array",
        "items" : "Address"
      },
      "default" : [ ]
    } ]
  } ],
  "messages" : { }
}
</code></pre>

<h4>五、Benchmark以及选型建议</h4>

<p>Benchmark
以下数据来自<a href="https://code.google.com/p/thrift-protobuf-compare/wiki/Benchmarking">https://code.google.com/p/thrift-protobuf-compare/wiki/Benchmarking</a></p>

<ul>
<li>解析性能</li>
<li>序列化之空间开销</li>
<li>序列化大小</li>
</ul>


<p>从上图可得出如下结论：</p>

<ul>
<li>1、XML序列化（Xstream）无论在性能和简洁性上比较差。</li>
<li>2、Thrift与Protobuf相比在时空开销方面都有一定的劣势。</li>
<li>3、Protobuf和Avro在两方面表现都非常优越。</li>
</ul>


<p>选型建议</p>

<pre><code>以上描述的五种序列化和反序列化协议都各自具有相应的特点，适用于不同的场景：
1、对于公司间的系统调用，如果性能要求在100ms以上的服务，基于XML的SOAP协议是一个值得考虑的方案。
2、基于Web browser的Ajax，以及Mobile app与服务端之间的通讯，JSON协议是首选。对于性能要求不太高，或者以动态类型语言为主，或者传输数据载荷很小的的运用场景，JSON也是非常不错的选择。
3、对于调试环境比较恶劣的场景，采用JSON或XML能够极大的提高调试效率，降低系统开发成本。
4、当对性能和简洁性有极高要求的场景，Protobuf，Thrift，Avro之间具有一定的竞争关系。
5、对于T级别的数据的持久化应用场景，Protobuf和Avro是首要选择。如果持久化后的数据存储在Hadoop子项目里，Avro会是更好的选择。
6、由于Avro的设计理念偏向于动态类型语言，对于动态语言为主的应用场景，Avro是更好的选择。
7、对于持久层非Hadoop项目，以静态类型语言为主的应用场景，Protobuf会更符合静态类型语言工程师的开发习惯。
8、如果需要提供一个完整的RPC解决方案，Thrift是一个好的选择。
9、如果序列化之后需要支持不同的传输层协议，或者需要跨防火墙访问的高性能场景，Protobuf可以优先考虑。
</code></pre>

<!--more-->

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[站在AFN上看ASI]]></title>
    <link href="http://al1020119.github.io/blog/2015/01/05/zhan-zai-afnshang-kan-asi/"/>
    <updated>2015-01-05T14:53:45+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/01/05/zhan-zai-afnshang-kan-asi</id>
    <content type="html"><![CDATA[<h6>一、底层实现</h6>

<ul>
<li><p>1> AFN的底层基于OC的NSURLConnection和NSURLSession</p></li>
<li><p>2> ASI的底层基于纯C语言的CFNetwork框架</p></li>
<li><p>3> ASI的运行性能 高于 AFN</p></li>
</ul>


<!--more-->


<h6>二、对服务器返回的数据处理</h6>

<ul>
<li><p>1> ASI没有直接提供对服务器数据处理的方式，直接返回data\string</p></li>
<li><p>2> AFN提供了多种对服务器数据处理的方式</p>

<ul>
<li><p>JSON处理</p></li>
<li><p>XML处理</p></li>
<li><p>其他处理</p></li>
</ul>
</li>
</ul>


<h6>三、监听请求的过程</h6>

<ul>
<li><p>1> AFN提供了success和failure两个block来监听请求的过程（只能监听成功和失败）</p>

<ul>
<li><p>success : 请求成功后调用</p></li>
<li><p>failure : 请求失败后调用</p></li>
</ul>
</li>
<li><p>2> ASI提供了3套方案，每一套方案都能监听请求的完整过程</p></li>
</ul>


<p>（监听请求开始、接收到响应头信息、接受到具体数据、接受完毕、请求失败）</p>

<pre><code>* 成为代理，遵守协议，实现协议中的代理方法

* 成为代理，不遵守协议，自定义代理方法

* 设置block
</code></pre>

<h6>四、在文件下载和文件上传的使用难易度</h6>

<ul>
<li><p>1> AFN</p>

<ul>
<li><p>不容易监听下载进度和上传进度</p></li>
<li><p>不容易实现断点续传</p></li>
<li><p>一般只用来下载不大的文件</p></li>
</ul>
</li>
<li><p>2> ASI</p>

<ul>
<li><p>非常容易实现下载和上传</p></li>
<li><p>非常容易监听下载进度和上传进度</p></li>
<li><p>非常容易实现断点续传</p></li>
<li><p>下载或大或小的文件都行</p></li>
</ul>
</li>
</ul>


<h6>五、ASI提供了更多的实用功能</h6>

<ul>
<li><p>1> 控制圈圈要不要在请求过程中转</p></li>
<li><p>2> 可以轻松地设置请求之间的依赖：每一个请求都是一个NSOperation对象</p></li>
<li><p>3> 可以统一管理所有请求（还专门提供了一个叫做ASINetworkQueue来管理所有的请求对象）</p>

<ul>
<li><p>暂停\恢复\取消所有的请求</p></li>
<li><p>监听整个队列中所有请求的下载进度和上传进度</p></li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UIView&CALayer是撒？]]></title>
    <link href="http://al1020119.github.io/blog/2014/08/15/uiview%20calayer/"/>
    <updated>2014-08-15T13:53:19+08:00</updated>
    <id>http://al1020119.github.io/blog/2014/08/15/uiview calayer</id>
    <content type="html"><![CDATA[<p>UIView与CALayer详解</p>

<p>研究Core Animation已经有段时间了，关于Core Animation，网上没什么好的介绍。苹果网站上有篇专门的总结性介绍，但是似乎原理性的东西不多，看得人云山雾罩，感觉，写那篇东西的人，其实是假 设读的人了解界面动画技术的原理的。今天有点别的事情要使用Linux，忘掉了ssh的密码，没办法重新设ssh，结果怎么也想不起来怎么设ssh远程登 陆了，没办法又到网上查了一遍，太浪费时间了，痛感忘记记笔记是多么可怕的事情。鉴于Core Animation的内容实在是非常繁杂，应用的Obj-C语言本身的特性也很多，所以写个备忘录记录一下，懂的人看了后如果发现了错误，还不吝指教。</p>

<!--more-->


<ul>
<li>1.UIView 是iOS系统中界面元素的基础，所有的界面元素都继承自它。它本身完全是由CoreAnimation来实现的（Mac下似乎不是这样）。它真正的绘图部 分，是由一个叫CALayer（Core Animation Layer）的类来管理。UIView本身，更像是一个CALayer的管理器，访问它的跟绘图和跟坐标有关的属性，例如frame，bounds等等， 实际上内部都是在访问它所包含的CALayer的相关属性。</li>
</ul>


<p>2.UIView有个layer属性，可以返回它的主CALayer实例，UIView有一个layerClass方法，返回主layer所使用的类，UIView的子类，可以通过重载这个方法，来让UIView使用不同的CALayer来显示，例如通过</p>

<pre><code>- (class) layerClass {

  return ([CAEAGLLayer class]);

}
</code></pre>

<p>使某个UIView的子类使用GL来进行绘制。</p>

<ul>
<li>3.UIView的CALayer类似UIView的子View树形结构，也可以向它的layer上添加子layer，来完成某些特殊的表示。</li>
</ul>


<p>例如下面的代码</p>

<pre><code>grayCover = [[CALayer alloc] init];

grayCover.backgroundColor = [[[UIColor blackColor] colorWithAlphaComponent:0.2] CGColor];

[self.layer addSubLayer: grayCover];
</code></pre>

<p>会在目标View上敷上一层黑色的透明薄膜。</p>

<ul>
<li>4.UIView的layer树形在系统内部，被系统维护着三份copy（这段理解有点吃不准）。</li>
</ul>


<p>例如：</p>

<pre><code>第一份，逻辑树，就是代码里可以操纵的，例如更改layer的属性等等就在这一份。
第二份，动画树，这是一个中间层，系统正在这一层上更改属性，进行各种渲染操作。
第三份，显示树，这棵树的内容是当前正被显示在屏幕上的内容。
这三棵树的逻辑结构都是一样的，区别只有各自的属性。
</code></pre>

<ul>
<li><p>5.动画的运作
UIView 的主layer以外（我觉得是这样），对它的subLayer，也就是子layer的属性进行更改，系统将自动进行动画生成，动画持续时间有个缺省时间， 个人感觉大概是0.5秒。在动画时间里，系统自动判定哪些属性更改了，自动对更改的属性进行动画插值，生成中间帧然后连续显示产生动画效果。</p></li>
<li><p>6.坐标系系统（对position和anchorPoint的关系还是犯晕）
CALayer 的坐标系系统和UIView有点不一样，它多了一个叫anchorPoint的属性，它使用CGPoint结构，但是值域是0~1，也就是按照比例来设 置。这个点是各种图形变换的坐标原点，同时会更改layer的position的位置，它的缺省值是{0.5, 0.5}，也就是在layer的中央。
某layer.anchorPoint = CGPointMake(0.f, 0.f);
如果这么设置，layer的左上角就会被挪到原来的中间的位置，
加上这样一句就好了
某layer.position = CGPointMake(0.f, 0.f);</p></li>
<li><p>7.真实例子的分析</p></li>
</ul>


<p>这 是iphone上iBook翻页的效果，假设每一页都是一个UIView，我觉得一个页面是贴了俩个Layer，文字Layer显示正面的内容，背面 layer用文字layer的快照做affine翻转，贴在文字layer的后面。因为Layer可以设置显示阴影，也许后面的阴影效果没有使用单独的一 个layer来显示。至于这个曲面效果，我查了很多资料也没有结果，估计是使用了GL的曲面绘图？</p>

<ul>
<li>8.最后一个让人恶心的。
layer 可以设置圆角显示，例如UIButton的效果，也可以设置阴影显示，但是如果layer树中的某个layer设置了圆角，树中所有layer的阴影效果 都将显示不了了。如果既想有圆角又想要阴影，好像只能做两个重叠的UIView，一个的layer显示圆角，一个的layer显示阴影&hellip;..</li>
</ul>


<p>CALayer属于Core Animation部分的内容，比较重要而不太好理解。以下是园子中看到的一篇文章的摘录：</p>

<ol>
<li><p>UIView是iOS系统中界面元素的基础，所有的界面元素都是继承自它。它本身完全是由CoreAnimation来实现的。它真正的绘图部分，是由一个CALayer类来管理。UIView本身更像是一个CALayer的管理器，访问它的跟绘图和跟坐标有关的属性，例如frame，bounds等，实际上内部都是在访问它所包含的CALayer的相关属性。</p></li>
<li><p>UIView有个重要属性layer，可以返回它的主CALayer实例。</p></li>
</ol>


<p>// 要访问层，读取UIView实例的layer属性</p>

<pre><code>CALayer *layer = myView.layer
</code></pre>

<p>所有从UIView继承来的对象都继承了这个属性。这意味着你可以转换、缩放、旋转，甚至可以在Navigation bars，Tables，Text boxes等其它的View类上增加动画。每个UIView都有一个层，控制着各自的内容最终被显示在屏幕上的方式。</p>

<p>UIView的layerClass方法，可以返回主layer所使用的类，UIView的子类可以通过重载这个方法，来让UIView使用不同的CALayer来显示。代码示例：</p>

<pre><code>- (class)layerClass {
   return ([CAEAGLLayer class]);

}
</code></pre>

<p>上述代码使得某个UIView的子类使用GL来进行绘制。</p>

<ol>
<li>UIView的CALayer类似UIView的子View树形结构，也可以向它的layer上添加子layer，来完成某些特殊的表示。即CALayer层是可以嵌套的。</li>
</ol>


<p>示例代码：</p>

<pre><code>grayCover = [[CALayer alloc] init];

grayCover.backgroundColor = [[UIColor blackColor] colorWithAlphaComponent:0.2] CGColor];
[self.layer addSubLayer:grayCover];
</code></pre>

<p>上述代码会在目标View上敷上一层黑色透明薄膜的效果。</p>

<ol>
<li><p>UIView的layer树形在系统内部，被维护着三份copy。分别是逻辑树，这里是代码可以操纵的；动画树，是一个中间层，系统就在这一层上更改属性，进行各种渲染操作；显示树，其内容就是当前正被显示在屏幕上得内容。</p></li>
<li><p>动画的运作：对UIView的subLayer（非主Layer）属性进行更改，系统将自动进行动画生成，动画持续时间的缺省值似乎是0.5秒。</p></li>
<li><p>坐标系统：CALayer的坐标系统比UIView多了一个anchorPoint属性，使用CGPoint结构表示，值域是0~1，是个比例值。这个点是各种图形变换的坐标原点，同时会更改layer的position的位置，它的缺省值是{0.5,0.5}，即在layer的中央。</p></li>
</ol>


<p>某layer.anchorPoint = CGPointMake(0.f,0.f);
如果这么设置，只会将layer的左上角被挪到原来的中间位置，必须加上这一句：
某layer.position = CGPointMake(0.f,0.f);
最后：layer可以设置圆角显示（cornerRadius），也可以设置阴影 (shadowColor)。但是如果layer树中某个 layer设置了圆角，树种所有layer的阴影效果都将不显示了。因此若是要有圆角又要阴影，变通方法只能做两个重叠的UIView，一个的layer 显示圆角，一个layer显示阴影&hellip;&hellip;</p>

<p>7.渲染：当更新层，改变不能立即显示在屏幕上。当所有的层都准备好时，可以调用setNeedsDisplay方法来重绘显示。</p>

<pre><code>[gameLayer setNeedsDisplay];
</code></pre>

<p>若要重绘部分屏幕区域，请使用setNeedsDisplayInRect:方法，通过在CGRect结构的区域更新：</p>

<pre><code>[gameLayer setNeedsDisplayInRect:CGRectMake(150.0,100.0,50.0,75.0)];
</code></pre>

<p>如果是用的Core Graphics框架来执行渲染的话，可以直接渲染Core Graphics的内容。用renderInContext:来做这个事。</p>

<pre><code>[gameLayer renderInContext:UIGraphicsGetCurrentContext()];
</code></pre>

<p>8.变换：要在一个层中添加一个3D或仿射变换，可以分别设置层的transform或affineTransform属性。</p>

<pre><code>1 characterView.layer.transform = CATransform3DMakeScale(-1.0,-1.0,1.0);
2 
3 CGAffineTransform transform = CGAffineTransformMakeRotation(45.0);
4 backgroundView.layer.affineTransform = transform;
</code></pre>

<p>9.变形：Quartz Core的渲染能力，使二维图像可以被自由操纵，就好像是三维的。图像可以在一个三维坐标系中以任意角度被旋转，缩放和倾斜。CATransform3D的一套方法提供了一些魔术般的变换效果。</p>
]]></content>
  </entry>
  
</feed>
