<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 高级开发 | iOS梦工厂]]></title>
  <link href="http://al1020119.github.io/blog/categories/gao-ji-kai-fa/atom.xml" rel="self"/>
  <link href="http://al1020119.github.io/"/>
  <updated>2015-12-08T01:15:10+08:00</updated>
  <id>http://al1020119.github.io/</id>
  <author>
    <name><![CDATA[iCocos]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[NSProxy&amp;NSObject初探]]></title>
    <link href="http://al1020119.github.io/blog/2015/12/13/nsproxy-and-nsobjectchu-tan/"/>
    <updated>2015-12-13T13:20:37+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/12/13/nsproxy-and-nsobjectchu-tan</id>
    <content type="html"><![CDATA[<p>NSObject类属于根类。根类在层级结构中处于最高级，也就是说除此以外没有更高层级。而且Objective-c中还有其他根类，不像Java里只有一个java.lang.Object根类，其他所有的类都直接或间接的继承于它。因此，</p>

<p>Java代码可以依据任何对象来实现它的基本方法。Cocoa有多个根类，除了NSObject还有NSProxy等其他等级的根类。这只是部分原因，NSObject协议定义了一套所有的根类都可以实现的基础方法，这样在编码时就容易找到了。</p>

<p>NSObject类遵循NSObject协议，这就是说，NSObject类实现了下面这些基础方法：</p>

<pre><code>@interface NSObject  
</code></pre>

<p>NSProxy同样遵循NSObject协议：</p>

<pre><code>@interface NSProxy      
</code></pre>

<!--more-->


<p>NSObject协议包含了hash，isEqual:，description等方法。事实上，NSProxy遵循NSObject协议意味着你可以依靠实现NSProxy来实现NSObject方法。</p>

<h3>NSObjetc：</h3>

<p>NSObject协议组对所有的Object－C下的objects都生效。
如果objects遵从该协议，就会被看作是first－class objects（一级类）。
另外，遵从该协议的objects的retain，release，autorelease等方法也服从objects的管理和在Foundation中定义的释放方法。一些容器中的对象也可以管理这些objects，比如
说NSArray 和NSDictionary定义的对象。
Cocoa的根类也遵循该协议，所以所有继承NSObjects的objects都有遵循该协议的特性。</p>

<h3>NSProXY：</h3>

<p>NSProxy 是一个虚基类，它为一些表现的像是其它对象替身或者并不存在的对象定义一套API。一般的，发送给代理的消息被转发给一个真实的对象或者代理本身load(或者将本身转换成)一个真实的对象。NSProxy的基类可以被用来透明的转发消息或者耗费巨大的对象的lazy 初始化。</p>

<p>NSProxy实现了包括NSObject协议在内基类所需的基础方法，但是作为一个虚拟的基类并没有提供初始化的方法。它接收到任何自己没有定义的方法他都会产生一个异常，所以一个实际的子类必须提供一个初始化方法或者创建方法，并且重载forwardInvocation:方法和methodSignatureForSelector:方法来处理自己没有实现的消息。一个子类的forwardInvocation:实现应该采取所有措施来处理invocation,比如转发网络消息，或者加载一个真实的对象，并把invocation转发给他。methodSignatureForSelector:需要为给定消息提供参数类型信息，子类的实现应该有能力决定他应该转发消息的参数类型，并构造相对应的NSMethodSignature对象。详细信息可以查看NSDistantObject, NSInvocation, and NSMethodSignature的类型说明。</p>

<h4>简单使用</h4>

<h6>NSProxy</h6>

<pre><code>// MyProxy.h
#import&lt;Foundation/Foundation.h&gt;

@interface MyProxy :NSProxy {
    NSObject *object;
}

- (id)transformToObject:(NSObject *)anObject;

@end

// MyProxy.m
#import"MyProxy.h"

@implementation MyProxy

- (void)dealloc
{
    [objectrelease];
    object = nil;
    [superdealloc];
}

- (void)fun
{
   // Do someting virtual
    //先做一些代理工作，然后创建一个后台线程，在后台线程中再调用真正的[object fun];
}

// Stupid transform implementation just by assigning a passed in object as transformation target. You can write your factory here and use passed in object as id for object that need ot be created.
- (id)transformToObject:(NSObject *)anObject 
{
    if(object != anObject) {
        [objectrelease];
    }
    object = [anObject retain];
    return object;
}

- (void)forwardInvocation:(NSInvocation *)invocation 
{
    if (object != nil) {
        [invocation setTarget:object];    

        [invocation invoke];
    }
}

- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel 
{
   NSMethodSignature *result;
    if (object != nil) {
        result = [objectmethodSignatureForSelector:sel];
    } else {
       // Will throw an exception as default implementation
        result = [supermethodSignatureForSelector:sel];
    }
    return result;
}

@end
</code></pre>

<hr />

<h6>NSObject</h6>

<pre><code>// RealSubject.h
#import&lt;Foundation/Foundation.h&gt;
@implementation RealSubject : NSObject

- (void)fun;

@end

// RealSubject.m
#import"RealSubject.h"

@implementation RealSubject

- (void)fun
{
    //这个方法需要代理进行惰性调用
   // Do something real
}

- (void)otherFun
{
    //这个方法不需要代理做任何处理，可直接被调用
   // Do something real
}

@end

// main.m
int main(int argc,char *argv[]) 
{
   NSAutoreleasePool * pool = [[NSAutoreleasePoolalloc] init];

    MyProxy *myProxy = [MyProxy alloc];
    RealSubject *realSub = [[RealSubject alloc] init];
    [myProxytransformToObject:realSub];
    [myProxyfun]; // 直接调用myProxy的fun，执行代理工作
    [myProxyotherFun]; // 依次调用myProxy的methodSignatureForSelector和forwardInvocation转发给realSub，realSub调用otherFun

    [realSubject release];
    [myProxyrelease];

    [pool release];
    return 0;
}
</code></pre>

<blockquote><p>注意，调用MyProxy中未定义的方法otherFun会出现'MyProxy' may not respond to &lsquo;fun'的警告，可通过使用私有范畴或通过performSelector:withObject:来避免，如果有更好的方法，请告知。</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[KeyChain初探]]></title>
    <link href="http://al1020119.github.io/blog/2015/12/12/keychainchu-tan/"/>
    <updated>2015-12-12T22:46:16+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/12/12/keychainchu-tan</id>
    <content type="html"><![CDATA[<p>iOS的keychain服务提供了一种安全的保存私密信息（密码，序列号，证书等）的方式，每个ios程序都有一个独立的keychain存储。相对于NSUserDefaults、文件保存等一般方式，keychain保存更为安全，而且keychain里保存的信息不会因App被删除而丢失，所以在重装App后，keychain里的数据还能使用。</p>

<blockquote><p>“yourAppID.com.yourCompany.whatever”就是你要起的公共区名称，除了whatever字段可以随便定之外，其他的都必须如实填写。这个文件的路径要配置在 Project->build setting->Code Signing Entitlements里，否则公共区无效，配置好后，须用你正式的证书签名编译才可通过，否则xcode会弹框告诉你code signing有问题。所以，苹果限制了你只能同公司的产品共享KeyChain数据，别的公司访问不了你公司产品的KeyChain。</p></blockquote>

<!--more-->


<h3>一.基本知识</h3>

<h6>1.方法</h6>

<ul>
<li>SecItemAdd 增</li>
<li>SecItemUpdate 改</li>
<li>SecItemDelete 删</li>
<li>SecItemCopyMatching 查</li>
</ul>


<h6>2.权限</h6>

<p>文档上说iOS的keyChain是一个相对独立的空间，当程序替换，删除时并不会删除keyChain的内容，这个要比Library/Cache好。刷机，恢复出厂应该就没有了。关于备份，只会备份数据，到那时不会备份设备的密钥，换句话说，即使拿到数据，也没有办法解密里面的内容。有人说似乎破解的手机就能破解keyChain,本人并不清楚，希望有大神能指教。但个人认为，keyChain只是沙盒的升级版，可以存放一些非私密的信息，即使破解也不影响其它用户，只影响那个破解了的设备。（比如针对该设备的一个密钥）。</p>

<p>可访问性一般来说，自己的程序只能访问自己的keychain,相同bundle的程序通过设置group可以互相共享同组的keychain，从而实现程序间可以共同访问一些数据。详细后面介绍一些我测试下来的经验。</p>

<h6>3.如何查询keyChain</h6>

<pre><code>[objc] view plaincopyprint?在CODE上查看代码片派生到我的代码片
genericPasswordQuery = [[NSMutableDictionary alloc] init];   
[genericPasswordQuery setObject:(id)kSecClassGenericPassword forKey:(id)kSecClass];//1  
[genericPasswordQuery setObject:identifier forKey:(id)kSecAttrGeneric];//2  
if (accessGroup != nil){  
    [genericPasswordQuery setObject:accessGroup forKey:(id)kSecAttrAccessGroup];//3  
}  
[genericPasswordQuery setObject:(id)kSecMatchLimitOne forKey:(id)kSecMatchLimit];//4  
[genericPasswordQuery setObject:(id)kCFBooleanTrue forKey:(id)kSecReturnAttributes];//5  
NSDictionary *tempQuery = [NSDictionary dictionaryWithDictionary:genericPasswordQuery];  
NSMutableDictionary *outDictionary = nil;      
if (SecItemCopyMatching((CFDictionaryRef)tempQuery, (CFTypeRef *)&amp;outDictionary) == noErr){//6  
//found and outDicitionary is not nil  
}else{  
//not found  
}  
</code></pre>

<ul>
<li>1.设置Class值，每个Class对应的都有不同的参数类型</li>
<li>2.用户确定的参数，一般是程序中使用的类别，比如说是"Password"或"Account Info"，作为search的主力条件</li>
<li>3.设置Group,如果不同程序都拥有这个组，那么不同程序间可以共享这个组的数据</li>
<li>4.只返回第一个匹配数据，查询方法使用，还有值kSecMatchLimitAll</li>
<li>5.返回数据为CFDicitionaryRef，查询方法使用</li>
<li>6.执行查询方法，判断返回值</li>
</ul>


<blockquote><p>eg:这个是none-ARC的代码哦！ARC情况下会有bridge提示。</p></blockquote>

<h6>4.类型转换</h6>

<p>介绍增删改方法调用前，先介绍转换方法，如何将NSDictionary转换成KeyChain方法可以设置的Dicitionary，一般在写程序过程中，应该尽量避免直接访问KeyChain，一般会创建一个NSDictionary来同步对应的数据，所以两者需要做转换。</p>

<pre><code>//data to secItem  
- (NSMutableDictionary *)dictionaryToSecItemFormat:(NSDictionary *)dictionaryToConvert  
{  
    // Create a dictionary to return populated with the attributes and data.  
    NSMutableDictionary *returnDictionary = [NSMutableDictionary dictionaryWithDictionary:dictionaryToConvert];  

    //设置kSecClass  
    [returnDictionary setObject:(id)kSecClassGenericPassword forKey:(id)kSecClass];  
    //将Dictionary里的kSecValueData(一般就是这个keyChain里主要内容，比如说是password),NSString转换成NSData  
    NSString *passwordString = [dictionaryToConvert objectForKey:(id)kSecValueData];  
    [returnDictionary setObject:[passwordString dataUsingEncoding:NSUTF8StringEncoding] forKey:(id)kSecValueData];  
    return returnDictionary;  
}  
//secItem to data  
- (NSMutableDictionary *)secItemFormatToDictionary:(NSDictionary *)dictionaryToConvert  
{  
    NSMutableDictionary *returnDictionary = [NSMutableDictionary dictionaryWithDictionary:dictionaryToConvert];  

    // Add the proper search key and class attribute.  
    [returnDictionary setObject:(id)kCFBooleanTrue forKey:(id)kSecReturnData];  
    [returnDictionary setObject:(id)kSecClassGenericPassword forKey:(id)kSecClass];  

    // Acquire the password data from the attributes.  
    NSData *passwordData = NULL;  
    if (SecItemCopyMatching((CFDictionaryRef)returnDictionary, (CFTypeRef *)&amp;passwordData) == noErr)  
    {  
        // 删除多余的kSecReturnData数据  
        [returnDictionary removeObjectForKey:(id)kSecReturnData];  

        // 对应前面的步骤，将数据从NSData转成NSString  
        NSString *password = [[[NSString alloc] initWithBytes:[passwordData bytes] length:[passwordData length]  
                                                     encoding:NSUTF8StringEncoding] autorelease];  
        [returnDictionary setObject:password forKey:(id)kSecValueData];  
    }  
    else  
    {  
        NSAssert(NO, @"Serious error, no matching item found in the keychain.\n");  
    }  
    [passwordData release];   
    return returnDictionary;  
}  
</code></pre>

<h6>5.增删改</h6>

<p>用代码来说明</p>

<pre><code>- (void)writeToKeychain  
{  
    NSDictionary *attributes = NULL;  
    NSMutableDictionary *updateItem = NULL;  
    OSStatus result;  
    //判断是增还是改  
    if (SecItemCopyMatching((CFDictionaryRef)genericPasswordQuery, (CFTypeRef *)&amp;attributes) == noErr)  
    {  
            // First we need the attributes from the Keychain.  
            updateItem = [NSMutableDictionary dictionaryWithDictionary:attributes];  
        // Second we need to add the appropriate search key/values.  
            [updateItem setObject:[genericPasswordQuery objectForKey:(id)kSecClass] forKey:(id)kSecClass];  
            // Lastly, we need to set up the updated attribute list being careful to remove the class.  
            NSMutableDictionary *tempCheck = [self dictionaryToSecItemFormat:keychainItemData];  
            //删除kSecClass update不能update该字段，否则会报错  
            [tempCheck removeObjectForKey:(id)kSecClass];  
        //参数1表示search的，参数2表示需要更新后的值  
            result = SecItemUpdate((CFDictionaryRef)updateItem, (CFDictionaryRef)tempCheck);  
    }else{  
            //增加  
            result = SecItemAdd((CFDictionaryRef)[self dictionaryToSecItemFormat:keychainItemData], NULL);  
    }  
}  
</code></pre>

<p>删除很简单，就不写注释了</p>

<pre><code>- (void)resetKeychainItem  
{  
    OSStatus junk = noErr;  
    if (!keychainItemData)  
    {  
        self.keychainItemData = [[NSMutableDictionary alloc] init];  
    }  
    else if (keychainItemData)  
    {  
        NSMutableDictionary *tempDictionary = [self dictionaryToSecItemFormat:keychainItemData];  
        junk = SecItemDelete((CFDictionaryRef)tempDictionary);  
        NSAssert( junk == noErr || junk == errSecItemNotFound, @"Problem deleting current dictionary." );  
    }  

    // Default attributes for keychain item.  
    [keychainItemData setObject:@"" forKey:(id)kSecAttrAccount];  
    [keychainItemData setObject:@"" forKey:(id)kSecAttrLabel];  
    [keychainItemData setObject:@"" forKey:(id)kSecAttrDescription];  

    // Default data for keychain item.  
    [keychainItemData setObject:@"" forKey:(id)kSecValueData];  
}  
</code></pre>

<p>二.Group的配置
配置Target的Code Signing Entitlements.</p>

<p><img src="/images/keyChain001.png" title="Caption" ></p>

<p>配置该文件</p>

<p><img src="/images/keyChain002.png" title="Caption" ></p>

<p><img src="/images/keyChain003.png" title="Caption" ></p>

<p>可以配置一个Array列表，表示该程序可以支持多个group
这样就可以在创建secItem时候添加kSecAttrAccessGroup了。
经过测试有以下经验同大家分享：</p>

<ul>
<li><p>1.相同bundle下生成的程序都可以共享相同group的keyChain.
相同bundle解释下就是：比如:2个程序分别使用的provision对应bundle是com.jv.key1和com.jv.key2，那你配置文件肯定是{Identifer}.com.jv.{name},其中identifer是苹果生成的随机串号，可以在申请证书时看到，复制过来即可，name可以自己取，程序中指定属于哪个Group即可。</p></li>
<li><p>2.如果你在 addkey时，没有指定group,则会默认添加你keychain-access-groups里第一个group，如果你没有设置Entitlements,则默认使用对应的程序的bundle name,比如com.jv.key1,表示只能给自己程序使用。</p></li>
<li><p>3.如果你程序添加的group并不存在你的配置文件中，程序会奔溃，表示无法添加。因此你只能添加你配置文件中支持的keychain。</p></li>
</ul>


<p>三、保存私密信息（工具）
在应用里使用使用keyChain，我们需要导入Security.framework ，keychain的操作接口声明在头文件SecItem.h里。直接使用SecItem.h里方法操作keychain，需要写的代码较为复杂，为减轻咱们程序员的开发，我们可以使用一些已经封装好了的工具类，下面我会简单介绍下我用过的两个工具类：KeychainItemWrapper和SFHFKeychainUtils。</p>

<p>（一）KeychainItemWrapper是apple官方例子“GenericKeychain”里一个访问keychain常用操作的封装类，在官网上下载了GenericKeychain项目后，只需要
把“KeychainItemWrapper.h”和“KeychainItemWrapper.m”拷贝到我们项目，并导入Security.framework 。KeychainItemWrapper的用法：</p>

<pre><code>/** 初始化一个保存用户帐号的KeychainItemWrapper */
KeychainItemWrapper *wrapper = [[KeychainItemWrapper alloc] initWithIdentifier:@"Account Number"
                                                                   accessGroup:@"YOUR_APP_ID_HERE.com.yourcompany.AppIdentifier"];  

//保存帐号
[
wrapper setObject:@"&lt;帐号&gt;" forKey:(id)kSecAttrAccount];    

//保存密码
[
wrapper setObject:@"&lt;帐号密码&gt;" forKey:(id)kSecValueData];    

//从keychain里取出帐号密码
NSString *password = [wrapper objectForKey:(id)kSecValueData];      

//清空设置
[
wrapper resetKeychainItem];
</code></pre>

<p>其中方法“- (void)setObject:(id)inObject forKey:(id)key;”里参数“forKey”的值应该是Security.framework 里头文件“SecItem.h”里定义好的key，用其他字符串做key程序会崩溃！</p>

<p>（二）SFHFKeychainUtils 提供了在 iOS keychain中安全的存储密码的工具</p>

<p>下载地址<a href="https://github.com/ldandersen/scifihifi-iphone/tree/master/security">https://github.com/ldandersen/scifihifi-iphone/tree/master/security</a></p>

<ul>
<li><p>1、引入Security.frameWork框架。</p></li>
<li><p>2、引入头文件：SFHKeychainUtils.h.</p></li>
<li><p>3、存密码：</p></li>
</ul>


<hr />

<pre><code>[SFHFKeychainUtils storeUsername:@"dd" andPassword:@"aa"forServiceName:SERVICE_NAME updateExisting:1 error:nil];

[SFHFKeychainUtils deleteItemForUsername:@"dd" andServiceName:SERVICE_NAME error:nil];
</code></pre>

<ul>
<li>4、取密码：</li>
</ul>


<hr />

<pre><code>NSString *passWord =  [SFHFKeychainUtils getPasswordForUsername:@"dd"andServiceName:SERVICE_NAME error:nil];
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Core Image 初探]]></title>
    <link href="http://al1020119.github.io/blog/2015/12/10/core-image-chu-tan/"/>
    <updated>2015-12-10T10:09:37+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/12/10/core-image-chu-tan</id>
    <content type="html"><![CDATA[<blockquote><p>前言：
Core Image 是 IOS 的图片处理框架，有使用方便、易于管理，性能优异的特点。</p>

<ul>
<li>用途

<ul>
<li>在照片、视频处理，把滤镜作为最后一步，添加水印</li>
<li>给照相机提供实时效果</li>
<li>面部检测，自动滤镜增益,图片分析算法</li>
<li>更多</li>
</ul>
</li>
</ul>
</blockquote>

<!--more-->


<h2>coreimage framework 组成</h2>

<p>apple 已经帮我们把image的处理分类好，来看看它的结构：</p>

<p><img src="/images/coreimage001.png" title="Caption" ></p>

<p>主要分为三部分：</p>

<h5>定义部分：</h5>

<p> CoreImage 何CoreImageDefines。见名思义，代表了CoreImage 这个框架和它的定义。</p>

<h5>操作部分：</h5>

<pre><code>滤镜（CIFliter）：CIFilter 产生一个CIImage。典型的，接受一到多的图片作为输入，经过一些过滤操作，产生指定输出的图片。

检测（CIDetector）：CIDetector 检测处理图片的特性，如使用来检测图片中人脸的眼睛、嘴巴、等等。

特征（CIFeature）：CIFeature 代表由 detector处理后产生的特征。
</code></pre>

<h5>图像部分：</h5>

<pre><code>画布（CIContext）：画布类可被用与处理Quartz 2D 或者 OpenGL。可以用它来关联CoreImage类。如滤镜、颜色等渲染处理。

颜色（CIColor）：   图片的关联与画布、图片像素颜色的处理。

向量（CIVector）： 图片的坐标向量等几何方法处理。

图片（CIImage）： 代表一个图像，可代表关联后输出的图像。　　
</code></pre>

<p><img src="/images/coreimage002.jpg" title="Caption" ></p>

<h2>2.  处理步骤：</h2>

<pre><code>  1）create a ciimage object;

  2) create a cifilter object and set input values

  3)  create a cicontext object.

  4) render the filter output image into a cgimage
</code></pre>

<p>　　　　</p>

<h2>3.注意</h2>

<p>　　　　a。关注Ciimage 产生的途径：</p>

<p>　　　　　　　　1）通过URL和Data</p>

<p>　　　　　　　　 2）通过其他图片类转换，CGImageRef或其他图片。</p>

<p>　　　　　　　　 3）通过CVpixelBufferRef。</p>

<p>　　　　　　　　 4）一组像素Data。</p>

<p>　　　　b.  图片颜色，KCCImageColorSpace 来重载默认颜色空间。</p>

<p>　　　　c. 图片Metadata。</p>

<p>　　　　</p>

<h2>4. 使用滤镜。</h2>

<p>　　　　CISepiaTone、CiColorControls、CIHueBlendMode。</p>

<p><img src="/images/coreimage003.png" title="Caption" ></p>

<p>处理过程：多个CImage输入 －－ 》 CIHeBlendMode  －－》 CiSepiatone。</p>

<p><img src="/images/coreimage004.jpg" title="Caption" ></p>

<p>渲染输出：</p>

<p><img src="/images/coreimage005.jpg" title="Caption" ></p>

<p>流程： 获取context  －》 转成CIimage －》 渲染成CGImageRef  －》 转换为UIimage －》 释放 CGImageRef －》 使用UIImage。</p>

<h2>5.脸部检测</h2>

<p>　　自动增强： CIRedEyeCorrection  、CIFaceBalance（调整图片来给出更好的皮肤色调）、CIVibrance（在不扭曲皮肤色调的情况下，增加饱和度）、CIToneCurve（调整图片对比）、高亮阴影调整。
　　
　　</p>

<hr />

<p>&mdash;-基本使用&mdash;-</p>

<hr />

<h5>Core Image 处理图片的工作流程</h5>

<ul>
<li>创建新的CIImage</li>
<li>创建新的CIFilter，通过键-值编码设置输入值，一定要给inputImage加入一个值，这个属性是图像数据源</li>
<li>从CIFilter中生成输出图片。通过访问CIFilter的outputImage属性，可以得到输出图像，这是一个新的CIImage对象，包含了原始图片的数据以及一个滤镜链。 在得到输出图像后，可以使用滤镜来渲染出最终的效果图像。也可以将其作为一个新滤镜的输入图像，这样会产生出一条滤镜链</li>
<li>用CIContext 渲染CIImage 对象，这个CIContext 可以是基于CPU的，输出为CGImageRef，通过 LibDispatch（GCD）渲染 ，更加可靠，也更加易用。也可以是基于GPU的，开发者可通过Open ES 2.0 画出来。使用GPU渲染时CPU没有负担，更好地性能，但无法在后台运行</li>
</ul>


<p>使用例子：</p>

<pre><code> CIImage *myCoreImage = [CIImage imageWithCGImage:self.myImageView.image.CGImage options:nil];  

// 创建Filter，@"CISepiaTone"这个名字是系统指定的  
CIFilter *sepia = [CIFilter filterWithName:@"CISepiaTone"];  

// 设置Filter  
[sepia setValue:myCoreImage forKey:@"inputImage"];  

NSNumber *intensity = [NSNumber numberWithFloat:.5f];  
[sepia setValue:intensity forKey:@"inputIntensity"];  

// 生成新的 CIImage  
CIImage *outputImage = [sepia outputImage];  

// 取出UIImage  
CGImageRef renderImage = [_imageContext createCGImage:outputImage fromRect:[outputImage extent]];  
[self.myImageView setImage:[UIImage imageWithCGImage:renderImage]];
</code></pre>

<blockquote><p>DemoCoreImage 是直接从IOS 核心框架拿过来的。
CoreImageMySelf 是我自己提取的只为实现优化功能的demo
提取的功能模块有，filter的使用、自动优化的使用、脸部检测</p></blockquote>

<p>再来看看常见的使用方式</p>

<ul>
<li>CIImage</li>
</ul>


<p>保存图像数据的类，可以通过UIImage，图像文件或者像素数据来创建，包括未处理的像素数据如：</p>

<pre><code>- imageWithCVPixelBuffer:

- imageWithData:
</code></pre>

<p>方法等等。</p>

<p>也可以通过图像数据类比如UIImage，CGImageRef等等。</p>

<ul>
<li>CIFilter</li>
</ul>


<p>滤镜类，这个框架中对图片属性进行细节处理的类。它对所有的像素进行操作，用一些键-值设置来决定具体操作的程度。</p>

<ul>
<li>CIContext</li>
</ul>


<p>上下文类，如CoreGraphics以及CoreData中的上下文用于处理绘制渲染以及处理托管对象一样，CoreImage的上下文也是实现对图像处理的具体对象。</p>

<p>这里需要注意的是在Context创建的时候，我们需要给它设定为是基于GPU还是CPU。(这里使用GPU)</p>

<blockquote><p>基于GPU的话，处理速度更快，因为利用了GPU硬件的并行优势。但是GPU受限于硬件纹理尺寸，而且如果你的程序在后台继续处理和保存图片的话，那么需要使用CPU，因为当app切换到后台状态时GPU处理会被打断。</p></blockquote>

<h3>使用步骤：</h3>

<h6>0.导入CIImage图片</h6>

<pre><code>CIImage *ciImage = [[CIImage alloc]initWithImage:[UIImage imageNamed:@"test.jpg"]];
</code></pre>

<h6>1.创建出Filter滤镜</h6>

<pre><code>CIFilter *filterOne = [CIFilter filterWithName:@"CIPixellate"];
[filterOne setValue:ciImage forKey:kCIInputImageKey];
[filterOne setDefaults];

CIImage *outImage = [filterOne valueForKey:kCIOutputImageKey];
</code></pre>

<h6>2.用CIContext将滤镜中的图片渲染出来</h6>

<pre><code>CIContext *context = [CIContext contextWithOptions:nil];

CGImageRef cgImage = [context createCGImage:outImage fromRect:[outImage extent]];
</code></pre>

<h6>3.导出图片</h6>

<pre><code>UIImage *showImage = [UIImage imageWithCGImage:cgImage];
CGImageRelease(cgImage);
</code></pre>

<h6>4.加载图片</h6>

<pre><code> _image.image = showImage;
</code></pre>

<hr />

<h3>如果要使用组合滤镜</h3>

<h6>在步骤1中设置组合滤镜，只需要将上一个滤镜的输出变为下一个滤镜的输入就行了</h6>

<pre><code>//第一个滤镜
CIFilter *filterOne = [CIFilter filterWithName:@"CIPixellate"];
[filterOne setValue:ciImage forKey:kCIInputImageKey];
[filterOne setDefaults];
CIImage *outImage = [filterOne valueForKey:kCIOutputImageKey];
//第二个滤镜
CIFilter *filterTwo = [CIFilter filterWithName:@"CIHueAdjust"];
[filterTwo setValue:outImage forKey:kCIInputImageKey];
[filterTwo setDefaults];
[filterTwo setValue:@(1.f) forKey:kCIInputAngleKey];
CIImage *outputImage = [filterTwo valueForKey:kCIOutputImageKey];
</code></pre>

<h6>记住渲染的时候，步骤2，要将最后输出的CIImage传入</h6>

<pre><code>CIContext *context = [CIContext contextWithOptions:nil];

CGImageRef cgImage = [context createCGImage:outputImage fromRect:[outImage extent]];
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iBeacon初探]]></title>
    <link href="http://al1020119.github.io/blog/2015/12/08/ibeaconchu-tan/"/>
    <updated>2015-12-08T17:42:15+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/12/08/ibeaconchu-tan</id>
    <content type="html"><![CDATA[<blockquote><p>iBeacon 是苹果公司在 iOS 7 中新推出的一种近场定位技术，可以感知一个附近的 iBeacon 信标的存在。
当一个 iBeacon 兼容设备进入/退出一个 iBeacon 信标标识的区域时，iOS 和支持 iBeacon 的 app 就能得知这一信息，从而对用户发出相应的通知。</p></blockquote>

<p>典型的应用场景例如博物馆实时推送附近展品的相关信息，商场内即时通知客户折扣信息
等。苹果在 Apple Store 中也部署了 iBeacon 来推送优惠、活动信息。</p>

<!--more-->


<h4>Apple Store 中的 iBeacon 支持</h4>

<h6>特点</h6>

<pre><code>iBeacon 基于低功耗蓝牙技术（Bluetooth Low Energy, BLE）这一开放标准，因此也继承了 BLE 的一些特点。
</code></pre>

<h6>范围广</h6>

<pre><code>相比于 NFC 的数厘米的识别范围，iBeacon 的识别范围可以达到数十米，并且能够估计距离的远近。
</code></pre>

<h6>兼容性</h6>

<pre><code>iBeacon 是基于 BLE 做的一个简单封装，因此大部分支持 BLE 的设备都可以兼容。
例如可以使用一个普通的蓝牙芯片作为信标，使用 Android 设备检测信标的存在。
</code></pre>

<h6>低能耗</h6>

<pre><code>不少 beacon 实现宣称可以不依赖外部能源独立运行两年。
</code></pre>

<h6>使用场景</h6>

<pre><code>我们以一个连锁商场的例子来讲解 iBeacon 的一个流程。在一个连锁商场中，店家需要在商场中的不同地方推送不同的优惠信息，比如服装和家居柜台推送的消息就很有可能不同。
</code></pre>

<p>当消费者走进某个商场时，会扫描到一个 beacon。这个 beacon 有三个标志符，proximityUUID 是一个整个公司（所有连锁商场）统一的值，可以用来标识这个公司，major 值用来标识特定的连锁商场，比如消费者正在走进的商场，minor 值标识了特定的一个位置的 beacon，例如定位到消费者正在门口。</p>

<p>这时商场的 app 会被系统唤醒，app 可以运行一个比较短的时间。在这段时间内，app 可以根据 beacon 的属性查询到用户的地理位置（通过查询服务器或者本地数据），例如在化妆品专柜，之后就可以通过一个 local notification 推送化妆品的促销信息。用户可以点击这次 local notification 来查看更详细的信息，这样一次促销行为就完成了。</p>

<h6>API</h6>

<pre><code>闲话少说，我们来看下 iBeacon 具体怎么使用：
</code></pre>

<h6>Beacon 的表示</h6>

<pre><code>iBeacon 本质上来说是一个位置（区域）信息，所以 Apple 把 iBeacon 功能集成在了 Core Location 里面。
</code></pre>

<p>iBeacon 信标在 Core Location 中表现为一个 CLBeacon，它圈定的范围则表现为 CLBeaconRegion，这是一个 CLRegion 的子类。</p>

<p>CLBeaconRegion 主要用三个属性来标识一个 iBeacon，proximityUUID、major 和 minor。
proximityUUID 是一个 NSUUID，用来标识公司，每个公司、组织使用的 iBeacon 应该拥有同样的 proximityUUID。
major 用来识别一组相关联的 beacon，例如在连锁超市的场景中，每个分店的 beacon 应该拥有同样的 major。
minor 则用来区分某个特定的 beacon。</p>

<pre><code>这些属性如果不指定（即 nil），匹配的时候就会忽略这个属性。例如只指定 proximityUUID 的 CLBeaconRegion 可以匹配某公司的所有 beacons。
</code></pre>

<h6>Monitoring</h6>

<pre><code>Apple 在 iOS 4 中增加了地理围栏 API，可以用来在设备进入/退出某个地理区域时获得通知，这些 API 包括 -startMonitoringForRegion:、-locationManager:didEnterRegion:、-locationManager:didExitRegion: 等。
</code></pre>

<p>CLBeaconRegion 作为 CLRegion 的子类也可以复用这些 API，这种检测 iBeacon 的方式叫做 monitoring。</p>

<p>使用这种方法可以在程序在后台运行时检测 iBeacon，但是只能同时检测 20 个 region，也不能推测设备与 beacon 的距离。</p>

<h6>Ranging</h6>

<pre><code>除了使用地理围栏 API 的方式，Apple 还在 iOS 7 中新增加了 iBeacon 专用的检测方式，也就是 ranging。
</code></pre>

<p>通过 CLLocationManager 的 -startRangingBeaconsInRegion: 方法可以开始检测特定的 iBeacon。</p>

<p>当检测到 beacon 的时候，CLLocationManager 的 delegate 方法 -locationManager:didRangeBeacons:inRegion: 会被调用，通知调用者现在被检测到的 beacons。
这个方法会返回一个 CLBeacon 的数组，根据 CLBeacon 的 proximity 属性就可以判断设备和 beacon 之间的距离。</p>

<blockquote><p>proximity 属性有四个可能的值，unknown、immediate、near 和 far。
另外 CLBeacon 还有 accuracy 和 rssi 两个属性能提供更详细的距离数据。</p></blockquote>

<h6>使用 iOS 设备作为 iBeacon</h6>

<p>我们可以使用 Core Bluetooth 框架来广播特定的 payload 来让 iOS 设备成为一个 iBeacon。
这个 payload 可以由 CLBeaconRegion 的 -peripheralDataWithMeasuredPower: 方法来获取。
之后交给 CBPeripheralManager 广播出去就可以了。</p>

<p>需要注意的是，广播 iBeacon 信息的时候 app 必须在前台运行。</p>

<h6>行为</h6>

<p>iBeacon 的 API 并不十分复杂，但他的行为比较难弄清楚，特别是当应用运行在后台时，检测到 beacon 的时间延迟会让开发者难以推测。在做了一些实验和合理的推测后，我们得出了一些</p>

<blockquote><p>结论：
检测到 beacon 的时间跟设备进行蓝牙扫描的时间间隔有关，每当设备进行扫描的时候，就能发现 iBeacon region 的变化。
在 ranging 打开的情况下，设备会每秒钟做一次扫描，也就是说状态更新最多延迟一秒。
程序在后台运行，并且 monitoring 打开的时候，设备可能每隔数分钟做一次扫描。iOS 7 的响应速度较慢，iOS 7.1 有比较大的改善。
如果存在设置 notifyEntryStateOnDisplay=YES 的 beacon，iOS 会在屏幕点亮的时候（锁屏状态下按下 home 键，或者因为收到推送点亮等）进行一次扫描。
设备重启并不影响 iBeacon 后台检测的执行。
iOS 7 中，在多任务界面中杀掉程序会终止 iBeacon 检测的执行，iOS 7.1 上改变了这一行为，被杀掉的 app 还可以继续进行 iBeacon 检测。</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OpenEL GS初探]]></title>
    <link href="http://al1020119.github.io/blog/2015/12/07/openel-gschu-tan/"/>
    <updated>2015-12-07T17:43:44+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/12/07/openel-gschu-tan</id>
    <content type="html"><![CDATA[<blockquote><p>写在前头，好久没有更新博客，感谢老朋友的再次来访，同时也欢迎新朋友~</p></blockquote>

<p>说起OpenGL，相信大不多数朋友都不会陌生，或多或少都有接触。本文不属于OpenGL提高篇，主要目的在于帮助新手更快熟悉iOS中如何使用OpenGL，关于这方面的介绍，网上也有很多，本文主要任务在于整理，介绍稍有偏重。这里有比较完整的Demo，可以协助大家更快上手</p>

<!--more-->


<p>OpenGL版本</p>

<p>iOS系统默认支持OpenGl ES1.0、ES2.0以及ES3.0 3个版本，三者之间并不是简单的版本升级，设计理念甚至完全不同，在开发OpenGL项目前，需要根据业务需求选择合适的版本。这方面的介绍不少，不再展开。在学习OpenGL代码的时候也需要知道它对应着哪个版本，在ES1中执行ES2代码是看不到任何效果的，你可以在初始化EAGLContext时指定ES版本号</p>

<pre><code>EAGLContext *context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES1];
</code></pre>

<p>OpenGL坐标系</p>

<p>OpenGL坐标系不同于UIKit坐标系，其实它是这样的</p>

<p><img src="/images/openEL001.png" title="Caption" ></p>

<p>除了方向，还有一点需要注意，默认情况各个方向坐标值范围为（-1，1），而不是UIKit中的（0，320）。当绘制点(320，0)，它并不会出现在屏幕右上角。在ES1中，可以通过以下代码将坐标系转化为熟悉的（320，480）</p>

<pre><code>- (void)glkView:(GLKView *)view drawInRect:(CGRect)rect {
    glViewport(0, 0, rect.size.width * 2, rect.size.height * 2);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glOrthof(0, 320, 0, 480, -1024, 1024);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
}
</code></pre>

<p>接下来说说iOS中如何使用OpenGL</p>

<pre><code>GLKViewController &amp; GLKView
</code></pre>

<p>机智的码农是不是已经发现这两个对象， 为了方便大家更快的开发，系统为OpenGL提供了简单的封装，继承GLKViewController定义自己的ViewController，GLKViewController的view为GLKView类，GLKView的delegate定义了绘制回调函数</p>

<pre><code>- (void)glkView:(GLKView *)view drawInRect:(CGRect)rect
</code></pre>

<p>GLKViewController定义数据刷新函数，当子类实现-(void)update方法，glkViewControllerUpdate方法将不再被调用</p>

<pre><code>- (void)glkViewControllerUpdate:(GLKViewController *)controller
</code></pre>

<p>HJGLKViewControllerDemo模拟了GLKViewController方法实现，有兴趣的童鞋可以查看GLKViewController内部实现机制。需要补充一点，默认情况下，GLKViewController渲染RunLoop并非NSRunLoopCommonModes，而是NSDefaultRunLoopMode，因此在UIKit中使用GLKViewController，当滑动界面时，OpenGL是不会渲染的，为了解决这个问题，可以使用HJGLKViewController替换GLKViewController，HJGLKViewController中默认渲染RunLoop使用NSRunLoopCommonModes模式</p>

<h3>EAGLContext</h3>

<p>在介绍选择版本时已经提到EAGLContext，与UIKit中CGContextRef相似，EAGLContext相当于OpenGL绘制句柄或者上下文，在绘制试图之前，需要指定使用创建的上下文绘制</p>

<p>[EAGLContext setCurrentContext:view.context];
当一个APP可能存在多个EAGLContext时，需要处理并存冲突等问题，比如大家所熟知的GPUImage，都会使用到EAGLContext。因此，在使用中要记得及时释放。有兴趣的朋友可以看看这篇文章</p>

<h3>Draw</h3>

<p>OpenGL绘制本文就不做介绍，HJGLKViewControllerDemo中有大量的示例，顺便推荐几篇相关文章</p>

<p>详解第一个OpenGL程序
西蒙iPhone-OpenGL ES 中文教程专题
Cocos2d源码
小贴士：当App退到后台时， 切记暂停OpenGL绘制，否则可能导致crash</p>
]]></content>
  </entry>
  
</feed>
