<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 高级开发 | iOS梦工厂]]></title>
  <link href="http://al1020119.github.io/blog/categories/gao-ji-kai-fa/atom.xml" rel="self"/>
  <link href="http://al1020119.github.io/"/>
  <updated>2015-12-03T11:59:13+08:00</updated>
  <id>http://al1020119.github.io/</id>
  <author>
    <name><![CDATA[iCocos]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[序列化&amp;反序列化深究]]></title>
    <link href="http://al1020119.github.io/blog/2015/12/04/xu-lie-hua-and-fan-xu-lie-hua-shen-jiu/"/>
    <updated>2015-12-04T09:36:37+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/12/04/xu-lie-hua-and-fan-xu-lie-hua-shen-jiu</id>
    <content type="html"><![CDATA[<blockquote><p>摘要
序列化和反序列化几乎是工程师们每天都要面对的事情，但是要精确掌握这两个概念并不容易：一方面，它们往往作为框架的一部分出现而湮没在框架之中；另一方面，它们会以其他更容易理解的概念出现，例如加密、持久化。然而，序列化和反序列化的选型却是系统设计或重构一个重要的环节，在分布式、大数据量系统设计里面更为显著。恰当的序列化协议不仅可以提高系统的通用性、强健性、安全性、优化系统性能，而且会让系统更加易于调试、便于扩展。本文从多个角度去分析和讲解“序列化和反序列化”，并对比了当前流行的几种序列化协议，期望对读者做序列化选型有所帮助。</p></blockquote>

<!--more-->


<h2>简介</h2>

<p>文章作者服务于美团推荐与个性化组，该组致力于为美团用户提供每天billion级别的高质量个性化推荐以及排序服务。从Terabyte级别的用户行为数据，到Gigabyte级别的Deal/Poi数据；从对实时性要求毫秒以内的用户实时地理位置数据，到定期后台job数据，推荐与重排序系统需要多种类型的数据服务。推荐与重排序系统客户包括各种内部服务、美团客户端、美团网站。为了提供高质量的数据服务，为了实现与上下游各系统进行良好的对接，序列化和反序列化的选型往往是我们做系统设计的一个重要考虑因素。</p>

<p>本文内容按如下方式组织：</p>

<ul>
<li>第一部分给出了序列化和反序列化的定义，以及其在通讯协议中所处的位置。</li>
<li>第二部分从使用者的角度探讨了序列化协议的一些特性。</li>
<li>第三部分描述在具体的实施过程中典型的序列化组件，并与数据库组建进行了类比。</li>
<li>第四部分分别讲解了目前常见的几种序列化协议的特性，应用场景，并对相关组件进行举例。</li>
<li>最后一部分，基于各种协议的特性，以及相关benchmark数据，给出了作者的技术选型建议。</li>
</ul>


<h4>一、定义以及相关概念</h4>

<p>互联网的产生带来了机器间通讯的需求，而互联通讯的双方需要采用约定的协议，序列化和反序列化属于通讯协议的一部分。通讯协议往往采用分层模型，不同模型每层的功能定义以及颗粒度不同，例如：TCP/IP协议是一个四层协议，而OSI模型却是七层协议模型。在OSI七层协议模型中展现层（Presentation Layer）的主要功能是把应用层的对象转换成一段连续的二进制串，或者反过来，把二进制串转换成应用层的对象&ndash;这两个功能就是序列化和反序列化。一般而言，TCP/IP协议的应用层对应与OSI七层协议模型的应用层，展示层和会话层，所以序列化协议属于TCP/IP协议应用层的一部分。本文对序列化协议的讲解主要基于OSI七层协议模型。</p>

<ul>
<li>序列化： 将数据结构或对象转换成二进制串的过程</li>
<li>反序列化：将在序列化过程中所生成的二进制串转换成数据结构或者对象的过程</li>
</ul>


<p>数据结构、对象与二进制串
不同的计算机语言中，数据结构，对象以及二进制串的表示方式并不相同。</p>

<p>数据结构和对象：对于类似Java这种完全面向对象的语言，工程师所操作的一切都是对象（Object），来自于类的实例化。在Java语言中最接近数据结构的概念，就是POJO（Plain Old Java Object）或者Javabean－－那些只有setter/getter方法的类。而在C++这种半面向对象的语言中，数据结构和struct对应，对象和class对应。</p>

<p>二进制串：序列化所生成的二进制串指的是存储在内存中的一块数据。C++语言具有内存操作符，所以二进制串的概念容易理解，例如，C++语言的字符串可以直接被传输层使用，因为其本质上就是以'\0'结尾的存储在内存中的二进制串。在Java语言里面，二进制串的概念容易和String混淆。实际上String 是Java的一等公民，是一种特殊对象（Object）。对于跨语言间的通讯，序列化后的数据当然不能是某种语言的特殊数据类型。二进制串在Java里面所指的是byte[]，byte是Java的8中原生数据类型之一（Primitive data types）。</p>

<h4>二、序列化协议特性</h4>

<p>每种序列化协议都有优点和缺点，它们在设计之初有自己独特的应用场景。在系统设计的过程中，需要考虑序列化需求的方方面面，综合对比各种序列化协议的特性，最终给出一个折衷的方案。</p>

<h6>通用性有两个层面的意义：</h6>

<ul>
<li>第一、技术层面，序列化协议是否支持跨平台、跨语言。如果不支持，在技术层面上的通用性就大大降低了。</li>
<li>第二、流行程度，序列化和反序列化需要多方参与，很少人使用的协议往往意味着昂贵的学习成本；另一方面，流行度低的协议，往往缺乏稳定而成熟的跨语言、跨平台的公共包。</li>
</ul>


<p>强健性/鲁棒性
以下两个方面的原因会导致协议不够强健：</p>

<ul>
<li>第一、成熟度不够，一个协议从制定到实施，到最后成熟往往是一个漫长的阶段。协议的强健性依赖于大量而全面的测试，对于致力于提供高质量服务的系统，采用处于测试阶段的序列化协议会带来很高的风险。</li>
<li>第二、语言/平台的不公平性。为了支持跨语言、跨平台的功能，序列化协议的制定者需要做大量的工作；但是，当所支持的语言或者平台之间存在难以调和的特性的时候，协议制定者需要做一个艰难的决定&ndash;支持更多人使用的语言/平台，亦或支持更多的语言/平台而放弃某个特性。当协议的制定者决定为某种语言或平台提供更多支持的时候，对于使用者而言，协议的强健性就被牺牲了。</li>
</ul>


<p>可调试性/可读性
序列化和反序列化的数据正确性和业务正确性的调试往往需要很长的时间，良好的调试机制会大大提高开发效率。序列化后的二进制串往往不具备人眼可读性，为了验证序列化结果的正确性，写入方不得同时撰写反序列化程序，或提供一个查询平台&ndash;这比较费时；另一方面，如果读取方未能成功实现反序列化，这将给问题查找带来了很大的挑战&ndash;难以定位是由于自身的反序列化程序的bug所导致还是由于写入方序列化后的错误数据所导致。对于跨公司间的调试，由于以下原因，问题会显得更严重：</p>

<ul>
<li>第一、支持不到位，跨公司调试在问题出现后可能得不到及时的支持，这大大延长了调试周期。</li>
<li>第二、访问限制，调试阶段的查询平台未必对外公开，这增加了读取方的验证难度。</li>
</ul>


<p>如果序列化后的数据人眼可读，这将大大提高调试效率， XML和JSON就具有人眼可读的优点。</p>

<h6>性能包括两个方面，时间复杂度和空间复杂度：</h6>

<ul>
<li>第一、空间开销（Verbosity）， 序列化需要在原有的数据上加上描述字段，以为反序列化解析之用。如果序列化过程引入的额外开销过高，可能会导致过大的网络，磁盘等各方面的压力。对于海量分布式存储系统，数据量往往以TB为单位，巨大的的额外空间开销意味着高昂的成本。</li>
<li>第二、时间开销（Complexity），复杂的序列化协议会导致较长的解析时间，这可能会使得序列化和反序列化阶段成为整个系统的瓶颈。</li>
</ul>


<p>可扩展性/兼容性
移动互联时代，业务系统需求的更新周期变得更快，新的需求不断涌现，而老的系统还是需要继续维护。如果序列化协议具有良好的可扩展性，支持自动增加新的业务字段，而不影响老的服务，这将大大提供系统的灵活度。</p>

<p>安全性/访问限制
在序列化选型的过程中，安全性的考虑往往发生在跨局域网访问的场景。当通讯发生在公司之间或者跨机房的时候，出于安全的考虑，对于跨局域网的访问往往被限制为基于HTTP/HTTPS的80和443端口。如果使用的序列化协议没有兼容而成熟的HTTP传输层框架支持，可能会导致以下三种结果之一：</p>

<ul>
<li>第一、因为访问限制而降低服务可用性。</li>
<li>第二、被迫重新实现安全协议而导致实施成本大大提高。</li>
<li>第三、开放更多的防火墙端口和协议访问，而牺牲安全性。</li>
</ul>


<h4>三、序列化和反序列化的组件</h4>

<p>典型的序列化和反序列化过程往往需要如下组件：</p>

<ul>
<li>IDL（Interface description language）文件：参与通讯的各方需要对通讯的内容需要做相关的约定（Specifications）。为了建立一个与语言和平台无关的约定，这个约定需要采用与具体开发语言、平台无关的语言来进行描述。这种语言被称为接口描述语言（IDL），采用IDL撰写的协议约定称之为IDL文件。</li>
<li>IDL Compiler：IDL文件中约定的内容为了在各语言和平台可见，需要有一个编译器，将IDL文件转换成各语言对应的动态库。</li>
<li>Stub/Skeleton Lib：负责序列化和反序列化的工作代码。Stub是一段部署在分布式系统客户端的代码，一方面接收应用层的参数，并对其序列化后通过底层协议栈发送到服务端，另一方面接收服务端序列化后的结果数据，反序列化后交给客户端应用层；Skeleton部署在服务端，其功能与Stub相反，从传输层接收序列化参数，反序列化后交给服务端应用层，并将应用层的执行结果序列化后最终传送给客户端Stub。</li>
<li>Client/Server：指的是应用层程序代码，他们面对的是IDL所生存的特定语言的class或struct。
底层协议栈和互联网：序列化之后的数据通过底层的传输层、网络层、链路层以及物理层协议转换成数字信号在互联网中传递。
序列化组件</li>
</ul>


<p>序列化组件与数据库访问组件的对比
数据库访问对于很多工程师来说相对熟悉，所用到的组件也相对容易理解。下表类比了序列化过程中用到的部分组件和数据库访问组件的对应关系，以便于大家更好的把握序列化相关组件的概念。</p>

<table>
<thead>
<tr>
<th> 序列化组件         </th>
<th style="text-align:center;"> 数据库组件          </th>
<th style="text-align:right;"> 说明  </th>
</tr>
</thead>
<tbody>
<tr>
<td> IDL           </td>
<td style="text-align:center;">   DDL              </td>
<td style="text-align:right;"> 用于建表或者模型的语言</td>
</tr>
<tr>
<td> DL            </td>
<td style="text-align:center;"> file DB Schema    </td>
<td style="text-align:right;"> 表创建文件或模型文件</td>
</tr>
<tr>
<td> Stub/Skeleton </td>
<td style="text-align:center;">  lib  O/R mapping </td>
<td style="text-align:right;">   将class和Table或者数据模型进行映射</td>
</tr>
</tbody>
</table>


<h4>四、几种常见的序列化和反序列化协议</h4>

<p>互联网早期的序列化协议主要有COM和CORBA。</p>

<p>COM主要用于Windows平台，并没有真正实现跨平台，另外COM的序列化的原理利用了编译器中虚表，使得其学习成本巨大（想一下这个场景， 工程师需要是简单的序列化协议，但却要先掌握语言编译器）。由于序列化的数据与编译器紧耦合，扩展属性非常麻烦。</p>

<p>CORBA是早期比较好的实现了跨平台，跨语言的序列化协议。COBRA的主要问题是参与方过多带来的版本过多，版本之间兼容性较差，以及使用复杂晦涩。这些政治经济，技术实现以及早期设计不成熟的问题，最终导致COBRA的渐渐消亡。J2SE 1.3之后的版本提供了基于CORBA协议的RMI-IIOP技术，这使得Java开发者可以采用纯粹的Java语言进行CORBA的开发。</p>

<p>这里主要介绍和对比几种当下比较流行的序列化协议，包括XML、JSON、Protobuf、Thrift和Avro。</p>

<p>一个例子
如前所述，序列化和反序列化的出现往往晦涩而隐蔽，与其他概念之间往往相互包容。为了更好了让大家理解序列化和反序列化的相关概念在每种协议里面的具体实现，我们将一个例子穿插在各种序列化协议讲解中。在该例子中，我们希望将一个用户信息在多个系统里面进行传递；在应用层，如果采用Java语言，所面对的类对象如下所示：</p>

<pre><code>class Address
{
    private String city;
    private String postcode;
    private String street;
}
public class UserInfo
{
    private Integer userid;
    private String name;
    private List&lt;Address&gt; address;
}
</code></pre>

<h6>XML&amp;SOAP</h6>

<ul>
<li><p>XML是一种常用的序列化和反序列化协议，具有跨机器，跨语言等优点。 XML历史悠久，其1.0版本早在1998年就形成标准，并被广泛使用至今。XML的最初产生目标是对互联网文档（Document）进行标记，所以它的设计理念中就包含了对于人和机器都具备可读性。 但是，当这种标记文档的设计被用来序列化对象的时候，就显得冗长而复杂（Verbose and Complex）。 XML本质上是一种描述语言，并且具有自我描述（Self-describing）的属性，所以XML自身就被用于XML序列化的IDL。 标准的XML描述格式有两种：DTD（Document Type Definition）和XSD（XML Schema Definition）。作为一种人眼可读（Human-readable）的描述语言，XML被广泛使用在配置文件中，例如O/R mapping、 Spring Bean Configuration File 等。</p></li>
<li><p>SOAP（Simple Object Access protocol） 是一种被广泛应用的，基于XML为序列化和反序列化协议的结构化消息传递协议。SOAP在互联网影响如此大，以至于我们给基于SOAP的解决方案一个特定的名称&ndash;Web service。SOAP虽然可以支持多种传输层协议，不过SOAP最常见的使用方式还是XML+HTTP。SOAP协议的主要接口描述语言（IDL）是WSDL（Web Service Description Language）。SOAP具有安全、可扩展、跨语言、跨平台并支持多种传输层协议。如果不考虑跨平台和跨语言的需求，XML的在某些语言里面具有非常简单易用的序列化使用方法，无需IDL文件和第三方编译器， 例如Java＋XStream。</p></li>
</ul>


<p>自我描述与递归
SOAP是一种采用XML进行序列化和反序列化的协议，它的IDL是WSDL. 而WSDL的描述文件是XSD，而XSD自身是一种XML文件。 这里产生了一种有趣的在数学上称之为“递归”的问题，这种现象往往发生在一些具有自我属性（Self-description）的事物上。</p>

<p>IDL文件举例
采用WSDL描述上述用户基本信息的例子如下：</p>

<pre><code>&lt;xsd:complexType name='Address'&gt;
     &lt;xsd:attribute name='city' type='xsd:string' /&gt;
     &lt;xsd:attribute name='postcode' type='xsd:string' /&gt;
     &lt;xsd:attribute name='street' type='xsd:string' /&gt;
&lt;/xsd:complexType&gt;
&lt;xsd:complexType name='UserInfo'&gt;
     &lt;xsd:sequence&gt;
     &lt;xsd:element name='address' type='tns:Address'/&gt;
     &lt;xsd:element name='address1' type='tns:Address'/&gt; 
     &lt;/xsd:sequence&gt;
     &lt;xsd:attribute name='userid' type='xsd:int' /&gt;
     &lt;xsd:attribute name='name' type='xsd:string' /&gt; 
&lt;/xsd:complexType&gt;
</code></pre>

<p>典型应用场景和非应用场景
SOAP协议具有广泛的群众基础，基于HTTP的传输协议使得其在穿越防火墙时具有良好安全特性，XML所具有的人眼可读（Human-readable）特性使得其具有出众的可调试性，互联网带宽的日益剧增也大大弥补了其空间开销大（Verbose）的缺点。对于在公司之间传输数据量相对小或者实时性要求相对低（例如秒级别）的服务是一个好的选择。</p>

<p>由于XML的额外空间开销大，序列化之后的数据量剧增，对于数据量巨大序列持久化应用常景，这意味着巨大的内存和磁盘开销，不太适合XML。另外，XML的序列化和反序列化的空间和时间开销都比较大，对于对性能要求在ms级别的服务，不推荐使用。WSDL虽然具备了描述对象的能力，SOAP的S代表的也是simple，但是SOAP的使用绝对不简单。对于习惯于面向对象编程的用户，WSDL文件不直观。</p>

<p>JSON（Javascript Object Notation）
JSON起源于弱类型语言Javascript， 它的产生来自于一种称之为"Associative array"的概念，其本质是就是采用"Attribute－value"的方式来描述对象。实际上在Javascript和PHP等弱类型语言中，类的描述方式就是Associative array。JSON的如下优点，使得它快速成为最广泛使用的序列化协议之一：</p>

<ul>
<li>1、这种Associative array格式非常符合工程师对对象的理解。</li>
<li>2、它保持了XML的人眼可读（Human-readable）的优点。</li>
<li>3、相对于XML而言，序列化后的数据更加简洁。 来自于的以下链接的研究表明：XML所产生序列化之后文件的大小接近JSON的两倍。<a href="http://www.codeproject.com/Articles/604720/JSON-vs-XML-Some-hard-numbers-about-verbosity">http://www.codeproject.com/Articles/604720/JSON-vs-XML-Some-hard-numbers-about-verbosity</a></li>
<li>4、它具备Javascript的先天性支持，所以被广泛应用于Web browser的应用常景中，是Ajax的事实标准协议。</li>
<li>5、与XML相比，其协议比较简单，解析速度比较快。</li>
<li>6、松散的Associative array使得其具有良好的可扩展性和兼容性。</li>
</ul>


<p>IDL悖论
JSON实在是太简单了，或者说太像各种语言里面的类了，所以采用JSON进行序列化不需要IDL。这实在是太神奇了，存在一种天然的序列化协议，自身就实现了跨语言和跨平台。然而事实没有那么神奇，之所以产生这种假象，来自于两个原因：</p>

<h6>第一</h6>

<p>Associative array在弱类型语言里面就是类的概念，在PHP和Javascript里面Associative array就是其class的实际实现方式，所以在这些弱类型语言里面，JSON得到了非常良好的支持。</p>

<h6>第二</h6>

<p>IDL的目的是撰写IDL文件，而IDL文件被IDL Compiler编译后能够产生一些代码（Stub/Skeleton），而这些代码是真正负责相应的序列化和反序列化工作的组件。 但是由于Associative array和一般语言里面的class太像了，他们之间形成了一一对应关系，这就使得我们可以采用一套标准的代码进行相应的转化。对于自身支持Associative array的弱类型语言，语言自身就具备操作JSON序列化后的数据的能力；对于Java这强类型语言，可以采用反射的方式统一解决，例如Google提供的Gson。</p>

<p>典型应用场景和非应用场景
JSON在很多应用场景中可以替代XML，更简洁并且解析速度更快。典型应用场景包括：</p>

<ul>
<li>1、公司之间传输数据量相对小，实时性要求相对低（例如秒级别）的服务。</li>
<li>2、基于Web browser的Ajax请求。</li>
<li>3、由于JSON具有非常强的前后兼容性，对于接口经常发生变化，并对可调式性要求高的场景，例如Mobile app与服务端的通讯。</li>
<li>4、由于JSON的典型应用场景是JSON＋HTTP，适合跨防火墙访问。</li>
</ul>


<p>总的来说，采用JSON进行序列化的额外空间开销比较大，对于大数据量服务或持久化，这意味着巨大的内存和磁盘开销，这种场景不适合。没有统一可用的IDL降低了对参与方的约束，实际操作中往往只能采用文档方式来进行约定，这可能会给调试带来一些不便，延长开发周期。 由于JSON在一些语言中的序列化和反序列化需要采用反射机制，所以在性能要求为ms级别，不建议使用。</p>

<p>IDL文件举例
以下是UserInfo序列化之后的一个例子：</p>

<pre><code>{"userid":1,"name":"messi","address":[{"city":"北京","postcode":"1000000","street":"wangjingdonglu"}]}
</code></pre>

<p>Thrift
Thrift是Facebook开源提供的一个高性能，轻量级RPC服务框架，其产生正是为了满足当前大数据量、分布式、跨语言、跨平台数据通讯的需求。 但是，Thrift并不仅仅是序列化协议，而是一个RPC框架。相对于JSON和XML而言，Thrift在空间开销和解析性能上有了比较大的提升，对于对性能要求比较高的分布式系统，它是一个优秀的RPC解决方案；但是由于Thrift的序列化被嵌入到Thrift框架里面，Thrift框架本身并没有透出序列化和反序列化接口，这导致其很难和其他传输层协议共同使用（例如HTTP）。</p>

<p>典型应用场景和非应用场景
对于需求为高性能，分布式的RPC服务，Thrift是一个优秀的解决方案。它支持众多语言和丰富的数据类型，并对于数据字段的增删具有较强的兼容性。所以非常适用于作为公司内部的面向服务构建（SOA）的标准RPC框架。</p>

<p>不过Thrift的文档相对比较缺乏，目前使用的群众基础相对较少。另外由于其Server是基于自身的Socket服务，所以在跨防火墙访问时，安全是一个顾虑，所以在公司间进行通讯时需要谨慎。 另外Thrift序列化之后的数据是Binary数组，不具有可读性，调试代码时相对困难。最后，由于Thrift的序列化和框架紧耦合，无法支持向持久层直接读写数据，所以不适合做数据持久化序列化协议。</p>

<p>IDL文件举例</p>

<pre><code>struct Address
{ 
    1: required string city;
    2: optional string postcode;
    3: optional string street;
} 
struct UserInfo
{ 
    1: required string userid;
    2: required i32 name;
    3: optional list&lt;Address&gt; address;
}
</code></pre>

<p>Protobuf
Protobuf具备了优秀的序列化协议的所需的众多典型特征：</p>

<ul>
<li>1、标准的IDL和IDL编译器，这使得其对工程师非常友好。</li>
<li>2、序列化数据非常简洁，紧凑，与XML相比，其序列化之后的数据量约为1/3到1/10。</li>
<li>3、解析速度非常快，比对应的XML快约20-100倍。</li>
<li>4、提供了非常友好的动态库，使用非常简介，反序列化只需要一行代码。</li>
</ul>


<p>Protobuf是一个纯粹的展示层协议，可以和各种传输层协议一起使用；Protobuf的文档也非常完善。 但是由于Protobuf产生于Google，所以目前其仅仅支持Java、C++、Python三种语言。另外Protobuf支持的数据类型相对较少，不支持常量类型。由于其设计的理念是纯粹的展现层协议（Presentation Layer），目前并没有一个专门支持Protobuf的RPC框架。</p>

<p>典型应用场景和非应用场景
Protobuf具有广泛的用户基础，空间开销小以及高解析性能是其亮点，非常适合于公司内部的对性能要求高的RPC调用。由于Protobuf提供了标准的IDL以及对应的编译器，其IDL文件是参与各方的非常强的业务约束，另外，Protobuf与传输层无关，采用HTTP具有良好的跨防火墙的访问属性，所以Protobuf也适用于公司间对性能要求比较高的场景。由于其解析性能高，序列化后数据量相对少，非常适合应用层对象的持久化场景。</p>

<p>它的主要问题在于其所支持的语言相对较少，另外由于没有绑定的标准底层传输层协议，在公司间进行传输层协议的调试工作相对麻烦。</p>

<p>IDL文件举例</p>

<pre><code>message Address
{
    required string city=1;
        optional string postcode=2;
        optional string street=3;
}
message UserInfo
{
    required string userid=1;
    required string name=2;
    repeated Address address=3;
}
</code></pre>

<p>Avro</p>

<pre><code>Avro的产生解决了JSON的冗长和没有IDL的问题，Avro属于Apache Hadoop的一个子项目。 Avro提供两种序列化格式：JSON格式或者Binary格式。Binary格式在空间开销和解析性能方面可以和Protobuf媲美，JSON格式方便测试阶段的调试。 Avro支持的数据类型非常丰富，包括C++语言里面的union类型。Avro支持JSON格式的IDL和类似于Thrift和Protobuf的IDL（实验阶段），这两者之间可以互转。Schema可以在传输数据的同时发送，加上JSON的自我描述属性，这使得Avro非常适合动态类型语言。 Avro在做文件持久化的时候，一般会和Schema一起存储，所以Avro序列化文件自身具有自我描述属性，所以非常适合于做Hive、Pig和MapReduce的持久化数据格式。对于不同版本的Schema，在进行RPC调用的时候，服务端和客户端可以在握手阶段对Schema进行互相确认，大大提高了最终的数据解析速度。
</code></pre>

<p>典型应用场景和非应用场景
Avro解析性能高并且序列化之后的数据非常简洁，比较适合于高性能的序列化服务。</p>

<p>由于Avro目前非JSON格式的IDL处于实验阶段，而JSON格式的IDL对于习惯于静态类型语言的工程师来说不直观。</p>

<p>IDL文件举例</p>

<pre><code>protocol Userservice {
  record Address {
   string city;
   string postcode;
   string street;
  }  
  record UserInfo {
   string name;
   int userid;
   array&lt;Address&gt; address = [];
  }
}
</code></pre>

<p>所对应的JSON Schema格式如下：</p>

<pre><code>{
  "protocol" : "Userservice",
  "namespace" : "org.apache.avro.ipc.specific",
  "version" : "1.0.5",
  "types" : [ {
    "type" : "record",
    "name" : "Address",
    "fields" : [ {
      "name" : "city",
      "type" : "string"
    }, {
      "name" : "postcode",
      "type" : "string"
    }, {
      "name" : "street",
      "type" : "string"
    } ]
  }, {
    "type" : "record",
    "name" : "UserInfo",
    "fields" : [ {
      "name" : "name",
      "type" : "string"
    }, {
      "name" : "userid",
      "type" : "int"
    }, {
      "name" : "address",
      "type" : {
        "type" : "array",
        "items" : "Address"
      },
      "default" : [ ]
    } ]
  } ],
  "messages" : { }
}
</code></pre>

<h4>五、Benchmark以及选型建议</h4>

<p>Benchmark
以下数据来自<a href="https://code.google.com/p/thrift-protobuf-compare/wiki/Benchmarking">https://code.google.com/p/thrift-protobuf-compare/wiki/Benchmarking</a></p>

<ul>
<li>解析性能</li>
<li>序列化之空间开销</li>
<li>序列化大小</li>
</ul>


<p>从上图可得出如下结论：</p>

<ul>
<li>1、XML序列化（Xstream）无论在性能和简洁性上比较差。</li>
<li>2、Thrift与Protobuf相比在时空开销方面都有一定的劣势。</li>
<li>3、Protobuf和Avro在两方面表现都非常优越。</li>
</ul>


<p>选型建议</p>

<pre><code>以上描述的五种序列化和反序列化协议都各自具有相应的特点，适用于不同的场景：
1、对于公司间的系统调用，如果性能要求在100ms以上的服务，基于XML的SOAP协议是一个值得考虑的方案。
2、基于Web browser的Ajax，以及Mobile app与服务端之间的通讯，JSON协议是首选。对于性能要求不太高，或者以动态类型语言为主，或者传输数据载荷很小的的运用场景，JSON也是非常不错的选择。
3、对于调试环境比较恶劣的场景，采用JSON或XML能够极大的提高调试效率，降低系统开发成本。
4、当对性能和简洁性有极高要求的场景，Protobuf，Thrift，Avro之间具有一定的竞争关系。
5、对于T级别的数据的持久化应用场景，Protobuf和Avro是首要选择。如果持久化后的数据存储在Hadoop子项目里，Avro会是更好的选择。
6、由于Avro的设计理念偏向于动态类型语言，对于动态语言为主的应用场景，Avro是更好的选择。
7、对于持久层非Hadoop项目，以静态类型语言为主的应用场景，Protobuf会更符合静态类型语言工程师的开发习惯。
8、如果需要提供一个完整的RPC解决方案，Thrift是一个好的选择。
9、如果序列化之后需要支持不同的传输层协议，或者需要跨防火墙访问的高性能场景，Protobuf可以优先考虑。
</code></pre>

<!--more-->

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[粘贴深究]]></title>
    <link href="http://al1020119.github.io/blog/2015/12/03/nian-tie-shen-jiu/"/>
    <updated>2015-12-03T02:59:00+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/12/03/nian-tie-shen-jiu</id>
    <content type="html"><![CDATA[<p>在iOS中，可以使用剪贴板实现应用程序之中以及应用程序之间实现数据的共享。比如你可以从iPhone QQ复制一个url，然后粘贴到safari浏览器中查看这个链接的内容。</p>

<h3>一、在iOS中下面三个控件，自身就有复制-粘贴的功能：</h3>

<ul>
<li>1、UITextView</li>
<li>2、UITextField</li>
<li>3、UIWebView</li>
</ul>


<h3>二、UIKit framework提供了几个类和协议方便我们在自己的应用程序中实现剪贴板的功能。</h3>

<ul>
<li>1、UIPasteboard：我们可以向其中写入数据，也可以读取数据</li>
<li>2、UIMenuController：显示一个快捷菜单，用来复制、剪贴、粘贴选择的项。</li>
<li>3、UIResponder中的 canPerformAction:withSender:用于控制哪些命令显示在快捷菜单中。</li>
<li>4、当快捷菜单上的命令点击的时候，UIResponderStandardEditActions将会被调用。</li>
</ul>


<h3>三、下面这些项能被放置到剪贴板中</h3>

<ul>
<li>1、UIPasteboardTypeListString —  字符串数组, 包含kUTTypeUTF8PlainText</li>
<li>2、UIPasteboardTypeListURL —   URL数组，包含kUTTypeURL</li>
<li>3、UIPasteboardTypeListImage —   图形数组, 包含kUTTypePNG 和kUTTypeJPEG</li>
<li>4、UIPasteboardTypeListColor —   颜色数组</li>
</ul>


<h3>四、剪贴板的类型分为两种：</h3>

<p>系统级：使用UIPasteboardNameGeneral和UIPasteboardNameFind创建，系统级的剪贴板，当应用程序关闭，或者卸载时，数据都不会丢失。
应用程序级：通过设置，可以让数据在应用程序关闭之后仍然保存在剪贴板中，但是应用程序卸载之后数据就会失去。我们可用通过pasteboardWithName:create：来创建。</p>

<p>了解这些之后，下面通过一系列的例子来说明如何在应用程序中使用剪贴板。</p>

<p>例子：</p>

<h5>1、复制剪贴文本。</h5>

<pre><code>下面通过一个例子，可以在tableview上显示一个快捷菜单，上面只有复制按钮，复制tableview上的数据之后，然后粘贴到title上。
</code></pre>

<p>定义一个单元格类CopyTableViewCell，在这个类的上显示快捷菜单，实现复制功能。</p>

<pre><code>@interface CopyTableViewCell : UITableViewCell {
    id delegate;
}
@property (nonatomic, retain) id delegate;
@end
</code></pre>

<p>实现CopyTableViewCell ：</p>

<pre><code>#import "CopyTableViewCell.h"

@implementation CopyTableViewCell

@synthesize delegate;

- (id)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier {
    if ((self = [super initWithStyle:style reuseIdentifier:reuseIdentifier])) {
    }
    return self;
}
- (void)setSelected:(BOOL)selected animated:(BOOL)animated {
    [super setSelected:selected animated:animated];
}
- (void)setHighlighted:(BOOL)highlighted animated:(BOOL)animated {
    [[self delegate] performSelector:@selector(showMenu:)
                          withObject:self afterDelay:0.9f];

    [super setHighlighted:highlighted animated:animated];

}
- (BOOL)canBecomeFirstResponder
{
    return YES;
}
- (BOOL)canPerformAction:(SEL)action withSender:(id)sender{
    if (action == @selector(cut:)){
        return NO;
    }
    else if(action == @selector(copy:)){
        return YES;
    }
    else if(action == @selector(paste:)){
        return NO;
    }
    else if(action == @selector(select:)){
        return NO;
    }
    else if(action == @selector(selectAll:)){
        return NO;
    }
    else
    {
        return [super canPerformAction:action withSender:sender];
    }
}
- (void)copy:(id)sender {
    UIPasteboard *pasteboard = [UIPasteboard generalPasteboard];
    [pasteboard setString:[[self textLabel]text]];
}
- (void)dealloc {
    [super dealloc];
}
@end
</code></pre>

<p>复制代码
定义CopyPasteTextController，实现粘贴功能。
    @interface CopyPasteTextController : UIViewController<UITableViewDelegate> {
        //用来标识是否显示快捷菜单
        BOOL menuVisible;
        UITableView *tableView;
    }</p>

<pre><code>@property (nonatomic, getter=isMenuVisible) BOOL menuVisible;

@property (nonatomic, retain) IBOutlet UITableView *tableView;
@end
</code></pre>

<p>实现CopyPasteTextController ：</p>

<pre><code>#import "CopyPasteTextController.h"
#import "CopyTableViewCell.h"

@implementation CopyPasteTextController
@synthesize menuVisible,tableView;
- (void)viewDidLoad {
    [super viewDidLoad];
    [self setTitle:@"文字复制粘贴"];
    //点击这个按钮将剪贴板的内容粘贴到title上
    UIBarButtonItem *addButton = [[[UIBarButtonItem alloc]
                                      initWithBarButtonSystemItem:UIBarButtonSystemItemRefresh
                                      target:self
                                      action:@selector(readFromPasteboard:)]
                                     autorelease];
    [[self navigationItem] setRightBarButtonItem:addButton];
}


// Customize the number of sections in the table view.
- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView
{
    return 1;
}

- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section
{
    return 9;
}

// Customize the appearance of table view cells.
- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath
{
    static NSString *CellIdentifier =@"Cell";
    CopyTableViewCell *cell = (CopyTableViewCell *)[tableView
                                                           dequeueReusableCellWithIdentifier:CellIdentifier];
    if (cell == nil)
    {
        cell = [[[CopyTableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:CellIdentifier] autorelease];
        [cell setDelegate:self];
    }

    // Configure the cell.
    NSString *text = [NSString stringWithFormat:@"Row %d", [indexPath row]];
    [[cell textLabel] setText:text];
    return cell;
}

- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath
{
    if([self isMenuVisible])
    {
        return;
    }
    [[[self tableView] cellForRowAtIndexPath:indexPath] setSelected:YES
                                                           animated:YES];
}
//显示菜单
- (void)showMenu:(id)cell {
    if ([cell isHighlighted]) {
        [cell becomeFirstResponder];

        UIMenuController * menu = [UIMenuController sharedMenuController];
        [menu setTargetRect: [cell frame] inView: [self view]];
        [menu setMenuVisible: YES animated: YES];
    }
}
- (void)readFromPasteboard:(id)sender {
    [self setTitle:[NSString stringWithFormat:@"Pasteboard = %@",
                      [[UIPasteboard generalPasteboard] string]]];
}

- (void)didReceiveMemoryWarning
{
    // Releases the view if it doesn't have a superview.
    [super didReceiveMemoryWarning];

    // Relinquish ownership any cached data, images, etc that aren't in use.
}

- (void)viewDidUnload
{
    [super viewDidUnload];
    [self.tableView release];

    // Relinquish ownership of anything that can be recreated in viewDidLoad or on demand.
    // For example: self.myOutlet = nil;
}
</code></pre>

<p>复制一行数据：
点击右上角的按钮粘贴，将数据显示在title上：</p>

<h6>2、图片复制粘贴</h6>

<p>   下面通过一个例子，将图片复制和剪贴到另外一个UIImageView中间。</p>

<ul>
<li>1、在界面上放置两个uiimageview，一个是图片的数据源，一个是将图片粘贴到的地方。CopyPasteImageViewController 代码如下：</li>
</ul>


<p>@interface CopyPasteImageViewController : UIViewController {
    UIImageView <em>imageView;
    UIImageView </em>pasteView;
    UIImageView <em>selectedView;
}
@property (nonatomic, retain) IBOutlet UIImageView </em>imageView;
@property (nonatomic, retain) IBOutlet UIImageView <em>pasteView;
@property (nonatomic, retain) UIImageView </em>selectedView;
- (void)placeImageOnPasteboard:(id)view;
@end
* 2、当触摸图片的时候我们显示快捷菜单：</p>

<hr />

<pre><code>- (void)touchesBegan:(NSSet*)touches withEvent:(UIEvent*)event {
    NSSet *copyTouches = [event touchesForView:imageView];
    NSSet *pasteTouches = [event touchesForView:pasteView];

    [self becomeFirstResponder];
    if ([copyTouches count] &gt; 0) {
        [self performSelector:@selector(showMenu:)
                   withObject:imageView afterDelay:0.9f];
    }
    else  if([pasteTouches count] &gt; 0) {
        [self performSelector:@selector(showMenu:)
                   withObject:pasteView afterDelay:0.9f];
    }
    [super touchesBegan:touches withEvent:event];
}

- (void)showMenu:(id)view {
    [self setSelectedView:view];

    UIMenuController * menu = [UIMenuController sharedMenuController];
    [menu setTargetRect: CGRectMake(5, 10, 1, 1) inView: view];
    [menu setMenuVisible: YES animated: YES];
}
</code></pre>

<p>这里的快捷菜单，显示三个菜单项：剪贴、粘贴、复制：</p>

<hr />

<pre><code>- (BOOL)canPerformAction:(SEL)action withSender:(id)sender{
    if (action == @selector(cut:)) {
        return ([self selectedView] == imageView) ? YES : NO;
    } else if (action == @selector(copy:)) {
        return ([self selectedView] == imageView) ? YES : NO;
    } else if (action == @selector(paste:)) {
        return ([self selectedView] == pasteView) ? YES : NO;
    } else if (action == @selector(select:)) {
        return NO;
    } else if (action == @selector(selectAll:)) {
        return NO;
    } else {
        return [super canPerformAction:action withSender:sender];
    }
}
- (void)cut:(id)sender {
    [self copy:sender];
    [imageView setHidden:YES];
}
- (void)copy:(id)sender {
    [self placeImageOnPasteboard:[self imageView]];
}
- (void)paste:(id)sender {
    UIPasteboard *appPasteBoard =
    [UIPasteboard pasteboardWithName:@"CopyPasteImage" create:YES];
    NSData *data =[appPasteBoard dataForPasteboardType:@"com.marizack.CopyPasteImage.imageView"];
    pasteView.image = [UIImage imageWithData:data];
}
</code></pre>

<!--more-->

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[长链接&amp;短链接]]></title>
    <link href="http://al1020119.github.io/blog/2015/11/30/chang-lian-jie-and-duan-lian-jie/"/>
    <updated>2015-11-30T21:30:21+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/11/30/chang-lian-jie-and-duan-lian-jie</id>
    <content type="html"><![CDATA[<ul>
<li>HTTP协议与TCP/IP协议的关系</li>
<li>如何理解HTTP协议是无状态的</li>
<li>什么是长连接、短连接？

<ul>
<li> TCP连接</li>
<li> TCP短连接</li>
<li> TCP长连接</li>
</ul>
</li>
<li>长连接短连接操作过程</li>
<li>长连接和短连接的优点和缺点</li>
<li>什么时候用长连接，短连接？</li>
</ul>


<h3>HTTP协议与TCP/IP协议的关系</h3>

<p>HTTP的长连接和短连接本质上是TCP长连接和短连接。HTTP属于应用层协议，在传输层使用TCP协议，在网络层使用IP协议。IP协议主要解决网络路由和寻址问题，TCP协议主要解决如何在IP层之上可靠的传递数据包，使在网络上的另一端收到发端发出的所有包，并且顺序与发出顺序一致。TCP有可靠，面向连接的特点。</p>

<h3>如何理解HTTP协议是无状态的</h3>

<p>HTTP协议是无状态的，指的是协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。也就是说，打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系。HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接）。</p>

<h3>什么是长连接、短连接？</h3>

<p>在HTTP/1.0中，默认使用的是短连接。也就是说，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。如果客户端浏览器访问的某个HTML或其他类型的 Web页中包含有其他的Web资源，如JavaScript文件、图像文件、CSS文件等；当浏览器每遇到这样一个Web资源，就会建立一个HTTP会话。</p>

<p>但从 HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头有加入这行代码：</p>

<p>Connection:keep-alive</p>

<p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的 TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接要客户端和服务端都支持长连接。</p>

<p>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</p>

<h5>TCP连接</h5>

<p>当网络通信时采用TCP协议时，在真正的读写操作之前，server与client之间必须建立一个连接，当读写操作完成后，双方不再需要这个连接 时它们可以释放这个连接，连接的建立是需要三次握手的，而释放则需要4次握手，所以说每个连接的建立都是需要资源消耗和时间消耗的</p>

<p>经典的三次握手示意图：</p>

<p>经典的四次握手关闭图：</p>

<h5>TCP短连接</h5>

<p>我们模拟一下TCP短连接的情况，client向server发起连接请求，server接到请求，然后双方建立连接。client向server 发送消息，server回应client，然后一次读写就完成了，这时候双方任何一个都可以发起close操作，不过一般都是client先发起 close操作。为什么呢，一般的server不会回复完client后立即关闭连接的，当然不排除有特殊的情况。从上面的描述看，短连接一般只会在 client/server间传递一次读写操作</p>

<p>短连接的优点是：管理起来比较简单，存在的连接都是有用的连接，不需要额外的控制手段</p>

<h5>TCP长连接</h5>

<p>接下来我们再模拟一下长连接的情况，client向server发起连接，server接受client连接，双方建立连接。Client与server完成一次读写之后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。</p>

<p>首先说一下TCP/IP详解上讲到的TCP保活功能，保活功能主要为服务器应用提供，服务器应用希望知道客户主机是否崩溃，从而可以代表客户使用资源。如果客户已经消失，使得服务器上保留一个半开放的连接，而服务器又在等待来自客户端的数据，则服务器将应远等待客户端的数据，保活功能就是试图在服务 器端检测到这种半开放的连接。</p>

<p>如果一个给定的连接在两小时内没有任何的动作，则服务器就向客户发一个探测报文段，客户主机必须处于以下4个状态之一：</p>

<p>客户主机依然正常运行，并从服务器可达。客户的TCP响应正常，而服务器也知道对方是正常的，服务器在两小时后将保活定时器复位。
客户主机已经崩溃，并且关闭或者正在重新启动。在任何一种情况下，客户的TCP都没有响应。服务端将不能收到对探测的响应，并在75秒后超时。服务器总共发送10个这样的探测 ，每个间隔75秒。如果服务器没有收到一个响应，它就认为客户主机已经关闭并终止连接。
客户主机崩溃并已经重新启动。服务器将收到一个对其保活探测的响应，这个响应是一个复位，使得服务器终止这个连接。
客户机正常运行，但是服务器不可达，这种情况与2类似，TCP能发现的就是没有收到探查的响应。</p>

<h5>长连接短连接操作过程</h5>

<p>短连接的操作步骤是：</p>

<p>建立连接——数据传输——关闭连接…建立连接——数据传输——关闭连接</p>

<p>长连接的操作步骤是：</p>

<p>建立连接——数据传输…（保持连接）…数据传输——关闭连接</p>

<h3>长连接和短连接的优点和缺点</h3>

<p>由上可以看出，长连接可以省去较多的TCP建立和关闭的操作，减少浪费，节约时间。对于频繁请求资源的客户来说，较适用长连接。不过这里存在一个问题，存活功能的探测周期太长，还有就是它只是探测TCP连接的存活，属于比较斯文的做法，遇到恶意的连接时，保活功能就不够使了。在长连接的应用场景下，client端一般不会主动关闭它们之间的连接，Client与server之间的连接如果一直不关闭的话，会存在一个问题，随着客户端连接越来越多，server早晚有扛不住的时候，这时候server端需要采取一些策略，如关闭一些长时间没有读写事件发生的连接，这样可 以避免一些恶意连接导致server端服务受损；如果条件再允许就可以以客户端机器为颗粒度，限制每个客户端的最大长连接数，这样可以完全避免某个蛋疼的客户端连累后端服务。</p>

<p>短连接对于服务器来说管理较为简单，存在的连接都是有用的连接，不需要额外的控制手段。但如果客户请求频繁，将在TCP的建立和关闭操作上浪费时间和带宽。</p>

<p>长连接和短连接的产生在于client和server采取的关闭策略，具体的应用场景采用具体的策略，没有十全十美的选择，只有合适的选择。</p>

<h3>什么时候用长连接，短连接？</h3>

<p>长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况，。每个TCP连接都需要三步握手，这需要时间，如果每个操作都是先连接，再操作的话那么处理速度会降低很多，所以每个操作完后都不断开，次处理时直接发送数据包就OK了，不用建立TCP连接。例如：数据库的连接用长连接， 如果用短连接频繁的通信会造成socket错误，而且频繁的socket 创建也是对资源的浪费。</p>

<p>而像WEB网站的http服务一般都用短链接，因为长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以并发量大，但每个用户无需频繁操作情况下需用短连好。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自定义相册删除复活的实现]]></title>
    <link href="http://al1020119.github.io/blog/2015/11/29/zi-ding-yi-xiang-ce-shan-chu-fu-huo-de-shi-xian/"/>
    <updated>2015-11-29T00:22:52+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/11/29/zi-ding-yi-xiang-ce-shan-chu-fu-huo-de-shi-xian</id>
    <content type="html"><![CDATA[<p>在这里（<a href="http://www.cnblogs.com/iCocos/p/4705585.html">http://www.cnblogs.com/iCocos/p/4705585.html</a>）我们提到了。</p>

<ul>
<li>简单的实现了获取系统相册图片并且保存图片到系统相册</li>
<li>定义自定义的相册，并且保存到自定义相册</li>
</ul>


<p>这里久以一个简单的例子实现一个上面的所有功能，并且添加一个很有用的功能实现
App中自定义的相册呗删除之后再次保存相片无法成功</p>

<p>这里使用的是一个系统的库：ALAssetsLibrary</p>

<p>先来看看咱们取得相册中的相片</p>

<pre><code>- (void)getAllPhotos
{
    ALAssetsLibrary *library = [[ALAssetsLibrary alloc] init];
    // 遍历所有的文件夹, 一个ALAssetsGroup对象就代表一个文件夹
    [library enumerateGroupsWithTypes:ALAssetsGroupAll usingBlock:^(ALAssetsGroup *group, BOOL *stop) {
        // 遍历文件夹内的所有多媒体文件（图片、视频）, 一个ALAsset对象就代表一张图片
        [group enumerateAssetsUsingBlock:^(ALAsset *result, NSUInteger index, BOOL *stop) {
            // 缩略图
            XMGLog(@"%@", [UIImage imageWithCGImage:result.thumbnail]);
            // 获得原始图片
            //            XMGLog(@"%@", [UIImage imageWithCGImage:result.defaultRepresentation.fullResolutionImage]);
        }];

   } failureBlock:nil];
}
</code></pre>

<p>下面我们看看代码具体的实现</p>

<p>一：首先定义一个属性涌来记录并且实现其他一些功能</p>

<pre><code> /** 相册库 */
@property (nonatomic, strong) ALAssetsLibrary *library;
</code></pre>

<p>二：然后就懒加载这个属性</p>

<pre><code>- (ALAssetsLibrary *)library
{
    if (!_library) {
        _library = [[ALAssetsLibrary alloc] init];
    }
    return _library;
}
</code></pre>

<p>三：点击保存按钮的实现</p>

<pre><code>- (IBAction)save
{
// 获得文件夹的名字
__block NSString *groupName = [self groupName];

// self的弱引用
XMGWeakSelf;

// 图片库
__weak ALAssetsLibrary *weakLibrary = self.library;

// 创建文件夹
[weakLibrary addAssetsGroupAlbumWithName:groupName resultBlock:^(ALAssetsGroup *group) {
    if (group) { // 新创建的文件夹
        // 添加图片到文件夹中
        [weakSelf addImageToGroup:group];
    } else { // 文件夹已经存在
        [weakLibrary enumerateGroupsWithTypes:ALAssetsGroupAll usingBlock:^(ALAssetsGroup *group, BOOL *stop) {
            NSString *name = [group valueForProperty:ALAssetsGroupPropertyName];
            if ([name isEqualToString:groupName]) { // 是自己创建的文件夹
                // 添加图片到文件夹中

                [weakSelf addImageToGroup:group];

                *stop = YES; // 停止遍历
            } else if ([name isEqualToString:@"Camera Roll"]) {
                // 文件夹被用户强制删除了
                groupName = [groupName stringByAppendingString:@" "];
                // 存储新的名字
                [[NSUserDefaults standardUserDefaults] setObject:groupName forKey:XMGGroupNameKey];
                [[NSUserDefaults standardUserDefaults] synchronize];
                // 创建新的文件夹
                [weakLibrary addAssetsGroupAlbumWithName:groupName resultBlock:^(ALAssetsGroup *group) {
                    // 添加图片到文件夹中
                    [weakSelf addImageToGroup:group];
                } failureBlock:nil];
            }
        } failureBlock:nil];
    }

    } failureBlock:nil];
    }
</code></pre>

<p>四：添加图片</p>

<pre><code>/**
 * 添加一张图片到某个文件夹中
 */
- (void)addImageToGroup:(ALAssetsGroup *)group
{
__weak ALAssetsLibrary *weakLibrary = self.library;
// 需要保存的图片

CGImageRef image = self.imageView.image.CGImage;

// 添加图片到【相机胶卷】
[weakLibrary writeImageToSavedPhotosAlbum:image metadata:nil completionBlock:^(NSURL *assetURL, NSError *error) {
    [weakLibrary assetForURL:assetURL resultBlock:^(ALAsset *asset) {
        // 添加一张图片到自定义的文件夹中
        [group addAsset:asset];
        [SVProgressHUD showSuccessWithStatus:@"保存成功!"];
    } failureBlock:nil];
}];
}
</code></pre>

<p>五：关于沙河中的组名</p>

<p>先定义一个用于保存名字用的key和一个需要保存的名字</p>

<pre><code>static NSString * const iCocosGroupNameKey = @"iCocosGroupNameKey";
static NSString * const iCocosDefaultGroupName = @"iCocos";
</code></pre>

<p>实现祖名的存取</p>

<pre><code>- (NSString *)groupName
{
    // 先从沙盒中取得名字

    NSString *groupName = [[NSUserDefaults standardUserDefaults] stringForKey:XMGGroupNameKey];
    if (groupName == nil) { // 沙盒中没有存储任何文件夹的名字
   groupName = XMGDefaultGroupName;

    // 存储名字到沙盒中
    [[NSUserDefaults standardUserDefaults] setObject:groupName forKey:XMGGroupNameKey];
 [[NSUserDefaults standardUserDefaults] synchronize];
}
return groupName;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[XMPP使用总结]]></title>
    <link href="http://al1020119.github.io/blog/2015/11/29/xmppshi-yong-zong-jie/"/>
    <updated>2015-11-29T00:21:39+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/11/29/xmppshi-yong-zong-jie</id>
    <content type="html"><![CDATA[<p>引言：
最近面试被问到了一个问题，笔者当时就懵了：什么XMPP，平时怎么使用，使用过程中遇到什么问题？。</p>

<p>但是还是通过记忆，简单的说了一下自己所知道了，不过那并没有撒卵用，所以你懂的</p>

<h6>##XMPPFramework是一个OS X/iOS平台的开源项目，使用Objective-C实现了XMPP协议（RFC-3920），同时还提供了用于读写XML的工具，大大简化了基于XMPP的通信应用的开发。</h6>

<h3>关于连接的</h3>

<pre><code>//此方法在stream开始连接服务器的时候调用
 - (void)xmppStreamDidConnect:(XMPPStream *)sender
 //此方法在stream连接断开的时候调用
 - (void)xmppStreamDidDisconnect:(XMPPStream *)sender withError:(NSError *)error;
</code></pre>

<h3>关于验证的</h3>

<pre><code>//验证失败后调用
 - (void)xmppStream:(XMPPStream *)sender didNotAuthenticate:(NSXMLElement *)error
//验证成功后调用
 - (void)xmppStreamDidAuthenticate:(XMPPStream *)sender
</code></pre>

<h3>关于通信的</h3>

<pre><code>//收到消息后调用
- (void)xmppStream:(XMPPStream *)sender didReceiveMessage:(XMPPMessage *)message
//接受到好友状态更新
- (void)xmppStream:(XMPPStream *)sender didReceivePresence:(XMPPPresence *)presence
</code></pre>

<h4>简单实战</h4>

<h6>登录和好友上下线</h6>

<h5>XMPP中常用对象们</h5>

<pre><code>XMPPStream：xmpp基础服务类
XMPPRoster：好友列表类
XMPPRosterCoreDataStorage：好友列表（用户账号）在core data中的操作类
XMPPvCardCoreDataStorage：好友名片（昵称，签名，性别，年龄等信息）在core data中的操作类
XMPPvCardTemp：好友名片实体类，从数据库里取出来的都是它
xmppvCardAvatarModule：好友头像
XMPPReconnect：如果失去连接,自动重连
XMPPRoom：提供多用户聊天支持
</code></pre>

<p>XMPPPubSub：发布订阅</p>

<h5>登录操作，也就是连接xmpp服务器</h5>

<pre><code>- (void)connect {
    if (self.xmppStream == nil) {
        self.xmppStream = [[XMPPStream alloc] init];
        [self.xmppStream addDelegate:self delegateQueue:dispatch_get_main_queue()];
    }
    if (![self.xmppStream isConnected]) {
        NSString *username = [[NSUserDefaults standardUserDefaults] objectForKey:@"username"];
        XMPPJID *jid = [XMPPJID jidWithUser:username domain:@"lizhen" resource:@"Ework"];
        [self.xmppStream setMyJID:jid];
        [self.xmppStream setHostName:@"10.4.125.113"];
        NSError *error = nil;
        if (![self.xmppStream connect:&amp;error]) {
            NSLog(@"Connect Error: %@", [[error userInfo] description]);
        }
    }
}
</code></pre>

<p>connect成功之后会依次调用XMPPStreamDelegate的方法，首先调用</p>

<pre><code>- (void)xmppStream:(XMPPStream *)sender socketDidConnect:(GCDAsyncSocket *)socket
</code></pre>

<p>&hellip;
然后</p>

<ul>
<li><p>(void)xmppStreamDidConnect:(XMPPStream *)sender
在该方法下面需要使用xmppStream 的authenticateWithPassword方法进行密码验证，成功的话会响应delegate的方法，就是下面这个</p></li>
<li><p>(void)xmppStreamDidAuthenticate:(XMPPStream *)sender</p></li>
</ul>


<h5>上线</h5>

<p>实现 - (void)xmppStreamDidAuthenticate:(XMPPStream *)sender 委托方法</p>

<pre><code>- (void)xmppStreamDidAuthenticate:(XMPPStream *)sender {
     XMPPPresence *presence = [XMPPPresence presenceWithType:@"available"];
    [self.xmppStream sendElement:presence];
 }
</code></pre>

<h5>退出并断开连接</h5>

<pre><code> - (void)disconnect {
     XMPPPresence *presence = [XMPPPresence presenceWithType:@"unavailable"];
    [self.xmppStream sendElement:presence];

      [self.xmppStream disconnect];
  }
</code></pre>

<h5>好友状态</h5>

<p>获取好友状态，通过实现</p>

<pre><code>- (void)xmppStream:(XMPPStream *)sender didReceivePresence:(XMPPPresence *)presence
</code></pre>

<p>&hellip;
方法，当接收到 presence 标签的内容时，XMPPFramework 框架回调该方法</p>

<pre><code>presence 的状态：
available 上线
away 离开
do not disturb 忙碌
unavailable 下线

- (void)xmppStream:(XMPPStream *)sender didReceivePresence:(XMPPPresence *)presence {
    NSString *presenceType = [presence type];
    NSString *presenceFromUser = [[presence from] user];
    if (![presenceFromUser isEqualToString:[[sender myJID] user]]) {
        if ([presenceType isEqualToString:@"available"]) {
            //
        } else if ([presenceType isEqualToString:@"unavailable"]) {
            //
        }
    }
}
</code></pre>

<h3>接收消息和发送消息</h3>

<h5>接收消息</h5>

<p>通过实现</p>

<ul>
<li><p>(void)xmppStream:(XMPPStream <em>)sender didReceiveMessage:(XMPPMessage </em>)message;
当接收到 message 标签的内容时，XMPPFramework 框架回调该方法
根据 XMPP 协议，消息体的内容存储在标签 body 内</p></li>
<li><p>(void)xmppStream:(XMPPStream <em>)sender didReceiveMessage:(XMPPMessage </em>)message {
  NSString *messageBody = [[message elementForName:@&ldquo;body&rdquo;] stringValue];
}</p></li>
</ul>


<h5>发送消息</h5>

<p>发送消息，我们需要根据 XMPP 协议，将数据放到标签内</p>

<pre><code>- (void)sendMessage:(NSString *) message toUser:(NSString *) user {
    NSXMLElement *body = [NSXMLElement elementWithName:@"body"];
    [body setStringValue:message];
    NSXMLElement *message = [NSXMLElement elementWithName:@"message"];
    [message addAttributeWithName:@"type" stringValue:@"chat"];
    NSString *to = [NSString stringWithFormat:@"%@@example.com", user];
    [message addAttributeWithName:@"to" stringValue:to];
    [message addChild:body];
    [self.xmppStream sendElement:message];
}
</code></pre>

<h3>获取好友信息和删除好友</h3>

<h5>好友列表和好友名片</h5>

<pre><code>[_xmppRoster fetchRoster];//获取好友列表
//获取到一个好友节点
- (void)xmppRoster:(XMPPRoster *)sender didRecieveRosterItem:(NSXMLElement *)item
//获取完好友列表
- (void)xmppRosterDidEndPopulating:(XMPPRoster *)sender
//到服务器上请求联系人名片信息
- (void)fetchvCardTempForJID:(XMPPJID *)jid;
//请求联系人的名片，如果数据库有就不请求，没有就发送名片请求
- (void)fetchvCardTempForJID:(XMPPJID *)jid ignoreStorage:(BOOL)ignoreStorage;
//获取联系人的名片，如果数据库有就返回，没有返回空，并到服务器上抓取
- (XMPPvCardTemp *)vCardTempForJID:(XMPPJID *)jid shouldFetch:(BOOL)shouldFetch;
//更新自己的名片信息
- (void)updateMyvCardTemp:(XMPPvCardTemp *)vCardTemp;
//获取到一盒联系人的名片信息的回调
- (void)xmppvCardTempModule:(XMPPvCardTempModule *)vCardTempModule
        didReceivevCardTemp:(XMPPvCardTemp *)vCardTemp
                     forJID:(XMPPJID *)jid
</code></pre>

<h5>添加好友</h5>

<pre><code>//name为用户账号
    - (void)XMPPAddFriendSubscribe:(NSString *)name
    {
        //XMPPHOST 就是服务器名，  主机名
        XMPPJID *jid = [XMPPJID jidWithString:[NSString stringWithFormat:@"%@@%@",name,XMPPHOST]];
        //[presence addAttributeWithName:@"subscription" stringValue:@"好友"];
        [xmppRoster subscribePresenceToUser:jid];

    }
</code></pre>

<h5>收到添加好友的请求</h5>

<pre><code>- (void)xmppRoster:(XMPPRoster *)sender didReceivePresenceSubscriptionRequest:(XMPPPresence *)presence
    {
        //取得好友状态
        NSString *presenceType = [NSString stringWithFormat:@"%@", [presence type]]; //online/offline
        //请求的用户
        NSString *presenceFromUser =[NSString stringWithFormat:@"%@", [[presence from] user]];
        NSLog(@"presenceType:%@",presenceType);

        NSLog(@"presence2:%@  sender2:%@",presence,sender);

        XMPPJID *jid = [XMPPJID jidWithString:presenceFromUser];
        //接收添加好友请求
        [xmppRoster acceptPresenceSubscriptionRequestFrom:jid andAddToRoster:YES];

    }
</code></pre>

<h5>删除好友</h5>

<pre><code>//删除好友，name为好友账号
- (void)removeBuddy:(NSString *)name  
{  
    XMPPJID *jid = [XMPPJID jidWithString:[NSString stringWithFormat:@"%@@%@",name,XMPPHOST]];  

    [self xmppRoster] removeUser:jid];  
}
</code></pre>

<h5>聊天室</h5>

<p>初始化聊天室</p>

<pre><code>     XMPPJID *roomJID = [XMPPJID jidWithString:ROOM_JID];

    xmppRoom = [[XMPPRoom alloc] initWithRoomStorage:self jid:roomJID];

    [xmppRoom activate:xmppStream];
     [xmppRoom addDelegate:self delegateQueue:dispatch_get_main_queue()];
</code></pre>

<p>创建聊天室成功</p>

<pre><code>`- (void)xmppRoomDidCreate:(XMPPRoom *)sender
{
    DDLogInfo(@"%@: %@", THIS_FILE, THIS_METHOD);
}`
</code></pre>

<p>加入聊天室，使用昵称</p>

<pre><code>[xmppRoom joinRoomUsingNickname:@"quack" history:nil];
</code></pre>

<p>获取聊天室信息</p>

<pre><code>- (void)xmppRoomDidJoin:(XMPPRoom *)sender
    {
        [xmppRoom fetchConfigurationForm];
        [xmppRoom fetchBanList];
        [xmppRoom fetchMembersList];
        [xmppRoom fetchModeratorsList];
    }
</code></pre>

<p>如果房间存在，会调用委托</p>

<pre><code>    // 收到禁止名单列表

    - (void)xmppRoom:(XMPPRoom *)sender didFetchBanList:(NSArray *)items;
    // 收到好友名单列表

    - (void)xmppRoom:(XMPPRoom *)sender didFetchMembersList:(NSArray *)items;
    // 收到主持人名单列表

    - (void)xmppRoom:(XMPPRoom *)sender didFetchModeratorsList:(NSArray *)items;
房间不存在，调用委托

    - (void)xmppRoom:(XMPPRoom *)sender didNotFetchBanList:(XMPPIQ *)iqError;
    - (void)xmppRoom:(XMPPRoom *)sender didNotFetchMembersList:(XMPPIQ *)iqError;
    - (void)xmppRoom:(XMPPRoom *)sender didNotFetchModeratorsList:(XMPPIQ *)iqError;
</code></pre>

<p>离开房间</p>

<pre><code>[xmppRoom deactivate:xmppStream];
</code></pre>

<p>XMPPRoomDelegate的其他代理方法:</p>

<p>离开聊天室</p>

<pre><code>    - (void)xmppRoomDidLeave:(XMPPRoom *)sender
    {
        DDLogVerbose(@"%@: %@", THIS_FILE, THIS_METHOD);
    }
</code></pre>

<p>新人加入群聊</p>

<pre><code>    - (void)xmppRoom:(XMPPRoom *)sender occupantDidJoin:(XMPPJID *)occupantJID
     {
         DDLogVerbose(@"%@: %@", THIS_FILE, THIS_METHOD);
    }
</code></pre>

<p>有人退出群聊</p>

<pre><code>    - (void)xmppRoom:(XMPPRoom *)sender occupantDidLeave:(XMPPJID *)occupantJID
    {
        DDLogVerbose(@"%@: %@", THIS_FILE, THIS_METHOD);
    }
</code></pre>

<p>有人在群里发言</p>

<pre><code>    - (void)xmppRoom:(XMPPRoom *)sender didReceiveMessage:(XMPPMessage *)message fromOccupant:(XMPPJID *)occupantJID
     {
         DDLogVerbose(@"%@: %@", THIS_FILE, THIS_METHOD);
    }
</code></pre>

<h5>消息回执</h5>

<p>这个是XEP－0184协议的内容
发送消息时附加回执请求
代码实现</p>

<pre><code>NSString *siID = [XMPPStream generateUUID];
    //发送消息
    XMPPMessage *message = [XMPPMessage messageWithType:@"chat" to:jid elementID:siID];
    NSXMLElement *receipt = [NSXMLElement elementWithName:@"request" xmlns:@"urn:xmpp:receipts"];
    [message addChild:receipt];
    [message addBody:@"测试"];
    [self.xmppStream sendElement:message];
</code></pre>

<p>收到回执请求的消息，发送回执</p>

<pre><code>- (void)xmppStream:(XMPPStream *)sender didReceiveMessage:(XMPPMessage *)message
    {
        //回执判断
        NSXMLElement *request = [message elementForName:@"request"];
        if (request)
        {
            if ([request.xmlns isEqualToString:@"urn:xmpp:receipts"])//消息回执
            {
                //组装消息回执
                XMPPMessage *msg = [XMPPMessage messageWithType:[message attributeStringValueForName:@"type"] to:message.from elementID:[message attributeStringValueForName:@"id"]];
                NSXMLElement *recieved = [NSXMLElement elementWithName:@"received" xmlns:@"urn:xmpp:receipts"];
                [msg addChild:recieved];

                //发送回执
                [self.xmppStream sendElement:msg];
            }
        }else
        {
            NSXMLElement *received = [message elementForName:@"received"];
            if (received)
            {
                if ([received.xmlns isEqualToString:@"urn:xmpp:receipts"])//消息回执
                {
                    //发送成功
                    NSLog(@"message send success!");
                }  
            }  
        }  

        //消息处理  
        //...  
    }
</code></pre>

<h5>添加AutoPing</h5>

<p>为 了监听服务器是否有效，增加心跳监听。用XEP-0199协议，在XMPPFrameWork框架下，封装了 XMPPAutoPing 和 XMPPPing两个类都可以使用，因为XMPPAutoPing已经组合进了XMPPPing类，所以XMPPAutoPing使用起来更方便。</p>

<pre><code>//初始化并启动ping
-(void)autoPingProxyServer:(NSString*)strProxyServer
{
    _xmppAutoPing = [[XMPPAutoPingalloc] init];
    [_xmppAutoPingactivate:_xmppStream];
    [_xmppAutoPingaddDelegate:selfdelegateQueue:  dispatch_get_main_queue()];
    _xmppAutoPing.respondsToQueries = YES;
    _xmppAutoPing.pingInterval=2;//ping 间隔时间
    if (nil != strProxyServer)
    {
       _xmppAutoPing.targetJID = [XMPPJID jidWithString: strProxyServer ];//设置ping目标服务器，如果为nil,则监听socketstream当前连接上的那个服务器
    }
}
//卸载监听
 [_xmppAutoPing   deactivate];
  [_xmppAutoPing   removeDelegate:self];
   _xmppAutoPing = nil;
//ping XMPPAutoPingDelegate的委托方法:
- (void)xmppAutoPingDidSendPing:(XMPPAutoPing *)sender
{
    NSLog(@"- (void)xmppAutoPingDidSendPing:(XMPPAutoPing *)sender");
}
- (void)xmppAutoPingDidReceivePong:(XMPPAutoPing *)sender
{
    NSLog(@"- (void)xmppAutoPingDidReceivePong:(XMPPAutoPing *)sender");
}

- (void)xmppAutoPingDidTimeout:(XMPPAutoPing *)sender
{
    NSLog(@"- (void)xmppAutoPingDidTimeout:(XMPPAutoPing *)sender");
}
</code></pre>
]]></content>
  </entry>
  
</feed>
