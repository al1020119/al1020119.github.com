<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 项目实战 | iOS梦工厂]]></title>
  <link href="http://al1020119.github.io/blog/categories/xiang-mu-shi-zhan/atom.xml" rel="self"/>
  <link href="http://al1020119.github.io/"/>
  <updated>2015-12-10T21:40:55+08:00</updated>
  <id>http://al1020119.github.io/</id>
  <author>
    <name><![CDATA[iCocos]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[全屏返回（Runtime）]]></title>
    <link href="http://al1020119.github.io/blog/2015/11/06/quan-ping-fan-hui-(runtime)/"/>
    <updated>2015-11-06T02:51:33+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/11/06/quan-ping-fan-hui-(runtime)</id>
    <content type="html"><![CDATA[<blockquote><p>前言</p>

<p>此次文章，讲述的是导航控制器全屏滑动返回效果，而且代码量非常少，10行内搞定。</p></blockquote>

<p>如果喜欢我的文章，可以关注我，也可以来小码哥，了解下我们的iOS培训课程。陆续还会有更新ing&hellip;.</p>

<!--more-->


<h5>一、自定义导航控制器</h5>

<p>目的：以后需要使用全屏滑动返回功能，就使用自己定义的导航控制器。</p>

<h5>二、分析导航控制器侧滑功能</h5>

<p>效果：导航控制器默认自带了侧滑功能，当用户在界面的左边滑动的时候，就会有侧滑功能。</p>

<p>系统自带的侧滑效果：</p>

<p>分析：</p>

<ul>
<li><p>1.导航控制器的view自带了滑动手势，只不过手势的触发范围只能在左边。</p></li>
<li><p>2.当用户在界面左边拖动，就会触发滑动手势方法，并且有滑动返回功能，说明系统手势触发的方法已经实现了滑动返回功能。</p></li>
<li><p>3.为什么说系统手势触发的方法已经实现了滑动返回功能？</p></li>
</ul>


<h3>原因：</h3>

<p>创建滑动手势对象的时候，需要绑定监听者，当触发手势的时候会调用target的action。</p>

<p>UIPanGestureRecognizer *pan = [[UIPanGestureRecognizer alloc] initWithTarget:target action:action];
当用户在界面左边滑动，有滑动返回功能，这是因为触发手势了，调用target的action方法，说明action方法内部实现滑动返回功能，否则就不会有滑动返回效果。</p>

<h5>三、实现全屏滑动功能分析</h5>

<p>打印导航控制器自带的滑动手势，看下它的真实面目。</p>

<p>系统自带的滑动手势interactivePopGestureRecognizer</p>

<pre><code>//  self指向的导航控制器，在导航控制器的viewDidLoad方法打印 
- (void)viewDidLoad { 
    [super viewDidLoad]; 
    NSLog(@"%@",self.interactivePopGestureRecognizer); 
} 
</code></pre>

<p>由图中可知：</p>

<ul>
<li><p>1.系统自带的手势是UIScreenEdgePanGestureRecognizer类型对象,屏幕边缘滑动手势</p></li>
<li><p>2.系统自带手势target是_UINavigationInteractiveTransition类型的对象</p></li>
<li><p>3.target调用的action方法名叫handleNavigationTransition:</p></li>
</ul>


<p>分析：</p>

<p>UIScreenEdgePanGestureRecognizer，看名称就知道，这个手势的范围只能在屏幕的周边，就是因为这个手势，系统自带的滑动效果，只能实现侧边滑动。</p>

<h5>四、如何实现全屏滑动功能</h5>

<p>给自己的导航控制器，添加一个全屏的滑动手势，调用系统自带滑动手势的target的action方法，利用系统实现的滑动返回功能，加上自己全屏滑动手势，就有全屏滑动功能了。</p>

<p>问题：如何拿到系统自带的target对象?，action方法名已经知道，而且系统肯定在target对象实现了，只要拿到target对象，调用这个方法就行。</p>

<p>通过打印系统自带的滑动手势的代理，发现正好是_UINavigationInteractiveTransition对象，因此我猜测这个代理对象就是target对象,只要拿到它，就拿到系统自带滑动手势的target对象。</p>

<pre><code>// 打印系统自带滑动手势的代理对象 
SLog(@"%@",self.interactivePopGestureRecognizer.delegate); 
</code></pre>

<p>导航控制器全屏滑动注意点:</p>

<ul>
<li><p>1.禁止系统自带滑动手势使用。</p></li>
<li><p>2.只有导航控制器的非根控制器才需要触发手势，使用手势代理，控制手势触发。</p></li>
</ul>


<p>全屏滑动代码实现</p>

<pre><code>- (void)viewDidLoad { 
    [super viewDidLoad]; 
    // 获取系统自带滑动手势的target对象 
    id target = self.interactivePopGestureRecognizer.delegate; 
    // 创建全屏滑动手势，调用系统自带滑动手势的target的action方法 
    UIPanGestureRecognizer *pan = [[UIPanGestureRecognizer alloc] initWithTarget:target action:@selector(handleNavigationTransition:)]; 
    // 设置手势代理，拦截手势触发 
    pan.delegate = self; 
    // 给导航控制器的view添加全屏滑动手势 
    [self.view addGestureRecognizer:pan]; 
    // 禁止使用系统自带的滑动手势 
    self.interactivePopGestureRecognizer.enabled = NO; 
} 
// 什么时候调用：每次触发手势之前都会询问下代理，是否触发。 
// 作用：拦截手势触发 
- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer 
{ 
    // 注意：只有非根控制器才有滑动返回功能，根控制器没有。 
    // 判断导航控制器是否只有一个子控制器，如果只有一个子控制器，肯定是根控制器 
    if (self.childViewControllers.count == 1) { 
        // 表示用户在根控制器界面，就不需要触发滑动手势， 
        return NO; 
    } 
    return YES; 
} 
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[切换控制器]]></title>
    <link href="http://al1020119.github.io/blog/2015/09/22/qie-huan-kong-zhi-qi/"/>
    <updated>2015-09-22T02:51:10+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/09/22/qie-huan-kong-zhi-qi</id>
    <content type="html"><![CDATA[<p>从一个视图控制器切换到另一个视图控制器的几种方式</p>

<!--more-->


<h4>1,模态(modal)画面的显示方法：</h4>

<p>例如iphone通讯录管理程序中，追加新的通讯纪录时，就是使用这种模态画面
例：点击一个按钮，进入另一个界面
    - (IBAction)pressAbout:(id)sender {</p>

<pre><code>iCocosViewController *iCocos=[[[iCocosViewController alloc] initWithNibName:@"iCocosViewController" bundle:nil] autorelease];

[self presentModalViewController:aboutanimated:YES];//显示模态画面

关闭模态画面的方法：

[self dissmissModalViewControllerAnimationed:YES];
</code></pre>

<h4>2,SwitchViewController中有2个控制器的属性：BviewController,CViewController</h4>

<ul>
<li>使用方法：insertSubview: atIndex:
这种画面跳转方法并非最佳的跳转方法：</li>
<li>实际上并非真的实现了两个画面间的跳转，而是同时启动了2个画面，控制其中哪一个画面显示在前台，哪一个画面显示在后台而已。</li>
<li>这种画面跳转方式有一个很大的缺点，即当画面数量增加时，画面跳转的实现代码将月来越复杂，而且各个画面间不可避免的有相互依赖关系。</li>
</ul>


<h4>3,UITabBarController实现并列画面跳转（这里其实就是window的切花）</h4>

<pre><code>//将5个viewController实例放入TabBar的viewcontrollers属性中    

self.tabBarController.viewControllers = @[navFrist, navSecond,navThird,navFourth,navFifth];   

self.window.rootViewController = self.tabBarController;

[self.window addSubview:self.tabBarController.view];//将根控制器的视图加到应用程序主窗口
</code></pre>

<h4>4,UINavigationController实现多层画面跳转，在导航控制器中，载入有层级关系的界面</h4>

<pre><code>- (IBAction)addRightAction:(id)sender
{
    iCocosViewController *iCocos=[[[iCocosViewController alloc]initWithNibName:@"iCocosViewController" bundle:nil] autorelease];

[self.navigationController pushViewController:aiCocos animated:YES];
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ScrollView回到顶部复原]]></title>
    <link href="http://al1020119.github.io/blog/2015/08/21/scrollviewhui-dao-ding-bu-fu-yuan/"/>
    <updated>2015-08-21T02:33:00+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/08/21/scrollviewhui-dao-ding-bu-fu-yuan</id>
    <content type="html"><![CDATA[<p>相信细心的开发者都会发现scrollView自带一个功能,当用户点击顶部的状态栏时,scrollView的ContentOffset.y轴会自动滚动到初始位置,效果如图所示:</p>

<!--more-->


<blockquote><p>单个scrollView单击顶部状态栏系统自带功能展示</p></blockquote>

<p>这个功能对用户来说非常实用,尤其是在scrollView(TableView, WebView, CollectionView一切继承scrollView的控件)展示的内容很多,当用户翻看很久以后,想回到最顶部时,只需单击一下顶部的状态栏位置就可以轻松返回到顶部(这里吐槽下.貌似很多用户都不知道有这个功能),而不用使劲用手滑动到顶部.</p>

<ul>
<li>可是功能在当前控制器有多个scrollView(TableView, WebView, CollectionView一切继承scrollView的控件)的时候就会失效,效果如下图所示:</li>
</ul>


<p>当控制器内有多个scrollView时,系统自带的滚动到顶的功能就会失效</p>

<p>实际开发中,我们的产品在同一个控制器经常会有多个scrollView组合在一起的情况,这就意味着系统的方法已经失效了,需要开发人员自己来实现这个效果,下面我们就来搞定这个需求</p>

<blockquote><p>我们分析下原生的方法为什么会失效,当一个控制器内只有一个scrollView时,点击状态栏,系统会遍历当前keyWindow的子控件,发现子控件中只有一个scrollView会调用这个scrollView的setContentOffset: animated:的这个方法,将scrollView的contentOffset.y值修改为初始值,但是当子控件中又多个scrollView时,系统会不知道掉用哪一个scrollView而失效,知道这点我们就知道该如何搞定这个问题了</p></blockquote>

<p>这里就直接将解决思路一一写出来不将代码分段展示了,在代码中我加了详细的注释objective-c的套路和swift基本一样,在最后会将Swift和objective-c的代码一起放上,如果需要直接解决问题的童鞋可以直接将代码拷贝到工程里即可</p>

<ul>
<li>首先创建一个topWindow继承至NSObject,这里我们考虑将这个功能完全封装起来,所以所有的方法都用的类方法,所以用最基本的类就可以</li>
<li>在initialize方法中初始化topWIndow,将topWIndow的级别改成最高的UIWindowLevelAlert级别,设置topWindow位置,并且添加点击手势</li>
<li>在topWIndow被点击调用的方法中,我们拿出UIApplication的keyWindow,遍历keyWindow的所有子控件,如果满足是scrollView同时又显示在当前keyWindow条件时,将subView的contentOffset的y值回复到原始</li>
<li>然后采用递归的套路在遍历subView内时候有满足条件的子控件,直到没有满足条件时会停止</li>
</ul>


<h4>Swift的代码</h4>

<pre><code>import UIKit
class TopWindow: UIWindow {
    private static let window_: UIWindow = UIWindow()
    ///  类初始化方法,保证window_只被创建一次
    override class func initialize() {
        window_.frame = CGRectMake(0, 0, global.appWidth, 20)
        window_.windowLevel = UIWindowLevelAlert
        window_.addGestureRecognizer(UITapGestureRecognizer(target: self, action: "topWindowClick"))
    }
    class func topWindowClick() {
        // 遍历当前主窗口所有view,将满足条件的scrollView滚动回原位
        searchAllowScrollViewInView(UIApplication.sharedApplication().keyWindow!)
    }
    private class func searchAllowScrollViewInView(superView: UIView) {
        for subview: UIView in superView.subviews as! [UIView] {
            if subview.isKindOfClass(UIScrollView.self) &amp;&amp; superView.viewIsInKeyWindow() {
                // 拿到scrollView的contentOffset
                var offest = (subview as! UIScrollView).contentOffset
                // 将offest的y轴还原成最开始的值
                offest.y = -(subview as! UIScrollView).contentInset.top
                // 重新设置scrollView的内容
                (subview as! UIScrollView).setContentOffset(offest, animated: true)
            }
            // 递归,让子控件再次调用这个方法判断时候还有满足条件的view
            searchAllowScrollViewInView(subview)
        }
    }
    ///  添加topWindow,使手势生效
    class func showTopWindow() {
        window_.hidden = false
    }
    ///  隐藏topWindow,移除手势
    class func hiddenTopWindow() {
        window_.hidden = true
    }
}
///  对UIView的一个扩展
extension UIView {
    ///  判断调用方法的view是否在keyWindow中
    func viewIsInKeyWindow() -&gt; Bool {
        let keyWindow = UIApplication.sharedApplication().keyWindow!
        // 将当前view的坐标系转换到window.bounds
        let viewNewFrame = keyWindow.convertRect(self.frame, fromView: self.superview)
        let keyWindowBounds = keyWindow.bounds
        // 判断当前view是否在keyWindow的范围内
        let isIntersects = CGRectIntersectsRect(viewNewFrame, keyWindowBounds)
        // 判断是否满足所有条件
        return !self.hidden &amp;&amp; self.alpha &gt; 0.01 &amp;&amp; self.window == keyWindow &amp;&amp; isIntersects
    }   
}
</code></pre>

<p>在AppDelegate里,程序启动完成方法时添加就OK了</p>

<pre><code>  func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -&gt; Bool {
      // 添加顶部的window
      TopWindow.showTopWindow()
      return true
  }
</code></pre>

<p>需要注意添加了自定义的window后,控制器的改变状态栏状态方法会失效,可以在info.plist中将改变状态栏的管理权交给UIApplication解决,或者在需要改变状态栏的控制器中调用TopWindow.hiddenTopWindow()即可,或者直接改info.plist,用UIApplication.sharedApplication().setStatusBarStyle来管理</p>

<h4>Objective-C代码</h4>

<p>.h文件只暴露显示和隐藏方法</p>

<pre><code>#import @interface WNXTopWindow : NSObject
+ (void)show;
+ (void)hide;
@end
</code></pre>

<p>.m文件</p>

<pre><code>#import "WNXTopWindow.h"
@implementation WNXTopWindow
static UIWindow *window_;
//初始化window
+ (void)initialize {
  window_ = [[UIWindow alloc] init];
  window_.frame = CGRectMake(0, 0, [UIScreen mainScreen].bounds.size.width, 20);
  window_.windowLevel = UIWindowLevelAlert;
  [window_ addGestureRecognizer:[[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(windowClick)]];
}  
+ (void)show {
  window_.hidden = NO;
}
+ (void)hide {
  window_.hidden = YES;
}
// 监听窗口点击
+ (void)windowClick {
  UIWindow *window = [UIApplication sharedApplication].keyWindow;
  [self searchScrollViewInView:window];
}
+ (void)searchScrollViewInView:(UIView *)superview {
  for (UIScrollView *subview in superview.subviews) {
      // 如果是scrollview, 滚动最顶部
      if ([subview isKindOfClass:[UIScrollView class]] &amp;&amp; [subview isShowingOnKeyWindow]) {
          CGPoint offset = subview.contentOffset;
          offset.y = - subview.contentInset.top;
          [subview setContentOffset:offset animated:YES];
      }
      // 递归继续查找子控件
      [self searchScrollViewInView:subview];
  }
}
+ (BOOL)isShowingOnKeyWindow:(UIView *)view {
  // 主窗口
  UIWindow *keyWindow = [UIApplication sharedApplication].keyWindow;
  // 以主窗口左上角为坐标原点, 计算self的矩形框
  CGRect newFrame = [keyWindow convertRect:view.frame fromView:view.superview];
  CGRect winBounds = keyWindow.bounds;
  // 主窗口的bounds 和 self的矩形框 是否有重叠
  BOOL intersects = CGRectIntersectsRect(newFrame, winBounds);
  return !view.isHidden &amp;&amp; view.alpha &gt; 0.01 &amp;&amp; view.window == keyWindow &amp;&amp; intersects;
}
@end
</code></pre>

<p>同样,也是在程序初始化完成AppDelegate文件中显示topWindow,整个工程这个问题就统统解决了</p>

<pre><code>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
  // 添加一个window, 点击这个window, 可以让屏幕上的scrollView滚到最顶部
  [WNXTopWindow show];
  return YES;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SVN实战总结]]></title>
    <link href="http://al1020119.github.io/blog/2015/07/02/svnshi-zhan-zong-jie/"/>
    <updated>2015-07-02T22:44:29+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/07/02/svnshi-zhan-zong-jie</id>
    <content type="html"><![CDATA[<ul>
<li>A：add，新增</li>
<li>C：conflict，冲突</li>
<li>D：delete，删除</li>
<li>M：modify，本地已经修改</li>
<li>G：modify and merGed，本地文件修改并且和服务器的进行合并</li>
<li>U：update，从服务器更新</li>
<li>R：replace，从服务器替换</li>
<li>I：ignored，忽略</li>
</ul>


<p>常见提示图标：</p>

<h6>黄色感叹号(有冲突):</h6>

<pre><code>--这是有冲突了，冲突就是说你对某个文件进行了修改，别人也对这个文件进行了修改，别人抢在你提交之前先提交了，这时你再提交就会被提示发生冲突，而不允许你提交，防止你的提交覆盖了别人的修改。要解决冲突，如果你确认你的修改是无效的，则用TSVN还原你的修改就行了；如果认为你的修改是正确的，别人的提交是无效的，那么用TSVN先标记为“解决冲突”，然后就可以提交了；如果你认为你的修改和别人的修改都有一部分是有效的，那么你就把别人的修改手动合并到你的修改中，然后使用TSVN标注为“解决冲突”，然后就可以提交了。进入文件夹，寻找有黄色感叹号的文件，这些文件就是发生冲突的地方，根据实际情况处理冲突
</code></pre>

<!--more-->


<h6>米字号(有本地修改代码)：</h6>

<pre><code>--这是说明你有未提交的本地代码。
</code></pre>

<h6>问好(新加入的资源):</h6>

<pre><code>--这说明该文件是项目中新增文件资源，新增资源可以是文件、图片、代码等。
</code></pre>

<h6>红色感叹号(本地代码与库没有保持一致)：</h6>

<pre><code>--这说明本地代码跟库上没有保持一致，如果用户想修复，可以将带红色感叹号图标文件删除，直接update即可。
</code></pre>

<h6>灰色向右箭头(本地修改过)</h6>

<pre><code>--本地代码没有及时上库。
</code></pre>

<h6>蓝色向左箭头(SVN上修改过)</h6>

<pre><code>--记得更新代码后修改，提交前跟svn对比习惯。
</code></pre>

<h6>灰色向右且中间有个加号的箭头(本地比SVN上多出的文件)</h6>

<pre><code>--修改完记得跟svn保持一致
</code></pre>

<h6>蓝色向左且中间有个加号的箭头(SVN上比本地多出的文件)</h6>

<pre><code>--删除该文件后，再次更新，将svn上文件全部更新下来。
</code></pre>

<h6>灰色向右且中间有个减号的箭头(本地删除了,而SVN上未删除的文件)</h6>

<pre><code>--也就是说你删除确认后，一定要记得上库，跟svn保持一致
</code></pre>

<h6>蓝色向左且中间有个减号的箭头(SVN上删除了,而本地未删除的文件)</h6>

<pre><code>--比对svn库上代码，确定需要删除后，更新svn(删除无用代码)。
</code></pre>

<h6>红色双向箭头(SVN上修改过,本地也修改过的文件 )</h6>

<pre><code>--这个表示本地和svn上都修改过，最好就是把本地修改合并到svn，修改代码前最后先更新。
</code></pre>

<h4>版本回退</h4>

<ul>
<li><p>本地版本回退：</p>

<ul>
<li>右键选中对应的项目或者文件，弹出菜单中选中Revert</li>
<li>提示你当前工程有一些修改，但是还没提交，"Discard XXX"-点击后当前修改的内容会被取消，“Copy XXX”-点击会会先复制一份代码到废纸篓</li>
<li>点击 “Discard XXX”后，本地工程已更新至选择的版本，如果想将服务器上的也更新到选择的版本，可以再commit。</li>
</ul>
</li>
<li><p>服务器版本回退：误将错误的文件上传到了svn服务器，回滚的办法是：</p>

<ul>
<li>1：svn merge -r100:99 .  （注意有个点，表示当前路径）</li>
<li>2：svn ci -m &ldquo;revert version&rdquo; . （代码提交，实际上删除之前误传的文件）</li>
</ul>
</li>
</ul>


<h4>.a（库文件）</h4>

<ul>
<li>首先打开软件左上角 CornerStone-Preferences-SubVersion</li>
<li>第一个地方把对号去掉，第二个地方把.a那个删除，然后save。</li>
<li>然后把你的.a文件放到本地的相应文件夹下，</li>
<li>但是 CornerStone（我的是v2.7.10 版本的） 里相应文件夹下看不到带问号的.a文件的话，点击上边 View-Show Ignored  Items</li>
<li>到这里就ok了，选中你的静态库 点击底部Add 问号会变成A，然后就可以提交了。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[字典转模型深究]]></title>
    <link href="http://al1020119.github.io/blog/2015/05/01/zi-dian-zhuan-mo-xing-shen-jiu/"/>
    <updated>2015-05-01T02:33:18+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/05/01/zi-dian-zhuan-mo-xing-shen-jiu</id>
    <content type="html"><![CDATA[<blockquote><p>引言：
在文字开始之前先介绍两个软件：</p></blockquote>

<h5>JSONExport</h5>

<p><img src="/images/zidianzhuanmoxin005.png" title="Caption" ></p>

<h5>JSON Accelerator</h5>

<p><img src="/images/zidianzhuanmoxin006.png" title="Caption" ></p>

<blockquote><p>关于模型类的两个神器，我也是刚接触不久，但是感觉非常有用，基本上可以节省你在模型类上的99%的时间。</p></blockquote>

<ul>
<li>如果你觉得自己对应本文后面的内容非常了解，那么请直接下载上面的软件试试。</li>
<li>如果你并不是很熟练，那么轻认真看完后面的内容，相信对你有好处，再去下载对应的软件。</li>
</ul>


<p>关于Plist转模型在iOS开发中是非常常见的，每开一一个项目或者实现一个功能都要用到它，所以今天就给大家讲讲Plist怎么转成模型数据，</p>

<blockquote><p>前提：必须有一个Plist文件或者通过一定的方式返回的plist数据</p></blockquote>

<!--more-->


<h2>一：直接加载Plist数据</h2>

<p><img src="/images/zidianzhuanmoxin001.png" title="Caption" ></p>

<pre><code>定义一个数组属性 
@property (nonatomic, assign) NSArray *apps; 
</code></pre>

<h6>获取Plist文件</h6>

<pre><code>//懒加载plist文件，返回一个apps数据，后面直接使用旧可以
-(NSArray *)apps
{
    if (_apps == nil) {
        _apps = [NSArray arrayWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@"iCocos.plist" ofType:nil]];
    }
    return _apps;
}
</code></pre>

<h6>加载Plsit中的数据</h6>

<pre><code>    //取出数组中对应的数据放到一个字典里面
    NSDictionary *dic = self.apps[i];


    //创建一个UIImageView
    UIImageView *icon = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, iW, 50)];
    /**
     取出字典中的icon
    */
     icon.image = [UIImage imageNamed:dic[@"icon"]];

    [view addSubview:icon];



    //创建一个Label
    UILabel *l = [[UILabel alloc] initWithFrame:CGRectMake(0, CGRectGetMaxY(icon.frame), iW, 20)];
    /**
     取出字典中的label
     */
    l.text = dic[@"label"];

    [view addSubview:l];



    //创建一个按钮
    UIButton *btn = [[UIButton alloc] initWithFrame:CGRectMake(0, CGRectGetMaxY(l.frame), iW, 20)];
    /**
     取出字典中的btn
     */
    [btn setTitle:dic[@"btn"] forState:UIControlStateNormal];

    [view addSubview:btn];
</code></pre>

<h2>二：使用简单的模型加载Plist数据</h2>

<p><img src="/images/zidianzhuanmoxin002.png" title="Caption" ></p>

<pre><code> 1 //定义一个数组属性

  2 @property (nonatomic, assign) NSArray *apps; 
</code></pre>

<h6>在模型中定义模型对应的属性</h6>

<pre><code>@property (nonatomic, copy) NSString *icon;


@property (nonatomic, copy) NSString *label;


@property (nonatomic, copy) NSString *btn;
</code></pre>

<h6>模型方法</h6>

<pre><code>/**
 模型数据方法
 */
+(instancetype)messageWithDict:(NSDictionary *)dict;


-(instancetype)initWithDict:(NSDictionary *)dict;
</code></pre>

<h6>模型的实现文件</h6>

<pre><code>/**
 模型数据方法的实现
 */

+ (instancetype)messageWithDict:(NSDictionary *)dict
{
    return [[self alloc] initWithDict:dict];
}

- (instancetype)initWithDict:(NSDictionary *)dict
{
    if (self = [super init]) {
        [self setValuesForKeysWithDictionary:dict];
    }
    return self;
}
</code></pre>

<h6>实用模型加载Plist文件</h6>

<pre><code>/**
 模型数据的加载，返回arry以后我们就只要使用array就能使用这个模型类里面的数据也就是使用plist数据
 */
//懒加载plist文件，返回一个apps数据，后面直接使用旧可以
-(NSMutableArray *)apps
{
    if (_apps == nil) {
        NSArray *array = [NSArray arrayWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@"iCocos.plist" ofType:nil]];

        NSMutableArray *arrayApps = [NSMutableArray array];

        for (NSDictionary *dic in array) {
            appsModel *model = [[appsModel alloc] init];
            model.label = dic[@"label"];
            model.btn = dic[@"btn"];
            model.icon = dic[@"icon"];

            [arrayApps addObject:model];
        }
        _apps = arrayApps;
    }
    return _apps;
}
</code></pre>

<h6>加载模型中对应的plist数据</h6>

<pre><code>    //取出数组中对应的数据放到一个字典里面
    appsModel *app = self.apps[i];


    //创建一个UIImageView
    UIImageView *icon = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, iW, 50)];
    /**
     取出字典中的icon
     */
    icon.image = [UIImage imageNamed:app.icon];
    [view addSubview:icon];



    //创建一个Label
    UILabel *l = [[UILabel alloc] initWithFrame:CGRectMake(0, CGRectGetMaxY(icon.frame), iW, 20)];
    /**
     取出字典中的label
     */
    l.text = app.label;
    [view addSubview:l];



    //创建一个按钮
    UIButton *btn = [[UIButton alloc] initWithFrame:CGRectMake(0, CGRectGetMaxY(l.frame), iW, 20)];
    /**
     取出字典中的btn
     */
    [btn setTitle:app.btn forState:UIControlStateNormal];
    [view addSubview:btn];
</code></pre>

<h5>注：上面是plist中的属性和模型中定义的属性一一对应的时候的，如果不是一一对应我们就要将模型一个一个的赋值与实现</h5>

<pre><code>- (instancetype)initWithDict:(NSDictionary *)dict
{
self = [super init];
if (self) {
    self.label = dict[@"label"];
    self.btn = dict[@"btn"];
    self.icon = dict[@"icon"];

//[self setValue:dict[@"label"] forKeyPath:@"label"];

    //封装
    [self setValuesForKeysWithDictionary:dict];
}

return self;
}
</code></pre>

<p>/<em>*
 模型数据的加载，返回arry以后我们就只要使用array就能使用这个模型类里面的数据也就是使用plist数据
 </em>/</p>

<pre><code>//懒加载plist文件，返回一个apps数据，后面直接使用旧可以
-(NSMutableArray *)apps
{
    if (_apps == nil) {
        NSArray *array = [NSArray arrayWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@"iCocos.plist" ofType:nil]];

        NSMutableArray *arrayApps = [NSMutableArray array];

        for (NSDictionary *dic in array) {
//            appsModel *model = [[appsModel alloc] initWithDict:dic];
            appsModel *model = [appsModel appsWithDict:dic];

            [arrayApps addObject:model];
        }
        _apps = arrayApps;
    }
    return _apps;
}
</code></pre>

<h6>我们也可以讲加载模型的代码进行封装，这样更加简单的实现模式数据的的使用</h6>

<p>在模型中定义并且实现一个模型封装的方法</p>

<pre><code>+(NSArray *)appList
{
        NSArray *array = [NSArray arrayWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@"iCocos.plist" ofType:nil]];

        NSMutableArray *arrayApps = [NSMutableArray array];

        for (NSDictionary *dic in array) {
            //            appsModel *model = [[appsModel alloc] initWithDict:dic];
            appsModel *model = [appsModel appsWithDict:dic];

            [arrayApps addObject:model];
    }
    return arrayApps;

}
</code></pre>

<h6>实用的时候只要直接使用封装好的模型方法就可以：</h6>

<pre><code>/**
 模型数据的加载，返回arry以后我们就只要使用array就能使用这个模型类里面的数据也就是使用plist数据
 */
//懒加载plist文件，返回一个apps数据，后面直接使用旧可以
-(NSArray *)apps
{
    if (_apps == nil) {

        _apps = [appsModel appList];
    }
    return _apps;
}
</code></pre>

<h2>三：复杂Plist转模型</h2>

<p>有的时候我们会遇到Plist中还有更小一级的节点和属性这个时候我们就需要更复杂的模型来加载，但是实用起来并不复杂</p>

<p>比如Plist中海油一个friends这歌子模型</p>

<p><img src="/images/zidianzhuanmoxin003.png" title="Caption" ></p>

<h6>那么我转模型的时候就可以根据plist中的数据进行处理，</h6>

<h6>首先我们一一般都是从子模型开始，我们就先定义子模型</h6>

<pre><code>/**
 根据plist里面存在的子列中的数据再创建一个模型数据
 */

/**
 设置子模型数据的属性
 */

@property (nonatomic, assign) NSString *icon;

@property (nonatomic, assign) NSString *intro;

@property (nonatomic, assign) NSString *name;

@property (nonatomic, assign, getter=isVip)BOOL vip;


/**
 子模型数据的方法
 */
+ (instancetype)friendWithDict:(NSDictionary *)dict;

- (instancetype)initWithDict:(NSDictionary *)dict;
</code></pre>

<h6>子模型的实现</h6>

<pre><code>/**
 子模型数据的方法de实现
 */

+ (instancetype)friendWithDict:(NSDictionary *)dict
{
    return [[self alloc] initWithDict:dict];
}

- (instancetype)initWithDict:(NSDictionary *)dict
{
    if (self = [super init]) {
        [self setValuesForKeysWithDictionary:dict];
    }
    return self;
}
</code></pre>

<h6>然后就是根模型</h6>

<pre><code>/**
 根据plist中的数据创建一个模型数据
 */

/**
 设置模型数据的中的属性
 */

@property (nonatomic, assign) NSArray *friends;

@property (nonatomic, copy) NSString *name;

@property (nonatomic, assign) NSNumber *online;

/**
 模型数据的方法
 */

+ (instancetype)groupWithDict:(NSDictionary *)dict;


- (instancetype)initWithDict:(NSDictionary *)dict;
</code></pre>

<h6>根模型的实现，这里只需要在根模型加载需要实现的子模型酒可以</h6>

<pre><code>/**
 模型数据的方法的实现
 */

+ (instancetype)groupWithDict:(NSDictionary *)dict
{
    return [[self alloc] initWithDict:dict];
}

- (instancetype)initWithDict:(NSDictionary *)dict
{
    if (self = [super init]) {
        [self setValuesForKeysWithDictionary:dict];

        NSMutableArray *friendArray = [NSMutableArray array];
        for (NSDictionary *dict in self.friends) {
            FriendsPlistChildren *friend = [FriendsPlistChildren friendWithDict:dict];
            [friendArray addObject:friend];
        }
        self.friends = friendArray;
    }
    return self;
}
</code></pre>

<h6>使用模型数据，方法还是和之前一样的，不需要去处理子模型，因为我们在跟模型里面已经处理好了</h6>

<pre><code>/**
 加载模型数据的方法
 */

- (NSArray *)groups
{
    if (_groups == nil) {
        NSArray *dictArray = [NSArray arrayWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@"friends.plist" ofType:nil]];

        NSMutableArray *groupArray = [NSMutableArray array];
        for (NSDictionary *dict in dictArray) {
            FirendsPlistRoot *group = [FirendsPlistRoot groupWithDict:dict];
            [groupArray addObject:group];
        }

        _groups = groupArray;
    }
    return _groups;
}
</code></pre>

<h2>四：使用第三份库</h2>

<p>在iOS届有一个神人不知道大家知不知道————他叫李明杰，他（MJ）不仅技术牛逼，而且对天朝iOS界的贡献也是无法用语言来形容的，如果你是老一辈的iOS开发者倒是很正常，如果你只是刚开始学习iOS或者学习iOS不久你都不知道或者没有听过这个名字那么就可以说明你真的out了，甚至说你你根本没有用心在学，关于这个神人我就不做多介绍了，如果你想知道更多，请点击www.520it.com</p>

<p>今天我就使用他的一个NB的框架来实现plist转模型数据，这个框架使用起来非常简单，一行代码就可以搞定你想的功能，</p>

<p>首先你需要去github上面下载这个框架：<a href="https://github.com/CoderMJLee/MJExtension">MJExtension</a></p>

<p>下载好了之后直接讲MJExtension拖到你的项目</p>

<p><img src="/images/zidianzhuanmoxin004.png" title="Caption" ></p>

<h6>首先根据plist数据新建对应的模型数据</h6>

<p>这里我一新浪微博中的小部分做测试</p>

<pre><code>#import "User.h"
#import "Status.h"
#import "StatusResult.h"

/**
 *  微博文本内容
 */
@property (copy, nonatomic) NSString *text;

/**
 *  微博作者
 */
@property (strong, nonatomic) User *user;

/**
 *  转发的微博
 */
@property (strong, nonatomic) Status *retweetedStatus;
/**
 *  存放着某一页微博数据（里面都是Status模型）
 */
@property (strong, nonatomic) NSMutableArray *statuses;

/**
 *  总数
 */
@property (assign, nonatomic) NSNumber *totalNumber;

/**
 *  上一页的游标
 */
@property (assign, nonatomic) long long previousCursor;

/**
 *  下一页的游标
 */
@property (assign, nonatomic) long long nextCursor;
/**
 *  名称
 */
@property (copy, nonatomic) NSString *name;

/**
 *  头像
 */
@property (copy, nonatomic) NSString *icon;
</code></pre>

<h6>下面就是证明去使用这个框架实现你想要的功能了，这里介绍了几乎你开发中需要用到的所有方法和例子，</h6>

<pre><code>/**
 MJ友情提醒：
 1.MJExtension是一套“字典和模型之间互相转换”的轻量级框架
 2.MJExtension能完成的功能
 * 字典 --&gt; 模型
 * 模型 --&gt; 字典
 * 字典数组 --&gt; 模型数组
 * 模型数组 --&gt; 字典数组
 3.具体用法主要参考 main.m中各个函数 以及 "NSObject+MJKeyValue.h"
 4.希望各位大神能用得爽
 */

#import &lt;Foundation/Foundation.h&gt;
#import "MJExtension.h"
#import "User.h"
#import "Status.h"
#import "StatusResult.h"

/**
 *  简单的字典 -&gt; 模型
 */
void keyValues2object()
{
    // 1.定义一个字典
    NSDictionary *dict = @{
                           @"name" : @"Jack",
                           @"icon" : @"lufy.png",
                           };

    // 2.将字典转为User模型
    User *user = [User objectWithKeyValues:dict];

    // 3.打印User模型的属性
    NSLog(@"name=%@, icon=%@", user.name, user.icon);
}

/**
 *  复杂的字典 -&gt; 模型 (模型里面包含了模型)
 */
void keyValues2object2()
{
    // 1.定义一个字典
    NSDictionary *dict = @{
                           @"text" : @"是啊，今天天气确实不错！",

                           @"user" : @{
                                   @"name" : @"Jack",
                                   @"icon" : @"lufy.png"
                                   },

                           @"retweetedStatus" : @{
                                   @"text" : @"今天天气真不错！",

                                   @"user" : @{
                                           @"name" : @"Rose",
                                           @"icon" : @"nami.png"
                                           }
                                   }
                           };

    // 2.将字典转为Status模型
    Status *status = [Status objectWithKeyValues:dict];

    // 3.打印status的属性
    NSString *text = status.text;
    NSString *name = status.user.name;
    NSString *icon = status.user.icon;
    NSLog(@"text=%@, name=%@, icon=%@", text, name, icon);

    // 4.打印status.retweetedStatus的属性
    NSString *text2 = status.retweetedStatus.text;
    NSString *name2 = status.retweetedStatus.user.name;
    NSString *icon2 = status.retweetedStatus.user.icon;
    NSLog(@"text2=%@, name2=%@, icon2=%@", text2, name2, icon2);
}

/**
 *  复杂的字典 -&gt; 模型 (模型的数组属性里面又装着模型)
 */
void keyValues2object3()
{
    // 1.定义一个字典
    NSDictionary *dict = @{
                           @"statuses" : @[
                                   @{
                                       @"text" : @"今天天气真不错！",

                                       @"user" : @{
                                               @"name" : @"Rose",
                                               @"icon" : @"nami.png"
                                               }
                                       },

                                   @{
                                       @"text" : @"明天去旅游了",

                                       @"user" : @{
                                               @"name" : @"Jack",
                                               @"icon" : @"lufy.png"
                                               }
                                       },

                                   @{
                                       @"text" : @"嘿嘿，这东西不错哦！",

                                       @"user" : @{
                                               @"name" : @"Jim",
                                               @"icon" : @"zero.png"
                                               }
                                       }

                                   ],

                           @"totalNumber" : @"2014",

                           @"previousCursor" : @"13476589",

                           @"nextCursor" : @"13476599"
                           };

    // 2.将字典转为StatusResult模型
    StatusResult *result = [StatusResult objectWithKeyValues:dict];

    // 3.打印StatusResult模型的简单属性
    NSLog(@"totalNumber=%d, previousCursor=%lld, nextCursor=%lld", result.totalNumber, result.previousCursor, result.nextCursor);

    // 4.打印statuses数组中的模型属性
    for (Status *status in result.statuses) {
        NSString *text = status.text;
        NSString *name = status.user.name;
        NSString *icon = status.user.icon;
        NSLog(@"text=%@, name=%@, icon=%@", text, name, icon);
    }
}

/**
 *  字典数组 -&gt; 模型数组
 */
void keyValuesArray2objectArray()
{
    // 1.定义一个字典数组
    NSArray *dictArray = @[
                           @{
                               @"name" : @"Jack",
                               @"icon" : @"lufy.png",
                               },

                           @{
                               @"name" : @"Rose",
                               @"icon" : @"nami.png",
                               },

                           @{
                               @"name" : @"Jim",
                               @"icon" : @"zero.png",
                               }
                           ];

    // 2.将字典数组转为User模型数组
    NSArray *userArray = [User objectArrayWithKeyValuesArray:dictArray];

    // 3.打印userArray数组中的User模型属性
    for (User *user in userArray) {
        NSLog(@"name=%@, icon=%@", user.name, user.icon);
    }
}

/**
 *  模型 -&gt; 字典
 */
void object2keyValues()
{
    // 1.新建模型
    User *user = [[User alloc] init];
    user.name = @"Jack";
    user.icon = @"lufy.png";

    Status *status = [[Status alloc] init];
    status.user = user;
    status.text = @"今天的心情不错！";

    // 2.将模型转为字典
    //    NSDictionary *dict = [status keyValues];
    NSDictionary *dict = status.keyValues;
    NSLog(@"%@", dict);
}

/**
 *  模型数组 -&gt; 字典数组
 */
void objectArray2keyValuesArray()
{
    // 1.新建模型数组
    User *user1 = [[User alloc] init];
    user1.name = @"Jack";
    user1.icon = @"lufy.png";

    User *user2 = [[User alloc] init];
    user2.name = @"Rose";
    user2.icon = @"nami.png";

    User *user3 = [[User alloc] init];
    user3.name = @"Jim";
    user3.icon = @"zero.png";

    NSArray *userArray = @[user1, user2, user3];

    // 2.将模型数组转为字典数组
    NSArray *dictArray = [User keyValuesArrayWithObjectArray:userArray];
    NSLog(@"%@", dictArray);
}

int main(int argc, const char * argv[])
{
    @autoreleasepool {
        // 简单的字典 -&gt; 模型
        keyValues2object();

        // 复杂的字典 -&gt; 模型 (模型里面包含了模型)
        keyValues2object2();

        // 复杂的字典 -&gt; 模型 (模型的数组属性里面又装着模型)
        keyValues2object3();

        // 字典数组 -&gt; 模型数组
        keyValuesArray2objectArray();

        // 模型转字典
        object2keyValues();

        // 模型数组 -&gt; 字典数组
        objectArray2keyValuesArray();
    }
    return 0;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
