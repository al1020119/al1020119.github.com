<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 性能相关 | iOS梦工厂]]></title>
  <link href="http://al1020119.github.io/blog/categories/xing-neng-xiang-guan/atom.xml" rel="self"/>
  <link href="http://al1020119.github.io/"/>
  <updated>2015-12-01T03:10:31+08:00</updated>
  <id>http://al1020119.github.io/</id>
  <author>
    <name><![CDATA[iCocos]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[够逼格的注释习惯]]></title>
    <link href="http://al1020119.github.io/blog/2015/12/03/you-xiu-cheng-xu-yuan-shi-zen-yao-xie-zhu-shi-de/"/>
    <updated>2015-12-03T02:59:30+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/12/03/you-xiu-cheng-xu-yuan-shi-zen-yao-xie-zhu-shi-de</id>
    <content type="html"><![CDATA[<p>够逼格的注释习惯总结</p>

<p>首先关于注意这里就不说什么VVDocument了，来点新鲜的！</p>

<h6>也许你使用过#warning 警告提示</h6>

<h6>也许你也使用过#pragma marks。</h6>

<p>但是你见过或者使用过下面这个吗？</p>

<pre><code>Comments containing:
MARK:
TODO:
FIXME:
!!!:
???:
</code></pre>

<p>没有，那么你就快速的看看下面的内容，非常好用，也非常简单，不过具体使用看个人</p>

<p> 首先说一下三个最常用的：</p>

<ul>
<li>1、TODO</li>
</ul>


<p> 等待实现的功能</p>

<ul>
<li>2、FIXME</li>
</ul>


<p> 需要修正的功能</p>

<ul>
<li>3、！！！</li>
</ul>


<p> 需要改进的功能</p>

<p>具体使用</p>

<pre><code>// FIXME:sss
/* FIXME: sss */


// MARK:sss
/* MARK:sss */


// !!!:sss
/* !!!: sss */


// ???:sss
/* ???: sss */


// TODO:sss
/* TODO: sss */


// Comments containing: sss
/* Comments containing: sss */
</code></pre>

<p>注意空格.</p>

<p> 最后你会发现下面的效果，虽然和#pragma marks没有什么区别，但是这就是装逼原因</p>

<p>关于最后一个/<em> Comments containing: sss </em>/，笔者还没照发对应的使用方法，如果你知道可以联系我哦！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[消除警告]]></title>
    <link href="http://al1020119.github.io/blog/2015/12/02/xiao-chu-jing-gao/"/>
    <updated>2015-12-02T02:51:46+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/12/02/xiao-chu-jing-gao</id>
    <content type="html"><![CDATA[<h6>前言：</h6>

<p>现在你维护的项目有多少警告？看着几百条警告觉得心里烦么？你真的觉得警告又不是错误可以完全不管么？ 如果你也被这些问题困惑，可以和我一起进行下面的操作。其实大部分的警告都是很好改的，把自己整个项目的警告撸一遍应该也就耗费半小时的时间，一次麻烦带来之后的清净这样不好么？</p>

<p>本文分为三个部分：</p>

<ul>
<li>1.简单粗暴的消除警告。</li>
<li>2.详细科学的消除警告。（包括警告收录）</li>
<li>3.添加警告。</li>
</ul>


<h4>一、简单粗暴的消除警告</h4>

<p>警告如果是自己项目中的还好直接改了，如果是第三方库，你改了之后，pod下作者更新一下又白改了，所以可以用这种简单粗暴的方法：直接让第三方库的警告不显示</p>

<p> 就是在podfile文件里面加上一行指令 。
inhibit_all_warnings!
如果某警告实在无法消除，但是又不想让他显示，可以加入预编译指令</p>

<p>比如我已经知道某行会报上面警告了，我就用这个宏把这几行包住，就不会报引号中-Wunused-variable的警告了</p>

<pre><code>#pragma clang diagnostic push
#pragma clang diagnostic ignored"-Wunused-variable" //这里是会报警告的代码

#pragma clang diagnostic pop
</code></pre>

<p>这个-Wunused-variable代表的意思就是 有的东西 你实例化了但是没有使用（同上面第几条）。 但是如何得到一个警告的标示符？</p>

<ol>
<li><p>如图选择一个警告，点击右键，reveal in log  就能看到右边有个方括号[]里面的东西就是 这个警告对应的标示符</p></li>
<li><p>如果希望整个项目中都忽略 某种很无聊的警告，就在项目中Build Setting里加上这个标示符，可以连着加的。</p></li>
<li><p>如果不想整个项目都忽略，只想个别文件忽略，那就找到个别文件加上此指令，这个操作应该使用率不高（一般都是全项目忽略），就不上图了。去Build Phases 里面的 Compile Sources里面改。</p></li>
</ol>


<h4>二、详细科学的消除警告</h4>

<p>其实笔者本意是想把一些第一眼看不懂比较坑的警告收录进来，但是后来发现那基本没几个需要些写了，所以就采用了全收录的方法，遇到的就记录下以后也会不断更新。 可以直接按command+F 在本页面搜索警告</p>

<pre><code>Unused variable 'replyURL'
</code></pre>

<h6>1.没有使用</h6>

<pre><code>Cannot find protocol definition for 'TencentSessionDelegate'
</code></pre>

<h6>2.这种明明都能运行还说我没有定义的警告，是因为你这个协议虽然定义了，但是你这个协议可能还遵守了XX协议，然后这个XX协议没有定义导致会报这种警告，所以遇到这种警告要往“父协议”找。 举个栗子，上面这行就是腾讯授权的库里面报的警告，</h6>

<pre><code>@protocol TencentSessionDelegate
此协议遵守了TencentApiInterfaceDelegate协议，在TencentOAuth.h类中#import "TencentApiInterface.h" 警告可破


Null passed to a callee that requires a non-null argument
</code></pre>

<h6>3.这个警告比较新，是xcode6.3开始 为了让OC也能有swift的？和！的功能，你在声明一个属性的时候加上 <strong>nullable（？可以为空）与</strong>nonnull（！不能为空） 如果放在@property里面的话不用写下划线</h6>

<pre><code>@property (nonatomic, copy, nonnull) NSString * tickets;
@property (nonatomic, copy) NSString * __nonnull tickets;
</code></pre>

<p>或者用宏NS_ASSUME_NONNULL_BEGIN和NS_ASSUME_NONNULL_END 包住多个属性全部具备nonnull，然后仅对需要nullable的改下就行，有点类似于f-no-objc-arc那种先整体给个路线在单独改个别文件的思想。 此警告就是某属性说好的不能为空，你又在某地方写了XX = nil 所以冲突了。</p>

<pre><code>Auto property synthesis will not synthesize property 'privateCacheDirectory'; it will be implemented by its superclass, use @dynamic to acknowledge intention
</code></pre>

<h6>4.他说你的父类实现了setget方法，但是如果你什么都不写，就会系统自动生成出最一般的setget方法，请用@dynamic 来承认父类实现的这个getset方法。</h6>

<pre><code>Unsupported Configuration: Scene is unreachable due to lack of entry points and does not have an identifier for runtime access via -instantiateViewControllerWithIdentifier:.
</code></pre>

<h6>5.一般是storyboard报的警告，简而言之就是你有的页面没有和箭头所指的控制器连起来，导致最终改页面可能无法显示。</h6>

<pre><code>Deprecated: Push segues are deprecated in iOS 8.0 and later
</code></pre>

<h6>6.iOS8之后呢，不要再用push拖线了，统一用show，他会自己根据你是否有导航栏来判断走push还是走modal</h6>

<pre><code>Unsupported Configuration: Plain Style unsupported in a Navigation Item
</code></pre>

<h6>7.导航栏的item 不支持用plain ，那就用Bordered呗。</h6>

<pre><code>The launch image set "LaunchImage" has 2 unassigned images.
The app icon set "AppIcon" has 2 unassigned images.
</code></pre>

<h6>8.几张图标还是启动图找不到自己的位置，可能是一次导入了全部尺寸图片，但是右边的设置只勾了iOS8的 那iOS7尺寸的图标就会报此警告。删掉，或者对照右边匹配。</h6>

<pre><code>'sizeWithFont:constrainedToSize:lineBreakMode:' is deprecated: first deprecated in iOS 7.0 - Use -boundingRectWithSize:options:attributes:context:
</code></pre>

<h6>9.方法废除，旧的方法sizeWithFontToSize在iOS7后就废除了取而代之是boundingRectWithSize方法</h6>

<pre><code>Undeclared selector 'historyAction'
</code></pre>

<h6>10.使用未声明的方法，一般出现在@selector() 括号里写了个不存在的方法或方法名写错了。</h6>

<pre><code>PerformSelector may cause a leak because its selector is unknown
</code></pre>

<h6>11.这个和上面类似就是直接把上面那个@SEL拿来用会报这个警告</h6>

<pre><code>'strongify' macro redefined
</code></pre>

<h6>12.这个宏声明重复,删一个吧</h6>

<pre><code>'UITextAttributeFont' is deprecated: first deprecated in iOS 7.0 - Use NSFontAttributeName
'UITextAttributeTextColor' is deprecated: first deprecated in iOS 7.0 - Use NSForegroundColorAttributeName
'UITextAttributeTextShadowColor' is deprecated: first deprecated in iOS 7.0 - Use NSShadowAttributeName with an NSShadow instance as the value
</code></pre>

<h6>13.方法废除,一般一起出现</h6>

<pre><code>Code will never be executed
</code></pre>

<h6>14.他说这代码永远也轮不到他执行，估计是有几行代码写在了return之后</h6>

<pre><code>Assigning to 'id' from incompatible type 'SXTabViewController *const __strong'
</code></pre>

<h6>15.一般出现在xxx.delegate = self ，应该在上面遵守协议</h6>

<pre><code>Format specifies type 'unsigned long' but the argument has type 'unsigned int'
</code></pre>

<h6>16.这个警告一般会出现在NSStringWithFormat里面 前面%d %lu 什么的和后面填进去的参数不匹配就报了警告</h6>

<pre><code>Values of type 'NSInteger' should not be used as format arguments; add an explicit cast to 'long' instead
</code></pre>

<h6>17.类似于上面，也是format里面前后写的不匹配</h6>

<pre><code>Method 'dealWithURL:andTitle:andKeyword:' in protocol 'SXPostAdDelegate' not implemented
</code></pre>

<h6>18.经典警告，遵守了协议，但是没有实现协议方法。 也可能你实现了只是又加了个参数或是你写的方法和协议方法名字有点轻微不同</h6>

<pre><code>Using integer absolute value function 'abs' when argument is of floating point type
</code></pre>

<h6>19.这个可以自动修正，就是说abs适用于整数绝对值，要是float取绝对值要用fabsf</h6>

<pre><code>Attribute Unavailable: Automatic Preferred Max Layout Width is not available on iOS versions prior to 8.0
</code></pre>

<h6>20.有的方法你用的太落后了，也有的方法你用的太超前了。 说这个最大宽度在iOS8之前的系统是要坑的</h6>

<pre><code>Too many personality routines for compact unwind to encode
</code></pre>

<h6>21.你可以在otherlink 中加入 -Wl,-no_compact_unwind 去掉该警告，根据苹果的解释，这个是由于某些地方 c/c++/oc/oc++混用会造成编译警告。一般没有什么伤害。</h6>

<pre><code>Property 'ssid' requires method 'ssid' to be defined - use @synthesize, @dynamic or provide a method implementation in this class implementation
</code></pre>

<h6>22.说这个ssid必须要定义个这个属性的getter方法，如果警告是setSsid就是setter方法， 用@synthesize和@dynamic 都行，一个是让编译器生成getter和setter，一个是自己生成，如果你有模型分发或kvc之类的，选@dynamic就行</h6>

<pre><code>Unknown escape sequence '\)'
</code></pre>

<h6>23.未知的转义序列。 一般有个斜杠再加个东西他都会以为是转义字符，一看\）不认识就报警告了，一般正则表达式容易报这种警告</h6>

<pre><code>Property 'LoginPort' not found on object of type 'LoginLvsTestTask *'; did you mean to access property loginPort?
</code></pre>

<h6>24.这种可以点击自动修复，是典型的大小写写错了，他提醒了一下。</h6>

<pre><code>Variable 'type' is used uninitialized whenever switch default is taken
</code></pre>

<h6>25.这是出现在switch语句中的警告， 一般可能是switch外面定义了个type但是并没有初始化（初始化操作都写在switch的各个分支里），然后在最后return type。 但是switch的有个分支没有对type初始化，他说如果你来到这个分支的话，那还没初始化就要被return。</h6>

<h5>三、添加警告</h5>

<h6>1.首先最常用的就是 普通警告，这也没什么好说的了</h6>

<pre><code>#warning TODO
</code></pre>

<h6>2.如果是自己写的文件或第三方库，有了新的接口，然后提示旧的接口废除的话需要在方法后加上宏NS_DEPRECATED_IOS和范围</h6>

<pre><code>- (void)addTapAction:(SEL)tapAction target:(id)target NS_DEPRECATED_IOS(2_0, 4_0);
</code></pre>

<h6>3.如果需要在此方法后加上带信息的警告则需要这么写</h6>

<pre><code>- (void)addTapAction:(SEL)tapAction target:(id)target __attribute((deprecated("这个接口会爆内存 不建议使用")));
</code></pre>

<p>显示的效果像这样：</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UITableView性能优化与卡顿问题]]></title>
    <link href="http://al1020119.github.io/blog/2015/11/29/uitableviewxing-neng-you-hua-yu-qia-dun-wen-ti/"/>
    <updated>2015-11-29T00:19:52+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/11/29/uitableviewxing-neng-you-hua-yu-qia-dun-wen-ti</id>
    <content type="html"><![CDATA[<p>引言：</p>

<p>在iOS开发中关于TableView算是已经用烂了的控件，但是又有几个人认真去考路过他的性能优化问题（卡顿）</p>

<p>最近项目中也遇到了不少卡顿的问题，为了更好的饿提高项目的性能，也为了提高自己的技术，专门花了一段时间研究了一下关于TableView的性能问题，在这里就总结了一下，希望可以帮你解决实际问题。</p>

<p>1.最常用的就是cell的重用， 注册重用标识符</p>

<pre><code>如果不重用cell时，每当一个cell显示到屏幕上时，就会重新创建一个新的cell
如果有很多数据的时候，就会堆积很多cell。如果重用cell，为cell创建一个ID
每当需要显示cell 的时候，都会先去缓冲池中寻找可循环利用的cell，如果没有再重新创建cell
设置正确的reuseIdentifer以重用cell
</code></pre>

<p>2.避免cell的重新布局</p>

<pre><code>cell的布局填充等操作 比较耗时，一般创建时就布局好
如可以将cell单独放到一个自定义类，初始化时就布局好
</code></pre>

<p>3.提前计算并缓存cell的属性及内容</p>

<pre><code>在cellForRowAtIndexPath:中尽量做更少的操作。如果需要做一些处理，那么最好做过一次之后，就将结果缓存起来。
当我们创建cell的数据源方法时，编译器并不是先创建cell 再定cell的高度
而是先根据内容一次确定每一个cell的高度，高度确定后，再创建要显示的cell，滚动时，每当cell进入凭虚都会计算高度，提前估算高度告诉编译器，编译器知道高度后，紧接着就会创建cell，这时再调用高度的具体计算方法，这样可以方式浪费时间去计算显示以外的cell
</code></pre>

<p>4.减少cell中控件的数量</p>

<pre><code>尽量使cell得布局大致相同，不同风格的cell可以使用不用的重用标识符，初始化时添加控件，
不适用的可以先隐藏
</code></pre>

<p>5.不要使用ClearColor，无背景色，透明度也不要设置为0</p>

<pre><code>渲染耗时比较长
尽量将view设置为不透明，包括cell本身。
</code></pre>

<p>6.使用局部更新</p>

<pre><code>如果只是更新某组的话，使用reloadSection进行局部更新
</code></pre>

<p>7.加载网络数据，下载图片，使用异步加载，并缓存</p>

<pre><code>如果cell显示的内容来此网络，那么确保这些内容是通过异步来获取的
</code></pre>

<p>8.少使用addView 给cell动态添加view</p>

<p>9.按需加载cell，cell滚动很快时，只加载范围内的cell</p>

<pre><code>注意正确使用懒加载
</code></pre>

<p>10.不要实现无用的代理方法，tableView只遵守两个协议</p>

<pre><code>非必要的代理或者数据源方法可以省略，比如numberofsention
</code></pre>

<p>11.缓存行高：</p>

<pre><code>如果row的高度不相同，那么将其缓存下来
estimatedHeightForRow不能和HeightForRow里面的layoutIfNeed同时存在，这两者同时存在才会出现“窜动”的bug。所以我的建议是：只要是固定行高就写预估行高来减少行高调用次数提升性能。如果是动态行高就不要写预估方法了，用一个行高的缓存字典来减少代码的调用次数即可
</code></pre>

<p>12.避免渐变，图像缩放以及离屏绘制</p>

<p>13.使用shadowPath来设置阴影。</p>

<p>14.使用适当的数据结构来保存需要的信息。不同的结构会带来不同的操作代价。</p>

<p>15.使用rowHeight, sectionFooterHeight 和 sectionHeaderHeight 来设置一个恒定 高度，而不要从delegate中获取。</p>

<hr />

<p>参考：相关性能优化问题</p>

<p><a href="http://www.cocoachina.com/ios/20150408/11501.html">iOS应用性能调优的25个建议和技巧</a></p>
]]></content>
  </entry>
  
</feed>
