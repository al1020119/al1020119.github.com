
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>iOSå¼€å‘â€”â€”å¸¸ç”¨åŠŸèƒ½ä»£ç é›†é”¦ï¼ˆå‹ç§€ç¯‡ï¼‰ - iOSæ¢¦å·¥å‚</title>
  <meta name="author" content="iCocos">

  
  <meta name="description" content="æœ¬æ¬¡æ€»ç»“ï¼Œæ˜¯å› ä¸ºä¸€æ¬¡ä¸Šçº¿Appè¢«æ‹’ä¹‹åçš„å†²åŠ¨ï¼Œå› ä¸ºæœ‰ä¸€ä¸ªåŠŸèƒ½ä»£ç è‡ªå·±ä¹‹å‰ç»å¸¸å†™ï¼Œä½†æ˜¯å†™å¤šäº†å°±å¿«ï¼Œæå¾—æ‰‹é€Ÿç»ƒå¾—è¶…å¿«ï¼ˆä¸è¦æƒ³æ±¡å’¯å“¦ğŸ˜‚ï¼‰ï¼Œæ‰€ä»¥å†™çš„æ—¶å€™å°±æ²¡æœ‰å¤šæƒ³ï¼Œä¹Ÿæ²¡æœ‰æ‰¾æ‰¾ä¹‹å‰çš„ä»£ç ï¼Œç»“æœå¯¼è‡´æ‚²å‚¬çš„ç»“å±€ã€‚ ä¹‹å‰æ²¡æœ‰æ•´ç†è¿‡é¡¹ç›®ä¸­é‡åˆ°æˆ–è€…å†™è¿‡ï¼Œæˆ–è€…ç»å¸¸è¦ç”¨çš„ä»£ç ï¼Œå¯èƒ½è§‰å¾—å¤šå†™å‡ éå°±æ²¡äº‹äº†ï¼Œæˆ–è€…ç½‘ä¸Šä¸€æ‰¾å°±æœ‰äº† &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://al1020119.github.io/blog/2016/10/16/ioskai-fa-chang-yong-gong-neng-dai-ma-ji-jin-(you-xiu-pian-)/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="iOSæ¢¦å·¥å‚" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//libs.baidu.com/jquery/1.7.2/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->

<!--<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
-->
  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">iOSæ¢¦å·¥å‚</a></h1>
  
    <h2>iCocosâ€”â€”ä¸æˆ˜èƒœè‡ªå·±ï¼Œä½•ä»¥æ”¹å˜æœªæ¥ï¼</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="al1020119.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">åšæ–‡</a></li>
  <li><a href="/blog/archives">å½’æ¡£</a></li>
  <li><a href="/icocos">iCocos</a></li>
  <li><a href="/year">å¹´ç»ˆ</a></li>
  <li><a href="/other">å…¶ä»–</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">iOSå¼€å‘â€”â€”å¸¸ç”¨åŠŸèƒ½ä»£ç é›†é”¦ï¼ˆå‹ç§€ç¯‡ï¼‰</h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-10-16T12:47:16+08:00'><span class='date'><span class='date-month'>Oct</span> <span class='date-day'>16</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>12:47 pm</span></time>
        
        
        |   <a href="#comments">Comments</a>
        
      </p>
    
  </header>


<div class="entry-content"><p>æœ¬æ¬¡æ€»ç»“ï¼Œæ˜¯å› ä¸ºä¸€æ¬¡ä¸Šçº¿Appè¢«æ‹’ä¹‹åçš„å†²åŠ¨ï¼Œå› ä¸ºæœ‰ä¸€ä¸ªåŠŸèƒ½ä»£ç è‡ªå·±ä¹‹å‰ç»å¸¸å†™ï¼Œä½†æ˜¯å†™å¤šäº†å°±å¿«ï¼Œæå¾—æ‰‹é€Ÿç»ƒå¾—è¶…å¿«ï¼ˆä¸è¦æƒ³æ±¡å’¯å“¦ğŸ˜‚ï¼‰ï¼Œæ‰€ä»¥å†™çš„æ—¶å€™å°±æ²¡æœ‰å¤šæƒ³ï¼Œä¹Ÿæ²¡æœ‰æ‰¾æ‰¾ä¹‹å‰çš„ä»£ç ï¼Œç»“æœå¯¼è‡´æ‚²å‚¬çš„ç»“å±€ã€‚</p>

<p>ä¹‹å‰æ²¡æœ‰æ•´ç†è¿‡é¡¹ç›®ä¸­é‡åˆ°æˆ–è€…å†™è¿‡ï¼Œæˆ–è€…ç»å¸¸è¦ç”¨çš„ä»£ç ï¼Œå¯èƒ½è§‰å¾—å¤šå†™å‡ éå°±æ²¡äº‹äº†ï¼Œæˆ–è€…ç½‘ä¸Šä¸€æ‰¾å°±æœ‰äº†ã€‚å¯æ˜¯äº‹å®å¹¶éå¦‚æœï¼Œé¦–å…ˆï¼Œç½‘ä¸Šæ‰¾çš„æ°¸è¿œä¸æ˜¯ä½ çš„ã€‚å…¶æ¬¡ï¼Œå†™å¾—å†å¤šè¿˜æ˜¯æœ‰ç²—å¿ƒæˆ–è€…æ³¨æ„ä¸åˆ°çš„åœ°æ–¹ã€‚æœ€åï¼Œæ•´ç†æˆè‡ªå·±çš„èƒ½æœ€å¿«é€Ÿåº¦çš„æ‰¾åˆ°å¹¶å®ç°ï¼Œæé«˜æ•ˆç‡ã€‚ä½•ä¹è€Œä¸ä¸ºå‘¢ï¼Ÿ</p>

<p>å¥½äº†ï¼ŒåºŸè¯ä¸å¤šè¯´ï¼Œç†è®ºä¹Ÿæ²¡æœ‰ï¼Œå¤§éƒ¨åˆ†åªè¦ä¸¤ä¸ªæ“ä½œï¼šcopy-pasteã€‚æœ‰äº›è¿˜æ˜¯éœ€è¦åšå°å°çš„æ”¹åŠ¨çš„ï¼Œæ ¹æ®é¡¹ç›®éœ€æ±‚ã€‚</p>

<!--more-->


<ol>
<li>å–æ¶ˆtableViewå¤´éƒ¨å’Œåº•éƒ¨æ‚¬æµ®æ•ˆæœ</li>
<li>è·å–éšæœºæ•°</li>
<li>å»é™¤tableViewåˆ†ç»„å¤´éƒ¨å¤šä½™é—´è·</li>
<li>å›¾ç‰‡æˆªå–</li>
<li>æ¨¡ç³Šå›¾ç‰‡</li>
<li>è·å–æ–‡ä»¶å¤§å°</li>
<li>æ‰‹æœºå·éªŒè¯</li>
<li>é‚®ç®±éªŒè¯</li>
<li>ç½‘å€éªŒè¯</li>
<li>JSONè½¬å­—å…¸</li>
<li>iPhoneè®¾å¤‡ç±»å‹åˆ¤æ–­</li>
<li>iPhoneç³»ç»Ÿç‰ˆæœ¬åˆ¤æ–­</li>
<li>æ—¥å¿—æ‰“å°</li>
<li>é¢œè‰²è·å–</li>
<li>å¼±å¼•ç”¨</li>
<li>è·å–å±å¹•å°ºå¯¸</li>
<li>è·å–viewçš„æ§åˆ¶</li>
<li>å­—å…¸é˜²å´©æºƒ</li>
<li>æ•°ç»„é˜²å´©æºƒ</li>
<li>æœ¬æ–‡è¾“å…¥é”™è¯¯æç¤º</li>
<li>è·å–å½“å‰æ—¶é—´</li>
<li>è·å–å½“å‰ç‰ˆæœ¬</li>
<li>tabBarçº¢ç‚¹æ˜¾ç¤º</li>
<li>Logæ—¥å¿—.m</li>
<li>MD5åŠ å¯†</li>
<li>æŒ‰é’®èƒŒæ™¯é¢œè‰²</li>
<li>åˆ¤æ–­å¯¹è±¡æ˜¯å¦ä¸ºç©º</li>
<li>é”®ç›˜é€€å‡ºä¸éšè—é€šçŸ¥</li>
<li>è·å–è®¾å¤‡å”¯ä¸€ID</li>
<li>MOVè½¬Mp4</li>
<li>ä¸Šä¼ å›¾ç‰‡</li>
<li>ä¸Šä¼ è§†é¢‘</li>
<li>è·å–è§†é¢‘å¸§å›¾</li>
<li>å‹ç¼©å¹¶å¯¼å‡ºè§†é¢‘</li>
<li>ä¿å­˜è§†é¢‘åˆ°ç›¸å†Œ</li>
<li>è·å–å½“å‰æœ€é¡¶å±‚çš„ViewController</li>
<li>æ•°ç»„æ‹†åˆ†</li>
<li>å›¾ç‰‡å‹ç¼©</li>
<li><p>é‡Šæ”¾timerå®</p></li>
<li><p>å…¶ä»–</p></li>
</ol>


<!--more-->


<h2>1ï¼šå–æ¶ˆtableViewå¤´éƒ¨å’Œåº•éƒ¨æ‚¬æµ®æ•ˆæœ</h2>

<pre><code>- (void)scrollViewDidScroll:(UIScrollView *)scrollView {  
    CGFloat sectionHeaderHeight = 10; //è¿™é‡Œæ˜¯æˆ‘çš„headerViewå’ŒfooterViewçš„é«˜åº¦  
    if (_tableView.contentOffset.y&lt;=sectionHeaderHeight&amp;&amp;_tableView.contentOffset.y&gt;=0) {  
        _tableView.contentInset = UIEdgeInsetsMake(-_tableView.contentOffset.y, 0, 0, 0);  
    } else if (_tableView.contentOffset.y&gt;=sectionHeaderHeight) {  
        _tableView.contentInset = UIEdgeInsetsMake(-sectionHeaderHeight, 0, 0, 0);  
    }  
}  


    -(void)scrollViewDidScroll:(UIScrollView *)scrollView {

    if (scrollView == self.tableView)

        {

        UITableView *tableview = (UITableView *)scrollView;

        CGFloat sectionHeaderHeight = 64;

        CGFloat sectionFooterHeight = 120;

        CGFloat offsetY = tableview.contentOffset.y;

        if (offsetY &gt;= 0 &amp;&amp; offsetY &lt;= sectionHeaderHeight)

        {

            tableview.contentInset = UIEdgeInsetsMake(-offsetY, 0, -sectionFooterHeight, 0);

        }else if (offsetY &gt;= sectionHeaderHeight &amp;&amp; offsetY &lt;= tableview.contentSize.height - tableview.frame.size.height - sectionFooterHeight)

        {

            tableview.contentInset = UIEdgeInsetsMake(-sectionHeaderHeight, 0, -sectionFooterHeight, 0);

        }else if (offsetY &gt;= tableview.contentSize.height - tableview.frame.size.height - sectionFooterHeight &amp;&amp; offsetY &lt;= tableview.contentSize.height - tableview.frame.size.height)         {

            tableview.contentInset = UIEdgeInsetsMake(-offsetY, 0, -(tableview.contentSize.height - tableview.frame.size.height - sectionFooterHeight), 0);

        }

    }

}
</code></pre>

<h2>2ï¼šè·å–éšæœºæ•°</h2>

<pre><code>//ç¬¬ä¸€ç§
srand((unsigned)time(0)); //ä¸åŠ è¿™å¥æ¯æ¬¡äº§ç”Ÿçš„éšæœºæ•°ä¸å˜
int i = rand() % 5;
//ç¬¬äºŒç§
srandom(time(0));
int i = random() % 5;
//ç¬¬ä¸‰ç§
int i = arc4random() % 5 ; 
</code></pre>

<h2>3ï¼šå»é™¤tableViewåˆ†ç»„å¤´éƒ¨å¤šä½™é—´è·</h2>

<h4>ä¸€ï¼š</h4>

<pre><code>- (void)viewDidLoad {
    [super viewDidLoad];

    self.tableView.tableHeaderView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 0, CGFLOAT_MIN)];
}
</code></pre>

<h4>äºŒï¼š</h4>

<pre><code>- (void)viewWillAppear:(BOOL)animated{

    [super viewWillAppear:animated];

    CGRect frameH = self.tableView.tableHeaderView.frame;
    frameH.size.height = 5;
    UIView *headerView = [[UIView alloc] initWithFrame:frameH];
    [self.tableView setTableHeaderView:headerView];


    CGRect frameF = self.tableView.tableHeaderView.frame;
    frameF.size.height = 1;
    UIView *footerView = [[UIView alloc] initWithFrame:frameF];
    [self.tableView setTableFooterView:footerView];

}
</code></pre>

<h2>4ï¼šå›¾ç‰‡æˆªå–</h2>

<pre><code>CGSize itemSize = CGSizeMake(self.image.size.width, self.image.size.height);

dispatch_async(dispatch_get_global_queue(0, 0), ^{

    UIImage *dynamicCellImage = [UIImage imageWithData:[NSData dataWithContentsOfURL:[NSURL URLWithString:model.cover]]];
            UIGraphicsBeginImageContextWithOptions(itemSize, NO, [UIScreen mainScreen].scale);

            //å‹ç¼©å›¾ç‰‡
            CGSize newSize;
            CGImageRef imageRef = nil;

            if ((dynamicCellImage.size.width / dynamicCellImage.size.height) &lt; (self.image.size.width / self.image.size.height)) {
                newSize.width = dynamicCellImage.size.width;
                newSize.height = dynamicCellImage.size.width * self.image.size.height / self.image.size.width;

                imageRef = CGImageCreateWithImageInRect([dynamicCellImage CGImage], CGRectMake(0, fabs(dynamicCellImage.size.height - newSize.height) / 2, newSize.width, newSize.height));

            } else {
                newSize.height = dynamicCellImage.size.height;
                newSize.width = dynamicCellImage.size.height * self.image.size.width / self.image.size.height;

                imageRef = CGImageCreateWithImageInRect([dynamicCellImage CGImage], CGRectMake(fabs(dynamicCellImage.size.width - newSize.width) / 2, 0, newSize.width, newSize.height));
            }

            dispatch_async(dispatch_get_main_queue(), ^{
                self.image.image = [UIImage imageWithCGImage:imageRef];
            });

            UIGraphicsEndImageContext();

});
</code></pre>

<h2>5ï¼šæ¨¡ç³Šå›¾ç‰‡</h2>

<pre><code>//åŠ æ¨¡ç³Šæ•ˆæœï¼Œimageæ˜¯å›¾ç‰‡ï¼Œbluræ˜¯æ¨¡ç³Šåº¦
+ (UIImage *)blurryImage:(UIImage *)image withBlurLevel:(CGFloat)blur {
    //æ¨¡ç³Šåº¦,
    if ((blur &lt; 0.1f) || (blur &gt; 2.0f)) {
        blur = 0.5f;
    }

    //boxSizeå¿…é¡»å¤§äº0
    int boxSize = (int)(blur * 100);
    boxSize -= (boxSize % 2) + 1;
//    iCocosLog(@"boxSize:%i",boxSize);
    //å›¾åƒå¤„ç†
    CGImageRef img = image.CGImage;

    //å›¾åƒç¼“å­˜,è¾“å…¥ç¼“å­˜ï¼Œè¾“å‡ºç¼“å­˜
    vImage_Buffer inBuffer, outBuffer;
    vImage_Error error;
    //åƒç´ ç¼“å­˜
    void *pixelBuffer;

    //æ•°æ®æºæä¾›è€…ï¼ŒDefines an opaque type that supplies Quartz with data.
    CGDataProviderRef inProvider = CGImageGetDataProvider(img);
    // providerâ€™s data.
    CFDataRef inBitmapData = CGDataProviderCopyData(inProvider);

    //å®½ï¼Œé«˜ï¼Œå­—èŠ‚/è¡Œï¼Œdata
    inBuffer.width = CGImageGetWidth(img);
    inBuffer.height = CGImageGetHeight(img);
    inBuffer.rowBytes = CGImageGetBytesPerRow(img);
    inBuffer.data = (void*)CFDataGetBytePtr(inBitmapData);

    //åƒæ•°ç¼“å­˜ï¼Œå­—èŠ‚è¡Œ*å›¾ç‰‡é«˜
    pixelBuffer = malloc(CGImageGetBytesPerRow(img) * CGImageGetHeight(img));

    outBuffer.data = pixelBuffer;
    outBuffer.width = CGImageGetWidth(img);
    outBuffer.height = CGImageGetHeight(img);
    outBuffer.rowBytes = CGImageGetBytesPerRow(img);


    // ç¬¬ä¸‰ä¸ªä¸­é—´çš„ç¼“å­˜åŒº,æŠ—é”¯é½¿çš„æ•ˆæœ
    void *pixelBuffer2 = malloc(CGImageGetBytesPerRow(img) * CGImageGetHeight(img));
    vImage_Buffer outBuffer2;
    outBuffer2.data = pixelBuffer2;
    outBuffer2.width = CGImageGetWidth(img);
    outBuffer2.height = CGImageGetHeight(img);
    outBuffer2.rowBytes = CGImageGetBytesPerRow(img);


    //Convolves a region of interest within an ARGB8888 source image by an implicit M x N kernel that has the effect of a box filter.
    error = vImageBoxConvolve_ARGB8888(&amp;inBuffer, &amp;outBuffer2, NULL, 0, 0, boxSize, boxSize, NULL, kvImageEdgeExtend);
    error = vImageBoxConvolve_ARGB8888(&amp;outBuffer2, &amp;inBuffer, NULL, 0, 0, boxSize, boxSize, NULL, kvImageEdgeExtend);
    error = vImageBoxConvolve_ARGB8888(&amp;inBuffer, &amp;outBuffer, NULL, 0, 0, boxSize, boxSize, NULL, kvImageEdgeExtend);

    if (error) {
        iCocosLog(@"error from convolution %ld", error);
    }

    //    iCocosLog(@"å­—èŠ‚ç»„æˆéƒ¨åˆ†ï¼š%zu",CGImageGetBitsPerComponent(img));
    //é¢œè‰²ç©ºé—´DeviceRGB
    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    //ç”¨å›¾ç‰‡åˆ›å»ºä¸Šä¸‹æ–‡,CGImageGetBitsPerComponent(img),7,8
    CGContextRef ctx = CGBitmapContextCreate(
                                             outBuffer.data,
                                             outBuffer.width,
                                             outBuffer.height,
                                             8,
                                             outBuffer.rowBytes,
                                             colorSpace,
                                             CGImageGetBitmapInfo(image.CGImage));

    //æ ¹æ®ä¸Šä¸‹æ–‡ï¼Œå¤„ç†è¿‡çš„å›¾ç‰‡ï¼Œé‡æ–°ç»„ä»¶
    CGImageRef imageRef = CGBitmapContextCreateImage (ctx);
    UIImage *returnImage = [UIImage imageWithCGImage:imageRef];

    //clean up
    CGContextRelease(ctx);
    CGColorSpaceRelease(colorSpace);

    free(pixelBuffer);
    free(pixelBuffer2);
    CFRelease(inBitmapData);

    CGColorSpaceRelease(colorSpace);
    CGImageRelease(imageRef);

    return returnImage;
}
</code></pre>

<h2>6ï¼šæ–‡ä»¶å¤§å°</h2>

<pre><code>/**
 *  é€šå¸¸ç”¨äºåˆ é™¤ç¼“å­˜çš„æ—¶ï¼Œè®¡ç®—ç¼“å­˜å¤§å°
 */
//å•ä¸ªæ–‡ä»¶çš„å¤§å°
+ (long long) fileSizeAtPath:(NSString*) filePath{
    NSFileManager* manager = [NSFileManager defaultManager];
    if ([manager fileExistsAtPath:filePath]){
        return [[manager attributesOfItemAtPath:filePath error:nil] fileSize];
    }
    return 0;
}
</code></pre>

<h2>7ï¼šæ‰‹æœºå·</h2>

<pre><code>/**
 *  æ‰‹æœºå·åˆ¤æ–­
 *
 *  @param mobileNum å·ç å­—ç¬¦ä¸²
 *
 *  @return BOOL
 */
+ (BOOL)isMobileNumber:(NSString *)mobileNum
{
        /**
         * ç§»åŠ¨å·æ®µæ­£åˆ™è¡¨è¾¾å¼
         */
        NSString *CM_NUM = @"^((13[4-9])|(147)|(15[0-2,7-9])|(178)|(18[2-4,7-8]))\\d{8}|(1705)\\d{7}$";
        /**
         * è”é€šå·æ®µæ­£åˆ™è¡¨è¾¾å¼
         */
        NSString *CU_NUM = @"^((13[0-2])|(145)|(15[5-6])|(176)|(18[5,6]))\\d{8}|(1709)\\d{7}$";
        /**
         * ç”µä¿¡å·æ®µæ­£åˆ™è¡¨è¾¾å¼
         */
        NSString *CT_NUM = @"^((133)|(153)|(177)|(18[0,1,9]))\\d{8}$";

        NSPredicate *pred1 = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", CM_NUM];
        BOOL isMatch1 = [pred1 evaluateWithObject:mobileNum];
        NSPredicate *pred2 = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", CU_NUM];
        BOOL isMatch2 = [pred2 evaluateWithObject:mobileNum];
        NSPredicate *pred3 = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", CT_NUM];
        BOOL isMatch3 = [pred3 evaluateWithObject:mobileNum];

        if (isMatch1 || isMatch2 || isMatch3) {
            return YES;
        }else{
            return NO;
        }
}
</code></pre>

<h2>8ï¼šé‚®ç®±</h2>

<h4>é€šè¿‡åŒºåˆ†å­—ç¬¦ä¸²</h4>

<pre><code>-(BOOL)validateEmail:(NSString*)email

{

    if((0 != [email rangeOfString:@"@"].length) &amp;&amp;

       (0 != [email rangeOfString:@"."].length))

    {

        NSCharacterSet* tmpInvalidCharSet = [[NSCharacterSet alphanumericCharacterSet] invertedSet];

        NSMutableCharacterSet* tmpInvalidMutableCharSet = [[tmpInvalidCharSet mutableCopy] autorelease];

        [tmpInvalidMutableCharSet removeCharactersInString:@"_-"];





        NSRange range1 = [email rangeOfString:@"@"

                                      options:NSCaseInsensitiveSearch];



        //å–å¾—ç”¨æˆ·åéƒ¨åˆ†

        NSString* userNameString = [email substringToIndex:range1.location];

        NSArray* userNameArray   = [userNameString componentsSeparatedByString:@"."];



        for(NSString* string in userNameArray)

        {

            NSRange rangeOfInavlidChars = [string rangeOfCharacterFromSet: tmpInvalidMutableCharSet];

            if(rangeOfInavlidChars.length != 0 || [string isEqualToString:@""])

                return NO;

        }



        //å–å¾—åŸŸåéƒ¨åˆ†

        NSString *domainString = [email substringFromIndex:range1.location+1];

        NSArray *domainArray   = [domainString componentsSeparatedByString:@"."];



        for(NSString *string in domainArray)

        {

            NSRange rangeOfInavlidChars=[string rangeOfCharacterFromSet:tmpInvalidMutableCharSet];

            if(rangeOfInavlidChars.length !=0 || [string isEqualToString:@""])

                return NO;

        }



        return YES;

    }

    else {

       return NO;

    }

}
</code></pre>

<h4>åˆ©ç”¨æ­£åˆ™è¡¨è¾¾å¼éªŒè¯</h4>

<pre><code>-(BOOL)isValidateEmail:(NSString *)email {

    NSString *emailRegex = @"[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,4}"; 

    NSPredicate *emailTest = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", emailRegex]; 

    return [emailTest evaluateWithObject:email];

}
</code></pre>

<h2>9ï¼šç½‘å€</h2>

<h4>1.é¦–å…ˆè¿›è¡Œç¬¬ä¸€æ­¥åˆ¤æ–­ä¼ å…¥çš„å­—ç¬¦ä¸²æ˜¯å¦ç¬¦åˆHTTPè·¯å¾„çš„è¯­æ³•è§„åˆ™,å³â€<a href="HTTPS://%E2%80%9D">HTTPS://%E2%80%9D</a> æˆ– â€œ<a href="HTTP://%E2%80%9D">HTTP://%E2%80%9D</a> ,ä»å°è£…çš„ä¸€ä¸ªå‡½æ•°,ä¼ å…¥å³å¯åˆ¤æ–­</h4>

<pre><code>- (NSURL *)smartURLForString:(NSString *)str
{
    NSURL *     result;
    NSString *  trimmedStr;
    NSRange     schemeMarkerRange;
    NSString *  scheme;

    assert(str != nil);

    result = nil;

    trimmedStr = [str stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceCharacterSet]];
    if ( (trimmedStr != nil) &amp;&amp; (trimmedStr.length != 0) ) {
        schemeMarkerRange = [trimmedStr rangeOfString:@"://"];

        if (schemeMarkerRange.location == NSNotFound) {
            result = [NSURL URLWithString:[NSString stringWithFormat:@"http://%@", trimmedStr]];
        } else {
            scheme = [trimmedStr substringWithRange:NSMakeRange(0, schemeMarkerRange.location)];
            assert(scheme != nil);

            if ( ([scheme compare:@"http"  options:NSCaseInsensitiveSearch] == NSOrderedSame)
                || ([scheme compare:@"https" options:NSCaseInsensitiveSearch] == NSOrderedSame) ) {
                result = [NSURL URLWithString:trimmedStr];
            } else {
                // It looks like this is some unsupported URL scheme.
            }
        }
    }

    return result;
}
</code></pre>

<h4>ç¬¬äºŒæ­¥,åˆ¤æ–­æ­¤è·¯å¾„æ˜¯å¦èƒ½å¤Ÿè¯·æ±‚æˆåŠŸ,ç›´æ¥è¿›è¡ŒHTTPè¯·æ±‚,è§‚å¯Ÿè¿”å›ç»“æœ-></h4>

<pre><code>//åˆ¤æ–­
-(void) validateUrl: (NSURL *) candidate {
    NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:candidate];
    [request setHTTPMethod:@"HEAD"];
    NSURLSession *session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]];
    NSURLSessionDataTask *task = [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {
        NSLog(@"error %@",error);
        if (error) {
            NSLog(@"ä¸å¯ç”¨");
        }else{
            NSLog(@"å¯ç”¨");
        }
    }];
    [task resume];
}
</code></pre>

<h2>10ï¼šJSONè½¬å­—å…¸</h2>

<pre><code>/*!
 * @brief æŠŠæ ¼å¼åŒ–çš„JSONæ ¼å¼çš„å­—ç¬¦ä¸²è½¬æ¢æˆå­—å…¸
 * @param jsonString JSONæ ¼å¼çš„å­—ç¬¦ä¸²
 * @return è¿”å›å­—å…¸
 */
- (NSDictionary *)dictionaryWithJsonString:(NSString *)jsonString {
    if (jsonString == nil) {
        return nil;
    }
    iCocosLog(@"%@", jsonString);

    NSData *jsonData = [jsonString dataUsingEncoding:NSUTF8StringEncoding];
    NSError *err;
    NSDictionary *dic = [NSJSONSerialization JSONObjectWithData:jsonData
                                                        options:NSJSONReadingMutableContainers
                                                          error:&amp;err];
    if(err) {
        iCocosLog(@"jsonè§£æå¤±è´¥ï¼š%@",err);
        return nil;
    }
    return dic;
}
</code></pre>

<h4>æ•°ç»„è½¬JSON</h4>

<pre><code>    NSArray *uids = [self.allModelUID objectAtIndexCheck:range];

    NSError *error = nil;
    NSData *picsJsonData = [NSJSONSerialization dataWithJSONObject:uids
                                                           options:NSJSONWritingPrettyPrinted
                                                             error:&amp;error];
    NSString *JSONString = [[NSString alloc] initWithData:picsJsonData encoding:NSUTF8StringEncoding];
</code></pre>

<h2>11ï¼šiPhoneè®¾å¤‡ç±»å‹</h2>

<pre><code>typedef NS_ENUM(char, iPhoneModel){//0~3
    iPhone4,//320*480
    iPhone5,//320*568
    iPhone6,//375*667
    iPhone6Plus,//414*736
    UnKnown
};



/**
 *  return current running iPhone model
 *
 *  @return iPhone model
 */
+ (iPhoneModel)iPhonesModel {
    //bounds method gets the points not the pixels!!!
    CGRect rect = [[UIScreen mainScreen] bounds];

    CGFloat width = rect.size.width;
    CGFloat height = rect.size.height;

    //get current interface Orientation
    UIInterfaceOrientation orientation = [[UIApplication sharedApplication] statusBarOrientation];
    //unknown
    if (UIInterfaceOrientationUnknown == orientation) {
        return UnKnown;
    }
    /**
     //    portrait   width * height
     //    iPhone4:320*480
     //    iPhone5:320*568
     //    iPhone6:375*667
     //    iPhone6Plus:414*736
     */

    //portrait
    if (UIInterfaceOrientationPortrait == orientation) {
        if (width ==  320.0f) {
            if (height == 480.0f) {
                return iPhone4;
            } else {
                return iPhone5;
            }
        } else if (width == 375.0f) {
            return iPhone6;
        } else if (width == 414.0f) {
            return iPhone6Plus;
        }
    } else if (UIInterfaceOrientationLandscapeLeft == orientation || UIInterfaceOrientationLandscapeRight == orientation) {//landscape
        if (height == 320.0) {
            if (width == 480.0f) {
                return iPhone4;
            } else {
                return iPhone5;
            }
        } else if (height == 375.0f) {
            return iPhone6;
        } else if (height == 414.0f) {
            return iPhone6Plus;
        }
    }

    return UnKnown;
}
</code></pre>

<h2>12ï¼šiPhoneç³»ç»Ÿç‰ˆæœ¬</h2>

<pre><code>//è·å–å½“å‰ç³»ç»Ÿç‰ˆæœ¬
#define __ios10_0__ ([[UIDevice currentDevice].systemVersion floatValue] &gt;= 10.0)
#define __ios9_0__ ([[UIDevice currentDevice].systemVersion floatValue] &gt;= 9.0)
#define __ios8_0__ ([[UIDevice currentDevice].systemVersion floatValue] &gt;= 8.0)
</code></pre>

<h2>13ï¼šæ—¥å¿—</h2>

<pre><code>// æ—¥å¿—è¾“å‡º
#ifdef DEBUG // å¼€å‘é˜¶æ®µ-DEBUGé˜¶æ®µ:ä½¿ç”¨Log
#define iCocosLog(...) NSLog(__VA_ARGS__)
#else // å‘å¸ƒé˜¶æ®µ-ä¸Šçº¿é˜¶æ®µ:ç§»é™¤Log
#define iCocosLog(...)
#endif
</code></pre>

<p>è¯¦ç»†</p>

<pre><code>#ifdef DEBUG
#define iCocosLog(format, ...) printf("\n[%s] %s [ç¬¬%dè¡Œ] %s\n", __TIME__, __FUNCTION__, __LINE__, [[NSString stringWithFormat:format, ## __VA_ARGS__] UTF8String]);
#else
#define iCocosLog(format, ...)
#endif
</code></pre>

<h2>14ï¼šé¢œè‰²</h2>

<pre><code>// é¢œè‰²
#define iCocosARGBColor(r, g, b, a) [UIColor colorWithRed:(r)/255.0 green:(g)/255.0 blue:(b)/255.0 alpha:a]
#define iCocosColor(r, g, b) iCocosARGBColor((r), (g), (b), 255)


#define random(r, g, b, a) [UIColor colorWithRed:(r)/255.0 green:(g)/255.0 blue:(b)/255.0 alpha:(a)/255.0]
#define iCocosRandomColor (random(arc4random_uniform(256), arc4random_uniform(256), arc4random_uniform(256), arc4random_uniform(256)))
</code></pre>

<h2>15ï¼šå¼±å¼•ç”¨</h2>

<pre><code>// å¼±å¼•ç”¨
#define iCocosWeakSelf __weak typeof(self) weakSelf = self;
</code></pre>

<h2>16ï¼šå±å¹•å°ºå¯¸</h2>

<pre><code>// å±å¹•å°ºå¯¸
#define iCocosScreenH [UIScreen mainScreen].bounds.size.height
#define iCocosScreenW [UIScreen mainScreen].bounds.size.width
</code></pre>

<h2>17ï¼šè·å–viewçš„æ§åˆ¶</h2>

<pre><code>/** è·å–å½“å‰Viewçš„æ§åˆ¶å™¨å¯¹è±¡ */
-(UIViewController *)getCurrentViewController{
    UIResponder *next = [self nextResponder];
    do {
        if ([next isKindOfClass:[UIViewController class]]) {
            return (UIViewController *)next;
        }
        next = [next nextResponder];
    } while (next != nil);
    return nil;
}
</code></pre>

<h2>18ï¼šå­—å…¸é˜²è¹¦</h2>

<h4>ä¸å¯å˜</h4>

<pre><code>/*!
 @method objectAtIndexCheck:
 @abstract æ£€æŸ¥æ˜¯å¦è¶Šç•Œå’ŒNSNullå¦‚æœæ˜¯è¿”å›nil
 @result è¿”å›å¯¹è±¡
 */
- (id)objectStringForKey:(NSString *)key
{
    if ([self objectForKey:key] == nil) {
//        iCocosLog(@"é”®å€¼å¯¹ä¸å­˜åœ¨");
        return nil;
    }
    id value = [self objectForKey:key];

    return value;
}
</code></pre>

<h4>å¯å˜</h4>

<pre><code>/*!
 @method objectAtIndexCheck:
 @abstract æ£€æŸ¥æ˜¯å¦è¶Šç•Œå’ŒNSNullå¦‚æœæ˜¯è¿”å›nil
 @result è¿”å›å¯¹è±¡
 */
- (id)objectStringForKey:(NSString *)key
{
    if ([self objectForKey:key] == nil) {

//        iCocosLog(@"é”®å€¼å¯¹ä¸å­˜åœ¨");

        return nil;
//        return 0;
    }
    id value = [self objectForKey:key];

    return value;
}
</code></pre>

<h2>19ï¼šæ•°ç»„é˜²è¹¦</h2>

<h4>ä¸å¯å˜</h4>

<pre><code>/*!
 @method objectAtIndexCheck:
 @abstract æ£€æŸ¥æ˜¯å¦è¶Šç•Œå’ŒNSNullå¦‚æœæ˜¯è¿”å›nil
 @result è¿”å›å¯¹è±¡
 */
- (id)objectAtIndexCheck:(NSUInteger)index  {

    if (index &gt;= [self count]) {
        iCocosLog(@"æ•°ç»„è¶Šç•Œ");
        return nil;
    }
    id value = [self objectAtIndex:index];
    if (value == [NSNull null]) {
        iCocosLog(@"æ•°ç»„ä¸ºç©º");
        return nil;
    }
    return value;
}
</code></pre>

<h4>å¯å˜</h4>

<pre><code>/*!
 @method objectAtIndexCheck:
 @abstract æ£€æŸ¥æ˜¯å¦è¶Šç•Œå’ŒNSNullå¦‚æœæ˜¯è¿”å›nil
 @result è¿”å›å¯¹è±¡
 */
- (id)objectAtIndexCheck:(NSUInteger)index  {

    if (index &gt;= [self count]) {
        iCocosLog(@"æ•°ç»„è¶Šç•Œ");
        return nil;
    }
    id value = [self objectAtIndex:index];
    if (value == [NSNull null]) {
        iCocosLog(@"æ•°ç»„ä¸ºç©º");
        return nil;
    }
    return value;
}



- (void)removeObjectAtCheckIndex:(NSInteger)index
{
    if (index &gt;= [self count]) {
        iCocosLog(@"æ•°ç»„è¶Šç•Œ");
        return ;
    }
    id value = [self objectAtIndex:index];
    if (value == [NSNull null]) {
        iCocosLog(@"æ•°ç»„ä¸ºç©º");
        return ;
    }

    [self removeObjectAtIndex:index];

}
</code></pre>

<h2>20ï¼šæœ¬æ–‡è¾“å…¥é”™è¯¯æç¤º</h2>

<pre><code>- (void)shake {
    CAKeyframeAnimation *keyFrame = [CAKeyframeAnimation animationWithKeyPath:@"position.x"];
    keyFrame.duration = 0.3;
    CGFloat x = self.layer.position.x;
    keyFrame.values = @[@(x - 30), @(x - 30), @(x + 20), @(x - 20), @(x + 10), @(x - 10), @(x + 5), @(x - 5)];
    [self.layer addAnimation:keyFrame forKey:@"shake"];

}
</code></pre>

<h2>21ï¼šå½“å‰æ—¶é—´</h2>

<pre><code>+ (NSString *)nowTimes{
    NSDate* dat = [NSDate dateWithTimeIntervalSinceNow:0];
    int a=(int)([dat timeIntervalSince1970] + 0.5);
    NSString *timeString = [NSString stringWithFormat:@"%d", a];//è½¬ä¸ºå­—ç¬¦å‹
    return timeString;
}
</code></pre>

<h2>22:å½“å‰ç‰ˆæœ¬</h2>

<pre><code>/*
 *  å½“å‰ç¨‹åºçš„ç‰ˆæœ¬å·
 */
-(NSString *)version{
    //ç³»ç»Ÿç›´æ¥è¯»å–çš„ç‰ˆæœ¬å·
    NSString *versionValueStringForSystemNow=[[NSBundle mainBundle].infoDictionary valueForKey:(NSString *)kCFBundleVersionKey];
    return versionValueStringForSystemNow;
}
</code></pre>

<h2>23:tabBarçº¢ç‚¹</h2>

<pre><code>- (void)showBadgeOnItemIndex:(int)index{

    //ç§»é™¤ä¹‹å‰çš„å°çº¢ç‚¹
    [self removeBadgeOnItemIndex:index];

    //æ–°å»ºå°çº¢ç‚¹
    UIView *badgeView = [[UIView alloc]init];
    badgeView.tag = 888 + index;
    badgeView.backgroundColor = [UIColor redColor];
    CGRect tabFrame = self.frame;

    //ç¡®å®šå°çº¢ç‚¹çš„ä½ç½®
    float percentX = (index +0.6) / TabbarItemNums;
    CGFloat x = ceilf(percentX * tabFrame.size.width);
    CGFloat y = ceilf(0.1 * tabFrame.size.height);
    badgeView.frame = CGRectMake(x, y, 8, 8);
    badgeView.layer.cornerRadius = badgeView.frame.size.width/2;

    [self addSubview:badgeView];

}

- (void)hideBadgeOnItemIndex:(int)index{

    //ç§»é™¤å°çº¢ç‚¹
    [self removeBadgeOnItemIndex:index];

}

- (void)removeBadgeOnItemIndex:(int)index{

    //æŒ‰ç…§tagå€¼è¿›è¡Œç§»é™¤
    for (UIView *subView in self.subviews) {
        if (subView.tag == 888+index) {
            [subView removeFromSuperview];
        }
    }
}
</code></pre>

<h2>24:Logæ—¥å¿—.m</h2>

<pre><code>@implementation UIView(Log)
+ (NSString *)searchAllSubviews:(UIView *)superview
{
    NSMutableString *xml = [NSMutableString string];

    NSString *class = NSStringFromClass(superview.class);
    class = [class stringByReplacingOccurrencesOfString:@"_" withString:@""];
    [xml appendFormat:@"&lt;%@ frame=\"%@\"&gt;\n", class, NSStringFromCGRect(superview.frame)];
    for (UIView *childView in superview.subviews) {
        NSString *subviewXml = [self searchAllSubviews:childView];
        [xml appendString:subviewXml];
    }
    [xml appendFormat:@"&lt;/%@&gt;\n", class];
    return xml;
}

- (NSString *)description
{
    return [UIView searchAllSubviews:self];
}
@end

@implementation NSDictionary (Log)
- (NSString *)descriptionWithLocale:(id)locale
{
    NSMutableString *str = [NSMutableString string];

    [str appendString:@"{\n"];

    // éå†å­—å…¸çš„æ‰€æœ‰é”®å€¼å¯¹
    [self enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) {
        [str appendFormat:@"\t%@ = %@,\n", key, obj];
    }];

    [str appendString:@"}"];

    // æŸ¥å‡ºæœ€åä¸€ä¸ª,çš„èŒƒå›´
    NSRange range = [str rangeOfString:@"," options:NSBackwardsSearch];
    if (range.length) {
        // åˆ æ‰æœ€åä¸€ä¸ª,
        [str deleteCharactersInRange:range];
    }

    return str;
}
@end

@implementation NSArray (Log)
- (NSString *)descriptionWithLocale:(id)locale
{
    NSMutableString *str = [NSMutableString string];

    [str appendString:@"[\n"];

    // éå†æ•°ç»„çš„æ‰€æœ‰å…ƒç´ 
    [self enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {
        [str appendFormat:@"%@,\n", obj];
    }];

    [str appendString:@"]"];

    // æŸ¥å‡ºæœ€åä¸€ä¸ª,çš„èŒƒå›´
    NSRange range = [str rangeOfString:@"," options:NSBackwardsSearch];
    if (range.length) {
        // åˆ æ‰æœ€åä¸€ä¸ª,
        [str deleteCharactersInRange:range];
    }

    return str;
}
@end
</code></pre>

<h2>25:MD5</h2>

<pre><code>//16ä½MD5åŠ å¯†æ–¹å¼
- (NSString *)getMd5_16Bit_String:(NSString *)srcString{
    //æå–32ä½MD5æ•£åˆ—çš„ä¸­é—´16ä½
    NSString *md5_32Bit_String=[self getMd5_32Bit_String:srcString];
    NSString *result = [[md5_32Bit_String substringToIndex:24] substringFromIndex:8];//å³9ï½25ä½

    return result;
}


//32ä½MD5åŠ å¯†æ–¹å¼
- (NSString *)getMd5_32Bit_String:(NSString *)srcString{
    const char *cStr = [srcString UTF8String];
    unsigned char digest[CC_MD5_DIGEST_LENGTH];
    CC_MD5( cStr, strlen(cStr), digest );
    NSMutableString *result = [NSMutableString stringWithCapacity:CC_MD5_DIGEST_LENGTH * 2];
    for(int i = 0; i &lt; CC_MD5_DIGEST_LENGTH; i++)
        [result appendFormat:@"%02x", digest[i]];

    return result;
}
</code></pre>

<h2>26:æŒ‰é’®èƒŒæ™¯é¢œè‰²</h2>

<pre><code>/**
 *  ä½¿ç”¨èƒŒæ™¯é¢œè‰²è®¾ç½®æŒ‰é’®ä¸åŒçŠ¶æ€çš„å›¾ç‰‡
 *
 *  @param color é¢œè‰²
 *
 *  @return èƒŒæ™¯å›¾ç‰‡
 */
+ (UIImage *)imageWithColor:(UIColor *)color {
    CGRect rect = CGRectMake(0.0f, 0.0f, 1.0f, 1.0f);
    UIGraphicsBeginImageContext(rect.size);
    CGContextRef context = UIGraphicsGetCurrentContext();

    CGContextSetFillColorWithColor(context, [color CGColor]);
    CGContextFillRect(context, rect);

    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();
    UIGraphicsEndImageContext();

    return image;
}
</code></pre>

<h2>27ï¼šå¯¹è±¡æ˜¯å¦ä¸ºç©º</h2>

<pre><code>// åˆ¤æ–­å¯¹è±¡æ˜¯å¦ä¸ºç©º
- (BOOL)isBlanceObject:(id)object{
    if (object == nil || object == NULL) {
        return YES;
    }
    if ([object isKindOfClass:[NSNull class]]) {
        return YES;
    }
    return NO;
}
</code></pre>

<h2>28ï¼šé”®ç›˜é€€å‡ºä¸éšè—</h2>

<pre><code>[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(keyboardWillShow:) name:UIKeyboardWillShowNotification object:nil];
[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(keyboardWillHide:) name:UIKeyboardWillHideNotification object:nil];
</code></pre>

<p>}</p>

<pre><code>- (void)keyboardWillShow:(NSNotification *)notification {

    // è·å–é€šçŸ¥çš„ä¿¡æ¯å­—å…¸
    NSDictionary *userInfo = [notification userInfo];

    // è·å–é”®ç›˜å¼¹å‡ºåçš„rect
    NSValue* aValue = [userInfo objectForKey:UIKeyboardFrameEndUserInfoKey];
    CGRect keyboardRect = [aValue CGRectValue];

    // è·å–é”®ç›˜å¼¹å‡ºåŠ¨ç”»æ—¶é—´
    NSValue *animationDurationValue = [userInfo objectForKey:UIKeyboardAnimationDurationUserInfoKey];
    NSTimeInterval animationDuration;
    [animationDurationValue getValue:&amp;animationDuration];

}


- (void)keyboardWillHide:(NSNotification *)notification {

    // è·å–é€šçŸ¥ä¿¡æ¯å­—å…¸
    NSDictionary* userInfo = [notification userInfo];

    // è·å–é”®ç›˜éšè—åŠ¨ç”»æ—¶é—´
    NSValue *animationDurationValue = [userInfo objectForKey:UIKeyboardAnimationDurationUserInfoKey];
    NSTimeInterval animationDuration;
    [animationDurationValue getValue:&amp;animationDuration];


}
</code></pre>

<h2>29ï¼šè·å–è®¾å¤‡å”¯ä¸€ID</h2>

<p>-(NSString <em>)getUniqueDeviceIdentifierAsString
{
    NSString </em>appName=[[[NSBundle mainBundle] infoDictionary] objectForKey:(NSString*)kCFBundleNameKey];</p>

<pre><code>NSString *strApplicationUUID =  [SAMKeychain passwordForService:appName account:@"incoding"];
if (strApplicationUUID == nil)
{
    strApplicationUUID  = [[[UIDevice currentDevice] identifierForVendor] UUIDString];

    NSError *error = nil;
    SAMKeychainQuery *query = [[SAMKeychainQuery alloc] init];
    query.service = appName;
    query.account = @"incoding";
    query.password = strApplicationUUID;
    query.synchronizationMode = SAMKeychainQuerySynchronizationModeNo;
    [query save:&amp;error];

}

return strApplicationUUID;
</code></pre>

<p>}</p>

<h2>30ï¼šMOVè½¬Mp4</h2>

<pre><code>- (void)movFileTransformToMP4WithSourceUrl:(NSURL *)sourceUrl completion:(void(^)(NSString *Mp4FilePath))comepleteBlock
{
    /**
     *  movæ ¼å¼è½¬mp4æ ¼å¼
     */
    AVURLAsset *avAsset = [AVURLAsset URLAssetWithURL:sourceUrl options:nil];

    NSArray *compatiblePresets = [AVAssetExportSession exportPresetsCompatibleWithAsset:avAsset];

    NSLog(@"%@",compatiblePresets);

    if ([compatiblePresets containsObject:AVAssetExportPresetHighestQuality]) {

        AVAssetExportSession *exportSession = [[AVAssetExportSession alloc] initWithAsset:avAsset presetName:AVAssetExportPresetMediumQuality];


        NSDate *date = [NSDate date];
        NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
        [formatter setDateFormat:@"yyyyMMddHHmmss"];
        NSString *uniqueName = [NSString stringWithFormat:@"%@.mp4",[formatter stringFromDate:date]];
        NSString * resultPath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES)[0] stringByAppendingPathComponent:uniqueName];//PATH_OF_DOCUMENTä¸ºdocumentsè·¯å¾„

        NSLog(@"output File Path : %@",resultPath);

        exportSession.outputURL = [NSURL fileURLWithPath:resultPath];

        exportSession.outputFileType = AVFileTypeMPEG4;//å¯ä»¥é…ç½®å¤šç§è¾“å‡ºæ–‡ä»¶æ ¼å¼

        exportSession.shouldOptimizeForNetworkUse = YES;

        [exportSession exportAsynchronouslyWithCompletionHandler:^(void)
         {
             switch (exportSession.status) {

                 case AVAssetExportSessionStatusUnknown:

                     break;

                 case AVAssetExportSessionStatusWaiting:

                     break;

                 case AVAssetExportSessionStatusExporting:

                     break;

                 case AVAssetExportSessionStatusCompleted:
                 {
                     comepleteBlock(resultPath);


                     NSLog(@"mp4 file size:%lf MB",[NSData dataWithContentsOfURL:exportSession.outputURL].length/1024.f/1024.f);
                 }
                     break;

                 case AVAssetExportSessionStatusFailed:

                     break;

                 case AVAssetExportSessionStatusCancelled:

                     break;

             }  

         }];
    }  
}
</code></pre>

<h2>31:ä¸Šä¼ å›¾ç‰‡</h2>

<pre><code>+ (void)uploadImage:(UIImage *)imageIcon successUpload:(void (^)(id responseObject))successUpload failureUpload:(void (^)(NSError *error))failureUpload;
{

    //    æ‹¿åˆ°æ–‡ä»¶
    NSString *NSDocmentsPath = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject;
    NSString *iconPath       = [NSDocmentsPath stringByAppendingPathComponent:[NSString stringWithFormat:@"faceUrl.png"]];
    //NSURL *url = [NSURL fileURLWithPath:iconPath];

    long long size = [iCocosGetSize fileSizeAtPath:iconPath];

    if (size &gt;= 7000000) {
        [SVProgressHUD showInfoWithStatus:@"å›¾ç‰‡è¿‡å¤§ï¼Œè¯·é‡æ–°ä¸Šä¼  \n è¯·ä¸è¦ä¸Šä¼ è¶…è¿‡7Mbæ–‡ä»¶"];
        NSDictionary *errDict = [NSDictionary dictionaryWithObject:@"big" forKey:@"state"];
        failureUpload((NSError *)errDict);
        return;
    }

    //1:æ–‡ä»¶çš„32ä½MD5å€¼
    NSString *strForEight = [iCocosFormatFileGetEight getStringWithEight:iconPath];
    //2:æ–‡ä»¶çš„å‰8ä¸ªå­—èŠ‚çš„16ä½+æ–‡ä»¶çš„å8ä¸ªå­—èŠ‚çš„16ä½
    NSString *str32MD5    = [NSString getMd5_32Bit_String:iconPath];

    NSString *str64       = [NSString stringWithFormat:@"%@%@", str32MD5,strForEight];

    //å­˜å›¾ç‰‡
    //    NSData *imageData = UIImageJPEGRepresentation(imageIcon, 1.0);//å°†UIImageè½¬ä¸ºNSDataï¼Œ1.0è¡¨ç¤ºä¸å‹ç¼©å›¾ç‰‡è´¨é‡ã€‚
    NSData *imageData = [iCocosFileCondenseTools resetSizeOfImageData:imageIcon maxSize:50];


    [imageData writeToFile:iconPath atomically:YES];

    AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];
    manager.responseSerializer.acceptableContentTypes = [NSSet setWithObjects:@"text/html", nil];

    //    NSString *urlStrIF        = [NSString stringWithFormat:@"%@file/exist%@", [iCocosUrlOperationTools shareiCocosUrlOperationTools].iCocosFileUrl, [iCocosURLRequestExtension getURLRequestExtension]];
    NSMutableDictionary *dict = [NSMutableDictionary dictionary];
    //æ–‡ä»¶çš„32ä½MD5+å‰8ä¸ªå­—èŠ‚çš„16ä½+å8ä¸ªå­—èŠ‚çš„16ä½
    dict[@"file_md5"] = str64;
    dict[@"is_blur"] = @(1);
    dict[@"file_size"] = @([iCocosGetSize fileSizeAtPath:iconPath]);
    dict[@"ext"] = @"png";

    /**
     *  è¶…æ—¶æ—¶é—´
     */
    [manager.requestSerializer willChangeValueForKey:@"timeoutInterval"];
    manager.requestSerializer.timeoutInterval = 10.f;
    [manager.requestSerializer didChangeValueForKey:@"timeoutInterval"];

    //    [manager POST:urlStrIF parameters:dict progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {

    [iCocosAFNPOSTRequestData iCocos_POST_HostSecurity:@"file/exist" hostHeaderValue:[iCocosUrlOperationTools shareiCocosUrlOperationTools].iCocosFileHost firstRequestWithUrl:[iCocosUrlOperationTools shareiCocosUrlOperationTools].iCocosFileUrl secondRequestWithIp:[iCocosUrlOperationTools shareiCocosUrlOperationTools].iCocosFileIp params:dict success:^(id response) {

        NSString *state = [NSString stringWithFormat:@"%@", [response objectStringForKey:@"state"]];
        NSString *msg= [NSString stringWithFormat:@"%@", [response objectStringForKey:@"msg"]];
        if ([state isEqualToString:@"0"]) {
            NSString *exist = [NSString stringWithFormat:@"%@", [[response objectStringForKey:@"data"] objectStringForKey:@"exist"]];
            /**
             *  æ³¨æ„è¿™é‡Œéœ€è¦æ¢æˆçœŸå®æœåŠ¡å™¨åœ°å€
             */
            if ([exist isEqualToString:@"0"]) { //ä¸å­˜åœ¨å°±éœ€è¦å‘é€è¯·æ±‚
                NSString *imageUrl          = [NSString stringWithFormat:@"%@file/up%@", [iCocosUrlOperationTools shareiCocosUrlOperationTools].iCocosFileUrl,[iCocosURLRequestExtension getURLRequestExtension]];
                NSMutableDictionary *params = [NSMutableDictionary dictionary];
                params[@"blur"]          = @(1);


                AFHTTPSessionManager *mger = [AFHTTPSessionManager manager];

                AFJSONResponseSerializer *response = [AFJSONResponseSerializer serializer];
                response.removesKeysWithNullValues = YES;
                manager.responseSerializer = response;

                manager.requestSerializer = [AFHTTPRequestSerializer serializer];//å“åº”



                mger.responseSerializer.acceptableContentTypes = [NSSet setWithObjects:@"image/png", @"text/html", nil];

                /**
                 *  è¶…æ—¶æ—¶é—´
                 */
                [manager.requestSerializer willChangeValueForKey:@"timeoutInterval"];
                manager.requestSerializer.timeoutInterval = 10.f;
                [manager.requestSerializer didChangeValueForKey:@"timeoutInterval"];


                [mger POST:imageUrl parameters:params constructingBodyWithBlock:^(id&lt;AFMultipartFormData&gt; formData) {
                    // ä¸Šä¼ æ–‡ä»¶
                    NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
                    formatter.dateFormat       = @"yyyyMMddHHmmss";
                    NSString *str              = [formatter stringFromDate:[NSDate date]];
                    NSString *fileName         = [NSString stringWithFormat:@"%@.png", str];

                    [formData appendPartWithFileData:imageData name:@"file" fileName:fileName mimeType:@"image/png"];

                } progress:^(NSProgress * _Nonnull uploadProgress) {

                    iCocosLog(@"å°é¢å›¾ç‰‡================%@", uploadProgress);

                } success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {

                    NSDictionary *dataDic    = [responseObject objectStringForKey:@"data"]; 


                    successUpload(dataDic);

                    iCocosLog(@"%@", responseObject);
                } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {
                    iCocosLog(@"ä¸Šä¼ é”™è¯¯:%@", error);

                    failureUpload(error);
                }];

            } else {

                NSDictionary *dataDic    = [response objectStringForKey:@"data"];

                successUpload(dataDic);
            }

        } else {
            successUpload(response);
        }
    } failure:^(NSError *error) {
        failureUpload(error);
    }];

}
</code></pre>

<h2>32ï¼šä¸Šä¼ è§†é¢‘</h2>

<h4>ä¸Šä¼ MOV</h4>

<pre><code>+ (void)updateMOVVideo:(NSURL *)url successUpload:(void (^)(id responseObject))successUpload failureUpload:(void (^)(NSError *error))failureUpload;
{
    //ä¿å­˜æ•°æ®
    //    NSUserDefaults *defaults =[NSUserDefaults standardUserDefaults];
    //    NSURL *url = [defaults URLForKey:@"RecordVideoUrl"];

    NSData *videoData = [NSData dataWithContentsOfURL:url];

    //   NSString *videoUrl = [iCocosUpLoadVideoTools upLoadVideoGetVideoUrlWithFileUrlInSandbox:url];

    //    NSString *strUrl = [NSString stringWithContentsOfURL:url usedEncoding:0 error:nil];

    //    //1:æ–‡ä»¶çš„32ä½MD5å€¼
    //    NSString *strForEight = [iCocosFormatFileGetEight getStringWithEight:strUrl];
    //
    //    //2:æ–‡ä»¶çš„å‰8ä¸ªå­—èŠ‚çš„16ä½+æ–‡ä»¶çš„å8ä¸ªå­—èŠ‚çš„16ä½
    //    NSString *str32MD5 = [NSString getMd5_32Bit_String:strUrl];

    NSString *str32MD5 = [iCocosRandomSix getSixRandom];

    NSString *str64 = [NSString stringWithFormat:@"%@%@", str32MD5,str32MD5];

    AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];
    manager.responseSerializer.acceptableContentTypes = [NSSet setWithObjects:@"text/html", nil];

    //    NSString *urlStrIF = [NSString stringWithFormat:@"%@file/exist%@", [iCocosUrlOperationTools shareiCocosUrlOperationTools].iCocosFileUrl, [iCocosURLRequestExtension getURLRequestExtension]];
    NSMutableDictionary *dict = [NSMutableDictionary dictionary];
    dict[@"file_md5"] = str64;
    dict[@"is_blur"] = 0;
    dict[@"file_size"] = @([iCocosGetSize fileSizeAtPath:[url absoluteString]]);
    dict[@"ext"] = @"MOV";

    /**
     *  è¶…æ—¶æ—¶é—´
     */
    [manager.requestSerializer willChangeValueForKey:@"timeoutInterval"];
    manager.requestSerializer.timeoutInterval = 10.f;
    [manager.requestSerializer didChangeValueForKey:@"timeoutInterval"];

    /** è·å–è§†é¢‘æ˜¯å¦ä¸Šä¼  */
    //    [manager POST:urlStrIF parameters:dict progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {

    [iCocosAFNPOSTRequestData iCocos_POST_HostSecurity:@"file/exist" hostHeaderValue:[iCocosUrlOperationTools shareiCocosUrlOperationTools].iCocosFileHost firstRequestWithUrl:[iCocosUrlOperationTools shareiCocosUrlOperationTools].iCocosFileUrl secondRequestWithIp:[iCocosUrlOperationTools shareiCocosUrlOperationTools].iCocosFileIp params:dict success:^(id response) {

        NSString *state = [NSString stringWithFormat:@"%@", [response objectStringForKey:@"state"]];
        if ([state isEqualToString:@"0"]) {
            NSString *exist = [response objectStringForKey:@"exist"];
            /**
             *  æ³¨æ„è¿™é‡Œéœ€è¦æ¢æˆçœŸå®æœåŠ¡å™¨åœ°å€
             */
            if (exist == 0) { //ä¸å­˜åœ¨å°±éœ€è¦å‘é€è¯·æ±‚
                NSString *vidUrl = [NSString stringWithFormat:@"%@file/up%@", [iCocosUrlOperationTools shareiCocosUrlOperationTools].iCocosFileUrl, [iCocosURLRequestExtension getURLRequestExtension]];
                NSMutableDictionary *params = [NSMutableDictionary dictionary];
                //            params[@"name:file"] = @""; //Content-Disposition: form-data; name="file"; filename="1.txt"
                params[@"is_blur"] = @0;
                params[@"need_mp4"] = @1;
                AFHTTPSessionManager *mger = [AFHTTPSessionManager manager];

                AFJSONResponseSerializer *response = [AFJSONResponseSerializer serializer];
                response.removesKeysWithNullValues = YES;
                manager.responseSerializer = response;

                manager.requestSerializer = [AFHTTPRequestSerializer serializer];//å“åº”


                [mger.securityPolicy setAllowInvalidCertificates:YES];

                /** ä¸Šä¼ è§†é¢‘ */
                [mger POST:vidUrl parameters:params constructingBodyWithBlock:^(id&lt;AFMultipartFormData&gt; formData) {

                    // ä¸Šä¼ æ–‡ä»¶
                    NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
                    formatter.dateFormat = @"yyyyMMddHHmmss";
                    NSString *str = [formatter stringFromDate:[NSDate date]];
                    NSString *fileName = [NSString stringWithFormat:@"%@.mov", str];

                    if (videoData != nil) {
                        [formData appendPartWithFileData:videoData name:@"file" fileName:fileName mimeType:@"video/quicktime"];
                    } else {

                    }

                } progress:^(NSProgress * _Nonnull uploadProgress) {

//                    iCocosLog(@"%@", uploadProgress);

                } success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {

                    NSString *state = [NSString stringWithFormat:@"%@", [responseObject objectStringForKey:@"state"]];
                    if ([state isEqualToString:@"0"]) {

                        NSDictionary *dataDic = [responseObject objectStringForKey:@"data"];

                        successUpload(dataDic);
                    }

                } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {
                    iCocosLog(@"ä¸Šä¼ é”™è¯¯:%@", error);
                    failureUpload(error);
                }];

            } else {
                /**
                 *  å·²ç»ä¸Šä¼ 
                 */
                NSDictionary *dataDic    = [response objectStringForKey:@"data"];
                NSString *file_url       = [NSString stringWithFormat:@"%@", [dataDic objectStringForKey:@"file_url"]];
                NSString *mp4_file_url       = [NSString stringWithFormat:@"%@", [dataDic objectStringForKey:@"mp4_file_url"]];

                NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];
                [defaults setValue:file_url forKey:@"video_url"];
                [defaults setValue:mp4_file_url forKey:@"mp4_file_url"];
                [defaults synchronize];

                successUpload(dataDic);
            }

        } else {
            successUpload(response);
        }
    } failure:^(NSError *error) { //ä¸Šä¼ é”™è¯¯
        failureUpload(error);
    }];
}
</code></pre>

<h4>ä¸Šä¼ MP4</h4>

<pre><code>+ (void)updateMP4Video:(NSURL *)url successUpload:(void (^)(id responseObject))successUpload failureUpload:(void (^)(NSError *error))failureUpload
{
    //ä¿å­˜æ•°æ®
    //    NSUserDefaults *defaults =[NSUserDefaults standardUserDefaults];
    //    NSURL *url = [defaults URLForKey:@"RecordVideoUrl"];

    NSData *videoData = [NSData dataWithContentsOfURL:url];

    //   NSString *videoUrl = [iCocosUpLoadVideoTools upLoadVideoGetVideoUrlWithFileUrlInSandbox:url];

    //    NSString *strUrl = [NSString stringWithContentsOfURL:url usedEncoding:0 error:nil];

    //    //1:æ–‡ä»¶çš„32ä½MD5å€¼
    //    NSString *strForEight = [iCocosFormatFileGetEight getStringWithEight:strUrl];
    //
    //    //2:æ–‡ä»¶çš„å‰8ä¸ªå­—èŠ‚çš„16ä½+æ–‡ä»¶çš„å8ä¸ªå­—èŠ‚çš„16ä½
    //    NSString *str32MD5 = [NSString getMd5_32Bit_String:strUrl];

    NSString *str32MD5 = [iCocosRandomSix getSixRandom];

    NSString *str64 = [NSString stringWithFormat:@"%@%@", str32MD5,str32MD5];

    AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];
    manager.responseSerializer.acceptableContentTypes = [NSSet setWithObjects:@"text/html", nil];

    //    NSString *urlStrIF = [NSString stringWithFormat:@"%@file/exist%@", [iCocosUrlOperationTools shareiCocosUrlOperationTools].iCocosFileUrl, [iCocosURLRequestExtension getURLRequestExtension]];
    NSMutableDictionary *dict = [NSMutableDictionary dictionary];
    dict[@"file_md5"] = str64;
    dict[@"is_blur"] = 0;
    dict[@"file_size"] = @([iCocosGetSize fileSizeAtPath:[url absoluteString]]);
    dict[@"ext"] = @"mp4";

    /**
     *  è¶…æ—¶æ—¶é—´
     */
    [manager.requestSerializer willChangeValueForKey:@"timeoutInterval"];
    manager.requestSerializer.timeoutInterval = 10.f;
    [manager.requestSerializer didChangeValueForKey:@"timeoutInterval"];

    /** è·å–è§†é¢‘æ˜¯å¦ä¸Šä¼  */
    //    [manager POST:urlStrIF parameters:dict progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {

    [iCocosAFNPOSTRequestData iCocos_POST_HostSecurity:@"file/exist" hostHeaderValue:[iCocosUrlOperationTools shareiCocosUrlOperationTools].iCocosFileHost firstRequestWithUrl:[iCocosUrlOperationTools shareiCocosUrlOperationTools].iCocosFileUrl secondRequestWithIp:[iCocosUrlOperationTools shareiCocosUrlOperationTools].iCocosFileIp params:dict success:^(id response) {

        NSString *state = [NSString stringWithFormat:@"%@", [response objectStringForKey:@"state"]];
        if ([state isEqualToString:@"0"]) {
            NSString *exist = [response objectStringForKey:@"exist"];
            /**
             *  æ³¨æ„è¿™é‡Œéœ€è¦æ¢æˆçœŸå®æœåŠ¡å™¨åœ°å€
             */
            if (exist == 0) { //ä¸å­˜åœ¨å°±éœ€è¦å‘é€è¯·æ±‚
                NSString *vidUrl = [NSString stringWithFormat:@"%@file/up%@", [iCocosUrlOperationTools shareiCocosUrlOperationTools].iCocosFileUrl, [iCocosURLRequestExtension getURLRequestExtension]];
                NSMutableDictionary *params = [NSMutableDictionary dictionary];
                //            params[@"name:file"] = @""; //Content-Disposition: form-data; name="file"; filename="1.txt"
                params[@"is_blur"] = @0;
                params[@"need_mp4"] = @1;
                AFHTTPSessionManager *mger = [AFHTTPSessionManager manager];

                AFJSONResponseSerializer *response = [AFJSONResponseSerializer serializer];
                response.removesKeysWithNullValues = YES;
                manager.responseSerializer = response;

                manager.requestSerializer = [AFHTTPRequestSerializer serializer];//å“åº”


                [mger.securityPolicy setAllowInvalidCertificates:YES];

                /** ä¸Šä¼ è§†é¢‘ */
                [mger POST:vidUrl parameters:params constructingBodyWithBlock:^(id&lt;AFMultipartFormData&gt; formData) {

                    // ä¸Šä¼ æ–‡ä»¶
                    NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
                    formatter.dateFormat = @"yyyyMMddHHmmss";
                    NSString *str = [formatter stringFromDate:[NSDate date]];
                    NSString *fileName = [NSString stringWithFormat:@"%@.mp4", str];

                    if (videoData != nil) {
                        [formData appendPartWithFileData:videoData name:@"file" fileName:fileName mimeType:@"video/mp4"];
                    } else {

                    }

                } progress:^(NSProgress * _Nonnull uploadProgress) {


//                    iCocosLog(@"%@", uploadProgress);


                } success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {

                    NSString *state = [NSString stringWithFormat:@"%@", [responseObject objectStringForKey:@"state"]];
                    if ([state isEqualToString:@"0"]) {

                        NSDictionary *dataDic = [responseObject objectStringForKey:@"data"];

                        successUpload(dataDic);
                    }


                } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {
                    iCocosLog(@"ä¸Šä¼ é”™è¯¯:%@", error);
                    failureUpload(error);
                }];

            } else {

                /**
                 *  å·²ç»ä¸Šä¼ 
                 */
                NSDictionary *dataDic    = [response objectStringForKey:@"data"];
                NSString *file_url       = [NSString stringWithFormat:@"%@", [dataDic objectStringForKey:@"file_url"]];
                NSString *mp4_file_url       = [NSString stringWithFormat:@"%@", [dataDic objectStringForKey:@"mp4_file_url"]];

                NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];
                [defaults setValue:file_url forKey:@"video_url"];
                [defaults setValue:mp4_file_url forKey:@"mp4_file_url"];
                [defaults synchronize];

                successUpload(dataDic);
            }

        } else {
            successUpload(response);
        }
    } failure:^(NSError *error) { //ä¸Šä¼ é”™è¯¯
        failureUpload(error);
    }];
}
</code></pre>

<h2>33:è·å–è§†é¢‘å¸§å›¾</h2>

<h4>åŒæ­¥è·å–å¸§å›¾</h4>

<p>åŒæ­¥è·å–ä¸­é—´å¸§ï¼Œéœ€è¦æŒ‡å®šå“ªä¸ªæ—¶é—´ç‚¹çš„å¸§ï¼Œå½“è·å–åˆ°ä»¥åï¼Œè¿”å›æ¥çš„å›¾ç‰‡å¯¹è±¡æ˜¯CFRetainedè¿‡çš„ï¼Œéœ€è¦å¤–é¢æ‰‹åŠ¨CGImageReleaseä¸€ä¸‹ï¼Œé‡Šæ”¾å†…å­˜ã€‚é€šè¿‡AVAssetæ¥è®¿é—®å…·ä½“çš„è§†é¢‘èµ„æºï¼Œç„¶åé€šè¿‡AVAssetImageGeneratorå›¾ç‰‡ç”Ÿæˆå™¨æ¥ç”ŸæˆæŸä¸ªå¸§å›¾ç‰‡ï¼š
    // Get the video&rsquo;s center frame as video poster image
    - (UIImage <em>)frameImageFromVideoURL:(NSURL </em>)videoURL {
      // result
      UIImage *image = nil;</p>

<pre><code>  // AVAssetImageGenerator
  AVAsset *asset = [AVAsset assetWithURL:videoURL];
  AVAssetImageGenerator *imageGenerator = [[AVAssetImageGenerator alloc] initWithAsset:asset];
  imageGenerator.appliesPreferredTrackTransform = YES;

  // calculate the midpoint time of video
  Float64 duration = CMTimeGetSeconds([asset duration]);
  // å–æŸä¸ªå¸§çš„æ—¶é—´ï¼Œå‚æ•°ä¸€è¡¨ç¤ºå“ªä¸ªæ—¶é—´ï¼ˆç§’ï¼‰ï¼Œå‚æ•°äºŒè¡¨ç¤ºæ¯ç§’å¤šå°‘å¸§
  // é€šå¸¸æ¥è¯´ï¼Œ600æ˜¯ä¸€ä¸ªå¸¸ç”¨çš„å…¬å…±å‚æ•°ï¼Œè‹¹æœæœ‰è¯´æ˜:
  // 24 frames per second (fps) for film, 30 fps for NTSC (used for TV in North America and
  // Japan), and 25 fps for PAL (used for TV in Europe).
  // Using a timescale of 600, you can exactly represent any number of frames in these systems
  CMTime midpoint = CMTimeMakeWithSeconds(duration / 2.0, 600);

  // get the image from
  NSError *error = nil;
  CMTime actualTime;
  // Returns a CFRetained CGImageRef for an asset at or near the specified time.
  // So we should mannully release it
  CGImageRef centerFrameImage = [imageGenerator copyCGImageAtTime:midpoint
                                                       actualTime:&amp;actualTime
                                                            error:&amp;error];

  if (centerFrameImage != NULL) {
    image = [[UIImage alloc] initWithCGImage:centerFrameImage];
    // Release the CFRetained image
    CGImageRelease(centerFrameImage);
  }

  return image;
}
</code></pre>

<h4>å¼‚æ­¥è·å–å¸§å›¾</h4>

<p>å¼‚æ­¥è·å–æŸä¸ªå¸§çš„å›¾ç‰‡ï¼Œä¸åŒæ­¥ç›¸æ¯”ï¼Œåªæ˜¯è°ƒç”¨APIä¸åŒï¼Œå¯ä»¥ä¼ å¤šä¸ªæ—¶é—´ç‚¹ï¼Œç„¶åè®¡ç®—å‡ºå®é™…çš„æ—¶é—´å¹¶è¿”å›å›¾ç‰‡ï¼Œä½†æ˜¯è¿”å›çš„å›¾ç‰‡ä¸éœ€è¦æˆ‘ä»¬æ‰‹åŠ¨å†releaseäº†ã€‚æœ‰å¯èƒ½å–ä¸åˆ°å›¾ç‰‡ï¼Œæ‰€ä»¥è¿˜éœ€è¦åˆ¤æ–­æ˜¯å¦æ˜¯AVAssetImageGeneratorSucceededï¼Œæ˜¯æ‰è½¬æ¢å›¾ç‰‡ï¼š</p>

<pre><code>// å¼‚æ­¥è·å–å¸§å›¾ç‰‡ï¼Œå¯ä»¥ä¸€æ¬¡è·å–å¤šå¸§å›¾ç‰‡
- (void)centerFrameImageWithVideoURL:(NSURL *)videoURL completion:(void (^)(UIImage *image))completion {
  // AVAssetImageGenerator
  AVAsset *asset = [AVAsset assetWithURL:videoURL];
  AVAssetImageGenerator *imageGenerator = [[AVAssetImageGenerator alloc] initWithAsset:asset];
  imageGenerator.appliesPreferredTrackTransform = YES;

  // calculate the midpoint time of video
  Float64 duration = CMTimeGetSeconds([asset duration]);
  // å–æŸä¸ªå¸§çš„æ—¶é—´ï¼Œå‚æ•°ä¸€è¡¨ç¤ºå“ªä¸ªæ—¶é—´ï¼ˆç§’ï¼‰ï¼Œå‚æ•°äºŒè¡¨ç¤ºæ¯ç§’å¤šå°‘å¸§
  // é€šå¸¸æ¥è¯´ï¼Œ600æ˜¯ä¸€ä¸ªå¸¸ç”¨çš„å…¬å…±å‚æ•°ï¼Œè‹¹æœæœ‰è¯´æ˜:
  // 24 frames per second (fps) for film, 30 fps for NTSC (used for TV in North America and
  // Japan), and 25 fps for PAL (used for TV in Europe).
  // Using a timescale of 600, you can exactly represent any number of frames in these systems
  CMTime midpoint = CMTimeMakeWithSeconds(duration / 2.0, 600);

  // å¼‚æ­¥è·å–å¤šå¸§å›¾ç‰‡
  NSValue *midTime = [NSValue valueWithCMTime:midpoint];
  [imageGenerator generateCGImagesAsynchronouslyForTimes:@[midTime] completionHandler:^(CMTime requestedTime, CGImageRef  _Nullable image, CMTime actualTime, AVAssetImageGeneratorResult result, NSError * _Nullable error) {
    if (result == AVAssetImageGeneratorSucceeded &amp;&amp; image != NULL) {
      UIImage *centerFrameImage = [[UIImage alloc] initWithCGImage:image];
      dispatch_async(dispatch_get_main_queue(), ^{
        if (completion) {
          completion(centerFrameImage);
        }
      });
    } else {
      dispatch_async(dispatch_get_main_queue(), ^{
        if (completion) {
          completion(nil);
        }
      });
    }
  }];
}
</code></pre>

<h2>34:å‹ç¼©å¹¶å¯¼å‡ºè§†é¢‘</h2>

<p>å‹ç¼©è§†é¢‘æ˜¯å› ä¸ºè§†é¢‘åˆ†è¾¨ç‡è¿‡é«˜æ‰€ç”Ÿæˆçš„è§†é¢‘çš„å¤§å°å¤ªå¤§äº†ï¼Œå¯¹äºç§»åŠ¨è®¾å¤‡æ¥è¯´ï¼Œå†…å­˜æ˜¯ä¸èƒ½å¤ªå¤§çš„ï¼Œå¦‚æœä¸æ”¯æŒåˆ†ç‰‡ä¸Šä¼ åˆ°æœåŠ¡å™¨ï¼Œæˆ–è€…ä¸æ”¯æŒæµä¸Šä¼ ã€æ–‡ä»¶ä¸Šä¼ ï¼Œè€Œåªèƒ½æ”¯æŒè¡¨å•ä¸Šä¼ ï¼Œé‚£ä¹ˆå¿…é¡»è¦é™åˆ¶å¤§å°ï¼Œå‹ç¼©è§†é¢‘ã€‚</p>

<p>å°±åƒæˆ‘ä»¬åœ¨ä½¿ç”¨æŸå¹³å°çš„è§†é¢‘çš„ä¸Šä¼ çš„æ—¶å€™ï¼Œåˆ°ç°åœ¨è¿˜æ²¡æœ‰æ”¯æŒæµä¸Šä¼ ï¼Œä¹Ÿä¸æ”¯æŒæ–‡ä»¶ä¸Šä¼ ï¼Œåªæ”¯æŒè¡¨å•ä¸Šä¼ ï¼Œå¯¼è‡´è§†é¢‘å¤§ä¸€ç‚¹å°±ä¼šé—ªé€€ã€‚æµä¸Šä¼ æ˜¯ä¸Šä¼ æˆåŠŸäº†ï¼Œä½†æ˜¯äººå®¶åå°ä¸è¯†åˆ«ï¼Œè¿™ä¸€æ¬¡è®©æŸå¹³å°å‘åäº†ã€‚ç›´æ¥ç”¨fileä¸Šä¼ ï¼Œä¹Ÿä¼ è¿‡å»äº†ï¼Œä¸Šä¼ è¿›åº¦100%äº†ï¼Œä½†æ˜¯äººå®¶é‚£è¾¹è¿˜æ˜¯ä½œä¸ºå¤±è´¥å¤„ç†ï¼Œæ— å¥ˆï¼</p>

<blockquote><p>è¨€å½’æ­£ä¼ ï¼Œå‹ç¼©ã€å¯¼å‡ºè§†é¢‘ï¼Œéœ€è¦é€šè¿‡AVAssetExportSessionæ¥å®ç°ï¼Œæˆ‘ä»¬éœ€è¦æŒ‡å®šä¸€ä¸ªpresetï¼Œå¹¶åˆ¤æ–­æ˜¯å¦æ”¯æŒè¿™ä¸ªpresetï¼Œåªæœ‰æ”¯æŒæ‰èƒ½ä½¿ç”¨ã€‚</p></blockquote>

<p>æˆ‘ä»¬è¿™é‡Œè®¾ç½®çš„presetä¸ºAVAssetExportPreset640x480ï¼Œå±äºå‹ç¼©å¾—æ¯”è¾ƒå‰å®³çš„äº†ï¼Œè¿™éœ€è¦æ ¹æ®æœåŠ¡å™¨è§†é¢‘ä¸Šä¼ çš„æ”¯æŒç¨‹åº¦è€Œé€‰æ‹©çš„ã€‚ç„¶åé€šè¿‡è°ƒç”¨å¼‚æ­¥å‹ç¼©å¹¶å¯¼å‡ºè§†é¢‘ï¼š</p>

<pre><code>- (void)compressVideoWithVideoURL:(NSURL *)videoURL
                        savedName:(NSString *)savedName
                       completion:(void (^)(NSString *savedPath))completion {
  // Accessing video by URL
  AVURLAsset *videoAsset = [[AVURLAsset alloc] initWithURL:videoURL options:nil];

  // Find compatible presets by video asset.
  NSArray *presets = [AVAssetExportSession exportPresetsCompatibleWithAsset:videoAsset];

  // Begin to compress video
  // Now we just compress to low resolution if it supports
  // If you need to upload to the server, but server does't support to upload by streaming,
  // You can compress the resolution to lower. Or you can support more higher resolution.
  if ([presets containsObject:AVAssetExportPreset640x480]) {
    AVAssetExportSession *session = [[AVAssetExportSession alloc] initWithAsset:videoAsset  presetName:AVAssetExportPreset640x480];

    NSString *doc = [NSHomeDirectory() stringByAppendingPathComponent:@"Documents"];
    NSString *folder = [doc stringByAppendingPathComponent:@"HYBVideos"];
    BOOL isDir = NO;
    BOOL isExist = [[NSFileManager defaultManager] fileExistsAtPath:folder isDirectory:&amp;isDir];
    if (!isExist || (isExist &amp;&amp; !isDir)) {
      NSError *error = nil;
      [[NSFileManager defaultManager] createDirectoryAtPath:folder
                                withIntermediateDirectories:YES
                                                 attributes:nil
                                                      error:&amp;error];
      if (error == nil) {
        NSLog(@"ç›®å½•åˆ›å»ºæˆåŠŸ");
      } else {
        NSLog(@"ç›®å½•åˆ›å»ºå¤±è´¥");
      }
    }

    NSString *outPutPath = [folder stringByAppendingPathComponent:savedName];
    session.outputURL = [NSURL fileURLWithPath:outPutPath];

    // Optimize for network use.
    session.shouldOptimizeForNetworkUse = true;

    NSArray *supportedTypeArray = session.supportedFileTypes;
    if ([supportedTypeArray containsObject:AVFileTypeMPEG4]) {
      session.outputFileType = AVFileTypeMPEG4;
    } else if (supportedTypeArray.count == 0) {
      NSLog(@"No supported file types");
      return;
    } else {
      session.outputFileType = [supportedTypeArray objectAtIndex:0];
    }

    // Begin to export video to the output path asynchronously.
    [session exportAsynchronouslyWithCompletionHandler:^{
      if ([session status] == AVAssetExportSessionStatusCompleted) {
        dispatch_async(dispatch_get_main_queue(), ^{
          if (completion) {
            completion([session.outputURL path]);
          }
        });
      } else {
        dispatch_async(dispatch_get_main_queue(), ^{
          if (completion) {
            completion(nil);
          }
        });
      }
    }];
  }
}
</code></pre>

<h2>35:ä¿å­˜è§†é¢‘åˆ°ç›¸å†Œ</h2>

<p>å†™å…¥ç›¸å†Œå¯ä»¥é€šè¿‡ALAssetsLibraryç±»æ¥å®ç°ï¼Œå®ƒæä¾›äº†å†™å…¥ç›¸å†Œçš„APIï¼Œå¼‚æ­¥å†™å…¥ï¼Œå®Œæˆæ˜¯è¦å›åˆ°ä¸»çº¿ç¨‹æ›´æ–°UIï¼š</p>

<pre><code>NSURL *videoURL = [info objectForKey:UIImagePickerControllerMediaURL];
ALAssetsLibrary *library = [[ALAssetsLibrary alloc] init];
dispatch_async(dispatch_get_global_queue(0, 0), ^{
  // åˆ¤æ–­ç›¸å†Œæ˜¯å¦å…¼å®¹è§†é¢‘ï¼Œå…¼å®¹æ‰èƒ½ä¿å­˜åˆ°ç›¸å†Œ
  if ([library videoAtPathIsCompatibleWithSavedPhotosAlbum:videoURL]) {
    [library writeVideoAtPathToSavedPhotosAlbum:videoURL completionBlock:^(NSURL *assetURL, NSError *error) {
      dispatch_async(dispatch_get_main_queue(), ^{
        // å†™å…¥ç›¸å†Œ
        if (error == nil) {
            NSLog(@"å†™å…¥ç›¸å†ŒæˆåŠŸ");
        } else {
           NSLog(@"å†™å…¥ç›¸å†Œå¤±è´¥");
        }
      }
    }];
  }
});
</code></pre>

<h2>36:è·å–å½“å‰æœ€é¡¶å±‚çš„ViewController</h2>

<pre><code>    - (UIViewController *)topViewController {
    UIViewController *resultVC;
    resultVC = [self _topViewController:[[UIApplication sharedApplication].keyWindow rootViewController]];
    while (resultVC.presentedViewController) {
        resultVC = [self _topViewController:resultVC.presentedViewController];
    }
    return resultVC;
}

- (UIViewController *)_topViewController:(UIViewController *)vc {
    if ([vc isKindOfClass:[UINavigationController class]]) {
        return [self _topViewController:[(UINavigationController *)vc topViewController]];
    } else if ([vc isKindOfClass:[UITabBarController class]]) {
        return [self _topViewController:[(UITabBarController *)vc selectedViewController]];
    } else {
        return vc;
    }
    return nil;
}
</code></pre>

<p>ä½¿ç”¨æ–¹æ³•</p>

<pre><code>UIViewController *topmostVC = [self topViewController];
</code></pre>

<h2>37:æ•°ç»„æ‹†åˆ†</h2>

<pre><code>/**
 *  æ•°ç»„æ‹†åˆ†
 *
 *  @param array   æ•°ç»„
 *  @param subSize å¤§å°
 *
 *  @return å¤šä¸ªæ•°ç»„
 */
- (NSMutableArray *)splitArray: (NSArray *)array withSubSize : (int)subSize{
    //  æ•°ç»„å°†è¢«æ‹†åˆ†æˆæŒ‡å®šé•¿åº¦æ•°ç»„çš„ä¸ªæ•°
    unsigned long count = array.count % subSize == 0 ? (array.count / subSize) : (array.count / subSize + 1);
    //  ç”¨æ¥ä¿å­˜æŒ‡å®šé•¿åº¦æ•°ç»„çš„å¯å˜æ•°ç»„å¯¹è±¡
    NSMutableArray *arr = [[NSMutableArray alloc] init];

    //åˆ©ç”¨æ€»ä¸ªæ•°è¿›è¡Œå¾ªç¯ï¼Œå°†æŒ‡å®šé•¿åº¦çš„å…ƒç´ åŠ å…¥æ•°ç»„
    for (int i = 0; i &lt; count; i ++) {
        //æ•°ç»„ä¸‹æ ‡
        int index = i * subSize;
        //ä¿å­˜æ‹†åˆ†çš„å›ºå®šé•¿åº¦çš„æ•°ç»„å…ƒç´ çš„å¯å˜æ•°ç»„
        NSMutableArray *arr1 = [[NSMutableArray alloc] init];
        //ç§»é™¤å­æ•°ç»„çš„æ‰€æœ‰å…ƒç´ 
        [arr1 removeAllObjects];

        int j = index;
        //å°†æ•°ç»„ä¸‹æ ‡ä¹˜ä»¥1ã€2ã€3ï¼Œå¾—åˆ°æ‹†åˆ†æ—¶æ•°ç»„çš„æœ€å¤§ä¸‹æ ‡å€¼ï¼Œä½†æœ€å¤§ä¸èƒ½è¶…è¿‡æ•°ç»„çš„æ€»å¤§å°
        while (j &lt; subSize*(i + 1) &amp;&amp; j &lt; array.count) {
            [arr1 addObject:[array objectAtIndexCheck:j]];
            j += 1;
        }
        //å°†å­æ•°ç»„æ·»åŠ åˆ°ä¿å­˜å­æ•°ç»„çš„æ•°ç»„ä¸­
        [arr addObject:[arr1 copy]];  
    }  

    return arr;
}
</code></pre>

<h2>38.å›¾ç‰‡å‹ç¼©</h2>

<p>ç”¨æ³•ï¼šUIImage *yourImage= [self imageWithImageSimple:image scaledToSize:CGSizeMake(210.0, 210.0)];</p>

<pre><code>//å‹ç¼©å›¾ç‰‡
- (UIImage*)imageWithImageSimple:(UIImage*)image scaledToSize:(CGSize)newSize

{

// Create a graphics image context

UIGraphicsBeginImageContext(newSize);

// Tell the old image to draw in this newcontext, with the desired

// new size

[image drawInRect:CGRectMake(0,0,newSize.width,newSize.height)];

// Get the new image from the context

UIImage* newImage = UIGraphicsGetImageFromCurrentImageContext();

// End the context

UIGraphicsEndImageContext();

// Return the new image.

return newImage;

}
</code></pre>

<h2>39.é‡Šæ”¾Timerå®</h2>

<pre><code>/*
 * åˆ¤æ–­è¿™ä¸ªTimerä¸ä¸ºnilåˆ™åœæ­¢å¹¶é‡Šæ”¾
 * å¦‚æœä¸å…ˆåœæ­¢å¯èƒ½ä¼šå¯¼è‡´crash
 */
#define WVSAFA_DELETE_TIMER(timer) { \
    if (timer != nil) { \
        [timer invalidate]; \
        [timer release]; \
        timer = nil; \
    } \
}
</code></pre>

<h2>40ã€‚ å…¶ä»–</h2>

<h6>è·å–æŸä¸ªviewæ‰€åœ¨çš„æ§åˆ¶å™¨</h6>

<pre><code>- (UIViewController *)viewController
{
  UIViewController *viewController = nil;  
  UIResponder *next = self.nextResponder;
  while (next)
  {
    if ([next isKindOfClass:[UIViewController class]])
    {
      viewController = (UIViewController *)next;      
      break;    
    }    
    next = next.nextResponder;  
  } 
    return viewController;
}
</code></pre>

<h6>ä¸¤ç§æ–¹æ³•åˆ é™¤NSUserDefaultsæ‰€æœ‰è®°å½•</h6>

<pre><code>//æ–¹æ³•ä¸€
NSString *appDomain = [[NSBundle mainBundle] bundleIdentifier];
[[NSUserDefaults standardUserDefaults] removePersistentDomainForName:appDomain];


//æ–¹æ³•äºŒ
- (void)resetDefaults
{
    NSUserDefaults * defs = [NSUserDefaults standardUserDefaults];
    NSDictionary * dict = [defs dictionaryRepresentation];
    for (id key in dict)
    {
        [defs removeObjectForKey:key];
    }
    [defs synchronize];
}
</code></pre>

<h6>æ‰“å°ç³»ç»Ÿæ‰€æœ‰å·²æ³¨å†Œçš„å­—ä½“åç§°</h6>

<pre><code>#pragma mark - æ‰“å°ç³»ç»Ÿæ‰€æœ‰å·²æ³¨å†Œçš„å­—ä½“åç§°
void enumerateFonts()
{
    for(NSString *familyName in [UIFont familyNames])
   {
        NSLog(@"%@",familyName);               
        NSArray *fontNames = [UIFont fontNamesForFamilyName:familyName];       
        for(NSString *fontName in fontNames)
       {
            NSLog(@"\t|- %@",fontName);
       }
   }
}
</code></pre>

<h6>è·å–å›¾ç‰‡æŸä¸€ç‚¹çš„é¢œè‰²</h6>

<pre><code>- (UIColor*) getPixelColorAtLocation:(CGPoint)point inImage:(UIImage *)image
{

    UIColor* color = nil;
    CGImageRef inImage = image.CGImage;
    CGContextRef cgctx = [self createARGBBitmapContextFromImage:inImage];

    if (cgctx == NULL) {
        return nil; /* error */
    }
    size_t w = CGImageGetWidth(inImage);
    size_t h = CGImageGetHeight(inImage);
    CGRect rect = {0,0,w,}};

    CGContextDrawImage(cgctx, rect, inImage);
    unsigned char* data = CGBitmapContextGetData (cgctx);
    if (data != NULL) {
        int offset = 4*((w*round(point.y))+round(point.x));
        int alpha =  data[offset];
        int red = data[offset+1];
        int green = data[offset+2];
        int blue = data[offset+3];
        color = [UIColor colorWithRed:(red/255.0f) green:(green/255.0f) blue:
                 (blue/255.0f) alpha:(alpha/255.0f)];
    }
    CGContextRelease(cgctx);
    if (data) {
        free(data);
    }
    return color;
}
</code></pre>

<h6>å­—ç¬¦ä¸²åè½¬</h6>

<pre><code>ç¬¬ä¸€ç§ï¼š
- (NSString *)reverseWordsInString:(NSString *)str
{    
    NSMutableString *newString = [[NSMutableString alloc] initWithCapacity:str.length];
    for (NSInteger i = str.length - 1; i &gt;= 0 ; i --)
    {
        unichar ch = [str characterAtIndex:i];       
        [newString appendFormat:@"%c", ch];    
    }    
     return newString;
}

//ç¬¬äºŒç§ï¼š
- (NSString*)reverseWordsInString:(NSString*)str
{    
     NSMutableString *reverString = [NSMutableString stringWithCapacity:str.length];    
     [str enumerateSubstringsInRange:NSMakeRange(0, str.length) options:NSStringEnumerationReverse | NSStringEnumerationByComposedCharacterSequences  usingBlock:^(NSString *substring, NSRange substringRange, NSRange enclosingRange, BOOL *stop) { 
          [reverString appendString:substring];                         
      }];    
     return reverString;
}
</code></pre>

<h6>ç¦æ­¢é”å±ï¼Œ</h6>

<p>é»˜è®¤æƒ…å†µä¸‹ï¼Œå½“è®¾å¤‡ä¸€æ®µæ—¶é—´æ²¡æœ‰è§¦æ§åŠ¨ä½œæ—¶ï¼ŒiOSä¼šé”ä½å±å¹•ã€‚ä½†æœ‰ä¸€äº›åº”ç”¨æ˜¯ä¸éœ€è¦é”å±çš„ï¼Œæ¯”å¦‚è§†é¢‘æ’­æ”¾å™¨ã€‚</p>

<pre><code>[UIApplication sharedApplication].idleTimerDisabled = YES;
æˆ–
[[UIApplication sharedApplication] setIdleTimerDisabled:YES];
</code></pre>

<h6>æ¨¡æ€æ¨å‡ºé€æ˜ç•Œé¢</h6>

<pre><code>UIViewController *vc = [[UIViewController alloc] init];
UINavigationController *na = [[UINavigationController alloc] initWithRootViewController:vc];

if ([[[UIDevice currentDevice] systemVersion] floatValue] &gt;= 8.0)
{
     na.modalPresentationStyle = UIModalPresentationOverCurrentContext;
}
else
{
     self.modalPresentationStyle=UIModalPresentationCurrentContext;
}

[self presentViewController:na animated:YES completion:nil];
</code></pre>

<h6>Xcodeè°ƒè¯•ä¸æ˜¾ç¤ºå†…å­˜å ç”¨</h6>

<pre><code>editSCheme  é‡Œé¢æœ‰ä¸ªé€‰é¡¹å«å«åšenable zoombie Objects  å–æ¶ˆé€‰ä¸­
</code></pre>

<h6>æ˜¾ç¤ºéšè—æ–‡ä»¶</h6>

<pre><code>//æ˜¾ç¤º
defaults write com.apple.finder AppleShowAllFiles -bool true
killall Finder

//éšè—
defaults write com.apple.finder AppleShowAllFiles -bool false
killall Finder
</code></pre>

<h6>iOSè·³è½¬åˆ°App Storeä¸‹è½½åº”ç”¨è¯„åˆ†</h6>

<pre><code>[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@"itms-apps://itunes.apple.com/WebObjects/MZStore.woa/wa/viewContentsUserReviews?type=Purple+Software&amp;id=APPID"]];
</code></pre>

<h6>iOS è·å–æ±‰å­—çš„æ‹¼éŸ³</h6>

<pre><code>+ (NSString *)transform:(NSString *)chinese
{    
    //å°†NSStringè£…æ¢æˆNSMutableString 
    NSMutableString *pinyin = [chinese mutableCopy];    
    //å°†æ±‰å­—è½¬æ¢ä¸ºæ‹¼éŸ³(å¸¦éŸ³æ ‡)    
    CFStringTransform((__bridge CFMutableStringRef)pinyin, NULL, kCFStringTransformMandarinLatin, NO);    
    NSLog(@"%@", pinyin);    
    //å»æ‰æ‹¼éŸ³çš„éŸ³æ ‡    
    CFStringTransform((__bridge CFMutableStringRef)pinyin, NULL, kCFStringTransformStripCombiningMarks, NO);    
    NSLog(@"%@", pinyin);    
    //è¿”å›æœ€è¿‘ç»“æœ    
    return pinyin;
 }
</code></pre>

<h6>æ‰‹åŠ¨æ›´æ”¹iOSçŠ¶æ€æ çš„é¢œè‰²</h6>

<pre><code>- (void)setStatusBarBackgroundColor:(UIColor *)color
{
    UIView *statusBar = [[[UIApplication sharedApplication] valueForKey:@"statusBarWindow"] valueForKey:@"statusBar"];

    if ([statusBar respondsToSelector:@selector(setBackgroundColor:)])
    {
        statusBar.backgroundColor = color;    
    }
}
</code></pre>

<h6>åˆ¤æ–­å½“å‰ViewControlleræ˜¯pushè¿˜æ˜¯presentçš„æ–¹å¼æ˜¾ç¤ºçš„</h6>

<pre><code>NSArray *viewcontrollers=self.navigationController.viewControllers;

if (viewcontrollers.count &gt; 1)
{
    if ([viewcontrollers objectAtIndex:viewcontrollers.count - 1] == self)
    {
        //pushæ–¹å¼
       [self.navigationController popViewControllerAnimated:YES];
    }
}
else
{
    //presentæ–¹å¼
    [self dismissViewControllerAnimated:YES completion:nil];
}
</code></pre>

<h6>è·å–å®é™…ä½¿ç”¨çš„LaunchImageå›¾ç‰‡</h6>

<pre><code>- (NSString *)getLaunchImageName
{
    CGSize viewSize = self.window.bounds.size;
    // ç«–å±    
    NSString *viewOrientation = @"Portrait";  
    NSString *launchImageName = nil;    
    NSArray* imagesDict = [[[NSBundle mainBundle] infoDictionary] valueForKey:@"UILaunchImages"];
    for (NSDictionary* dict in imagesDict)
    {
        CGSize imageSize = CGSizeFromString(dict[@"UILaunchImageSize"]);
        if (CGSizeEqualToSize(imageSize, viewSize) &amp;&amp; [viewOrientation isEqualToString:dict[@"UILaunchImageOrientation"]])
        {
            launchImageName = dict[@"UILaunchImageName"];        
        }    
    }    
    return launchImageName;
}
</code></pre>

<h6>iOSåœ¨å½“å‰å±å¹•è·å–ç¬¬ä¸€å“åº”</h6>

<pre><code>UIWindow * keyWindow = [[UIApplication sharedApplication] keyWindow];
UIView * firstResponder = [keyWindow performSelector:@selector(firstResponder)];
</code></pre>

<h6>åˆ¤æ–­å¯¹è±¡æ˜¯å¦éµå¾ªäº†æŸåè®®</h6>

<pre><code>if ([self.selectedController conformsToProtocol:@protocol(RefreshPtotocol)])
{
     [self.selectedController performSelector:@selector(onTriggerRefresh)];
}
</code></pre>

<h6>åˆ¤æ–­viewæ˜¯ä¸æ˜¯æŒ‡å®šè§†å›¾çš„å­è§†å›¾</h6>

<pre><code>BOOL isView = [textView isDescendantOfView:self.view];
</code></pre>

<h6>NSArray å¿«é€Ÿæ±‚æ€»å’Œ æœ€å¤§å€¼ æœ€å°å€¼ å’Œ å¹³å‡å€¼</h6>

<pre><code>NSArray *array = [NSArray arrayWithObjects:@"2.0", @"2.3", @"3.0", @"4.0", @"10", nil];
CGFloat sum = [[array valueForKeyPath:@"@sum.floatValue"] floatValue];
CGFloat avg = [[array valueForKeyPath:@"@avg.floatValue"] floatValue];
CGFloat max =[[array valueForKeyPath:@"@max.floatValue"] floatValue];
CGFloat min =[[array valueForKeyPath:@"@min.floatValue"] floatValue];
NSLog(@"%f\n%f\n%f\n%f",sum,avg,max,min);
</code></pre>

<h6>ä¿®æ”¹UITextFieldä¸­Placeholderçš„æ–‡å­—é¢œè‰²</h6>

<pre><code>[textField setValue:[UIColor redColor] forKeyPath:@"_placeholderLabel.textColor"];
</code></pre>

<h6>å…³äºNSDateFormatterçš„æ ¼å¼</h6>

<pre><code>G: å…¬å…ƒæ—¶ä»£ï¼Œä¾‹å¦‚ADå…¬å…ƒ
yy: å¹´çš„å2ä½
yyyy: å®Œæ•´å¹´
MM: æœˆï¼Œæ˜¾ç¤ºä¸º1-12
MMM: æœˆï¼Œæ˜¾ç¤ºä¸ºè‹±æ–‡æœˆä»½ç®€å†™,å¦‚ Jan
MMMM: æœˆï¼Œæ˜¾ç¤ºä¸ºè‹±æ–‡æœˆä»½å…¨ç§°ï¼Œå¦‚ Janualy
dd: æ—¥ï¼Œ2ä½æ•°è¡¨ç¤ºï¼Œå¦‚02
d: æ—¥ï¼Œ1-2ä½æ˜¾ç¤ºï¼Œå¦‚ 2
EEE: ç®€å†™æ˜ŸæœŸå‡ ï¼Œå¦‚Sun
EEEE: å…¨å†™æ˜ŸæœŸå‡ ï¼Œå¦‚Sunday
aa: ä¸Šä¸‹åˆï¼ŒAM/PM
H: æ—¶ï¼Œ24å°æ—¶åˆ¶ï¼Œ0-23
Kï¼šæ—¶ï¼Œ12å°æ—¶åˆ¶ï¼Œ0-11
m: åˆ†ï¼Œ1-2ä½
mm: åˆ†ï¼Œ2ä½
s: ç§’ï¼Œ1-2ä½
ss: ç§’ï¼Œ2ä½
S: æ¯«ç§’
</code></pre>

<h6>è·å–ä¸€ä¸ªç±»çš„æ‰€æœ‰å­ç±»</h6>

<pre><code>+ (NSArray *) allSubclasses
{
    Class myClass = [self class];
    NSMutableArray *mySubclasses = [NSMutableArray array];
    unsigned int numOfClasses;
    Class *classes = objc_copyClassList(&amp;numOfClasses;);
    for (unsigned int ci = 0; ci 
}
</code></pre>

<h6>ç›‘æµ‹IOSè®¾å¤‡æ˜¯å¦è®¾ç½®äº†ä»£ç†ï¼Œéœ€è¦CFNetwork.framework</h6>

<pre><code>NSDictionary *proxySettings = (__bridge NSDictionary *)(CFNetworkCopySystemProxySettings());
NSArray *proxies = (__bridge NSArray *)(CFNetworkCopyProxiesForURL((__bridge CFURLRef _Nonnull)([NSURL URLWithString:@"http://www.baidu.com"]), (__bridge CFDictionaryRef _Nonnull)(proxySettings)));
NSLog(@"\n%@",proxies);

NSDictionary *settings = proxies[0];
NSLog(@"%@",[settings objectForKey:(NSString *)kCFProxyHostNameKey]);
NSLog(@"%@",[settings objectForKey:(NSString *)kCFProxyPortNumberKey]);
NSLog(@"%@",[settings objectForKey:(NSString *)kCFProxyTypeKey]);

if ([[settings objectForKey:(NSString *)kCFProxyTypeKey] isEqualToString:@"kCFProxyTypeNone"])
{
     NSLog(@"æ²¡ä»£ç†");
}
else
{
     NSLog(@"è®¾ç½®äº†ä»£ç†");
}
</code></pre>

<h6>é˜¿æ‹‰ä¼¯æ•°å­—è½¬ä¸­æ–‡æ ¼å¼</h6>

<pre><code>+(NSString *)translation:(NSString *)arebic
{  
    NSString *str = arebic;
    NSArray *arabic_numerals = @[@"1",@"2",@"3",@"4",@"5",@"6",@"7",@"8",@"9",@"0"];
    NSArray *chinese_numerals = @[@"ä¸€",@"äºŒ",@"ä¸‰",@"å››",@"äº”",@"å…­",@"ä¸ƒ",@"å…«",@"ä¹",@"é›¶"];
    NSArray *digits = @[@"ä¸ª",@"å",@"ç™¾",@"åƒ",@"ä¸‡",@"å",@"ç™¾",@"åƒ",@"äº¿",@"å",@"ç™¾",@"åƒ",@"å…†"];
    NSDictionary *dictionary = [NSDictionary dictionaryWithObjects:chinese_numerals forKeys:arabic_numerals];

    NSMutableArray *sums = [NSMutableArray array];
    for (int i = 0; i 

}
</code></pre>

<h6>Base64ç¼–ç ä¸NSStringå¯¹è±¡æˆ–NSDataå¯¹è±¡çš„è½¬æ¢</h6>

<pre><code>// Create NSData object
NSData *nsdata = [@"iOS Developer Tips encoded in Base64"
  dataUsingEncoding:NSUTF8StringEncoding];

// Get NSString from NSData object in Base64
NSString *base64Encoded = [nsdata base64EncodedStringWithOptions:0];

// Print the Base64 encoded string
NSLog(@"Encoded: %@", base64Encoded);

// Let's go the other way...

// NSData from the Base64 encoded str
NSData *nsdataFromBase64String = [[NSData alloc]
  initWithBase64EncodedString:base64Encoded options:0];

// Decoded NSString from the NSData
NSString *base64Decoded = [[NSString alloc]
  initWithData:nsdataFromBase64String encoding:NSUTF8StringEncoding];
NSLog(@"Decoded: %@", base64Decoded);
</code></pre>

<h6>å–æ¶ˆUICollectionViewçš„éšå¼åŠ¨ç”»</h6>

<pre><code>UICollectionViewåœ¨reloadItemsçš„æ—¶å€™ï¼Œé»˜è®¤ä¼šé™„åŠ ä¸€ä¸ªéšå¼çš„fadeåŠ¨ç”»ï¼Œæœ‰æ—¶å€™å¾ˆè®¨åŒï¼Œå°¤å…¶æ˜¯å½“ä½ çš„cellæ˜¯å¤åˆcellçš„æƒ…å†µä¸‹(æ¯”å¦‚cellä½¿ç”¨åˆ°äº†UIStackView)ã€‚
</code></pre>

<h6>ä¸‹é¢å‡ ç§æ–¹æ³•éƒ½å¯ä»¥å¸®ä½ å»é™¤è¿™äº›åŠ¨ç”»</h6>

<pre><code>//æ–¹æ³•ä¸€
[UIView performWithoutAnimation:^{
    [collectionView reloadItemsAtIndexPaths:@[[NSIndexPath indexPathForItem:index inSection:0]]];
}];

//æ–¹æ³•äºŒ
[UIView animateWithDuration:0 animations:^{
    [collectionView performBatchUpdates:^{
        [collectionView reloadItemsAtIndexPaths:@[[NSIndexPath indexPathForItem:index inSection:0]]];
    } completion:nil];
}];

//æ–¹æ³•ä¸‰
[UIView setAnimationsEnabled:NO];
[self.trackPanel performBatchUpdates:^{
    [collectionView reloadItemsAtIndexPaths:@[[NSIndexPath indexPathForItem:index inSection:0]]];
} completion:^(BOOL finished) {
    [UIView setAnimationsEnabled:YES];
}];
</code></pre>

<h6>è®©Xcodeçš„æ§åˆ¶å°æ”¯æŒLLDBç±»å‹çš„æ‰“å°</h6>

<pre><code>æ‰“å¼€ç»ˆç«¯è¾“å…¥ä¸‰æ¡å‘½ä»¤:
touch ~/.lldbinit
echo display @import UIKit &gt;&gt; ~/.lldbinit
echo target stop-hook add -o \"target stop-hook disable\" &gt;&gt; ~/.lldbinit
</code></pre>

<h6>CocoaPods pod install/pod updateæ›´æ–°æ…¢çš„é—®é¢˜</h6>

<pre><code>pod install --verbose --no-repo-update 
pod update --verbose --no-repo-update
</code></pre>

<p>å¦‚æœä¸åŠ åé¢çš„å‚æ•°ï¼Œé»˜è®¤ä¼šå‡çº§CocoaPodsçš„specä»“åº“ï¼ŒåŠ ä¸€ä¸ªå‚æ•°å¯ä»¥çœç•¥è¿™ä¸€æ­¥ï¼Œç„¶åé€Ÿåº¦å°±ä¼šæå‡ä¸å°‘</p>

<h6>UIImage å ç”¨å†…å­˜å¤§å°</h6>

<pre><code>UIImage *image = [UIImage imageNamed:@"aa"];
NSUInteger size  = CGImageGetHeight(image.CGImage) * CGImageGetBytesPerRow(image.CGImage);
</code></pre>

<h6>GCD timerå®šæ—¶å™¨</h6>

<pre><code>dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0,queue);
dispatch_source_set_timer(timer,dispatch_walltime(NULL, 0),1.0*NSEC_PER_SEC, 0); //æ¯ç§’æ‰§è¡Œ
dispatch_source_set_event_handler(timer, ^{
    //@"å€’è®¡æ—¶ç»“æŸï¼Œå…³é—­"
    dispatch_source_cancel(timer); 
    dispatch_async(dispatch_get_main_queue(), ^{

    });
});
dispatch_resume(timer);
</code></pre>

<h6>å›¾ç‰‡ä¸Šç»˜åˆ¶æ–‡å­— å†™ä¸€ä¸ªUIImageçš„category</h6>

<pre><code>- (UIImage *)imageWithTitle:(NSString *)title fontSize:(CGFloat)fontSize
{
    //ç”»å¸ƒå¤§å°
    CGSize size=CGSizeMake(self.size.width,self.size.height);
    //åˆ›å»ºä¸€ä¸ªåŸºäºä½å›¾çš„ä¸Šä¸‹æ–‡
    UIGraphicsBeginImageContextWithOptions(size,NO,0.0);//opaque:NO  scale:0.0

    [self drawAtPoint:CGPointMake(0.0,0.0)];

    //æ–‡å­—å±…ä¸­æ˜¾ç¤ºåœ¨ç”»å¸ƒä¸Š
    NSMutableParagraphStyle* paragraphStyle = [[NSParagraphStyle defaultParagraphStyle] mutableCopy];
    paragraphStyle.lineBreakMode = NSLineBreakByCharWrapping;
    paragraphStyle.alignment=NSTextAlignmentCenter;//æ–‡å­—å±…ä¸­

    //è®¡ç®—æ–‡å­—æ‰€å çš„size,æ–‡å­—å±…ä¸­æ˜¾ç¤ºåœ¨ç”»å¸ƒä¸Š
    CGSize sizeText=[title boundingRectWithSize:self.size options:NSStringDrawingUsesLineFragmentOrigin
                                     attributes:@{NSFontAttributeName:[UIFont systemFontOfSize:fontSize]}context:nil].size;
    CGFloat width = self.size.width;
    CGFloat height = self.size.height;

    CGRect rect = CGRectMake((width-sizeText.width)/2, (height-sizeText.height)/2, sizeText.width, sizeText.height);
    //ç»˜åˆ¶æ–‡å­—
    [title drawInRect:rect withAttributes:@{ NSFontAttributeName:[UIFont systemFontOfSize:fontSize],NSForegroundColorAttributeName:[ UIColor whiteColor],NSParagraphStyleAttributeName:paragraphStyle}];

    //è¿”å›ç»˜åˆ¶çš„æ–°å›¾å½¢
    UIImage *newImage= UIGraphicsGetImageFromCurrentImageContext();
    UIGraphicsEndImageContext();
    return newImage;
}
</code></pre>

<h6>æŸ¥æ‰¾ä¸€ä¸ªè§†å›¾çš„æ‰€æœ‰å­è§†å›¾</h6>

<pre><code>- (NSMutableArray *)allSubViewsForView:(UIView *)view
{
    NSMutableArray *array = [NSMutableArray arrayWithCapacity:0];
    for (UIView *subView in view.subviews)
    {
        [array addObject:subView];
        if (subView.subviews.count &gt; 0)
        {
            [array addObjectsFromArray:[self allSubViewsForView:subView]];
        }
    }
    return array;
}
</code></pre>

<h6>è®¡ç®—æ–‡ä»¶å¤§å°</h6>

<pre><code>//æ–‡ä»¶å¤§å°
- (long long)fileSizeAtPath:(NSString *)path
{
    NSFileManager *fileManager = [NSFileManager defaultManager];

    if ([fileManager fileExistsAtPath:path])
    {
        long long size = [fileManager attributesOfItemAtPath:path error:nil].fileSize;
        return size;
    }

    return 0;
}

//æ–‡ä»¶å¤¹å¤§å°
- (long long)folderSizeAtPath:(NSString *)path
{
    NSFileManager *fileManager = [NSFileManager defaultManager];

    long long folderSize = 0;

    if ([fileManager fileExistsAtPath:path])
    {
        NSArray *childerFiles = [fileManager subpathsAtPath:path];
        for (NSString *fileName in childerFiles)
        {
            NSString *fileAbsolutePath = [path stringByAppendingPathComponent:fileName];
            if ([fileManager fileExistsAtPath:fileAbsolutePath])
            {
                long long size = [fileManager attributesOfItemAtPath:fileAbsolutePath error:nil].fileSize;
                folderSize += size;
            }
        }
    }

    return folderSize;
}
</code></pre>

<h6>UIViewè®¾ç½®éƒ¨åˆ†åœ†è§’</h6>

<p>ä½ æ˜¯ä¸æ˜¯ä¹Ÿé‡åˆ°è¿‡è¿™æ ·çš„é—®é¢˜ï¼Œä¸€ä¸ªbuttonæˆ–è€…labelï¼Œåªè¦å³è¾¹çš„ä¸¤ä¸ªè§’åœ†è§’ï¼Œæˆ–è€…åªè¦ä¸€ä¸ªåœ†è§’ã€‚è¯¥æ€ä¹ˆåŠå‘¢ã€‚è¿™å°±éœ€è¦å›¾å±‚è’™ç‰ˆæ¥å¸®åŠ©æˆ‘ä»¬äº†</p>

<pre><code>CGRect rect = view.bounds;
CGSize radio = CGSizeMake(30, 30);//åœ†è§’å°ºå¯¸
UIRectCorner corner = UIRectCornerTopLeft|UIRectCornerTopRight;//è¿™åªåœ†è§’ä½ç½®
UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:rect byRoundingCorners:corner cornerRadii:radio];
CAShapeLayer *masklayer = [[CAShapeLayer alloc]init];//åˆ›å»ºshapelayer
masklayer.frame = view.bounds;
masklayer.path = path.CGPath;//è®¾ç½®è·¯å¾„
view.layer.mask = masklayer;
</code></pre>

<h6>å–ä¸Šæ•´ä¸å–ä¸‹æ•´</h6>

<pre><code>floor(x),æœ‰æ—¶å€™ä¹Ÿå†™åšFloor(x)ï¼Œå…¶åŠŸèƒ½æ˜¯â€œä¸‹å–æ•´â€ï¼Œå³å–ä¸å¤§äºxçš„æœ€å¤§æ•´æ•° ä¾‹å¦‚ï¼š
x=3.14ï¼Œfloor(x)=3
y=9.99999ï¼Œfloor(y)=9

ä¸floorå‡½æ•°å¯¹åº”çš„æ˜¯ceilå‡½æ•°ï¼Œå³ä¸Šå–æ•´å‡½æ•°ã€‚

ceilå‡½æ•°çš„ä½œç”¨æ˜¯æ±‚ä¸å°äºç»™å®šå®æ•°çš„æœ€å°æ•´æ•°ã€‚
ceil(2)=ceil(1.2)=cei(1.5)=2.00

floorå‡½æ•°ä¸ceilå‡½æ•°çš„è¿”å›å€¼å‡ä¸ºdoubleå‹
</code></pre>

<h6>è®¡ç®—å­—ç¬¦ä¸²å­—ç¬¦é•¿åº¦ï¼Œä¸€ä¸ªæ±‰å­—ç®—ä¸¤ä¸ªå­—ç¬¦</h6>

<pre><code>//æ–¹æ³•ä¸€ï¼š
- (int)convertToInt:(NSString*)strtemp
{
    int strlength = 0;
    char* p = (char*)[strtemp cStringUsingEncoding:NSUnicodeStringEncoding];
    for (int i=0 ; i
}
</code></pre>

<h6>ç»™UIViewè®¾ç½®å›¾ç‰‡</h6>

<pre><code>UIImage *image = [UIImage imageNamed:@"image"];
self.MYView.layer.contents = (__bridge id _Nullable)(image.CGImage);
self.MYView.layer.contentsRect = CGRectMake(0, 0, 0.5, 0.5);
</code></pre>

<h6>é˜²æ­¢scrollViewæ‰‹åŠ¿è¦†ç›–ä¾§æ»‘æ‰‹åŠ¿</h6>

<pre><code>[scrollView.panGestureRecognizerrequireGestureRecognizerToFail:self.navigationController.interactivePopGestureRecognizer];
</code></pre>

<h6>å»æ‰å¯¼èˆªæ è¿”å›çš„backæ ‡é¢˜</h6>

<pre><code>[[UIBarButtonItemappearance]setBackButtonTitlePositionAdjustment:UIOffsetMake(0, -60)forBarMetrics:UIBarMetricsDefault];
</code></pre>

<h6>å­—ç¬¦ä¸²ä¸­æ˜¯å¦å«æœ‰ä¸­æ–‡</h6>

<pre><code>+ (BOOL)checkIsChinese:(NSString *)string
{
    for (int i=0; i
}
</code></pre>

<h6>dispatch_groupçš„ä½¿ç”¨</h6>

<pre><code> dispatch_group_t dispatchGroup = dispatch_group_create();
    dispatch_group_enter(dispatchGroup);
    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
        NSLog(@"ç¬¬ä¸€ä¸ªè¯·æ±‚å®Œæˆ");
        dispatch_group_leave(dispatchGroup);
    });

    dispatch_group_enter(dispatchGroup);

    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(10 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
        NSLog(@"ç¬¬äºŒä¸ªè¯·æ±‚å®Œæˆ");
        dispatch_group_leave(dispatchGroup);
    });

    dispatch_group_notify(dispatchGroup, dispatch_get_main_queue(), ^(){
        NSLog(@"è¯·æ±‚å®Œæˆ");
    });
</code></pre>

<h6>UITextFieldæ¯å››ä½åŠ ä¸€ä¸ªç©ºæ ¼,å®ç°ä»£ç†</h6>

<pre><code>- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string
{
    // å››ä½åŠ ä¸€ä¸ªç©ºæ ¼
    if ([string isEqualToString:@""])
    {
        // åˆ é™¤å­—ç¬¦
        if ((textField.text.length - 2) % 5 == 0)
        {
            textField.text = [textField.text substringToIndex:textField.text.length - 1];
        }
        return YES;
    }
    else
    {
        if (textField.text.length % 5 == 0)
        {
            textField.text = [NSString stringWithFormat:@"%@ ", textField.text];
        }
    }
    return YES;
}
</code></pre>

<h6>è·å–ç§æœ‰å±æ€§å’Œæˆå‘˜å˜é‡ #import</h6>

<pre><code>//è·å–ç§æœ‰å±æ€§ æ¯”å¦‚è®¾ç½®UIDatePickerçš„å­—ä½“é¢œè‰²
- (void)setTextColor
{
    //è·å–æ‰€æœ‰çš„å±æ€§ï¼Œå»æŸ¥çœ‹æœ‰æ²¡æœ‰å¯¹åº”çš„å±æ€§
    unsigned int count = 0;
    objc_property_t *propertys = class_copyPropertyList([UIDatePicker class], &amp;count);
    for(int i = 0;i 


//è·å¾—æˆå‘˜å˜é‡ æ¯”å¦‚ä¿®æ”¹UIAlertActionçš„æŒ‰é’®å­—ä½“é¢œè‰²
    unsigned int count = 0;
    Ivar *ivars = class_copyIvarList([UIAlertAction class], &amp;count);
    for(int i =0;i 
</code></pre>

<h6>è·å–æ‰‹æœºå®‰è£…çš„åº”ç”¨</h6>

<pre><code>Class c =NSClassFromString(@"LSApplicationWorkspace");
id s = [(id)c performSelector:NSSelectorFromString(@"defaultWorkspace")];
NSArray *array = [s performSelector:NSSelectorFromString(@"allInstalledApplications")];
for (id item in array)
{
    NSLog(@"%@",[item performSelector:NSSelectorFromString(@"applicationIdentifier")]);
    //NSLog(@"%@",[item performSelector:NSSelectorFromString(@"bundleIdentifier")]);
    NSLog(@"%@",[item performSelector:NSSelectorFromString(@"bundleVersion")]);
    NSLog(@"%@",[item performSelector:NSSelectorFromString(@"shortVersionString")]);
}
</code></pre>

<h6>åˆ¤æ–­ä¸¤ä¸ªæ—¥æœŸæ˜¯å¦åœ¨åŒä¸€å‘¨ å†™åœ¨NSDateçš„categoryé‡Œé¢</h6>

<pre><code>- (BOOL)isSameDateWithDate:(NSDate *)date
{
    //æ—¥æœŸé—´éš”å¤§äºä¸ƒå¤©ä¹‹é—´è¿”å›NO
    if (fabs([self timeIntervalSinceDate:date]) &gt;= 7 * 24 *3600)
    {
        return NO;
    }

    NSCalendar *calender = [NSCalendar currentCalendar];
    calender.firstWeekday = 2;//è®¾ç½®æ¯å‘¨ç¬¬ä¸€å¤©ä»å‘¨ä¸€å¼€å§‹
    //è®¡ç®—ä¸¤ä¸ªæ—¥æœŸåˆ†åˆ«ä¸ºè¿™å¹´ç¬¬å‡ å‘¨
    NSUInteger countSelf = [calender ordinalityOfUnit:NSCalendarUnitWeekday inUnit:NSCalendarUnitYear forDate:self];
    NSUInteger countDate = [calender ordinalityOfUnit:NSCalendarUnitWeekday inUnit:NSCalendarUnitYear forDate:date];

    //ç›¸ç­‰å°±åœ¨åŒä¸€å‘¨ï¼Œä¸ç›¸ç­‰å°±ä¸åœ¨åŒä¸€å‘¨
    return countSelf == countDate;
}
</code></pre>

<h6>åº”ç”¨å†…æ‰“å¼€ç³»ç»Ÿè®¾ç½®ç•Œé¢</h6>

<pre><code>//iOS8ä¹‹å
[[UIApplication sharedApplication] openURL:[NSURL URLWithString:UIApplicationOpenSettingsURLString]];
//å¦‚æœAppæ²¡æœ‰æ·»åŠ æƒé™ï¼Œæ˜¾ç¤ºçš„æ˜¯è®¾å®šç•Œé¢ã€‚å¦‚æœAppæœ‰æ·»åŠ æƒé™ï¼ˆä¾‹å¦‚é€šçŸ¥ï¼‰ï¼Œæ˜¾ç¤ºçš„æ˜¯Appçš„è®¾å®šç•Œé¢ã€‚

//iOS8ä¹‹å‰
//å…ˆæ·»åŠ ä¸€ä¸ªurl typeå¦‚ä¸‹å›¾ï¼Œåœ¨ä»£ç ä¸­è°ƒç”¨å¦‚ä¸‹ä»£ç ,å³å¯è·³è½¬åˆ°è®¾ç½®é¡µé¢çš„å¯¹åº”é¡¹
[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@"prefs:root=WIFI"]];
</code></pre>

<h6>å¯é€‰å€¼å¦‚ä¸‹ï¼š</h6>

<pre><code>About â€” prefs:root=General&amp;path=About
Accessibility â€” prefs:root=General&amp;path=ACCESSIBILITY
Airplane Mode On â€” prefs:root=AIRPLANE_MODE
Auto-Lock â€” prefs:root=General&amp;path=AUTOLOCK
Brightness â€” prefs:root=Brightness
Bluetooth â€” prefs:root=General&amp;path=Bluetooth
Date &amp; Time â€” prefs:root=General&amp;path=DATE_AND_TIME
FaceTime â€” prefs:root=FACETIME
General â€” prefs:root=General
Keyboard â€” prefs:root=General&amp;path=Keyboard
iCloud â€” prefs:root=CASTLE
iCloud Storage &amp; Backup â€” prefs:root=CASTLE&amp;path=STORAGE_AND_BACKUP
International â€” prefs:root=General&amp;path=INTERNATIONAL
Location Services â€” prefs:root=LOCATION_SERVICES
Music â€” prefs:root=MUSIC
Music Equalizer â€” prefs:root=MUSIC&amp;path=EQ
Music Volume Limit â€” prefs:root=MUSIC&amp;path=VolumeLimit
Network â€” prefs:root=General&amp;path=Network
Nike + iPod â€” prefs:root=NIKE_PLUS_IPOD
Notes â€” prefs:root=NOTES
Notification â€” prefs:root=NOTIFICATI*****_ID
Phone â€” prefs:root=Phone
Photos â€” prefs:root=Photos
Profile â€” prefs:root=General&amp;path=ManagedConfigurationList
Reset â€” prefs:root=General&amp;path=Reset
Safari â€” prefs:root=Safari
Siri â€” prefs:root=General&amp;path=Assistant
Sounds â€” prefs:root=Sounds
Software Update â€” prefs:root=General&amp;path=SOFTWARE_UPDATE_LINK
Store â€” prefs:root=STORE
Twitter â€” prefs:root=TWITTER
Usage â€” prefs:root=General&amp;path=USAGE
VPN â€” prefs:root=General&amp;path=Network/VPN
Wallpaper â€” prefs:root=Wallpaper
Wi-Fi â€” prefs:root=WIFI
</code></pre>

<h6>å±è”½è§¦å‘äº‹ä»¶ï¼Œ2ç§’åå–æ¶ˆå±è”½</h6>

<pre><code>[[UIApplication sharedApplication] beginIgnoringInteractionEvents];
dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
    [[UIApplication sharedApplication] endIgnoringInteractionEvents]
});
</code></pre>

<h6>åŠ¨ç”»æš‚åœå†å¼€å§‹</h6>

<pre><code>-(void)pauseLayer:(CALayer *)layer
{
    CFTimeInterval pausedTime = [layer convertTime:CACurrentMediaTime() fromLayer:nil];
    layer.speed = 0.0;
    layer.timeOffset = pausedTime;
}

-(void)resumeLayer:(CALayer *)layer
{
    CFTimeInterval pausedTime = [layer timeOffset];
    layer.speed = 1.0;
    layer.timeOffset = 0.0;
    layer.beginTime = 0.0;
    CFTimeInterval timeSincePause = [layer convertTime:CACurrentMediaTime() fromLayer:nil] - pausedTime;
    layer.beginTime = timeSincePause;
}
</code></pre>

<p>iOSä¸­æ•°å­—çš„æ ¼å¼åŒ–</p>

<pre><code>//é€šè¿‡NSNumberFormatterï¼ŒåŒæ ·å¯ä»¥è®¾ç½®NSNumberè¾“å‡ºçš„æ ¼å¼ã€‚ä¾‹å¦‚å¦‚ä¸‹ä»£ç ï¼š
NSNumberFormatter *formatter = [[NSNumberFormatter alloc] init];
formatter.numberStyle = NSNumberFormatterDecimalStyle;
NSString *string = [formatter stringFromNumber:[NSNumber numberWithInt:123456789]];
NSLog(@"Formatted number string:%@",string);
//è¾“å‡ºç»“æœä¸ºï¼š[1223:403] Formatted number string:123,456,789

//å…¶ä¸­NSNumberFormatterç±»æœ‰ä¸ªå±æ€§numberStyleï¼Œå®ƒæ˜¯ä¸€ä¸ªæšä¸¾å‹ï¼Œè®¾ç½®ä¸åŒçš„å€¼å¯ä»¥è¾“å‡ºä¸åŒçš„æ•°å­—æ ¼å¼ã€‚è¯¥æšä¸¾åŒ…æ‹¬ï¼š
typedef NS_ENUM(NSUInteger, NSNumberFormatterStyle) {
    NSNumberFormatterNoStyle = kCFNumberFormatterNoStyle,
    NSNumberFormatterDecimalStyle = kCFNumberFormatterDecimalStyle,
    NSNumberFormatterCurrencyStyle = kCFNumberFormatterCurrencyStyle,
    NSNumberFormatterPercentStyle = kCFNumberFormatterPercentStyle,
    NSNumberFormatterScientificStyle = kCFNumberFormatterScientificStyle,
    NSNumberFormatterSpellOutStyle = kCFNumberFormatterSpellOutStyle
};
//å„ä¸ªæšä¸¾å¯¹åº”è¾“å‡ºæ•°å­—æ ¼å¼çš„æ•ˆæœå¦‚ä¸‹ï¼šå…¶ä¸­ç¬¬ä¸‰é¡¹å’Œæœ€åä¸€é¡¹çš„è¾“å‡ºä¼šæ ¹æ®ç³»ç»Ÿè®¾ç½®çš„è¯­è¨€åŒºåŸŸçš„ä¸åŒè€Œä¸åŒã€‚
[1243:403] Formatted number string:123456789
[1243:403] Formatted number string:123,456,789
[1243:403] Formatted number string:ï¿¥123,456,789.00
[1243:403] Formatted number string:-539,222,988%
[1243:403] Formatted number string:1.23456789E8
[1243:403] Formatted number string:ä¸€äº¿äºŒåƒä¸‰ç™¾å››åäº”ä¸‡å…­åƒä¸ƒç™¾å…«åä¹
</code></pre>

<h6>å¦‚ä½•è·å–WebViewæ‰€æœ‰çš„å›¾ç‰‡åœ°å€ï¼Œ</h6>

<p>åœ¨ç½‘é¡µåŠ è½½å®Œæˆæ—¶ï¼Œé€šè¿‡jsè·å–å›¾ç‰‡å’Œæ·»åŠ ç‚¹å‡»çš„è¯†åˆ«æ–¹å¼</p>

<pre><code>//UIWebView
- (void)webViewDidFinishLoad:(UIWebView *)webView
{
    //è¿™é‡Œæ˜¯jsï¼Œä¸»è¦ç›®çš„å®ç°å¯¹urlçš„è·å–
    static  NSString * const jsGetImages =
    @"function getImages(){\
    var objs = document.getElementsByTagName(\"img\");\
    var imgScr = '';\
    for(var i=0;i

}

//WKWebView
- (void)webView:(WKWebView *)webView didFinishNavigation:(null_unspecified WKNavigation *)navigation
{
    static  NSString * const jsGetImages =
    @"function getImages(){\
    var objs = document.getElementsByTagName(\"img\");\
    var imgScr = '';\
    for(var i=0;i
</code></pre>

<h6>è·å–åˆ°webviewçš„é«˜åº¦</h6>

<pre><code>CGFloat height = [[self.webView stringByEvaluatingJavaScriptFromString:@"document.body.offsetHeight"] floatValue];
</code></pre>

<h6>navigationBarå˜ä¸ºçº¯é€æ˜</h6>

<pre><code>//ç¬¬ä¸€ç§æ–¹æ³•
//å¯¼èˆªæ çº¯é€æ˜
[self.navigationBar setBackgroundImage:[UIImage new] forBarMetrics:UIBarMetricsDefault];
//å»æ‰å¯¼èˆªæ åº•éƒ¨çš„é»‘çº¿
self.navigationBar.shadowImage = [UIImage new];

//ç¬¬äºŒç§æ–¹æ³•
[[self.navigationBar subviews] objectAtIndex:0].alpha = 0;
</code></pre>

<h6>tabBaråŒç†</h6>

<pre><code>[self.tabBar setBackgroundImage:[UIImage new]];
self.tabBar.shadowImage = [UIImage new];
</code></pre>

<h6>navigationBaræ ¹æ®æ»‘åŠ¨è·ç¦»çš„æ¸å˜è‰²å®ç°</h6>

<pre><code>//ç¬¬ä¸€ç§
- (void)scrollViewDidScroll:(UIScrollView *)scrollView
{
    CGFloat offsetToShow = 200.0;//æ»‘åŠ¨å¤šå°‘å°±å®Œå…¨æ˜¾ç¤º
    CGFloat alpha = 1 - (offsetToShow - scrollView.contentOffset.y) / offsetToShow;
    [[self.navigationController.navigationBar subviews] objectAtIndex:0].alpha = alpha;
}

//ç¬¬äºŒç§
- (void)scrollViewDidScroll:(UIScrollView *)scrollView
{
    CGFloat offsetToShow = 200.0;
    CGFloat alpha = 1 - (offsetToShow - scrollView.contentOffset.y) / offsetToShow;

    [self.navigationController.navigationBar setShadowImage:[UIImage new]];
    [self.navigationController.navigationBar setBackgroundImage:[self imageWithColor:[[UIColor orangeColor]colorWithAlphaComponent:alpha]] forBarMetrics:UIBarMetricsDefault];
}

//ç”Ÿæˆä¸€å¼ çº¯è‰²çš„å›¾ç‰‡
- (UIImage *)imageWithColor:(UIColor *)color
{
    CGRect rect = CGRectMake(0.0f, 0.0f, 1.0f, 1.0f);
    UIGraphicsBeginImageContext(rect.size);
    CGContextRef context = UIGraphicsGetCurrentContext();
    CGContextSetFillColorWithColor(context, [color CGColor]);
    CGContextFillRect(context, rect);
    UIImage *theImage = UIGraphicsGetImageFromCurrentImageContext();
    UIGraphicsEndImageContext();

    return theImage;
}
</code></pre>

<h6>iOS å¼€å‘ä¸­ä¸€äº›ç›¸å…³çš„è·¯å¾„</h6>

<pre><code>æ¨¡æ‹Ÿå™¨çš„ä½ç½®:
/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs 

æ–‡æ¡£å®‰è£…ä½ç½®:
/Applications/Xcode.app/Contents/Developer/Documentation/DocSets

æ’ä»¶ä¿å­˜è·¯å¾„:
~/Library/ApplicationSupport/Developer/Shared/Xcode/Plug-ins

è‡ªå®šä¹‰ä»£ç æ®µçš„ä¿å­˜è·¯å¾„:
~/Library/Developer/Xcode/UserData/CodeSnippets/ 
å¦‚æœæ‰¾ä¸åˆ°CodeSnippetsæ–‡ä»¶å¤¹ï¼Œå¯ä»¥è‡ªå·±æ–°å»ºä¸€ä¸ªCodeSnippetsæ–‡ä»¶å¤¹ã€‚

æè¿°æ–‡ä»¶è·¯å¾„
~/Library/MobileDevice/Provisioning Profiles
</code></pre>

<h6>navigationItemçš„BarButtonItemå¦‚ä½•ç´§é å±å¹•å³è¾¹ç•Œæˆ–è€…å·¦è¾¹ç•Œï¼Ÿ</h6>

<p>ä¸€èˆ¬æƒ…å†µä¸‹ï¼Œå³è¾¹çš„itemä¼šå’Œå±å¹•å³ä¾§ä¿æŒä¸€æ®µè·ç¦»ï¼š
ä¸‹é¢æ˜¯é€šè¿‡æ·»åŠ ä¸€ä¸ªè´Ÿå€¼å®½åº¦çš„å›ºå®šé—´è·çš„itemæ¥è§£å†³ï¼Œä¹Ÿå¯ä»¥æ”¹å˜å®½åº¦å®ç°ä¸åŒçš„é—´éš”ï¼š</p>

<pre><code>UIImage *img = [[UIImage imageNamed:@"icon_cog"] imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal];
//å®½åº¦ä¸ºè´Ÿæ•°çš„å›ºå®šé—´è·çš„ç³»ç»Ÿitem
UIBarButtonItem *rightNegativeSpacer = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemFixedSpace target:nil action:nil];
[rightNegativeSpacer setWidth:-15];

UIBarButtonItem *rightBtnItem1 = [[UIBarButtonItem alloc]initWithImage:img style:UIBarButtonItemStylePlain target:self action:@selector(rightButtonItemClicked:)];
UIBarButtonItem *rightBtnItem2 = [[UIBarButtonItem alloc]initWithImage:img style:UIBarButtonItemStylePlain target:self action:@selector(rightButtonItemClicked:)];
self.navigationItem.rightBarButtonItems = @[rightNegativeSpacer,rightBtnItem1,rightBtnItem2];
</code></pre>

<h6>NSStringè¿›è¡ŒURLç¼–ç å’Œè§£ç </h6>

<pre><code>NSString *string = @"http://abc.com?aaa=ä½ å¥½&amp;bbb=tttee";

//ç¼–ç  æ‰“å°ï¼šhttp://abc.com?aaa=%E4%BD%A0%E5%A5%BD&amp;bbb=tttee
string = [string stringByAddingPercentEncodingWithAllowedCharacters:[NSCharacterSet URLQueryAllowedCharacterSet]];

//è§£ç  æ‰“å°ï¼šhttp://abc.com?aaa=ä½ å¥½&amp;bbb=tttee
string = [string stringByRemovingPercentEncoding];
</code></pre>

<h6>UIWebViewè®¾ç½®User-Agentã€‚</h6>

<pre><code>//è®¾ç½®
NSDictionary *dic = @{@"UserAgent":@"your UserAgent"};
[[NSUserDefaults standardUserDefaults] registerDefaults:dic];
//è·å–
NSString *agent = [self.WebView stringByEvaluatingJavaScriptFromString:@"navigator.userAgent"];
</code></pre>

<h6>è·å–ç¡¬ç›˜æ€»å®¹é‡ä¸å¯ç”¨å®¹é‡:</h6>

<pre><code>NSFileManager *fileManager = [NSFileManager defaultManager];
NSDictionary *attributes = [fileManager attributesOfFileSystemForPath:NSHomeDirectory() error:nil];

NSLog(@"å®¹é‡%.2fG",[attributes[NSFileSystemSize] doubleValue] / (powf(1024, 3)));
NSLog(@"å¯ç”¨%.2fG",[attributes[NSFileSystemFreeSize] doubleValue] / powf(1024, 3));
</code></pre>

<h6>è·å–UIColorçš„RGBAå€¼</h6>

<pre><code>UIColor *color = [UIColor colorWithRed:0.2 green:0.3 blue:0.9 alpha:1.0];
const CGFloat *components = CGColorGetComponents(color.CGColor);
NSLog(@"Red: %.1f", components[0]);
NSLog(@"Green: %.1f", components[1]);
NSLog(@"Blue: %.1f", components[2]);
NSLog(@"Alpha: %.1f", components[3]);
</code></pre>

<h6>ä¿®æ”¹textFieldçš„placeholderçš„å­—ä½“é¢œè‰²ã€å¤§å°</h6>

<pre><code>[self.textField setValue:[UIColor redColor] forKeyPath:@"_placeholderLabel.textColor"];
[self.textField setValue:[UIFont boldSystemFontOfSize:16] forKeyPath:@"_placeholderLabel.font"];
</code></pre>

<h6>AFNç§»é™¤JSONä¸­çš„NSNull</h6>

<pre><code>AFJSONResponseSerializer *response = [AFJSONResponseSerializer serializer];
response.removesKeysWithNullValues = YES;
</code></pre>

<h6>ceil()å’Œfloor()</h6>

<pre><code>ceil()åŠŸ èƒ½ï¼šè¿”å›å¤§äºæˆ–è€…ç­‰äºæŒ‡å®šè¡¨è¾¾å¼çš„æœ€å°æ•´æ•°
floor()åŠŸ èƒ½ï¼šè¿”å›å°äºæˆ–è€…ç­‰äºæŒ‡å®šè¡¨è¾¾å¼çš„æœ€å¤§æ•´æ•°
UIWebViewé‡Œé¢çš„å›¾ç‰‡è‡ªé€‚åº”å±å¹•
</code></pre>

<h6>åœ¨webViewåŠ è½½å®Œçš„ä»£ç†æ–¹æ³•é‡Œé¢è¿™æ ·å†™ï¼š</h6>

<pre><code>- (void)webViewDidFinishLoad:(UIWebView *)webView
{
    NSString *js = @"function imgAutoFit() { \
    var imgs = document.getElementsByTagName('img'); \
    for (var i = 0; i &lt; imgs.length; ++i) { \
    var img = imgs[i]; \
    img.style.maxWidth = %f; \
    } \
    }";

    js = [NSString stringWithFormat:js, [UIScreen mainScreen].bounds.size.width - 20];

    [webView stringByEvaluatingJavaScriptFromString:js];
    [webView stringByEvaluatingJavaScriptFromString:@"imgAutoFit()"];
}
</code></pre>

<h6>NSDateFormatæœ€ä½³æ–¹å¼ï¼ˆstrptimeï¼‰</h6>

<pre><code>+ (NSDate *)dateFromISO8601StringDateFormatter:(NSString *)string locale:(NSLocale *)locale{
    if (!string) {
        return nil;
    }

    struct tm tm;
    time_t t;

    strptime([string cStringUsingEncoding:NSUTF8StringEncoding], "%Y-%m-%d %H:%M:%S", &amp;tm);
    tm.tm_isdst = -1;
    t = mktime(&amp;tm);

    return [NSDate dateWithTimeIntervalSince1970:t + [[NSTimeZone localTimeZone] secondsFromGMT]];
}

- (NSString *)ISO8601String:(NSDate*)date {
    struct tm *timeinfo;
    char buffer[80];

    time_t rawtime = [date timeIntervalSince1970] - [[NSTimeZone localTimeZone] secondsFromGMT];
    timeinfo = localtime(&amp;rawtime);

    strftime(buffer, 80, "%Y-%m-%d %H:%M:%S", timeinfo);

    return [NSString stringWithCString:buffer encoding:NSUTF8StringEncoding];
}
</code></pre>

<h6>æ¯›ç»ç’ƒ</h6>

<pre><code>//åˆ›å»º
UIImageView *imageView = [[UIImageView alloc]initWithFrame:self.view.bounds];
//å›¾ç‰‡
imageView.image = [UIImage imageNamed:@"1.jpeg"];
//èƒŒæ™¯é¢œè‰²
imageView.backgroundColor = [UIColor yellowColor];
//è®¾ç½®å›¾ç‰‡å†…å®¹æ¨¡å¼
imageView.contentMode = UIViewContentModeScaleAspectFill;

[self.view addSubview:imageView];

//æ¯›ç»ç’ƒ
UIToolbar *toolbar = [[UIToolbar alloc]initWithFrame:imageView.bounds];
//æ ·å¼
toolbar.barStyle = UIBarStyleDefault;
//é€æ˜åº¦
toolbar.alpha = 0.8f;
[imageView addSubview:toolbar];
</code></pre>

<h6>tableviewä¸‹æ‹‰åˆ·æ–°åœç•™ï¼ˆä¸æ»šåˆ°é¡¶éƒ¨ï¼‰ï¼Œ ç±»ä¼¼QQï¼Œå¾®ä¿¡æ‹‰å»å†å²æ¶ˆæ¯</h6>

<p> å…³äºTableViewä»£ç†æ–¹æ³•å’Œå…¶ä»–ä¸€äº›æ•°æ®ä¸é€»è¾‘å¤„ç†å’Œå¹³æ—¶ä¸€æ ·ï¼Œåªæ˜¯åœ¨ä¸‹å•¦çš„æ—¶å€™å•¦åˆ°çš„æ•°æ®ï¼Œæ”¾åˆ°æœ€å‰é¢ï¼ŒåŒäº‹æ§åˆ¶TableViewçš„åç§»ã€‚</p>

<pre><code>self.oldSize = self.tableView.contentSize;
self.oldPoint = self.tableView.contentOffset;

dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{

    //                if (self.isfirst) {
    for (int i = 0; i &lt; 15; i++) {
        [self.dataArray insertObject:[NSString stringWithFormat:@"æ–°å¢åŠ ä¿¡æ¯%d",i] atIndex:0];
    }

    //            }
    //            self.isfirst = YES;
    // åˆ·æ–°è¡¨æ ¼
    [self.tableView reloadData];

    // (æœ€å¥½åœ¨åˆ·æ–°è¡¨æ ¼åè°ƒç”¨)è°ƒç”¨endRefreshingå¯ä»¥ç»“æŸåˆ·æ–°çŠ¶æ€
    [self.tableView EndRefreshing];

    CGSize newSize = self.tableView.contentSize;


    CGPoint newPoint = CGPointMake(0, self.oldPoint.y+newSize.height - self.oldSize.height);
    self.tableView.contentOffset = newPoint;
});
</code></pre>

<h6>KeyChainéšç§ä¿¡æ¯å­˜å‚¨ï¼ˆä¸»è¦æ˜¯å¯†ç ç±»ï¼‰</h6>

<p>é›†æˆNSObject</p>

<pre><code> -(NSMutableDictionary *)getKeychainQuery:(NSString *)service
{
    return [NSMutableDictionary dictionaryWithObjectsAndKeys:
            (__bridge_transfer id)kSecClassGenericPassword,(__bridge_transfer id)kSecClass,
            service, (__bridge_transfer id)kSecAttrService,
            service, (__bridge_transfer id)kSecAttrAccount,
            (__bridge_transfer id)kSecAttrAccessibleAfterFirstUnlock,(__bridge_transfer id)kSecAttrAccessible,
            nil];
}

+ (void)saveKeychainValue:(NSString *)sValue Key:(NSString *)sKey
{
    //Get search dictionary
    NSMutableDictionary *keychainQuery = [self getKeychainQuery:sKey];
    //Delete old item before add new item
    SecItemDelete((__bridge_retained CFDictionaryRef)keychainQuery);
    //Add new object to search dictionary(Attention:the data format)
    [keychainQuery setObject:[NSKeyedArchiver archivedDataWithRootObject:sValue] forKey:(__bridge_transfer id)kSecValueData];
    //Add item to keychain with the search dictionary
    SecItemAdd((__bridge_retained CFDictionaryRef)keychainQuery, NULL);
}

+ (NSString *)readKeychainValue:(NSString *)sKey
{
    NSString *ret = nil;
    NSMutableDictionary *keychainQuery = [self getKeychainQuery:sKey];

    //Configure the search setting
    [keychainQuery setObject:(id)kCFBooleanTrue forKey:(__bridge_transfer id)kSecReturnData];
    [keychainQuery setObject:(__bridge_transfer id)kSecMatchLimitOne forKey:(__bridge_transfer id)kSecMatchLimit];
    CFDataRef keyData = NULL;
    if (SecItemCopyMatching((__bridge_retained CFDictionaryRef)keychainQuery, (CFTypeRef *)&amp;keyData) == noErr) {
    &lt;a href="http://www.jobbole.com/members/xyz937134366"&gt;@try&lt;/a&gt; {
        ret = (NSString *)[NSKeyedUnarchiver unarchiveObjectWithData:(__bridge_transfer NSData *)keyData];
        } &lt;a href="http://www.jobbole.com/members/wx895846013"&gt;@catch&lt;/a&gt; (NSException *e) {
            NSLog(@"Unarchive of %@ failed: %@", sKey, e);
        } &lt;a href="http://www.jobbole.com/members/finally"&gt;@finally&lt;/a&gt; {
        }
    }
    return ret;
}

+ (void)deleteKeychainValue:(NSString *)sKey {
    NSMutableDictionary *keychainQuery = [self getKeychainQuery:sKey];
    SecItemDelete((__bridge_retained CFDictionaryRef)keychainQuery);
}
</code></pre>

<h6>è‡ªå®šä¹‰åœ†è§’è£å‰ªï¼šææ€§èƒ½</h6>

<pre><code>// ------------------------------------------------------------------
// --------------------- ä»¥ä¸‹æ˜¯è‡ªå®šä¹‰å›¾åƒå¤„ç†éƒ¨åˆ† -----------------------
// ------------------------------------------------------------------

// è‡ªå®šä¹‰è£å‰ªç®—æ³•
- (UIImage *)dealImage:(UIImage *)img cornerRadius:(CGFloat)c {
    // 1.CGDataProviderRef æŠŠ CGImage è½¬ äºŒè¿›åˆ¶æµ
    CGDataProviderRef provider = CGImageGetDataProvider(img.CGImage);
    void *imgData = (void *)CFDataGetBytePtr(CGDataProviderCopyData(provider));
    int width = img.size.width * img.scale;
    int height = img.size.height * img.scale;

    // 2.å¤„ç† imgData
//    dealImage(imgData, width, height);
    cornerImage(imgData, width, height, c);

    // 3.CGDataProviderRef æŠŠ äºŒè¿›åˆ¶æµ è½¬ CGImage
    CGDataProviderRef pv = CGDataProviderCreateWithData(NULL, imgData, width * height * 4, releaseData);
    CGImageRef content = CGImageCreate(width , height, 8, 32, 4 * width, CGColorSpaceCreateDeviceRGB(), kCGBitmapByteOrder32Big | kCGImageAlphaPremultipliedLast, pv, NULL, true, kCGRenderingIntentDefault);
    UIImage *result = [UIImage imageWithCGImage:content];
    CGDataProviderRelease(pv);      // é‡Šæ”¾ç©ºé—´
    CGImageRelease(content);

    return result;
}

void releaseData(void *info, const void *data, size_t size) {
    free((void *)data);
}

// åœ¨ img ä¸Šå¤„ç†å›¾ç‰‡, æµ‹è¯•ç”¨
void dealImage(UInt32 *img, int w, int h) {
    int num = w * h;
    UInt32 *cur = img;
    for (int i=0; i&lt;num; i++, cur++) {
        UInt8 *p = (UInt8 *)cur;
        // RGBA æ’åˆ—
        // f(x) = 255 - g(x) æ±‚è´Ÿç‰‡
        p[0] = 255 - p[0];
        p[1] = 255 - p[1];
        p[2] = 255 - p[2];
        p[3] = 255;
    }
}

// è£å‰ªåœ†è§’
void cornerImage(UInt32 *const img, int w, int h, CGFloat cornerRadius) {
    CGFloat c = cornerRadius;
    CGFloat min = w &gt; h ? h : w;

    if (c &lt; 0) { c = 0; }
    if (c &gt; min * 0.5) { c = min * 0.5; }

    // å·¦ä¸Š y:[0, c), x:[x, c-y)
    for (int y=0; y&lt;c; y++) {
        for (int x=0; x&lt;c-y; x++) {
            UInt32 *p = img + y * w + x;    // p 32ä½æŒ‡é’ˆï¼ŒRGBAæ’åˆ—ï¼Œå„8ä½
            if (isCircle(c, c, c, x, y) == false) {
                *p = 0;
            }
        }
    }
    // å³ä¸Š y:[0, c), x:[w-c+y, w)
    int tmp = w-c;
    for (int y=0; y&lt;c; y++) {
        for (int x=tmp+y; x&lt;w; x++) {
            UInt32 *p = img + y * w + x;
            if (isCircle(w-c, c, c, x, y) == false) {
                *p = 0;
            }
        }
    }
    // å·¦ä¸‹ y:[h-c, h), x:[0, y-h+c)
    tmp = h-c;
    for (int y=h-c; y&lt;h; y++) {
        for (int x=0; x&lt;y-tmp; x++) {
            UInt32 *p = img + y * w + x;
            if (isCircle(c, h-c, c, x, y) == false) {
                *p = 0;
            }
        }
    }
    // å³ä¸‹ y~[h-c, h), x~[w-c+h-y, w)
    tmp = w-c+h;
    for (int y=h-c; y&lt;h; y++) {
        for (int x=tmp-y; x&lt;w; x++) {
            UInt32 *p = img + y * w + x;
            if (isCircle(w-c, h-c, c, x, y) == false) {
                *p = 0;
            }
        }
    }
}

// åˆ¤æ–­ç‚¹ (px, py) åœ¨ä¸åœ¨åœ†å¿ƒ (cx, cy) åŠå¾„ r çš„åœ†å†…
static inline bool isCircle(float cx, float cy, float r, float px, float py) {
    if ((px-cx) * (px-cx) + (py-cy) * (py-cy) &gt; r * r) {
        return false;
    }
    return true;
}

// å…¶ä»–å›¾åƒæ•ˆæœå¯ä»¥è‡ªå·±å†™å‡½æ•°ï¼Œç„¶ååœ¨ dealImage: ä¸­è°ƒç”¨ otherImage å³å¯
void otherImage(UInt32 *const img, int w, int h) {
    // è‡ªå®šä¹‰å¤„ç†
}
</code></pre>

<h6>éšè—tabbarä¸Šé¢çš„è™šçº¿</h6>

<pre><code>//éšè—é˜´å½±çº¿
[[UITabBar appearance] setShadowImage:[UIImage new]];
- (void)setupTabBarBackgroundImage {
    UIImage *image = [UIImage imageNamed:@"tab_bg"];
    CGFloat top = 40; // é¡¶ç«¯ç›–é«˜åº¦
    CGFloat bottom = 40 ; // åº•ç«¯ç›–é«˜åº¦
    CGFloat left = 100; // å·¦ç«¯ç›–å®½åº¦
    CGFloat right = 100; // å³ç«¯ç›–å®½åº¦
    UIEdgeInsets insets = UIEdgeInsetsMake(top, left, bottom, right);
    // æŒ‡å®šä¸ºæ‹‰ä¼¸æ¨¡å¼ï¼Œä¼¸ç¼©åé‡æ–°èµ‹å€¼
    UIImage *TabBgImage = [image resizableImageWithCapInsets:insets resizingMode:UIImageResizingModeStretch];
    self.tabBar.backgroundImage = TabBgImage;
    [[UITabBar appearance] setShadowImage:[UIImage new]];
    [[UITabBar appearance] setBackgroundImage:[[UIImage alloc]init]];
}
//è‡ªå®šä¹‰TabBaré«˜åº¦
- (void)viewWillLayoutSubviews {
    CGRect tabFrame = self.tabBar.frame;
    tabFrame.size.height = 60;
    tabFrame.origin.y = self.view.frame.size.height - 60;
    self.tabBar.frame = tabFrame;
}
</code></pre>

<h6>éšè—å¯¼èˆªæ ä¸‹é¢çš„è™šçº¿</h6>

<h6>#æ–¹æ³•ä¸€ï¼Œä¸–ç•Œä½¿ç”¨èƒŒæ™¯å›¾ç‰‡ä¸é˜´å½±</h6>

<pre><code>- (void)viewWillAppear:(BOOL)animated{



    // Called when the view is about to made visible. Default does nothing    

    [super viewWillAppear:animated];



    //å»é™¤å¯¼èˆªæ ä¸‹æ–¹çš„æ¨ªçº¿

    [navigationBar setBackgroundImage:[UIImage imageWithColor:[self colorFromHexRGB:@"33cccc"]]

                       forBarPosition:UIBarPositionAny

                           barMetrics:UIBarMetricsDefault];

    [navigationBar setShadowImage:[UIImage new]];



}
</code></pre>

<p>è¿™æ˜¯å”¯ä¸€ä¸€ä¸ªéšè—è¿™æ¡çº¿çš„å®˜æ–¹ç”¨æ³•ï¼Œä½†æ˜¯æœ‰ä¸€ä¸ªç¼ºé™·-åˆ é™¤äº†translucency(åŠé€æ˜)</p>

<h6>#æ–¹æ³•äºŒï¼š</h6>

<p>1ï¼‰å£°æ˜UIImageViewå˜é‡,å­˜å‚¨åº•éƒ¨æ¨ªçº¿</p>

<pre><code>@interface MyViewController {
    UIImageView *navBarHairlineImageView;
}
</code></pre>

<p>2ï¼‰åœ¨viewDidLoadä¸­åŠ å…¥ï¼š</p>

<pre><code>navBarHairlineImageView = [self findHairlineImageViewUnder:self.navigationController.navigationBar];
</code></pre>

<p>3ï¼‰å®ç°æ‰¾å‡ºåº•éƒ¨æ¨ªçº¿çš„å‡½æ•°</p>

<pre><code>- (UIImageView *)findHairlineImageViewUnder:(UIView *)view {
    if ([view isKindOfClass:UIImageView.class] &amp;&amp; view.bounds.size.height &lt;= 1.0) {
            return (UIImageView *)view;
    }
    for (UIView *subview in view.subviews) {
        UIImageView *imageView = [self findHairlineImageViewUnder:subview];
        if (imageView) {
            return imageView;
        }
    }
    return nil;
}
</code></pre>

<p>4ï¼‰æœ€ååœ¨viewWillAppearï¼ŒviewWillDisappearä¸­å¤„ç†</p>

<pre><code>- (void)viewWillAppear:(BOOL)animated {
    [super viewWillAppear:animated];
    navBarHairlineImageView.hidden = YES;
}

- (void)viewWillDisappear:(BOOL)animated {
    [super viewWillDisappear:animated];
    navBarHairlineImageView.hidden = NO;
}
</code></pre>

<p> ###ä¸¤ä¸ªèŒƒå›´çš„å¯Œæ–‡æœ¬</p>

<pre><code>NSString *times = [NSString stringWithFormat:@"å“‡å¡ï¼æœ¬æ¬¡è§†é¢‘èŠå¤©%@", [info objectStringForKey:@"times"]];
NSString *type = [NSString stringWithFormat:@"%@", [info objectStringForKey:@"type"]];
NSString *counts = nil;
if ([type isEqualToString:@"1"]) {
    counts = [NSString stringWithFormat:@"æ¶ˆè€—%@èƒ½é‡", [info objectStringForKey:@"counts"]];
} else {
    counts = [NSString stringWithFormat:@"èµšäº†%@ç§¯åˆ†", [info objectStringForKey:@"counts"]];
}

NSString *formatString = [NSString stringWithFormat:@"%@,%@", times, counts];
NSMutableAttributedString *AttributedStr = [[NSMutableAttributedString alloc]initWithString:formatString];
NSRange range = [formatString rangeOfString:@","];
[AttributedStr addAttribute:NSForegroundColorAttributeName value:[UIColor colorWithHexString:@"#fb455a"] range:NSMakeRange(9, range.location - 9)];
[AttributedStr addAttribute:NSForegroundColorAttributeName value:[UIColor colorWithHexString:@"#fb455a"] range:NSMakeRange(range.location + 3, formatString.length - range.location - 5)];
</code></pre>

<h3>ä¿®æ”¹UIAlertController</h3>

<pre><code>// åœ¨ viewDidLoad ä¸­åˆ›å»º
UIAlertController *alertVC = [UIAlertController alertControllerWithTitle:nil message:AttributedStr.string preferredStyle:UIAlertControllerStyleAlert];
// ç”¨ KVC ä¿®æ”¹å…¶ æ²¡æœ‰æš´éœ²å‡ºæ¥çš„
</code></pre>

<p>//    [alertVC setValue:AttributedTit forKey:@&ldquo;attributedTitle&rdquo;];
    [alertVC setValue:AttributedStr forKey:@&ldquo;attributedMessage&rdquo;];</p>

<pre><code>//ä¿®æ”¹æŒ‰é’®çš„é¢œè‰²ï¼ŒåŒä¸Šå¯ä»¥ä½¿ç”¨åŒæ ·çš„æ–¹æ³•ä¿®æ”¹å†…å®¹ï¼Œæ ·å¼
UIAlertAction *defaultAction = [UIAlertAction actionWithTitle:@"ç¡®å®š" style:UIAlertActionStyleDefault handler:nil];
[defaultAction setValue:[UIColor blackColor] forKey:@"_titleTextColor"];
[alertVC addAction:defaultAction];

[self presentViewController:alertVC animated:YES completion:nil];
</code></pre>

<p>ä¸Šé¢ä½¿ç”¨äº†ä¸€ç§ä¸ªäººæ¯”è¾ƒå–œæ¬¢çš„æ–¹æ³•ï¼Œ</p>

<blockquote><p>æ€»ä½“æ¥è¯´ï¼Œç¬¬äºŒç§åŠæ³•è¿˜æ˜¯å¾ˆå¥½åœ°ï¼Œå»ºè®®å¤§å®¶ä½¿ç”¨ç¬¬äºŒç§åŠæ³•ã€‚</p></blockquote>

<hr />

<pre><code>Q Qï¼š2211523682/790806573

å¾®ä¿¡ï¼š18370997821/13148454507

å¾®åšWB:http://weibo.com/u/3288975567?is_hot=1

gitåšæ–‡ï¼šhttp://al1020119.github.io/

githubï¼šhttps://github.com/al1020119
</code></pre>

<p><img src="/images/iCocosCoder.jpg" title="Caption" ></p>

<p><img src="/images/iCocosPublic.jpg" title="Caption" ></p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">iCocos</span></span>

      




<time class='entry-date' datetime='2016-10-16T12:47:16+08:00'><span class='date'><span class='date-month'>Oct</span> <span class='date-day'>16</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>12:47 pm</span></time>
      


    </p>
    
      <div class="sharing">
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2016/10/14/ioszhuang-bi-pian-apobian-cheng/" title="Previous Post: iOSè£…é€¼ç¯‡â€”â€”AOPç¼–ç¨‹">&laquo; iOSè£…é€¼ç¯‡â€”â€”AOPç¼–ç¨‹</a>
      
      
        <a class="basic-alignment right" href="/blog/2016/10/20/apptai-pang-liao-jian-fei/" title="Next Post: Appå¤ªèƒ–äº†â€”â€”å‡è‚¥ğŸ˜‚">Appå¤ªèƒ–äº†â€”â€”å‡è‚¥ğŸ˜‚ &raquo;</a>
      
    </p>
  </footer>
</article>



  <section>
    <h1>Comments</h1>
    <div id="comments" aria-live="polite"><!-- Duoshuo Comment BEGIN -->
<div class="ds-thread" data-title="iOSå¼€å‘â€”â€”å¸¸ç”¨åŠŸèƒ½ä»£ç é›†é”¦ï¼ˆå‹ç§€ç¯‡ï¼‰"></div>
<script type="text/javascript">
  var duoshuoQuery = {short_name:"icocoscao"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = 'http://static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script>
<!-- Duoshuo Comment END --></div>
  </section>


</div>

<aside class="sidebar">
  
    <section>
    <h1>æ–‡ç« åˆ†ç±»</h1>
    <ul id="categories">
        <li class='category'><a href='/blog/categories/algorithms/'>algorithms (6)</a></li>
<li class='category'><a href='/blog/categories/and/'>and (11)</a></li>
<li class='category'><a href='/blog/categories/apples/'>apples (2)</a></li>
<li class='category'><a href='/blog/categories/application/'>application (1)</a></li>
<li class='category'><a href='/blog/categories/architecture/'>architecture (2)</a></li>
<li class='category'><a href='/blog/categories/audio/'>audio (5)</a></li>
<li class='category'><a href='/blog/categories/audio-video/'>audio-video (1)</a></li>
<li class='category'><a href='/blog/categories/data/'>data (6)</a></li>
<li class='category'><a href='/blog/categories/developer/'>developer (16)</a></li>
<li class='category'><a href='/blog/categories/foundation/'>foundation (31)</a></li>
<li class='category'><a href='/blog/categories/full/'>full (13)</a></li>
<li class='category'><a href='/blog/categories/low-level/'>low-level (4)</a></li>
<li class='category'><a href='/blog/categories/lve/'>lve (5)</a></li>
<li class='category'><a href='/blog/categories/news/'>news (4)</a></li>
<li class='category'><a href='/blog/categories/others/'>others (1)</a></li>
<li class='category'><a href='/blog/categories/performance/'>performance (12)</a></li>
<li class='category'><a href='/blog/categories/php-lover/'>php-lover (2)</a></li>
<li class='category'><a href='/blog/categories/practical/'>practical (1)</a></li>
<li class='category'><a href='/blog/categories/radio/'>radio (5)</a></li>
<li class='category'><a href='/blog/categories/reverse/'>reverse (6)</a></li>
<li class='category'><a href='/blog/categories/senior/'>senior (31)</a></li>
<li class='category'><a href='/blog/categories/stack/'>stack (13)</a></li>
<li class='category'><a href='/blog/categories/structures/'>structures (6)</a></li>
<li class='category'><a href='/blog/categories/summarize/'>summarize (5)</a></li>
<li class='category'><a href='/blog/categories/tools/'>tools (5)</a></li>
<li class='category'><a href='/blog/categories/video/'>video (5)</a></li>

    </ul>
</section><section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2017/01/20/chu-shi-llvm-slash-clang/">åˆè¯†LLVM/Clang</a>
      </li>
    
      <li class="post">
        <a href="/blog/2017/01/12/node-dot-jsshi-shi-yao-gui-%3F/">Node.jsæ˜¯ä»€ä¹ˆé¬¼ï¼Ÿ</a>
      </li>
    
      <li class="post">
        <a href="/blog/2017/01/10/appda-bao-fa-bu-keng-zhong-zhi-keng/">Appæ‰“åŒ…å‘å¸ƒâ€”â€”â€”å‘ä¸­ä¹‹å‘</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/12/30/bao-chi-chu-cin-ji-xu-qian-jin/">ä¿æŒåˆå¿ƒç»§ç»­å‰è¿›-å¹´ç»ˆç¯‡</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/12/26/ios-daobao/">è‡ªåŠ¨æ‰“åŒ…ä¸Šä¼ ä»£ç </a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/al1020119">@al1020119</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'al1020119',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>





<section>
<h1>åšå®¢<abbr title="The word 'åšå®¢' is a registered trademark of DENSO WAVE INCORPORATED. It applies only for the word 'åšå®¢', not for image.">&trade;</abbr></h1>
<a href="http://al1020119.github.io/blog/2016/10/16/ioskai-fa-chang-yong-gong-neng-dai-ma-ji-jin-(you-xiu-pian-)/"><img src="http://chart.apis.google.com/chart?chs=150x150&cht=qr&chld=|0&chco=165B94&chl=http://al1020119.github.io/blog/2016/10/16/ioskai-fa-chang-yong-gong-neng-dai-ma-ji-jin-(you-xiu-pian-)/" alt="post-qrcode"></a></section>


<section>
<h1>github<abbr title="The word 'github' is a registered trademark of DENSO WAVE INCORPORATED. It applies only for the word 'github', not for image.">&trade;</abbr></h1>
<a><img src="/images/iCocosgithub.png" alt="post-qrcode"></a></section>


<section>
<h1>å¾®ä¿¡<abbr title="The word 'å¾®ä¿¡' is a registered trademark of DENSO WAVE INCORPORATED. It applies only for the word 'å¾®ä¿¡', not for image.">&trade;</abbr></h1>
<a><img src="/images/iCocosWX.png" alt="post-qrcode"></a></section>


<section>
<h1>å…¬ä¼—å·<abbr title="The word 'å…¬ä¼—å·' is a registered trademark of DENSO WAVE INCORPORATED. It applies only for the word 'å…¬ä¼—å·', not for image.">&trade;</abbr></h1>
<a><img src="/images/iCocosMGC.png" alt="post-qrcode"></a><section>
  
  
</section>
<h1>å…¬ä¼—å·<abbr title="The word 'å…¬ä¼—å·' is a registered trademark of DENSO WAVE INCORPORATED. It applies only for the word 'å…¬ä¼—å·', not for image.">&trade;</abbr></h1>
<a><img src="/images/iCocos520.png" alt="post-qrcode"></a></section>
<section>
    <h1>è®¿å®¢ç»Ÿè®¡</h1>
    <br/>
    <a href="http://s07.flagcounter.com/more/2SH"><img src="http://s07.flagcounter.com/count/2SH/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_1/flags_0/" alt="Flag Counter" border="0"></a>
</section><section>
    <h1>æ–°æµªå¾®åš</h1>
    <ul id="weibo">
        <li>
            
            <!-- åœ¨æ­¤æ’å…¥è·å¾—çš„å¾®åšç§€ä»£ç  -->
            <iframe width="100%" height="550" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=550&fansRow=2&ptype=1&speed=0&skin=1&isTitle=1&noborder=1&isWeibo=1&isFans=1&uid=3288975567&verifier=20ffcedd&dpc=1"></iframe>
            
        </li>
    </ul>
</section>
  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2013 - iCocos -
<span class="credit">welcome to <a href="http://al1020119.github.io">æ›¹#é»</a></span>
</p>

</footer>
  






<!--
-->



</body>
</html>
