---
layout: post
title: "å¤šçº¿ç¨‹å®‰å…¨ï¼Ÿå„ç§é”çš„å®ç°åŸç†ğŸ˜‚"
date: 2016-08-31 15:06:21 +0800
comments: true
categories: 
---


æœ¬æ–‡è¦åšçš„å°±æ˜¯ç®€å•çš„åˆ†æ iOS å¼€å‘ä¸­å¸¸è§çš„å‡ ç§é”å¦‚ä½•å®ç°ï¼Œä»¥åŠä¼˜ç¼ºç‚¹æ˜¯ä»€ä¹ˆï¼Œä¸ºä»€ä¹ˆä¼šæœ‰æ€§èƒ½ä¸Šçš„å·®è·ï¼Œæœ€ç»ˆä¼šç®€å•çš„ä»‹ç»é”çš„åº•å±‚å®ç°åŸç†ã€‚æ°´å¹³æœ‰é™ï¼Œå¦‚æœä¸æ…æœ‰è¯¯ï¼Œæ¬¢è¿äº¤æµæŒ‡æ­£ã€‚åŒæ—¶å»ºè®®è¯»è€…åœ¨é˜…è¯»æœ¬æ–‡ä»¥å‰ï¼Œå¯¹ OC ä¸­å„ç§é”çš„ä½¿ç”¨æ–¹æ³•å…ˆæœ‰å¤§æ¦‚çš„è®¤è¯†ã€‚


åœ¨ ibireme çš„ ä¸å†å®‰å…¨çš„ OSSpinLock ä¸€æ–‡ä¸­ï¼Œæœ‰ä¸€å¼ å›¾ç‰‡ç®€å•çš„æ¯”è¾ƒäº†å„ç§é”çš„åŠ è§£é”æ€§èƒ½:


{% img /images/duoxianchengsuoshixianyuanli001.png Caption %}  



<!--more-->



æœ¬æ–‡ä¼šæŒ‰ç…§ä»ä¸Šè‡³ä¸‹(é€Ÿåº¦ç”±å¿«è‡³æ…¢)çš„é¡ºåºåˆ†ææ¯ä¸ªé”çš„å®ç°åŸç†ã€‚éœ€è¦è¯´æ˜çš„æ˜¯ï¼ŒåŠ è§£é”é€Ÿåº¦ä¸è¡¨ç¤ºé”çš„æ•ˆç‡ï¼Œåªè¡¨ç¤ºåŠ è§£é”æ“ä½œåœ¨æ‰§è¡Œæ—¶çš„å¤æ‚ç¨‹åº¦ï¼Œä¸‹æ–‡ä¼šé€šè¿‡å…·ä½“çš„ä¾‹å­æ¥è§£é‡Šã€‚


##OSSpinLock


ä¸Šè¿°æ–‡ç« ä¸­å·²ç»ä»‹ç»äº† OSSpinLock ä¸å†å®‰å…¨ï¼Œä¸»è¦åŸå› å‘ç”Ÿåœ¨ä½ä¼˜å…ˆçº§çº¿ç¨‹æ‹¿åˆ°é”æ—¶ï¼Œé«˜ä¼˜å…ˆçº§çº¿ç¨‹è¿›å…¥å¿™ç­‰(busy-wait)çŠ¶æ€ï¼Œæ¶ˆè€—å¤§é‡ CPU æ—¶é—´ï¼Œä»è€Œå¯¼è‡´ä½ä¼˜å…ˆçº§çº¿ç¨‹æ‹¿ä¸åˆ° CPU æ—¶é—´ï¼Œä¹Ÿå°±æ— æ³•å®Œæˆä»»åŠ¡å¹¶é‡Šæ”¾é”ã€‚è¿™ç§é—®é¢˜è¢«ç§°ä¸ºä¼˜å…ˆçº§åè½¬ã€‚


ä¸ºä»€ä¹ˆå¿™ç­‰ä¼šå¯¼è‡´ä½ä¼˜å…ˆçº§çº¿ç¨‹æ‹¿ä¸åˆ°æ—¶é—´ç‰‡ï¼Ÿè¿™è¿˜å¾—ä»æ“ä½œç³»ç»Ÿçš„çº¿ç¨‹è°ƒåº¦è¯´èµ·ã€‚


	ç°ä»£æ“ä½œç³»ç»Ÿåœ¨ç®¡ç†æ™®é€šçº¿ç¨‹æ—¶ï¼Œé€šå¸¸é‡‡ç”¨æ—¶é—´ç‰‡è½®è½¬ç®—æ³•(Round Robinï¼Œç®€ç§° RR)ã€‚æ¯ä¸ªçº¿ç¨‹ä¼šè¢«åˆ†é…ä¸€æ®µæ—¶é—´ç‰‡(quantum)ï¼Œé€šå¸¸åœ¨ 10-100 æ¯«ç§’å·¦å³ã€‚å½“çº¿ç¨‹ç”¨å®Œå±äºè‡ªå·±çš„æ—¶é—´ç‰‡ä»¥åï¼Œå°±ä¼šè¢«æ“ä½œç³»ç»ŸæŒ‚èµ·ï¼Œæ”¾å…¥ç­‰å¾…é˜Ÿåˆ—ä¸­ï¼Œç›´åˆ°ä¸‹ä¸€æ¬¡è¢«åˆ†é…æ—¶é—´ç‰‡ã€‚


####è‡ªæ—‹é”çš„å®ç°åŸç†


è‡ªæ—‹é”çš„ç›®çš„æ˜¯ä¸ºäº†ç¡®ä¿ä¸´ç•ŒåŒºåªæœ‰ä¸€ä¸ªçº¿ç¨‹å¯ä»¥è®¿é—®ï¼Œå®ƒçš„ä½¿ç”¨å¯ä»¥ç”¨ä¸‹é¢è¿™æ®µä¼ªä»£ç æ¥æè¿°:


    do {

        Acquire Lock

            Critical section  // ä¸´ç•ŒåŒº

        Release Lock

            Reminder section // ä¸éœ€è¦é”ä¿æŠ¤çš„ä»£ç 

    }


åœ¨ Acquire Lock è¿™ä¸€æ­¥ï¼Œæˆ‘ä»¬ç”³è¯·åŠ é”ï¼Œç›®çš„æ˜¯ä¸ºäº†ä¿æŠ¤ä¸´ç•ŒåŒº(Critical Section) ä¸­çš„ä»£ç ä¸ä¼šè¢«å¤šä¸ªçº¿ç¨‹æ‰§è¡Œã€‚


è‡ªæ—‹é”çš„å®ç°æ€è·¯å¾ˆç®€å•ï¼Œç†è®ºä¸Šæ¥è¯´åªè¦å®šä¹‰ä¸€ä¸ªå…¨å±€å˜é‡ï¼Œç”¨æ¥è¡¨ç¤ºé”çš„å¯ç”¨æƒ…å†µå³å¯ï¼Œä¼ªä»£ç å¦‚ä¸‹:


    bool lock = false; // ä¸€å¼€å§‹æ²¡æœ‰é”ä¸Šï¼Œä»»ä½•çº¿ç¨‹éƒ½å¯ä»¥ç”³è¯·é”

    do {

        while(lock); // å¦‚æœ lock ä¸º true å°±ä¸€ç›´æ­»å¾ªç¯ï¼Œç›¸å½“äºç”³è¯·é”

        lock = true; // æŒ‚ä¸Šé”ï¼Œè¿™æ ·åˆ«çš„çº¿ç¨‹å°±æ— æ³•è·å¾—é”

            Critical section  // ä¸´ç•ŒåŒº

        lock = false; // ç›¸å½“äºé‡Šæ”¾é”ï¼Œè¿™æ ·åˆ«çš„çº¿ç¨‹å¯ä»¥è¿›å…¥ä¸´ç•ŒåŒº

            Reminder section // ä¸éœ€è¦é”ä¿æŠ¤çš„ä»£ç         

    }


æ³¨é‡Šå†™å¾—å¾ˆæ¸…æ¥šï¼Œå°±ä¸å†é€è¡Œåˆ†æäº†ã€‚å¯æƒœè¿™æ®µä»£ç å­˜åœ¨ä¸€ä¸ªé—®é¢˜: å¦‚æœä¸€å¼€å§‹æœ‰å¤šä¸ªçº¿ç¨‹åŒæ—¶æ‰§è¡Œ while å¾ªç¯ï¼Œä»–ä»¬éƒ½ä¸ä¼šåœ¨è¿™é‡Œå¡ä½ï¼Œè€Œæ˜¯ç»§ç»­æ‰§è¡Œï¼Œè¿™æ ·å°±æ— æ³•ä¿è¯é”çš„å¯é æ€§äº†ã€‚è§£å†³æ€è·¯ä¹Ÿå¾ˆç®€å•ï¼Œåªè¦ç¡®ä¿ç”³è¯·é”çš„è¿‡ç¨‹æ˜¯åŸå­æ“ä½œå³å¯ã€‚


####åŸå­æ“ä½œ


ç‹­ä¹‰ä¸Šçš„åŸå­æ“ä½œè¡¨ç¤ºä¸€æ¡ä¸å¯æ‰“æ–­çš„æ“ä½œï¼Œä¹Ÿå°±æ˜¯è¯´çº¿ç¨‹åœ¨æ‰§è¡Œæ“ä½œè¿‡ç¨‹ä¸­ï¼Œä¸ä¼šè¢«æ“ä½œç³»ç»ŸæŒ‚èµ·ï¼Œè€Œæ˜¯ä¸€å®šä¼šæ‰§è¡Œå®Œã€‚åœ¨å•å¤„ç†å™¨ç¯å¢ƒä¸‹ï¼Œä¸€æ¡æ±‡ç¼–æŒ‡ä»¤æ˜¾ç„¶æ˜¯åŸå­æ“ä½œï¼Œå› ä¸ºä¸­æ–­ä¹Ÿè¦é€šè¿‡æŒ‡ä»¤æ¥å®ç°ã€‚


> ç„¶è€Œåœ¨å¤šå¤„ç†å™¨çš„æƒ…å†µä¸‹ï¼Œèƒ½å¤Ÿè¢«å¤šä¸ªå¤„ç†å™¨åŒæ—¶æ‰§è¡Œçš„æ“ä½œä»»ç„¶ç®—ä¸ä¸ŠåŸå­æ“ä½œã€‚å› æ­¤ï¼ŒçœŸæ­£çš„åŸå­æ“ä½œå¿…é¡»ç”±ç¡¬ä»¶æä¾›æ”¯æŒï¼Œæ¯”å¦‚ x86 å¹³å°ä¸Šå¦‚æœåœ¨æŒ‡ä»¤å‰é¢åŠ ä¸Š â€œLOCKâ€ å‰ç¼€ï¼Œå¯¹åº”çš„æœºå™¨ç åœ¨æ‰§è¡Œæ—¶ä¼šæŠŠæ€»çº¿é”ä½ï¼Œä½¿å¾—å…¶ä»– CPUä¸èƒ½å†æ‰§è¡Œç›¸åŒæ“ä½œï¼Œä»è€Œä»ç¡¬ä»¶å±‚é¢ç¡®ä¿äº†æ“ä½œçš„åŸå­æ€§ã€‚


è¿™äº›éå¸¸åº•å±‚çš„æ¦‚å¿µæ— éœ€å®Œå…¨æŒæ¡ï¼Œæˆ‘ä»¬åªè¦çŸ¥é“ä¸Šè¿°ç”³è¯·é”çš„è¿‡ç¨‹ï¼Œå¯ä»¥ç”¨ä¸€ä¸ªåŸå­æ€§æ“ä½œ test_and_set æ¥å®Œæˆï¼Œå®ƒç”¨ä¼ªä»£ç å¯ä»¥è¿™æ ·è¡¨ç¤º:


    bool test_and_set (bool *target) {

        bool rv = *target; 

        *target = TRUE; 

        return rv;

    }


è¿™æ®µä»£ç çš„ä½œç”¨æ˜¯æŠŠ target çš„å€¼è®¾ç½®ä¸º 1ï¼Œå¹¶è¿”å›åŸæ¥çš„å€¼ã€‚å½“ç„¶ï¼Œåœ¨å…·ä½“å®ç°æ—¶ï¼Œå®ƒé€šè¿‡ä¸€ä¸ªåŸå­æ€§çš„æŒ‡ä»¤æ¥å®Œæˆã€‚


####è‡ªæ—‹é”çš„æ€»ç»“


è‡³æ­¤ï¼Œè‡ªæ—‹é”çš„å®ç°åŸç†å°±å¾ˆæ¸…æ¥šäº†:


    bool lock = false; // ä¸€å¼€å§‹æ²¡æœ‰é”ä¸Šï¼Œä»»ä½•çº¿ç¨‹éƒ½å¯ä»¥ç”³è¯·é”

    do {

        while(test_and_set(&lock); // test_and_set æ˜¯ä¸€ä¸ªåŸå­æ“ä½œ

            Critical section  // ä¸´ç•ŒåŒº

        lock = false; // ç›¸å½“äºé‡Šæ”¾é”ï¼Œè¿™æ ·åˆ«çš„çº¿ç¨‹å¯ä»¥è¿›å…¥ä¸´ç•ŒåŒº

            Reminder section // ä¸éœ€è¦é”ä¿æŠ¤çš„ä»£ç         

    }


å¦‚æœä¸´ç•ŒåŒºçš„æ‰§è¡Œæ—¶é—´è¿‡é•¿ï¼Œä½¿ç”¨è‡ªæ—‹é”ä¸æ˜¯ä¸ªå¥½ä¸»æ„ã€‚ä¹‹å‰æˆ‘ä»¬ä»‹ç»è¿‡æ—¶é—´ç‰‡è½®è½¬ç®—æ³•ï¼Œçº¿ç¨‹åœ¨å¤šç§æƒ…å†µä¸‹ä¼šé€€å‡ºè‡ªå·±çš„æ—¶é—´ç‰‡ã€‚å…¶ä¸­ä¸€ç§æ˜¯ç”¨å®Œäº†æ—¶é—´ç‰‡çš„æ—¶é—´ï¼Œè¢«æ“ä½œç³»ç»Ÿå¼ºåˆ¶æŠ¢å ã€‚é™¤æ­¤ä»¥å¤–ï¼Œå½“çº¿ç¨‹è¿›è¡Œ I/O æ“ä½œï¼Œæˆ–è¿›å…¥ç¡çœ çŠ¶æ€æ—¶ï¼Œéƒ½ä¼šä¸»åŠ¨è®©å‡ºæ—¶é—´ç‰‡ã€‚æ˜¾ç„¶åœ¨ while å¾ªç¯ä¸­ï¼Œçº¿ç¨‹å¤„äºå¿™ç­‰çŠ¶æ€ï¼Œç™½ç™½æµªè´¹ CPU æ—¶é—´ï¼Œæœ€ç»ˆå› ä¸ºè¶…æ—¶è¢«æ“ä½œç³»ç»ŸæŠ¢å æ—¶é—´ç‰‡ã€‚å¦‚æœä¸´ç•ŒåŒºæ‰§è¡Œæ—¶é—´è¾ƒé•¿ï¼Œæ¯”å¦‚æ˜¯æ–‡ä»¶è¯»å†™ï¼Œè¿™ç§å¿™ç­‰æ˜¯æ¯«æ— å¿…è¦çš„ã€‚


##ä¿¡å·é‡


ä¹‹å‰æˆ‘åœ¨ ä»‹ç» GCD åº•å±‚å®ç°çš„æ–‡ç«  ä¸­ç®€å•æè¿°äº†ä¿¡å·é‡ dispatch_semaphore_t çš„å®ç°åŸç†ï¼Œå®ƒæœ€ç»ˆä¼šè°ƒç”¨åˆ° sem_wait æ–¹æ³•ï¼Œè¿™ä¸ªæ–¹æ³•åœ¨ glibc ä¸­è¢«å®ç°å¦‚ä¸‹:


    int sem_wait (sem_t *sem) {

      int *futex = (int *) sem;

      if (atomic_decrement_if_positive (futex) > 0)

        return 0;

      int err = lll_futex_wait (futex, 0);

        return -1;

    )


é¦–å…ˆä¼šæŠŠä¿¡å·é‡çš„å€¼å‡ä¸€ï¼Œå¹¶åˆ¤æ–­æ˜¯å¦å¤§äºé›¶ã€‚å¦‚æœå¤§äºé›¶ï¼Œè¯´æ˜ä¸ç”¨ç­‰å¾…ï¼Œæ‰€ä»¥ç«‹åˆ»è¿”å›ã€‚å…·ä½“çš„ç­‰å¾…æ“ä½œåœ¨ lll_futex_wait å‡½æ•°ä¸­å®ç°ï¼Œlll æ˜¯ low level lock çš„ç®€ç§°ã€‚è¿™ä¸ªå‡½æ•°é€šè¿‡æ±‡ç¼–ä»£ç å®ç°ï¼Œè°ƒç”¨åˆ° SYS_futex è¿™ä¸ªç³»ç»Ÿè°ƒç”¨ï¼Œä½¿çº¿ç¨‹è¿›å…¥ç¡çœ çŠ¶æ€ï¼Œä¸»åŠ¨è®©å‡ºæ—¶é—´ç‰‡ï¼Œè¿™ä¸ªå‡½æ•°åœ¨äº’æ–¥é”çš„å®ç°ä¸­ï¼Œä¹Ÿæœ‰å¯èƒ½è¢«ç”¨åˆ°ã€‚


+ ä¸»åŠ¨è®©å‡ºæ—¶é—´ç‰‡å¹¶ä¸æ€»æ˜¯ä»£è¡¨æ•ˆç‡é«˜ã€‚è®©å‡ºæ—¶é—´ç‰‡ä¼šå¯¼è‡´æ“ä½œç³»ç»Ÿåˆ‡æ¢åˆ°å¦ä¸€ä¸ªçº¿ç¨‹ï¼Œè¿™ç§ä¸Šä¸‹æ–‡åˆ‡æ¢é€šå¸¸éœ€è¦ 10 å¾®ç§’å·¦å³ï¼Œè€Œä¸”è‡³å°‘éœ€è¦ä¸¤æ¬¡åˆ‡æ¢ã€‚å¦‚æœç­‰å¾…æ—¶é—´å¾ˆçŸ­ï¼Œæ¯”å¦‚åªæœ‰å‡ ä¸ªå¾®ç§’ï¼Œå¿™ç­‰å°±æ¯”çº¿ç¨‹ç¡çœ æ›´é«˜æ•ˆã€‚


å¯ä»¥çœ‹åˆ°ï¼Œè‡ªæ—‹é”å’Œä¿¡å·é‡çš„å®ç°éƒ½éå¸¸ç®€å•ï¼Œè¿™ä¹Ÿæ˜¯ä¸¤è€…çš„åŠ è§£é”è€—æ—¶åˆ†åˆ«æ’åœ¨ç¬¬ä¸€å’Œç¬¬äºŒçš„åŸå› ã€‚å†æ¬¡å¼ºè°ƒï¼ŒåŠ è§£é”è€—æ—¶ä¸èƒ½å‡†ç¡®ååº”å‡ºé”çš„æ•ˆç‡(æ¯”å¦‚æ—¶é—´ç‰‡åˆ‡æ¢å°±æ— æ³•å‘ç”Ÿ)ï¼Œå®ƒåªèƒ½ä»ä¸€å®šç¨‹åº¦ä¸Šè¡¡é‡é”çš„å®ç°å¤æ‚ç¨‹åº¦ã€‚


##pthread_mutex


pthread è¡¨ç¤º POSIX threadï¼Œå®šä¹‰äº†ä¸€ç»„è·¨å¹³å°çš„çº¿ç¨‹ç›¸å…³çš„ APIï¼Œpthread_mutex è¡¨ç¤ºäº’æ–¥é”ã€‚äº’æ–¥é”çš„å®ç°åŸç†ä¸ä¿¡å·é‡éå¸¸ç›¸ä¼¼ï¼Œä¸æ˜¯ä½¿ç”¨å¿™ç­‰ï¼Œè€Œæ˜¯é˜»å¡çº¿ç¨‹å¹¶ç¡çœ ï¼Œéœ€è¦è¿›è¡Œä¸Šä¸‹æ–‡åˆ‡æ¢ã€‚


äº’æ–¥é”çš„å¸¸è§ç”¨æ³•å¦‚ä¸‹:


    pthread_mutexattr_t attr;

    pthread_mutexattr_init(&attr);

    pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_NORMAL);  // å®šä¹‰é”çš„å±æ€§

     

    pthread_mutex_t mutex;

    pthread_mutex_init(&mutex, &attr) // åˆ›å»ºé”

     

    pthread_mutex_lock(&mutex); // ç”³è¯·é”

        // ä¸´ç•ŒåŒº

    pthread_mutex_unlock(&mutex); // é‡Šæ”¾é”


å¯¹äº pthread_mutex æ¥è¯´ï¼Œå®ƒçš„ç”¨æ³•å’Œä¹‹å‰æ²¡æœ‰å¤ªå¤§çš„æ”¹å˜ï¼Œæ¯”è¾ƒé‡è¦çš„æ˜¯é”çš„ç±»å‹ï¼Œå¯ä»¥æœ‰ PTHREAD_MUTEX_NORMALã€PTHREAD_MUTEX_ERRORCHECKã€PTHREAD_MUTEX_RECURSIVE ç­‰ç­‰ï¼Œå…·ä½“çš„ç‰¹æ€§å°±ä¸åšè§£é‡Šäº†ï¼Œç½‘ä¸Šæœ‰å¾ˆå¤šç›¸å…³èµ„æ–™ã€‚


> ä¸€èˆ¬æƒ…å†µä¸‹ï¼Œä¸€ä¸ªçº¿ç¨‹åªèƒ½ç”³è¯·ä¸€æ¬¡é”ï¼Œä¹Ÿåªèƒ½åœ¨è·å¾—é”çš„æƒ…å†µä¸‹æ‰èƒ½é‡Šæ”¾é”ï¼Œå¤šæ¬¡ç”³è¯·é”æˆ–é‡Šæ”¾æœªè·å¾—çš„é”éƒ½ä¼šå¯¼è‡´å´©æºƒã€‚å‡è®¾åœ¨å·²ç»è·å¾—é”çš„æƒ…å†µä¸‹å†æ¬¡ç”³è¯·é”ï¼Œçº¿ç¨‹ä¼šå› ä¸ºç­‰å¾…é”çš„é‡Šæ”¾è€Œè¿›å…¥ç¡çœ çŠ¶æ€ï¼Œå› æ­¤å°±ä¸å¯èƒ½å†é‡Šæ”¾é”ï¼Œä»è€Œå¯¼è‡´æ­»é”ã€‚


ç„¶è€Œè¿™ç§æƒ…å†µç»å¸¸ä¼šå‘ç”Ÿï¼Œæ¯”å¦‚æŸä¸ªå‡½æ•°ç”³è¯·äº†é”ï¼Œåœ¨ä¸´ç•ŒåŒºå†…åˆé€’å½’è°ƒç”¨äº†è‡ªå·±ã€‚è¾›è¿çš„æ˜¯ pthread_mutex æ”¯æŒé€’å½’é”ï¼Œä¹Ÿå°±æ˜¯å…è®¸ä¸€ä¸ªçº¿ç¨‹é€’å½’çš„ç”³è¯·é”ï¼Œåªè¦æŠŠ attr çš„ç±»å‹æ”¹æˆ PTHREAD_MUTEX_RECURSIVE å³å¯ã€‚


##äº’æ–¥é”çš„å®ç°


äº’æ–¥é”åœ¨ç”³è¯·é”æ—¶ï¼Œè°ƒç”¨äº† pthread_mutex_lock æ–¹æ³•ï¼Œå®ƒåœ¨ä¸åŒçš„ç³»ç»Ÿä¸Šå®ç°å„æœ‰ä¸åŒï¼Œæœ‰æ—¶å€™å®ƒçš„å†…éƒ¨æ˜¯ä½¿ç”¨ä¿¡å·é‡æ¥å®ç°ï¼Œå³ä½¿ä¸ç”¨ä¿¡å·é‡ï¼Œä¹Ÿä¼šè°ƒç”¨åˆ° lll_futex_wait å‡½æ•°ï¼Œä»è€Œå¯¼è‡´çº¿ç¨‹ä¼‘çœ ã€‚


> ä¸Šæ–‡è¯´åˆ°å¦‚æœä¸´ç•ŒåŒºå¾ˆçŸ­ï¼Œå¿™ç­‰çš„æ•ˆç‡ä¹Ÿè®¸æ›´é«˜ï¼Œæ‰€ä»¥åœ¨æœ‰äº›ç‰ˆæœ¬çš„å®ç°ä¸­ï¼Œä¼šé¦–å…ˆå°è¯•ä¸€å®šæ¬¡æ•°(æ¯”å¦‚ 1000 æ¬¡)çš„ test_and_testï¼Œè¿™æ ·å¯ä»¥åœ¨é”™è¯¯ä½¿ç”¨äº’æ–¥é”æ—¶æé«˜æ€§èƒ½ã€‚


å¦å¤–ï¼Œç”±äº pthread_mutex æœ‰å¤šç§ç±»å‹ï¼Œå¯ä»¥æ”¯æŒé€’å½’é”ç­‰ï¼Œå› æ­¤åœ¨ç”³è¯·åŠ é”æ—¶ï¼Œéœ€è¦å¯¹é”çš„ç±»å‹åŠ ä»¥åˆ¤æ–­ï¼Œè¿™ä¹Ÿå°±æ˜¯ä¸ºä»€ä¹ˆå®ƒå’Œä¿¡å·é‡çš„å®ç°ç±»ä¼¼ï¼Œä½†æ•ˆç‡ç•¥ä½çš„åŸå› ã€‚


##NSLock


NSLock æ˜¯ Objective-C ä»¥å¯¹è±¡çš„å½¢å¼æš´éœ²ç»™å¼€å‘è€…çš„ä¸€ç§é”ï¼Œå®ƒçš„å®ç°éå¸¸ç®€å•ï¼Œé€šè¿‡å®ï¼Œå®šä¹‰äº† lock æ–¹æ³•:


    #define    MLOCK \

    - (void) lock\

    {\

      int err = pthread_mutex_lock(&_mutex);\

      // é”™è¯¯å¤„ç† â€¦â€¦

    }


NSLock åªæ˜¯åœ¨å†…éƒ¨å°è£…äº†ä¸€ä¸ª pthread_mutexï¼Œå±æ€§ä¸º PTHREAD_MUTEX_ERRORCHECKï¼Œå®ƒä¼šæŸå¤±ä¸€å®šæ€§èƒ½æ¢æ¥é”™è¯¯æç¤ºã€‚


è¿™é‡Œä½¿ç”¨å®å®šä¹‰çš„åŸå› æ˜¯ï¼ŒOC å†…éƒ¨è¿˜æœ‰å…¶ä»–å‡ ç§é”ï¼Œä»–ä»¬çš„ lock æ–¹æ³•éƒ½æ˜¯ä¸€æ¨¡ä¸€æ ·ï¼Œä»…ä»…æ˜¯å†…éƒ¨ pthread_mutex äº’æ–¥é”çš„ç±»å‹ä¸åŒã€‚é€šè¿‡å®å®šä¹‰ï¼Œå¯ä»¥ç®€åŒ–æ–¹æ³•çš„å®šä¹‰ã€‚


> NSLock æ¯” pthread_mutex ç•¥æ…¢çš„åŸå› åœ¨äºå®ƒéœ€è¦ç»è¿‡æ–¹æ³•è°ƒç”¨ï¼ŒåŒæ—¶ç”±äºç¼“å­˜çš„å­˜åœ¨ï¼Œå¤šæ¬¡æ–¹æ³•è°ƒç”¨ä¸ä¼šå¯¹æ€§èƒ½äº§ç”Ÿå¤ªå¤§çš„å½±å“ã€‚


##NSCondition


NSCondition çš„åº•å±‚æ˜¯é€šè¿‡æ¡ä»¶å˜é‡(condition variable) pthread_cond_t æ¥å®ç°çš„ã€‚æ¡ä»¶å˜é‡æœ‰ç‚¹åƒä¿¡å·é‡ï¼Œæä¾›äº†çº¿ç¨‹é˜»å¡ä¸ä¿¡å·æœºåˆ¶ï¼Œå› æ­¤å¯ä»¥ç”¨æ¥é˜»å¡æŸä¸ªçº¿ç¨‹ï¼Œå¹¶ç­‰å¾…æŸä¸ªæ•°æ®å°±ç»ªï¼Œéšåå”¤é†’çº¿ç¨‹ï¼Œæ¯”å¦‚å¸¸è§çš„ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å¼ã€‚


####å¦‚ä½•ä½¿ç”¨æ¡ä»¶å˜é‡


å¾ˆå¤šä»‹ç» pthread_cond_t çš„æ–‡ç« éƒ½ä¼šæåˆ°ï¼Œå®ƒéœ€è¦ä¸äº’æ–¥é”é…åˆä½¿ç”¨:


    void consumer () { // æ¶ˆè´¹è€…

        pthread_mutex_lock(&mutex);

        while (data == NULL) {

            pthread_cond_wait(&condition_variable_signal, &mutex); // ç­‰å¾…æ•°æ®

        }

        // --- æœ‰æ–°çš„æ•°æ®ï¼Œä»¥ä¸‹ä»£ç è´Ÿè´£å¤„ç† â†“â†“â†“â†“â†“â†“

        // temp = data;

        // --- æœ‰æ–°çš„æ•°æ®ï¼Œä»¥ä¸Šä»£ç è´Ÿè´£å¤„ç† â†‘â†‘â†‘â†‘â†‘â†‘

        pthread_mutex_unlock(&mutex);

    }

     

    void producer () {

        pthread_mutex_lock(&mutex);

        // ç”Ÿäº§æ•°æ®

        pthread_cond_signal(&condition_variable_signal); // å‘å‡ºä¿¡å·ç»™æ¶ˆè´¹è€…ï¼Œå‘Šè¯‰ä»–ä»¬æœ‰äº†æ–°çš„æ•°æ®

        pthread_mutex_unlock(&mutex);

    }


è‡ªç„¶æˆ‘ä»¬ä¼šæœ‰ç–‘é—®:â€œå¦‚æœä¸ç”¨äº’æ–¥é”ï¼Œåªç”¨æ¡ä»¶å˜é‡ä¼šæœ‰ä»€ä¹ˆé—®é¢˜å‘¢ï¼Ÿâ€ã€‚é—®é¢˜åœ¨äºï¼Œtemp = data; è¿™æ®µä»£ç ä¸æ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼Œä¹Ÿè®¸åœ¨ä½ æŠŠ data è¯»å‡ºæ¥ä»¥å‰ï¼Œå·²ç»æœ‰åˆ«çš„çº¿ç¨‹ä¿®æ”¹äº†æ•°æ®ã€‚å› æ­¤æˆ‘ä»¬éœ€è¦ä¿è¯æ¶ˆè´¹è€…æ‹¿åˆ°çš„æ•°æ®æ˜¯çº¿ç¨‹å®‰å…¨çš„ã€‚


wait æ–¹æ³•é™¤äº†ä¼šè¢« signal æ–¹æ³•å”¤é†’ï¼Œæœ‰æ—¶è¿˜ä¼šè¢«è™šå‡å”¤é†’ï¼Œæ‰€ä»¥éœ€è¦è¿™é‡Œ while å¾ªç¯ä¸­çš„åˆ¤æ–­æ¥åšäºŒæ¬¡ç¡®è®¤ã€‚


####ä¸ºä»€ä¹ˆè¦ä½¿ç”¨æ¡ä»¶å˜é‡


ä»‹ç»æ¡ä»¶å˜é‡çš„æ–‡ç« éå¸¸å¤šï¼Œä½†å¤§å¤šéƒ½å¯¹ä¸€ä¸ªä¸€ä¸ªåŸºæœ¬é—®é¢˜é¿è€Œä¸è°ˆ:â€œä¸ºä»€ä¹ˆè¦ç”¨æ¡ä»¶å˜é‡ï¼Ÿå®ƒä»…ä»…æ˜¯æ§åˆ¶äº†çº¿ç¨‹çš„æ‰§è¡Œé¡ºåºï¼Œç”¨ä¿¡å·é‡æˆ–è€…äº’æ–¥é”èƒ½ä¸èƒ½æ¨¡æ‹Ÿå‡ºç±»ä¼¼æ•ˆæœï¼Ÿâ€


ç½‘ä¸Šçš„ç›¸å…³èµ„æ–™æ¯”è¾ƒå°‘ï¼Œæˆ‘ç®€å•è¯´ä¸€ä¸‹ä¸ªäººçœ‹æ³•ã€‚ä¿¡å·é‡å¯ä»¥ä¸€å®šç¨‹åº¦ä¸Šæ›¿ä»£ conditionï¼Œä½†æ˜¯äº’æ–¥é”ä¸è¡Œã€‚åœ¨ä»¥ä¸Šç»™å‡ºçš„ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å¼çš„ä»£ç ä¸­ï¼Œ pthread_cond_wait æ–¹æ³•çš„æœ¬è´¨æ˜¯é”çš„è½¬ç§»ï¼Œæ¶ˆè´¹è€…æ”¾å¼ƒé”ï¼Œç„¶åç”Ÿäº§è€…è·å¾—é”ï¼ŒåŒç†ï¼Œpthread_cond_signal åˆ™æ˜¯ä¸€ä¸ªé”ä»ç”Ÿäº§è€…åˆ°æ¶ˆè´¹è€…è½¬ç§»çš„è¿‡ç¨‹ã€‚


å¦‚æœä½¿ç”¨äº’æ–¥é”ï¼Œæˆ‘ä»¬éœ€è¦æŠŠä»£ç æ”¹æˆè¿™æ ·:


    void consumer () { // æ¶ˆè´¹è€…

        pthread_mutex_lock(&mutex);

        while (data == NULL) {

            pthread_mutex_unlock(&mutex);

            pthread_mutex_lock(&another_lock)  // ç›¸å½“äº wait å¦ä¸€ä¸ªäº’æ–¥é”

            pthread_mutex_lock(&mutex);

        }

        pthread_mutex_unlock(&mutex);

    }


è¿™æ ·åšå­˜åœ¨çš„é—®é¢˜åœ¨äºï¼Œåœ¨ç­‰å¾… another_lock ä¹‹å‰ï¼Œ ç”Ÿäº§è€…æœ‰å¯èƒ½å…ˆæ‰§è¡Œä»£ç ï¼Œ ä»è€Œé‡Šæ”¾äº† another_lockã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬æ— æ³•ä¿è¯é‡Šæ”¾é”å’Œç­‰å¾…å¦ä¸€ä¸ªé”è¿™ä¸¤ä¸ªæ“ä½œæ˜¯åŸå­æ€§çš„ï¼Œä¹Ÿå°±æ— æ³•ä¿è¯â€œå…ˆç­‰å¾…ã€åé‡Šæ”¾ another_lockâ€ è¿™ä¸ªé¡ºåºã€‚


> ç”¨ä¿¡å·é‡åˆ™ä¸å­˜åœ¨è¿™ä¸ªé—®é¢˜ï¼Œå› ä¸ºä¿¡å·é‡çš„ç­‰å¾…å’Œå”¤é†’å¹¶ä¸éœ€è¦æ»¡è¶³å…ˆåé¡ºåºï¼Œä¿¡å·é‡åªè¡¨ç¤ºæœ‰å¤šå°‘ä¸ªèµ„æºå¯ç”¨ï¼Œå› æ­¤ä¸å­˜åœ¨ä¸Šè¿°é—®é¢˜ã€‚ç„¶è€Œä¸ pthread_cond_wait ä¿è¯çš„åŸå­æ€§é”è½¬ç§»ç›¸æ¯”ï¼Œä½¿ç”¨ä¿¡å·é‡ä¼¼ä¹å­˜åœ¨ä¸€å®šé£é™©(æš‚æ—¶æ²¡æœ‰æŸ¥åˆ°éåŸå­æ€§æ“ä½œæœ‰ä½•ä¸å¦¥)ã€‚


ä¸è¿‡ï¼Œä½¿ç”¨ condition æœ‰ä¸€ä¸ªå¥½å¤„ï¼Œæˆ‘ä»¬å¯ä»¥è°ƒç”¨ pthread_cond_broadcast æ–¹æ³•é€šçŸ¥æ‰€æœ‰ç­‰å¾…ä¸­çš„æ¶ˆè´¹è€…ï¼Œè¿™æ˜¯ä½¿ç”¨ä¿¡å·é‡æ— æ³•å®ç°çš„ã€‚


##NSCondition çš„åšæ³•


NSCondition å…¶å®æ˜¯å°è£…äº†ä¸€ä¸ªäº’æ–¥é”å’Œæ¡ä»¶å˜é‡ï¼Œ å®ƒæŠŠå‰è€…çš„ lock æ–¹æ³•å’Œåè€…çš„ wait/signal ç»Ÿä¸€åœ¨ NSCondition å¯¹è±¡ä¸­ï¼Œæš´éœ²ç»™ä½¿ç”¨è€…:


    - (void) signal {

      pthread_cond_signal(&_condition);

    }

     

    // å…¶å®è¿™ä¸ªå‡½æ•°æ˜¯é€šè¿‡å®æ¥å®šä¹‰çš„ï¼Œå±•å¼€åå°±æ˜¯è¿™æ ·

    - (void) lock {

      int err = pthread_mutex_lock(&_mutex);

    }


å®ƒçš„åŠ è§£é”è¿‡ç¨‹ä¸ NSLock å‡ ä¹ä¸€è‡´ï¼Œç†è®ºä¸Šæ¥è¯´è€—æ—¶ä¹Ÿåº”è¯¥ä¸€æ ·(å®é™…æµ‹è¯•ä¹Ÿæ˜¯å¦‚æ­¤)ã€‚åœ¨å›¾ä¸­æ˜¾ç¤ºå®ƒè€—æ—¶ç•¥é•¿ï¼Œæˆ‘çŒœæµ‹æœ‰å¯èƒ½æ˜¯æµ‹è¯•è€…åœ¨æ¯æ¬¡åŠ è§£é”çš„å‰åè¿˜é™„å¸¦äº†å˜é‡çš„åˆå§‹åŒ–å’Œé”€æ¯æ“ä½œã€‚


##NSRecursiveLock


ä¸Šæ–‡å·²ç»è¯´è¿‡ï¼Œé€’å½’é”ä¹Ÿæ˜¯é€šè¿‡ pthread_mutex_lock å‡½æ•°æ¥å®ç°ï¼Œåœ¨å‡½æ•°å†…éƒ¨ä¼šåˆ¤æ–­é”çš„ç±»å‹ï¼Œå¦‚æœæ˜¾ç¤ºæ˜¯é€’å½’é”ï¼Œå°±å…è®¸é€’å½’è°ƒç”¨ï¼Œä»…ä»…å°†ä¸€ä¸ªè®¡æ•°å™¨åŠ ä¸€ï¼Œé”çš„é‡Šæ”¾è¿‡ç¨‹ä¹Ÿæ˜¯åŒç†ã€‚


> NSRecursiveLock ä¸ NSLock çš„åŒºåˆ«åœ¨äºå†…éƒ¨å°è£…çš„ pthread_mutex_t å¯¹è±¡çš„ç±»å‹ä¸åŒï¼Œå‰è€…çš„ç±»å‹ä¸º PTHREAD_MUTEX_RECURSIVEã€‚


##NSConditionLock


NSConditionLock å€ŸåŠ© NSCondition æ¥å®ç°ï¼Œå®ƒçš„æœ¬è´¨å°±æ˜¯ä¸€ä¸ªç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å‹ã€‚â€œæ¡ä»¶è¢«æ»¡è¶³â€å¯ä»¥ç†è§£ä¸ºç”Ÿäº§è€…æä¾›äº†æ–°çš„å†…å®¹ã€‚NSConditionLock çš„å†…éƒ¨æŒæœ‰ä¸€ä¸ª NSCondition å¯¹è±¡ï¼Œä»¥åŠ _condition_value å±æ€§ï¼Œåœ¨åˆå§‹åŒ–æ—¶å°±ä¼šå¯¹è¿™ä¸ªå±æ€§è¿›è¡Œèµ‹å€¼:


    // ç®€åŒ–ç‰ˆä»£ç 

    - (id) initWithCondition: (NSInteger)value {

        if (nil != (self = [super init])) {

            _condition = [NSCondition new]

            _condition_value = value;

        }

        return self;

    }


å®ƒçš„ lockWhenCondition æ–¹æ³•å…¶å®å°±æ˜¯æ¶ˆè´¹è€…æ–¹æ³•:


    - (void) lockWhenCondition: (NSInteger)value {

        [_condition lock];

        while (value != _condition_value) {

            [_condition wait];

        }

    }


å¯¹åº”çš„ unlockWhenCondition æ–¹æ³•åˆ™æ˜¯ç”Ÿäº§è€…ï¼Œä½¿ç”¨äº† broadcast æ–¹æ³•é€šçŸ¥äº†æ‰€æœ‰çš„æ¶ˆè´¹è€…:


    - (void) unlockWithCondition: (NSInteger)value {

        _condition_value = value;

        [_condition broadcast];

        [_condition unlock];

    }


##@synchronized


è¿™å…¶å®æ˜¯ä¸€ä¸ª OC å±‚é¢çš„é”ï¼Œ ä¸»è¦æ˜¯é€šè¿‡ç‰ºç‰²æ€§èƒ½æ¢æ¥è¯­æ³•ä¸Šçš„ç®€æ´ä¸å¯è¯»ã€‚


> æˆ‘ä»¬çŸ¥é“ @synchronized åé¢éœ€è¦ç´§è·Ÿä¸€ä¸ª OC å¯¹è±¡ï¼Œå®ƒå®é™…ä¸Šæ˜¯æŠŠè¿™ä¸ªå¯¹è±¡å½“åšé”æ¥ä½¿ç”¨ã€‚è¿™æ˜¯é€šè¿‡ä¸€ä¸ªå“ˆå¸Œè¡¨æ¥å®ç°çš„ï¼ŒOC åœ¨åº•å±‚ä½¿ç”¨äº†ä¸€ä¸ªäº’æ–¥é”çš„æ•°ç»„(ä½ å¯ä»¥ç†è§£ä¸ºé”æ± )ï¼Œé€šè¿‡å¯¹å¯¹è±¡å»å“ˆå¸Œå€¼æ¥å¾—åˆ°å¯¹åº”çš„äº’æ–¥é”ã€‚


å…·ä½“çš„å®ç°åŸç†å¯ä»¥å‚è€ƒè¿™ç¯‡æ–‡ç« : å…³äº @synchronizedï¼Œè¿™å„¿æ¯”ä½ æƒ³çŸ¥é“çš„è¿˜è¦å¤š



> å‚è€ƒèµ„æ–™


    pthread_mutex_lock

    ThreadSafety

    Difference between binary semaphore and mutex

    å…³äº @synchronizedï¼Œè¿™å„¿æ¯”ä½ æƒ³çŸ¥é“çš„è¿˜è¦å¤š

    pthread_mutex_lock.c æºç 

    [Pthread] Linuxä¸­çš„çº¿ç¨‹åŒæ­¥æœºåˆ¶(äºŒ)â€“In Glibc

    pthreadçš„å„ç§åŒæ­¥æœºåˆ¶

    pthread_cond_wait

    Conditional Variable vs Semaphore
    
    
 




===
===


######å¾®ä¿¡å·ï¼š
	
clpaial10201119ï¼ˆQ Qï¼š2211523682ï¼‰
    
######å¾®åšWB:

[http://weibo.com/u/3288975567?is_hot=1](http://weibo.com/u/3288975567?is_hot=1)

######gitHubï¼š


[https://github.com/al1020119](https://github.com/al1020119)
	
######åšå®¢

[http://al1020119.github.io/](http://al1020119.github.io/)

===

{% img /images/iCocosCoder.jpg Caption %}  

{% img /images/iCocosPublic.jpg Caption %}  