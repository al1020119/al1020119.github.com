---
layout: post
title: "iOSå¼€å‘â€”â€”å¸¸ç”¨åŠŸèƒ½ä»£ç é›†é”¦ï¼ˆå‹ç§€ç¯‡ï¼‰"
date: 2016-10-16 12:47:16 +0800
comments: true
categories: 
---


æœ¬æ¬¡æ€»ç»“ï¼Œæ˜¯å› ä¸ºä¸€æ¬¡ä¸Šçº¿Appè¢«æ‹’ä¹‹åçš„å†²åŠ¨ï¼Œå› ä¸ºæœ‰ä¸€ä¸ªåŠŸèƒ½ä»£ç è‡ªå·±ä¹‹å‰ç»å¸¸å†™ï¼Œä½†æ˜¯å†™å¤šäº†å°±å¿«ï¼Œæå¾—æ‰‹é€Ÿç»ƒå¾—è¶…å¿«ï¼ˆä¸è¦æƒ³æ±¡å’¯å“¦ğŸ˜‚ï¼‰ï¼Œæ‰€ä»¥å†™çš„æ—¶å€™å°±æ²¡æœ‰å¤šæƒ³ï¼Œä¹Ÿæ²¡æœ‰æ‰¾æ‰¾ä¹‹å‰çš„ä»£ç ï¼Œç»“æœå¯¼è‡´æ‚²å‚¬çš„ç»“å±€ã€‚

ä¹‹å‰æ²¡æœ‰æ•´ç†è¿‡é¡¹ç›®ä¸­é‡åˆ°æˆ–è€…å†™è¿‡ï¼Œæˆ–è€…ç»å¸¸è¦ç”¨çš„ä»£ç ï¼Œå¯èƒ½è§‰å¾—å¤šå†™å‡ éå°±æ²¡äº‹äº†ï¼Œæˆ–è€…ç½‘ä¸Šä¸€æ‰¾å°±æœ‰äº†ã€‚å¯æ˜¯äº‹å®å¹¶éå¦‚æœï¼Œé¦–å…ˆï¼Œç½‘ä¸Šæ‰¾çš„æ°¸è¿œä¸æ˜¯ä½ çš„ã€‚å…¶æ¬¡ï¼Œå†™å¾—å†å¤šè¿˜æ˜¯æœ‰ç²—å¿ƒæˆ–è€…æ³¨æ„ä¸åˆ°çš„åœ°æ–¹ã€‚æœ€åï¼Œæ•´ç†æˆè‡ªå·±çš„èƒ½æœ€å¿«é€Ÿåº¦çš„æ‰¾åˆ°å¹¶å®ç°ï¼Œæé«˜æ•ˆç‡ã€‚ä½•ä¹è€Œä¸ä¸ºå‘¢ï¼Ÿ

å¥½äº†ï¼ŒåºŸè¯ä¸å¤šè¯´ï¼Œç†è®ºä¹Ÿæ²¡æœ‰ï¼Œå¤§éƒ¨åˆ†åªè¦ä¸¤ä¸ªæ“ä½œï¼šcopy-pasteã€‚æœ‰äº›è¿˜æ˜¯éœ€è¦åšå°å°çš„æ”¹åŠ¨çš„ï¼Œæ ¹æ®é¡¹ç›®éœ€æ±‚ã€‚


<!--more-->



1. å–æ¶ˆtableViewå¤´éƒ¨å’Œåº•éƒ¨æ‚¬æµ®æ•ˆæœ
2. è·å–éšæœºæ•°
3. å»é™¤tableViewåˆ†ç»„å¤´éƒ¨å¤šä½™é—´è·
4. å›¾ç‰‡æˆªå–
5. æ¨¡ç³Šå›¾ç‰‡
6. è·å–æ–‡ä»¶å¤§å°
7. æ‰‹æœºå·éªŒè¯
8. é‚®ç®±éªŒè¯
9. ç½‘å€éªŒè¯
10. JSONè½¬å­—å…¸
11. iPhoneè®¾å¤‡ç±»å‹åˆ¤æ–­
12. iPhoneç³»ç»Ÿç‰ˆæœ¬åˆ¤æ–­
13. æ—¥å¿—æ‰“å°
14. é¢œè‰²è·å–
15. å¼±å¼•ç”¨
16. è·å–å±å¹•å°ºå¯¸
17. è·å–viewçš„æ§åˆ¶
18. å­—å…¸é˜²å´©æºƒ
19. æ•°ç»„é˜²å´©æºƒ
20. æœ¬æ–‡è¾“å…¥é”™è¯¯æç¤º
21. è·å–å½“å‰æ—¶é—´
22. è·å–å½“å‰ç‰ˆæœ¬
23. tabBarçº¢ç‚¹æ˜¾ç¤º
24. Logæ—¥å¿—.m
25. MD5åŠ å¯†
26. æŒ‰é’®èƒŒæ™¯é¢œè‰²
27. åˆ¤æ–­å¯¹è±¡æ˜¯å¦ä¸ºç©º
28. é”®ç›˜é€€å‡ºä¸éšè—é€šçŸ¥
29. è·å–è®¾å¤‡å”¯ä¸€ID
30. MOVè½¬Mp4
31. ä¸Šä¼ å›¾ç‰‡
32. ä¸Šä¼ è§†é¢‘
33. è·å–è§†é¢‘å¸§å›¾
34. å‹ç¼©å¹¶å¯¼å‡ºè§†é¢‘
35. ä¿å­˜è§†é¢‘åˆ°ç›¸å†Œ
36. è·å–å½“å‰æœ€é¡¶å±‚çš„ViewController
37. æ•°ç»„æ‹†åˆ†
38. å›¾ç‰‡å‹ç¼©
39. é‡Šæ”¾timerå®
40. è·å–æŸä¸ªviewæ‰€åœ¨çš„æ§åˆ¶å™¨
41. ä¸¤ç§æ–¹æ³•åˆ é™¤NSUserDefaultsæ‰€æœ‰è®°å½•
42. æ‰“å°ç³»ç»Ÿæ‰€æœ‰å·²æ³¨å†Œçš„å­—ä½“åç§°
43. è·å–å›¾ç‰‡æŸä¸€ç‚¹çš„é¢œè‰²
44. å­—ç¬¦ä¸²åè½¬
45. ç¦æ­¢é”å±ï¼Œ
46. æ¨¡æ€æ¨å‡ºé€æ˜ç•Œé¢
47. Xcodeè°ƒè¯•ä¸æ˜¾ç¤ºå†…å­˜å ç”¨
48. æ˜¾ç¤ºéšè—æ–‡ä»¶
49. iOSè·³è½¬åˆ°App Storeä¸‹è½½åº”ç”¨è¯„åˆ†
50. iOS è·å–æ±‰å­—çš„æ‹¼éŸ³
51. æ‰‹åŠ¨æ›´æ”¹iOSçŠ¶æ€æ çš„é¢œè‰²
52. åˆ¤æ–­å½“å‰ViewControlleræ˜¯pushè¿˜æ˜¯presentçš„æ–¹å¼æ˜¾ç¤ºçš„
53. è·å–å®é™…ä½¿ç”¨çš„LaunchImageå›¾ç‰‡
54. iOSåœ¨å½“å‰å±å¹•è·å–ç¬¬ä¸€å“åº”
55. åˆ¤æ–­viewæ˜¯ä¸æ˜¯æŒ‡å®šè§†å›¾çš„å­è§†å›¾
56. NSArray å¿«é€Ÿæ±‚æ€»å’Œ æœ€å¤§å€¼ æœ€å°å€¼ å’Œ å¹³å‡å€¼
57. ä¿®æ”¹UITextFieldä¸­Placeholderçš„æ–‡å­—é¢œè‰²
58. å…³äºNSDateFormatterçš„æ ¼å¼
59. è·å–ä¸€ä¸ªç±»çš„æ‰€æœ‰å­ç±»
60. ç›‘æµ‹IOSè®¾å¤‡æ˜¯å¦è®¾ç½®äº†ä»£ç†ï¼Œéœ€è¦CFNetwork.framework
61. é˜¿æ‹‰ä¼¯æ•°å­—è½¬ä¸­æ–‡æ ¼å¼
62. Base64ç¼–ç ä¸NSStringå¯¹è±¡æˆ–NSDataå¯¹è±¡çš„è½¬æ¢
63. å–æ¶ˆUICollectionViewçš„éšå¼åŠ¨ç”»
64. ä¸‹é¢å‡ ç§æ–¹æ³•éƒ½å¯ä»¥å¸®ä½ å»é™¤è¿™äº›åŠ¨ç”»
65. è®©Xcodeçš„æ§åˆ¶å°æ”¯æŒLLDBç±»å‹çš„æ‰“å°
66. CocoaPods pod install/pod updateæ›´æ–°æ…¢çš„é—®é¢˜
67. UIImage å ç”¨å†…å­˜å¤§å°
68. GCD timerå®šæ—¶å™¨
69. å›¾ç‰‡ä¸Šç»˜åˆ¶æ–‡å­— å†™ä¸€ä¸ªUIImageçš„category
70. æŸ¥æ‰¾ä¸€ä¸ªè§†å›¾çš„æ‰€æœ‰å­è§†å›¾
71. è®¡ç®—æ–‡ä»¶å¤§å°
72. UIViewè®¾ç½®éƒ¨åˆ†åœ†è§’
73. å–ä¸Šæ•´ä¸å–ä¸‹æ•´
74. è®¡ç®—å­—ç¬¦ä¸²å­—ç¬¦é•¿åº¦ï¼Œä¸€ä¸ªæ±‰å­—ç®—ä¸¤ä¸ªå­—ç¬¦
75. ç»™UIViewè®¾ç½®å›¾ç‰‡
76. é˜²æ­¢scrollViewæ‰‹åŠ¿è¦†ç›–ä¾§æ»‘æ‰‹åŠ¿
77. å­—ç¬¦ä¸²ä¸­æ˜¯å¦å«æœ‰ä¸­æ–‡
78. dispatch_groupçš„ä½¿ç”¨
79. UITextFieldæ¯å››ä½åŠ ä¸€ä¸ªç©ºæ ¼,å®ç°ä»£ç†
80. è·å–ç§æœ‰å±æ€§å’Œæˆå‘˜å˜é‡ #import
81. è·å–æ‰‹æœºå®‰è£…çš„åº”ç”¨
82. åˆ¤æ–­ä¸¤ä¸ªæ—¥æœŸæ˜¯å¦åœ¨åŒä¸€å‘¨ å†™åœ¨NSDateçš„categoryé‡Œé¢
83. åº”ç”¨å†…æ‰“å¼€ç³»ç»Ÿè®¾ç½®ç•Œé¢
84. å¯é€‰å€¼å¦‚ä¸‹ï¼š
85. å±è”½è§¦å‘äº‹ä»¶ï¼Œ2ç§’åå–æ¶ˆå±è”½
86. åŠ¨ç”»æš‚åœå†å¼€å§‹
87. iOSä¸­æ•°å­—çš„æ ¼å¼åŒ–
88. å¦‚ä½•è·å–WebViewæ‰€æœ‰çš„å›¾ç‰‡åœ°å€ï¼Œ
89. è·å–åˆ°webviewçš„é«˜åº¦
90. navigationBarå˜ä¸ºçº¯é€æ˜
91. tabBaråŒç†
92. navigationBaræ ¹æ®æ»‘åŠ¨è·ç¦»çš„æ¸å˜è‰²å®ç°
93. iOS å¼€å‘ä¸­ä¸€äº›ç›¸å…³çš„è·¯å¾„
94. navigationItemçš„BarButtonItemå¦‚ä½•ç´§é å±å¹•å³è¾¹ç•Œæˆ–è€…å·¦è¾¹ç•Œï¼Ÿ
95. NSStringè¿›è¡ŒURLç¼–ç å’Œè§£ç 
96. UIWebViewè®¾ç½®User-Agentã€‚
97. è·å–ç¡¬ç›˜æ€»å®¹é‡ä¸å¯ç”¨å®¹é‡:
98. è·å–UIColorçš„RGBAå€¼
99. ä¿®æ”¹textFieldçš„placeholderçš„å­—ä½“é¢œè‰²ã€å¤§å°
100. AFNç§»é™¤JSONä¸­çš„NSNull
101. ceil()å’Œfloor()
102. åœ¨webViewåŠ è½½å®Œçš„ä»£ç†æ–¹æ³•é‡Œé¢è¿™æ ·å†™ï¼š
103. NSDateFormatæœ€ä½³æ–¹å¼ï¼ˆstrptimeï¼‰
104. æ¯›ç»ç’ƒ
105. tableviewä¸‹æ‹‰åˆ·æ–°åœç•™ï¼ˆä¸æ»šåˆ°é¡¶éƒ¨ï¼‰ï¼Œ ç±»ä¼¼QQï¼Œå¾®ä¿¡æ‹‰å»å†å²æ¶ˆæ¯
106. KeyChainéšç§ä¿¡æ¯å­˜å‚¨ï¼ˆä¸»è¦æ˜¯å¯†ç ç±»ï¼‰
107. è‡ªå®šä¹‰åœ†è§’è£å‰ªï¼šææ€§èƒ½
108. éšè—tabbarä¸Šé¢çš„è™šçº¿
109. éšè—å¯¼èˆªæ ä¸‹é¢çš„è™šçº¿
110. ä¸¤ä¸ªèŒƒå›´çš„å¯Œæ–‡æœ¬
111. ä¿®æ”¹UIAlertController

<!--more-->

##1ï¼šå–æ¶ˆtableViewå¤´éƒ¨å’Œåº•éƒ¨æ‚¬æµ®æ•ˆæœ

    - (void)scrollViewDidScroll:(UIScrollView *)scrollView {  
        CGFloat sectionHeaderHeight = 10; //è¿™é‡Œæ˜¯æˆ‘çš„headerViewå’ŒfooterViewçš„é«˜åº¦  
        if (_tableView.contentOffset.y<=sectionHeaderHeight&&_tableView.contentOffset.y>=0) {  
            _tableView.contentInset = UIEdgeInsetsMake(-_tableView.contentOffset.y, 0, 0, 0);  
        } else if (_tableView.contentOffset.y>=sectionHeaderHeight) {  
            _tableView.contentInset = UIEdgeInsetsMake(-sectionHeaderHeight, 0, 0, 0);  
        }  
    }  
    
    
	    -(void)scrollViewDidScroll:(UIScrollView *)scrollView {
	
	    if (scrollView == self.tableView)
	
	        {
	
	        UITableView *tableview = (UITableView *)scrollView;
	
	        CGFloat sectionHeaderHeight = 64;
	
	        CGFloat sectionFooterHeight = 120;
	
	        CGFloat offsetY = tableview.contentOffset.y;
	
	        if (offsetY >= 0 && offsetY <= sectionHeaderHeight)
	
	        {
	
	            tableview.contentInset = UIEdgeInsetsMake(-offsetY, 0, -sectionFooterHeight, 0);
	
	        }else if (offsetY >= sectionHeaderHeight && offsetY <= tableview.contentSize.height - tableview.frame.size.height - sectionFooterHeight)
	
	        {
	
	            tableview.contentInset = UIEdgeInsetsMake(-sectionHeaderHeight, 0, -sectionFooterHeight, 0);
	
	        }else if (offsetY >= tableview.contentSize.height - tableview.frame.size.height - sectionFooterHeight && offsetY <= tableview.contentSize.height - tableview.frame.size.height)         {
	
	            tableview.contentInset = UIEdgeInsetsMake(-offsetY, 0, -(tableview.contentSize.height - tableview.frame.size.height - sectionFooterHeight), 0);
	
	        }
	
	    }
	
	}
##2ï¼šè·å–éšæœºæ•°

	//ç¬¬ä¸€ç§
	srand((unsigned)time(0)); //ä¸åŠ è¿™å¥æ¯æ¬¡äº§ç”Ÿçš„éšæœºæ•°ä¸å˜
	int i = rand() % 5;
	//ç¬¬äºŒç§
	srandom(time(0));
	int i = random() % 5;
	//ç¬¬ä¸‰ç§
	int i = arc4random() % 5 ; 

##3ï¼šå»é™¤tableViewåˆ†ç»„å¤´éƒ¨å¤šä½™é—´è·

####ä¸€ï¼š

	- (void)viewDidLoad {
	    [super viewDidLoad];
	    
	    self.tableView.tableHeaderView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 0, CGFLOAT_MIN)];
	}

####äºŒï¼š

	- (void)viewWillAppear:(BOOL)animated{
	    
	    [super viewWillAppear:animated];
	    
	    CGRect frameH = self.tableView.tableHeaderView.frame;
	    frameH.size.height = 5;
	    UIView *headerView = [[UIView alloc] initWithFrame:frameH];
	    [self.tableView setTableHeaderView:headerView];
	    
	    
	    CGRect frameF = self.tableView.tableHeaderView.frame;
	    frameF.size.height = 1;
	    UIView *footerView = [[UIView alloc] initWithFrame:frameF];
	    [self.tableView setTableFooterView:footerView];
	    
	}

####æœ‰ä¸ªæœ‹å‹ç»™äº†ä¸€ä¸ªæ›´å¥½çš„æ–¹æ¡ˆ

	ç›´æ¥è®¾ç½®å†…è¾¹è·ï¼ŒTableViewä¼šç›´æ¥æ ¹æ®å†…è¾¹è·è¿›è¡Œç›¸åº”çš„ç¼©è¿›ï¼


##4ï¼šå›¾ç‰‡æˆªå–

    CGSize itemSize = CGSizeMake(self.image.size.width, self.image.size.height);
    
    dispatch_async(dispatch_get_global_queue(0, 0), ^{
        
        UIImage *dynamicCellImage = [UIImage imageWithData:[NSData dataWithContentsOfURL:[NSURL URLWithString:model.cover]]];
                UIGraphicsBeginImageContextWithOptions(itemSize, NO, [UIScreen mainScreen].scale);
                
                //å‹ç¼©å›¾ç‰‡
                CGSize newSize;
                CGImageRef imageRef = nil;
                
                if ((dynamicCellImage.size.width / dynamicCellImage.size.height) < (self.image.size.width / self.image.size.height)) {
                    newSize.width = dynamicCellImage.size.width;
                    newSize.height = dynamicCellImage.size.width * self.image.size.height / self.image.size.width;
                    
                    imageRef = CGImageCreateWithImageInRect([dynamicCellImage CGImage], CGRectMake(0, fabs(dynamicCellImage.size.height - newSize.height) / 2, newSize.width, newSize.height));
                    
                } else {
                    newSize.height = dynamicCellImage.size.height;
                    newSize.width = dynamicCellImage.size.height * self.image.size.width / self.image.size.height;
                    
                    imageRef = CGImageCreateWithImageInRect([dynamicCellImage CGImage], CGRectMake(fabs(dynamicCellImage.size.width - newSize.width) / 2, 0, newSize.width, newSize.height));
                }
                
                dispatch_async(dispatch_get_main_queue(), ^{
                    self.image.image = [UIImage imageWithCGImage:imageRef];
                });
                
                UIGraphicsEndImageContext();

    });
    
    
##5ï¼šæ¨¡ç³Šå›¾ç‰‡

	//åŠ æ¨¡ç³Šæ•ˆæœï¼Œimageæ˜¯å›¾ç‰‡ï¼Œbluræ˜¯æ¨¡ç³Šåº¦
	+ (UIImage *)blurryImage:(UIImage *)image withBlurLevel:(CGFloat)blur {
	    //æ¨¡ç³Šåº¦,
	    if ((blur < 0.1f) || (blur > 2.0f)) {
	        blur = 0.5f;
	    }
	    
	    //boxSizeå¿…é¡»å¤§äº0
	    int boxSize = (int)(blur * 100);
	    boxSize -= (boxSize % 2) + 1;
	//    iCocosLog(@"boxSize:%i",boxSize);
	    //å›¾åƒå¤„ç†
	    CGImageRef img = image.CGImage;
	    
	    //å›¾åƒç¼“å­˜,è¾“å…¥ç¼“å­˜ï¼Œè¾“å‡ºç¼“å­˜
	    vImage_Buffer inBuffer, outBuffer;
	    vImage_Error error;
	    //åƒç´ ç¼“å­˜
	    void *pixelBuffer;
	    
	    //æ•°æ®æºæä¾›è€…ï¼ŒDefines an opaque type that supplies Quartz with data.
	    CGDataProviderRef inProvider = CGImageGetDataProvider(img);
	    // providerâ€™s data.
	    CFDataRef inBitmapData = CGDataProviderCopyData(inProvider);
	    
	    //å®½ï¼Œé«˜ï¼Œå­—èŠ‚/è¡Œï¼Œdata
	    inBuffer.width = CGImageGetWidth(img);
	    inBuffer.height = CGImageGetHeight(img);
	    inBuffer.rowBytes = CGImageGetBytesPerRow(img);
	    inBuffer.data = (void*)CFDataGetBytePtr(inBitmapData);
	    
	    //åƒæ•°ç¼“å­˜ï¼Œå­—èŠ‚è¡Œ*å›¾ç‰‡é«˜
	    pixelBuffer = malloc(CGImageGetBytesPerRow(img) * CGImageGetHeight(img));
	    
	    outBuffer.data = pixelBuffer;
	    outBuffer.width = CGImageGetWidth(img);
	    outBuffer.height = CGImageGetHeight(img);
	    outBuffer.rowBytes = CGImageGetBytesPerRow(img);
	    
	    
	    // ç¬¬ä¸‰ä¸ªä¸­é—´çš„ç¼“å­˜åŒº,æŠ—é”¯é½¿çš„æ•ˆæœ
	    void *pixelBuffer2 = malloc(CGImageGetBytesPerRow(img) * CGImageGetHeight(img));
	    vImage_Buffer outBuffer2;
	    outBuffer2.data = pixelBuffer2;
	    outBuffer2.width = CGImageGetWidth(img);
	    outBuffer2.height = CGImageGetHeight(img);
	    outBuffer2.rowBytes = CGImageGetBytesPerRow(img);
	    
	    
	    //Convolves a region of interest within an ARGB8888 source image by an implicit M x N kernel that has the effect of a box filter.
	    error = vImageBoxConvolve_ARGB8888(&inBuffer, &outBuffer2, NULL, 0, 0, boxSize, boxSize, NULL, kvImageEdgeExtend);
	    error = vImageBoxConvolve_ARGB8888(&outBuffer2, &inBuffer, NULL, 0, 0, boxSize, boxSize, NULL, kvImageEdgeExtend);
	    error = vImageBoxConvolve_ARGB8888(&inBuffer, &outBuffer, NULL, 0, 0, boxSize, boxSize, NULL, kvImageEdgeExtend);
	    
	    if (error) {
	        iCocosLog(@"error from convolution %ld", error);
	    }
	    
	    //    iCocosLog(@"å­—èŠ‚ç»„æˆéƒ¨åˆ†ï¼š%zu",CGImageGetBitsPerComponent(img));
	    //é¢œè‰²ç©ºé—´DeviceRGB
	    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
	    //ç”¨å›¾ç‰‡åˆ›å»ºä¸Šä¸‹æ–‡,CGImageGetBitsPerComponent(img),7,8
	    CGContextRef ctx = CGBitmapContextCreate(
	                                             outBuffer.data,
	                                             outBuffer.width,
	                                             outBuffer.height,
	                                             8,
	                                             outBuffer.rowBytes,
	                                             colorSpace,
	                                             CGImageGetBitmapInfo(image.CGImage));
	    
	    //æ ¹æ®ä¸Šä¸‹æ–‡ï¼Œå¤„ç†è¿‡çš„å›¾ç‰‡ï¼Œé‡æ–°ç»„ä»¶
	    CGImageRef imageRef = CGBitmapContextCreateImage (ctx);
	    UIImage *returnImage = [UIImage imageWithCGImage:imageRef];
	    
	    //clean up
	    CGContextRelease(ctx);
	    CGColorSpaceRelease(colorSpace);
	    
	    free(pixelBuffer);
	    free(pixelBuffer2);
	    CFRelease(inBitmapData);
	    
	    CGColorSpaceRelease(colorSpace);
	    CGImageRelease(imageRef);
	    
	    return returnImage;
	}

##6ï¼šæ–‡ä»¶å¤§å°

	/**
	 *  é€šå¸¸ç”¨äºåˆ é™¤ç¼“å­˜çš„æ—¶ï¼Œè®¡ç®—ç¼“å­˜å¤§å°
	 */
	//å•ä¸ªæ–‡ä»¶çš„å¤§å°
	+ (long long) fileSizeAtPath:(NSString*) filePath{
	    NSFileManager* manager = [NSFileManager defaultManager];
	    if ([manager fileExistsAtPath:filePath]){
	        return [[manager attributesOfItemAtPath:filePath error:nil] fileSize];
	    }
	    return 0;
	}
	
##7ï¼šæ‰‹æœºå·

	/**
	 *  æ‰‹æœºå·åˆ¤æ–­
	 *
	 *  @param mobileNum å·ç å­—ç¬¦ä¸²
	 *
	 *  @return BOOL
	 */
	+ (BOOL)isMobileNumber:(NSString *)mobileNum
	{
	        /**
	         * ç§»åŠ¨å·æ®µæ­£åˆ™è¡¨è¾¾å¼
	         */
	        NSString *CM_NUM = @"^((13[4-9])|(147)|(15[0-2,7-9])|(178)|(18[2-4,7-8]))\\d{8}|(1705)\\d{7}$";
	        /**
	         * è”é€šå·æ®µæ­£åˆ™è¡¨è¾¾å¼
	         */
	        NSString *CU_NUM = @"^((13[0-2])|(145)|(15[5-6])|(176)|(18[5,6]))\\d{8}|(1709)\\d{7}$";
	        /**
	         * ç”µä¿¡å·æ®µæ­£åˆ™è¡¨è¾¾å¼
	         */
	        NSString *CT_NUM = @"^((133)|(153)|(177)|(18[0,1,9]))\\d{8}$";
	    
	        NSPredicate *pred1 = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", CM_NUM];
	        BOOL isMatch1 = [pred1 evaluateWithObject:mobileNum];
	        NSPredicate *pred2 = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", CU_NUM];
	        BOOL isMatch2 = [pred2 evaluateWithObject:mobileNum];
	        NSPredicate *pred3 = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", CT_NUM];
	        BOOL isMatch3 = [pred3 evaluateWithObject:mobileNum];
	        
	        if (isMatch1 || isMatch2 || isMatch3) {
	            return YES;
	        }else{
	            return NO;
	        }
	}

##8ï¼šé‚®ç®±


####é€šè¿‡åŒºåˆ†å­—ç¬¦ä¸²
	
	-(BOOL)validateEmail:(NSString*)email
	
	{
	
	    if((0 != [email rangeOfString:@"@"].length) &&
	
	       (0 != [email rangeOfString:@"."].length))
	
	    {
	
	        NSCharacterSet* tmpInvalidCharSet = [[NSCharacterSet alphanumericCharacterSet] invertedSet];
	
	        NSMutableCharacterSet* tmpInvalidMutableCharSet = [[tmpInvalidCharSet mutableCopy] autorelease];
	
	        [tmpInvalidMutableCharSet removeCharactersInString:@"_-"];
	
	        
	
	       
	
	        NSRange range1 = [email rangeOfString:@"@"
	
	                                      options:NSCaseInsensitiveSearch];
	
	        
	
	        //å–å¾—ç”¨æˆ·åéƒ¨åˆ†
	
	        NSString* userNameString = [email substringToIndex:range1.location];
	
	        NSArray* userNameArray   = [userNameString componentsSeparatedByString:@"."];
	
	        
	
	        for(NSString* string in userNameArray)
	
	        {
	
	            NSRange rangeOfInavlidChars = [string rangeOfCharacterFromSet: tmpInvalidMutableCharSet];
	
	            if(rangeOfInavlidChars.length != 0 || [string isEqualToString:@""])
	
	                return NO;
	
	        }
	
	        
	
	        //å–å¾—åŸŸåéƒ¨åˆ†
	
	        NSString *domainString = [email substringFromIndex:range1.location+1];
	
	        NSArray *domainArray   = [domainString componentsSeparatedByString:@"."];
	
	        
	
	        for(NSString *string in domainArray)
	
	        {
	
	            NSRange rangeOfInavlidChars=[string rangeOfCharacterFromSet:tmpInvalidMutableCharSet];
	
	            if(rangeOfInavlidChars.length !=0 || [string isEqualToString:@""])
	
	                return NO;
	
	        }
	
	        
	
	        return YES;
	
	    }
	
	    else {
	
	       return NO;
	
	    }
	
	}


####åˆ©ç”¨æ­£åˆ™è¡¨è¾¾å¼éªŒè¯

	-(BOOL)isValidateEmail:(NSString *)email {
	
	    NSString *emailRegex = @"[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,4}"; 
	
	    NSPredicate *emailTest = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", emailRegex]; 
	
	    return [emailTest evaluateWithObject:email];
	
	}

##9ï¼šç½‘å€
####1.é¦–å…ˆè¿›è¡Œç¬¬ä¸€æ­¥åˆ¤æ–­ä¼ å…¥çš„å­—ç¬¦ä¸²æ˜¯å¦ç¬¦åˆHTTPè·¯å¾„çš„è¯­æ³•è§„åˆ™,å³â€HTTPS://â€ æˆ– â€œHTTP://â€ ,ä»å°è£…çš„ä¸€ä¸ªå‡½æ•°,ä¼ å…¥å³å¯åˆ¤æ–­

	- (NSURL *)smartURLForString:(NSString *)str
	{
	    NSURL *     result;
	    NSString *  trimmedStr;
	    NSRange     schemeMarkerRange;
	    NSString *  scheme;
	
	    assert(str != nil);
	
	    result = nil;
	
	    trimmedStr = [str stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceCharacterSet]];
	    if ( (trimmedStr != nil) && (trimmedStr.length != 0) ) {
	        schemeMarkerRange = [trimmedStr rangeOfString:@"://"];
	
	        if (schemeMarkerRange.location == NSNotFound) {
	            result = [NSURL URLWithString:[NSString stringWithFormat:@"http://%@", trimmedStr]];
	        } else {
	            scheme = [trimmedStr substringWithRange:NSMakeRange(0, schemeMarkerRange.location)];
	            assert(scheme != nil);
	
	            if ( ([scheme compare:@"http"  options:NSCaseInsensitiveSearch] == NSOrderedSame)
	                || ([scheme compare:@"https" options:NSCaseInsensitiveSearch] == NSOrderedSame) ) {
	                result = [NSURL URLWithString:trimmedStr];
	            } else {
	                // It looks like this is some unsupported URL scheme.
	            }
	        }
	    }
	
	    return result;
	}

####ç¬¬äºŒæ­¥,åˆ¤æ–­æ­¤è·¯å¾„æ˜¯å¦èƒ½å¤Ÿè¯·æ±‚æˆåŠŸ,ç›´æ¥è¿›è¡ŒHTTPè¯·æ±‚,è§‚å¯Ÿè¿”å›ç»“æœ->

	//åˆ¤æ–­
	-(void) validateUrl: (NSURL *) candidate {
	    NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:candidate];
	    [request setHTTPMethod:@"HEAD"];
	    NSURLSession *session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]];
	    NSURLSessionDataTask *task = [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {
	        NSLog(@"error %@",error);
	        if (error) {
	            NSLog(@"ä¸å¯ç”¨");
	        }else{
	            NSLog(@"å¯ç”¨");
	        }
	    }];
	    [task resume];
	}
##10ï¼šJSONè½¬å­—å…¸


	/*!
	 * @brief æŠŠæ ¼å¼åŒ–çš„JSONæ ¼å¼çš„å­—ç¬¦ä¸²è½¬æ¢æˆå­—å…¸
	 * @param jsonString JSONæ ¼å¼çš„å­—ç¬¦ä¸²
	 * @return è¿”å›å­—å…¸
	 */
	- (NSDictionary *)dictionaryWithJsonString:(NSString *)jsonString {
	    if (jsonString == nil) {
	        return nil;
	    }
	    iCocosLog(@"%@", jsonString);
	    
	    NSData *jsonData = [jsonString dataUsingEncoding:NSUTF8StringEncoding];
	    NSError *err;
	    NSDictionary *dic = [NSJSONSerialization JSONObjectWithData:jsonData
	                                                        options:NSJSONReadingMutableContainers
	                                                          error:&err];
	    if(err) {
	        iCocosLog(@"jsonè§£æå¤±è´¥ï¼š%@",err);
	        return nil;
	    }
	    return dic;
	}

####æ•°ç»„è½¬JSON

    	NSArray *uids = [self.allModelUID objectAtIndexCheck:range];

        NSError *error = nil;
        NSData *picsJsonData = [NSJSONSerialization dataWithJSONObject:uids
                                                               options:NSJSONWritingPrettyPrinted
                                                                 error:&error];
        NSString *JSONString = [[NSString alloc] initWithData:picsJsonData encoding:NSUTF8StringEncoding];


##11ï¼šiPhoneè®¾å¤‡ç±»å‹

	typedef NS_ENUM(char, iPhoneModel){//0~3
	    iPhone4,//320*480
	    iPhone5,//320*568
	    iPhone6,//375*667
	    iPhone6Plus,//414*736
	    UnKnown
	};
	
	
	
	/**
	 *  return current running iPhone model
	 *
	 *  @return iPhone model
	 */
	+ (iPhoneModel)iPhonesModel {
	    //bounds method gets the points not the pixels!!!
	    CGRect rect = [[UIScreen mainScreen] bounds];
	    
	    CGFloat width = rect.size.width;
	    CGFloat height = rect.size.height;
	    
	    //get current interface Orientation
	    UIInterfaceOrientation orientation = [[UIApplication sharedApplication] statusBarOrientation];
	    //unknown
	    if (UIInterfaceOrientationUnknown == orientation) {
	        return UnKnown;
	    }
	    /**
	     //    portrait   width * height
	     //    iPhone4:320*480
	     //    iPhone5:320*568
	     //    iPhone6:375*667
	     //    iPhone6Plus:414*736
	     */
	    
	    //portrait
	    if (UIInterfaceOrientationPortrait == orientation) {
	        if (width ==  320.0f) {
	            if (height == 480.0f) {
	                return iPhone4;
	            } else {
	                return iPhone5;
	            }
	        } else if (width == 375.0f) {
	            return iPhone6;
	        } else if (width == 414.0f) {
	            return iPhone6Plus;
	        }
	    } else if (UIInterfaceOrientationLandscapeLeft == orientation || UIInterfaceOrientationLandscapeRight == orientation) {//landscape
	        if (height == 320.0) {
	            if (width == 480.0f) {
	                return iPhone4;
	            } else {
	                return iPhone5;
	            }
	        } else if (height == 375.0f) {
	            return iPhone6;
	        } else if (height == 414.0f) {
	            return iPhone6Plus;
	        }
	    }
	    
	    return UnKnown;
	}


##12ï¼šiPhoneç³»ç»Ÿç‰ˆæœ¬

	//è·å–å½“å‰ç³»ç»Ÿç‰ˆæœ¬
	#define __ios10_0__ ([[UIDevice currentDevice].systemVersion floatValue] >= 10.0)
	#define __ios9_0__ ([[UIDevice currentDevice].systemVersion floatValue] >= 9.0)
	#define __ios8_0__ ([[UIDevice currentDevice].systemVersion floatValue] >= 8.0)

##13ï¼šæ—¥å¿—

	// æ—¥å¿—è¾“å‡º
	#ifdef DEBUG // å¼€å‘é˜¶æ®µ-DEBUGé˜¶æ®µ:ä½¿ç”¨Log
	#define iCocosLog(...) NSLog(__VA_ARGS__)
	#else // å‘å¸ƒé˜¶æ®µ-ä¸Šçº¿é˜¶æ®µ:ç§»é™¤Log
	#define iCocosLog(...)
	#endif

è¯¦ç»†


	#ifdef DEBUG
	#define iCocosLog(format, ...) printf("\n[%s] %s [ç¬¬%dè¡Œ] %s\n", __TIME__, __FUNCTION__, __LINE__, [[NSString stringWithFormat:format, ## __VA_ARGS__] UTF8String]);
	#else
	#define iCocosLog(format, ...)
	#endif


##14ï¼šé¢œè‰²

	// é¢œè‰²
	#define iCocosARGBColor(r, g, b, a) [UIColor colorWithRed:(r)/255.0 green:(g)/255.0 blue:(b)/255.0 alpha:a]
	#define iCocosColor(r, g, b) iCocosARGBColor((r), (g), (b), 255)


	#define random(r, g, b, a) [UIColor colorWithRed:(r)/255.0 green:(g)/255.0 blue:(b)/255.0 alpha:(a)/255.0]
	#define iCocosRandomColor (random(arc4random_uniform(256), arc4random_uniform(256), arc4random_uniform(256), arc4random_uniform(256)))

##15ï¼šå¼±å¼•ç”¨

	// å¼±å¼•ç”¨
	#define iCocosWeakSelf __weak typeof(self) weakSelf = self;
##16ï¼šå±å¹•å°ºå¯¸

	// å±å¹•å°ºå¯¸
	#define iCocosScreenH [UIScreen mainScreen].bounds.size.height
	#define iCocosScreenW [UIScreen mainScreen].bounds.size.width
	
	
##17ï¼šè·å–viewçš„æ§åˆ¶

	/** è·å–å½“å‰Viewçš„æ§åˆ¶å™¨å¯¹è±¡ */
	-(UIViewController *)getCurrentViewController{
	    UIResponder *next = [self nextResponder];
	    do {
	        if ([next isKindOfClass:[UIViewController class]]) {
	            return (UIViewController *)next;
	        }
	        next = [next nextResponder];
	    } while (next != nil);
	    return nil;
	}


##18ï¼šå­—å…¸é˜²è¹¦

####ä¸å¯å˜

	/*!
	 @method objectAtIndexCheck:
	 @abstract æ£€æŸ¥æ˜¯å¦è¶Šç•Œå’ŒNSNullå¦‚æœæ˜¯è¿”å›nil
	 @result è¿”å›å¯¹è±¡
	 */
	- (id)objectStringForKey:(NSString *)key
	{
	    if ([self objectForKey:key] == nil) {
	//        iCocosLog(@"é”®å€¼å¯¹ä¸å­˜åœ¨");
	        return nil;
	    }
	    id value = [self objectForKey:key];
	      
	    return value;
	}


####å¯å˜

	/*!
	 @method objectAtIndexCheck:
	 @abstract æ£€æŸ¥æ˜¯å¦è¶Šç•Œå’ŒNSNullå¦‚æœæ˜¯è¿”å›nil
	 @result è¿”å›å¯¹è±¡
	 */
	- (id)objectStringForKey:(NSString *)key
	{
	    if ([self objectForKey:key] == nil) {
	        
	//        iCocosLog(@"é”®å€¼å¯¹ä¸å­˜åœ¨");
	        
	        return nil;
	//        return 0;
	    }
	    id value = [self objectForKey:key];
	    
	    return value;
	}


##19ï¼šæ•°ç»„é˜²è¹¦

####ä¸å¯å˜

	/*!
	 @method objectAtIndexCheck:
	 @abstract æ£€æŸ¥æ˜¯å¦è¶Šç•Œå’ŒNSNullå¦‚æœæ˜¯è¿”å›nil
	 @result è¿”å›å¯¹è±¡
	 */
	- (id)objectAtIndexCheck:(NSUInteger)index  {
	    
	    if (index >= [self count]) {
	        iCocosLog(@"æ•°ç»„è¶Šç•Œ");
	        return nil;
	    }
	    id value = [self objectAtIndex:index];
	    if (value == [NSNull null]) {
	        iCocosLog(@"æ•°ç»„ä¸ºç©º");
	        return nil;
	    }
	    return value;
	}


####å¯å˜

	/*!
	 @method objectAtIndexCheck:
	 @abstract æ£€æŸ¥æ˜¯å¦è¶Šç•Œå’ŒNSNullå¦‚æœæ˜¯è¿”å›nil
	 @result è¿”å›å¯¹è±¡
	 */
	- (id)objectAtIndexCheck:(NSUInteger)index  {
	    
	    if (index >= [self count]) {
	        iCocosLog(@"æ•°ç»„è¶Šç•Œ");
	        return nil;
	    }
	    id value = [self objectAtIndex:index];
	    if (value == [NSNull null]) {
	        iCocosLog(@"æ•°ç»„ä¸ºç©º");
	        return nil;
	    }
	    return value;
	}



	- (void)removeObjectAtCheckIndex:(NSInteger)index
	{
	    if (index >= [self count]) {
	        iCocosLog(@"æ•°ç»„è¶Šç•Œ");
	        return ;
	    }
	    id value = [self objectAtIndex:index];
	    if (value == [NSNull null]) {
	        iCocosLog(@"æ•°ç»„ä¸ºç©º");
	        return ;
	    }
	    
	    [self removeObjectAtIndex:index];
	    
	}

##20ï¼šæœ¬æ–‡è¾“å…¥é”™è¯¯æç¤º

	- (void)shake {
	    CAKeyframeAnimation *keyFrame = [CAKeyframeAnimation animationWithKeyPath:@"position.x"];
	    keyFrame.duration = 0.3;
	    CGFloat x = self.layer.position.x;
	    keyFrame.values = @[@(x - 30), @(x - 30), @(x + 20), @(x - 20), @(x + 10), @(x - 10), @(x + 5), @(x - 5)];
	    [self.layer addAnimation:keyFrame forKey:@"shake"];
	
	}


##21ï¼šå½“å‰æ—¶é—´

	+ (NSString *)nowTimes{
	    NSDate* dat = [NSDate dateWithTimeIntervalSinceNow:0];
	    int a=(int)([dat timeIntervalSince1970] + 0.5);
	    NSString *timeString = [NSString stringWithFormat:@"%d", a];//è½¬ä¸ºå­—ç¬¦å‹
	    return timeString;
	}


##22:å½“å‰ç‰ˆæœ¬

	/*
	 *  å½“å‰ç¨‹åºçš„ç‰ˆæœ¬å·
	 */
	-(NSString *)version{
	    //ç³»ç»Ÿç›´æ¥è¯»å–çš„ç‰ˆæœ¬å·
	    NSString *versionValueStringForSystemNow=[[NSBundle mainBundle].infoDictionary valueForKey:(NSString *)kCFBundleVersionKey];
	    return versionValueStringForSystemNow;
	}

##23:tabBarçº¢ç‚¹


	- (void)showBadgeOnItemIndex:(int)index{
	    
	    //ç§»é™¤ä¹‹å‰çš„å°çº¢ç‚¹
	    [self removeBadgeOnItemIndex:index];
	    
	    //æ–°å»ºå°çº¢ç‚¹
	    UIView *badgeView = [[UIView alloc]init];
	    badgeView.tag = 888 + index;
	    badgeView.backgroundColor = [UIColor redColor];
	    CGRect tabFrame = self.frame;
	    
	    //ç¡®å®šå°çº¢ç‚¹çš„ä½ç½®
	    float percentX = (index +0.6) / TabbarItemNums;
	    CGFloat x = ceilf(percentX * tabFrame.size.width);
	    CGFloat y = ceilf(0.1 * tabFrame.size.height);
	    badgeView.frame = CGRectMake(x, y, 8, 8);
	    badgeView.layer.cornerRadius = badgeView.frame.size.width/2;
	    
	    [self addSubview:badgeView];
	    
	}
	
	- (void)hideBadgeOnItemIndex:(int)index{
	    
	    //ç§»é™¤å°çº¢ç‚¹
	    [self removeBadgeOnItemIndex:index];
	    
	}
	
	- (void)removeBadgeOnItemIndex:(int)index{
	    
	    //æŒ‰ç…§tagå€¼è¿›è¡Œç§»é™¤
	    for (UIView *subView in self.subviews) {
	        if (subView.tag == 888+index) {
	            [subView removeFromSuperview];
	        }
	    }
	}


##24:Logæ—¥å¿—.m

	@implementation UIView(Log)
	+ (NSString *)searchAllSubviews:(UIView *)superview
	{
	    NSMutableString *xml = [NSMutableString string];
	    
	    NSString *class = NSStringFromClass(superview.class);
	    class = [class stringByReplacingOccurrencesOfString:@"_" withString:@""];
	    [xml appendFormat:@"<%@ frame=\"%@\">\n", class, NSStringFromCGRect(superview.frame)];
	    for (UIView *childView in superview.subviews) {
	        NSString *subviewXml = [self searchAllSubviews:childView];
	        [xml appendString:subviewXml];
	    }
	    [xml appendFormat:@"</%@>\n", class];
	    return xml;
	}
	
	- (NSString *)description
	{
	    return [UIView searchAllSubviews:self];
	}
	@end
	
	@implementation NSDictionary (Log)
	- (NSString *)descriptionWithLocale:(id)locale
	{
	    NSMutableString *str = [NSMutableString string];
	    
	    [str appendString:@"{\n"];
	    
	    // éå†å­—å…¸çš„æ‰€æœ‰é”®å€¼å¯¹
	    [self enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) {
	        [str appendFormat:@"\t%@ = %@,\n", key, obj];
	    }];
	    
	    [str appendString:@"}"];
	    
	    // æŸ¥å‡ºæœ€åä¸€ä¸ª,çš„èŒƒå›´
	    NSRange range = [str rangeOfString:@"," options:NSBackwardsSearch];
	    if (range.length) {
	        // åˆ æ‰æœ€åä¸€ä¸ª,
	        [str deleteCharactersInRange:range];
	    }
	    
	    return str;
	}
	@end
	
	@implementation NSArray (Log)
	- (NSString *)descriptionWithLocale:(id)locale
	{
	    NSMutableString *str = [NSMutableString string];
	    
	    [str appendString:@"[\n"];
	    
	    // éå†æ•°ç»„çš„æ‰€æœ‰å…ƒç´ 
	    [self enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {
	        [str appendFormat:@"%@,\n", obj];
	    }];
	    
	    [str appendString:@"]"];
	    
	    // æŸ¥å‡ºæœ€åä¸€ä¸ª,çš„èŒƒå›´
	    NSRange range = [str rangeOfString:@"," options:NSBackwardsSearch];
	    if (range.length) {
	        // åˆ æ‰æœ€åä¸€ä¸ª,
	        [str deleteCharactersInRange:range];
	    }
	    
	    return str;
	}
	@end

##25:MD5

	//16ä½MD5åŠ å¯†æ–¹å¼
	- (NSString *)getMd5_16Bit_String:(NSString *)srcString{
	    //æå–32ä½MD5æ•£åˆ—çš„ä¸­é—´16ä½
	    NSString *md5_32Bit_String=[self getMd5_32Bit_String:srcString];
	    NSString *result = [[md5_32Bit_String substringToIndex:24] substringFromIndex:8];//å³9ï½25ä½
	    
	    return result;
	}
	
	
	//32ä½MD5åŠ å¯†æ–¹å¼
	- (NSString *)getMd5_32Bit_String:(NSString *)srcString{
	    const char *cStr = [srcString UTF8String];
	    unsigned char digest[CC_MD5_DIGEST_LENGTH];
	    CC_MD5( cStr, strlen(cStr), digest );
	    NSMutableString *result = [NSMutableString stringWithCapacity:CC_MD5_DIGEST_LENGTH * 2];
	    for(int i = 0; i < CC_MD5_DIGEST_LENGTH; i++)
	        [result appendFormat:@"%02x", digest[i]];
	    
	    return result;
	}


##26:æŒ‰é’®èƒŒæ™¯é¢œè‰²


	/**
	 *  ä½¿ç”¨èƒŒæ™¯é¢œè‰²è®¾ç½®æŒ‰é’®ä¸åŒçŠ¶æ€çš„å›¾ç‰‡
	 *
	 *  @param color é¢œè‰²
	 *
	 *  @return èƒŒæ™¯å›¾ç‰‡
	 */
	+ (UIImage *)imageWithColor:(UIColor *)color {
	    CGRect rect = CGRectMake(0.0f, 0.0f, 1.0f, 1.0f);
	    UIGraphicsBeginImageContext(rect.size);
	    CGContextRef context = UIGraphicsGetCurrentContext();
	    
	    CGContextSetFillColorWithColor(context, [color CGColor]);
	    CGContextFillRect(context, rect);
	    
	    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();
	    UIGraphicsEndImageContext();
	    
	    return image;
	}

##27ï¼šå¯¹è±¡æ˜¯å¦ä¸ºç©º


	// åˆ¤æ–­å¯¹è±¡æ˜¯å¦ä¸ºç©º
	- (BOOL)isBlanceObject:(id)object{
	    if (object == nil || object == NULL) {
	        return YES;
	    }
	    if ([object isKindOfClass:[NSNull class]]) {
	        return YES;
	    }
	    return NO;
	}

##28ï¼šé”®ç›˜é€€å‡ºä¸éšè—


    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(keyboardWillShow:) name:UIKeyboardWillShowNotification object:nil];
    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(keyboardWillHide:) name:UIKeyboardWillHideNotification object:nil];
}

	- (void)keyboardWillShow:(NSNotification *)notification {
	
	    // è·å–é€šçŸ¥çš„ä¿¡æ¯å­—å…¸
	    NSDictionary *userInfo = [notification userInfo];
	
	    // è·å–é”®ç›˜å¼¹å‡ºåçš„rect
	    NSValue* aValue = [userInfo objectForKey:UIKeyboardFrameEndUserInfoKey];
	    CGRect keyboardRect = [aValue CGRectValue];
	
	    // è·å–é”®ç›˜å¼¹å‡ºåŠ¨ç”»æ—¶é—´
	    NSValue *animationDurationValue = [userInfo objectForKey:UIKeyboardAnimationDurationUserInfoKey];
	    NSTimeInterval animationDuration;
	    [animationDurationValue getValue:&animationDuration];
	
	}
	
	
	- (void)keyboardWillHide:(NSNotification *)notification {
	
	    // è·å–é€šçŸ¥ä¿¡æ¯å­—å…¸
	    NSDictionary* userInfo = [notification userInfo];
	
	    // è·å–é”®ç›˜éšè—åŠ¨ç”»æ—¶é—´
	    NSValue *animationDurationValue = [userInfo objectForKey:UIKeyboardAnimationDurationUserInfoKey];
	    NSTimeInterval animationDuration;
	    [animationDurationValue getValue:&animationDuration];
	
	
	}

##29ï¼šè·å–è®¾å¤‡å”¯ä¸€ID

-(NSString *)getUniqueDeviceIdentifierAsString
{
    NSString *appName=[[[NSBundle mainBundle] infoDictionary] objectForKey:(NSString*)kCFBundleNameKey];
 
    NSString *strApplicationUUID =  [SAMKeychain passwordForService:appName account:@"incoding"];
    if (strApplicationUUID == nil)
    {
        strApplicationUUID  = [[[UIDevice currentDevice] identifierForVendor] UUIDString];
 
        NSError *error = nil;
        SAMKeychainQuery *query = [[SAMKeychainQuery alloc] init];
        query.service = appName;
        query.account = @"incoding";
        query.password = strApplicationUUID;
        query.synchronizationMode = SAMKeychainQuerySynchronizationModeNo;
        [query save:&error];
 
    }
 
    return strApplicationUUID;
}

##30ï¼šMOVè½¬Mp4


	- (void)movFileTransformToMP4WithSourceUrl:(NSURL *)sourceUrl completion:(void(^)(NSString *Mp4FilePath))comepleteBlock
	{
	    /**
	     *  movæ ¼å¼è½¬mp4æ ¼å¼
	     */
	    AVURLAsset *avAsset = [AVURLAsset URLAssetWithURL:sourceUrl options:nil];
	    
	    NSArray *compatiblePresets = [AVAssetExportSession exportPresetsCompatibleWithAsset:avAsset];
	    
	    NSLog(@"%@",compatiblePresets);
	    
	    if ([compatiblePresets containsObject:AVAssetExportPresetHighestQuality]) {
	        
	        AVAssetExportSession *exportSession = [[AVAssetExportSession alloc] initWithAsset:avAsset presetName:AVAssetExportPresetMediumQuality];
	        
	        
	        NSDate *date = [NSDate date];
	        NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
	        [formatter setDateFormat:@"yyyyMMddHHmmss"];
	        NSString *uniqueName = [NSString stringWithFormat:@"%@.mp4",[formatter stringFromDate:date]];
	        NSString * resultPath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES)[0] stringByAppendingPathComponent:uniqueName];//PATH_OF_DOCUMENTä¸ºdocumentsè·¯å¾„
	        
	        NSLog(@"output File Path : %@",resultPath);
	        
	        exportSession.outputURL = [NSURL fileURLWithPath:resultPath];
	        
	        exportSession.outputFileType = AVFileTypeMPEG4;//å¯ä»¥é…ç½®å¤šç§è¾“å‡ºæ–‡ä»¶æ ¼å¼
	        
	        exportSession.shouldOptimizeForNetworkUse = YES;
	        
	        [exportSession exportAsynchronouslyWithCompletionHandler:^(void)
	         {
	             switch (exportSession.status) {
	                     
	                 case AVAssetExportSessionStatusUnknown:
	                     
	                     break;
	                     
	                 case AVAssetExportSessionStatusWaiting:
	                     
	                     break;
	                     
	                 case AVAssetExportSessionStatusExporting:
	                     
	                     break;
	                     
	                 case AVAssetExportSessionStatusCompleted:
	                 {
	                     comepleteBlock(resultPath);
	                     
	                     
	                     NSLog(@"mp4 file size:%lf MB",[NSData dataWithContentsOfURL:exportSession.outputURL].length/1024.f/1024.f);
	                 }
	                     break;
	                     
	                 case AVAssetExportSessionStatusFailed:
	                     
	                     break;
	                     
	                 case AVAssetExportSessionStatusCancelled:
	                     
	                     break;
	                     
	             }  
	             
	         }];
	    }  
	}


##31:ä¸Šä¼ å›¾ç‰‡


	+ (void)uploadImage:(UIImage *)imageIcon successUpload:(void (^)(id responseObject))successUpload failureUpload:(void (^)(NSError *error))failureUpload;
	{
	    
	    //    æ‹¿åˆ°æ–‡ä»¶
	    NSString *NSDocmentsPath = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject;
	    NSString *iconPath       = [NSDocmentsPath stringByAppendingPathComponent:[NSString stringWithFormat:@"faceUrl.png"]];
	    //NSURL *url = [NSURL fileURLWithPath:iconPath];
	    
	    long long size = [iCocosGetSize fileSizeAtPath:iconPath];
	    
	    if (size >= 7000000) {
	        [SVProgressHUD showInfoWithStatus:@"å›¾ç‰‡è¿‡å¤§ï¼Œè¯·é‡æ–°ä¸Šä¼  \n è¯·ä¸è¦ä¸Šä¼ è¶…è¿‡7Mbæ–‡ä»¶"];
	        NSDictionary *errDict = [NSDictionary dictionaryWithObject:@"big" forKey:@"state"];
	        failureUpload((NSError *)errDict);
	        return;
	    }
	    
	    //1:æ–‡ä»¶çš„32ä½MD5å€¼
	    NSString *strForEight = [iCocosFormatFileGetEight getStringWithEight:iconPath];
	    //2:æ–‡ä»¶çš„å‰8ä¸ªå­—èŠ‚çš„16ä½+æ–‡ä»¶çš„å8ä¸ªå­—èŠ‚çš„16ä½
	    NSString *str32MD5    = [NSString getMd5_32Bit_String:iconPath];
	    
	    NSString *str64       = [NSString stringWithFormat:@"%@%@", str32MD5,strForEight];
	    
	    //å­˜å›¾ç‰‡
	    //    NSData *imageData = UIImageJPEGRepresentation(imageIcon, 1.0);//å°†UIImageè½¬ä¸ºNSDataï¼Œ1.0è¡¨ç¤ºä¸å‹ç¼©å›¾ç‰‡è´¨é‡ã€‚
	    NSData *imageData = [iCocosFileCondenseTools resetSizeOfImageData:imageIcon maxSize:50];
	    
	    
	    [imageData writeToFile:iconPath atomically:YES];
	    
	    AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];
	    manager.responseSerializer.acceptableContentTypes = [NSSet setWithObjects:@"text/html", nil];
	    
	    //    NSString *urlStrIF        = [NSString stringWithFormat:@"%@file/exist%@", [iCocosUrlOperationTools shareiCocosUrlOperationTools].iCocosFileUrl, [iCocosURLRequestExtension getURLRequestExtension]];
	    NSMutableDictionary *dict = [NSMutableDictionary dictionary];
	    //æ–‡ä»¶çš„32ä½MD5+å‰8ä¸ªå­—èŠ‚çš„16ä½+å8ä¸ªå­—èŠ‚çš„16ä½
	    dict[@"file_md5"] = str64;
	    dict[@"is_blur"] = @(1);
	    dict[@"file_size"] = @([iCocosGetSize fileSizeAtPath:iconPath]);
	    dict[@"ext"] = @"png";
	    
	    /**
	     *  è¶…æ—¶æ—¶é—´
	     */
	    [manager.requestSerializer willChangeValueForKey:@"timeoutInterval"];
	    manager.requestSerializer.timeoutInterval = 10.f;
	    [manager.requestSerializer didChangeValueForKey:@"timeoutInterval"];
	    
	    //    [manager POST:urlStrIF parameters:dict progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {
	    
	    [iCocosAFNPOSTRequestData iCocos_POST_HostSecurity:@"file/exist" hostHeaderValue:[iCocosUrlOperationTools shareiCocosUrlOperationTools].iCocosFileHost firstRequestWithUrl:[iCocosUrlOperationTools shareiCocosUrlOperationTools].iCocosFileUrl secondRequestWithIp:[iCocosUrlOperationTools shareiCocosUrlOperationTools].iCocosFileIp params:dict success:^(id response) {
	        
	        NSString *state = [NSString stringWithFormat:@"%@", [response objectStringForKey:@"state"]];
	        NSString *msg= [NSString stringWithFormat:@"%@", [response objectStringForKey:@"msg"]];
	        if ([state isEqualToString:@"0"]) {
	            NSString *exist = [NSString stringWithFormat:@"%@", [[response objectStringForKey:@"data"] objectStringForKey:@"exist"]];
	            /**
	             *  æ³¨æ„è¿™é‡Œéœ€è¦æ¢æˆçœŸå®æœåŠ¡å™¨åœ°å€
	             */
	            if ([exist isEqualToString:@"0"]) { //ä¸å­˜åœ¨å°±éœ€è¦å‘é€è¯·æ±‚
	                NSString *imageUrl          = [NSString stringWithFormat:@"%@file/up%@", [iCocosUrlOperationTools shareiCocosUrlOperationTools].iCocosFileUrl,[iCocosURLRequestExtension getURLRequestExtension]];
	                NSMutableDictionary *params = [NSMutableDictionary dictionary];
	                params[@"blur"]          = @(1);
	                
	                
	                AFHTTPSessionManager *mger = [AFHTTPSessionManager manager];
	                
	                AFJSONResponseSerializer *response = [AFJSONResponseSerializer serializer];
	                response.removesKeysWithNullValues = YES;
	                manager.responseSerializer = response;
	                
	                manager.requestSerializer = [AFHTTPRequestSerializer serializer];//å“åº”
	                
	                
	                
	                mger.responseSerializer.acceptableContentTypes = [NSSet setWithObjects:@"image/png", @"text/html", nil];
	                
	                /**
	                 *  è¶…æ—¶æ—¶é—´
	                 */
	                [manager.requestSerializer willChangeValueForKey:@"timeoutInterval"];
	                manager.requestSerializer.timeoutInterval = 10.f;
	                [manager.requestSerializer didChangeValueForKey:@"timeoutInterval"];
	                
	                
	                [mger POST:imageUrl parameters:params constructingBodyWithBlock:^(id<AFMultipartFormData> formData) {
	                    // ä¸Šä¼ æ–‡ä»¶
	                    NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
	                    formatter.dateFormat       = @"yyyyMMddHHmmss";
	                    NSString *str              = [formatter stringFromDate:[NSDate date]];
	                    NSString *fileName         = [NSString stringWithFormat:@"%@.png", str];
	                    
	                    [formData appendPartWithFileData:imageData name:@"file" fileName:fileName mimeType:@"image/png"];
	                    
	                } progress:^(NSProgress * _Nonnull uploadProgress) {
	                    
	                    iCocosLog(@"å°é¢å›¾ç‰‡================%@", uploadProgress);
	                    
	                } success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {
	                    
	                    NSDictionary *dataDic    = [responseObject objectStringForKey:@"data"]; 
	                    
	                    
	                    successUpload(dataDic);
	                    
	                    iCocosLog(@"%@", responseObject);
	                } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {
	                    iCocosLog(@"ä¸Šä¼ é”™è¯¯:%@", error);
	                    
	                    failureUpload(error);
	                }];
	                
	            } else {
	                
	                NSDictionary *dataDic    = [response objectStringForKey:@"data"];
	                
	                successUpload(dataDic);
	            }
	            
	        } else {
	            successUpload(response);
	        }
	    } failure:^(NSError *error) {
	        failureUpload(error);
	    }];
	
	}


##32ï¼šä¸Šä¼ è§†é¢‘

####ä¸Šä¼ MOV

	+ (void)updateMOVVideo:(NSURL *)url successUpload:(void (^)(id responseObject))successUpload failureUpload:(void (^)(NSError *error))failureUpload;
	{
	    //ä¿å­˜æ•°æ®
	    //    NSUserDefaults *defaults =[NSUserDefaults standardUserDefaults];
	    //    NSURL *url = [defaults URLForKey:@"RecordVideoUrl"];
	    
	    NSData *videoData = [NSData dataWithContentsOfURL:url];
	    
	    //   NSString *videoUrl = [iCocosUpLoadVideoTools upLoadVideoGetVideoUrlWithFileUrlInSandbox:url];
	    
	    //    NSString *strUrl = [NSString stringWithContentsOfURL:url usedEncoding:0 error:nil];
	    
	    //    //1:æ–‡ä»¶çš„32ä½MD5å€¼
	    //    NSString *strForEight = [iCocosFormatFileGetEight getStringWithEight:strUrl];
	    //
	    //    //2:æ–‡ä»¶çš„å‰8ä¸ªå­—èŠ‚çš„16ä½+æ–‡ä»¶çš„å8ä¸ªå­—èŠ‚çš„16ä½
	    //    NSString *str32MD5 = [NSString getMd5_32Bit_String:strUrl];
	    
	    NSString *str32MD5 = [iCocosRandomSix getSixRandom];
	    
	    NSString *str64 = [NSString stringWithFormat:@"%@%@", str32MD5,str32MD5];
	    
	    AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];
	    manager.responseSerializer.acceptableContentTypes = [NSSet setWithObjects:@"text/html", nil];
	    
	    //    NSString *urlStrIF = [NSString stringWithFormat:@"%@file/exist%@", [iCocosUrlOperationTools shareiCocosUrlOperationTools].iCocosFileUrl, [iCocosURLRequestExtension getURLRequestExtension]];
	    NSMutableDictionary *dict = [NSMutableDictionary dictionary];
	    dict[@"file_md5"] = str64;
	    dict[@"is_blur"] = 0;
	    dict[@"file_size"] = @([iCocosGetSize fileSizeAtPath:[url absoluteString]]);
	    dict[@"ext"] = @"MOV";
	    
	    /**
	     *  è¶…æ—¶æ—¶é—´
	     */
	    [manager.requestSerializer willChangeValueForKey:@"timeoutInterval"];
	    manager.requestSerializer.timeoutInterval = 10.f;
	    [manager.requestSerializer didChangeValueForKey:@"timeoutInterval"];
	    
	    /** è·å–è§†é¢‘æ˜¯å¦ä¸Šä¼  */
	    //    [manager POST:urlStrIF parameters:dict progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {
	    
	    [iCocosAFNPOSTRequestData iCocos_POST_HostSecurity:@"file/exist" hostHeaderValue:[iCocosUrlOperationTools shareiCocosUrlOperationTools].iCocosFileHost firstRequestWithUrl:[iCocosUrlOperationTools shareiCocosUrlOperationTools].iCocosFileUrl secondRequestWithIp:[iCocosUrlOperationTools shareiCocosUrlOperationTools].iCocosFileIp params:dict success:^(id response) {
	        
	        NSString *state = [NSString stringWithFormat:@"%@", [response objectStringForKey:@"state"]];
	        if ([state isEqualToString:@"0"]) {
	            NSString *exist = [response objectStringForKey:@"exist"];
	            /**
	             *  æ³¨æ„è¿™é‡Œéœ€è¦æ¢æˆçœŸå®æœåŠ¡å™¨åœ°å€
	             */
	            if (exist == 0) { //ä¸å­˜åœ¨å°±éœ€è¦å‘é€è¯·æ±‚
	                NSString *vidUrl = [NSString stringWithFormat:@"%@file/up%@", [iCocosUrlOperationTools shareiCocosUrlOperationTools].iCocosFileUrl, [iCocosURLRequestExtension getURLRequestExtension]];
	                NSMutableDictionary *params = [NSMutableDictionary dictionary];
	                //            params[@"name:file"] = @""; //Content-Disposition: form-data; name="file"; filename="1.txt"
	                params[@"is_blur"] = @0;
	                params[@"need_mp4"] = @1;
	                AFHTTPSessionManager *mger = [AFHTTPSessionManager manager];
	                
	                AFJSONResponseSerializer *response = [AFJSONResponseSerializer serializer];
	                response.removesKeysWithNullValues = YES;
	                manager.responseSerializer = response;
	                
	                manager.requestSerializer = [AFHTTPRequestSerializer serializer];//å“åº”
	                
	                
	                [mger.securityPolicy setAllowInvalidCertificates:YES];
	                
	                /** ä¸Šä¼ è§†é¢‘ */
	                [mger POST:vidUrl parameters:params constructingBodyWithBlock:^(id<AFMultipartFormData> formData) {
	                    
	                    // ä¸Šä¼ æ–‡ä»¶
	                    NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
	                    formatter.dateFormat = @"yyyyMMddHHmmss";
	                    NSString *str = [formatter stringFromDate:[NSDate date]];
	                    NSString *fileName = [NSString stringWithFormat:@"%@.mov", str];
	                    
	                    if (videoData != nil) {
	                        [formData appendPartWithFileData:videoData name:@"file" fileName:fileName mimeType:@"video/quicktime"];
	                    } else {
	                        
	                    }
	                    
	                } progress:^(NSProgress * _Nonnull uploadProgress) {
	                    
	//                    iCocosLog(@"%@", uploadProgress);
	                    
	                } success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {
	                    
	                    NSString *state = [NSString stringWithFormat:@"%@", [responseObject objectStringForKey:@"state"]];
	                    if ([state isEqualToString:@"0"]) {
	                        
	                        NSDictionary *dataDic = [responseObject objectStringForKey:@"data"];
	                        
	                        successUpload(dataDic);
	                    }
	                    
	                } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {
	                    iCocosLog(@"ä¸Šä¼ é”™è¯¯:%@", error);
	                    failureUpload(error);
	                }];
	                
	            } else {
	                /**
	                 *  å·²ç»ä¸Šä¼ 
	                 */
	                NSDictionary *dataDic    = [response objectStringForKey:@"data"];
	                NSString *file_url       = [NSString stringWithFormat:@"%@", [dataDic objectStringForKey:@"file_url"]];
	                NSString *mp4_file_url       = [NSString stringWithFormat:@"%@", [dataDic objectStringForKey:@"mp4_file_url"]];
	                
	                NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];
	                [defaults setValue:file_url forKey:@"video_url"];
	                [defaults setValue:mp4_file_url forKey:@"mp4_file_url"];
	                [defaults synchronize];
	                
	                successUpload(dataDic);
	            }
	            
	        } else {
	            successUpload(response);
	        }
	    } failure:^(NSError *error) { //ä¸Šä¼ é”™è¯¯
	        failureUpload(error);
	    }];
	}
	
####ä¸Šä¼ MP4	
	
	+ (void)updateMP4Video:(NSURL *)url successUpload:(void (^)(id responseObject))successUpload failureUpload:(void (^)(NSError *error))failureUpload
	{
	    //ä¿å­˜æ•°æ®
	    //    NSUserDefaults *defaults =[NSUserDefaults standardUserDefaults];
	    //    NSURL *url = [defaults URLForKey:@"RecordVideoUrl"];
	    
	    NSData *videoData = [NSData dataWithContentsOfURL:url];
	    
	    //   NSString *videoUrl = [iCocosUpLoadVideoTools upLoadVideoGetVideoUrlWithFileUrlInSandbox:url];
	    
	    //    NSString *strUrl = [NSString stringWithContentsOfURL:url usedEncoding:0 error:nil];
	    
	    //    //1:æ–‡ä»¶çš„32ä½MD5å€¼
	    //    NSString *strForEight = [iCocosFormatFileGetEight getStringWithEight:strUrl];
	    //
	    //    //2:æ–‡ä»¶çš„å‰8ä¸ªå­—èŠ‚çš„16ä½+æ–‡ä»¶çš„å8ä¸ªå­—èŠ‚çš„16ä½
	    //    NSString *str32MD5 = [NSString getMd5_32Bit_String:strUrl];
	    
	    NSString *str32MD5 = [iCocosRandomSix getSixRandom];
	    
	    NSString *str64 = [NSString stringWithFormat:@"%@%@", str32MD5,str32MD5];
	    
	    AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];
	    manager.responseSerializer.acceptableContentTypes = [NSSet setWithObjects:@"text/html", nil];
	    
	    //    NSString *urlStrIF = [NSString stringWithFormat:@"%@file/exist%@", [iCocosUrlOperationTools shareiCocosUrlOperationTools].iCocosFileUrl, [iCocosURLRequestExtension getURLRequestExtension]];
	    NSMutableDictionary *dict = [NSMutableDictionary dictionary];
	    dict[@"file_md5"] = str64;
	    dict[@"is_blur"] = 0;
	    dict[@"file_size"] = @([iCocosGetSize fileSizeAtPath:[url absoluteString]]);
	    dict[@"ext"] = @"mp4";
	    
	    /**
	     *  è¶…æ—¶æ—¶é—´
	     */
	    [manager.requestSerializer willChangeValueForKey:@"timeoutInterval"];
	    manager.requestSerializer.timeoutInterval = 10.f;
	    [manager.requestSerializer didChangeValueForKey:@"timeoutInterval"];
	    
	    /** è·å–è§†é¢‘æ˜¯å¦ä¸Šä¼  */
	    //    [manager POST:urlStrIF parameters:dict progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {
	    
	    [iCocosAFNPOSTRequestData iCocos_POST_HostSecurity:@"file/exist" hostHeaderValue:[iCocosUrlOperationTools shareiCocosUrlOperationTools].iCocosFileHost firstRequestWithUrl:[iCocosUrlOperationTools shareiCocosUrlOperationTools].iCocosFileUrl secondRequestWithIp:[iCocosUrlOperationTools shareiCocosUrlOperationTools].iCocosFileIp params:dict success:^(id response) {
	        
	        NSString *state = [NSString stringWithFormat:@"%@", [response objectStringForKey:@"state"]];
	        if ([state isEqualToString:@"0"]) {
	            NSString *exist = [response objectStringForKey:@"exist"];
	            /**
	             *  æ³¨æ„è¿™é‡Œéœ€è¦æ¢æˆçœŸå®æœåŠ¡å™¨åœ°å€
	             */
	            if (exist == 0) { //ä¸å­˜åœ¨å°±éœ€è¦å‘é€è¯·æ±‚
	                NSString *vidUrl = [NSString stringWithFormat:@"%@file/up%@", [iCocosUrlOperationTools shareiCocosUrlOperationTools].iCocosFileUrl, [iCocosURLRequestExtension getURLRequestExtension]];
	                NSMutableDictionary *params = [NSMutableDictionary dictionary];
	                //            params[@"name:file"] = @""; //Content-Disposition: form-data; name="file"; filename="1.txt"
	                params[@"is_blur"] = @0;
	                params[@"need_mp4"] = @1;
	                AFHTTPSessionManager *mger = [AFHTTPSessionManager manager];
	                
	                AFJSONResponseSerializer *response = [AFJSONResponseSerializer serializer];
	                response.removesKeysWithNullValues = YES;
	                manager.responseSerializer = response;
	                
	                manager.requestSerializer = [AFHTTPRequestSerializer serializer];//å“åº”
	                
	                
	                [mger.securityPolicy setAllowInvalidCertificates:YES];
	                
	                /** ä¸Šä¼ è§†é¢‘ */
	                [mger POST:vidUrl parameters:params constructingBodyWithBlock:^(id<AFMultipartFormData> formData) {
	                    
	                    // ä¸Šä¼ æ–‡ä»¶
	                    NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
	                    formatter.dateFormat = @"yyyyMMddHHmmss";
	                    NSString *str = [formatter stringFromDate:[NSDate date]];
	                    NSString *fileName = [NSString stringWithFormat:@"%@.mp4", str];
	                    
	                    if (videoData != nil) {
	                        [formData appendPartWithFileData:videoData name:@"file" fileName:fileName mimeType:@"video/mp4"];
	                    } else {
	                        
	                    }
	                    
	                } progress:^(NSProgress * _Nonnull uploadProgress) {
	                    
	                    
	//                    iCocosLog(@"%@", uploadProgress);
	                    
	                    
	                } success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {
	                    
	                    NSString *state = [NSString stringWithFormat:@"%@", [responseObject objectStringForKey:@"state"]];
	                    if ([state isEqualToString:@"0"]) {
	                        
	                        NSDictionary *dataDic = [responseObject objectStringForKey:@"data"];
	                        
	                        successUpload(dataDic);
	                    }
	                    
	                    
	                } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {
	                    iCocosLog(@"ä¸Šä¼ é”™è¯¯:%@", error);
	                    failureUpload(error);
	                }];
	                
	            } else {
	                
	                /**
	                 *  å·²ç»ä¸Šä¼ 
	                 */
	                NSDictionary *dataDic    = [response objectStringForKey:@"data"];
	                NSString *file_url       = [NSString stringWithFormat:@"%@", [dataDic objectStringForKey:@"file_url"]];
	                NSString *mp4_file_url       = [NSString stringWithFormat:@"%@", [dataDic objectStringForKey:@"mp4_file_url"]];
	                
	                NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];
	                [defaults setValue:file_url forKey:@"video_url"];
	                [defaults setValue:mp4_file_url forKey:@"mp4_file_url"];
	                [defaults synchronize];
	                
	                successUpload(dataDic);
	            }
	            
	        } else {
	            successUpload(response);
	        }
	    } failure:^(NSError *error) { //ä¸Šä¼ é”™è¯¯
	        failureUpload(error);
	    }];
	}


##33:è·å–è§†é¢‘å¸§å›¾

####åŒæ­¥è·å–å¸§å›¾

åŒæ­¥è·å–ä¸­é—´å¸§ï¼Œéœ€è¦æŒ‡å®šå“ªä¸ªæ—¶é—´ç‚¹çš„å¸§ï¼Œå½“è·å–åˆ°ä»¥åï¼Œè¿”å›æ¥çš„å›¾ç‰‡å¯¹è±¡æ˜¯CFRetainedè¿‡çš„ï¼Œéœ€è¦å¤–é¢æ‰‹åŠ¨CGImageReleaseä¸€ä¸‹ï¼Œé‡Šæ”¾å†…å­˜ã€‚é€šè¿‡AVAssetæ¥è®¿é—®å…·ä½“çš„è§†é¢‘èµ„æºï¼Œç„¶åé€šè¿‡AVAssetImageGeneratorå›¾ç‰‡ç”Ÿæˆå™¨æ¥ç”ŸæˆæŸä¸ªå¸§å›¾ç‰‡ï¼š
	// Get the video's center frame as video poster image
	- (UIImage *)frameImageFromVideoURL:(NSURL *)videoURL {
	  // result
	  UIImage *image = nil;
	  
	  // AVAssetImageGenerator
	  AVAsset *asset = [AVAsset assetWithURL:videoURL];
	  AVAssetImageGenerator *imageGenerator = [[AVAssetImageGenerator alloc] initWithAsset:asset];
	  imageGenerator.appliesPreferredTrackTransform = YES;
	  
	  // calculate the midpoint time of video
	  Float64 duration = CMTimeGetSeconds([asset duration]);
	  // å–æŸä¸ªå¸§çš„æ—¶é—´ï¼Œå‚æ•°ä¸€è¡¨ç¤ºå“ªä¸ªæ—¶é—´ï¼ˆç§’ï¼‰ï¼Œå‚æ•°äºŒè¡¨ç¤ºæ¯ç§’å¤šå°‘å¸§
	  // é€šå¸¸æ¥è¯´ï¼Œ600æ˜¯ä¸€ä¸ªå¸¸ç”¨çš„å…¬å…±å‚æ•°ï¼Œè‹¹æœæœ‰è¯´æ˜:
	  // 24 frames per second (fps) for film, 30 fps for NTSC (used for TV in North America and
	  // Japan), and 25 fps for PAL (used for TV in Europe).
	  // Using a timescale of 600, you can exactly represent any number of frames in these systems
	  CMTime midpoint = CMTimeMakeWithSeconds(duration / 2.0, 600);
	  
	  // get the image from
	  NSError *error = nil;
	  CMTime actualTime;
	  // Returns a CFRetained CGImageRef for an asset at or near the specified time.
	  // So we should mannully release it
	  CGImageRef centerFrameImage = [imageGenerator copyCGImageAtTime:midpoint
	                                                       actualTime:&actualTime
	                                                            error:&error];
	  
	  if (centerFrameImage != NULL) {
	    image = [[UIImage alloc] initWithCGImage:centerFrameImage];
	    // Release the CFRetained image
	    CGImageRelease(centerFrameImage);
	  }
	  
	  return image;
	}

####å¼‚æ­¥è·å–å¸§å›¾

å¼‚æ­¥è·å–æŸä¸ªå¸§çš„å›¾ç‰‡ï¼Œä¸åŒæ­¥ç›¸æ¯”ï¼Œåªæ˜¯è°ƒç”¨APIä¸åŒï¼Œå¯ä»¥ä¼ å¤šä¸ªæ—¶é—´ç‚¹ï¼Œç„¶åè®¡ç®—å‡ºå®é™…çš„æ—¶é—´å¹¶è¿”å›å›¾ç‰‡ï¼Œä½†æ˜¯è¿”å›çš„å›¾ç‰‡ä¸éœ€è¦æˆ‘ä»¬æ‰‹åŠ¨å†releaseäº†ã€‚æœ‰å¯èƒ½å–ä¸åˆ°å›¾ç‰‡ï¼Œæ‰€ä»¥è¿˜éœ€è¦åˆ¤æ–­æ˜¯å¦æ˜¯AVAssetImageGeneratorSucceededï¼Œæ˜¯æ‰è½¬æ¢å›¾ç‰‡ï¼š

	// å¼‚æ­¥è·å–å¸§å›¾ç‰‡ï¼Œå¯ä»¥ä¸€æ¬¡è·å–å¤šå¸§å›¾ç‰‡
	- (void)centerFrameImageWithVideoURL:(NSURL *)videoURL completion:(void (^)(UIImage *image))completion {
	  // AVAssetImageGenerator
	  AVAsset *asset = [AVAsset assetWithURL:videoURL];
	  AVAssetImageGenerator *imageGenerator = [[AVAssetImageGenerator alloc] initWithAsset:asset];
	  imageGenerator.appliesPreferredTrackTransform = YES;
	  
	  // calculate the midpoint time of video
	  Float64 duration = CMTimeGetSeconds([asset duration]);
	  // å–æŸä¸ªå¸§çš„æ—¶é—´ï¼Œå‚æ•°ä¸€è¡¨ç¤ºå“ªä¸ªæ—¶é—´ï¼ˆç§’ï¼‰ï¼Œå‚æ•°äºŒè¡¨ç¤ºæ¯ç§’å¤šå°‘å¸§
	  // é€šå¸¸æ¥è¯´ï¼Œ600æ˜¯ä¸€ä¸ªå¸¸ç”¨çš„å…¬å…±å‚æ•°ï¼Œè‹¹æœæœ‰è¯´æ˜:
	  // 24 frames per second (fps) for film, 30 fps for NTSC (used for TV in North America and
	  // Japan), and 25 fps for PAL (used for TV in Europe).
	  // Using a timescale of 600, you can exactly represent any number of frames in these systems
	  CMTime midpoint = CMTimeMakeWithSeconds(duration / 2.0, 600);
	  
	  // å¼‚æ­¥è·å–å¤šå¸§å›¾ç‰‡
	  NSValue *midTime = [NSValue valueWithCMTime:midpoint];
	  [imageGenerator generateCGImagesAsynchronouslyForTimes:@[midTime] completionHandler:^(CMTime requestedTime, CGImageRef  _Nullable image, CMTime actualTime, AVAssetImageGeneratorResult result, NSError * _Nullable error) {
	    if (result == AVAssetImageGeneratorSucceeded && image != NULL) {
	      UIImage *centerFrameImage = [[UIImage alloc] initWithCGImage:image];
	      dispatch_async(dispatch_get_main_queue(), ^{
	        if (completion) {
	          completion(centerFrameImage);
	        }
	      });
	    } else {
	      dispatch_async(dispatch_get_main_queue(), ^{
	        if (completion) {
	          completion(nil);
	        }
	      });
	    }
	  }];
	}
	 
	 
##34:å‹ç¼©å¹¶å¯¼å‡ºè§†é¢‘

å‹ç¼©è§†é¢‘æ˜¯å› ä¸ºè§†é¢‘åˆ†è¾¨ç‡è¿‡é«˜æ‰€ç”Ÿæˆçš„è§†é¢‘çš„å¤§å°å¤ªå¤§äº†ï¼Œå¯¹äºç§»åŠ¨è®¾å¤‡æ¥è¯´ï¼Œå†…å­˜æ˜¯ä¸èƒ½å¤ªå¤§çš„ï¼Œå¦‚æœä¸æ”¯æŒåˆ†ç‰‡ä¸Šä¼ åˆ°æœåŠ¡å™¨ï¼Œæˆ–è€…ä¸æ”¯æŒæµä¸Šä¼ ã€æ–‡ä»¶ä¸Šä¼ ï¼Œè€Œåªèƒ½æ”¯æŒè¡¨å•ä¸Šä¼ ï¼Œé‚£ä¹ˆå¿…é¡»è¦é™åˆ¶å¤§å°ï¼Œå‹ç¼©è§†é¢‘ã€‚

å°±åƒæˆ‘ä»¬åœ¨ä½¿ç”¨æŸå¹³å°çš„è§†é¢‘çš„ä¸Šä¼ çš„æ—¶å€™ï¼Œåˆ°ç°åœ¨è¿˜æ²¡æœ‰æ”¯æŒæµä¸Šä¼ ï¼Œä¹Ÿä¸æ”¯æŒæ–‡ä»¶ä¸Šä¼ ï¼Œåªæ”¯æŒè¡¨å•ä¸Šä¼ ï¼Œå¯¼è‡´è§†é¢‘å¤§ä¸€ç‚¹å°±ä¼šé—ªé€€ã€‚æµä¸Šä¼ æ˜¯ä¸Šä¼ æˆåŠŸäº†ï¼Œä½†æ˜¯äººå®¶åå°ä¸è¯†åˆ«ï¼Œè¿™ä¸€æ¬¡è®©æŸå¹³å°å‘åäº†ã€‚ç›´æ¥ç”¨fileä¸Šä¼ ï¼Œä¹Ÿä¼ è¿‡å»äº†ï¼Œä¸Šä¼ è¿›åº¦100%äº†ï¼Œä½†æ˜¯äººå®¶é‚£è¾¹è¿˜æ˜¯ä½œä¸ºå¤±è´¥å¤„ç†ï¼Œæ— å¥ˆï¼

>è¨€å½’æ­£ä¼ ï¼Œå‹ç¼©ã€å¯¼å‡ºè§†é¢‘ï¼Œéœ€è¦é€šè¿‡AVAssetExportSessionæ¥å®ç°ï¼Œæˆ‘ä»¬éœ€è¦æŒ‡å®šä¸€ä¸ªpresetï¼Œå¹¶åˆ¤æ–­æ˜¯å¦æ”¯æŒè¿™ä¸ªpresetï¼Œåªæœ‰æ”¯æŒæ‰èƒ½ä½¿ç”¨ã€‚

æˆ‘ä»¬è¿™é‡Œè®¾ç½®çš„presetä¸ºAVAssetExportPreset640x480ï¼Œå±äºå‹ç¼©å¾—æ¯”è¾ƒå‰å®³çš„äº†ï¼Œè¿™éœ€è¦æ ¹æ®æœåŠ¡å™¨è§†é¢‘ä¸Šä¼ çš„æ”¯æŒç¨‹åº¦è€Œé€‰æ‹©çš„ã€‚ç„¶åé€šè¿‡è°ƒç”¨å¼‚æ­¥å‹ç¼©å¹¶å¯¼å‡ºè§†é¢‘ï¼š


	- (void)compressVideoWithVideoURL:(NSURL *)videoURL
	                        savedName:(NSString *)savedName
	                       completion:(void (^)(NSString *savedPath))completion {
	  // Accessing video by URL
	  AVURLAsset *videoAsset = [[AVURLAsset alloc] initWithURL:videoURL options:nil];
	  
	  // Find compatible presets by video asset.
	  NSArray *presets = [AVAssetExportSession exportPresetsCompatibleWithAsset:videoAsset];
	  
	  // Begin to compress video
	  // Now we just compress to low resolution if it supports
	  // If you need to upload to the server, but server does't support to upload by streaming,
	  // You can compress the resolution to lower. Or you can support more higher resolution.
	  if ([presets containsObject:AVAssetExportPreset640x480]) {
	    AVAssetExportSession *session = [[AVAssetExportSession alloc] initWithAsset:videoAsset  presetName:AVAssetExportPreset640x480];
	    
	    NSString *doc = [NSHomeDirectory() stringByAppendingPathComponent:@"Documents"];
	    NSString *folder = [doc stringByAppendingPathComponent:@"HYBVideos"];
	    BOOL isDir = NO;
	    BOOL isExist = [[NSFileManager defaultManager] fileExistsAtPath:folder isDirectory:&isDir];
	    if (!isExist || (isExist && !isDir)) {
	      NSError *error = nil;
	      [[NSFileManager defaultManager] createDirectoryAtPath:folder
	                                withIntermediateDirectories:YES
	                                                 attributes:nil
	                                                      error:&error];
	      if (error == nil) {
	        NSLog(@"ç›®å½•åˆ›å»ºæˆåŠŸ");
	      } else {
	        NSLog(@"ç›®å½•åˆ›å»ºå¤±è´¥");
	      }
	    }
	    
	    NSString *outPutPath = [folder stringByAppendingPathComponent:savedName];
	    session.outputURL = [NSURL fileURLWithPath:outPutPath];
	    
	    // Optimize for network use.
	    session.shouldOptimizeForNetworkUse = true;
	    
	    NSArray *supportedTypeArray = session.supportedFileTypes;
	    if ([supportedTypeArray containsObject:AVFileTypeMPEG4]) {
	      session.outputFileType = AVFileTypeMPEG4;
	    } else if (supportedTypeArray.count == 0) {
	      NSLog(@"No supported file types");
	      return;
	    } else {
	      session.outputFileType = [supportedTypeArray objectAtIndex:0];
	    }
	    
	    // Begin to export video to the output path asynchronously.
	    [session exportAsynchronouslyWithCompletionHandler:^{
	      if ([session status] == AVAssetExportSessionStatusCompleted) {
	        dispatch_async(dispatch_get_main_queue(), ^{
	          if (completion) {
	            completion([session.outputURL path]);
	          }
	        });
	      } else {
	        dispatch_async(dispatch_get_main_queue(), ^{
	          if (completion) {
	            completion(nil);
	          }
	        });
	      }
	    }];
	  }
	}
	

##35:ä¿å­˜è§†é¢‘åˆ°ç›¸å†Œ

å†™å…¥ç›¸å†Œå¯ä»¥é€šè¿‡ALAssetsLibraryç±»æ¥å®ç°ï¼Œå®ƒæä¾›äº†å†™å…¥ç›¸å†Œçš„APIï¼Œå¼‚æ­¥å†™å…¥ï¼Œå®Œæˆæ˜¯è¦å›åˆ°ä¸»çº¿ç¨‹æ›´æ–°UIï¼š

	NSURL *videoURL = [info objectForKey:UIImagePickerControllerMediaURL];
	ALAssetsLibrary *library = [[ALAssetsLibrary alloc] init];
	dispatch_async(dispatch_get_global_queue(0, 0), ^{
	  // åˆ¤æ–­ç›¸å†Œæ˜¯å¦å…¼å®¹è§†é¢‘ï¼Œå…¼å®¹æ‰èƒ½ä¿å­˜åˆ°ç›¸å†Œ
	  if ([library videoAtPathIsCompatibleWithSavedPhotosAlbum:videoURL]) {
	    [library writeVideoAtPathToSavedPhotosAlbum:videoURL completionBlock:^(NSURL *assetURL, NSError *error) {
	      dispatch_async(dispatch_get_main_queue(), ^{
	        // å†™å…¥ç›¸å†Œ
	        if (error == nil) {
	            NSLog(@"å†™å…¥ç›¸å†ŒæˆåŠŸ");
	        } else {
	           NSLog(@"å†™å…¥ç›¸å†Œå¤±è´¥");
	        }
	      }
	    }];
	  }
	});
	

##36:è·å–å½“å‰æœ€é¡¶å±‚çš„ViewController
	
		- (UIViewController *)topViewController {
	    UIViewController *resultVC;
	    resultVC = [self _topViewController:[[UIApplication sharedApplication].keyWindow rootViewController]];
	    while (resultVC.presentedViewController) {
	        resultVC = [self _topViewController:resultVC.presentedViewController];
	    }
	    return resultVC;
	}

	- (UIViewController *)_topViewController:(UIViewController *)vc {
	    if ([vc isKindOfClass:[UINavigationController class]]) {
	        return [self _topViewController:[(UINavigationController *)vc topViewController]];
	    } else if ([vc isKindOfClass:[UITabBarController class]]) {
	        return [self _topViewController:[(UITabBarController *)vc selectedViewController]];
	    } else {
	        return vc;
	    }
	    return nil;
	}

ä½¿ç”¨æ–¹æ³•

	UIViewController *topmostVC = [self topViewController];
	


##37:æ•°ç»„æ‹†åˆ†
	
	
	/**
	 *  æ•°ç»„æ‹†åˆ†
	 *
	 *  @param array   æ•°ç»„
	 *  @param subSize å¤§å°
	 *
	 *  @return å¤šä¸ªæ•°ç»„
	 */
	- (NSMutableArray *)splitArray: (NSArray *)array withSubSize : (int)subSize{
	    //  æ•°ç»„å°†è¢«æ‹†åˆ†æˆæŒ‡å®šé•¿åº¦æ•°ç»„çš„ä¸ªæ•°
	    unsigned long count = array.count % subSize == 0 ? (array.count / subSize) : (array.count / subSize + 1);
	    //  ç”¨æ¥ä¿å­˜æŒ‡å®šé•¿åº¦æ•°ç»„çš„å¯å˜æ•°ç»„å¯¹è±¡
	    NSMutableArray *arr = [[NSMutableArray alloc] init];
	    
	    //åˆ©ç”¨æ€»ä¸ªæ•°è¿›è¡Œå¾ªç¯ï¼Œå°†æŒ‡å®šé•¿åº¦çš„å…ƒç´ åŠ å…¥æ•°ç»„
	    for (int i = 0; i < count; i ++) {
	        //æ•°ç»„ä¸‹æ ‡
	        int index = i * subSize;
	        //ä¿å­˜æ‹†åˆ†çš„å›ºå®šé•¿åº¦çš„æ•°ç»„å…ƒç´ çš„å¯å˜æ•°ç»„
	        NSMutableArray *arr1 = [[NSMutableArray alloc] init];
	        //ç§»é™¤å­æ•°ç»„çš„æ‰€æœ‰å…ƒç´ 
	        [arr1 removeAllObjects];
	        
	        int j = index;
	        //å°†æ•°ç»„ä¸‹æ ‡ä¹˜ä»¥1ã€2ã€3ï¼Œå¾—åˆ°æ‹†åˆ†æ—¶æ•°ç»„çš„æœ€å¤§ä¸‹æ ‡å€¼ï¼Œä½†æœ€å¤§ä¸èƒ½è¶…è¿‡æ•°ç»„çš„æ€»å¤§å°
	        while (j < subSize*(i + 1) && j < array.count) {
	            [arr1 addObject:[array objectAtIndexCheck:j]];
	            j += 1;
	        }
	        //å°†å­æ•°ç»„æ·»åŠ åˆ°ä¿å­˜å­æ•°ç»„çš„æ•°ç»„ä¸­
	        [arr addObject:[arr1 copy]];  
	    }  
	    
	    return arr;
	}

##38.å›¾ç‰‡å‹ç¼©

ç”¨æ³•ï¼šUIImage *yourImage= [self imageWithImageSimple:image scaledToSize:CGSizeMake(210.0, 210.0)];
	
	//å‹ç¼©å›¾ç‰‡
	- (UIImage*)imageWithImageSimple:(UIImage*)image scaledToSize:(CGSize)newSize
	
	{
	
	// Create a graphics image context
	
	UIGraphicsBeginImageContext(newSize);
	
	// Tell the old image to draw in this newcontext, with the desired
	
	// new size
	
	[image drawInRect:CGRectMake(0,0,newSize.width,newSize.height)];
	
	// Get the new image from the context
	
	UIImage* newImage = UIGraphicsGetImageFromCurrentImageContext();
	
	// End the context
	
	UIGraphicsEndImageContext();
	
	// Return the new image.
	
	return newImage;
	
	}
	
##39.é‡Šæ”¾Timerå®

	/*
	 * åˆ¤æ–­è¿™ä¸ªTimerä¸ä¸ºnilåˆ™åœæ­¢å¹¶é‡Šæ”¾
	 * å¦‚æœä¸å…ˆåœæ­¢å¯èƒ½ä¼šå¯¼è‡´crash
	 */
	#define WVSAFA_DELETE_TIMER(timer) { \
	    if (timer != nil) { \
	        [timer invalidate]; \
	        [timer release]; \
	        timer = nil; \
	    } \
	}



###è·å–æŸä¸ªviewæ‰€åœ¨çš„æ§åˆ¶å™¨

	- (UIViewController *)viewController
	{
	  UIViewController *viewController = nil;  
	  UIResponder *next = self.nextResponder;
	  while (next)
	  {
	    if ([next isKindOfClass:[UIViewController class]])
	    {
	      viewController = (UIViewController *)next;      
	      break;    
	    }    
	    next = next.nextResponder;  
	  } 
	    return viewController;
	}

###ä¸¤ç§æ–¹æ³•åˆ é™¤NSUserDefaultsæ‰€æœ‰è®°å½•

	//æ–¹æ³•ä¸€
	NSString *appDomain = [[NSBundle mainBundle] bundleIdentifier];
	[[NSUserDefaults standardUserDefaults] removePersistentDomainForName:appDomain];
	
	
	//æ–¹æ³•äºŒ
	- (void)resetDefaults
	{
	    NSUserDefaults * defs = [NSUserDefaults standardUserDefaults];
	    NSDictionary * dict = [defs dictionaryRepresentation];
	    for (id key in dict)
	    {
	        [defs removeObjectForKey:key];
	    }
	    [defs synchronize];
	}

###æ‰“å°ç³»ç»Ÿæ‰€æœ‰å·²æ³¨å†Œçš„å­—ä½“åç§°

	#pragma mark - æ‰“å°ç³»ç»Ÿæ‰€æœ‰å·²æ³¨å†Œçš„å­—ä½“åç§°
	void enumerateFonts()
	{
	    for(NSString *familyName in [UIFont familyNames])
	   {
	        NSLog(@"%@",familyName);               
	        NSArray *fontNames = [UIFont fontNamesForFamilyName:familyName];       
	        for(NSString *fontName in fontNames)
	       {
	            NSLog(@"\t|- %@",fontName);
	       }
	   }
	}

###è·å–å›¾ç‰‡æŸä¸€ç‚¹çš„é¢œè‰²

	- (UIColor*) getPixelColorAtLocation:(CGPoint)point inImage:(UIImage *)image
	{
	
	    UIColor* color = nil;
	    CGImageRef inImage = image.CGImage;
	    CGContextRef cgctx = [self createARGBBitmapContextFromImage:inImage];
	
	    if (cgctx == NULL) {
	        return nil; /* error */
	    }
	    size_t w = CGImageGetWidth(inImage);
	    size_t h = CGImageGetHeight(inImage);
	    CGRect rect = {0,0,w,}};
	
	    CGContextDrawImage(cgctx, rect, inImage);
	    unsigned char* data = CGBitmapContextGetData (cgctx);
	    if (data != NULL) {
	        int offset = 4*((w*round(point.y))+round(point.x));
	        int alpha =  data[offset];
	        int red = data[offset+1];
	        int green = data[offset+2];
	        int blue = data[offset+3];
	        color = [UIColor colorWithRed:(red/255.0f) green:(green/255.0f) blue:
	                 (blue/255.0f) alpha:(alpha/255.0f)];
	    }
	    CGContextRelease(cgctx);
	    if (data) {
	        free(data);
	    }
	    return color;
	}

###å­—ç¬¦ä¸²åè½¬

	ç¬¬ä¸€ç§ï¼š
	- (NSString *)reverseWordsInString:(NSString *)str
	{    
	    NSMutableString *newString = [[NSMutableString alloc] initWithCapacity:str.length];
	    for (NSInteger i = str.length - 1; i >= 0 ; i --)
	    {
	        unichar ch = [str characterAtIndex:i];       
	        [newString appendFormat:@"%c", ch];    
	    }    
	     return newString;
	}
	
	//ç¬¬äºŒç§ï¼š
	- (NSString*)reverseWordsInString:(NSString*)str
	{    
	     NSMutableString *reverString = [NSMutableString stringWithCapacity:str.length];    
	     [str enumerateSubstringsInRange:NSMakeRange(0, str.length) options:NSStringEnumerationReverse | NSStringEnumerationByComposedCharacterSequences  usingBlock:^(NSString *substring, NSRange substringRange, NSRange enclosingRange, BOOL *stop) { 
	          [reverString appendString:substring];                         
	      }];    
	     return reverString;
	}

###ç¦æ­¢é”å±ï¼Œ

é»˜è®¤æƒ…å†µä¸‹ï¼Œå½“è®¾å¤‡ä¸€æ®µæ—¶é—´æ²¡æœ‰è§¦æ§åŠ¨ä½œæ—¶ï¼ŒiOSä¼šé”ä½å±å¹•ã€‚ä½†æœ‰ä¸€äº›åº”ç”¨æ˜¯ä¸éœ€è¦é”å±çš„ï¼Œæ¯”å¦‚è§†é¢‘æ’­æ”¾å™¨ã€‚

	[UIApplication sharedApplication].idleTimerDisabled = YES;
	æˆ–
	[[UIApplication sharedApplication] setIdleTimerDisabled:YES];

###æ¨¡æ€æ¨å‡ºé€æ˜ç•Œé¢

	UIViewController *vc = [[UIViewController alloc] init];
	UINavigationController *na = [[UINavigationController alloc] initWithRootViewController:vc];
	
	if ([[[UIDevice currentDevice] systemVersion] floatValue] >= 8.0)
	{
	     na.modalPresentationStyle = UIModalPresentationOverCurrentContext;
	}
	else
	{
	     self.modalPresentationStyle=UIModalPresentationCurrentContext;
	}
	
	[self presentViewController:na animated:YES completion:nil];


###Xcodeè°ƒè¯•ä¸æ˜¾ç¤ºå†…å­˜å ç”¨

	editSCheme  é‡Œé¢æœ‰ä¸ªé€‰é¡¹å«å«åšenable zoombie Objects  å–æ¶ˆé€‰ä¸­

###æ˜¾ç¤ºéšè—æ–‡ä»¶

	//æ˜¾ç¤º
	defaults write com.apple.finder AppleShowAllFiles -bool true
	killall Finder
	
	//éšè—
	defaults write com.apple.finder AppleShowAllFiles -bool false
	killall Finder
 
###iOSè·³è½¬åˆ°App Storeä¸‹è½½åº”ç”¨è¯„åˆ†

	[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@"itms-apps://itunes.apple.com/WebObjects/MZStore.woa/wa/viewContentsUserReviews?type=Purple+Software&id=APPID"]];

###iOS è·å–æ±‰å­—çš„æ‹¼éŸ³

	+ (NSString *)transform:(NSString *)chinese
	{    
	    //å°†NSStringè£…æ¢æˆNSMutableString 
	    NSMutableString *pinyin = [chinese mutableCopy];    
	    //å°†æ±‰å­—è½¬æ¢ä¸ºæ‹¼éŸ³(å¸¦éŸ³æ ‡)    
	    CFStringTransform((__bridge CFMutableStringRef)pinyin, NULL, kCFStringTransformMandarinLatin, NO);    
	    NSLog(@"%@", pinyin);    
	    //å»æ‰æ‹¼éŸ³çš„éŸ³æ ‡    
	    CFStringTransform((__bridge CFMutableStringRef)pinyin, NULL, kCFStringTransformStripCombiningMarks, NO);    
	    NSLog(@"%@", pinyin);    
	    //è¿”å›æœ€è¿‘ç»“æœ    
	    return pinyin;
	 }

###æ‰‹åŠ¨æ›´æ”¹iOSçŠ¶æ€æ çš„é¢œè‰²

	- (void)setStatusBarBackgroundColor:(UIColor *)color
	{
	    UIView *statusBar = [[[UIApplication sharedApplication] valueForKey:@"statusBarWindow"] valueForKey:@"statusBar"];
	
	    if ([statusBar respondsToSelector:@selector(setBackgroundColor:)])
	    {
	        statusBar.backgroundColor = color;    
	    }
	}


###åˆ¤æ–­å½“å‰ViewControlleræ˜¯pushè¿˜æ˜¯presentçš„æ–¹å¼æ˜¾ç¤ºçš„

	
	NSArray *viewcontrollers=self.navigationController.viewControllers;
	 
	if (viewcontrollers.count > 1)
	{
	    if ([viewcontrollers objectAtIndex:viewcontrollers.count - 1] == self)
	    {
	        //pushæ–¹å¼
	       [self.navigationController popViewControllerAnimated:YES];
	    }
	}
	else
	{
	    //presentæ–¹å¼
	    [self dismissViewControllerAnimated:YES completion:nil];
	}

###è·å–å®é™…ä½¿ç”¨çš„LaunchImageå›¾ç‰‡

	
	- (NSString *)getLaunchImageName
	{
	    CGSize viewSize = self.window.bounds.size;
	    // ç«–å±    
	    NSString *viewOrientation = @"Portrait";  
	    NSString *launchImageName = nil;    
	    NSArray* imagesDict = [[[NSBundle mainBundle] infoDictionary] valueForKey:@"UILaunchImages"];
	    for (NSDictionary* dict in imagesDict)
	    {
	        CGSize imageSize = CGSizeFromString(dict[@"UILaunchImageSize"]);
	        if (CGSizeEqualToSize(imageSize, viewSize) && [viewOrientation isEqualToString:dict[@"UILaunchImageOrientation"]])
	        {
	            launchImageName = dict[@"UILaunchImageName"];        
	        }    
	    }    
	    return launchImageName;
	}

###iOSåœ¨å½“å‰å±å¹•è·å–ç¬¬ä¸€å“åº”

	UIWindow * keyWindow = [[UIApplication sharedApplication] keyWindow];
	UIView * firstResponder = [keyWindow performSelector:@selector(firstResponder)];

###åˆ¤æ–­å¯¹è±¡æ˜¯å¦éµå¾ªäº†æŸåè®®

	
	if ([self.selectedController conformsToProtocol:@protocol(RefreshPtotocol)])
	{
	     [self.selectedController performSelector:@selector(onTriggerRefresh)];
	}

###åˆ¤æ–­viewæ˜¯ä¸æ˜¯æŒ‡å®šè§†å›¾çš„å­è§†å›¾

	BOOL isView = [textView isDescendantOfView:self.view];

###NSArray å¿«é€Ÿæ±‚æ€»å’Œ æœ€å¤§å€¼ æœ€å°å€¼ å’Œ å¹³å‡å€¼

		
	NSArray *array = [NSArray arrayWithObjects:@"2.0", @"2.3", @"3.0", @"4.0", @"10", nil];
	CGFloat sum = [[array valueForKeyPath:@"@sum.floatValue"] floatValue];
	CGFloat avg = [[array valueForKeyPath:@"@avg.floatValue"] floatValue];
	CGFloat max =[[array valueForKeyPath:@"@max.floatValue"] floatValue];
	CGFloat min =[[array valueForKeyPath:@"@min.floatValue"] floatValue];
	NSLog(@"%f\n%f\n%f\n%f",sum,avg,max,min);

###ä¿®æ”¹UITextFieldä¸­Placeholderçš„æ–‡å­—é¢œè‰²

	
	[textField setValue:[UIColor redColor] forKeyPath:@"_placeholderLabel.textColor"];

###å…³äºNSDateFormatterçš„æ ¼å¼

	
	G: å…¬å…ƒæ—¶ä»£ï¼Œä¾‹å¦‚ADå…¬å…ƒ
	yy: å¹´çš„å2ä½
	yyyy: å®Œæ•´å¹´
	MM: æœˆï¼Œæ˜¾ç¤ºä¸º1-12
	MMM: æœˆï¼Œæ˜¾ç¤ºä¸ºè‹±æ–‡æœˆä»½ç®€å†™,å¦‚ Jan
	MMMM: æœˆï¼Œæ˜¾ç¤ºä¸ºè‹±æ–‡æœˆä»½å…¨ç§°ï¼Œå¦‚ Janualy
	dd: æ—¥ï¼Œ2ä½æ•°è¡¨ç¤ºï¼Œå¦‚02
	d: æ—¥ï¼Œ1-2ä½æ˜¾ç¤ºï¼Œå¦‚ 2
	EEE: ç®€å†™æ˜ŸæœŸå‡ ï¼Œå¦‚Sun
	EEEE: å…¨å†™æ˜ŸæœŸå‡ ï¼Œå¦‚Sunday
	aa: ä¸Šä¸‹åˆï¼ŒAM/PM
	H: æ—¶ï¼Œ24å°æ—¶åˆ¶ï¼Œ0-23
	Kï¼šæ—¶ï¼Œ12å°æ—¶åˆ¶ï¼Œ0-11
	m: åˆ†ï¼Œ1-2ä½
	mm: åˆ†ï¼Œ2ä½
	s: ç§’ï¼Œ1-2ä½
	ss: ç§’ï¼Œ2ä½
	S: æ¯«ç§’

###è·å–ä¸€ä¸ªç±»çš„æ‰€æœ‰å­ç±»

	
	+ (NSArray *) allSubclasses
	{
	    Class myClass = [self class];
	    NSMutableArray *mySubclasses = [NSMutableArray array];
	    unsigned int numOfClasses;
	    Class *classes = objc_copyClassList(&numOfClasses;);
	    for (unsigned int ci = 0; ci 
	}
###ç›‘æµ‹IOSè®¾å¤‡æ˜¯å¦è®¾ç½®äº†ä»£ç†ï¼Œéœ€è¦CFNetwork.framework

	
	NSDictionary *proxySettings = (__bridge NSDictionary *)(CFNetworkCopySystemProxySettings());
	NSArray *proxies = (__bridge NSArray *)(CFNetworkCopyProxiesForURL((__bridge CFURLRef _Nonnull)([NSURL URLWithString:@"http://www.baidu.com"]), (__bridge CFDictionaryRef _Nonnull)(proxySettings)));
	NSLog(@"\n%@",proxies);
	 
	NSDictionary *settings = proxies[0];
	NSLog(@"%@",[settings objectForKey:(NSString *)kCFProxyHostNameKey]);
	NSLog(@"%@",[settings objectForKey:(NSString *)kCFProxyPortNumberKey]);
	NSLog(@"%@",[settings objectForKey:(NSString *)kCFProxyTypeKey]);
	 
	if ([[settings objectForKey:(NSString *)kCFProxyTypeKey] isEqualToString:@"kCFProxyTypeNone"])
	{
	     NSLog(@"æ²¡ä»£ç†");
	}
	else
	{
	     NSLog(@"è®¾ç½®äº†ä»£ç†");
	}

###é˜¿æ‹‰ä¼¯æ•°å­—è½¬ä¸­æ–‡æ ¼å¼

	
	+(NSString *)translation:(NSString *)arebic
	{  
	    NSString *str = arebic;
	    NSArray *arabic_numerals = @[@"1",@"2",@"3",@"4",@"5",@"6",@"7",@"8",@"9",@"0"];
	    NSArray *chinese_numerals = @[@"ä¸€",@"äºŒ",@"ä¸‰",@"å››",@"äº”",@"å…­",@"ä¸ƒ",@"å…«",@"ä¹",@"é›¶"];
	    NSArray *digits = @[@"ä¸ª",@"å",@"ç™¾",@"åƒ",@"ä¸‡",@"å",@"ç™¾",@"åƒ",@"äº¿",@"å",@"ç™¾",@"åƒ",@"å…†"];
	    NSDictionary *dictionary = [NSDictionary dictionaryWithObjects:chinese_numerals forKeys:arabic_numerals];
	 
	    NSMutableArray *sums = [NSMutableArray array];
	    for (int i = 0; i 
	 
	}

###Base64ç¼–ç ä¸NSStringå¯¹è±¡æˆ–NSDataå¯¹è±¡çš„è½¬æ¢

	
	// Create NSData object
	NSData *nsdata = [@"iOS Developer Tips encoded in Base64"
	  dataUsingEncoding:NSUTF8StringEncoding];
	 
	// Get NSString from NSData object in Base64
	NSString *base64Encoded = [nsdata base64EncodedStringWithOptions:0];
	 
	// Print the Base64 encoded string
	NSLog(@"Encoded: %@", base64Encoded);
	 
	// Let's go the other way...
	 
	// NSData from the Base64 encoded str
	NSData *nsdataFromBase64String = [[NSData alloc]
	  initWithBase64EncodedString:base64Encoded options:0];
	 
	// Decoded NSString from the NSData
	NSString *base64Decoded = [[NSString alloc]
	  initWithData:nsdataFromBase64String encoding:NSUTF8StringEncoding];
	NSLog(@"Decoded: %@", base64Decoded);

###å–æ¶ˆUICollectionViewçš„éšå¼åŠ¨ç”»

	UICollectionViewåœ¨reloadItemsçš„æ—¶å€™ï¼Œé»˜è®¤ä¼šé™„åŠ ä¸€ä¸ªéšå¼çš„fadeåŠ¨ç”»ï¼Œæœ‰æ—¶å€™å¾ˆè®¨åŒï¼Œå°¤å…¶æ˜¯å½“ä½ çš„cellæ˜¯å¤åˆcellçš„æƒ…å†µä¸‹(æ¯”å¦‚cellä½¿ç”¨åˆ°äº†UIStackView)ã€‚
###ä¸‹é¢å‡ ç§æ–¹æ³•éƒ½å¯ä»¥å¸®ä½ å»é™¤è¿™äº›åŠ¨ç”»
	
	//æ–¹æ³•ä¸€
	[UIView performWithoutAnimation:^{
	    [collectionView reloadItemsAtIndexPaths:@[[NSIndexPath indexPathForItem:index inSection:0]]];
	}];
	
	//æ–¹æ³•äºŒ
	[UIView animateWithDuration:0 animations:^{
	    [collectionView performBatchUpdates:^{
	        [collectionView reloadItemsAtIndexPaths:@[[NSIndexPath indexPathForItem:index inSection:0]]];
	    } completion:nil];
	}];
	
	//æ–¹æ³•ä¸‰
	[UIView setAnimationsEnabled:NO];
	[self.trackPanel performBatchUpdates:^{
	    [collectionView reloadItemsAtIndexPaths:@[[NSIndexPath indexPathForItem:index inSection:0]]];
	} completion:^(BOOL finished) {
	    [UIView setAnimationsEnabled:YES];
	}];
###è®©Xcodeçš„æ§åˆ¶å°æ”¯æŒLLDBç±»å‹çš„æ‰“å°
	
	æ‰“å¼€ç»ˆç«¯è¾“å…¥ä¸‰æ¡å‘½ä»¤:
	touch ~/.lldbinit
	echo display @import UIKit >> ~/.lldbinit
	echo target stop-hook add -o \"target stop-hook disable\" >> ~/.lldbinit

###CocoaPods pod install/pod updateæ›´æ–°æ…¢çš„é—®é¢˜
	
	pod install --verbose --no-repo-update 
	pod update --verbose --no-repo-update
å¦‚æœä¸åŠ åé¢çš„å‚æ•°ï¼Œé»˜è®¤ä¼šå‡çº§CocoaPodsçš„specä»“åº“ï¼ŒåŠ ä¸€ä¸ªå‚æ•°å¯ä»¥çœç•¥è¿™ä¸€æ­¥ï¼Œç„¶åé€Ÿåº¦å°±ä¼šæå‡ä¸å°‘

###UIImage å ç”¨å†…å­˜å¤§å°

	UIImage *image = [UIImage imageNamed:@"aa"];
	NSUInteger size  = CGImageGetHeight(image.CGImage) * CGImageGetBytesPerRow(image.CGImage);

###GCD timerå®šæ—¶å™¨

	
	dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
	dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0,queue);
	dispatch_source_set_timer(timer,dispatch_walltime(NULL, 0),1.0*NSEC_PER_SEC, 0); //æ¯ç§’æ‰§è¡Œ
	dispatch_source_set_event_handler(timer, ^{
	    //@"å€’è®¡æ—¶ç»“æŸï¼Œå…³é—­"
	    dispatch_source_cancel(timer); 
	    dispatch_async(dispatch_get_main_queue(), ^{
	 
	    });
	});
	dispatch_resume(timer);

###å›¾ç‰‡ä¸Šç»˜åˆ¶æ–‡å­— å†™ä¸€ä¸ªUIImageçš„category

	- (UIImage *)imageWithTitle:(NSString *)title fontSize:(CGFloat)fontSize
	{
	    //ç”»å¸ƒå¤§å°
	    CGSize size=CGSizeMake(self.size.width,self.size.height);
	    //åˆ›å»ºä¸€ä¸ªåŸºäºä½å›¾çš„ä¸Šä¸‹æ–‡
	    UIGraphicsBeginImageContextWithOptions(size,NO,0.0);//opaque:NO  scale:0.0
	
	    [self drawAtPoint:CGPointMake(0.0,0.0)];
	
	    //æ–‡å­—å±…ä¸­æ˜¾ç¤ºåœ¨ç”»å¸ƒä¸Š
	    NSMutableParagraphStyle* paragraphStyle = [[NSParagraphStyle defaultParagraphStyle] mutableCopy];
	    paragraphStyle.lineBreakMode = NSLineBreakByCharWrapping;
	    paragraphStyle.alignment=NSTextAlignmentCenter;//æ–‡å­—å±…ä¸­
	
	    //è®¡ç®—æ–‡å­—æ‰€å çš„size,æ–‡å­—å±…ä¸­æ˜¾ç¤ºåœ¨ç”»å¸ƒä¸Š
	    CGSize sizeText=[title boundingRectWithSize:self.size options:NSStringDrawingUsesLineFragmentOrigin
	                                     attributes:@{NSFontAttributeName:[UIFont systemFontOfSize:fontSize]}context:nil].size;
	    CGFloat width = self.size.width;
	    CGFloat height = self.size.height;
	
	    CGRect rect = CGRectMake((width-sizeText.width)/2, (height-sizeText.height)/2, sizeText.width, sizeText.height);
	    //ç»˜åˆ¶æ–‡å­—
	    [title drawInRect:rect withAttributes:@{ NSFontAttributeName:[UIFont systemFontOfSize:fontSize],NSForegroundColorAttributeName:[ UIColor whiteColor],NSParagraphStyleAttributeName:paragraphStyle}];
	
	    //è¿”å›ç»˜åˆ¶çš„æ–°å›¾å½¢
	    UIImage *newImage= UIGraphicsGetImageFromCurrentImageContext();
	    UIGraphicsEndImageContext();
	    return newImage;
	}

###æŸ¥æ‰¾ä¸€ä¸ªè§†å›¾çš„æ‰€æœ‰å­è§†å›¾

	
	- (NSMutableArray *)allSubViewsForView:(UIView *)view
	{
	    NSMutableArray *array = [NSMutableArray arrayWithCapacity:0];
	    for (UIView *subView in view.subviews)
	    {
	        [array addObject:subView];
	        if (subView.subviews.count > 0)
	        {
	            [array addObjectsFromArray:[self allSubViewsForView:subView]];
	        }
	    }
	    return array;
	}

###è®¡ç®—æ–‡ä»¶å¤§å°

	//æ–‡ä»¶å¤§å°
	- (long long)fileSizeAtPath:(NSString *)path
	{
	    NSFileManager *fileManager = [NSFileManager defaultManager];
	
	    if ([fileManager fileExistsAtPath:path])
	    {
	        long long size = [fileManager attributesOfItemAtPath:path error:nil].fileSize;
	        return size;
	    }
	
	    return 0;
	}
	
	//æ–‡ä»¶å¤¹å¤§å°
	- (long long)folderSizeAtPath:(NSString *)path
	{
	    NSFileManager *fileManager = [NSFileManager defaultManager];
	
	    long long folderSize = 0;
	
	    if ([fileManager fileExistsAtPath:path])
	    {
	        NSArray *childerFiles = [fileManager subpathsAtPath:path];
	        for (NSString *fileName in childerFiles)
	        {
	            NSString *fileAbsolutePath = [path stringByAppendingPathComponent:fileName];
	            if ([fileManager fileExistsAtPath:fileAbsolutePath])
	            {
	                long long size = [fileManager attributesOfItemAtPath:fileAbsolutePath error:nil].fileSize;
	                folderSize += size;
	            }
	        }
	    }
	
	    return folderSize;
	}

###UIViewè®¾ç½®éƒ¨åˆ†åœ†è§’

ä½ æ˜¯ä¸æ˜¯ä¹Ÿé‡åˆ°è¿‡è¿™æ ·çš„é—®é¢˜ï¼Œä¸€ä¸ªbuttonæˆ–è€…labelï¼Œåªè¦å³è¾¹çš„ä¸¤ä¸ªè§’åœ†è§’ï¼Œæˆ–è€…åªè¦ä¸€ä¸ªåœ†è§’ã€‚è¯¥æ€ä¹ˆåŠå‘¢ã€‚è¿™å°±éœ€è¦å›¾å±‚è’™ç‰ˆæ¥å¸®åŠ©æˆ‘ä»¬äº†

	
	CGRect rect = view.bounds;
	CGSize radio = CGSizeMake(30, 30);//åœ†è§’å°ºå¯¸
	UIRectCorner corner = UIRectCornerTopLeft|UIRectCornerTopRight;//è¿™åªåœ†è§’ä½ç½®
	UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:rect byRoundingCorners:corner cornerRadii:radio];
	CAShapeLayer *masklayer = [[CAShapeLayer alloc]init];//åˆ›å»ºshapelayer
	masklayer.frame = view.bounds;
	masklayer.path = path.CGPath;//è®¾ç½®è·¯å¾„
	view.layer.mask = masklayer;

###å–ä¸Šæ•´ä¸å–ä¸‹æ•´

	
	floor(x),æœ‰æ—¶å€™ä¹Ÿå†™åšFloor(x)ï¼Œå…¶åŠŸèƒ½æ˜¯â€œä¸‹å–æ•´â€ï¼Œå³å–ä¸å¤§äºxçš„æœ€å¤§æ•´æ•° ä¾‹å¦‚ï¼š
	x=3.14ï¼Œfloor(x)=3
	y=9.99999ï¼Œfloor(y)=9
	 
	ä¸floorå‡½æ•°å¯¹åº”çš„æ˜¯ceilå‡½æ•°ï¼Œå³ä¸Šå–æ•´å‡½æ•°ã€‚
	 
	ceilå‡½æ•°çš„ä½œç”¨æ˜¯æ±‚ä¸å°äºç»™å®šå®æ•°çš„æœ€å°æ•´æ•°ã€‚
	ceil(2)=ceil(1.2)=cei(1.5)=2.00
	 
	floorå‡½æ•°ä¸ceilå‡½æ•°çš„è¿”å›å€¼å‡ä¸ºdoubleå‹

###è®¡ç®—å­—ç¬¦ä¸²å­—ç¬¦é•¿åº¦ï¼Œä¸€ä¸ªæ±‰å­—ç®—ä¸¤ä¸ªå­—ç¬¦

	
	//æ–¹æ³•ä¸€ï¼š
	- (int)convertToInt:(NSString*)strtemp
	{
	    int strlength = 0;
	    char* p = (char*)[strtemp cStringUsingEncoding:NSUnicodeStringEncoding];
	    for (int i=0 ; i
	}

###ç»™UIViewè®¾ç½®å›¾ç‰‡

	UIImage *image = [UIImage imageNamed:@"image"];
	self.MYView.layer.contents = (__bridge id _Nullable)(image.CGImage);
	self.MYView.layer.contentsRect = CGRectMake(0, 0, 0.5, 0.5);

###é˜²æ­¢scrollViewæ‰‹åŠ¿è¦†ç›–ä¾§æ»‘æ‰‹åŠ¿
	
	[scrollView.panGestureRecognizerrequireGestureRecognizerToFail:self.navigationController.interactivePopGestureRecognizer];

###å»æ‰å¯¼èˆªæ è¿”å›çš„backæ ‡é¢˜

	[[UIBarButtonItemappearance]setBackButtonTitlePositionAdjustment:UIOffsetMake(0, -60)forBarMetrics:UIBarMetricsDefault];

###å­—ç¬¦ä¸²ä¸­æ˜¯å¦å«æœ‰ä¸­æ–‡

	
	+ (BOOL)checkIsChinese:(NSString *)string
	{
	    for (int i=0; i
	}


###dispatch_groupçš„ä½¿ç”¨

	
	 dispatch_group_t dispatchGroup = dispatch_group_create();
	    dispatch_group_enter(dispatchGroup);
	    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
	        NSLog(@"ç¬¬ä¸€ä¸ªè¯·æ±‚å®Œæˆ");
	        dispatch_group_leave(dispatchGroup);
	    });
	 
	    dispatch_group_enter(dispatchGroup);
	 
	    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(10 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
	        NSLog(@"ç¬¬äºŒä¸ªè¯·æ±‚å®Œæˆ");
	        dispatch_group_leave(dispatchGroup);
	    });
	 
	    dispatch_group_notify(dispatchGroup, dispatch_get_main_queue(), ^(){
	        NSLog(@"è¯·æ±‚å®Œæˆ");
	    });

###UITextFieldæ¯å››ä½åŠ ä¸€ä¸ªç©ºæ ¼,å®ç°ä»£ç†

	
	- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string
	{
	    // å››ä½åŠ ä¸€ä¸ªç©ºæ ¼
	    if ([string isEqualToString:@""])
	    {
	        // åˆ é™¤å­—ç¬¦
	        if ((textField.text.length - 2) % 5 == 0)
	        {
	            textField.text = [textField.text substringToIndex:textField.text.length - 1];
	        }
	        return YES;
	    }
	    else
	    {
	        if (textField.text.length % 5 == 0)
	        {
	            textField.text = [NSString stringWithFormat:@"%@ ", textField.text];
	        }
	    }
	    return YES;
	}

###è·å–ç§æœ‰å±æ€§å’Œæˆå‘˜å˜é‡ #import

	
	//è·å–ç§æœ‰å±æ€§ æ¯”å¦‚è®¾ç½®UIDatePickerçš„å­—ä½“é¢œè‰²
	- (void)setTextColor
	{
	    //è·å–æ‰€æœ‰çš„å±æ€§ï¼Œå»æŸ¥çœ‹æœ‰æ²¡æœ‰å¯¹åº”çš„å±æ€§
	    unsigned int count = 0;
	    objc_property_t *propertys = class_copyPropertyList([UIDatePicker class], &count);
	    for(int i = 0;i 
	
		
	//è·å¾—æˆå‘˜å˜é‡ æ¯”å¦‚ä¿®æ”¹UIAlertActionçš„æŒ‰é’®å­—ä½“é¢œè‰²
	    unsigned int count = 0;
	    Ivar *ivars = class_copyIvarList([UIAlertAction class], &count);
	    for(int i =0;i 

###è·å–æ‰‹æœºå®‰è£…çš„åº”ç”¨

	
	Class c =NSClassFromString(@"LSApplicationWorkspace");
	id s = [(id)c performSelector:NSSelectorFromString(@"defaultWorkspace")];
	NSArray *array = [s performSelector:NSSelectorFromString(@"allInstalledApplications")];
	for (id item in array)
	{
	    NSLog(@"%@",[item performSelector:NSSelectorFromString(@"applicationIdentifier")]);
	    //NSLog(@"%@",[item performSelector:NSSelectorFromString(@"bundleIdentifier")]);
	    NSLog(@"%@",[item performSelector:NSSelectorFromString(@"bundleVersion")]);
	    NSLog(@"%@",[item performSelector:NSSelectorFromString(@"shortVersionString")]);
	}

###åˆ¤æ–­ä¸¤ä¸ªæ—¥æœŸæ˜¯å¦åœ¨åŒä¸€å‘¨ å†™åœ¨NSDateçš„categoryé‡Œé¢

	- (BOOL)isSameDateWithDate:(NSDate *)date
	{
	    //æ—¥æœŸé—´éš”å¤§äºä¸ƒå¤©ä¹‹é—´è¿”å›NO
	    if (fabs([self timeIntervalSinceDate:date]) >= 7 * 24 *3600)
	    {
	        return NO;
	    }
	
	    NSCalendar *calender = [NSCalendar currentCalendar];
	    calender.firstWeekday = 2;//è®¾ç½®æ¯å‘¨ç¬¬ä¸€å¤©ä»å‘¨ä¸€å¼€å§‹
	    //è®¡ç®—ä¸¤ä¸ªæ—¥æœŸåˆ†åˆ«ä¸ºè¿™å¹´ç¬¬å‡ å‘¨
	    NSUInteger countSelf = [calender ordinalityOfUnit:NSCalendarUnitWeekday inUnit:NSCalendarUnitYear forDate:self];
	    NSUInteger countDate = [calender ordinalityOfUnit:NSCalendarUnitWeekday inUnit:NSCalendarUnitYear forDate:date];
	
	    //ç›¸ç­‰å°±åœ¨åŒä¸€å‘¨ï¼Œä¸ç›¸ç­‰å°±ä¸åœ¨åŒä¸€å‘¨
	    return countSelf == countDate;
	}

###åº”ç”¨å†…æ‰“å¼€ç³»ç»Ÿè®¾ç½®ç•Œé¢
	
	//iOS8ä¹‹å
	[[UIApplication sharedApplication] openURL:[NSURL URLWithString:UIApplicationOpenSettingsURLString]];
	//å¦‚æœAppæ²¡æœ‰æ·»åŠ æƒé™ï¼Œæ˜¾ç¤ºçš„æ˜¯è®¾å®šç•Œé¢ã€‚å¦‚æœAppæœ‰æ·»åŠ æƒé™ï¼ˆä¾‹å¦‚é€šçŸ¥ï¼‰ï¼Œæ˜¾ç¤ºçš„æ˜¯Appçš„è®¾å®šç•Œé¢ã€‚
	
	//iOS8ä¹‹å‰
	//å…ˆæ·»åŠ ä¸€ä¸ªurl typeå¦‚ä¸‹å›¾ï¼Œåœ¨ä»£ç ä¸­è°ƒç”¨å¦‚ä¸‹ä»£ç ,å³å¯è·³è½¬åˆ°è®¾ç½®é¡µé¢çš„å¯¹åº”é¡¹
	[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@"prefs:root=WIFI"]];

###å¯é€‰å€¼å¦‚ä¸‹ï¼š

	About â€” prefs:root=General&path=About
	Accessibility â€” prefs:root=General&path=ACCESSIBILITY
	Airplane Mode On â€” prefs:root=AIRPLANE_MODE
	Auto-Lock â€” prefs:root=General&path=AUTOLOCK
	Brightness â€” prefs:root=Brightness
	Bluetooth â€” prefs:root=General&path=Bluetooth
	Date & Time â€” prefs:root=General&path=DATE_AND_TIME
	FaceTime â€” prefs:root=FACETIME
	General â€” prefs:root=General
	Keyboard â€” prefs:root=General&path=Keyboard
	iCloud â€” prefs:root=CASTLE
	iCloud Storage & Backup â€” prefs:root=CASTLE&path=STORAGE_AND_BACKUP
	International â€” prefs:root=General&path=INTERNATIONAL
	Location Services â€” prefs:root=LOCATION_SERVICES
	Music â€” prefs:root=MUSIC
	Music Equalizer â€” prefs:root=MUSIC&path=EQ
	Music Volume Limit â€” prefs:root=MUSIC&path=VolumeLimit
	Network â€” prefs:root=General&path=Network
	Nike + iPod â€” prefs:root=NIKE_PLUS_IPOD
	Notes â€” prefs:root=NOTES
	Notification â€” prefs:root=NOTIFICATI*****_ID
	Phone â€” prefs:root=Phone
	Photos â€” prefs:root=Photos
	Profile â€” prefs:root=General&path=ManagedConfigurationList
	Reset â€” prefs:root=General&path=Reset
	Safari â€” prefs:root=Safari
	Siri â€” prefs:root=General&path=Assistant
	Sounds â€” prefs:root=Sounds
	Software Update â€” prefs:root=General&path=SOFTWARE_UPDATE_LINK
	Store â€” prefs:root=STORE
	Twitter â€” prefs:root=TWITTER
	Usage â€” prefs:root=General&path=USAGE
	VPN â€” prefs:root=General&path=Network/VPN
	Wallpaper â€” prefs:root=Wallpaper
	Wi-Fi â€” prefs:root=WIFI

###å±è”½è§¦å‘äº‹ä»¶ï¼Œ2ç§’åå–æ¶ˆå±è”½
	
	[[UIApplication sharedApplication] beginIgnoringInteractionEvents];
	dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
	    [[UIApplication sharedApplication] endIgnoringInteractionEvents]
	});

###åŠ¨ç”»æš‚åœå†å¼€å§‹

	
	-(void)pauseLayer:(CALayer *)layer
	{
	    CFTimeInterval pausedTime = [layer convertTime:CACurrentMediaTime() fromLayer:nil];
	    layer.speed = 0.0;
	    layer.timeOffset = pausedTime;
	}
	 
	-(void)resumeLayer:(CALayer *)layer
	{
	    CFTimeInterval pausedTime = [layer timeOffset];
	    layer.speed = 1.0;
	    layer.timeOffset = 0.0;
	    layer.beginTime = 0.0;
	    CFTimeInterval timeSincePause = [layer convertTime:CACurrentMediaTime() fromLayer:nil] - pausedTime;
	    layer.beginTime = timeSincePause;
	}

###iOSä¸­æ•°å­—çš„æ ¼å¼åŒ–
	
	//é€šè¿‡NSNumberFormatterï¼ŒåŒæ ·å¯ä»¥è®¾ç½®NSNumberè¾“å‡ºçš„æ ¼å¼ã€‚ä¾‹å¦‚å¦‚ä¸‹ä»£ç ï¼š
	NSNumberFormatter *formatter = [[NSNumberFormatter alloc] init];
	formatter.numberStyle = NSNumberFormatterDecimalStyle;
	NSString *string = [formatter stringFromNumber:[NSNumber numberWithInt:123456789]];
	NSLog(@"Formatted number string:%@",string);
	//è¾“å‡ºç»“æœä¸ºï¼š[1223:403] Formatted number string:123,456,789
	 
	//å…¶ä¸­NSNumberFormatterç±»æœ‰ä¸ªå±æ€§numberStyleï¼Œå®ƒæ˜¯ä¸€ä¸ªæšä¸¾å‹ï¼Œè®¾ç½®ä¸åŒçš„å€¼å¯ä»¥è¾“å‡ºä¸åŒçš„æ•°å­—æ ¼å¼ã€‚è¯¥æšä¸¾åŒ…æ‹¬ï¼š
	typedef NS_ENUM(NSUInteger, NSNumberFormatterStyle) {
	    NSNumberFormatterNoStyle = kCFNumberFormatterNoStyle,
	    NSNumberFormatterDecimalStyle = kCFNumberFormatterDecimalStyle,
	    NSNumberFormatterCurrencyStyle = kCFNumberFormatterCurrencyStyle,
	    NSNumberFormatterPercentStyle = kCFNumberFormatterPercentStyle,
	    NSNumberFormatterScientificStyle = kCFNumberFormatterScientificStyle,
	    NSNumberFormatterSpellOutStyle = kCFNumberFormatterSpellOutStyle
	};
	//å„ä¸ªæšä¸¾å¯¹åº”è¾“å‡ºæ•°å­—æ ¼å¼çš„æ•ˆæœå¦‚ä¸‹ï¼šå…¶ä¸­ç¬¬ä¸‰é¡¹å’Œæœ€åä¸€é¡¹çš„è¾“å‡ºä¼šæ ¹æ®ç³»ç»Ÿè®¾ç½®çš„è¯­è¨€åŒºåŸŸçš„ä¸åŒè€Œä¸åŒã€‚
	[1243:403] Formatted number string:123456789
	[1243:403] Formatted number string:123,456,789
	[1243:403] Formatted number string:ï¿¥123,456,789.00
	[1243:403] Formatted number string:-539,222,988%
	[1243:403] Formatted number string:1.23456789E8
	[1243:403] Formatted number string:ä¸€äº¿äºŒåƒä¸‰ç™¾å››åäº”ä¸‡å…­åƒä¸ƒç™¾å…«åä¹

###å¦‚ä½•è·å–WebViewæ‰€æœ‰çš„å›¾ç‰‡åœ°å€ï¼Œ

åœ¨ç½‘é¡µåŠ è½½å®Œæˆæ—¶ï¼Œé€šè¿‡jsè·å–å›¾ç‰‡å’Œæ·»åŠ ç‚¹å‡»çš„è¯†åˆ«æ–¹å¼

	
	//UIWebView
	- (void)webViewDidFinishLoad:(UIWebView *)webView
	{
	    //è¿™é‡Œæ˜¯jsï¼Œä¸»è¦ç›®çš„å®ç°å¯¹urlçš„è·å–
	    static  NSString * const jsGetImages =
	    @"function getImages(){\
	    var objs = document.getElementsByTagName(\"img\");\
	    var imgScr = '';\
	    for(var i=0;i
	
	}
		
	//WKWebView
	- (void)webView:(WKWebView *)webView didFinishNavigation:(null_unspecified WKNavigation *)navigation
	{
	    static  NSString * const jsGetImages =
	    @"function getImages(){\
	    var objs = document.getElementsByTagName(\"img\");\
	    var imgScr = '';\
	    for(var i=0;i

###è·å–åˆ°webviewçš„é«˜åº¦

	
	CGFloat height = [[self.webView stringByEvaluatingJavaScriptFromString:@"document.body.offsetHeight"] floatValue];

###navigationBarå˜ä¸ºçº¯é€æ˜

	
	//ç¬¬ä¸€ç§æ–¹æ³•
	//å¯¼èˆªæ çº¯é€æ˜
	[self.navigationBar setBackgroundImage:[UIImage new] forBarMetrics:UIBarMetricsDefault];
	//å»æ‰å¯¼èˆªæ åº•éƒ¨çš„é»‘çº¿
	self.navigationBar.shadowImage = [UIImage new];
	 
	//ç¬¬äºŒç§æ–¹æ³•
	[[self.navigationBar subviews] objectAtIndex:0].alpha = 0;

###tabBaråŒç†

	
	[self.tabBar setBackgroundImage:[UIImage new]];
	self.tabBar.shadowImage = [UIImage new];

###navigationBaræ ¹æ®æ»‘åŠ¨è·ç¦»çš„æ¸å˜è‰²å®ç°

	
	//ç¬¬ä¸€ç§
	- (void)scrollViewDidScroll:(UIScrollView *)scrollView
	{
	    CGFloat offsetToShow = 200.0;//æ»‘åŠ¨å¤šå°‘å°±å®Œå…¨æ˜¾ç¤º
	    CGFloat alpha = 1 - (offsetToShow - scrollView.contentOffset.y) / offsetToShow;
	    [[self.navigationController.navigationBar subviews] objectAtIndex:0].alpha = alpha;
	}
	
	//ç¬¬äºŒç§
	- (void)scrollViewDidScroll:(UIScrollView *)scrollView
	{
	    CGFloat offsetToShow = 200.0;
	    CGFloat alpha = 1 - (offsetToShow - scrollView.contentOffset.y) / offsetToShow;
	
	    [self.navigationController.navigationBar setShadowImage:[UIImage new]];
	    [self.navigationController.navigationBar setBackgroundImage:[self imageWithColor:[[UIColor orangeColor]colorWithAlphaComponent:alpha]] forBarMetrics:UIBarMetricsDefault];
	}
	
	//ç”Ÿæˆä¸€å¼ çº¯è‰²çš„å›¾ç‰‡
	- (UIImage *)imageWithColor:(UIColor *)color
	{
	    CGRect rect = CGRectMake(0.0f, 0.0f, 1.0f, 1.0f);
	    UIGraphicsBeginImageContext(rect.size);
	    CGContextRef context = UIGraphicsGetCurrentContext();
	    CGContextSetFillColorWithColor(context, [color CGColor]);
	    CGContextFillRect(context, rect);
	    UIImage *theImage = UIGraphicsGetImageFromCurrentImageContext();
	    UIGraphicsEndImageContext();
	
	    return theImage;
	}

###iOS å¼€å‘ä¸­ä¸€äº›ç›¸å…³çš„è·¯å¾„

	
	æ¨¡æ‹Ÿå™¨çš„ä½ç½®:
	/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs 
	 
	æ–‡æ¡£å®‰è£…ä½ç½®:
	/Applications/Xcode.app/Contents/Developer/Documentation/DocSets
	 
	æ’ä»¶ä¿å­˜è·¯å¾„:
	~/Library/ApplicationSupport/Developer/Shared/Xcode/Plug-ins
	 
	è‡ªå®šä¹‰ä»£ç æ®µçš„ä¿å­˜è·¯å¾„:
	~/Library/Developer/Xcode/UserData/CodeSnippets/ 
	å¦‚æœæ‰¾ä¸åˆ°CodeSnippetsæ–‡ä»¶å¤¹ï¼Œå¯ä»¥è‡ªå·±æ–°å»ºä¸€ä¸ªCodeSnippetsæ–‡ä»¶å¤¹ã€‚
	 
	æè¿°æ–‡ä»¶è·¯å¾„
	~/Library/MobileDevice/Provisioning Profiles

###navigationItemçš„BarButtonItemå¦‚ä½•ç´§é å±å¹•å³è¾¹ç•Œæˆ–è€…å·¦è¾¹ç•Œï¼Ÿ

ä¸€èˆ¬æƒ…å†µä¸‹ï¼Œå³è¾¹çš„itemä¼šå’Œå±å¹•å³ä¾§ä¿æŒä¸€æ®µè·ç¦»ï¼š
ä¸‹é¢æ˜¯é€šè¿‡æ·»åŠ ä¸€ä¸ªè´Ÿå€¼å®½åº¦çš„å›ºå®šé—´è·çš„itemæ¥è§£å†³ï¼Œä¹Ÿå¯ä»¥æ”¹å˜å®½åº¦å®ç°ä¸åŒçš„é—´éš”ï¼š
	
	UIImage *img = [[UIImage imageNamed:@"icon_cog"] imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal];
	//å®½åº¦ä¸ºè´Ÿæ•°çš„å›ºå®šé—´è·çš„ç³»ç»Ÿitem
	UIBarButtonItem *rightNegativeSpacer = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemFixedSpace target:nil action:nil];
	[rightNegativeSpacer setWidth:-15];
	 
	UIBarButtonItem *rightBtnItem1 = [[UIBarButtonItem alloc]initWithImage:img style:UIBarButtonItemStylePlain target:self action:@selector(rightButtonItemClicked:)];
	UIBarButtonItem *rightBtnItem2 = [[UIBarButtonItem alloc]initWithImage:img style:UIBarButtonItemStylePlain target:self action:@selector(rightButtonItemClicked:)];
	self.navigationItem.rightBarButtonItems = @[rightNegativeSpacer,rightBtnItem1,rightBtnItem2];

###NSStringè¿›è¡ŒURLç¼–ç å’Œè§£ç 

	
	NSString *string = @"http://abc.com?aaa=ä½ å¥½&bbb=tttee";
	 
	//ç¼–ç  æ‰“å°ï¼šhttp://abc.com?aaa=%E4%BD%A0%E5%A5%BD&bbb=tttee
	string = [string stringByAddingPercentEncodingWithAllowedCharacters:[NSCharacterSet URLQueryAllowedCharacterSet]];
	 
	//è§£ç  æ‰“å°ï¼šhttp://abc.com?aaa=ä½ å¥½&bbb=tttee
	string = [string stringByRemovingPercentEncoding];

###UIWebViewè®¾ç½®User-Agentã€‚

	
	//è®¾ç½®
	NSDictionary *dic = @{@"UserAgent":@"your UserAgent"};
	[[NSUserDefaults standardUserDefaults] registerDefaults:dic];
	//è·å–
	NSString *agent = [self.WebView stringByEvaluatingJavaScriptFromString:@"navigator.userAgent"];

###è·å–ç¡¬ç›˜æ€»å®¹é‡ä¸å¯ç”¨å®¹é‡:

	
	NSFileManager *fileManager = [NSFileManager defaultManager];
	NSDictionary *attributes = [fileManager attributesOfFileSystemForPath:NSHomeDirectory() error:nil];
	 
	NSLog(@"å®¹é‡%.2fG",[attributes[NSFileSystemSize] doubleValue] / (powf(1024, 3)));
	NSLog(@"å¯ç”¨%.2fG",[attributes[NSFileSystemFreeSize] doubleValue] / powf(1024, 3));

###è·å–UIColorçš„RGBAå€¼

	
	UIColor *color = [UIColor colorWithRed:0.2 green:0.3 blue:0.9 alpha:1.0];
	const CGFloat *components = CGColorGetComponents(color.CGColor);
	NSLog(@"Red: %.1f", components[0]);
	NSLog(@"Green: %.1f", components[1]);
	NSLog(@"Blue: %.1f", components[2]);
	NSLog(@"Alpha: %.1f", components[3]);

###ä¿®æ”¹textFieldçš„placeholderçš„å­—ä½“é¢œè‰²ã€å¤§å°

	
	[self.textField setValue:[UIColor redColor] forKeyPath:@"_placeholderLabel.textColor"];
	[self.textField setValue:[UIFont boldSystemFontOfSize:16] forKeyPath:@"_placeholderLabel.font"];

###AFNç§»é™¤JSONä¸­çš„NSNull

	AFJSONResponseSerializer *response = [AFJSONResponseSerializer serializer];
	response.removesKeysWithNullValues = YES;

###ceil()å’Œfloor()

	ceil()åŠŸ èƒ½ï¼šè¿”å›å¤§äºæˆ–è€…ç­‰äºæŒ‡å®šè¡¨è¾¾å¼çš„æœ€å°æ•´æ•°
	floor()åŠŸ èƒ½ï¼šè¿”å›å°äºæˆ–è€…ç­‰äºæŒ‡å®šè¡¨è¾¾å¼çš„æœ€å¤§æ•´æ•°
	UIWebViewé‡Œé¢çš„å›¾ç‰‡è‡ªé€‚åº”å±å¹•

###åœ¨webViewåŠ è½½å®Œçš„ä»£ç†æ–¹æ³•é‡Œé¢è¿™æ ·å†™ï¼š

	
	- (void)webViewDidFinishLoad:(UIWebView *)webView
	{
	    NSString *js = @"function imgAutoFit() { \
	    var imgs = document.getElementsByTagName('img'); \
	    for (var i = 0; i < imgs.length; ++i) { \
	    var img = imgs[i]; \
	    img.style.maxWidth = %f; \
	    } \
	    }";
	 
	    js = [NSString stringWithFormat:js, [UIScreen mainScreen].bounds.size.width - 20];
	 
	    [webView stringByEvaluatingJavaScriptFromString:js];
	    [webView stringByEvaluatingJavaScriptFromString:@"imgAutoFit()"];
	}


###NSDateFormatæœ€ä½³æ–¹å¼ï¼ˆstrptimeï¼‰

	+ (NSDate *)dateFromISO8601StringDateFormatter:(NSString *)string locale:(NSLocale *)locale{
	    if (!string) {
	        return nil;
	    }
	
	    struct tm tm;
	    time_t t;
	
	    strptime([string cStringUsingEncoding:NSUTF8StringEncoding], "%Y-%m-%d %H:%M:%S", &tm);
	    tm.tm_isdst = -1;
	    t = mktime(&tm);
	
	    return [NSDate dateWithTimeIntervalSince1970:t + [[NSTimeZone localTimeZone] secondsFromGMT]];
	}
	
	- (NSString *)ISO8601String:(NSDate*)date {
	    struct tm *timeinfo;
	    char buffer[80];
	
	    time_t rawtime = [date timeIntervalSince1970] - [[NSTimeZone localTimeZone] secondsFromGMT];
	    timeinfo = localtime(&rawtime);
	
	    strftime(buffer, 80, "%Y-%m-%d %H:%M:%S", timeinfo);
	
	    return [NSString stringWithCString:buffer encoding:NSUTF8StringEncoding];
	}

###æ¯›ç»ç’ƒ


    //åˆ›å»º
    UIImageView *imageView = [[UIImageView alloc]initWithFrame:self.view.bounds];
    //å›¾ç‰‡
    imageView.image = [UIImage imageNamed:@"1.jpeg"];
    //èƒŒæ™¯é¢œè‰²
    imageView.backgroundColor = [UIColor yellowColor];
    //è®¾ç½®å›¾ç‰‡å†…å®¹æ¨¡å¼
    imageView.contentMode = UIViewContentModeScaleAspectFill;
    
    [self.view addSubview:imageView];
    
    //æ¯›ç»ç’ƒ
    UIToolbar *toolbar = [[UIToolbar alloc]initWithFrame:imageView.bounds];
    //æ ·å¼
    toolbar.barStyle = UIBarStyleDefault;
    //é€æ˜åº¦
    toolbar.alpha = 0.8f;
    [imageView addSubview:toolbar];

###tableviewä¸‹æ‹‰åˆ·æ–°åœç•™ï¼ˆä¸æ»šåˆ°é¡¶éƒ¨ï¼‰ï¼Œ ç±»ä¼¼QQï¼Œå¾®ä¿¡æ‹‰å»å†å²æ¶ˆæ¯
 
 å…³äºTableViewä»£ç†æ–¹æ³•å’Œå…¶ä»–ä¸€äº›æ•°æ®ä¸é€»è¾‘å¤„ç†å’Œå¹³æ—¶ä¸€æ ·ï¼Œåªæ˜¯åœ¨ä¸‹å•¦çš„æ—¶å€™å•¦åˆ°çš„æ•°æ®ï¼Œæ”¾åˆ°æœ€å‰é¢ï¼ŒåŒäº‹æ§åˆ¶TableViewçš„åç§»ã€‚
 
 
    self.oldSize = self.tableView.contentSize;
    self.oldPoint = self.tableView.contentOffset;
    
    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
        
        //                if (self.isfirst) {
        for (int i = 0; i < 15; i++) {
            [self.dataArray insertObject:[NSString stringWithFormat:@"æ–°å¢åŠ ä¿¡æ¯%d",i] atIndex:0];
        }
        
        //            }
        //            self.isfirst = YES;
        // åˆ·æ–°è¡¨æ ¼
        [self.tableView reloadData];
        
        // (æœ€å¥½åœ¨åˆ·æ–°è¡¨æ ¼åè°ƒç”¨)è°ƒç”¨endRefreshingå¯ä»¥ç»“æŸåˆ·æ–°çŠ¶æ€
        [self.tableView EndRefreshing];
        
        CGSize newSize = self.tableView.contentSize;
        
        
        CGPoint newPoint = CGPointMake(0, self.oldPoint.y+newSize.height - self.oldSize.height);
        self.tableView.contentOffset = newPoint;
    });
    
    
###KeyChainéšç§ä¿¡æ¯å­˜å‚¨ï¼ˆä¸»è¦æ˜¯å¯†ç ç±»ï¼‰
	 
é›†æˆNSObject
	 
	 -(NSMutableDictionary *)getKeychainQuery:(NSString *)service
	{
	    return [NSMutableDictionary dictionaryWithObjectsAndKeys:
	            (__bridge_transfer id)kSecClassGenericPassword,(__bridge_transfer id)kSecClass,
	            service, (__bridge_transfer id)kSecAttrService,
	            service, (__bridge_transfer id)kSecAttrAccount,
	            (__bridge_transfer id)kSecAttrAccessibleAfterFirstUnlock,(__bridge_transfer id)kSecAttrAccessible,
	            nil];
	}
	 
	+ (void)saveKeychainValue:(NSString *)sValue Key:(NSString *)sKey
	{
	    //Get search dictionary
	    NSMutableDictionary *keychainQuery = [self getKeychainQuery:sKey];
	    //Delete old item before add new item
	    SecItemDelete((__bridge_retained CFDictionaryRef)keychainQuery);
	    //Add new object to search dictionary(Attention:the data format)
	    [keychainQuery setObject:[NSKeyedArchiver archivedDataWithRootObject:sValue] forKey:(__bridge_transfer id)kSecValueData];
	    //Add item to keychain with the search dictionary
	    SecItemAdd((__bridge_retained CFDictionaryRef)keychainQuery, NULL);
	}
	 
	+ (NSString *)readKeychainValue:(NSString *)sKey
	{
	    NSString *ret = nil;
	    NSMutableDictionary *keychainQuery = [self getKeychainQuery:sKey];
	 
	    //Configure the search setting
	    [keychainQuery setObject:(id)kCFBooleanTrue forKey:(__bridge_transfer id)kSecReturnData];
	    [keychainQuery setObject:(__bridge_transfer id)kSecMatchLimitOne forKey:(__bridge_transfer id)kSecMatchLimit];
	    CFDataRef keyData = NULL;
	    if (SecItemCopyMatching((__bridge_retained CFDictionaryRef)keychainQuery, (CFTypeRef *)&keyData) == noErr) {
	    <a href="http://www.jobbole.com/members/xyz937134366">@try</a> {
	        ret = (NSString *)[NSKeyedUnarchiver unarchiveObjectWithData:(__bridge_transfer NSData *)keyData];
	        } <a href="http://www.jobbole.com/members/wx895846013">@catch</a> (NSException *e) {
	            NSLog(@"Unarchive of %@ failed: %@", sKey, e);
	        } <a href="http://www.jobbole.com/members/finally">@finally</a> {
	        }
	    }
	    return ret;
	}
	 
	+ (void)deleteKeychainValue:(NSString *)sKey {
	    NSMutableDictionary *keychainQuery = [self getKeychainQuery:sKey];
	    SecItemDelete((__bridge_retained CFDictionaryRef)keychainQuery);
	}

###è‡ªå®šä¹‰åœ†è§’è£å‰ªï¼šææ€§èƒ½




	// ------------------------------------------------------------------
	// --------------------- ä»¥ä¸‹æ˜¯è‡ªå®šä¹‰å›¾åƒå¤„ç†éƒ¨åˆ† -----------------------
	// ------------------------------------------------------------------
	
	// è‡ªå®šä¹‰è£å‰ªç®—æ³•
	- (UIImage *)dealImage:(UIImage *)img cornerRadius:(CGFloat)c {
	    // 1.CGDataProviderRef æŠŠ CGImage è½¬ äºŒè¿›åˆ¶æµ
	    CGDataProviderRef provider = CGImageGetDataProvider(img.CGImage);
	    void *imgData = (void *)CFDataGetBytePtr(CGDataProviderCopyData(provider));
	    int width = img.size.width * img.scale;
	    int height = img.size.height * img.scale;
	    
	    // 2.å¤„ç† imgData
	//    dealImage(imgData, width, height);
	    cornerImage(imgData, width, height, c);
	    
	    // 3.CGDataProviderRef æŠŠ äºŒè¿›åˆ¶æµ è½¬ CGImage
	    CGDataProviderRef pv = CGDataProviderCreateWithData(NULL, imgData, width * height * 4, releaseData);
	    CGImageRef content = CGImageCreate(width , height, 8, 32, 4 * width, CGColorSpaceCreateDeviceRGB(), kCGBitmapByteOrder32Big | kCGImageAlphaPremultipliedLast, pv, NULL, true, kCGRenderingIntentDefault);
	    UIImage *result = [UIImage imageWithCGImage:content];
	    CGDataProviderRelease(pv);      // é‡Šæ”¾ç©ºé—´
	    CGImageRelease(content);
	    
	    return result;
	}
	
	void releaseData(void *info, const void *data, size_t size) {
	    free((void *)data);
	}
	
	// åœ¨ img ä¸Šå¤„ç†å›¾ç‰‡, æµ‹è¯•ç”¨
	void dealImage(UInt32 *img, int w, int h) {
	    int num = w * h;
	    UInt32 *cur = img;
	    for (int i=0; i<num; i++, cur++) {
	        UInt8 *p = (UInt8 *)cur;
	        // RGBA æ’åˆ—
	        // f(x) = 255 - g(x) æ±‚è´Ÿç‰‡
	        p[0] = 255 - p[0];
	        p[1] = 255 - p[1];
	        p[2] = 255 - p[2];
	        p[3] = 255;
	    }
	}
	
	// è£å‰ªåœ†è§’
	void cornerImage(UInt32 *const img, int w, int h, CGFloat cornerRadius) {
	    CGFloat c = cornerRadius;
	    CGFloat min = w > h ? h : w;
	    
	    if (c < 0) { c = 0; }
	    if (c > min * 0.5) { c = min * 0.5; }
	    
	    // å·¦ä¸Š y:[0, c), x:[x, c-y)
	    for (int y=0; y<c; y++) {
	        for (int x=0; x<c-y; x++) {
	            UInt32 *p = img + y * w + x;    // p 32ä½æŒ‡é’ˆï¼ŒRGBAæ’åˆ—ï¼Œå„8ä½
	            if (isCircle(c, c, c, x, y) == false) {
	                *p = 0;
	            }
	        }
	    }
	    // å³ä¸Š y:[0, c), x:[w-c+y, w)
	    int tmp = w-c;
	    for (int y=0; y<c; y++) {
	        for (int x=tmp+y; x<w; x++) {
	            UInt32 *p = img + y * w + x;
	            if (isCircle(w-c, c, c, x, y) == false) {
	                *p = 0;
	            }
	        }
	    }
	    // å·¦ä¸‹ y:[h-c, h), x:[0, y-h+c)
	    tmp = h-c;
	    for (int y=h-c; y<h; y++) {
	        for (int x=0; x<y-tmp; x++) {
	            UInt32 *p = img + y * w + x;
	            if (isCircle(c, h-c, c, x, y) == false) {
	                *p = 0;
	            }
	        }
	    }
	    // å³ä¸‹ y~[h-c, h), x~[w-c+h-y, w)
	    tmp = w-c+h;
	    for (int y=h-c; y<h; y++) {
	        for (int x=tmp-y; x<w; x++) {
	            UInt32 *p = img + y * w + x;
	            if (isCircle(w-c, h-c, c, x, y) == false) {
	                *p = 0;
	            }
	        }
	    }
	}
	
	// åˆ¤æ–­ç‚¹ (px, py) åœ¨ä¸åœ¨åœ†å¿ƒ (cx, cy) åŠå¾„ r çš„åœ†å†…
	static inline bool isCircle(float cx, float cy, float r, float px, float py) {
	    if ((px-cx) * (px-cx) + (py-cy) * (py-cy) > r * r) {
	        return false;
	    }
	    return true;
	}
	
	// å…¶ä»–å›¾åƒæ•ˆæœå¯ä»¥è‡ªå·±å†™å‡½æ•°ï¼Œç„¶ååœ¨ dealImage: ä¸­è°ƒç”¨ otherImage å³å¯
	void otherImage(UInt32 *const img, int w, int h) {
	    // è‡ªå®šä¹‰å¤„ç†
	}



###éšè—tabbarä¸Šé¢çš„è™šçº¿
	
	//éšè—é˜´å½±çº¿
	[[UITabBar appearance] setShadowImage:[UIImage new]];
	- (void)setupTabBarBackgroundImage {
	    UIImage *image = [UIImage imageNamed:@"tab_bg"];
	    CGFloat top = 40; // é¡¶ç«¯ç›–é«˜åº¦
	    CGFloat bottom = 40 ; // åº•ç«¯ç›–é«˜åº¦
	    CGFloat left = 100; // å·¦ç«¯ç›–å®½åº¦
	    CGFloat right = 100; // å³ç«¯ç›–å®½åº¦
	    UIEdgeInsets insets = UIEdgeInsetsMake(top, left, bottom, right);
	    // æŒ‡å®šä¸ºæ‹‰ä¼¸æ¨¡å¼ï¼Œä¼¸ç¼©åé‡æ–°èµ‹å€¼
	    UIImage *TabBgImage = [image resizableImageWithCapInsets:insets resizingMode:UIImageResizingModeStretch];
	    self.tabBar.backgroundImage = TabBgImage;
	    [[UITabBar appearance] setShadowImage:[UIImage new]];
	    [[UITabBar appearance] setBackgroundImage:[[UIImage alloc]init]];
	}
	//è‡ªå®šä¹‰TabBaré«˜åº¦
	- (void)viewWillLayoutSubviews {
	    CGRect tabFrame = self.tabBar.frame;
	    tabFrame.size.height = 60;
	    tabFrame.origin.y = self.view.frame.size.height - 60;
	    self.tabBar.frame = tabFrame;
	}
	
	
###éšè—å¯¼èˆªæ ä¸‹é¢çš„è™šçº¿

#######æ–¹æ³•ä¸€ï¼Œä¸–ç•Œä½¿ç”¨èƒŒæ™¯å›¾ç‰‡ä¸é˜´å½±

	- (void)viewWillAppear:(BOOL)animated{
	
	    
	
	    // Called when the view is about to made visible. Default does nothing    
	
	    [super viewWillAppear:animated];
	
	  
	
	    //å»é™¤å¯¼èˆªæ ä¸‹æ–¹çš„æ¨ªçº¿
	
	    [navigationBar setBackgroundImage:[UIImage imageWithColor:[self colorFromHexRGB:@"33cccc"]]
	
	                       forBarPosition:UIBarPositionAny
	
	                           barMetrics:UIBarMetricsDefault];
	
	    [navigationBar setShadowImage:[UIImage new]];
	
	    
	
	}
	
	
è¿™æ˜¯å”¯ä¸€ä¸€ä¸ªéšè—è¿™æ¡çº¿çš„å®˜æ–¹ç”¨æ³•ï¼Œä½†æ˜¯æœ‰ä¸€ä¸ªç¼ºé™·-åˆ é™¤äº†translucency(åŠé€æ˜)


#######æ–¹æ³•äºŒï¼š

1ï¼‰å£°æ˜UIImageViewå˜é‡,å­˜å‚¨åº•éƒ¨æ¨ªçº¿

	@interface MyViewController {
	    UIImageView *navBarHairlineImageView;
	}
 
2ï¼‰åœ¨viewDidLoadä¸­åŠ å…¥ï¼š

	navBarHairlineImageView = [self findHairlineImageViewUnder:self.navigationController.navigationBar];


3ï¼‰å®ç°æ‰¾å‡ºåº•éƒ¨æ¨ªçº¿çš„å‡½æ•°

	- (UIImageView *)findHairlineImageViewUnder:(UIView *)view {
	    if ([view isKindOfClass:UIImageView.class] && view.bounds.size.height <= 1.0) {
	            return (UIImageView *)view;
	    }
	    for (UIView *subview in view.subviews) {
	        UIImageView *imageView = [self findHairlineImageViewUnder:subview];
	        if (imageView) {
	            return imageView;
	        }
	    }
	    return nil;
	}
 
4ï¼‰æœ€ååœ¨viewWillAppearï¼ŒviewWillDisappearä¸­å¤„ç†

	- (void)viewWillAppear:(BOOL)animated {
	    [super viewWillAppear:animated];
	    navBarHairlineImageView.hidden = YES;
	}
	
	- (void)viewWillDisappear:(BOOL)animated {
	    [super viewWillDisappear:animated];
	    navBarHairlineImageView.hidden = NO;
	}
 ###ä¸¤ä¸ªèŒƒå›´çš„å¯Œæ–‡æœ¬

    NSString *times = [NSString stringWithFormat:@"å“‡å¡ï¼æœ¬æ¬¡è§†é¢‘èŠå¤©%@", [info objectStringForKey:@"times"]];
    NSString *type = [NSString stringWithFormat:@"%@", [info objectStringForKey:@"type"]];
    NSString *counts = nil;
    if ([type isEqualToString:@"1"]) {
        counts = [NSString stringWithFormat:@"æ¶ˆè€—%@èƒ½é‡", [info objectStringForKey:@"counts"]];
    } else {
        counts = [NSString stringWithFormat:@"èµšäº†%@ç§¯åˆ†", [info objectStringForKey:@"counts"]];
    }
    
    NSString *formatString = [NSString stringWithFormat:@"%@,%@", times, counts];
    NSMutableAttributedString *AttributedStr = [[NSMutableAttributedString alloc]initWithString:formatString];
    NSRange range = [formatString rangeOfString:@","];
    [AttributedStr addAttribute:NSForegroundColorAttributeName value:[UIColor colorWithHexString:@"#fb455a"] range:NSMakeRange(9, range.location - 9)];
    [AttributedStr addAttribute:NSForegroundColorAttributeName value:[UIColor colorWithHexString:@"#fb455a"] range:NSMakeRange(range.location + 3, formatString.length - range.location - 5)];
    

###ä¿®æ”¹UIAlertController


    // åœ¨ viewDidLoad ä¸­åˆ›å»º
    UIAlertController *alertVC = [UIAlertController alertControllerWithTitle:nil message:AttributedStr.string preferredStyle:UIAlertControllerStyleAlert];
    // ç”¨ KVC ä¿®æ”¹å…¶ æ²¡æœ‰æš´éœ²å‡ºæ¥çš„
//    [alertVC setValue:AttributedTit forKey:@"attributedTitle"];
    [alertVC setValue:AttributedStr forKey:@"attributedMessage"];
    
    //ä¿®æ”¹æŒ‰é’®çš„é¢œè‰²ï¼ŒåŒä¸Šå¯ä»¥ä½¿ç”¨åŒæ ·çš„æ–¹æ³•ä¿®æ”¹å†…å®¹ï¼Œæ ·å¼
    UIAlertAction *defaultAction = [UIAlertAction actionWithTitle:@"ç¡®å®š" style:UIAlertActionStyleDefault handler:nil];
    [defaultAction setValue:[UIColor blackColor] forKey:@"_titleTextColor"];
    [alertVC addAction:defaultAction];
    
    [self presentViewController:alertVC animated:YES completion:nil];
    

ä¸Šé¢ä½¿ç”¨äº†ä¸€ç§ä¸ªäººæ¯”è¾ƒå–œæ¬¢çš„æ–¹æ³•ï¼Œ

> æ€»ä½“æ¥è¯´ï¼Œç¬¬äºŒç§åŠæ³•è¿˜æ˜¯å¾ˆå¥½åœ°ï¼Œå»ºè®®å¤§å®¶ä½¿ç”¨ç¬¬äºŒç§åŠæ³•ã€‚
 




===
===


######å¾®ä¿¡å·ï¼š
	
clpaial10201119ï¼ˆQ Qï¼š2211523682ï¼‰
    
######å¾®åšWB:

[http://weibo.com/u/3288975567?is_hot=1](http://weibo.com/u/3288975567?is_hot=1)

######gitHubï¼š


[https://github.com/al1020119](https://github.com/al1020119)
	
######åšå®¢

[http://al1020119.github.io/](http://al1020119.github.io/)

===

{% img /images/iCocosCoder.jpg Caption %}  

{% img /images/iCocosPublic.jpg Caption %}  