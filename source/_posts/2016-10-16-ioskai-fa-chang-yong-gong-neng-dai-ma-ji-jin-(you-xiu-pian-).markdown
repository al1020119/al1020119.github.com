---
layout: post
title: "iOSå¼€å‘â€”â€”å¸¸ç”¨åŠŸèƒ½ä»£ç é›†é”¦ï¼ˆå‹ç§€ç¯‡ï¼‰"
date: 2016-10-16 12:47:16 +0800
comments: true
categories: 
---


æœ¬æ¬¡æ€»ç»“ï¼Œæ˜¯å› ä¸ºä¸€æ¬¡ä¸Šçº¿Appè¢«æ‹’ä¹‹åçš„å†²åŠ¨ï¼Œå› ä¸ºæœ‰ä¸€ä¸ªåŠŸèƒ½ä»£ç è‡ªå·±ä¹‹å‰ç»å¸¸å†™ï¼Œä½†æ˜¯å†™å¤šäº†å°±å¿«ï¼Œæå¾—æ‰‹é€Ÿç»ƒå¾—è¶…å¿«ï¼ˆä¸è¦æƒ³æ±¡å’¯å“¦ğŸ˜‚ï¼‰ï¼Œæ‰€ä»¥å†™çš„æ—¶å€™å°±æ²¡æœ‰å¤šæƒ³ï¼Œä¹Ÿæ²¡æœ‰æ‰¾æ‰¾ä¹‹å‰çš„ä»£ç ï¼Œç»“æœå¯¼è‡´æ‚²å‚¬çš„ç»“å±€ã€‚

ä¹‹å‰æ²¡æœ‰æ•´ç†è¿‡é¡¹ç›®ä¸­é‡åˆ°æˆ–è€…å†™è¿‡ï¼Œæˆ–è€…ç»å¸¸è¦ç”¨çš„ä»£ç ï¼Œå¯èƒ½è§‰å¾—å¤šå†™å‡ éå°±æ²¡äº‹äº†ï¼Œæˆ–è€…ç½‘ä¸Šä¸€æ‰¾å°±æœ‰äº†ã€‚å¯æ˜¯äº‹å®å¹¶éå¦‚æœï¼Œé¦–å…ˆï¼Œç½‘ä¸Šæ‰¾çš„æ°¸è¿œä¸æ˜¯ä½ çš„ã€‚å…¶æ¬¡ï¼Œå†™å¾—å†å¤šè¿˜æ˜¯æœ‰ç²—å¿ƒæˆ–è€…æ³¨æ„ä¸åˆ°çš„åœ°æ–¹ã€‚æœ€åï¼Œæ•´ç†æˆè‡ªå·±çš„èƒ½æœ€å¿«é€Ÿåº¦çš„æ‰¾åˆ°å¹¶å®ç°ï¼Œæé«˜æ•ˆç‡ã€‚ä½•ä¹è€Œä¸ä¸ºå‘¢ï¼Ÿ

å¥½äº†ï¼ŒåºŸè¯ä¸å¤šè¯´ï¼Œç†è®ºä¹Ÿæ²¡æœ‰ï¼Œå¤§éƒ¨åˆ†åªè¦ä¸¤ä¸ªæ“ä½œï¼šcopy-pasteã€‚æœ‰äº›è¿˜æ˜¯éœ€è¦åšå°å°çš„æ”¹åŠ¨çš„ï¼Œæ ¹æ®é¡¹ç›®éœ€æ±‚ã€‚


<!--more-->



1. å–æ¶ˆtableViewå¤´éƒ¨å’Œåº•éƒ¨æ‚¬æµ®æ•ˆæœ
2. è·å–éšæœºæ•°
3. å»é™¤tableViewåˆ†ç»„å¤´éƒ¨å¤šä½™é—´è·
4. å›¾ç‰‡æˆªå–
5. æ¨¡ç³Šå›¾ç‰‡
6. è·å–æ–‡ä»¶å¤§å°
7. æ‰‹æœºå·éªŒè¯
8. é‚®ç®±éªŒè¯
9. ç½‘å€éªŒè¯
10. JSONè½¬å­—å…¸
11. iPhoneè®¾å¤‡ç±»å‹åˆ¤æ–­
12. iPhoneç³»ç»Ÿç‰ˆæœ¬åˆ¤æ–­
13. æ—¥å¿—æ‰“å°
14. é¢œè‰²è·å–
15. å¼±å¼•ç”¨
16. è·å–å±å¹•å°ºå¯¸
17. è·å–viewçš„æ§åˆ¶
18. å­—å…¸é˜²å´©æºƒ
19. æ•°ç»„é˜²å´©æºƒ
20. æœ¬æ–‡è¾“å…¥é”™è¯¯æç¤º
21. è·å–å½“å‰æ—¶é—´
22. è·å–å½“å‰ç‰ˆæœ¬
23. tabBarçº¢ç‚¹æ˜¾ç¤º
24. Logæ—¥å¿—.m
25. MD5åŠ å¯†
26. æŒ‰é’®èƒŒæ™¯é¢œè‰²
27. åˆ¤æ–­å¯¹è±¡æ˜¯å¦ä¸ºç©º
28. é”®ç›˜é€€å‡ºä¸éšè—é€šçŸ¥
29. è·å–è®¾å¤‡å”¯ä¸€ID
30. MOVè½¬Mp4
31. ä¸Šä¼ å›¾ç‰‡
32. ä¸Šä¼ è§†é¢‘
33. è·å–è§†é¢‘å¸§å›¾
34. å‹ç¼©å¹¶å¯¼å‡ºè§†é¢‘
35. ä¿å­˜è§†é¢‘åˆ°ç›¸å†Œ
36. è·å–å½“å‰æœ€é¡¶å±‚çš„ViewController
37. æ•°ç»„æ‹†åˆ†
38. å›¾ç‰‡å‹ç¼©

<!--more-->

##1ï¼šå–æ¶ˆtableViewå¤´éƒ¨å’Œåº•éƒ¨æ‚¬æµ®æ•ˆæœ

    - (void)scrollViewDidScroll:(UIScrollView *)scrollView {  
        CGFloat sectionHeaderHeight = 10; //è¿™é‡Œæ˜¯æˆ‘çš„headerViewå’ŒfooterViewçš„é«˜åº¦  
        if (_tableView.contentOffset.y<=sectionHeaderHeight&&_tableView.contentOffset.y>=0) {  
            _tableView.contentInset = UIEdgeInsetsMake(-_tableView.contentOffset.y, 0, 0, 0);  
        } else if (_tableView.contentOffset.y>=sectionHeaderHeight) {  
            _tableView.contentInset = UIEdgeInsetsMake(-sectionHeaderHeight, 0, 0, 0);  
        }  
    }  
    
    
	    -(void)scrollViewDidScroll:(UIScrollView *)scrollView {
	
	    if (scrollView == self.tableView)
	
	        {
	
	        UITableView *tableview = (UITableView *)scrollView;
	
	        CGFloat sectionHeaderHeight = 64;
	
	        CGFloat sectionFooterHeight = 120;
	
	        CGFloat offsetY = tableview.contentOffset.y;
	
	        if (offsetY >= 0 && offsetY <= sectionHeaderHeight)
	
	        {
	
	            tableview.contentInset = UIEdgeInsetsMake(-offsetY, 0, -sectionFooterHeight, 0);
	
	        }else if (offsetY >= sectionHeaderHeight && offsetY <= tableview.contentSize.height - tableview.frame.size.height - sectionFooterHeight)
	
	        {
	
	            tableview.contentInset = UIEdgeInsetsMake(-sectionHeaderHeight, 0, -sectionFooterHeight, 0);
	
	        }else if (offsetY >= tableview.contentSize.height - tableview.frame.size.height - sectionFooterHeight && offsetY <= tableview.contentSize.height - tableview.frame.size.height)         {
	
	            tableview.contentInset = UIEdgeInsetsMake(-offsetY, 0, -(tableview.contentSize.height - tableview.frame.size.height - sectionFooterHeight), 0);
	
	        }
	
	    }
	
	}
##2ï¼šè·å–éšæœºæ•°

	//ç¬¬ä¸€ç§
	srand((unsigned)time(0)); //ä¸åŠ è¿™å¥æ¯æ¬¡äº§ç”Ÿçš„éšæœºæ•°ä¸å˜
	int i = rand() % 5;
	//ç¬¬äºŒç§
	srandom(time(0));
	int i = random() % 5;
	//ç¬¬ä¸‰ç§
	int i = arc4random() % 5 ; 

##3ï¼šå»é™¤tableViewåˆ†ç»„å¤´éƒ¨å¤šä½™é—´è·

####ä¸€ï¼š

	- (void)viewDidLoad {
	    [super viewDidLoad];
	    
	    self.tableView.tableHeaderView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 0, CGFLOAT_MIN)];
	}

####äºŒï¼š

	- (void)viewWillAppear:(BOOL)animated{
	    
	    [super viewWillAppear:animated];
	    
	    CGRect frameH = self.tableView.tableHeaderView.frame;
	    frameH.size.height = 5;
	    UIView *headerView = [[UIView alloc] initWithFrame:frameH];
	    [self.tableView setTableHeaderView:headerView];
	    
	    
	    CGRect frameF = self.tableView.tableHeaderView.frame;
	    frameF.size.height = 1;
	    UIView *footerView = [[UIView alloc] initWithFrame:frameF];
	    [self.tableView setTableFooterView:footerView];
	    
	}

##4ï¼šå›¾ç‰‡æˆªå–

    CGSize itemSize = CGSizeMake(self.image.size.width, self.image.size.height);
    
    dispatch_async(dispatch_get_global_queue(0, 0), ^{
        
        UIImage *dynamicCellImage = [UIImage imageWithData:[NSData dataWithContentsOfURL:[NSURL URLWithString:model.cover]]];
                UIGraphicsBeginImageContextWithOptions(itemSize, NO, [UIScreen mainScreen].scale);
                
                //å‹ç¼©å›¾ç‰‡
                CGSize newSize;
                CGImageRef imageRef = nil;
                
                if ((dynamicCellImage.size.width / dynamicCellImage.size.height) < (self.image.size.width / self.image.size.height)) {
                    newSize.width = dynamicCellImage.size.width;
                    newSize.height = dynamicCellImage.size.width * self.image.size.height / self.image.size.width;
                    
                    imageRef = CGImageCreateWithImageInRect([dynamicCellImage CGImage], CGRectMake(0, fabs(dynamicCellImage.size.height - newSize.height) / 2, newSize.width, newSize.height));
                    
                } else {
                    newSize.height = dynamicCellImage.size.height;
                    newSize.width = dynamicCellImage.size.height * self.image.size.width / self.image.size.height;
                    
                    imageRef = CGImageCreateWithImageInRect([dynamicCellImage CGImage], CGRectMake(fabs(dynamicCellImage.size.width - newSize.width) / 2, 0, newSize.width, newSize.height));
                }
                
                dispatch_async(dispatch_get_main_queue(), ^{
                    self.image.image = [UIImage imageWithCGImage:imageRef];
                });
                
                UIGraphicsEndImageContext();

    });
    
    
##5ï¼šæ¨¡ç³Šå›¾ç‰‡

	//åŠ æ¨¡ç³Šæ•ˆæœï¼Œimageæ˜¯å›¾ç‰‡ï¼Œbluræ˜¯æ¨¡ç³Šåº¦
	+ (UIImage *)blurryImage:(UIImage *)image withBlurLevel:(CGFloat)blur {
	    //æ¨¡ç³Šåº¦,
	    if ((blur < 0.1f) || (blur > 2.0f)) {
	        blur = 0.5f;
	    }
	    
	    //boxSizeå¿…é¡»å¤§äº0
	    int boxSize = (int)(blur * 100);
	    boxSize -= (boxSize % 2) + 1;
	//    iCocosLog(@"boxSize:%i",boxSize);
	    //å›¾åƒå¤„ç†
	    CGImageRef img = image.CGImage;
	    
	    //å›¾åƒç¼“å­˜,è¾“å…¥ç¼“å­˜ï¼Œè¾“å‡ºç¼“å­˜
	    vImage_Buffer inBuffer, outBuffer;
	    vImage_Error error;
	    //åƒç´ ç¼“å­˜
	    void *pixelBuffer;
	    
	    //æ•°æ®æºæä¾›è€…ï¼ŒDefines an opaque type that supplies Quartz with data.
	    CGDataProviderRef inProvider = CGImageGetDataProvider(img);
	    // providerâ€™s data.
	    CFDataRef inBitmapData = CGDataProviderCopyData(inProvider);
	    
	    //å®½ï¼Œé«˜ï¼Œå­—èŠ‚/è¡Œï¼Œdata
	    inBuffer.width = CGImageGetWidth(img);
	    inBuffer.height = CGImageGetHeight(img);
	    inBuffer.rowBytes = CGImageGetBytesPerRow(img);
	    inBuffer.data = (void*)CFDataGetBytePtr(inBitmapData);
	    
	    //åƒæ•°ç¼“å­˜ï¼Œå­—èŠ‚è¡Œ*å›¾ç‰‡é«˜
	    pixelBuffer = malloc(CGImageGetBytesPerRow(img) * CGImageGetHeight(img));
	    
	    outBuffer.data = pixelBuffer;
	    outBuffer.width = CGImageGetWidth(img);
	    outBuffer.height = CGImageGetHeight(img);
	    outBuffer.rowBytes = CGImageGetBytesPerRow(img);
	    
	    
	    // ç¬¬ä¸‰ä¸ªä¸­é—´çš„ç¼“å­˜åŒº,æŠ—é”¯é½¿çš„æ•ˆæœ
	    void *pixelBuffer2 = malloc(CGImageGetBytesPerRow(img) * CGImageGetHeight(img));
	    vImage_Buffer outBuffer2;
	    outBuffer2.data = pixelBuffer2;
	    outBuffer2.width = CGImageGetWidth(img);
	    outBuffer2.height = CGImageGetHeight(img);
	    outBuffer2.rowBytes = CGImageGetBytesPerRow(img);
	    
	    
	    //Convolves a region of interest within an ARGB8888 source image by an implicit M x N kernel that has the effect of a box filter.
	    error = vImageBoxConvolve_ARGB8888(&inBuffer, &outBuffer2, NULL, 0, 0, boxSize, boxSize, NULL, kvImageEdgeExtend);
	    error = vImageBoxConvolve_ARGB8888(&outBuffer2, &inBuffer, NULL, 0, 0, boxSize, boxSize, NULL, kvImageEdgeExtend);
	    error = vImageBoxConvolve_ARGB8888(&inBuffer, &outBuffer, NULL, 0, 0, boxSize, boxSize, NULL, kvImageEdgeExtend);
	    
	    if (error) {
	        iCocosLog(@"error from convolution %ld", error);
	    }
	    
	    //    iCocosLog(@"å­—èŠ‚ç»„æˆéƒ¨åˆ†ï¼š%zu",CGImageGetBitsPerComponent(img));
	    //é¢œè‰²ç©ºé—´DeviceRGB
	    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
	    //ç”¨å›¾ç‰‡åˆ›å»ºä¸Šä¸‹æ–‡,CGImageGetBitsPerComponent(img),7,8
	    CGContextRef ctx = CGBitmapContextCreate(
	                                             outBuffer.data,
	                                             outBuffer.width,
	                                             outBuffer.height,
	                                             8,
	                                             outBuffer.rowBytes,
	                                             colorSpace,
	                                             CGImageGetBitmapInfo(image.CGImage));
	    
	    //æ ¹æ®ä¸Šä¸‹æ–‡ï¼Œå¤„ç†è¿‡çš„å›¾ç‰‡ï¼Œé‡æ–°ç»„ä»¶
	    CGImageRef imageRef = CGBitmapContextCreateImage (ctx);
	    UIImage *returnImage = [UIImage imageWithCGImage:imageRef];
	    
	    //clean up
	    CGContextRelease(ctx);
	    CGColorSpaceRelease(colorSpace);
	    
	    free(pixelBuffer);
	    free(pixelBuffer2);
	    CFRelease(inBitmapData);
	    
	    CGColorSpaceRelease(colorSpace);
	    CGImageRelease(imageRef);
	    
	    return returnImage;
	}

##6ï¼šæ–‡ä»¶å¤§å°

	/**
	 *  é€šå¸¸ç”¨äºåˆ é™¤ç¼“å­˜çš„æ—¶ï¼Œè®¡ç®—ç¼“å­˜å¤§å°
	 */
	//å•ä¸ªæ–‡ä»¶çš„å¤§å°
	+ (long long) fileSizeAtPath:(NSString*) filePath{
	    NSFileManager* manager = [NSFileManager defaultManager];
	    if ([manager fileExistsAtPath:filePath]){
	        return [[manager attributesOfItemAtPath:filePath error:nil] fileSize];
	    }
	    return 0;
	}
	
##7ï¼šæ‰‹æœºå·

	/**
	 *  æ‰‹æœºå·åˆ¤æ–­
	 *
	 *  @param mobileNum å·ç å­—ç¬¦ä¸²
	 *
	 *  @return BOOL
	 */
	+ (BOOL)isMobileNumber:(NSString *)mobileNum
	{
	        /**
	         * ç§»åŠ¨å·æ®µæ­£åˆ™è¡¨è¾¾å¼
	         */
	        NSString *CM_NUM = @"^((13[4-9])|(147)|(15[0-2,7-9])|(178)|(18[2-4,7-8]))\\d{8}|(1705)\\d{7}$";
	        /**
	         * è”é€šå·æ®µæ­£åˆ™è¡¨è¾¾å¼
	         */
	        NSString *CU_NUM = @"^((13[0-2])|(145)|(15[5-6])|(176)|(18[5,6]))\\d{8}|(1709)\\d{7}$";
	        /**
	         * ç”µä¿¡å·æ®µæ­£åˆ™è¡¨è¾¾å¼
	         */
	        NSString *CT_NUM = @"^((133)|(153)|(177)|(18[0,1,9]))\\d{8}$";
	    
	        NSPredicate *pred1 = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", CM_NUM];
	        BOOL isMatch1 = [pred1 evaluateWithObject:mobileNum];
	        NSPredicate *pred2 = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", CU_NUM];
	        BOOL isMatch2 = [pred2 evaluateWithObject:mobileNum];
	        NSPredicate *pred3 = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", CT_NUM];
	        BOOL isMatch3 = [pred3 evaluateWithObject:mobileNum];
	        
	        if (isMatch1 || isMatch2 || isMatch3) {
	            return YES;
	        }else{
	            return NO;
	        }
	}

##8ï¼šé‚®ç®±


####é€šè¿‡åŒºåˆ†å­—ç¬¦ä¸²
	
	-(BOOL)validateEmail:(NSString*)email
	
	{
	
	    if((0 != [email rangeOfString:@"@"].length) &&
	
	       (0 != [email rangeOfString:@"."].length))
	
	    {
	
	        NSCharacterSet* tmpInvalidCharSet = [[NSCharacterSet alphanumericCharacterSet] invertedSet];
	
	        NSMutableCharacterSet* tmpInvalidMutableCharSet = [[tmpInvalidCharSet mutableCopy] autorelease];
	
	        [tmpInvalidMutableCharSet removeCharactersInString:@"_-"];
	
	        
	
	       
	
	        NSRange range1 = [email rangeOfString:@"@"
	
	                                      options:NSCaseInsensitiveSearch];
	
	        
	
	        //å–å¾—ç”¨æˆ·åéƒ¨åˆ†
	
	        NSString* userNameString = [email substringToIndex:range1.location];
	
	        NSArray* userNameArray   = [userNameString componentsSeparatedByString:@"."];
	
	        
	
	        for(NSString* string in userNameArray)
	
	        {
	
	            NSRange rangeOfInavlidChars = [string rangeOfCharacterFromSet: tmpInvalidMutableCharSet];
	
	            if(rangeOfInavlidChars.length != 0 || [string isEqualToString:@""])
	
	                return NO;
	
	        }
	
	        
	
	        //å–å¾—åŸŸåéƒ¨åˆ†
	
	        NSString *domainString = [email substringFromIndex:range1.location+1];
	
	        NSArray *domainArray   = [domainString componentsSeparatedByString:@"."];
	
	        
	
	        for(NSString *string in domainArray)
	
	        {
	
	            NSRange rangeOfInavlidChars=[string rangeOfCharacterFromSet:tmpInvalidMutableCharSet];
	
	            if(rangeOfInavlidChars.length !=0 || [string isEqualToString:@""])
	
	                return NO;
	
	        }
	
	        
	
	        return YES;
	
	    }
	
	    else {
	
	       return NO;
	
	    }
	
	}


####åˆ©ç”¨æ­£åˆ™è¡¨è¾¾å¼éªŒè¯

	-(BOOL)isValidateEmail:(NSString *)email {
	
	    NSString *emailRegex = @"[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,4}"; 
	
	    NSPredicate *emailTest = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", emailRegex]; 
	
	    return [emailTest evaluateWithObject:email];
	
	}

##9ï¼šç½‘å€
####1.é¦–å…ˆè¿›è¡Œç¬¬ä¸€æ­¥åˆ¤æ–­ä¼ å…¥çš„å­—ç¬¦ä¸²æ˜¯å¦ç¬¦åˆHTTPè·¯å¾„çš„è¯­æ³•è§„åˆ™,å³â€HTTPS://â€ æˆ– â€œHTTP://â€ ,ä»å°è£…çš„ä¸€ä¸ªå‡½æ•°,ä¼ å…¥å³å¯åˆ¤æ–­

	- (NSURL *)smartURLForString:(NSString *)str
	{
	    NSURL *     result;
	    NSString *  trimmedStr;
	    NSRange     schemeMarkerRange;
	    NSString *  scheme;
	
	    assert(str != nil);
	
	    result = nil;
	
	    trimmedStr = [str stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceCharacterSet]];
	    if ( (trimmedStr != nil) && (trimmedStr.length != 0) ) {
	        schemeMarkerRange = [trimmedStr rangeOfString:@"://"];
	
	        if (schemeMarkerRange.location == NSNotFound) {
	            result = [NSURL URLWithString:[NSString stringWithFormat:@"http://%@", trimmedStr]];
	        } else {
	            scheme = [trimmedStr substringWithRange:NSMakeRange(0, schemeMarkerRange.location)];
	            assert(scheme != nil);
	
	            if ( ([scheme compare:@"http"  options:NSCaseInsensitiveSearch] == NSOrderedSame)
	                || ([scheme compare:@"https" options:NSCaseInsensitiveSearch] == NSOrderedSame) ) {
	                result = [NSURL URLWithString:trimmedStr];
	            } else {
	                // It looks like this is some unsupported URL scheme.
	            }
	        }
	    }
	
	    return result;
	}

####ç¬¬äºŒæ­¥,åˆ¤æ–­æ­¤è·¯å¾„æ˜¯å¦èƒ½å¤Ÿè¯·æ±‚æˆåŠŸ,ç›´æ¥è¿›è¡ŒHTTPè¯·æ±‚,è§‚å¯Ÿè¿”å›ç»“æœ->

	//åˆ¤æ–­
	-(void) validateUrl: (NSURL *) candidate {
	    NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:candidate];
	    [request setHTTPMethod:@"HEAD"];
	    NSURLSession *session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]];
	    NSURLSessionDataTask *task = [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {
	        NSLog(@"error %@",error);
	        if (error) {
	            NSLog(@"ä¸å¯ç”¨");
	        }else{
	            NSLog(@"å¯ç”¨");
	        }
	    }];
	    [task resume];
	}
##10ï¼šJSONè½¬å­—å…¸


	/*!
	 * @brief æŠŠæ ¼å¼åŒ–çš„JSONæ ¼å¼çš„å­—ç¬¦ä¸²è½¬æ¢æˆå­—å…¸
	 * @param jsonString JSONæ ¼å¼çš„å­—ç¬¦ä¸²
	 * @return è¿”å›å­—å…¸
	 */
	- (NSDictionary *)dictionaryWithJsonString:(NSString *)jsonString {
	    if (jsonString == nil) {
	        return nil;
	    }
	    iCocosLog(@"%@", jsonString);
	    
	    NSData *jsonData = [jsonString dataUsingEncoding:NSUTF8StringEncoding];
	    NSError *err;
	    NSDictionary *dic = [NSJSONSerialization JSONObjectWithData:jsonData
	                                                        options:NSJSONReadingMutableContainers
	                                                          error:&err];
	    if(err) {
	        iCocosLog(@"jsonè§£æå¤±è´¥ï¼š%@",err);
	        return nil;
	    }
	    return dic;
	}

####æ•°ç»„è½¬JSON

    	NSArray *uids = [self.allModelUID objectAtIndexCheck:range];

        NSError *error = nil;
        NSData *picsJsonData = [NSJSONSerialization dataWithJSONObject:uids
                                                               options:NSJSONWritingPrettyPrinted
                                                                 error:&error];
        NSString *JSONString = [[NSString alloc] initWithData:picsJsonData encoding:NSUTF8StringEncoding];


##11ï¼šiPhoneè®¾å¤‡ç±»å‹

	typedef NS_ENUM(char, iPhoneModel){//0~3
	    iPhone4,//320*480
	    iPhone5,//320*568
	    iPhone6,//375*667
	    iPhone6Plus,//414*736
	    UnKnown
	};
	
	
	
	/**
	 *  return current running iPhone model
	 *
	 *  @return iPhone model
	 */
	+ (iPhoneModel)iPhonesModel {
	    //bounds method gets the points not the pixels!!!
	    CGRect rect = [[UIScreen mainScreen] bounds];
	    
	    CGFloat width = rect.size.width;
	    CGFloat height = rect.size.height;
	    
	    //get current interface Orientation
	    UIInterfaceOrientation orientation = [[UIApplication sharedApplication] statusBarOrientation];
	    //unknown
	    if (UIInterfaceOrientationUnknown == orientation) {
	        return UnKnown;
	    }
	    /**
	     //    portrait   width * height
	     //    iPhone4:320*480
	     //    iPhone5:320*568
	     //    iPhone6:375*667
	     //    iPhone6Plus:414*736
	     */
	    
	    //portrait
	    if (UIInterfaceOrientationPortrait == orientation) {
	        if (width ==  320.0f) {
	            if (height == 480.0f) {
	                return iPhone4;
	            } else {
	                return iPhone5;
	            }
	        } else if (width == 375.0f) {
	            return iPhone6;
	        } else if (width == 414.0f) {
	            return iPhone6Plus;
	        }
	    } else if (UIInterfaceOrientationLandscapeLeft == orientation || UIInterfaceOrientationLandscapeRight == orientation) {//landscape
	        if (height == 320.0) {
	            if (width == 480.0f) {
	                return iPhone4;
	            } else {
	                return iPhone5;
	            }
	        } else if (height == 375.0f) {
	            return iPhone6;
	        } else if (height == 414.0f) {
	            return iPhone6Plus;
	        }
	    }
	    
	    return UnKnown;
	}


##12ï¼šiPhoneç³»ç»Ÿç‰ˆæœ¬

	//è·å–å½“å‰ç³»ç»Ÿç‰ˆæœ¬
	#define __ios10_0__ ([[UIDevice currentDevice].systemVersion floatValue] >= 10.0)
	#define __ios9_0__ ([[UIDevice currentDevice].systemVersion floatValue] >= 9.0)
	#define __ios8_0__ ([[UIDevice currentDevice].systemVersion floatValue] >= 8.0)

##13ï¼šæ—¥å¿—

	// æ—¥å¿—è¾“å‡º
	#ifdef DEBUG // å¼€å‘é˜¶æ®µ-DEBUGé˜¶æ®µ:ä½¿ç”¨Log
	#define iCocosLog(...) NSLog(__VA_ARGS__)
	#else // å‘å¸ƒé˜¶æ®µ-ä¸Šçº¿é˜¶æ®µ:ç§»é™¤Log
	#define iCocosLog(...)
	#endif

è¯¦ç»†


	#ifdef DEBUG
	#define iCocosLog(format, ...) printf("\n[%s] %s [ç¬¬%dè¡Œ] %s\n", __TIME__, __FUNCTION__, __LINE__, [[NSString stringWithFormat:format, ## __VA_ARGS__] UTF8String]);
	#else
	#define iCocosLog(format, ...)
	#endif


##14ï¼šé¢œè‰²

	// é¢œè‰²
	#define iCocosARGBColor(r, g, b, a) [UIColor colorWithRed:(r)/255.0 green:(g)/255.0 blue:(b)/255.0 alpha:a]
	#define iCocosColor(r, g, b) iCocosARGBColor((r), (g), (b), 255)


	#define random(r, g, b, a) [UIColor colorWithRed:(r)/255.0 green:(g)/255.0 blue:(b)/255.0 alpha:(a)/255.0]
	#define iCocosRandomColor (random(arc4random_uniform(256), arc4random_uniform(256), arc4random_uniform(256), arc4random_uniform(256)))

##15ï¼šå¼±å¼•ç”¨

	// å¼±å¼•ç”¨
	#define iCocosWeakSelf __weak typeof(self) weakSelf = self;
##16ï¼šå±å¹•å°ºå¯¸

	// å±å¹•å°ºå¯¸
	#define iCocosScreenH [UIScreen mainScreen].bounds.size.height
	#define iCocosScreenW [UIScreen mainScreen].bounds.size.width
	
	
##17ï¼šè·å–viewçš„æ§åˆ¶

	/** è·å–å½“å‰Viewçš„æ§åˆ¶å™¨å¯¹è±¡ */
	-(UIViewController *)getCurrentViewController{
	    UIResponder *next = [self nextResponder];
	    do {
	        if ([next isKindOfClass:[UIViewController class]]) {
	            return (UIViewController *)next;
	        }
	        next = [next nextResponder];
	    } while (next != nil);
	    return nil;
	}


##18ï¼šå­—å…¸é˜²è¹¦

####ä¸å¯å˜

	/*!
	 @method objectAtIndexCheck:
	 @abstract æ£€æŸ¥æ˜¯å¦è¶Šç•Œå’ŒNSNullå¦‚æœæ˜¯è¿”å›nil
	 @result è¿”å›å¯¹è±¡
	 */
	- (id)objectStringForKey:(NSString *)key
	{
	    if ([self objectForKey:key] == nil) {
	//        iCocosLog(@"é”®å€¼å¯¹ä¸å­˜åœ¨");
	        return nil;
	    }
	    id value = [self objectForKey:key];
	      
	    return value;
	}


####å¯å˜

	/*!
	 @method objectAtIndexCheck:
	 @abstract æ£€æŸ¥æ˜¯å¦è¶Šç•Œå’ŒNSNullå¦‚æœæ˜¯è¿”å›nil
	 @result è¿”å›å¯¹è±¡
	 */
	- (id)objectStringForKey:(NSString *)key
	{
	    if ([self objectForKey:key] == nil) {
	        
	//        iCocosLog(@"é”®å€¼å¯¹ä¸å­˜åœ¨");
	        
	        return nil;
	//        return 0;
	    }
	    id value = [self objectForKey:key];
	    
	    return value;
	}


##19ï¼šæ•°ç»„é˜²è¹¦

####ä¸å¯å˜

	/*!
	 @method objectAtIndexCheck:
	 @abstract æ£€æŸ¥æ˜¯å¦è¶Šç•Œå’ŒNSNullå¦‚æœæ˜¯è¿”å›nil
	 @result è¿”å›å¯¹è±¡
	 */
	- (id)objectAtIndexCheck:(NSUInteger)index  {
	    
	    if (index >= [self count]) {
	        iCocosLog(@"æ•°ç»„è¶Šç•Œ");
	        return nil;
	    }
	    id value = [self objectAtIndex:index];
	    if (value == [NSNull null]) {
	        iCocosLog(@"æ•°ç»„ä¸ºç©º");
	        return nil;
	    }
	    return value;
	}


####å¯å˜

	/*!
	 @method objectAtIndexCheck:
	 @abstract æ£€æŸ¥æ˜¯å¦è¶Šç•Œå’ŒNSNullå¦‚æœæ˜¯è¿”å›nil
	 @result è¿”å›å¯¹è±¡
	 */
	- (id)objectAtIndexCheck:(NSUInteger)index  {
	    
	    if (index >= [self count]) {
	        iCocosLog(@"æ•°ç»„è¶Šç•Œ");
	        return nil;
	    }
	    id value = [self objectAtIndex:index];
	    if (value == [NSNull null]) {
	        iCocosLog(@"æ•°ç»„ä¸ºç©º");
	        return nil;
	    }
	    return value;
	}



	- (void)removeObjectAtCheckIndex:(NSInteger)index
	{
	    if (index >= [self count]) {
	        iCocosLog(@"æ•°ç»„è¶Šç•Œ");
	        return ;
	    }
	    id value = [self objectAtIndex:index];
	    if (value == [NSNull null]) {
	        iCocosLog(@"æ•°ç»„ä¸ºç©º");
	        return ;
	    }
	    
	    [self removeObjectAtIndex:index];
	    
	}

##20ï¼šæœ¬æ–‡è¾“å…¥é”™è¯¯æç¤º

	- (void)shake {
	    CAKeyframeAnimation *keyFrame = [CAKeyframeAnimation animationWithKeyPath:@"position.x"];
	    keyFrame.duration = 0.3;
	    CGFloat x = self.layer.position.x;
	    keyFrame.values = @[@(x - 30), @(x - 30), @(x + 20), @(x - 20), @(x + 10), @(x - 10), @(x + 5), @(x - 5)];
	    [self.layer addAnimation:keyFrame forKey:@"shake"];
	
	}


##21ï¼šå½“å‰æ—¶é—´

	+ (NSString *)nowTimes{
	    NSDate* dat = [NSDate dateWithTimeIntervalSinceNow:0];
	    int a=(int)([dat timeIntervalSince1970] + 0.5);
	    NSString *timeString = [NSString stringWithFormat:@"%d", a];//è½¬ä¸ºå­—ç¬¦å‹
	    return timeString;
	}


##22:å½“å‰ç‰ˆæœ¬

	/*
	 *  å½“å‰ç¨‹åºçš„ç‰ˆæœ¬å·
	 */
	-(NSString *)version{
	    //ç³»ç»Ÿç›´æ¥è¯»å–çš„ç‰ˆæœ¬å·
	    NSString *versionValueStringForSystemNow=[[NSBundle mainBundle].infoDictionary valueForKey:(NSString *)kCFBundleVersionKey];
	    return versionValueStringForSystemNow;
	}

##23:tabBarçº¢ç‚¹


	- (void)showBadgeOnItemIndex:(int)index{
	    
	    //ç§»é™¤ä¹‹å‰çš„å°çº¢ç‚¹
	    [self removeBadgeOnItemIndex:index];
	    
	    //æ–°å»ºå°çº¢ç‚¹
	    UIView *badgeView = [[UIView alloc]init];
	    badgeView.tag = 888 + index;
	    badgeView.backgroundColor = [UIColor redColor];
	    CGRect tabFrame = self.frame;
	    
	    //ç¡®å®šå°çº¢ç‚¹çš„ä½ç½®
	    float percentX = (index +0.6) / TabbarItemNums;
	    CGFloat x = ceilf(percentX * tabFrame.size.width);
	    CGFloat y = ceilf(0.1 * tabFrame.size.height);
	    badgeView.frame = CGRectMake(x, y, 8, 8);
	    badgeView.layer.cornerRadius = badgeView.frame.size.width/2;
	    
	    [self addSubview:badgeView];
	    
	}
	
	- (void)hideBadgeOnItemIndex:(int)index{
	    
	    //ç§»é™¤å°çº¢ç‚¹
	    [self removeBadgeOnItemIndex:index];
	    
	}
	
	- (void)removeBadgeOnItemIndex:(int)index{
	    
	    //æŒ‰ç…§tagå€¼è¿›è¡Œç§»é™¤
	    for (UIView *subView in self.subviews) {
	        if (subView.tag == 888+index) {
	            [subView removeFromSuperview];
	        }
	    }
	}


##24:Logæ—¥å¿—.m

	@implementation UIView(Log)
	+ (NSString *)searchAllSubviews:(UIView *)superview
	{
	    NSMutableString *xml = [NSMutableString string];
	    
	    NSString *class = NSStringFromClass(superview.class);
	    class = [class stringByReplacingOccurrencesOfString:@"_" withString:@""];
	    [xml appendFormat:@"<%@ frame=\"%@\">\n", class, NSStringFromCGRect(superview.frame)];
	    for (UIView *childView in superview.subviews) {
	        NSString *subviewXml = [self searchAllSubviews:childView];
	        [xml appendString:subviewXml];
	    }
	    [xml appendFormat:@"</%@>\n", class];
	    return xml;
	}
	
	- (NSString *)description
	{
	    return [UIView searchAllSubviews:self];
	}
	@end
	
	@implementation NSDictionary (Log)
	- (NSString *)descriptionWithLocale:(id)locale
	{
	    NSMutableString *str = [NSMutableString string];
	    
	    [str appendString:@"{\n"];
	    
	    // éå†å­—å…¸çš„æ‰€æœ‰é”®å€¼å¯¹
	    [self enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) {
	        [str appendFormat:@"\t%@ = %@,\n", key, obj];
	    }];
	    
	    [str appendString:@"}"];
	    
	    // æŸ¥å‡ºæœ€åä¸€ä¸ª,çš„èŒƒå›´
	    NSRange range = [str rangeOfString:@"," options:NSBackwardsSearch];
	    if (range.length) {
	        // åˆ æ‰æœ€åä¸€ä¸ª,
	        [str deleteCharactersInRange:range];
	    }
	    
	    return str;
	}
	@end
	
	@implementation NSArray (Log)
	- (NSString *)descriptionWithLocale:(id)locale
	{
	    NSMutableString *str = [NSMutableString string];
	    
	    [str appendString:@"[\n"];
	    
	    // éå†æ•°ç»„çš„æ‰€æœ‰å…ƒç´ 
	    [self enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {
	        [str appendFormat:@"%@,\n", obj];
	    }];
	    
	    [str appendString:@"]"];
	    
	    // æŸ¥å‡ºæœ€åä¸€ä¸ª,çš„èŒƒå›´
	    NSRange range = [str rangeOfString:@"," options:NSBackwardsSearch];
	    if (range.length) {
	        // åˆ æ‰æœ€åä¸€ä¸ª,
	        [str deleteCharactersInRange:range];
	    }
	    
	    return str;
	}
	@end

##25:MD5

	//16ä½MD5åŠ å¯†æ–¹å¼
	- (NSString *)getMd5_16Bit_String:(NSString *)srcString{
	    //æå–32ä½MD5æ•£åˆ—çš„ä¸­é—´16ä½
	    NSString *md5_32Bit_String=[self getMd5_32Bit_String:srcString];
	    NSString *result = [[md5_32Bit_String substringToIndex:24] substringFromIndex:8];//å³9ï½25ä½
	    
	    return result;
	}
	
	
	//32ä½MD5åŠ å¯†æ–¹å¼
	- (NSString *)getMd5_32Bit_String:(NSString *)srcString{
	    const char *cStr = [srcString UTF8String];
	    unsigned char digest[CC_MD5_DIGEST_LENGTH];
	    CC_MD5( cStr, strlen(cStr), digest );
	    NSMutableString *result = [NSMutableString stringWithCapacity:CC_MD5_DIGEST_LENGTH * 2];
	    for(int i = 0; i < CC_MD5_DIGEST_LENGTH; i++)
	        [result appendFormat:@"%02x", digest[i]];
	    
	    return result;
	}


##26:æŒ‰é’®èƒŒæ™¯é¢œè‰²


	/**
	 *  ä½¿ç”¨èƒŒæ™¯é¢œè‰²è®¾ç½®æŒ‰é’®ä¸åŒçŠ¶æ€çš„å›¾ç‰‡
	 *
	 *  @param color é¢œè‰²
	 *
	 *  @return èƒŒæ™¯å›¾ç‰‡
	 */
	+ (UIImage *)imageWithColor:(UIColor *)color {
	    CGRect rect = CGRectMake(0.0f, 0.0f, 1.0f, 1.0f);
	    UIGraphicsBeginImageContext(rect.size);
	    CGContextRef context = UIGraphicsGetCurrentContext();
	    
	    CGContextSetFillColorWithColor(context, [color CGColor]);
	    CGContextFillRect(context, rect);
	    
	    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();
	    UIGraphicsEndImageContext();
	    
	    return image;
	}

##27ï¼šå¯¹è±¡æ˜¯å¦ä¸ºç©º


	// åˆ¤æ–­å¯¹è±¡æ˜¯å¦ä¸ºç©º
	- (BOOL)isBlanceObject:(id)object{
	    if (object == nil || object == NULL) {
	        return YES;
	    }
	    if ([object isKindOfClass:[NSNull class]]) {
	        return YES;
	    }
	    return NO;
	}

##28ï¼šé”®ç›˜é€€å‡ºä¸éšè—


    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(keyboardWillShow:) name:UIKeyboardWillShowNotification object:nil];
    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(keyboardWillHide:) name:UIKeyboardWillHideNotification object:nil];
}

	- (void)keyboardWillShow:(NSNotification *)notification {
	
	    // è·å–é€šçŸ¥çš„ä¿¡æ¯å­—å…¸
	    NSDictionary *userInfo = [notification userInfo];
	
	    // è·å–é”®ç›˜å¼¹å‡ºåçš„rect
	    NSValue* aValue = [userInfo objectForKey:UIKeyboardFrameEndUserInfoKey];
	    CGRect keyboardRect = [aValue CGRectValue];
	
	    // è·å–é”®ç›˜å¼¹å‡ºåŠ¨ç”»æ—¶é—´
	    NSValue *animationDurationValue = [userInfo objectForKey:UIKeyboardAnimationDurationUserInfoKey];
	    NSTimeInterval animationDuration;
	    [animationDurationValue getValue:&animationDuration];
	
	}
	
	
	- (void)keyboardWillHide:(NSNotification *)notification {
	
	    // è·å–é€šçŸ¥ä¿¡æ¯å­—å…¸
	    NSDictionary* userInfo = [notification userInfo];
	
	    // è·å–é”®ç›˜éšè—åŠ¨ç”»æ—¶é—´
	    NSValue *animationDurationValue = [userInfo objectForKey:UIKeyboardAnimationDurationUserInfoKey];
	    NSTimeInterval animationDuration;
	    [animationDurationValue getValue:&animationDuration];
	
	
	}

##29ï¼šè·å–è®¾å¤‡å”¯ä¸€ID

-(NSString *)getUniqueDeviceIdentifierAsString
{
    NSString *appName=[[[NSBundle mainBundle] infoDictionary] objectForKey:(NSString*)kCFBundleNameKey];
 
    NSString *strApplicationUUID =  [SAMKeychain passwordForService:appName account:@"incoding"];
    if (strApplicationUUID == nil)
    {
        strApplicationUUID  = [[[UIDevice currentDevice] identifierForVendor] UUIDString];
 
        NSError *error = nil;
        SAMKeychainQuery *query = [[SAMKeychainQuery alloc] init];
        query.service = appName;
        query.account = @"incoding";
        query.password = strApplicationUUID;
        query.synchronizationMode = SAMKeychainQuerySynchronizationModeNo;
        [query save:&error];
 
    }
 
    return strApplicationUUID;
}

##30ï¼šMOVè½¬Mp4


	- (void)movFileTransformToMP4WithSourceUrl:(NSURL *)sourceUrl completion:(void(^)(NSString *Mp4FilePath))comepleteBlock
	{
	    /**
	     *  movæ ¼å¼è½¬mp4æ ¼å¼
	     */
	    AVURLAsset *avAsset = [AVURLAsset URLAssetWithURL:sourceUrl options:nil];
	    
	    NSArray *compatiblePresets = [AVAssetExportSession exportPresetsCompatibleWithAsset:avAsset];
	    
	    NSLog(@"%@",compatiblePresets);
	    
	    if ([compatiblePresets containsObject:AVAssetExportPresetHighestQuality]) {
	        
	        AVAssetExportSession *exportSession = [[AVAssetExportSession alloc] initWithAsset:avAsset presetName:AVAssetExportPresetMediumQuality];
	        
	        
	        NSDate *date = [NSDate date];
	        NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
	        [formatter setDateFormat:@"yyyyMMddHHmmss"];
	        NSString *uniqueName = [NSString stringWithFormat:@"%@.mp4",[formatter stringFromDate:date]];
	        NSString * resultPath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES)[0] stringByAppendingPathComponent:uniqueName];//PATH_OF_DOCUMENTä¸ºdocumentsè·¯å¾„
	        
	        NSLog(@"output File Path : %@",resultPath);
	        
	        exportSession.outputURL = [NSURL fileURLWithPath:resultPath];
	        
	        exportSession.outputFileType = AVFileTypeMPEG4;//å¯ä»¥é…ç½®å¤šç§è¾“å‡ºæ–‡ä»¶æ ¼å¼
	        
	        exportSession.shouldOptimizeForNetworkUse = YES;
	        
	        [exportSession exportAsynchronouslyWithCompletionHandler:^(void)
	         {
	             switch (exportSession.status) {
	                     
	                 case AVAssetExportSessionStatusUnknown:
	                     
	                     break;
	                     
	                 case AVAssetExportSessionStatusWaiting:
	                     
	                     break;
	                     
	                 case AVAssetExportSessionStatusExporting:
	                     
	                     break;
	                     
	                 case AVAssetExportSessionStatusCompleted:
	                 {
	                     comepleteBlock(resultPath);
	                     
	                     
	                     NSLog(@"mp4 file size:%lf MB",[NSData dataWithContentsOfURL:exportSession.outputURL].length/1024.f/1024.f);
	                 }
	                     break;
	                     
	                 case AVAssetExportSessionStatusFailed:
	                     
	                     break;
	                     
	                 case AVAssetExportSessionStatusCancelled:
	                     
	                     break;
	                     
	             }  
	             
	         }];
	    }  
	}


##31:ä¸Šä¼ å›¾ç‰‡


	+ (void)uploadImage:(UIImage *)imageIcon successUpload:(void (^)(id responseObject))successUpload failureUpload:(void (^)(NSError *error))failureUpload;
	{
	    
	    //    æ‹¿åˆ°æ–‡ä»¶
	    NSString *NSDocmentsPath = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject;
	    NSString *iconPath       = [NSDocmentsPath stringByAppendingPathComponent:[NSString stringWithFormat:@"faceUrl.png"]];
	    //NSURL *url = [NSURL fileURLWithPath:iconPath];
	    
	    long long size = [iCocosGetSize fileSizeAtPath:iconPath];
	    
	    if (size >= 7000000) {
	        [SVProgressHUD showInfoWithStatus:@"å›¾ç‰‡è¿‡å¤§ï¼Œè¯·é‡æ–°ä¸Šä¼  \n è¯·ä¸è¦ä¸Šä¼ è¶…è¿‡7Mbæ–‡ä»¶"];
	        NSDictionary *errDict = [NSDictionary dictionaryWithObject:@"big" forKey:@"state"];
	        failureUpload((NSError *)errDict);
	        return;
	    }
	    
	    //1:æ–‡ä»¶çš„32ä½MD5å€¼
	    NSString *strForEight = [iCocosFormatFileGetEight getStringWithEight:iconPath];
	    //2:æ–‡ä»¶çš„å‰8ä¸ªå­—èŠ‚çš„16ä½+æ–‡ä»¶çš„å8ä¸ªå­—èŠ‚çš„16ä½
	    NSString *str32MD5    = [NSString getMd5_32Bit_String:iconPath];
	    
	    NSString *str64       = [NSString stringWithFormat:@"%@%@", str32MD5,strForEight];
	    
	    //å­˜å›¾ç‰‡
	    //    NSData *imageData = UIImageJPEGRepresentation(imageIcon, 1.0);//å°†UIImageè½¬ä¸ºNSDataï¼Œ1.0è¡¨ç¤ºä¸å‹ç¼©å›¾ç‰‡è´¨é‡ã€‚
	    NSData *imageData = [iCocosFileCondenseTools resetSizeOfImageData:imageIcon maxSize:50];
	    
	    
	    [imageData writeToFile:iconPath atomically:YES];
	    
	    AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];
	    manager.responseSerializer.acceptableContentTypes = [NSSet setWithObjects:@"text/html", nil];
	    
	    //    NSString *urlStrIF        = [NSString stringWithFormat:@"%@file/exist%@", [iCocosUrlOperationTools shareiCocosUrlOperationTools].iCocosFileUrl, [iCocosURLRequestExtension getURLRequestExtension]];
	    NSMutableDictionary *dict = [NSMutableDictionary dictionary];
	    //æ–‡ä»¶çš„32ä½MD5+å‰8ä¸ªå­—èŠ‚çš„16ä½+å8ä¸ªå­—èŠ‚çš„16ä½
	    dict[@"file_md5"] = str64;
	    dict[@"is_blur"] = @(1);
	    dict[@"file_size"] = @([iCocosGetSize fileSizeAtPath:iconPath]);
	    dict[@"ext"] = @"png";
	    
	    /**
	     *  è¶…æ—¶æ—¶é—´
	     */
	    [manager.requestSerializer willChangeValueForKey:@"timeoutInterval"];
	    manager.requestSerializer.timeoutInterval = 10.f;
	    [manager.requestSerializer didChangeValueForKey:@"timeoutInterval"];
	    
	    //    [manager POST:urlStrIF parameters:dict progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {
	    
	    [iCocosAFNPOSTRequestData iCocos_POST_HostSecurity:@"file/exist" hostHeaderValue:[iCocosUrlOperationTools shareiCocosUrlOperationTools].iCocosFileHost firstRequestWithUrl:[iCocosUrlOperationTools shareiCocosUrlOperationTools].iCocosFileUrl secondRequestWithIp:[iCocosUrlOperationTools shareiCocosUrlOperationTools].iCocosFileIp params:dict success:^(id response) {
	        
	        NSString *state = [NSString stringWithFormat:@"%@", [response objectStringForKey:@"state"]];
	        NSString *msg= [NSString stringWithFormat:@"%@", [response objectStringForKey:@"msg"]];
	        if ([state isEqualToString:@"0"]) {
	            NSString *exist = [NSString stringWithFormat:@"%@", [[response objectStringForKey:@"data"] objectStringForKey:@"exist"]];
	            /**
	             *  æ³¨æ„è¿™é‡Œéœ€è¦æ¢æˆçœŸå®æœåŠ¡å™¨åœ°å€
	             */
	            if ([exist isEqualToString:@"0"]) { //ä¸å­˜åœ¨å°±éœ€è¦å‘é€è¯·æ±‚
	                NSString *imageUrl          = [NSString stringWithFormat:@"%@file/up%@", [iCocosUrlOperationTools shareiCocosUrlOperationTools].iCocosFileUrl,[iCocosURLRequestExtension getURLRequestExtension]];
	                NSMutableDictionary *params = [NSMutableDictionary dictionary];
	                params[@"blur"]          = @(1);
	                
	                
	                AFHTTPSessionManager *mger = [AFHTTPSessionManager manager];
	                
	                AFJSONResponseSerializer *response = [AFJSONResponseSerializer serializer];
	                response.removesKeysWithNullValues = YES;
	                manager.responseSerializer = response;
	                
	                manager.requestSerializer = [AFHTTPRequestSerializer serializer];//å“åº”
	                
	                
	                
	                mger.responseSerializer.acceptableContentTypes = [NSSet setWithObjects:@"image/png", @"text/html", nil];
	                
	                /**
	                 *  è¶…æ—¶æ—¶é—´
	                 */
	                [manager.requestSerializer willChangeValueForKey:@"timeoutInterval"];
	                manager.requestSerializer.timeoutInterval = 10.f;
	                [manager.requestSerializer didChangeValueForKey:@"timeoutInterval"];
	                
	                
	                [mger POST:imageUrl parameters:params constructingBodyWithBlock:^(id<AFMultipartFormData> formData) {
	                    // ä¸Šä¼ æ–‡ä»¶
	                    NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
	                    formatter.dateFormat       = @"yyyyMMddHHmmss";
	                    NSString *str              = [formatter stringFromDate:[NSDate date]];
	                    NSString *fileName         = [NSString stringWithFormat:@"%@.png", str];
	                    
	                    [formData appendPartWithFileData:imageData name:@"file" fileName:fileName mimeType:@"image/png"];
	                    
	                } progress:^(NSProgress * _Nonnull uploadProgress) {
	                    
	                    iCocosLog(@"å°é¢å›¾ç‰‡================%@", uploadProgress);
	                    
	                } success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {
	                    
	                    NSDictionary *dataDic    = [responseObject objectStringForKey:@"data"]; 
	                    
	                    
	                    successUpload(dataDic);
	                    
	                    iCocosLog(@"%@", responseObject);
	                } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {
	                    iCocosLog(@"ä¸Šä¼ é”™è¯¯:%@", error);
	                    
	                    failureUpload(error);
	                }];
	                
	            } else {
	                
	                NSDictionary *dataDic    = [response objectStringForKey:@"data"];
	                
	                successUpload(dataDic);
	            }
	            
	        } else {
	            successUpload(response);
	        }
	    } failure:^(NSError *error) {
	        failureUpload(error);
	    }];
	
	}


##32ï¼šä¸Šä¼ è§†é¢‘

####ä¸Šä¼ MOV

	+ (void)updateMOVVideo:(NSURL *)url successUpload:(void (^)(id responseObject))successUpload failureUpload:(void (^)(NSError *error))failureUpload;
	{
	    //ä¿å­˜æ•°æ®
	    //    NSUserDefaults *defaults =[NSUserDefaults standardUserDefaults];
	    //    NSURL *url = [defaults URLForKey:@"RecordVideoUrl"];
	    
	    NSData *videoData = [NSData dataWithContentsOfURL:url];
	    
	    //   NSString *videoUrl = [iCocosUpLoadVideoTools upLoadVideoGetVideoUrlWithFileUrlInSandbox:url];
	    
	    //    NSString *strUrl = [NSString stringWithContentsOfURL:url usedEncoding:0 error:nil];
	    
	    //    //1:æ–‡ä»¶çš„32ä½MD5å€¼
	    //    NSString *strForEight = [iCocosFormatFileGetEight getStringWithEight:strUrl];
	    //
	    //    //2:æ–‡ä»¶çš„å‰8ä¸ªå­—èŠ‚çš„16ä½+æ–‡ä»¶çš„å8ä¸ªå­—èŠ‚çš„16ä½
	    //    NSString *str32MD5 = [NSString getMd5_32Bit_String:strUrl];
	    
	    NSString *str32MD5 = [iCocosRandomSix getSixRandom];
	    
	    NSString *str64 = [NSString stringWithFormat:@"%@%@", str32MD5,str32MD5];
	    
	    AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];
	    manager.responseSerializer.acceptableContentTypes = [NSSet setWithObjects:@"text/html", nil];
	    
	    //    NSString *urlStrIF = [NSString stringWithFormat:@"%@file/exist%@", [iCocosUrlOperationTools shareiCocosUrlOperationTools].iCocosFileUrl, [iCocosURLRequestExtension getURLRequestExtension]];
	    NSMutableDictionary *dict = [NSMutableDictionary dictionary];
	    dict[@"file_md5"] = str64;
	    dict[@"is_blur"] = 0;
	    dict[@"file_size"] = @([iCocosGetSize fileSizeAtPath:[url absoluteString]]);
	    dict[@"ext"] = @"MOV";
	    
	    /**
	     *  è¶…æ—¶æ—¶é—´
	     */
	    [manager.requestSerializer willChangeValueForKey:@"timeoutInterval"];
	    manager.requestSerializer.timeoutInterval = 10.f;
	    [manager.requestSerializer didChangeValueForKey:@"timeoutInterval"];
	    
	    /** è·å–è§†é¢‘æ˜¯å¦ä¸Šä¼  */
	    //    [manager POST:urlStrIF parameters:dict progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {
	    
	    [iCocosAFNPOSTRequestData iCocos_POST_HostSecurity:@"file/exist" hostHeaderValue:[iCocosUrlOperationTools shareiCocosUrlOperationTools].iCocosFileHost firstRequestWithUrl:[iCocosUrlOperationTools shareiCocosUrlOperationTools].iCocosFileUrl secondRequestWithIp:[iCocosUrlOperationTools shareiCocosUrlOperationTools].iCocosFileIp params:dict success:^(id response) {
	        
	        NSString *state = [NSString stringWithFormat:@"%@", [response objectStringForKey:@"state"]];
	        if ([state isEqualToString:@"0"]) {
	            NSString *exist = [response objectStringForKey:@"exist"];
	            /**
	             *  æ³¨æ„è¿™é‡Œéœ€è¦æ¢æˆçœŸå®æœåŠ¡å™¨åœ°å€
	             */
	            if (exist == 0) { //ä¸å­˜åœ¨å°±éœ€è¦å‘é€è¯·æ±‚
	                NSString *vidUrl = [NSString stringWithFormat:@"%@file/up%@", [iCocosUrlOperationTools shareiCocosUrlOperationTools].iCocosFileUrl, [iCocosURLRequestExtension getURLRequestExtension]];
	                NSMutableDictionary *params = [NSMutableDictionary dictionary];
	                //            params[@"name:file"] = @""; //Content-Disposition: form-data; name="file"; filename="1.txt"
	                params[@"is_blur"] = @0;
	                params[@"need_mp4"] = @1;
	                AFHTTPSessionManager *mger = [AFHTTPSessionManager manager];
	                
	                AFJSONResponseSerializer *response = [AFJSONResponseSerializer serializer];
	                response.removesKeysWithNullValues = YES;
	                manager.responseSerializer = response;
	                
	                manager.requestSerializer = [AFHTTPRequestSerializer serializer];//å“åº”
	                
	                
	                [mger.securityPolicy setAllowInvalidCertificates:YES];
	                
	                /** ä¸Šä¼ è§†é¢‘ */
	                [mger POST:vidUrl parameters:params constructingBodyWithBlock:^(id<AFMultipartFormData> formData) {
	                    
	                    // ä¸Šä¼ æ–‡ä»¶
	                    NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
	                    formatter.dateFormat = @"yyyyMMddHHmmss";
	                    NSString *str = [formatter stringFromDate:[NSDate date]];
	                    NSString *fileName = [NSString stringWithFormat:@"%@.mov", str];
	                    
	                    if (videoData != nil) {
	                        [formData appendPartWithFileData:videoData name:@"file" fileName:fileName mimeType:@"video/quicktime"];
	                    } else {
	                        
	                    }
	                    
	                } progress:^(NSProgress * _Nonnull uploadProgress) {
	                    
	//                    iCocosLog(@"%@", uploadProgress);
	                    
	                } success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {
	                    
	                    NSString *state = [NSString stringWithFormat:@"%@", [responseObject objectStringForKey:@"state"]];
	                    if ([state isEqualToString:@"0"]) {
	                        
	                        NSDictionary *dataDic = [responseObject objectStringForKey:@"data"];
	                        
	                        successUpload(dataDic);
	                    }
	                    
	                } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {
	                    iCocosLog(@"ä¸Šä¼ é”™è¯¯:%@", error);
	                    failureUpload(error);
	                }];
	                
	            } else {
	                /**
	                 *  å·²ç»ä¸Šä¼ 
	                 */
	                NSDictionary *dataDic    = [response objectStringForKey:@"data"];
	                NSString *file_url       = [NSString stringWithFormat:@"%@", [dataDic objectStringForKey:@"file_url"]];
	                NSString *mp4_file_url       = [NSString stringWithFormat:@"%@", [dataDic objectStringForKey:@"mp4_file_url"]];
	                
	                NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];
	                [defaults setValue:file_url forKey:@"video_url"];
	                [defaults setValue:mp4_file_url forKey:@"mp4_file_url"];
	                [defaults synchronize];
	                
	                successUpload(dataDic);
	            }
	            
	        } else {
	            successUpload(response);
	        }
	    } failure:^(NSError *error) { //ä¸Šä¼ é”™è¯¯
	        failureUpload(error);
	    }];
	}
	
####ä¸Šä¼ MP4	
	
	+ (void)updateMP4Video:(NSURL *)url successUpload:(void (^)(id responseObject))successUpload failureUpload:(void (^)(NSError *error))failureUpload
	{
	    //ä¿å­˜æ•°æ®
	    //    NSUserDefaults *defaults =[NSUserDefaults standardUserDefaults];
	    //    NSURL *url = [defaults URLForKey:@"RecordVideoUrl"];
	    
	    NSData *videoData = [NSData dataWithContentsOfURL:url];
	    
	    //   NSString *videoUrl = [iCocosUpLoadVideoTools upLoadVideoGetVideoUrlWithFileUrlInSandbox:url];
	    
	    //    NSString *strUrl = [NSString stringWithContentsOfURL:url usedEncoding:0 error:nil];
	    
	    //    //1:æ–‡ä»¶çš„32ä½MD5å€¼
	    //    NSString *strForEight = [iCocosFormatFileGetEight getStringWithEight:strUrl];
	    //
	    //    //2:æ–‡ä»¶çš„å‰8ä¸ªå­—èŠ‚çš„16ä½+æ–‡ä»¶çš„å8ä¸ªå­—èŠ‚çš„16ä½
	    //    NSString *str32MD5 = [NSString getMd5_32Bit_String:strUrl];
	    
	    NSString *str32MD5 = [iCocosRandomSix getSixRandom];
	    
	    NSString *str64 = [NSString stringWithFormat:@"%@%@", str32MD5,str32MD5];
	    
	    AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];
	    manager.responseSerializer.acceptableContentTypes = [NSSet setWithObjects:@"text/html", nil];
	    
	    //    NSString *urlStrIF = [NSString stringWithFormat:@"%@file/exist%@", [iCocosUrlOperationTools shareiCocosUrlOperationTools].iCocosFileUrl, [iCocosURLRequestExtension getURLRequestExtension]];
	    NSMutableDictionary *dict = [NSMutableDictionary dictionary];
	    dict[@"file_md5"] = str64;
	    dict[@"is_blur"] = 0;
	    dict[@"file_size"] = @([iCocosGetSize fileSizeAtPath:[url absoluteString]]);
	    dict[@"ext"] = @"mp4";
	    
	    /**
	     *  è¶…æ—¶æ—¶é—´
	     */
	    [manager.requestSerializer willChangeValueForKey:@"timeoutInterval"];
	    manager.requestSerializer.timeoutInterval = 10.f;
	    [manager.requestSerializer didChangeValueForKey:@"timeoutInterval"];
	    
	    /** è·å–è§†é¢‘æ˜¯å¦ä¸Šä¼  */
	    //    [manager POST:urlStrIF parameters:dict progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {
	    
	    [iCocosAFNPOSTRequestData iCocos_POST_HostSecurity:@"file/exist" hostHeaderValue:[iCocosUrlOperationTools shareiCocosUrlOperationTools].iCocosFileHost firstRequestWithUrl:[iCocosUrlOperationTools shareiCocosUrlOperationTools].iCocosFileUrl secondRequestWithIp:[iCocosUrlOperationTools shareiCocosUrlOperationTools].iCocosFileIp params:dict success:^(id response) {
	        
	        NSString *state = [NSString stringWithFormat:@"%@", [response objectStringForKey:@"state"]];
	        if ([state isEqualToString:@"0"]) {
	            NSString *exist = [response objectStringForKey:@"exist"];
	            /**
	             *  æ³¨æ„è¿™é‡Œéœ€è¦æ¢æˆçœŸå®æœåŠ¡å™¨åœ°å€
	             */
	            if (exist == 0) { //ä¸å­˜åœ¨å°±éœ€è¦å‘é€è¯·æ±‚
	                NSString *vidUrl = [NSString stringWithFormat:@"%@file/up%@", [iCocosUrlOperationTools shareiCocosUrlOperationTools].iCocosFileUrl, [iCocosURLRequestExtension getURLRequestExtension]];
	                NSMutableDictionary *params = [NSMutableDictionary dictionary];
	                //            params[@"name:file"] = @""; //Content-Disposition: form-data; name="file"; filename="1.txt"
	                params[@"is_blur"] = @0;
	                params[@"need_mp4"] = @1;
	                AFHTTPSessionManager *mger = [AFHTTPSessionManager manager];
	                
	                AFJSONResponseSerializer *response = [AFJSONResponseSerializer serializer];
	                response.removesKeysWithNullValues = YES;
	                manager.responseSerializer = response;
	                
	                manager.requestSerializer = [AFHTTPRequestSerializer serializer];//å“åº”
	                
	                
	                [mger.securityPolicy setAllowInvalidCertificates:YES];
	                
	                /** ä¸Šä¼ è§†é¢‘ */
	                [mger POST:vidUrl parameters:params constructingBodyWithBlock:^(id<AFMultipartFormData> formData) {
	                    
	                    // ä¸Šä¼ æ–‡ä»¶
	                    NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
	                    formatter.dateFormat = @"yyyyMMddHHmmss";
	                    NSString *str = [formatter stringFromDate:[NSDate date]];
	                    NSString *fileName = [NSString stringWithFormat:@"%@.mp4", str];
	                    
	                    if (videoData != nil) {
	                        [formData appendPartWithFileData:videoData name:@"file" fileName:fileName mimeType:@"video/mp4"];
	                    } else {
	                        
	                    }
	                    
	                } progress:^(NSProgress * _Nonnull uploadProgress) {
	                    
	                    
	//                    iCocosLog(@"%@", uploadProgress);
	                    
	                    
	                } success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {
	                    
	                    NSString *state = [NSString stringWithFormat:@"%@", [responseObject objectStringForKey:@"state"]];
	                    if ([state isEqualToString:@"0"]) {
	                        
	                        NSDictionary *dataDic = [responseObject objectStringForKey:@"data"];
	                        
	                        successUpload(dataDic);
	                    }
	                    
	                    
	                } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {
	                    iCocosLog(@"ä¸Šä¼ é”™è¯¯:%@", error);
	                    failureUpload(error);
	                }];
	                
	            } else {
	                
	                /**
	                 *  å·²ç»ä¸Šä¼ 
	                 */
	                NSDictionary *dataDic    = [response objectStringForKey:@"data"];
	                NSString *file_url       = [NSString stringWithFormat:@"%@", [dataDic objectStringForKey:@"file_url"]];
	                NSString *mp4_file_url       = [NSString stringWithFormat:@"%@", [dataDic objectStringForKey:@"mp4_file_url"]];
	                
	                NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];
	                [defaults setValue:file_url forKey:@"video_url"];
	                [defaults setValue:mp4_file_url forKey:@"mp4_file_url"];
	                [defaults synchronize];
	                
	                successUpload(dataDic);
	            }
	            
	        } else {
	            successUpload(response);
	        }
	    } failure:^(NSError *error) { //ä¸Šä¼ é”™è¯¯
	        failureUpload(error);
	    }];
	}


##33:è·å–è§†é¢‘å¸§å›¾

####åŒæ­¥è·å–å¸§å›¾

åŒæ­¥è·å–ä¸­é—´å¸§ï¼Œéœ€è¦æŒ‡å®šå“ªä¸ªæ—¶é—´ç‚¹çš„å¸§ï¼Œå½“è·å–åˆ°ä»¥åï¼Œè¿”å›æ¥çš„å›¾ç‰‡å¯¹è±¡æ˜¯CFRetainedè¿‡çš„ï¼Œéœ€è¦å¤–é¢æ‰‹åŠ¨CGImageReleaseä¸€ä¸‹ï¼Œé‡Šæ”¾å†…å­˜ã€‚é€šè¿‡AVAssetæ¥è®¿é—®å…·ä½“çš„è§†é¢‘èµ„æºï¼Œç„¶åé€šè¿‡AVAssetImageGeneratorå›¾ç‰‡ç”Ÿæˆå™¨æ¥ç”ŸæˆæŸä¸ªå¸§å›¾ç‰‡ï¼š
	// Get the video's center frame as video poster image
	- (UIImage *)frameImageFromVideoURL:(NSURL *)videoURL {
	  // result
	  UIImage *image = nil;
	  
	  // AVAssetImageGenerator
	  AVAsset *asset = [AVAsset assetWithURL:videoURL];
	  AVAssetImageGenerator *imageGenerator = [[AVAssetImageGenerator alloc] initWithAsset:asset];
	  imageGenerator.appliesPreferredTrackTransform = YES;
	  
	  // calculate the midpoint time of video
	  Float64 duration = CMTimeGetSeconds([asset duration]);
	  // å–æŸä¸ªå¸§çš„æ—¶é—´ï¼Œå‚æ•°ä¸€è¡¨ç¤ºå“ªä¸ªæ—¶é—´ï¼ˆç§’ï¼‰ï¼Œå‚æ•°äºŒè¡¨ç¤ºæ¯ç§’å¤šå°‘å¸§
	  // é€šå¸¸æ¥è¯´ï¼Œ600æ˜¯ä¸€ä¸ªå¸¸ç”¨çš„å…¬å…±å‚æ•°ï¼Œè‹¹æœæœ‰è¯´æ˜:
	  // 24 frames per second (fps) for film, 30 fps for NTSC (used for TV in North America and
	  // Japan), and 25 fps for PAL (used for TV in Europe).
	  // Using a timescale of 600, you can exactly represent any number of frames in these systems
	  CMTime midpoint = CMTimeMakeWithSeconds(duration / 2.0, 600);
	  
	  // get the image from
	  NSError *error = nil;
	  CMTime actualTime;
	  // Returns a CFRetained CGImageRef for an asset at or near the specified time.
	  // So we should mannully release it
	  CGImageRef centerFrameImage = [imageGenerator copyCGImageAtTime:midpoint
	                                                       actualTime:&actualTime
	                                                            error:&error];
	  
	  if (centerFrameImage != NULL) {
	    image = [[UIImage alloc] initWithCGImage:centerFrameImage];
	    // Release the CFRetained image
	    CGImageRelease(centerFrameImage);
	  }
	  
	  return image;
	}

####å¼‚æ­¥è·å–å¸§å›¾

å¼‚æ­¥è·å–æŸä¸ªå¸§çš„å›¾ç‰‡ï¼Œä¸åŒæ­¥ç›¸æ¯”ï¼Œåªæ˜¯è°ƒç”¨APIä¸åŒï¼Œå¯ä»¥ä¼ å¤šä¸ªæ—¶é—´ç‚¹ï¼Œç„¶åè®¡ç®—å‡ºå®é™…çš„æ—¶é—´å¹¶è¿”å›å›¾ç‰‡ï¼Œä½†æ˜¯è¿”å›çš„å›¾ç‰‡ä¸éœ€è¦æˆ‘ä»¬æ‰‹åŠ¨å†releaseäº†ã€‚æœ‰å¯èƒ½å–ä¸åˆ°å›¾ç‰‡ï¼Œæ‰€ä»¥è¿˜éœ€è¦åˆ¤æ–­æ˜¯å¦æ˜¯AVAssetImageGeneratorSucceededï¼Œæ˜¯æ‰è½¬æ¢å›¾ç‰‡ï¼š

	// å¼‚æ­¥è·å–å¸§å›¾ç‰‡ï¼Œå¯ä»¥ä¸€æ¬¡è·å–å¤šå¸§å›¾ç‰‡
	- (void)centerFrameImageWithVideoURL:(NSURL *)videoURL completion:(void (^)(UIImage *image))completion {
	  // AVAssetImageGenerator
	  AVAsset *asset = [AVAsset assetWithURL:videoURL];
	  AVAssetImageGenerator *imageGenerator = [[AVAssetImageGenerator alloc] initWithAsset:asset];
	  imageGenerator.appliesPreferredTrackTransform = YES;
	  
	  // calculate the midpoint time of video
	  Float64 duration = CMTimeGetSeconds([asset duration]);
	  // å–æŸä¸ªå¸§çš„æ—¶é—´ï¼Œå‚æ•°ä¸€è¡¨ç¤ºå“ªä¸ªæ—¶é—´ï¼ˆç§’ï¼‰ï¼Œå‚æ•°äºŒè¡¨ç¤ºæ¯ç§’å¤šå°‘å¸§
	  // é€šå¸¸æ¥è¯´ï¼Œ600æ˜¯ä¸€ä¸ªå¸¸ç”¨çš„å…¬å…±å‚æ•°ï¼Œè‹¹æœæœ‰è¯´æ˜:
	  // 24 frames per second (fps) for film, 30 fps for NTSC (used for TV in North America and
	  // Japan), and 25 fps for PAL (used for TV in Europe).
	  // Using a timescale of 600, you can exactly represent any number of frames in these systems
	  CMTime midpoint = CMTimeMakeWithSeconds(duration / 2.0, 600);
	  
	  // å¼‚æ­¥è·å–å¤šå¸§å›¾ç‰‡
	  NSValue *midTime = [NSValue valueWithCMTime:midpoint];
	  [imageGenerator generateCGImagesAsynchronouslyForTimes:@[midTime] completionHandler:^(CMTime requestedTime, CGImageRef  _Nullable image, CMTime actualTime, AVAssetImageGeneratorResult result, NSError * _Nullable error) {
	    if (result == AVAssetImageGeneratorSucceeded && image != NULL) {
	      UIImage *centerFrameImage = [[UIImage alloc] initWithCGImage:image];
	      dispatch_async(dispatch_get_main_queue(), ^{
	        if (completion) {
	          completion(centerFrameImage);
	        }
	      });
	    } else {
	      dispatch_async(dispatch_get_main_queue(), ^{
	        if (completion) {
	          completion(nil);
	        }
	      });
	    }
	  }];
	}
	 
	 
##34:å‹ç¼©å¹¶å¯¼å‡ºè§†é¢‘

å‹ç¼©è§†é¢‘æ˜¯å› ä¸ºè§†é¢‘åˆ†è¾¨ç‡è¿‡é«˜æ‰€ç”Ÿæˆçš„è§†é¢‘çš„å¤§å°å¤ªå¤§äº†ï¼Œå¯¹äºç§»åŠ¨è®¾å¤‡æ¥è¯´ï¼Œå†…å­˜æ˜¯ä¸èƒ½å¤ªå¤§çš„ï¼Œå¦‚æœä¸æ”¯æŒåˆ†ç‰‡ä¸Šä¼ åˆ°æœåŠ¡å™¨ï¼Œæˆ–è€…ä¸æ”¯æŒæµä¸Šä¼ ã€æ–‡ä»¶ä¸Šä¼ ï¼Œè€Œåªèƒ½æ”¯æŒè¡¨å•ä¸Šä¼ ï¼Œé‚£ä¹ˆå¿…é¡»è¦é™åˆ¶å¤§å°ï¼Œå‹ç¼©è§†é¢‘ã€‚

å°±åƒæˆ‘ä»¬åœ¨ä½¿ç”¨æŸå¹³å°çš„è§†é¢‘çš„ä¸Šä¼ çš„æ—¶å€™ï¼Œåˆ°ç°åœ¨è¿˜æ²¡æœ‰æ”¯æŒæµä¸Šä¼ ï¼Œä¹Ÿä¸æ”¯æŒæ–‡ä»¶ä¸Šä¼ ï¼Œåªæ”¯æŒè¡¨å•ä¸Šä¼ ï¼Œå¯¼è‡´è§†é¢‘å¤§ä¸€ç‚¹å°±ä¼šé—ªé€€ã€‚æµä¸Šä¼ æ˜¯ä¸Šä¼ æˆåŠŸäº†ï¼Œä½†æ˜¯äººå®¶åå°ä¸è¯†åˆ«ï¼Œè¿™ä¸€æ¬¡è®©æŸå¹³å°å‘åäº†ã€‚ç›´æ¥ç”¨fileä¸Šä¼ ï¼Œä¹Ÿä¼ è¿‡å»äº†ï¼Œä¸Šä¼ è¿›åº¦100%äº†ï¼Œä½†æ˜¯äººå®¶é‚£è¾¹è¿˜æ˜¯ä½œä¸ºå¤±è´¥å¤„ç†ï¼Œæ— å¥ˆï¼

>è¨€å½’æ­£ä¼ ï¼Œå‹ç¼©ã€å¯¼å‡ºè§†é¢‘ï¼Œéœ€è¦é€šè¿‡AVAssetExportSessionæ¥å®ç°ï¼Œæˆ‘ä»¬éœ€è¦æŒ‡å®šä¸€ä¸ªpresetï¼Œå¹¶åˆ¤æ–­æ˜¯å¦æ”¯æŒè¿™ä¸ªpresetï¼Œåªæœ‰æ”¯æŒæ‰èƒ½ä½¿ç”¨ã€‚

æˆ‘ä»¬è¿™é‡Œè®¾ç½®çš„presetä¸ºAVAssetExportPreset640x480ï¼Œå±äºå‹ç¼©å¾—æ¯”è¾ƒå‰å®³çš„äº†ï¼Œè¿™éœ€è¦æ ¹æ®æœåŠ¡å™¨è§†é¢‘ä¸Šä¼ çš„æ”¯æŒç¨‹åº¦è€Œé€‰æ‹©çš„ã€‚ç„¶åé€šè¿‡è°ƒç”¨å¼‚æ­¥å‹ç¼©å¹¶å¯¼å‡ºè§†é¢‘ï¼š


	- (void)compressVideoWithVideoURL:(NSURL *)videoURL
	                        savedName:(NSString *)savedName
	                       completion:(void (^)(NSString *savedPath))completion {
	  // Accessing video by URL
	  AVURLAsset *videoAsset = [[AVURLAsset alloc] initWithURL:videoURL options:nil];
	  
	  // Find compatible presets by video asset.
	  NSArray *presets = [AVAssetExportSession exportPresetsCompatibleWithAsset:videoAsset];
	  
	  // Begin to compress video
	  // Now we just compress to low resolution if it supports
	  // If you need to upload to the server, but server does't support to upload by streaming,
	  // You can compress the resolution to lower. Or you can support more higher resolution.
	  if ([presets containsObject:AVAssetExportPreset640x480]) {
	    AVAssetExportSession *session = [[AVAssetExportSession alloc] initWithAsset:videoAsset  presetName:AVAssetExportPreset640x480];
	    
	    NSString *doc = [NSHomeDirectory() stringByAppendingPathComponent:@"Documents"];
	    NSString *folder = [doc stringByAppendingPathComponent:@"HYBVideos"];
	    BOOL isDir = NO;
	    BOOL isExist = [[NSFileManager defaultManager] fileExistsAtPath:folder isDirectory:&isDir];
	    if (!isExist || (isExist && !isDir)) {
	      NSError *error = nil;
	      [[NSFileManager defaultManager] createDirectoryAtPath:folder
	                                withIntermediateDirectories:YES
	                                                 attributes:nil
	                                                      error:&error];
	      if (error == nil) {
	        NSLog(@"ç›®å½•åˆ›å»ºæˆåŠŸ");
	      } else {
	        NSLog(@"ç›®å½•åˆ›å»ºå¤±è´¥");
	      }
	    }
	    
	    NSString *outPutPath = [folder stringByAppendingPathComponent:savedName];
	    session.outputURL = [NSURL fileURLWithPath:outPutPath];
	    
	    // Optimize for network use.
	    session.shouldOptimizeForNetworkUse = true;
	    
	    NSArray *supportedTypeArray = session.supportedFileTypes;
	    if ([supportedTypeArray containsObject:AVFileTypeMPEG4]) {
	      session.outputFileType = AVFileTypeMPEG4;
	    } else if (supportedTypeArray.count == 0) {
	      NSLog(@"No supported file types");
	      return;
	    } else {
	      session.outputFileType = [supportedTypeArray objectAtIndex:0];
	    }
	    
	    // Begin to export video to the output path asynchronously.
	    [session exportAsynchronouslyWithCompletionHandler:^{
	      if ([session status] == AVAssetExportSessionStatusCompleted) {
	        dispatch_async(dispatch_get_main_queue(), ^{
	          if (completion) {
	            completion([session.outputURL path]);
	          }
	        });
	      } else {
	        dispatch_async(dispatch_get_main_queue(), ^{
	          if (completion) {
	            completion(nil);
	          }
	        });
	      }
	    }];
	  }
	}
	

##35:ä¿å­˜è§†é¢‘åˆ°ç›¸å†Œ

å†™å…¥ç›¸å†Œå¯ä»¥é€šè¿‡ALAssetsLibraryç±»æ¥å®ç°ï¼Œå®ƒæä¾›äº†å†™å…¥ç›¸å†Œçš„APIï¼Œå¼‚æ­¥å†™å…¥ï¼Œå®Œæˆæ˜¯è¦å›åˆ°ä¸»çº¿ç¨‹æ›´æ–°UIï¼š

	NSURL *videoURL = [info objectForKey:UIImagePickerControllerMediaURL];
	ALAssetsLibrary *library = [[ALAssetsLibrary alloc] init];
	dispatch_async(dispatch_get_global_queue(0, 0), ^{
	  // åˆ¤æ–­ç›¸å†Œæ˜¯å¦å…¼å®¹è§†é¢‘ï¼Œå…¼å®¹æ‰èƒ½ä¿å­˜åˆ°ç›¸å†Œ
	  if ([library videoAtPathIsCompatibleWithSavedPhotosAlbum:videoURL]) {
	    [library writeVideoAtPathToSavedPhotosAlbum:videoURL completionBlock:^(NSURL *assetURL, NSError *error) {
	      dispatch_async(dispatch_get_main_queue(), ^{
	        // å†™å…¥ç›¸å†Œ
	        if (error == nil) {
	            NSLog(@"å†™å…¥ç›¸å†ŒæˆåŠŸ");
	        } else {
	           NSLog(@"å†™å…¥ç›¸å†Œå¤±è´¥");
	        }
	      }
	    }];
	  }
	});
	

##36:è·å–å½“å‰æœ€é¡¶å±‚çš„ViewController
	
		- (UIViewController *)topViewController {
	    UIViewController *resultVC;
	    resultVC = [self _topViewController:[[UIApplication sharedApplication].keyWindow rootViewController]];
	    while (resultVC.presentedViewController) {
	        resultVC = [self _topViewController:resultVC.presentedViewController];
	    }
	    return resultVC;
	}

	- (UIViewController *)_topViewController:(UIViewController *)vc {
	    if ([vc isKindOfClass:[UINavigationController class]]) {
	        return [self _topViewController:[(UINavigationController *)vc topViewController]];
	    } else if ([vc isKindOfClass:[UITabBarController class]]) {
	        return [self _topViewController:[(UITabBarController *)vc selectedViewController]];
	    } else {
	        return vc;
	    }
	    return nil;
	}

ä½¿ç”¨æ–¹æ³•

	UIViewController *topmostVC = [self topViewController];
	


##37:æ•°ç»„æ‹†åˆ†
	
	
	/**
	 *  æ•°ç»„æ‹†åˆ†
	 *
	 *  @param array   æ•°ç»„
	 *  @param subSize å¤§å°
	 *
	 *  @return å¤šä¸ªæ•°ç»„
	 */
	- (NSMutableArray *)splitArray: (NSArray *)array withSubSize : (int)subSize{
	    //  æ•°ç»„å°†è¢«æ‹†åˆ†æˆæŒ‡å®šé•¿åº¦æ•°ç»„çš„ä¸ªæ•°
	    unsigned long count = array.count % subSize == 0 ? (array.count / subSize) : (array.count / subSize + 1);
	    //  ç”¨æ¥ä¿å­˜æŒ‡å®šé•¿åº¦æ•°ç»„çš„å¯å˜æ•°ç»„å¯¹è±¡
	    NSMutableArray *arr = [[NSMutableArray alloc] init];
	    
	    //åˆ©ç”¨æ€»ä¸ªæ•°è¿›è¡Œå¾ªç¯ï¼Œå°†æŒ‡å®šé•¿åº¦çš„å…ƒç´ åŠ å…¥æ•°ç»„
	    for (int i = 0; i < count; i ++) {
	        //æ•°ç»„ä¸‹æ ‡
	        int index = i * subSize;
	        //ä¿å­˜æ‹†åˆ†çš„å›ºå®šé•¿åº¦çš„æ•°ç»„å…ƒç´ çš„å¯å˜æ•°ç»„
	        NSMutableArray *arr1 = [[NSMutableArray alloc] init];
	        //ç§»é™¤å­æ•°ç»„çš„æ‰€æœ‰å…ƒç´ 
	        [arr1 removeAllObjects];
	        
	        int j = index;
	        //å°†æ•°ç»„ä¸‹æ ‡ä¹˜ä»¥1ã€2ã€3ï¼Œå¾—åˆ°æ‹†åˆ†æ—¶æ•°ç»„çš„æœ€å¤§ä¸‹æ ‡å€¼ï¼Œä½†æœ€å¤§ä¸èƒ½è¶…è¿‡æ•°ç»„çš„æ€»å¤§å°
	        while (j < subSize*(i + 1) && j < array.count) {
	            [arr1 addObject:[array objectAtIndexCheck:j]];
	            j += 1;
	        }
	        //å°†å­æ•°ç»„æ·»åŠ åˆ°ä¿å­˜å­æ•°ç»„çš„æ•°ç»„ä¸­
	        [arr addObject:[arr1 copy]];  
	    }  
	    
	    return arr;
	}

##38.å›¾ç‰‡å‹ç¼©

ç”¨æ³•ï¼šUIImage *yourImage= [self imageWithImageSimple:image scaledToSize:CGSizeMake(210.0, 210.0)];
	
	//å‹ç¼©å›¾ç‰‡
	- (UIImage*)imageWithImageSimple:(UIImage*)image scaledToSize:(CGSize)newSize
	
	{
	
	// Create a graphics image context
	
	UIGraphicsBeginImageContext(newSize);
	
	// Tell the old image to draw in this newcontext, with the desired
	
	// new size
	
	[image drawInRect:CGRectMake(0,0,newSize.width,newSize.height)];
	
	// Get the new image from the context
	
	UIImage* newImage = UIGraphicsGetImageFromCurrentImageContext();
	
	// End the context
	
	UIGraphicsEndImageContext();
	
	// Return the new image.
	
	return newImage;
	
	}
	

 
===





    Q Qï¼š2211523682/790806573

    å¾®ä¿¡ï¼š18370997821/13148454507
    
    å¾®åšWB:http://weibo.com/u/3288975567?is_hot=1
    
	gitåšæ–‡ï¼šhttp://al1020119.github.io/
	
	githubï¼šhttps://github.com/al1020119


{% img /images/iCocosCoder.jpg Caption %}  

{% img /images/iCocosPublic.jpg Caption %}  