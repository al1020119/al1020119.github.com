<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[iOS梦工厂]]></title>
  <link href="http://al1020119.github.io/atom.xml" rel="self"/>
  <link href="http://al1020119.github.io/"/>
  <updated>2016-08-03T16:21:02+08:00</updated>
  <id>http://al1020119.github.io/</id>
  <author>
    <name><![CDATA[iCocos]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS开发各种底层实现--包你满意！]]></title>
    <link href="http://al1020119.github.io/blog/2016/08/01/gezhongdicenshixian/"/>
    <updated>2016-08-01T23:53:19+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/08/01/gezhongdicenshixian</id>
    <content type="html"><![CDATA[<p>iOS开发常用技术底层实现（精简概述）</p>

<h6>系统篇</h6>

<ul>
<li>内存管理</li>
<li>Runtime</li>
</ul>


<h6>代码篇</h6>

<ul>
<li>Block</li>
<li>__Block</li>
</ul>


<h6>实战</h6>

<ul>
<li>KVO</li>
<li>KVC</li>
</ul>


<h6>高级</h6>

<ul>
<li>GCD</li>
</ul>


<h6>通用篇</h6>

<ul>
<li>数组</li>
<li>字典</li>
<li>集合</li>
</ul>


<h6>必备篇</h6>

<ul>
<li>多线程</li>
<li>网络</li>
<li>数据持久化</li>
</ul>


<h6>全栈篇</h6>

<ul>
<li>JSPatch</li>
<li>React Native</li>
</ul>


<h6>#写在最后</h6>

<!--more-->


<p>更新中，敬请关注。。。。。。</p>

<pre><code>Q Q：2211523682/790806573

微信：18370997821/13148454507

微博WB:http://weibo.com/u/3288975567?is_hot=1

git博文：http://al1020119.github.io/

github：https://github.com/al1020119
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[福利：抢红包神器就是这么来的]]></title>
    <link href="http://al1020119.github.io/blog/2016/08/01/weixinhongbao/"/>
    <updated>2016-08-01T11:52:15+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/08/01/weixinhongbao</id>
    <content type="html"><![CDATA[<p>微信红包</p>

<p><img src="http://al1020119.github.io/images/weixinhongbao0001.jpg" title="Caption" ></p>

<p>别告诉我你对红包不感兴趣，如果真的是这样，那么请绕道，哈哈。</p>

<p>现在由于微信和QQ的普及，几乎所有用户都会使用红包这个功能，但是对于一个程序员来说，每看到一个好的功能都会努力试着研究一下，哪怕不能成功，由于看到了一篇比较看的文章，所以就专门花时间去搞一顿，结果大吃一惊。</p>

<p>最近有不少朋友找我要红包尾数的功能，我也不知道他们为什么要这个，可能是笔者太年轻了。但是我觉得这个可能不简单，而且这样的功能做好了也不能外漏，不然笔者的程序员职业生涯估计就到头了！</p>

<pre><code>前言：最近笔者在研究iOS逆向工程，顺便拿微信来练手，在非越狱手机上实现了微信自动抢红包的功能。
</code></pre>

<p>题外话：此教程是一篇严肃的学术探讨类文章，仅仅用于学习研究，也请读者不要用于商业或其他非法途径上，笔者一概不负责哟~~</p>

<p>好了，接下来可以进入正题了！</p>

<!--more-->


<h2>此教程所需要的工具/文件</h2>

<pre><code>yololib
class-dump
dumpdecrypted
iOSOpenDev
iTools
OpenSSH(Cydia)
iFile(Cydia)
Cycript(Cydia)
Command Line Tools
Xcode
苹果开发者证书或企业证书
一台越狱的iPhone
</code></pre>

<p>是的，想要实现在非越狱iPhone上达到自动抢红包的目的，工具用的可能是有点多（工欲善其事必先利其器^_^）。不过，没关系，大家可以按照教程的步骤一步一步来执行，不清楚的步骤可以重复实验，毕竟天上不会掉馅饼嘛。</p>

<h1>解密微信可执行文件(Mach-O)</h1>

<p>因为从Appstore下载安装的应用都是加密过的，所以我们需要用一些工具来为下载的App解密，俗称砸壳。这样才能便于后面分析App的代码结构。</p>

<p>首先我们需要一台已经越狱的iPhone手机(现在市面上越狱已经很成熟，具体越狱方法这里就不介绍了)。然后进入Cydia，安装OpenSSH、Cycript、iFile(调试程序时可以方便地查看日志文件)这三款软件。</p>

<pre><code>PS：笔者的手机是iPhone 6Plus，系统版本为iOS9.1。
</code></pre>

<p>在电脑上用iTunes上下载一个最新的微信，笔者当时下载的微信版本为6.3.13。下载完后，iTunes上会显示出已下载的app。</p>

<p>itnues</p>

<p><img src="http://al1020119.github.io/images/weixinhongbao0002.jpg" title="Caption" ></p>

<p>连上iPhone，用iTunes装上刚刚下载的微信应用。</p>

<p>打开Mac的终端，用ssh进入连上的iPhone(确保iPhone和Mac在同一个网段，笔者iPhone的IP地址为192.168.8.54)。OpenSSH的root密码默认为alpine。</p>

<p>ssh
<img src="http://al1020119.github.io/images/weixinhongbao0003.jpg" title="Caption" ></p>

<p>接下来就是需要找到微信的Bundle id了，，这里笔者有一个小技巧，我们可以把iPhone上的所有App都关掉，唯独保留微信，然后输入命令 ps -e</p>

<p>微信bundle id
<img src="http://al1020119.github.io/images/weixinhongbao0004.jpg" title="Caption" ><br/>
这样我们就找到了微信的可执行文件Wechat的具体路径了。接下来我们需要用Cycript找出微信的Documents的路径，输入命令cycript -p WeChat</p>

<p>cycript
<img src="http://al1020119.github.io/images/weixinhongbao0005.jpg" title="Caption" ></p>

<pre><code>编译dumpdecrypted
先记下刚刚我们获取到的两个路径(Bundle和Documents)，这时候我们就要开始用dumpdecrypted来为微信二进制文件(WeChat)砸壳了。
确保我们从Github上下载了最新的dumpdecrypted源码，进入dumpdecrypted源码的目录，编译dumpdecrypted.dylib，命令如下:
</code></pre>

<p>dumpdecrypted.dylib
<img src="http://al1020119.github.io/images/weixinhongbao0006.jpg" title="Caption" ><br/>
这样我们可以看到dumpdecrypted目录下生成了一个dumpdecrypted.dylib的文件。</p>

<pre><code>scp
拷贝dumpdecrypted.dylib到iPhone上，这里我们用到scp命令.
scp 源文件路径 目标文件路径 。具体如下：
</code></pre>

<p>scp
<img src="http://al1020119.github.io/images/weixinhongbao0007.jpg" title="Caption" ><br/>
    开始砸壳
    dumpdecrypted.dylib的具体用法是：DYLD_INSERT_LIBRARIES=/PathFrom/dumpdecrypted.dylib /PathTo</p>

<p>dumpdecrypted
<img src="http://al1020119.github.io/images/weixinhongbao0008.jpg" title="Caption" ><br/>
这样就代表砸壳成功了，当前目录下会生成砸壳后的文件，即WeChat.decrypted。同样用scp命令把WeChat.decrypted文件拷贝到电脑上,接下来我们要正式的dump微信的可执行文件了。</p>

<h1>dump微信可执行文件</h1>

<pre><code>从Github上下载最新的class-dump源代码，然后用Xcode编译即可生成class-dump(这里比较简单，笔者就不详细说明了)。

导出微信的头文件
使用class-dump命令,把刚刚砸壳后的WeChat.decrypted,导出其中的头文件。./class-dump -s -S -H ./WeChat.decrypted -o ./header6.3-arm64
</code></pre>

<p>导出的头文件
<img src="http://al1020119.github.io/images/weixinhongbao0009.jpg" title="Caption" ><br/>
这里我们可以新建一个Xcode项目，把刚刚导出的头文件加到新建的项目中，这样便于查找微信的相关代码。</p>

<p>微信的头文件
<img src="http://al1020119.github.io/images/weixinhongbao0010.jpg" title="Caption" ><br/>
找到CMessageMgr.h和WCRedEnvelopesLogicMgr.h这两文件，其中我们注意到有这两个方法：- (void)AsyncOnAddMsg:(id)arg1 MsgWrap:(id)arg2; ，- (void)OpenRedEnvelopesRequest:(id)arg1;。没错，接下来我们就是要利用这两个方法来实现微信自动抢红包功能。其实现原理是，通过hook微信的新消息函数，我们判断是否为红包消息，如果是，我们就调用微信的打开红包方法。这样就能达到自动抢红包的目的了。哈哈，是不是很简单，我们一起来看看具体是怎么实现的吧。</p>

<pre><code>新建一个dylib工程，因为Xcode默认不支持生成dylib，所以我们需要下载iOSOpenDev，安装完成后(Xcode7环境会提示安装iOSOpenDev失败，请参考iOSOpenDev安装问题)，重新打开Xcode，在新建项目的选项中即可看到iOSOpenDev选项了。
</code></pre>

<p>iOSOpenDev
<img src="http://al1020119.github.io/images/weixinhongbao0011.jpg" title="Caption" ><br/>
    dylib代码
    选择Cocoa Touch Library，这样我们就新建了一个dylib工程了，我们命名为autoGetRedEnv。</p>

<pre><code>删除autoGetRedEnv.h文件，修改autoGetRedEnv.m为autoGetRedEnv.mm，然后在项目中加入CaptainHook.h

因为微信不会主动来加载我们的hook代码，所以我们需要把hook逻辑写到构造函数中。

__attribute__((constructor)) static void entry()
{
  //具体hook方法
}

hook微信的AsyncOnAddMsg: MsgWrap:方法，实现方法如下：

//声明CMessageMgr类
CHDeclareClass(CMessageMgr);
CHMethod(2, void, CMessageMgr, AsyncOnAddMsg, id, arg1, MsgWrap, id, arg2)
{
  //调用原来的AsyncOnAddMsg:MsgWrap:方法
  CHSuper(2, CMessageMgr, AsyncOnAddMsg, arg1, MsgWrap, arg2);
  //具体抢红包逻辑
  //...
  //调用原生的打开红包的方法
  //注意这里必须为给objc_msgSend的第三个参数声明为NSMutableDictionary,不然调用objc_msgSend时，不会触发打开红包的方法
  ((void (*)(id, SEL, NSMutableDictionary*))objc_msgSend)(logicMgr, @selector(OpenRedEnvelopesRequest:), params);
}
__attribute__((constructor)) static void entry()
{
  //加载CMessageMgr类
  CHLoadLateClass(CMessageMgr);
  //hook AsyncOnAddMsg:MsgWrap:方法
  CHClassHook(2, CMessageMgr, AsyncOnAddMsg, MsgWrap);
}

    项目的全部代码，笔者已放入Github中。

完成好具体实现逻辑后，就可以顺利生成dylib了。
</code></pre>

<h1>重新打包微信App</h1>

<pre><code>为微信可执行文件注入dylib
要想微信应用运行后，能执行我们的代码，首先需要微信加入我们的dylib，这里我们用到一个dylib注入神器:yololib，从网上下载源代码，编译后得到yololib。

使用yololib简单的执行下面一句就可以成功完成注入。注入之前我们先把之前保存的WeChat.decrypted重命名为WeChat，即已砸完壳的可执行文件。
./yololib 目标可执行文件 需注入的dylib
注入成功后即可见到如下信息：

dylib注入
</code></pre>

<p><img src="http://al1020119.github.io/images/weixinhongbao0012.jpg" title="Caption" ><br/>
    新建Entitlements.plist</p>

<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;
&lt;plist version="1.0"&gt;
&lt;dict&gt;
  &lt;key&gt;application-identifier&lt;/key&gt;
  &lt;string&gt;123456.com.autogetredenv.demo&lt;/string&gt;
  &lt;key&gt;com.apple.developer.team-identifier&lt;/key&gt;
  &lt;string&gt;123456&lt;/string&gt;
  &lt;key&gt;get-task-allow&lt;/key&gt;
  &lt;true/&gt;
  &lt;key&gt;keychain-access-groups&lt;/key&gt;
  &lt;array&gt;
      &lt;string&gt;123456.com.autogetredenv.demo&lt;/string&gt;
  &lt;/array&gt;
&lt;/dict&gt;
&lt;/plist&gt;

这里大家也许不清楚自己的证书Teamid及其他信息，没关系，笔者这里有一个小窍门，大家可以找到之前用开发者证书或企业证书打包过的App(例如叫Demo)，然后在终端中输入以下命令即可找到相关信息，命令如下：
./ldid -e ./Demo.app/demo

给微信重新签名
接下来把我们生成的dylib(libautoGetRedEnv.dylib)、刚刚注入dylib的WeChat、以及embedded.mobileprovision文件(可以在之前打包过的App中找到)拷贝到WeChat.app中。

命令格式：codesign -f -s 证书名字 目标文件

    PS:证书名字可以在钥匙串中找到

分别用codesign命令来为微信中的相关文件签名,具体实现如下：

重新签名
</code></pre>

<p><img src="http://al1020119.github.io/images/weixinhongbao0013.jpg" title="Caption" ><br/>
    打包成ipa
    给微信重新签名后，我们就可以用xcrun来生成ipa了，具体实现如下：
    xcrun -sdk iphoneos PackageApplication -v WeChat.app  -o ~/WeChat.ipa</p>

<h1>安装拥有抢红包功能的微信</h1>

<p>以上步骤如果都成功实现的话，那么真的就是万事俱备，只欠东风了~~~</p>

<p>我们可以使用iTools工具，来为iPhone(此iPhone Device id需加入证书中)安装改良过的微信了。</p>

<p>iTools
<img src="http://al1020119.github.io/images/weixinhongbao0014.jpg" title="Caption" ></p>

<h1>大工告成！！</h1>

<p>好了，我们可以看看hook过的微信抢红包效果了~</p>

<p>自动抢红包
<img src="http://al1020119.github.io/images/weixinhongbao0015.gif" title="Caption" ><br/>
哈哈，是不是觉得很爽啊，"妈妈再也不用担心我抢红包了。"。大家如果有兴趣可以继续hook微信的其他函数，这样既加强了学习，又满足了自己的特(zhuang)殊(bi)需求嘛。</p>

<p>教程中所涉及到的工具及源代码笔者都上传到Github上。
Github地址</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[重整之道（面试+技术+底层+高级）]]></title>
    <link href="http://al1020119.github.io/blog/2016/07/26/chongzhengzhidao/"/>
    <updated>2016-07-26T13:53:19+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/07/26/chongzhengzhidao</id>
    <content type="html"><![CDATA[<p>重整之道（面试+技术+底层+高级）</p>

<p>不要问我为什么写这篇文章。</p>

<p>我，就是这么有尿性。。。。。。。。。。</p>

<p>前面三部分已经基本上完成，后面部分会陆续更新，敬请期待。但是光靠一篇这么短的文章想将通这些事不可能的，这里主要正对面试族，或者健忘族，亦或者是装逼族。好了废话不多说，我们开始吧！</p>

<ul>
<li>运行时（底层）</li>
<li>RunLoop（底层）</li>
<li>多线程（底层与安全）</li>
</ul>


<hr />

<ul>
<li>网络（底层与安全）</li>
<li>数据持久化（各种使用与区别）（CoreData、SQLite）</li>
<li>Block（底层/__Block）</li>
<li>音视频</li>
<li>直播</li>
<li>安全</li>
<li>优化（性能、卡顿）</li>
<li>常见错误</li>
<li>常用技术</li>
<li>全栈相关</li>
<li>算法（常用、排序）</li>
<li>数据结构</li>
<li>设计模式（32中）</li>
<li>架构设计</li>
<li>逆向工程</li>
<li>实战应用</li>
</ul>


<!--more-->


<h3>运行时（底层）</h3>

<h6>介绍</h6>

<p>runtime是一个c和汇编写的动态库(感谢Lision的指正)，是一套比较底层的C语言API，属于一个C语言库，平时我们所写的OC代码，最终都会转成runtime的C语言代码去执行。</p>

<p>这个系统主要做两件事 ：</p>

<ol>
<li>封装C语言的结构体和函数，让开发者在运行时创建、检查或者修改类、对象和方法等等。</li>
<li>传递消息，找出方法的最终执行代码。</li>
</ol>


<h6>常用关键字</h6>

<p>要想全面了解 Runtime 机制，我们必须先了解 Runtime 的一些术语，他们都对应着数据结构。</p>

<p>SEL</p>

<pre><code>它是selector在 Objc 中的表示(Swift 中是 Selector 类)。selector 是方法选择器，其实作用就和名字一样，日常生活中，我们通过人名辨别谁是谁，注意 Objc 在相同的类中不会有命名相同的两个方法。selector 对方法名进行包装，以便找到对应的方法实现。它的数据结构是：

typedef struct objc_selector *SEL;

我们可以看出它是个映射到方法的 C 字符串，你可以通过 Objc 编译器器命令@selector() 或者 Runtime 系统的 sel_registerName 函数来获取一个 SEL 类型的方法选择器。

注意：
不同类中相同名字的方法所对应的 selector 是相同的，由于变量的类型不同，所以不会导致它们调用方法实现混乱。
</code></pre>

<p>id</p>

<pre><code>id 是一个参数类型，它是指向某个类的实例的指针。定义如下：

以上定义，看到 objc_object 结构体包含一个 isa 指针，根据 isa 指针就可以找到对象所属的类。

注意：
isa 指针在代码运行时并不总指向实例对象所属的类型，所以不能依靠它来确定类型，要想确定类型还是需要用对象的 -class 方法。

PS:KVO 的实现机理就是将被观察对象的 isa 指针指向一个中间类而不是真实类型，详见:KVO章节。
</code></pre>

<p>Class</p>

<pre><code>typedef struct objc_class *Class;

Class 其实是指向 objc_class 结构体的指针。

一个运行时类中关联了它的父类指针、类名、成员变量、方法、缓存以及附属的协议。


由此可见，我们可以动态修改 *methodList 的值来添加成员方法，这也是 Category 实现的原理，同样解释了 Category 不能添加属性的原因。这里可以参考下美团技术团队的文章：深入理解 Objective-C: Category。

objc_ivar_list 结构体用来存储成员变量的列表，而 objc_ivar 则是存储了单个成员变量的信息；同理，objc_method_list 结构体存储着方法数组的列表，而单个方法的信息则由 objc_method 结构体存储。

值得注意的时，objc_class 中也有一个 isa 指针，这说明 Objc 类本身也是一个对象。为了处理类和对象的关系，Runtime 库创建了一种叫做 Meta Class(元类) 的东西，类对象所属的类就叫做元类。Meta Class 表述了类对象本身所具备的元数据。

我们所熟悉的类方法，就源自于 Meta Class。我们可以理解为类方法就是类对象的实例方法。每个类仅有一个类对象，而每个类对象仅有一个与之相关的元类。

当你发出一个类似 [NSObject alloc](类方法) 的消息时，实际上，这个消息被发送给了一个类对象(Class Object)，这个类对象必须是一个元类的实例，而这个元类同时也是一个根元类(Root Meta Class)的实例。所有元类的 isa 指针最终都指向根元类。

所以当 [NSObject alloc] 这条消息发送给类对象的时候，运行时代码 objc_msgSend() 会去它元类中查找能够响应消息的方法实现，如果找到了，就会对这个类对象执行方法调用。



super_class 指针，虚线时 isa 指针。而根元类的父类是 NSObject，isa指向了自己。而 NSObject 没有父类。

最后 objc_class 中还有一个 objc_cache ，缓存，它的作用很重要，后面会提到。
</code></pre>

<p>Method</p>

<pre><code>Method 代表类中某个方法的类型

typedef struct objc_method *Method;

objc_method 存储了方法名，方法类型和方法实现：

方法名类型为 SEL
方法类型 method_types 是个 char 指针，存储方法的参数类型和返回值类型
method_imp 指向了方法的实现，本质是一个函数指针
</code></pre>

<p>Ivar</p>

<pre><code>Ivar 是表示成员变量的类型。

typedef struct objc_ivar *Ivar;


其中 ivar_offset 是基地址偏移字节
</code></pre>

<p>IMP</p>

<pre><code>IMP在objc.h中的定义是：

typedef id (*IMP)(id, SEL, ...);

它就是一个函数指针，这是由编译器生成的。当你发起一个 ObjC 消息之后，最终它会执行的那段代码，就是由这个函数指针指定的。而 IMP 这个函数指针就指向了这个方法的实现。

如果得到了执行某个实例某个方法的入口，我们就可以绕开消息传递阶段，直接执行方法，这在后面 Cache 中会提到。

你会发现 IMP 指向的方法与 objc_msgSend 函数类型相同，参数都包含 id 和 SEL 类型。每个方法名都对应一个 SEL 类型的方法选择器，而每个实例对象中的 SEL 对应的方法实现肯定是唯一的，通过一组 id和 SEL 参数就能确定唯一的方法实现地址。

而一个确定的方法也只有唯一的一组 id 和 SEL 参数。
</code></pre>

<p>Cache</p>

<pre><code>typedef struct objc_cache *Cache

Cache 为方法调用的性能进行优化，每当实例对象接收到一个消息时，它不会直接在 isa 指针指向的类的方法列表中遍历查找能够响应的方法，因为每次都要查找效率太低了，而是优先在 Cache 中查找。

Runtime 系统会把被调用的方法存到 Cache 中，如果一个方法被调用，那么它有可能今后还会被调用，下次查找的时候就会效率更高。就像计算机组成原理中 CPU 绕过主存先访问 Cache 一样。
</code></pre>

<p>Property
    typedef struct objc_property *objc_property_t;//这个更常用</p>

<pre><code>可以通过class_copyPropertyList 和 protocol_copyPropertyList 方法获取类和协议中的属性：

注意：
返回的是属性列表，列表中每个元素都是一个 objc_property_t 指针
</code></pre>

<h6>动态特性</h6>

<pre><code>Objective-C具有相当多的动态特性，基本的，也是经常被提到和用到的有

    动态类型（Dynamic typing）
    动态绑定（Dynamic binding）
    动态加载（Dynamic loading）

动态类型：程序直到执行时才能确定所属的类。

id 数据类型，id 通用的对象类型，可以存储任意类型的对象，id后面没有号，它本身就是个指针，类似于void ，但只可以指向对象类型

静态类型与动态类型

    编译期检查与运行时检查
    静态类型在编译期就能检查出错误
    静态类型声明代码可读性好
    动态类型只有在运行时才能发现错误

动态绑定：程序直到执行时才能确定实际要调用的方法。

动态绑定所做的，即是在实例所属类确定后，将某些属性和相应的方法绑定到实例上。

说明：objective-c 中的BOOL实际上是一种对带符号的字符类型（signed char）的类型定义（typedef），它使用8位的存储空间。通过#define指令把YES定义为1，NO定义为0。

动态加载：根据需求加载所需要的资源

这点很容易理解，对于iOS开发来说，基本就是根据不同的机型做适配。最经典的例子就是在Retina设备上加载@2x的图片，而在老一些的普通屏设备上加载原图。随着Retina iPad的推出，和之后可能的Retina Mac的出现，这个特性相信会被越来越多地使用。
多态的出现时为了让不同的类能使用同名的方法。这个让程序的可读性大大提高，也降低了编程难度。

动态类型与动态绑定是为了解决随多态的便利而引起的弊端，有了动态类型与动态绑定，不用去考虑输出中的方法是哪个类型的方法，会自动判定。

而id类型的出现就是为了更好的承接动态类型与动态方法出来的返回值。
</code></pre>

<h6>常用方法</h6>

<p>Ivar <em>ivars = class_copyIvarList([iCocosObject class], &amp;count);
Method </em>met = class_copyMethodList([iCocosObject class], &amp;meth);
objc_property_t *xsL = class_copyPropertyList([iCocosObject class], &amp;xs);
Method ic =  class_getInstanceMethod(NSClassFromString(@&ldquo;<em>NSArrayM&rdquo;), @selector(iCocosobject:));
Method add =  class_getInstanceMethod(NSClassFromString(@&ldquo;</em>NSArrayM&rdquo;), @selector(addObject:));</p>

<pre><code>objc_msgSend : 给对象发送消息
class_copyMethodList : 遍历某个类所有的方法
class_copyIvarList : 遍历某个类所有的成员变量
class_..... 这是我们学习runtime必须知道的函数！
</code></pre>

<h6>属性与成员变量</h6>

<p>Ivar: 实例变量类型，是一个指向objc_ivar结构体的指针。objc_property_t：声明的属性的类型，是一个指向objc_property结构体的指针</p>

<ol>
<li>属性变量 是已经设置了 setter getter方法的 OC已经自己给设置了</li>
<li>属性变量 你每次调用 self.属性变量 的时候 都要调用getter或者setter方法
封装</li>
</ol>


<p>如果成员变量是private，程序中的其它对象很难直接访问该成员变量。如果是属性，相对更容易用父类方法读写属性。</p>

<p>性能</p>

<pre><code>成员变量地址可以根据实例的内存地址偏移寻址。而属性的读写都需要函数调用，相对更慢。
</code></pre>

<p>非基础类型</p>

<pre><code>对于复杂的C++类型，往往设为成员变量更合适，也许这种类型不支持copy，或者完全复制很麻烦。
</code></pre>

<p>多线程</p>

<pre><code>多线程环境下，为保证数据一致性，在需要同步执行的代码段更应该使用成员变量。如果对需要同步更新的数据用getter/setter 方法，数据更新效率低，会带来更多的获取锁请求失败。
</code></pre>

<p>程序正确性</p>

<pre><code>成员变量可以做直观的内存管理。属性可以一层层继承，还可以复写。容易出错。
</code></pre>

<p>二进制文件的体积</p>

<pre><code>默认用属性，会生成不必要的getter/setter 方法，程序体积会变大。
</code></pre>

<p>1.如果只是单纯的private变量，最好声明在implementation里.
2.如果是类的public属性，就用property写在.h文件里
3.如果自己内部需要setter和getter来实现一些东西，就在.m文件的类目里用property来声明</p>

<h6>消息机制消息机制</h6>

<pre><code>[obj makeText];==objc_msgSend(obj, @selector (makeText));


首先通过obj的isa指针找到obj对应的class。

首先检测这个 selector 是不是要忽略。比如 Mac OS X 开发，有了垃圾回收就不理会 retain，release 这些函数。
检测这个 selector 的 target 是不是 nil，Objc 允许我们对一个 nil 对象执行任何方法不会 Crash，因为运行时会被忽略掉。
如果上面两步都通过了，那么就开始查找这个类的实现 IMP，
在Class中先去cache中 通过SEL查找对应函数method，找到就执行对应的实现。
若cache中未找到，再去methodList中查找，找到就执行对应的实现。
若methodlist中未找到，则取superClass中查找（重复执行以上两个步骤），直到找到最根的类为止。
若任何一部能找到，则将method加 入到cache中，以方便下次查找，并通过method中的函数指针跳转到对应的函数中去执行。
如果以上都不能找到，则会开始进行消息转发
</code></pre>

<h6>消息转发</h6>

<pre><code>1.动态方法解析：向当前类发送 resolveInstanceMethod: 信号，检查是否动态向该类添加了方法。（迷茫请搜索：@dynamic）
2.快速消息转发：检查该类是否实现了 forwardingTargetForSelector: 方法，若实现了则调用这个方法。若该方法返回值对象非nil或非self，则向该返回对象重新发送消息。
3.标准消息转发：runtime发送methodSignatureForSelector:消息获取Selector对应的方法签名。返回值非空则通过forwardInvocation:转发消息，返回值为空则向当前对象发送doesNotRecognizeSelector:消息，程序崩溃退出

总结就是：
在一个函数找不到时，OC提供了三种方式去补救：
1、调用resolveInstanceMethod给个机会让类添加这个实现这个函数
2、调用forwardingTargetForSelector让别的对象去执行这个函数
3、调用forwardInvocation（函数执行器）灵活的将目标函数以其他形式执行。
如果都不中，调用doesNotRecognizeSelector抛出异常。
</code></pre>

<h6>常见用途</h6>

<ul>
<li>增加，删除，修改一个类，属性，成员变量，方法</li>
</ul>


<h6>实际应用</h6>

<ul>
<li>关联对象</li>
<li>方法混淆</li>
<li>NSCoding(归档和解档, 利用runtime遍历模型对象的所有属性)</li>
<li>字典 &ndash;> 模型 (利用runtime遍历模型对象的所有属性, 根据属性名从字典中取出对应的值, 设置到模型的属性上)</li>
<li>KVO(利用runtime动态产生一个类)</li>
<li>用于封装框架(想怎么改就怎么改) 这就是我们runtime机制的只要运用方向</li>
</ul>


<h3>RunLoop（底层）</h3>

<h6>RunLoop 的简单概述</h6>

<p>RunLoop:</p>

<pre><code>   Runloop是事件接收和分发机制的一个实现。

   Runloop提供了一种异步执行代码的机制，不能并行执行任务。

   在主队列中，Main RunLoop直接配合任务的执行，负责处理UI事件、定时器以及其他内核相关事件。
</code></pre>

<p>主要目的：</p>

<pre><code>   保证程序执行的线程不会被系统终止。   
</code></pre>

<p>使用Runloop ？</p>

<pre><code>   当需要和该线程进行交互的时候才会使用Runloop.


   每一个线程都有其对应的RunLoop，但是默认非主线程的RunLoop是没有运行的，需要为RunLoop添加至少一个事件源，然后去run它。


   一般情况下我们是没有必要去启用线程的RunLoop的，除非你在一个单独的线程中需要长久的检测某个事件。
</code></pre>

<p>主线程默认有Runloop。当自己启动一个线程，如果只是用于处理单一的事件，则该线程在执行完之后就退出了。所以当我们需要让该线程监听某项事务
时，就得让线程一直不退出，runloop就是这么一个循环，没有事件的时候，一直卡着，有事件来临了，执行其对应的函数。</p>

<pre><code>   RunLoop,正如其名所示,是线程进入和被线程用来相应事件以及调用事件处理函数的地方.需要在代码中使用控制语句实现RunLoop的循环,也就是说,需要代码提供while或者for循环来驱动RunLoop.


   在这个循环中,使用一个runLoop对象[NSRunloop currentRunloop]执行接收消息,调用对应的处理函数.


    Runloop接收两种源事件:input sources和timer sources。


   input sources 传递异步事件，通常是来自其他线程和不同的程序中的消息；


   timer sources(定时器) 传递同步事件（重复执行或者在特定时间上触发）。


   除了处理input sources，Runloop
</code></pre>

<p>也会产生一些关于本身行为的notificaiton。注册成为Runloop的observer，可以接收到这些notification，做一些额外
的处理。（使用CoreFoundation来成为runloop的observer）。</p>

<p>Runloop工作的特点:</p>

<pre><code>   1&gt;当有时间发生时,Runloop会根据具体的事件类型通知应用程序作出相应;


   2&gt;当没有事件发生时,Runloop会进入休眠状态,从而达到省电的目的;


   3&gt;当事件再次发生时,Runloop会被重新唤醒,处理事件.
</code></pre>

<p>提示:一般在开发中很少会主动创建Runloop,而通常会把事件添加到Runloop中.</p>

<p>苹果提供了两个途径来获取分别是Cocoe里面定义的NSRunLoop以及CoreFoundation里面定义的CFRunLoopRef。</p>

<pre><code>CFRunLoopRef提供了纯C函数的API，所有这些API都是线程安全的。
NSRunLoop提供了面向对象的API，但这些API不是线程安全的。
</code></pre>

<h6>RunLoop 与线程的关系</h6>

<p>iOS 开发中能遇到两个线程对象: pthread_t 和 NSThread。过去苹果有份文档标明了 NSThread 只是 pthread_t 的封装，但那份文档已经失效了，现在它们也有可能都是直接包装自最底层的 mach thread。苹果并没有提供这两个对象相互转换的接口，但不管怎么样，可以肯定的是 pthread_t 和 NSThread 是一一对应的。比如，你可以通过 pthread_main_np() 或 [NSThread mainThread] 来获取主线程；也可以通过 pthread_self() 或 [NSThread currentThread] 来获取当前线程。CFRunLoop 是基于 pthread 来管理的。</p>

<p>苹果不允许直接创建 RunLoop，它只提供了两个自动获取的函数：CFRunLoopGetMain() 和 CFRunLoopGetCurrent()。</p>

<p>线程和 RunLoop 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 RunLoop（主线程除外）。</p>

<h6>RunLoop 的 Mode</h6>

<ol>
<li><p>kCFRunLoopDefaultMode: App的默认 Mode，通常主线程是在这个 Mode 下运行的。</p></li>
<li><p>UITrackingRunLoopMode: 界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响。</p></li>
<li><p>UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用。</p></li>
<li><p>GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到。</p></li>
<li><p>kCFRunLoopCommonModes: 这是一个占位的 Mode，没有实际作用。</p></li>
</ol>


<p>你可以在这里看到更多的苹果内部的 Mode，但那些 Mode 在开发中就很难遇到了。</p>

<p>一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。</p>

<h6>RunLoop 的底层实现(内部逻辑)</h6>

<p>RunLoop 的核心是基于 mach port 的，其进入休眠时调用的函数是 mach_msg()</p>

<p>RunLoop 的核心就是一个 mach_msg() (见上面代码的第7步)，RunLoop 调用这个函数去接收消息，如果没有别人发送 port 消息过来，内核会将线程置于等待状态。例如你在模拟器里跑起一个 iOS 的 App，然后在 App 静止时点击暂停，你会看到主线程调用栈是停留在 mach_msg_trap() 这个地方。</p>

<h6>应用</h6>

<ul>
<li><p>AutoreleasePool</p></li>
<li><p>事件响应</p></li>
<li><p>手势识别</p></li>
<li><p>界面更新</p></li>
<li><p>定时器</p></li>
<li><p>PerformSelecter</p></li>
<li><p>关于GCD</p></li>
<li><p>关于网络请求</p></li>
<li><p>AFNetworking</p></li>
<li><p>AsyncDisplayKit</p></li>
</ul>


<h3>多线程（底层与安全）</h3>

<p>线程：1个进程要想执行任务，必须得有线程.线程是进程的基本执行单元，一个进程（程序）的所有任务都在线程中执行</p>

<p>底层：Mach是第一个以多线程方式处理任务的系统，因此多线程的底层实现机制是基于Mach的线程。</p>

<pre><code> 1》C语言的POSIX接口：#include&lt;pthread.h&gt;POSIX线程（POSIX threads），简称Pthreads，是线程的POSIX标准。该标准定义了创建和操纵线程的一整套API。在类Unix操作系统（Unix、Linux、Mac OS X等）中，都使用Pthreads作为操作系统的线程
 2》OC的NSThread
 3》 C语言的GCD接口（性能最好，代码更精简）  
 4》  OC的NSOperation和NSOperationQueue（基于GCD）
</code></pre>

<p>好处：</p>

<pre><code>1、使用线程可以把程序中占据时间长的任务放到后台去处理，如图片、视频的下载

2、发挥多核处理器的优势，并发执行让系统运行的更快、更流畅，用户体验更好
</code></pre>

<p>缺点：</p>

<pre><code>1、大量的线程降低代码的可读性，

2、更多的线程需要更多的内存空间

3、当多个线程对同一个资源出现争夺的时候要注意线程安全的问题。
</code></pre>

<p>GCD内部怎么实现的</p>

<pre><code>  1》 iOS和OSX的核心是XNU内核（苹果电脑发展的操作系统内核），GCD是基于XNU内核实现的。
  2》GCD的API全部在libdispatch库中
  3》GCD的底层实现主要有：Dispatch Queue和Dispatch Source
    Dispatch Queue :管理block操作
    Dispatch Source：处理事件（比如说线程间的通信）
</code></pre>

<p>6.GCD和NSOperationQueue</p>

<pre><code>   1》GCD是纯C语言的API，NSOperationQueue是基于GCD的OC版本的封装
   2》GCD只支持FIFO的队列，NSOperationQueue可以很方便的调整执行顺序，可以添加依赖设置最大并发数量。
   3》GCD的执行速度比NSOperationQueue快
   4》NSOperationQueue支持KVO，可以检测Operation是否正在执行，是否结束，是否取消。
</code></pre>

<p>如何进行选择？
任务之间不太相互依赖，选用GCD；
任务之间有依赖，或者要监听任务的执行情况：NSOperationQueue</p>

<p>一、前言
     1》只在主线程刷新访问UI
     2》如果要防止资源抢夺，得用synchronize进行加锁保护。
     3》如果异步操作要保证线程安全等问题，尽量使用GCD。（GCD有些函数默认就是安全的）</p>

<p>前段时间看了几个开源项目，发现他们保持线程同步的方式各不相同，有@synchronized、NSLock、dispatch_semaphore、NSCondition、pthread_mutex、OSSpinLock。后来网上查了一下，发现他们的实现机制各不相同，性能也各不一样。不好意思，我们平常使用最多的@synchronized是性能最差的。下面我们先分别介绍每个加锁方式的使用，在使用一个案例来对他们进行性能对比。</p>

<p>二、介绍与使用</p>

<p>2.1、@synchronized</p>

<pre><code>NSObject *obj = [[NSObject alloc] init];
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    @synchronized(obj) {
       NSLog(@"需要线程同步的操作1 开始");
       sleep(3);
       NSLog(@"需要线程同步的操作1 结束");
    }
});
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    sleep(1);
    @synchronized(obj) {
       NSLog(@"需要线程同步的操作2");
    }
});
</code></pre>

<p>@synchronized(obj)指令使用的obj为该锁的唯一标识，只有当标识相同时，才为满足互斥，如果线程2中的@synchronized(obj)改为@synchronized(self),刚线程2就不会被阻塞，@synchronized指令实现锁的优点就是我们不需要在代码中显式的创建锁对象，便可以实现锁的机制，但作为一种预防措施，@synchronized块会隐式的添加一个异常处理例程来保护代码，该处理例程会在异常抛出的时候自动的释放互斥锁。所以如果不想让隐式的异常处理例程带来额外的开销，你可以考虑使用锁对象。</p>

<p>2.2、dispatch_semaphore</p>

<pre><code>dispatch_semaphore_t signal = dispatch_semaphore_create(1);
dispatch_time_t overTime = dispatch_time(DISPATCH_TIME_NOW, 3 * NSEC_PER_SEC);
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    dispatch_semaphore_wait(signal, overTime);
            NSLog(@"需要线程同步的操作1 开始");
            sleep(2);
            NSLog(@"需要线程同步的操作1 结束");
        dispatch_semaphore_signal(signal);
});
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        sleep(1);
        dispatch_semaphore_wait(signal, overTime);
            NSLog(@"需要线程同步的操作2");
        dispatch_semaphore_signal(signal);
});
</code></pre>

<p>dispatch_semaphore是GCD用来同步的一种方式，与他相关的共有三个函数，分别是dispatch_semaphore_create，dispatch_semaphore_signal，dispatch_semaphore_wait。</p>

<p>（1）dispatch_semaphore_create的声明为：</p>

<p>dispatch_semaphore_t dispatch_semaphore_create(long value);</p>

<p>传入的参数为long，输出一个dispatch_semaphore_t类型且值为value的信号量。</p>

<p>值得注意的是，这里的传入的参数value必须大于或等于0，否则dispatch_semaphore_create会返回NULL。</p>

<p>（2）dispatch_semaphore_signal的声明为：</p>

<p>long dispatch_semaphore_signal(dispatch_semaphore_t dsema);</p>

<p>这个函数会使传入的信号量dsema的值加1；</p>

<p>(3) dispatch_semaphore_wait的声明为：</p>

<p>long dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout);</p>

<p>这个函数会使传入的信号量dsema的值减1；这个函数的作用是这样的，如果dsema信号量的值大于0，该函数所处线程就继续执行下面的语句，并且将信号量的值减1；如果desema的值为0，那么这个函数就阻塞当前线程等待timeout（注意timeout的类型为dispatch_time_t，不能直接传入整形或float型数），如果等待的期间desema的值被dispatch_semaphore_signal函数加1了，且该函数（即dispatch_semaphore_wait）所处线程获得了信号量，那么就继续向下执行并将信号量减1。如果等待期间没有获取到信号量或者信号量的值一直为0，那么等到timeout时，其所处线程自动执行其后语句。</p>

<p>dispatch_semaphore 是信号量，但当信号总量设为 1 时也可以当作锁来。在没有等待情况出现时，它的性能比 pthread_mutex 还要高，但一旦有等待情况出现时，性能就会下降许多。相对于 OSSpinLock 来说，它的优势在于等待时不会消耗 CPU 资源。</p>

<p>如上的代码，如果超时时间overTime设置成>2，可完成同步操作。如果overTime&lt;2的话，在线程1还没有执行完成的情况下，此时超时了，将自动执行下面的代码。</p>

<p>2.3、NSLock</p>

<pre><code>NSLock *lock = [[NSLock alloc] init];
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    //[lock lock];
    [lock lockBeforeDate:[NSDate date]];
    NSLog(@"需要线程同步的操作1 开始");
    sleep(2);
    NSLog(@"需要线程同步的操作1 结束");
    [lock unlock];
});
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    sleep(1);
    if ([lock tryLock]) {//尝试获取锁，如果获取不到返回NO，不会阻塞该线程
        NSLog(@"锁可用的操作");
        [lock unlock];
    }else{
        NSLog(@"锁不可用的操作");
    }
    NSDate *date = [[NSDate alloc] initWithTimeIntervalSinceNow:3];
    if ([lock lockBeforeDate:date]) {//尝试在未来的3s内获取锁，并阻塞该线程，如果3s内获取不到恢复线程, 返回NO,不会阻塞该线程
        NSLog(@"没有超时，获得锁");
        [lock unlock];
    }else{
        NSLog(@"超时，没有获得锁");
    }
});
</code></pre>

<p>NSLock是Cocoa提供给我们最基本的锁对象，这也是我们经常所使用的，除lock和unlock方法外，NSLock还提供了tryLock和lockBeforeDate:两个方法，前一个方法会尝试加锁，如果锁不可用(已经被锁住)，刚并不会阻塞线程，并返回NO。lockBeforeDate:方法会在所指定Date之前尝试加锁，如果在指定时间之前都不能加锁，则返回NO。</p>

<pre><code>@protocol NSLocking
- (void)lock;
- (void)unlock;
@end
@interface NSLock : NSObject  {
@private
    void *_priv;
}
- (BOOL)tryLock;
- (BOOL)lockBeforeDate:(NSDate *)limit;
@property (nullable, copy) NSString *name NS_AVAILABLE(10_5, 2_0);
@end
</code></pre>

<p>2.4、NSRecursiveLock递归锁</p>

<pre><code>//NSLock *lock = [[NSLock alloc] init];
NSRecursiveLock *lock = [[NSRecursiveLock alloc] init];
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
       static void (^RecursiveMethod)(int);
       RecursiveMethod = ^(int value) {
       [lock lock];
         if (value &gt; 0) {
                NSLog(@"value = %d", value);
                sleep(1);
                RecursiveMethod(value - 1);
          }
         [lock unlock];
     };
     RecursiveMethod(5);
});
</code></pre>

<p>NSRecursiveLock实际上定义的是一个递归锁，这个锁可以被同一线程多次请求，而不会引起死锁。这主要是用在循环或递归操作中。</p>

<p>这段代码是一个典型的死锁情况。在我们的线程中，RecursiveMethod是递归调用的。所以每次进入这个block时，都会去加一次锁，而从第二次开始，由于锁已经被使用了且没有解锁，所以它需要等待锁被解除，这样就导致了死锁，线程被阻塞住了。调试器中会输出如下信息：</p>

<p>在这种情况下，我们就可以使用NSRecursiveLock。它可以允许同一线程多次加锁，而不会造成死锁。递归锁会跟踪它被lock的次数。每次成功的lock都必须平衡调用unlock操作。只有所有达到这种平衡，锁最后才能被释放，以供其它线程使用。</p>

<p>如果我们将NSLock代替为NSRecursiveLock，上面代码则会正确执行。</p>

<p>如果需要其他功能，源码定义如下：</p>

<pre><code>@interface NSRecursiveLock : NSObject  {
@private
    void *_priv;
}
- (BOOL)tryLock;
- (BOOL)lockBeforeDate:(NSDate *)limit;
@property (nullable, copy) NSString *name NS_AVAILABLE(10_5, 2_0);
@end
</code></pre>

<p>2.5、NSConditionLock条件锁</p>

<pre><code>NSMutableArray *products = [NSMutableArray array];
NSInteger HAS_DATA = 1;
NSInteger NO_DATA = 0;
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    while (1) {
        [lock lockWhenCondition:NO_DATA];
        [products addObject:[[NSObject alloc] init]];
        NSLog(@"produce a product,总量:%zi",products.count);
        [lock unlockWithCondition:HAS_DATA];
        sleep(1);
    }
});
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    while (1) {
       NSLog(@"wait for product");
        [lock lockWhenCondition:HAS_DATA];
       [products removeObjectAtIndex:0];
       NSLog(@"custome a product");
       [lock unlockWithCondition:NO_DATA];
    }
});
</code></pre>

<p>当我们在使用多线程的时候，有时一把只会lock和unlock的锁未必就能完全满足我们的使用。因为普通的锁只能关心锁与不锁，而不在乎用什么钥匙才能开锁，而我们在处理资源共享的时候，多数情况是只有满足一定条件的情况下才能打开这把锁：</p>

<p>在线程1中的加锁使用了lock，所以是不需要条件的，所以顺利的就锁住了，但在unlock的使用了一个整型的条件，它可以开启其它线程中正在等待这把钥匙的临界地，而线程2则需要一把被标识为2的钥匙，所以当线程1循环到最后一次的时候，才最终打开了线程2中的阻塞。但即便如此，NSConditionLock也跟其它的锁一样，是需要lock与unlock对应的，只是lock,lockWhenCondition:与unlock，unlockWithCondition:是可以随意组合的，当然这是与你的需求相关的。</p>

<p>如果你需要其他功能，源码定义如下：</p>

<pre><code>@interface NSConditionLock : NSObject  {
@private
    void *_priv;
}
- (instancetype)initWithCondition:(NSInteger)condition NS_DESIGNATED_INITIALIZER;
@property (readonly) NSInteger condition;
- (void)lockWhenCondition:(NSInteger)condition;
- (BOOL)tryLock;
- (BOOL)tryLockWhenCondition:(NSInteger)condition;
- (void)unlockWithCondition:(NSInteger)condition;
- (BOOL)lockBeforeDate:(NSDate *)limit;
- (BOOL)lockWhenCondition:(NSInteger)condition beforeDate:(NSDate *)limit;
@property (nullable, copy) NSString *name NS_AVAILABLE(10_5, 2_0);
@end
</code></pre>

<p>2.6、NSCondition</p>

<pre><code>NSCondition *condition = [[NSCondition alloc] init];
NSMutableArray *products = [NSMutableArray array];
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        while (1) {
            [condition lock];
            if ([products count] == 0) {
                NSLog(@"wait for product");
                [condition wait];
            }
            [products removeObjectAtIndex:0];
            NSLog(@"custome a product");
            [condition unlock];
        }
    });
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        while (1) {
            [condition lock];
            [products addObject:[[NSObject alloc] init]];
            NSLog(@"produce a product,总量:%zi",products.count);
            [condition signal];
            [condition unlock];
            sleep(1);
        }
});
</code></pre>

<p>一种最基本的条件锁。手动控制线程wait和signal。</p>

<p>[condition lock];一般用于多线程同时访问、修改同一个数据源，保证在同一时间内数据源只被访问、修改一次，其他线程的命令需要在lock 外等待，只到unlock ，才可访问</p>

<p>[condition unlock];与lock 同时使用</p>

<p>[condition wait];让当前线程处于等待状态</p>

<p>[condition signal];CPU发信号告诉线程不用在等待，可以继续执行</p>

<p>2.7、pthread_mutex</p>

<pre><code>__block pthread_mutex_t theLock;
pthread_mutex_init(&amp;theLock, NULL);
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        pthread_mutex_lock(&amp;theLock);
        NSLog(@"需要线程同步的操作1 开始");
        sleep(3);
        NSLog(@"需要线程同步的操作1 结束");
        pthread_mutex_unlock(&amp;theLock);
});
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        sleep(1);
        pthread_mutex_lock(&amp;theLock);
        NSLog(@"需要线程同步的操作2");
        pthread_mutex_unlock(&amp;theLock);
});
</code></pre>

<p>c语言定义下多线程加锁方式。</p>

<p>1：pthread_mutex_init(pthread_mutex_t mutex,const pthread_mutexattr_t attr);</p>

<p>初始化锁变量mutex。attr为锁属性，NULL值为默认属性。</p>

<p>2：pthread_mutex_lock(pthread_mutex_t mutex);加锁</p>

<p>3：pthread_mutex_tylock(<em>pthread_mutex_t </em>mutex);加锁，但是与2不一样的是当锁已经在使用的时候，返回为EBUSY，而不是挂起等待。</p>

<p>4：pthread_mutex_unlock(pthread_mutex_t *mutex);释放锁</p>

<p>5：pthread_mutex_destroy(pthread_mutex_t* mutex);使用完后释放</p>

<p>代码执行操作结果如下：</p>

<p>2.8、pthread_mutex(recursive)</p>

<pre><code> __block pthread_mutex_t theLock;
//pthread_mutex_init(&amp;theLock, NULL);
pthread_mutexattr_t attr;
pthread_mutexattr_init(&amp;attr);
pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE);
pthread_mutex_init(&amp;lock, &amp;attr);
pthread_mutexattr_destroy(&amp;attr);
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    static void (^RecursiveMethod)(int);
    RecursiveMethod = ^(int value) {
            pthread_mutex_lock(&amp;theLock);
            if (value &gt; 0) {
                NSLog(@"value = %d", value);
                sleep(1);
                RecursiveMethod(value - 1);
            }
            pthread_mutex_unlock(&amp;theLock);
     };
    RecursiveMethod(5);
});
</code></pre>

<p>这是pthread_mutex为了防止在递归的情况下出现死锁而出现的递归锁。作用和NSRecursiveLock递归锁类似。</p>

<p>如果使用pthread_mutex_init(&amp;theLock, NULL);初始化锁的话，上面的代码会出现死锁现象。如果使用递归锁的形式，则没有问题。</p>

<p>2.9、OSSpinLock</p>

<pre><code>__block OSSpinLock theLock = OS_SPINLOCK_INIT;
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    OSSpinLockLock(&amp;theLock);
    NSLog(@"需要线程同步的操作1 开始");
    sleep(3);
    NSLog(@"需要线程同步的操作1 结束");
    OSSpinLockUnlock(&amp;theLock);
});
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    OSSpinLockLock(&amp;theLock);
    sleep(1);
    NSLog(@"需要线程同步的操作2");
    OSSpinLockUnlock(&amp;theLock);
});
</code></pre>

<p>OSSpinLock 自旋锁，性能最高的锁。原理很简单，就是一直 do while 忙等。它的缺点是当等待时会消耗大量 CPU 资源，所以它不适用于较长时间的任务。 不过最近YY大神在自己的博客不再安全的 OSSpinLock中说明了OSSpinLock已经不再安全，请大家谨慎使用。</p>

<p>三、性能对比</p>

<pre><code>OSSpinLock和dispatch_semaphore的效率远远高于其他。

@synchronized和NSConditionLock效率较差。

鉴于OSSpinLock的不安全，所以我们在开发中如果考虑性能的话，建议使用dispatch_semaphore。

如果不考虑性能，只是图个方便的话，那就使用@synchronized。
</code></pre>

<h3>网络（底层与安全）</h3>

<h3>数据持久化（各种使用与区别）（CoreData、SQLite）</h3>

<h3>Block（底层/__Block）</h3>

<h3>音视频</h3>

<h3>直播</h3>

<h3>安全</h3>

<h3>优化（性能、卡顿）</h3>

<h3>常见错误</h3>

<h3>常用技术</h3>

<p>KVC</p>

<pre><code>KVC运用了一个isa-swizzling技术。isa-swizzling就是类型混合指针机制。KVC主要通过isa-swizzling，来实现其内部查找定位的。isa指针，如其名称所指，（就是is a kind of的意思），指向维护分发表的对象的类。该分发表实际上包含了指向实现类中的方法的指针，和其它数据
一个对象在调用setValue的时候，（1）首先根据方法名找到运行方法的时候所需要的环境参数。（2）他会从自己isa指针结合环境参数，找到具体的方法实现的接口。（3）再直接查找得来的具体的方法实现。
</code></pre>

<p>KVO</p>

<pre><code>观察者为一个对象的属性进行了注册，被观察对象的isa指针被修改的时候，isa指针就会指向一个中间类（setter/getter方法），而不是真实的类。所以isa指针其实不需要指向实例对象真实的类。所以我们的程序最好不要依赖于isa指针。在调用类的方法的时候，最好要明确对象实例的类名。
熟悉KVO的朋友都知道，只有当我们调用KVC去访问key值的时候KVO才会起作用。所以肯定确定的是，KVO是基于KVC实现的。其实看了上面我们的分析以后，关系KVO的架构的构思也就水到渠成了。
</code></pre>

<p>任何工程产品（注意是任何工程产品）都可以使用以下两种方法之一进行测试。
黑盒测试：已知产品的功能设计规格，可以进行测试证明每个实现了的功能是否符合要求。
白盒测试：已知产品的内部工作过程，可以通过测试证明每种内部操作是否符合设计规格要求，所有内部成分是否以经过检查。</p>

<h5>黑盒测试</h5>

<p>软件的黑盒测试意味着测试要在软件的接口处进行。这种方法是把测试对象看做一个黑盒子，测试人员完全不考虑程序内部的逻辑结构和内部特性，只依据程序的需求规格说明书，检查程序的功能是否符合它的功能说明。因此黑盒测试又叫功能测试或数据驱动测试。</p>

<pre><code>黑盒测试主要是为了发现以下几类错误：
1、是否有不正确或遗漏的功能？
2、在接口上，输入是否能正确的接受？能否输出正确的结果？
3、是否有数据结构错误或外部信息（例如数据文件）访问错误？
4、性能上是否能够满足要求？
5、是否有初始化或终止性错误？
</code></pre>

<h5>白盒测试</h5>

<p>软件的白盒测试是对软件的过程性细节做细致的检查。这种方法是把测试对象看做一个打开的盒子，它允许测试人员利用程序内部的逻辑结构及有关信息，设计或选择测试用例，对程序所有逻辑路径进行测试。通过在不同点检查程序状态，确定实际状态是否与预期的状态一致。因此白盒测试又称为结构测试或逻辑驱动测试。</p>

<pre><code>白盒测试主要是想对程序模块进行如下检查：
1、对程序模块的所有独立的执行路径至少测试一遍。
2、对所有的逻辑判定，取“真”与取“假”的两种情况都能至少测一遍。
3、在循环的边界和运行的界限内执行循环体。
4、测试内部数据结构的有效性，等等。
</code></pre>

<p>以上事实说明，软件测试有一个致命的缺陷，即测试的不完全、不彻底性。由于任何程序只能进行少量（相对于穷举的巨大数量而言）的有限的测试，在未发现错误时，不能说明程序中没有错误。</p>

<h5>灰盒测试</h5>

<p>灰盒测试，是介于白盒测试与黑盒测试之间的，可以这样理解，灰盒测试关注输出对于输入的正确性，同时也关注内部表现，但这种关注不象白盒那样详细、完整，只是通过一些表征性的现象、事件、标志来判断内部的运行状态，有时候输出是正确的，但内部其实已经错误了，这种情况非常多，如果每次都通过白盒测试来操作，效率会很低，因此需要采取这样的一种灰盒的方法。</p>

<h3>全栈相关</h3>

<h3>算法（常用、排序）</h3>

<h3>数据结构</h3>

<h3>设计模式（32中）</h3>

<h3>架构设计</h3>

<h3>逆向工程</h3>

<h3>实战应用</h3>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[多线程之葵花宝典]]></title>
    <link href="http://al1020119.github.io/blog/2016/07/10/duoxianc/"/>
    <updated>2016-07-10T14:59:42+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/07/10/duoxianc</id>
    <content type="html"><![CDATA[<h2>一、进程和线程</h2>

<h4>1.什么是进程</h4>

<pre><code>进程是指在系统中正在运行的一个应用程序

每个进程之间是独立的，每个进程均运行在其专用且受保护的内存空间内





比如同时打开QQ、Xcode，系统就会分别启动2个进程

通过“活动监视器”可以查看Mac系统中所开启的进程
</code></pre>

<!--more-->


<h4>2.什么是线程</h4>

<pre><code>1个进程要想执行任务，必须得有线程（每1个进程至少要有1条线程）

线程是进程的基本执行单元，一个进程（程序）的所有任务都在线程中执行

比如使用酷狗播放音乐、使用迅雷下载电影，都需要在线程中执行
</code></pre>

<p> 　　</p>

<h4>3.线程的串行</h4>

<pre><code>1个线程中任务的执行是串行的

如果要在1个线程中执行多个任务，那么只能一个一个地按顺序执行这些任务

也就是说，在同一时间内，1个线程只能执行1个任务

比如在1个线程中下载3个文件（分别是文件A、文件B、文件C）
</code></pre>

<h2>二、多线程</h2>

<h4>1.什么是多线程</h4>

<pre><code>1个进程中可以开启多条线程，每条线程可以并行（同时）执行不同的任务

进程 -&gt;车间，线程-&gt;车间工人

多线程技术可以提高程序的执行效率

比如同时开启3条线程分别下载3个文件（分别是文件A、文件B、文件C）
</code></pre>

<h4>2.多线程的原理</h4>

<pre><code>同一时间，CPU只能处理1条线程，只有1条线程在工作（执行）
多线程并发（同时）执行，其实是CPU快速地在多条线程之间调度（切换）
如果CPU调度线程的时间足够快，就造成了多线程并发执行的假象
思考：如果线程非常非常多，会发生什么情况？
CPU会在N多线程之间调度，CPU会累死，消耗大量的CPU资源
每条线程被调度执行的频次会降低（线程的执行效率降低）
</code></pre>

<h4>3.多线程的优缺点</h4>

<p>多线程的优点</p>

<pre><code>能适当提高程序的执行效率

能适当提高资源利用率（CPU、内存利用率）
</code></pre>

<p>多线程的缺点</p>

<pre><code>开启线程需要占用一定的内存空间（默认情况下，主线程占用1M，子线程占用512KB），如果开启大量的线程，会占用大量的内存空间，降低程序的性能

线程越多，CPU在调度线程上的开销就越大

程序设计更加复杂：比如线程之间的通信、多线程的数据共享
</code></pre>

<h4>4.多线程在iOS开发中的应用</h4>

<pre><code>主线程:一个iOS程序运行后，默认会开启1条线程，称为“主线程”或“UI线程”

主线程的主要作用

显示\刷新UI界面

处理UI事件（比如点击事件、滚动事件、拖拽事件等）
</code></pre>

<p>主线程的使用注意:别将比较耗时的操作放到主线程中。</p>

<p>耗时操作会卡住主线程，严重影响UI的流畅度，给用户一种“卡”的坏体验</p>

<h2>多线程的四中方式</h2>

<h4>1. Pthreads</h4>

<h4>2. NSThread</h4>

<h4>3. GCD</h4>

<h4>4. NSOperation &amp; NSOperationQueue</h4>

<h2>多线程的全解析-看了不信你还不会？</h2>

<p><img src="http://al1020119.github.io/images/multithread.png" title="Caption" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CoreData 😘 SQLite 😍 FMDB]]></title>
    <link href="http://al1020119.github.io/blog/2016/07/05/zsqlfmdbcoredata/"/>
    <updated>2016-07-05T14:59:42+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/07/05/zsqlfmdbcoredata</id>
    <content type="html"><![CDATA[<p>概览</p>

<p>在iOS开发中数据存储的方式可以归纳为两类：一类是存储为文件，另一类是存储到数据库。例如前面IOS开发系列—Objective-C之Foundation框架的文章中提到归档、plist文件存储，包括偏好设置其本质都是存储为文件，只是说归档或者plist文件存储可以选择保存到沙盒中，而偏好设置系统已经规定只能保存到沙盒的Library/Preferences目录。当然，文件存储并不作为本文的重点内容。本文重点还是说数据库存储，做过数据库开发的朋友应该知道，可以通过SQL直接访问数据库，也可以通过ORM进行对象关系映射访问数据库。这两种方式恰恰对应iOS中SQLite和Core Data的内容，在此将重点进行分析:</p>

<h3>1. SQLite</h3>

<h3>2. Core Data</h3>

<h3>3. FMDB</h3>

<!--more-->


<hr />

<h2>SQLite</h2>

<p>SQLite是目前主流的嵌入式关系型数据库，其最主要的特点就是轻量级、跨平台，当前很多嵌入式操作系统都将其作为数据库首选。虽然SQLite是一款轻型数据库，但是其功能也绝不亚于很多大型关系数据库。学习数据库就要学习其相关的定义、操作、查询语言，也就是大家日常说得SQL语句。和其他数据库相比，SQLite中的SQL语法并没有太大的差别，因此这里对于SQL语句的内容不会过多赘述，大家可以参考SQLite中其他SQL相关的内容，这里还是重点讲解iOS中如何使用SQLite构建应用程序。先看一下SQLite数据库的几个特点：</p>

<ol>
<li><p>基于C语言开发的轻型数据库</p></li>
<li><p>在iOS中需要使用C语言语法进行数据库操作、访问（无法使用ObjC直接访问，因为libqlite3框架基于C语言编写）</p></li>
<li><p>SQLite中采用的是动态数据类型，即使创建时定义了一种类型，在实际操作时也可以存储其他类型，但是推荐建库时使用合适的类型（特别是应用需要考虑跨平台的情况时）</p></li>
<li><p>建立连接后通常不需要关闭连接（尽管可以手动关闭）</p></li>
</ol>


<p>要使用SQLite很简单，如果在Mac OSX上使用可以考虑到SQLite官方网站下载命令行工具，也可以使用类似于SQLiteManager、Navicat for SQLite等工具。为了方便大家开发调试，建议在开发环境中安装上述工具。</p>

<p>在iOS中操作SQLite数据库可以分为以下几步（注意先在项目中导入libsqlite3框架）：</p>

<ol>
<li><p>打开数据库，利用sqlite3_open()打开数据库会指定一个数据库文件保存路径，如果文件存在则直接打开，否则创建并打开。打开数据库会得到一个sqlite3类型的对象，后面需要借助这个对象进行其他操作。</p></li>
<li><p>执行SQL语句，执行SQL语句又包括有返回值的语句和无返回值语句。</p></li>
<li><p>对于无返回值的语句（如增加、删除、修改等）直接通过sqlite3_exec()函数执行；</p></li>
<li><p>对于有返回值的语句则首先通过sqlite3_prepare_v2()进行sql语句评估（语法检测），然后通过sqlite3_step()依次取出查询结果的每一行数据，对于每行数据都可以通过对应的sqlite3_column_类型()方法获得对应列的数据，如此反复循环直到遍历完成。当然，最后需要释放句柄。</p></li>
</ol>


<p>在整个操作过程中无需管理数据库连接，对于嵌入式SQLite操作是持久连接（尽管可以通过sqlite3_close()关闭），不需要开发人员自己释放连接。纵观整个操作过程，其实与其他平台的开发没有明显的区别，较为麻烦的就是数据读取，在iOS平台中使用C进行数据读取采用了游标的形式，每次只能读取一行数据，较为麻烦。因此实际开发中不妨对这些操作进行封装：</p>

<p>KCDbManager.h
    //
    //  DbManager.h
    //  DataAccess
    //
    //  Created by Kenshin Cui on 14-3-29.
    //  Copyright &copy; 2014年 Kenshin Cui. All rights reserved.
    //
    #import &lt;Foundation/Foundation.h>
    #import &lt;sqlite3.h>
    #import &ldquo;KCSingleton.h&rdquo;
    @interface KCDbManager : NSObject
    singleton_interface(KCDbManager);
    #pragma mark - 属性
    #pragma mark 数据库引用，使用它进行数据库操作
    @property (nonatomic) sqlite3 <em>database;
    #pragma mark - 共有方法
    /**
     *  打开数据库
     *
     *  @param dbname 数据库名称
     </em>/
    -(void)openDb:(NSString <em>)dbname;
    /**
     *  执行无返回值的sql
     *
     *  @param sql sql语句
     </em>/
    -(void)executeNonQuery:(NSString <em>)sql;
    /**
     *  执行有返回值的sql
     *
     *  @param sql sql语句
     *
     *  @return 查询结果
     </em>/
    -(NSArray <em>)executeQuery:(NSString </em>)sql;
    @end</p>

<pre><code>KCDbManager.m
//
//  DbManager.m
//  DataAccess
//
//  Created by Kenshin Cui on 14-3-29.
//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.
//
#import "KCDbManager.h"
#import &lt;sqlite3.h&gt;
#import "KCSingleton.h"
#import "KCAppConfig.h"
#ifndef kDatabaseName
#define kDatabaseName @"myDatabase.db"
#endif
@interface KCDbManager()
@end
@implementation KCDbManager
singleton_implementation(KCDbManager)
#pragma mark 重写初始化方法
-(instancetype)init{
    KCDbManager *manager;
    if((manager=[super init]))
    {
        [manager openDb:kDatabaseName];
    }
    return manager;
}
-(void)openDb:(NSString *)dbname{
    //取得数据库保存路径，通常保存沙盒Documents目录
    NSString *directory=[NSSearchPathForDirectoriesInDomains(NSDocumentationDirectory, NSUserDomainMask, YES) firstObject];
    NSLog(@"%@",directory);
    NSString *filePath=[directory stringByAppendingPathComponent:dbname];
    //如果有数据库则直接打开，否则创建并打开（注意filePath是ObjC中的字符串，需要转化为C语言字符串类型）
    if (SQLITE_OK ==sqlite3_open(filePath.UTF8String, &amp;_database)) {
        NSLog(@"数据库打开成功!");
    }else{
        NSLog(@"数据库打开失败!");
    }
}
-(void)executeNonQuery:(NSString *)sql{
    char *error;
    //单步执行sql语句，用于插入、修改、删除
    if (SQLITE_OK!=sqlite3_exec(_database, sql.UTF8String, NULL, NULL,&amp;error)) {
        NSLog(@"执行SQL语句过程中发生错误！错误信息：%s",error);
    }
}
-(NSArray *)executeQuery:(NSString *)sql{
    NSMutableArray *rows=[NSMutableArray array];//数据行

    //评估语法正确性
    sqlite3_stmt *stmt;
    //检查语法正确性
    if (SQLITE_OK==sqlite3_prepare_v2(_database, sql.UTF8String, -1, &amp;stmt, NULL)) {
        //单步执行sql语句
        while (SQLITE_ROW==sqlite3_step(stmt)) {
            int columnCount= sqlite3_column_count(stmt);
            NSMutableDictionary *dic=[NSMutableDictionary dictionary];
            for (int i=0; i&lt;columnCount; i++) {
                const char *name= sqlite3_column_name(stmt, i);//取得列名
                const unsigned char *value= sqlite3_column_text(stmt, i);//取得某列的值
                dic[[NSString stringWithUTF8String:name]]=[NSString stringWithUTF8String:(const char *)value];
            }
            [rows addObject:dic];
        }
    }

    //释放句柄
    sqlite3_finalize(stmt);

    return rows;
}
@end
</code></pre>

<p>在上面的类中对于数据库操作进行了封装，封装之后数据操作更加方便，同时所有的语法都由C转换成了ObjC。</p>

<p>下面仍然以微博查看为例进行SQLite演示。当然实际开发中微博数据是从网络读取的，但是考虑到缓存问题，通常会选择将微博数据保存到本地，下面的Demo演示了将数据存放到本地数据库以及数据读取的过程。当然，实际开发中并不会在视图控制器中直接调用数据库操作方法，在这里通常会引入两个概念Model和Service。Model自不必多说，就是MVC中的模型。而Service指的是操作数据库的服务层，它封装了对于Model的基本操作方法，实现具体的业务逻辑。为了解耦，在控制器中是不会直接接触数据库的，控制器中只和模型（模型是领域的抽象）、服务对象有关系，借助服务层对模型进行各类操作，模型的操作反应到数据库中就是对表中数据的操作。具体关系如下：</p>

<p><img src="http://al1020119.github.io/images/CSR001.jpg" title="Caption" ></p>

<p>要完成上述功能，首先定义一个应用程序全局对象进行数据库、表的创建。为了避免每次都创建数据库和表出错，这里利用了偏好设置进行保存当前创建状态（其实这也是数据存储的一部分），如果创建过了数据库则不再创建，否则创建数据库和表。</p>

<p>KCDatabaseCreator.m</p>

<pre><code>//
//  KCDatabaseCreator.m
//  DataAccess
//
//  Created by Kenshin Cui on 14-3-29.
//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.
//
#import "KCDatabaseCreator.h"
#import "KCDbManager.h"
@implementation KCDatabaseCreator
+(void)initDatabase{
    NSString *key=@"IsCreatedDb";
    NSUserDefaults *defaults=[[NSUserDefaults alloc]init];
    if ([[defaults valueForKey:key] intValue]!=1) {
        [self createUserTable];
        [self createStatusTable];
        [defaults setValue:@1 forKey:key];
    }
}
+(void)createUserTable{
    NSString *sql=@"CREATE TABLE User (Id integer PRIMARY KEY AUTOINCREMENT,name text,screenName text, profileImageUrl text,mbtype text,city text)";
    [[KCDbManager sharedKCDbManager] executeNonQuery:sql];
}
+(void)createStatusTable{
    NSString *sql=@"CREATE TABLE Status (Id integer PRIMARY KEY AUTOINCREMENT,source text,createdAt date,\"text\" text,user integer REFERENCES User (Id))";
    [[KCDbManager sharedKCDbManager] executeNonQuery:sql];
}
@end
</code></pre>

<p>其次，定义数据模型，这里定义用户User和微博Status两个数据模型类。注意模型应该尽量保持其单纯性，仅仅是简单的POCO，不要引入视图、控制器等相关内容。</p>

<p>KCUser.h</p>

<pre><code>//
//  KCUser.h
//  UrlConnection
//
//  Created by Kenshin Cui on 14-3-22.
//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.
//
#import &lt;Foundation/Foundation.h&gt;
@interface KCUser : NSObject
#pragma mark 编号
@property (nonatomic,strong) NSNumber *Id;
#pragma mark 用户名
@property (nonatomic,copy) NSString *name;
#pragma mark 用户昵称
@property (nonatomic,copy) NSString *screenName;
#pragma mark 头像
@property (nonatomic,copy) NSString *profileImageUrl;
#pragma mark 会员类型
@property (nonatomic,copy) NSString *mbtype;
#pragma mark 城市
@property (nonatomic,copy) NSString *city;
#pragma mark - 动态方法
/**
 *  初始化用户
 *
 *  @param name 用户名
 *  @param city 所在城市
 *
 *  @return 用户对象
 */
-(KCUser *)initWithName:(NSString *)name screenName:(NSString *)screenName profileImageUrl:(NSString *)profileImageUrl mbtype:(NSString *)mbtype city:(NSString *)city;
/**
 *  使用字典初始化用户对象
 *
 *  @param dic 用户数据
 *
 *  @return 用户对象
 */
-(KCUser *)initWithDictionary:(NSDictionary *)dic;
#pragma mark - 静态方法
+(KCUser *)userWithName:(NSString *)name screenName:(NSString *)screenName profileImageUrl:(NSString *)profileImageUrl mbtype:(NSString *)mbtype city:(NSString *)city;
@end
</code></pre>

<p>KCUser.m</p>

<pre><code>//
//  KCUser.m
//  UrlConnection
//
//  Created by Kenshin Cui on 14-3-22.
//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.
//
#import "KCUser.h"
@implementation KCUser
-(KCUser *)initWithName:(NSString *)name screenName:(NSString *)screenName profileImageUrl:(NSString *)profileImageUrl mbtype:(NSString *)mbtype city:(NSString *)city{
    if (self=[super init]) {
        self.name=name;
        self.screenName=screenName;
        self.profileImageUrl=profileImageUrl;
        self.mbtype=mbtype;
        self.city=city;
    }
    return self;
}
-(KCUser *)initWithDictionary:(NSDictionary *)dic{
    if (self=[super init]) {
        [self setValuesForKeysWithDictionary:dic];
    }
    return self;
}
+(KCUser *)userWithName:(NSString *)name screenName:(NSString *)screenName profileImageUrl:(NSString *)profileImageUrl mbtype:(NSString *)mbtype city:(NSString *)city{
    KCUser *user=[[KCUser alloc]initWithName:name screenName:screenName profileImageUrl:profileImageUrl mbtype:mbtype city:city];
    return user;
}
</code></pre>

<p>@end</p>

<p>KCStatus.h</p>

<pre><code>//
//  KCStatus.h
//  UITableView
//
//  Created by Kenshin Cui on 14-3-1.
//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.
//
#import &lt;Foundation/Foundation.h&gt;
#import "KCUser.h"
@interface KCStatus : NSObject
#pragma mark - 属性
@property (nonatomic,strong) NSNumber *Id;//微博id
@property (nonatomic,strong) KCUser *user;//发送用户
@property (nonatomic,copy) NSString *createdAt;//创建时间
@property (nonatomic,copy) NSString *source;//设备来源
@property (nonatomic,copy) NSString *text;//微博内容
#pragma mark - 动态方法
/**
 *  初始化微博数据
 *
 *  @param createAt        创建日期
 *  @param source          来源
 *  @param text            微博内容
 *  @param user            发送用户
 *
 *  @return 微博对象
 */
-(KCStatus *)initWithCreateAt:(NSString *)createAt source:(NSString *)source text:(NSString *)text user:(KCUser *)user;
/**
 *  初始化微博数据
 *
 *  @param profileImageUrl 用户头像
 *  @param mbtype          会员类型
 *  @param createAt        创建日期
 *  @param source          来源
 *  @param text            微博内容
 *  @param userId          用户编号
 *
 *  @return 微博对象
 */
-(KCStatus *)initWithCreateAt:(NSString *)createAt source:(NSString *)source text:(NSString *)text userId:(int)userId;
/**
 *  使用字典初始化微博对象
 *
 *  @param dic 字典数据
 *
 *  @return 微博对象
 */
-(KCStatus *)initWithDictionary:(NSDictionary *)dic;
#pragma mark - 静态方法
/**
 *  初始化微博数据
 *
 *  @param createAt        创建日期
 *  @param source          来源
 *  @param text            微博内容
 *  @param user            发送用户
 *
 *  @return 微博对象
 */
+(KCStatus *)statusWithCreateAt:(NSString *)createAt source:(NSString *)source text:(NSString *)text user:(KCUser *)user;
/**
 *  初始化微博数据
 *
 *  @param profileImageUrl 用户头像
 *  @param mbtype          会员类型
 *  @param createAt        创建日期
 *  @param source          来源
 *  @param text            微博内容
 *  @param userId          用户编号
 *
 *  @return 微博对象
 */
+(KCStatus *)statusWithCreateAt:(NSString *)createAt source:(NSString *)source text:(NSString *)text userId:(int)userId;
@end
</code></pre>

<p>KCStatus.m</p>

<pre><code>//
//  KCStatus.m
//  UITableView
//
//  Created by Kenshin Cui on 14-3-1.
//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.
//
#import "KCStatus.h"
@implementation KCStatus
-(KCStatus *)initWithDictionary:(NSDictionary *)dic{
    if (self=[super init]) {
        [self setValuesForKeysWithDictionary:dic];
        self.user=[[KCUser alloc]init];
        self.user.Id=dic[@"user"];
    }
    return self;
}
-(KCStatus *)initWithCreateAt:(NSString *)createAt source:(NSString *)source text:(NSString *)text user:(KCUser *)user{
    if (self=[super init]) {
        self.createdAt=createAt;
        self.source=source;
        self.text=text;
        self.user=user;
    }
    return self;
}
-(KCStatus *)initWithCreateAt:(NSString *)createAt source:(NSString *)source text:(NSString *)text userId:(int)userId{
    if (self=[super init]) {
        self.createdAt=createAt;
        self.source=source;
        self.text=text;
        KCUser *user=[[KCUser alloc]init];
        user.Id=[NSNumber numberWithInt:userId];
        self.user=user;
    }
    return self;
}
-(NSString *)source{
    return [NSString stringWithFormat:@"来自 %@",_source];
}
+(KCStatus *)statusWithCreateAt:(NSString *)createAt source:(NSString *)source text:(NSString *)text user:(KCUser *)user{
    KCStatus *status=[[KCStatus alloc]initWithCreateAt:createAt source:source text:text user:user];
    return status;
}
+(KCStatus *)statusWithCreateAt:(NSString *)createAt source:(NSString *)source text:(NSString *)text userId:(int)userId{
    KCStatus *status=[[KCStatus alloc]initWithCreateAt:createAt source:source text:text userId:userId];
    return status;
}
@end
</code></pre>

<p>然后，编写服务类，进行数据的增、删、改、查操作，由于服务类方法同样不需要过多的配置，因此定义为单例，保证程序中只有一个实例即可。服务类中调用前面封装的数据库方法将对数据库的操作转换为对模型的操作。</p>

<p>KCUserService.h</p>

<pre><code>//
//  KCUserService.h
//  DataAccess
//
//  Created by Kenshin Cui on 14-3-29.
//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.
//
#import &lt;Foundation/Foundation.h&gt;
#import "KCUser.h"
#import "KCSingleton.h"
@interface KCUserService : NSObject
singleton_interface(KCUserService)
/**
 *  添加用户信息
 *
 *  @param user 用户对象
 */
-(void)addUser:(KCUser *)user;
/**
 *  删除用户
 *
 *  @param user 用户对象
 */
-(void)removeUser:(KCUser *)user;
/**
 *  根据用户名删除用户
 *
 *  @param name 用户名
 */
-(void)removeUserByName:(NSString *)name;
/**
 *  修改用户内容
 *
 *  @param user 用户对象
 */
-(void)modifyUser:(KCUser *)user;
/**
 *  根据用户编号取得用户
 *
 *  @param Id 用户编号
 *
 *  @return 用户对象
 */
-(KCUser *)getUserById:(int)Id;
/**
 *  根据用户名取得用户
 *
 *  @param name 用户名
 *
 *  @return 用户对象
 */
-(KCUser *)getUserByName:(NSString *)name;
@end
</code></pre>

<p>KCUserService.m</p>

<pre><code>//
//  KCUserService.m
//  DataAccess
//
//  Created by Kenshin Cui on 14-3-29.
//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.
//
#import "KCUserService.h"
#import "KCUser.h"
#import "KCDbManager.h"
@implementation KCUserService
singleton_implementation(KCUserService)
-(void)addUser:(KCUser *)user{
    NSString *sql=[NSString stringWithFormat:@"INSERT INTO User (name,screenName, profileImageUrl,mbtype,city) VALUES('%@','%@','%@','%@','%@')",user.name,user.screenName, user.profileImageUrl,user.mbtype,user.city];
    [[KCDbManager sharedKCDbManager] executeNonQuery:sql];
}
-(void)removeUser:(KCUser *)user{
    NSString *sql=[NSString stringWithFormat:@"DELETE FROM User WHERE Id='%@'",user.Id];
    [[KCDbManager sharedKCDbManager] executeNonQuery:sql];
}
-(void)removeUserByName:(NSString *)name{
    NSString *sql=[NSString stringWithFormat:@"DELETE FROM User WHERE name='%@'",name];
    [[KCDbManager sharedKCDbManager] executeNonQuery:sql];
}
-(void)modifyUser:(KCUser *)user{
    NSString *sql=[NSString stringWithFormat:@"UPDATE User SET name='%@',screenName='%@',profileImageUrl='%@',mbtype='%@',city='%@' WHERE Id='%@'",user.name,user.screenName,user.profileImageUrl,user.mbtype,user.city,user.Id];
    [[KCDbManager sharedKCDbManager] executeNonQuery:sql];
}
-(KCUser *)getUserById:(int)Id{
    KCUser *user=[[KCUser alloc]init];
    NSString *sql=[NSString stringWithFormat:@"SELECT name,screenName,profileImageUrl,mbtype,city FROM User WHERE Id='%i'", Id];
    NSArray *rows= [[KCDbManager sharedKCDbManager] executeQuery:sql];
    if (rows&amp;&amp;rows.count&gt;0) {
        [user setValuesForKeysWithDictionary:rows[0]];
    }
    return user;
}
-(KCUser *)getUserByName:(NSString *)name{
    KCUser *user=[[KCUser alloc]init];
    NSString *sql=[NSString stringWithFormat:@"SELECT Id, name,screenName,profileImageUrl,mbtype,city FROM User WHERE name='%@'", name];
    NSArray *rows= [[KCDbManager sharedKCDbManager] executeQuery:sql];
    if (rows&amp;&amp;rows.count&gt;0) {
        [user setValuesForKeysWithDictionary:rows[0]];
    }
    return user;
}
@end
</code></pre>

<p>KCStatusService.h</p>

<pre><code>//
//  KCStatusService.h
//  DataAccess
//
//  Created by Kenshin Cui on 14-3-29.
//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.
//
#import &lt;Foundation/Foundation.h&gt;
#import "KCSingleton.h"
@class KCStatus;
@interface KCStatusService : NSObject
singleton_interface(KCStatusService)
/**
 *  添加微博信息
 *
 *  @param status 微博对象
 */
-(void)addStatus:(KCStatus *)status;
/**
 *  删除微博
 *
 *  @param status 微博对象
 */
-(void)removeStatus:(KCStatus *)status;
/**
 *  修改微博内容
 *
 *  @param status 微博对象
 */
-(void)modifyStatus:(KCStatus *)status;
/**
 *  根据编号取得微博
 *
 *  @param Id 微博编号
 *
 *  @return 微博对象
 */
-(KCStatus *)getStatusById:(int)Id;
/**
 *  取得所有微博对象
 *
 *  @return 所有微博对象
 */
-(NSArray *)getAllStatus;
@end
</code></pre>

<p>KCStatusService.m</p>

<pre><code>//
//  KCStatusService.m
//  DataAccess
//
//  Created by Kenshin Cui on 14-3-29.
//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.
//
#import "KCStatusService.h"
#import "KCDbManager.h"
#import "KCStatus.h"
#import "KCUserService.h"
#import "KCSingleton.h"
@interface KCStatusService(){

}
@end
@implementation KCStatusService
singleton_implementation(KCStatusService)
-(void)addStatus:(KCStatus *)status{
    NSString *sql=[NSString stringWithFormat:@"INSERT INTO Status (source,createdAt,\"text\" ,user) VALUES('%@','%@','%@','%@')",status.source,status.createdAt,status.text,status.user.Id];
    [[KCDbManager sharedKCDbManager] executeNonQuery:sql];
}
-(void)removeStatus:(KCStatus *)status{
    NSString *sql=[NSString stringWithFormat:@"DELETE FROM Status WHERE Id='%@'",status.Id];
    [[KCDbManager sharedKCDbManager] executeNonQuery:sql];
}
-(void)modifyStatus:(KCStatus *)status{
    NSString *sql=[NSString stringWithFormat:@"UPDATE Status SET source='%@',createdAt='%@',\"text\"='%@' ,user='%@' WHERE Id='%@'",status.source,status.createdAt,status.text,status.user, status.Id];
    [[KCDbManager sharedKCDbManager] executeNonQuery:sql];
}
-(KCStatus *)getStatusById:(int)Id{
    KCStatus *status=[[KCStatus alloc]init];
    NSString *sql=[NSString stringWithFormat:@"SELECT Id, source,createdAt,\"text\" ,user FROM Status WHERE Id='%i'", Id];
    NSArray *rows= [[KCDbManager sharedKCDbManager] executeQuery:sql];
    if (rows&amp;&amp;rows.count&gt;0) {
        [status setValuesForKeysWithDictionary:rows[0]];
        status.user=[[KCUserService sharedKCUserService] getUserById:[(NSNumber *)rows[0][@"user"] intValue]] ;
    }
    return status;
}
-(NSArray *)getAllStatus{
    NSMutableArray *array=[NSMutableArray array];
    NSString *sql=@"SELECT Id, source,createdAt,\"text\" ,user FROM Status ORDER BY Id";
    NSArray *rows= [[KCDbManager sharedKCDbManager] executeQuery:sql];
    for (NSDictionary *dic in rows) {
        KCStatus *status=[self getStatusById:[(NSNumber *)dic[@"Id"] intValue]];
        [array addObject:status];
    }
    return array;
}
@end
</code></pre>

<p>最后，在视图控制器中调用相应的服务层进行各类数据操作，在下面的代码中分别演示了增、删、改、查四类操作。</p>

<pre><code>KCMainViewController.m
//
//  KCMainTableViewController.m
//  DataAccess
//
//  Created by Kenshin Cui on 14-3-29.
//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.
//
#import "KCMainTableViewController.h"
#import "KCDbManager.h"
#import "KCDatabaseCreator.h"
#import "KCUser.h"
#import "KCStatus.h"
#import "KCUserService.h"
#import "KCStatusService.h"
#import "KCStatusTableViewCell.h"
@interface KCMainTableViewController (){
    NSArray *_status;
    NSMutableArray *_statusCells;
}
@end
@implementation KCMainTableViewController
- (void)viewDidLoad {
    [super viewDidLoad];
    [KCDatabaseCreator initDatabase];

//    [self addUsers];
//    [self removeUser];
//    [self modifyUserInfo];

//    [self addStatus];

    [self loadStatusData];

}
-(void)addUsers{
    KCUser *user1=[KCUser userWithName:@"Binger" screenName:@"冰儿" profileImageUrl:@"binger.jpg" mbtype:@"mbtype.png" city:@"北京"];
    [[KCUserService sharedKCUserService] addUser:user1];
    KCUser *user2=[KCUser userWithName:@"Xiaona" screenName:@"小娜" profileImageUrl:@"xiaona.jpg" mbtype:@"mbtype.png" city:@"北京"];
    [[KCUserService sharedKCUserService] addUser:user2];
    KCUser *user3=[KCUser userWithName:@"Lily" screenName:@"丽丽" profileImageUrl:@"lily.jpg" mbtype:@"mbtype.png" city:@"北京"];
    [[KCUserService sharedKCUserService] addUser:user3];
    KCUser *user4=[KCUser userWithName:@"Qianmo" screenName:@"阡陌" profileImageUrl:@"qianmo.jpg" mbtype:@"mbtype.png" city:@"北京"];
    [[KCUserService sharedKCUserService] addUser:user4];
    KCUser *user5=[KCUser userWithName:@"Yanyue" screenName:@"炎月" profileImageUrl:@"yanyue.jpg" mbtype:@"mbtype.png" city:@"北京"];
    [[KCUserService sharedKCUserService] addUser:user5];
}
-(void)addStatus{
    KCStatus *status1=[KCStatus statusWithCreateAt:@"9:00" source:@"iPhone 6" text:@"一只雪猴在日本边泡温泉边玩iPhone的照片，获得了\"2014年野生动物摄影师\"大赛特等奖。一起来为猴子配个词" userId:1];
    [[KCStatusService sharedKCStatusService] addStatus:status1];
    KCStatus *status2=[KCStatus statusWithCreateAt:@"9:00" source:@"iPhone 6" text:@"一只雪猴在日本边泡温泉边玩iPhone的照片，获得了\"2014年野生动物摄影师\"大赛特等奖。一起来为猴子配个词" userId:1];
    [[KCStatusService sharedKCStatusService] addStatus:status2];
    KCStatus *status3=[KCStatus statusWithCreateAt:@"9:30" source:@"iPhone 6" text:@"【我们送iPhone6了 要求很简单】真心回馈粉丝，小编觉得现在最好的奖品就是iPhone6了。今起到12月31日，关注我们，转发微博，就有机会获iPhone6(奖品可能需要等待)！每月抽一台[鼓掌]。不费事，还是试试吧，万一中了呢" userId:2];
    [[KCStatusService sharedKCStatusService] addStatus:status3];
    KCStatus *status4=[KCStatus statusWithCreateAt:@"9:45" source:@"iPhone 6" text:@"重大新闻：蒂姆库克宣布出柜后，ISIS战士怒扔iPhone，沙特神职人员呼吁人们换回iPhone 4。[via Pan-Arabia Enquirer]" userId:3];
    [[KCStatusService sharedKCStatusService] addStatus:status4];
    KCStatus *status5=[KCStatus statusWithCreateAt:@"10:05" source:@"iPhone 6" text:@"小伙伴们，有谁知道怎么往Iphone4S里倒东西？倒入的东西又该在哪里找？用了Iphone这么长时间，还真的不知道怎么弄！有谁知道啊？谢谢！" userId:4];
    [[KCStatusService sharedKCStatusService] addStatus:status5];
    KCStatus *status6=[KCStatus statusWithCreateAt:@"10:07" source:@"iPhone 6" text:@"在音悦台iPhone客户端里发现一个悦单《Infinite 金明洙》，推荐给大家! " userId:1];
    [[KCStatusService sharedKCStatusService] addStatus:status6];
    KCStatus *status7=[KCStatus statusWithCreateAt:@"11:20" source:@"iPhone 6" text:@"如果sony吧mp3播放器产品发展下去，不贪图手头节目源的现实利益，就木有苹果的ipod，也就木有iphone。柯达类似的现实利益，不自我革命的案例也是一种巨头的宿命。" userId:2];
    [[KCStatusService sharedKCStatusService] addStatus:status7];
    KCStatus *status8=[KCStatus statusWithCreateAt:@"13:00" source:@"iPhone 6" text:@"【iPhone 7 Plus】新买的iPhone 7 Plus ，如何？够酷炫么？" userId:2];
    [[KCStatusService sharedKCStatusService] addStatus:status8];
    KCStatus *status9=[KCStatus statusWithCreateAt:@"13:24" source:@"iPhone 6" text:@"自拍神器#卡西欧TR500#，tr350S～价格美丽，行货，全国联保～iPhone6 iPhone6Plus卡西欧TR150 TR200 TR350 TR350S全面到货 招收各种代理！[给力]微信：39017366" userId:3];
    [[KCStatusService sharedKCStatusService] addStatus:status9];
    KCStatus *status10=[KCStatus statusWithCreateAt:@"13:26" source:@"iPhone 6" text:@"猜到猴哥玩手机时所思所想者，再奖iPhone一部。（奖品由“2014年野生动物摄影师”评委会颁发）" userId:3];
    [[KCStatusService sharedKCStatusService] addStatus:status10];
}
-(void)removeUser{
    //注意在SQLite中区分大小写
    [[KCUserService sharedKCUserService] removeUserByName:@"Yanyue"];
}
-(void)modifyUserInfo{
    KCUser *user1= [[KCUserService sharedKCUserService]getUserByName:@"Xiaona"];
    user1.city=@"上海";
    [[KCUserService sharedKCUserService] modifyUser:user1];

    KCUser *user2= [[KCUserService sharedKCUserService]getUserByName:@"Lily"];
    user2.city=@"深圳";
    [[KCUserService sharedKCUserService] modifyUser:user2];
}
#pragma mark 加载数据
-(void)loadStatusData{
    _statusCells=[[NSMutableArray alloc]init];
    _status=[[KCStatusService sharedKCStatusService]getAllStatus];
    [_status enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {
        KCStatusTableViewCell *cell=[[KCStatusTableViewCell alloc]init];
        cell.status=(KCStatus *)obj;
        [_statusCells addObject:cell];
    }];
    NSLog(@"%@",[_status lastObject]);
}
#pragma mark - Table view data source
- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView {
    return 1;
}
- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section {
    return _status.count;
}
- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {
    static NSString *identtityKey=@"myTableViewCellIdentityKey1";
    KCStatusTableViewCell *cell=[self.tableView dequeueReusableCellWithIdentifier:identtityKey];
    if(cell==nil){
        cell=[[KCStatusTableViewCell alloc]initWithStyle:UITableViewCellStyleValue1 reuseIdentifier:identtityKey];
    }
    cell.status=_status[indexPath.row];
    return cell;
}
-(CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath{
    return ((KCStatusTableViewCell *)_statusCells[indexPath.row]).height;
}
-(CGFloat)tableView:(UITableView *)tableView heightForHeaderInSection:(NSInteger)section{
    return 20.0f;
}
@end
</code></pre>

<p>项目目录结构：</p>

<p><img src="http://al1020119.github.io/images/CSR002.jpg" title="Caption" ></p>

<p>运行效果</p>

<p><img src="http://al1020119.github.io/images/CSR003.jpg" title="Caption" >
Core Data</p>

<p>基本概念</p>

<p>当前，各类应用开发中只要牵扯到数据库操作通常都会用到一个概念“对象关系映射（ORM）”。例如在Java平台使用Hibernate，在.NET平台使用Entity Framework、Linq、NHibernate等。在iOS中也不例外，iOS中ORM框架首选Core Data，这是官方推荐的，不需要借助第三方框架。无论是哪种平台、哪种技术，ORM框架的作用都是相同的，那就是将关系数据库中的表（准确的说是实体）转换为程序中的对象，其本质还是对数据库的操作（例如Core Data中如果存储类型配置为SQLite则本质还是操作的SQLite数据库）。细心的朋友应该已经注意到，在上面的SQLite中其实我们在KCMainViewController中进行的数据库操作已经转换为了对象操作，服务层中的方法中已经将对数据库的操作封装起来，转换为了对Model的操作，这种方式已经是面向对象的。上述通过将对象映射到实体的过程完全是手动完成的，相对来说操作比较复杂，就拿对KCStatus对象的操作来说：首先要手动创建数据库（Status表），其次手动创建模型KCStatus，接着创建服务层KCStatusService。Core Data正是为了解决这个问题而产生的，它将数据库的创建、表的创建、对象和表的转换等操作封装起来，简化了我们的操作（注意Core Data只是将对象关系的映射简化了，并不是把服务层替代了，这一点大家需要明白）。</p>

<p>使用Core Data进行数据库存取并不需要手动创建数据库，这个过程完全由Core Data框架完成，开发人员面对的是模型，主要的工作就是把模型创建起来，具体数据库如何创建则不用管。在iOS项目中添加“Data Model”文件。然后在其中创建实体和关系：</p>

<p><img src="http://al1020119.github.io/images/CSR004.jpg" title="Caption" >
<img src="http://al1020119.github.io/images/CSR005.jpg" title="Caption" ></p>

<p>模型创建的过程中需要注意：</p>

<p>1.实体对象不需要创建ID主键，Attributes中应该是有意义属性（创建过程中应该考虑对象的属性而不是数据库中表有几个字段，尽管多数属性会对应表的字段）。</p>

<p>2.所有的属性应该指定具体类型（尽管在SQLite中可以不指定），因为实体对象会对应生成ObjC模型类。</p>

<p>3.实体对象中其他实体对象类型的属性应该通过Relationships建立，并且注意实体之间的对应关系（例如一个用户有多条微博，而一条微博则只属于一个用户,用户和微博形成一对多的关系）。</p>

<p>以上模型创建后，接下来就是根据上面的模型文件（.xcdatamodeld文件）生成具体的实体类。在Xcode中添加“NSManagedObject Subclass”文件，按照步骤选择创建的模型及实体，Xcode就会根据所创建模型生成具体的实体类。</p>

<p>User.h</p>

<pre><code>//
//  User.h
//  CoreData
//
//  Created by Kenshin Cui on 14/03/27.
//  Copyright (c) 2014年 cmjstudio. All rights reserved.
//
#import &lt;Foundation/Foundation.h&gt;
#import &lt;CoreData/CoreData.h&gt;
@class Status;
@interface User : NSManagedObject
@property (nonatomic, retain) NSString * city;
@property (nonatomic, retain) NSString * mbtype;
@property (nonatomic, retain) NSString * name;
@property (nonatomic, retain) NSString * profileImageUrl;
@property (nonatomic, retain) NSString * screenName;
@property (nonatomic, retain) NSSet *statuses;
@end
@interface User (CoreDataGeneratedAccessors)
- (void)addStatusesObject:(Status *)value;
- (void)removeStatusesObject:(Status *)value;
- (void)addStatuses:(NSSet *)values;
- (void)removeStatuses:(NSSet *)values;
@end
</code></pre>

<p>User.m</p>

<pre><code>//
//  User.m
//  CoreData
//
//  Created by Kenshin Cui on 14/03/27.
//  Copyright (c) 2014年 cmjstudio. All rights reserved.
//
#import "User.h"
#import "Status.h"
@implementation User
@dynamic city;
@dynamic mbtype;
@dynamic name;
@dynamic profileImageUrl;
@dynamic screenName;
@dynamic statuses;
@end
</code></pre>

<p>Status.h</p>

<pre><code>//
//  Status.h
//  CoreData
//
//  Created by Kenshin Cui on 14/03/27.
//  Copyright (c) 2014年 cmjstudio. All rights reserved.
//
#import &lt;Foundation/Foundation.h&gt;
#import &lt;CoreData/CoreData.h&gt;
@interface Status : NSManagedObject
@property (nonatomic, retain) NSDate * createdAt;
@property (nonatomic, retain) NSString * source;
@property (nonatomic, retain) NSString * text;
@property (nonatomic, retain) NSManagedObject *user;
@end

Status.m


//
//  Status.m
//  CoreData
//
//  Created by Kenshin Cui on 14/03/27.
//  Copyright (c) 2014年 cmjstudio. All rights reserved.
//
#import "Status.h"
@implementation Status
@dynamic createdAt;
@dynamic source;
@dynamic text;
@dynamic user;
@end
</code></pre>

<p>很显然，通过模型生成类的过程相当简单，通常这些类也不需要手动维护，如果模型发生的变化只要重新生成即可。有几点需要注意：</p>

<p>1.所有的实体类型都继承于NSManagedObject，每个NSManagedObject对象对应着数据库中一条记录。</p>

<p>2.集合属性（例如User中的status）生成了访问此属性的分类方法。</p>

<p>3.使用@dynamic代表具体属性实现，具体实现细节不需要开发人员关心。</p>

<p>当然，了解了这些还不足以完成数据的操作。究竟Core Data具体的设计如何，要完成数据的存取我们还需要了解一下Core Data几个核心的类。</p>

<p><img src="http://al1020119.github.io/images/CSR006.jpg" title="Caption" ></p>

<ol>
<li><p>Persistent Object Store：可以理解为存储持久对象的数据库（例如SQLite，注意Core Data也支持其他类型的数据存储，例如xml、二进制数据等）。</p></li>
<li><p>Managed Object Model：对象模型，对应Xcode中创建的模型文件。</p></li>
<li><p>Persistent Store Coordinator：对象模型和实体类之间的转换协调器，用于管理不同存储对象的上下文。</p></li>
<li><p>Managed Object Context:对象管理上下文，负责实体对象和数据库之间的交互。</p></li>
</ol>


<p>Core Data使用</p>

<p>Core Data使用起来相对直接使用SQLite3的API而言更加的面向对象，操作过程通常分为以下几个步骤：</p>

<p>1.创建管理上下文</p>

<p>创建管理上下可以细分为：加载模型文件->指定数据存储路径->创建对应数据类型的存储->创建管理对象上下方并指定存储。</p>

<p>经过这几个步骤之后可以得到管理对象上下文NSManagedObjectContext，以后所有的数据操作都由此对象负责。同时如果是第一次创建上下文，Core Data会自动创建存储文件（例如这里使用SQLite3存储），并且根据模型对象创建对应的表结构。下图为第一次运行生成的数据库及相关映射文件：</p>

<p><img src="http://al1020119.github.io/images/CSR007.jpg" title="Caption" ></p>

<p>为了方便后面使用，NSManagedObjectContext对象可以作为单例或静态属性来保存，下面是创建的管理对象上下文的主要代码：</p>

<pre><code>-(NSManagedObjectContext *)createDbContext{
    NSManagedObjectContext *context;
    //打开模型文件，参数为nil则打开包中所有模型文件并合并成一个
    NSManagedObjectModel *model=[NSManagedObjectModel mergedModelFromBundles:nil];
    //创建解析器
    NSPersistentStoreCoordinator *storeCoordinator=[[NSPersistentStoreCoordinator alloc]initWithManagedObjectModel:model];
    //创建数据库保存路径
    NSString *dir=[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject];
    NSLog(@"%@",dir);
    NSString *path=[dir stringByAppendingPathComponent:@"myDatabase.db"];
    NSURL *url=[NSURL fileURLWithPath:path];
    //添加SQLite持久存储到解析器
    NSError *error;
    [storeCoordinator addPersistentStoreWithType:NSSQLiteStoreType configuration:nil URL:url options:nil error:&amp;error];
    if(error){
        NSLog(@"数据库打开失败！错误:%@",error.localizedDescription);
    }else{
        context=[[NSManagedObjectContext alloc]init];
        context.persistentStoreCoordinator=storeCoordinator;
        NSLog(@"数据库打开成功！");
    }
    return context;
}
</code></pre>

<p>2.查询数据</p>

<p>对于有条件的查询，在Core Data中是通过谓词来实现的。首先创建一个请求，然后设置请求条件，最后调用上下文执行请求的方法。</p>

<pre><code>-(void)addUserWithName:(NSString *)name screenName:(NSString *)screenName profileImageUrl:(NSString *)profileImageUrl mbtype:(NSString *)mbtype city:(NSString *)city{
    //添加一个对象
    User *us= [NSEntityDescription insertNewObjectForEntityForName:@"User" inManagedObjectContext:self.context];
    us.name=name;
    us.screenName=screenName;
    us.profileImageUrl=profileImageUrl;
    us.mbtype=mbtype;
    us.city=city;
    NSError *error;
    //保存上下文
    if (![self.context save:&amp;error]) {
        NSLog(@"添加过程中发生错误,错误信息：%@！",error.localizedDescription);
    }
}
</code></pre>

<p>如果有多个条件，只要使用谓词组合即可，那么对于关联对象条件怎么查询呢？这里分为两种情况进行介绍：</p>

<p>a.查找一个对象只有唯一一个关联对象的情况，例如查找用户名为“Binger”的微博（一个微博只能属于一个用户），通过keypath查询</p>

<pre><code>-(NSArray *)getStatusesByUserName:(NSString *)name{
    NSFetchRequest *request=[NSFetchRequest fetchRequestWithEntityName:@"Status"];
    request.predicate=[NSPredicate predicateWithFormat:@"user.name=%@",name];
    NSArray *array=[self.context executeFetchRequest:request error:nil];
    return  array;
}
</code></pre>

<p>此时如果跟踪Core Data生成的SQL语句会发现其实就是把Status表和User表进行了关联查询（JOIN连接）。</p>

<p>b.查找一个对象有多个关联对象的情况，例如查找发送微博内容中包含“Watch”并且用户昵称为“小娜”的用户（一个用户有多条微博），此时可以充分利用谓词进行过滤。</p>

<pre><code>-(NSArray *)getUsersByStatusText:(NSString *)text screenName:(NSString *)screenName{
    NSFetchRequest *request=[NSFetchRequest fetchRequestWithEntityName:@"Status"];
    request.predicate=[NSPredicate predicateWithFormat:@"text LIKE '*Watch*'",text];
    NSArray *statuses=[self.context executeFetchRequest:request error:nil];

    NSPredicate *userPredicate= [NSPredicate predicateWithFormat:@"user.screenName=%@",screenName];
    NSArray *users= [statuses filteredArrayUsingPredicate:userPredicate];
    return users;
}
</code></pre>

<p>注意：如果单纯查找微博中包含“Watch”的用户，直接查出对应的微博，然后通过每个微博的user属性即可获得用户，此时就不用使用额外的谓词过滤条件。</p>

<p>3.插入数据</p>

<p>插入数据需要调用实体描述对象NSEntityDescription返回一个实体对象，然后设置对象属性，最后保存当前上下文即可。这里需要注意，增、删、改操作完最后必须调用管理对象上下文的保存方法，否则操作不会执行。</p>

<pre><code>-(void)addUserWithName:(NSString *)name screenName:(NSString *)screenName profileImageUrl:(NSString *)profileImageUrl mbtype:(NSString *)mbtype city:(NSString *)city{
    //添加一个对象
    User *us= [NSEntityDescription insertNewObjectForEntityForName:@"User" inManagedObjectContext:self.context];
    us.name=name;
    us.screenName=screenName;
    us.profileImageUrl=profileImageUrl;
    us.mbtype=mbtype;
    us.city=city;
    NSError *error;
    //保存上下文
    if (![self.context save:&amp;error]) {
        NSLog(@"添加过程中发生错误,错误信息：%@！",error.localizedDescription);
    }
}
</code></pre>

<p>4.删除数据</p>

<p>删除数据可以直接调用管理对象上下文的deleteObject方法，删除完保存上下文即可。注意，删除数据前必须先查询到对应对象。</p>

<pre><code>-(void)removeUser:(User *)user{
    [self.context deleteObject:user];
    NSError *error;
    if (![self.context save:&amp;error]) {
        NSLog(@"删除过程中发生错误，错误信息：%@!",error.localizedDescription);
    }
}
</code></pre>

<p>5.修改数据</p>

<p>修改数据首先也是取出对应的实体对象，然后通过修改对象的属性，最后保存上下文。</p>

<pre><code>-(void)modifyUserWithName:(NSString *)name screenName:(NSString *)screenName profileImageUrl:(NSString *)profileImageUrl mbtype:(NSString *)mbtype city:(NSString *)city{
    User *us=[self getUserByName:name];
    us.screenName=screenName;
    us.profileImageUrl=profileImageUrl;
    us.mbtype=mbtype;
    us.city=city;
    NSError *error;
    if (![self.context save:&amp;error]) {
        NSLog(@"修改过程中发生错误,错误信息：%@",error.localizedDescription);
    }
}
</code></pre>

<p>调试</p>

<p>虽然Core Data（如果使用SQLite数据库）操作最终转换为SQL操作，但是调试起来却不想操作SQL那么方便。特别是对于初学者而言经常出现查询报错的问题，如果能看到最终生成的SQL语句自然对于调试很有帮助。事实上在Xcode中是支持Core Data调试的，具体操作：Product-Scheme-Edit Scheme-Run-Arguments中依次添加两个参数（注意参数顺序不能错）：-com.apple.CoreData.SQLDebug、1。然后在运行程序过程中如果操作了数据库就会将SQL语句打印在输出面板。</p>

<p><img src="http://al1020119.github.io/images/CSR008.jpg" title="Caption" ></p>

<p>注意：如果模型发生了变化，此时可以重新生成实体类文件，但是所生成的数据库并不会自动更新，这时需要考虑重新生成数据库并迁移原有的数据。</p>

<p>FMDB</p>

<p>基本使用</p>

<p>相比于SQLite3来说Core Data存在着诸多优势，它面向对象，开发人员不必过多的关心更多数据库操作知识，同时它基于ObjC操作，书写更加优雅等。但是它本身也存在着一定的限制，例如如果考虑到跨平台，则只能选择SQLite，因为无论是iOS还是Android都可以使用同一个数据库，降低了开发成本和维护成本。其次是当前多数ORM框架都存在的性能问题，因为ORM最终转化为SQL操作，其中牵扯到模型数据转化，其性能自然比不上直接使用SQL操作数据库。那么有没有更好的选择呢？答案就是对SQLite进行封装。</p>

<p>其实通过前面对于SQLite的分析，大家应该已经看到KCDbManager就是对于SQLite封装的结果，开发人员面对的只有SQL和ObjC方法，不用过多libsqlite3的C语言API。但它毕竟只是一个简单的封装，还有更多的细节没有考虑，例如如何处理并发安全性，如何更好的处理事务等。因此，这里推荐使用第三方框架FMDB，整个框架非常轻量级但又不失灵活性，也是很多企业开发的首选。</p>

<p>1.FMDB既然是对于libsqlite3框架的封装，自然使用起来也是类似的，使用前也要打开一个数据库，这个数据库文件存在则直接打开否则会创建并打开。这里FMDB引入了一个MFDatabase对象来表示数据库，打开数据库和后面的数据库操作全部依赖此对象。下面是打开数据库获得MFDatabase对象的代码：</p>

<pre><code>-(void)openDb:(NSString *)dbname{
    //取得数据库保存路径，通常保存沙盒Documents目录
    NSString *directory=[NSSearchPathForDirectoriesInDomains(NSDocumentationDirectory, NSUserDomainMask, YES) firstObject];
    NSLog(@"%@",directory);
    NSString *filePath=[directory stringByAppendingPathComponent:dbname];
    //创建FMDatabase对象
    self.database=[FMDatabase databaseWithPath:filePath];
    //打开数据上
    if ([self.database open]) {
        NSLog(@"数据库打开成功!");
    }else{
        NSLog(@"数据库打开失败!");
    }
}
</code></pre>

<p>注意：dataWithPath中的路径参数一般会选择保存到沙箱中的Documents目录中；如果这个参数设置为nil则数据库会在内存中创建；如果设置为@””则会在沙箱中的临时目录创建,应用程序关闭则文件删除。</p>

<p>2.对于数据库的操作跟前面KCDbManager的封装是类似的，在FMDB中FMDatabase类提供了两个方法executeUpdate:和executeQuery:分别用于执行无返回结果的查询和有返回结果的查询。当然这两个方法有很多的重载这里就不详细解释了。唯一需要指出的是，如果调用有格式化参数的sql语句时，格式化符号使用“?”而不是“%@”、等。下面是两种情况的代码片段：</p>

<p>a.无返回结果</p>

<p>-(void)executeNonQuery:(NSString *)sql{
    //执行更新sql语句，用于插入、修改、删除
    if (![self.database executeUpdate:sql]) {
        NSLog(@&ldquo;执行SQL语句过程中发生错误！&rdquo;);
    }
}</p>

<p>b.有返回结果</p>

<p>-(NSArray <em>)executeQuery:(NSString </em>)sql{
    NSMutableArray <em>array=[NSMutableArray array];
    //执行查询sql语句
    FMResultSet </em>result= [self.database executeQuery:sql];
    while (result.next) {
        NSMutableDictionary *dic=[NSMutableDictionary dictionary];
        for (int i=0; i&lt;result.columnCount; ++i) {
            dic[[result columnNameForIndex:i]]=[result stringForColumnIndex:i];
        }
        [array addObject:dic];
    }
    return array;
}</p>

<p>对于有返回结果的查询而言，查询完返回一个游标FMResultSet，通过遍历游标进行查询。而且FMDB中提供了大量intForColumn、stringForColumn等方法进行取值。</p>

<p>并发和事务</p>

<p>我们知道直接使用libsqlite3进行数据库操作其实是线程不安全的，如果遇到多个线程同时操作一个表的时候可能会发生意想不到的结果。为了解决这个问题建议在多线程中使用FMDatabaseQueue对象，相比FMDatabase而言，它是线程安全的。</p>

<p>创建FMDatabaseQueue的方法是类似的，调用databaseQueueWithPath:方法即可。注意这里不需要调用打开操作。</p>

<pre><code>-(void)openDb:(NSString *)dbname{
    //取得数据库保存路径，通常保存沙盒Documents目录
    NSString *directory=[NSSearchPathForDirectoriesInDomains(NSDocumentationDirectory, NSUserDomainMask, YES) firstObject];
    NSLog(@"%@",directory);
    NSString *filePath=[directory stringByAppendingPathComponent:dbname];
    //创建FMDatabaseQueue对象
    self.database=[FMDatabaseQueue databaseQueueWithPath:filePath];
}
</code></pre>

<p>然后所有的增删改查操作调用FMDatabaseQueue的inDatabase:方法在block中执行操作sql语句即可。</p>

<pre><code>-(void)executeNonQuery:(NSString *)sql{
    //执行更新sql语句，用于插入、修改、删除
    [self.database inDatabase:^(FMDatabase *db) {
        [db executeQuery:sql];
    }];
}
-(NSArray *)executeQuery:(NSString *)sql{
    NSMutableArray *array=[NSMutableArray array];
    [self.database inDatabase:^(FMDatabase *db) {
        //执行查询sql语句
        FMResultSet *result= [db executeQuery:sql];
        while (result.next) {
            NSMutableDictionary *dic=[NSMutableDictionary dictionary];
            for (int i=0; i&lt;result.columnCount; ++i) {
                dic[[result columnNameForIndex:i]]=[result stringForColumnIndex:i];
            }
            [array addObject:dic];
        }
    }];
    return array;
}
</code></pre>

<p>之所以将事务放到FMDB中去说并不是因为只有FMDB才支持事务，而是因为FMDB将其封装成了几个方法来调用，不用自己写对应的sql而已。其实在在使用libsqlite3操作数据库时也是原生支持事务的（因为这里的事务是基于数据库的，FMDB还是使用的SQLite数据库），只要在执行sql语句前加上“begin transaction;”执行完之后执行“commit transaction;”或者“rollback transaction;”进行提交或回滚即可。另外在Core Data中大家也可以发现，所有的增、删、改操作之后必须调用上下文的保存方法，其实本身就提供了事务的支持，只要不调用保存方法，之前所有的操作是不会提交的。在FMDB中FMDatabase有beginTransaction、commit、rollback三个方法进行开启事务、提交事务和回滚事务。</p>

<p>总结：</p>

<p>core data</p>

<p>core data 基于model-view-controller（mvc）模式下，为创建分解的cocoa应用程序提供了一个灵活和强大的数据模型框架。</p>

<p>core data可以使你以图形界面的方式快速的定义app的数据模型，同时在你的代码中容易获取到它。core data提供了基础结构去处理常用的功能，例如保存，恢复，撤销和重做，允许你在app中继续创建新的任务。在使用core data的时候，你不用安装额外的数据库系统，因为core data使用内置的sqlite数据库。</p>

<p>core data提供了一个通用的数据管理解决方案来处理那些所有需要数据模型的app(或大或小)。app使用core data来管理数据对象是很多的益处。</p>

<p>苹果的图形用户界面编译器-interface builder（IB），提供了对core data controller对象的预构建，从而来减少app的用户界面和它的数据模型之间的粘滞代码。在使用core data的时候你不需要考虑sql的语法问题，也不需要管理相关的逻辑树去追踪用户的行为，更不用建立新的永久机制。当你写你app的用户界面到它的 core data模型的时候，它已经为你把所有的东西都做好了。</p>

<p>core data将你app的模型层放入到一组定义在内存中的数据对象。core data会追踪这些对象的改变，同时可以根据需要做相反的改变，例如用户执行撤销命令。当core data在对你app数据的改变进行保存的时候，core data会把这些数据归档，并永久性保存。它保存的数据在一些常规的文件，你可以在Finder中可以进行管理，用spotlight进行搜索，备份到 cd，和email给朋友或者家人。</p>

<p>在使用core data框架的时候，你可以创建一个管理对象的模型，该模型提供了对模型对象的抽象定义，这也就是我们所知道的entities，它可以在我们的程序中使用。</p>

<p>core data是一个实体-关系模型，该模型是使用Xcode的数据模型设计工具来定义的，对数据实体以及他们的关系提供了丰富的环境。</p>

<p>sqlite</p>

<p>mac os x中sqlite库，它是一个轻量级功能强大的关系数据引擎，也很容易嵌入到应用程序。可以在多个平台使用，sqlite是一个轻量级的嵌入式sql数据库编程。与core data框架不同的是，sqlite是使用程序式的，sql的主要的API来直接操作数据表。</p>

<p>fmdb
FMDB框架其实只是一层很薄的封装，主要的类也就两个：FMDatabase和FMResultSet。在使用fmdb的时候还需要导入libsqlite3.0.dylib。</p>

<p>core data允许用户使用代表实体和实体间关系的高层对象来操作数据。它也可以管理串行化的数据，提供对象生存期管理与object_graph 管理，包括存储。Core Data直接与Sqlite交互，避免开发者使用原本的SQL语句.</p>

<p>上面的三种，都是在什么情况下使用呢？
在编写程序的时候尽量使用core data，这样才是最优的选择。
至于sqlite和fmdb的使用情况，这个看个人喜好了，个人觉得没什么标准。fmdb就是对sqlite的封装，使用起来有方便的接口，没那么麻烦而已。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CoreData 大战 SQLite]]></title>
    <link href="http://al1020119.github.io/blog/2016/07/05/xsqlyucoredata/"/>
    <updated>2016-07-05T14:59:42+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/07/05/xsqlyucoredata</id>
    <content type="html"><![CDATA[<p>凭良心讲，我不能告诉你不去使用Core Data。它不错，而且也在变好，并且它被很多其他Cocoa开发者所理解，当有新人加入你的组或者需要别人接手你的项目的时候，这点很重要。</p>

<p>更重要的是，不值得花时间和精力去写自己的系统去代替它。真的，使用Core Data吧。</p>

<p>为什么我不使用Core Data<br/>
 Mike Ash写到：就我自己而言，我不是个狂热粉丝。我发现API是笨拙的，并且框架本身对于大量的数据是极其缓慢的。</p>

<p>一个实际的例子：10,000条目
想象一个RSS阅读器，一个用户可以在一个feed上点击右键，并且选择标记所有为已读。</p>

<!--more-->


<p>引擎下，有一个带有read属性的Article实体。把所有条目标记为已读，程序需要加载这个feed的所有文章(可能通过一对多的关系)，然后设置read属性为YES。</p>

<p>大部分情况下这样没关系。但是设想那个feed里有200个文章，为了避免阻塞主线程，你可能考虑在后台线程里做这个工作(特别当你的程序是一个iPhone应用)。当你一开始使用Core Data多线程，事情就开始变的不好处理了。</p>

<p>这可能还凑合，至少不值得切换走Core Data。</p>

<p>但是接下来加同步。</p>

<p>我用过两种不同的获取已读文章ID列表的RSS同步接口。其中一个返回近10,000个ID。</p>

<p>你不会打算在主线程中加载10,000个文章，然后设置read为NO。你甚至不想在后台线程里加载10,000个文章，即使很小心的管理内存，这有太多的工作（如果你频繁的这么做，想一下对电池寿命的影响）。</p>

<p>你真正想要做的是，让数据库给在ID列表里的每一个文章设置read为YES。</p>

<p>SQLite可以做到这个，只用一次调用。假设uniqueID上有索引，这会很快。而且你可以在后台线程执行像在主线程执行一样容易。</p>

<p>另一个例子：快速启动
我想减少我的另一个程序的启动时间，不只是开始的时间，而是在数据显示之前的所有时间。</p>

<p>那是个类似Twitter的应用(虽然它不是)，它显示消息的时间轴。显示时间轴意味着获取消息，加载相关用户。它很快，但是在启动的时候，会填充UI，然后填充数据。</p>

<p>关于iPhone的应用（或者所有应用）我的理论是，启动时间很重要，比其他大部分开发者想的都要重要。应用的启动很慢看起来不像是要启动一样，因为人们潜意识里记得，并且会产生阻止启动应用的想法。减少启动时间就减少了摩擦，让用户更有可能继续使用你的应用，并且推荐给其他人。这是你让你的应用成功的一部分。</p>

<p>因为我不使用Core Data，我手边有一个简单的，保守的解决方案。我把timeline（消息和人物对象）通过NSCoding保存到一个plist文件中。启动的时候它读这个文件，创建消息和人物对象，UI一出现就显示时间轴。</p>

<p>这明显的减少了延迟。</p>

<p>把消息和人物对象作为NSManagedObject的实例对象，这是不可能的。（假设我有编码的并且存储的IDs对象，但是那意味着读plist然后触及数据库。这种方式我完全避免了数据库）。</p>

<p>在更新更快的机器出来后, 我去掉了那些代码。回顾过去，我希望我可以把它留下来。</p>

<p>我怎么考虑这个问题
当考虑是否使用Core Data时，我考虑下面这些事情：</p>

<p>会有难以置信数量的数据吗？
对于一个RSS阅读器或者Twitter应用，答案显而易见：是的。有些人关注上百个人。一个人可能订阅了上千个feeds。</p>

<p>即使你的应用不从网络获取数据，仍然有可能让用户自动添加数据。如果你用一个支持AppleScript的Mac，有些人会写脚本去加载非常多的数据。如果通过web API去加数据也是一样的。</p>

<p>会有一个Web API包含类似于数据库的终端吗（对比类对象终端）？
一个RSS同步API能够返回一个已读文章的uniquelIDs列表。一个记笔记的应用的一个同步API可能返回已存档的和已删除的笔记的uniquelIDs。</p>

<p>用户可能通过操作处理大量对象吗？
在底层，需要考虑和之前一样的问题。当有人删除所有下载的5，000个面食食谱，你的食谱应用可以多好的完成这个功能（在iPhone上？）？</p>

<p>当我决定使用Core Data（我已经发布过使用Core Data的应用），我会小心留意我怎么使用它。为了得到好的性能，我发现我把它当做一个SQL数据库的一个奇怪接口来使用，然后我知道我应该舍弃Core Data，直接使用SQLite。</p>

<p>我怎么使用SQLite
我通过FMDB Wrapper来使用SQLite，FMDB来自Flying Meat Software，由Gus Mueller提供。</p>

<p>基本操作
我在iPhone以前，Core Data以前就使用过SQLite。这是它怎么工作的的要点：</p>

<ol>
<li>所有数据库访问-读和写-发生在连续的队列里，在一个后台线程。在主线程中触及数据库是从来不被允许的。使用一个连续队列来保证每一件事是按顺序发生的。</li>
<li>我大量使用blocks来让异步程序容易点。</li>
<li>模型对象只存在在主线程（但有两个重要的例外），改变会触发一个后台保存。</li>
<li>模型对象列出来他们在数据库中存储的属性。可能在代码里或者在plist文件里。
5, 一些模型对象是唯一的，一些不是。取决于应用的需要（大部分情况是唯一的）。</li>
<li>对关系型数据，我尽可能避免连表查询。</li>
<li>一些对象类型在启动的时候就完全读入内存，另一些对象类型可能只需要创建并维护一个他们的uniqueIDs的。NSMutableSet，所以不需要去触及数据库，我就知道已经有什么。</li>
<li>Web API的调用发生在后台线程，他们使用分开的模型对象。
我会通过我现在的应用的代码来详细描述。</li>
</ol>


<p>数据库更新
在我最近的应用中，有一个单一的数据库控制器-VSDatabaseController，它通过FMDB来与SQLite对话。</p>

<p>FMDB区分更新和查询。更新数据库，app调用：</p>

<pre><code>-[VSDatabaseController runDatabaseBlockInTransaction:(VSDatabaseUpdateBlock)databaseBlock] 
</code></pre>

<p>VSDatabaseUpdateBlock很简单：</p>

<pre><code>typedef void (^VSDatabaseUpdateBlock)(FMDatabase *database); 
</code></pre>

<p>runDatabaseBlockInTransaction也很简单：</p>

<pre><code>- (void)runDatabaseBlockInTransaction:(VSDatabaseUpdateBlock)databaseBlock { 
    dispatch_async(self.serialDispatchQueue, ^{ 
        @autoreleasepool { 
            [self beginTransaction]; 
            databaseBlock(self.database); 
            [self endTransaction]; 
        } 
    }); 
} 
</code></pre>

<p>（注意我用自己的连续调度队列。Gus建议看一下FMDatabaseQueue，也是一个连续调度队列。我还没能去看一下，因为它比FMDB的其他东西都要新。）</p>

<p>beginTransaction和endTransaction的调用是可嵌套的（在我的数据库控制器里）。在合适的时候他们会调用-[FMDatabase beginTransaction] 和 -[FMDatabase commit]。（使用事务是让SQLite变快的关键。）提示：我把当前事务存储在-[NSThread threadDictionary]。它很好获取每一个线程的数据，我几乎从不用其他的。</p>

<p>这儿有个调用更新数据库的简单例子：</p>

<pre><code>- (void)emptyTagsLookupTableForNote:(VSNote *)note { 
    NSString *uniqueID = note.uniqueID; 
    [self runDatabaseBlockInTransaction:^(FMDatabase *database) { 
        [database executeUpdate: 
            @"delete from tagsNotesLookup where noteUniqueID = ?;", uniqueID]; 
    }]; 
} 
</code></pre>

<p>这说明一些事情。首先SQL不可怕。即使你从没见过它，你也知道这行代码做了什么。</p>

<p>像VSDatabaseController的所有其他公共接口，emptyTagsLookupTableForNote应该在主线程中被调用。模型对象只能在主线程中被引用，所以在block中用uniqueID，而不是VSNote对象。</p>

<p>注意在这种情况下，我更新了一个查找表。Notes和tags是多对多关系，一种表现方式是用一个数据库表映射note uniqueIDs和tag uniqueIDs。这些表不会很难维护，但是如果可能，我确实尝试避免他们的使用。</p>

<p>注意在更新字符串中的?。-[FMDatabase executeUpdate:] 是一个可变参数函数。SQLite支持使用占位符?，所以你不需要把正真的值放入字符串。这儿有一个安全问题：它帮助守护程序反对SQL插入。如果你需要避开某些值，它也为你省了麻烦。</p>

<p>最后，在tagsNotesLookup表中，有一个noteUniquelID的索引（索引是SQLite性能的又一个关键）。这行代码在每次启动时都调用：</p>

<pre><code>[self.database executeUpdate: 
    @"CREATE INDEX if not exists noteUniqueIDIndex on tagsNotesLookup (noteUniqueID);"]; 
</code></pre>

<p>数据库获取
要获取对象，app调用：</p>

<pre><code>-[VSDatabaseController runFetchForClass:(Class)databaseObjectClass  
                             fetchBlock:(VSDatabaseFetchBlock)fetchBlock  
                      fetchResultsBlock:(VSDatabaseFetchResultsBlock)fetchResultsBlock]; 
</code></pre>

<p>这两行代码做了大部分工作：</p>

<pre><code>FMResultSet *resultSet = fetchBlock(self.database); 
NSArray *fetchedObjects = [self databaseObjectsWithResultSet:resultSet  
                                                       class:databaseObjectClass]; 
</code></pre>

<p>用FMDB查找数据库返回一个FMResultSet. 通过resultSet你可以逐句循环，创建模型对象。</p>

<p>我建议写通用的代码去转换数据库行到对象。一种我使用的方法是用一个plist，映射column名字到对象属性。它也包含类型，所以你知道是否需要调用 -[FMResultSet dateForColumn:]， -[FMResultSet stringForColumn:]或其他。</p>

<p>在我的最新应用里我做了些简单的事情。数据库行刚好对应模型对象属性的名字。所有属性都是strings，除了那些名字以“Date”结尾的属性。很简单，但是你可以看到需要一个清晰的对应关系。</p>

<p>唯一对象
创建模型对象和从数据库获取数据在同一个后台线程。一获取到，程序会把他们转到主线程。</p>

<p>通常我有uniqued对象。同一个数据库行结果始终对应同一个对象。</p>

<p>为了做到唯一，我创建了一个对象缓存，一个NSMapTable，在init函数里：_objectCache = [NSMapTable weakToWeakObjectsMapTable]。我来解释一下：</p>

<p>例如，当你做一个数据库获取并且把对象转交给一个视图控制器，你希望在视图控制器使用完这些对象后，或者一个不一样的视图控制器显示了，这些对象可以消失。</p>

<p>如果你的对象缓存是一个NSMutableDictionary，你将需要做一些额外的工作来清空缓存中的对象。确定它对应的对象在别的地方是否有引用就变的很痛苦。NSMapTable是弱引用，就会自动处理这个问题。</p>

<p>所以：我们在主线程中让对象唯一。如果一个对象已经在对象缓存中存在，我们就用那个存在的对象。（主线程胜出，因为它可能有新的改变。）如果对象缓存中没有，它会被加上。</p>

<p>保持对象在内存中
有很多次，把整个对象类型保留在内存中是有道理的。我最新的app有一个VSTag对象。虽然可能有成百上千个笔记，但tags的数量很小，基本少于10。一个tag只有6个属性：3个BOOL，两个很小的NSstring，还有一个NSDate。</p>

<p>启动的时候，app获取所有tags并且把他们保存在两个字典里，一个主键是tag的uniqueID，另一个主键是tag名字的小写。</p>

<p>这简化了很多事，不只是tag自动补全系统，这个可以完全在内存中操作，不需要数据库获取。</p>

<p>但是很多次，把所有数据保留在内存中是不实际的。比如我们不会在内存中保留所有笔记。</p>

<p>但是也有很多次，当不能在内存中保留对象时，你希望在内存中保留所有uniqueIDs。你会像这样做一个获取：</p>

<pre><code>FMResultSet *resultSet = [self.database executeQuery:@"select uniqueID from some_table"]; 
</code></pre>

<p>resultSet只包含了uniqueIDs， 你可以存储到一个NSMutableSet里。</p>

<p>我发现有时这个对web APIs很有用。想象一个API调用返回从某个确定的时间以后的，已创建笔记的uniqueIDs列表。如果我本地已经有了一个包含所有笔记uniqueIDs的NSMutableSet，我可以快速检查(通过 -[NSMutableSet minusSet])是否有漏掉的笔记，然后去调用另一个API下载那些漏掉的笔记。这些完全不需要触及数据库。</p>

<p>但是，像这样的事情应该小心处理。app可以提供足够的内存吗？它真的简化编程并且提高性能了吗？</p>

<p>用SQLite和FMDB而不是Core Data，给你带来大量的灵活性和聪明解决办法的空间。记住有的时候聪明是好的，也有的时候聪明是一个大错误。</p>

<p>Web APIs
我的API调用在后台进程（经常用一个NSOperationQueue，所以我可以取消操作）。模型对象只在主线程，但是我还传递模型对象给我的API调用。</p>

<p>是这样的：一个数据库对象有一个detachedCopy方法，可以复制数据库对象。这个复制对象不是引用自我用来唯一化的对象缓存。唯一引用那个对象的地方是API调用，当API调用结束，那个复制的对象就消失了。</p>

<p>这是一个好的系统，因为它意味着我可以在API调用里使用模型对象。方法看起来像这样：</p>

<pre><code>- (void)uploadNote:(VSNote *)note { 
    VSNoteAPICall *apiCall = [[VSNoteAPICall alloc] initWithNote:[note detachedCopy]]; 
    [self enqueueAPICall:apiCall]; 
} 
</code></pre>

<p>VSNoteAPICall从复制的VSNote获取值，并且创建HTTP请求，而不是一个字典或其他笔记的表现形式。</p>

<p>处理Web API返回值
我对web返回值做了一些类似的事情。我会对返回的JSON或者XML创建一个模型对象，这个模型对象也是分离的。它不是存储在为了唯一性的模型缓存里。</p>

<p>这儿有些事情是不确定的。有时有必要用那个模型对象在两个地方做本地修改：在内存缓存和数据库。</p>

<p>数据库通常是容易的部分。比如：我的应用已经有一个方法来保存笔记对象。它用一个SQL insert或者replace字符串。我只需调用那个从web API返回值生成的笔记对象，数据库就会更新。</p>

<p>但是可能那个对象有一个在内存中的版本，幸运的是我们很容易找到：</p>

<pre><code>VSNote *cachedNote = [self.mapTable objectForKey:downloadedNote.uniqueID]; 
</code></pre>

<p>如果cachedNote存在，我会让它从downloadedNote中获取值，而不是替换它（这样可能违反唯一性）。这可以共享detachedCopy方法的代码。</p>

<p>一旦cachedNote更新了，观察者会通过KVO通知笔记，或者我会发送一个NSNotification，或者两者都做。</p>

<p>Web API调用也会返回一些其他值。我提到过RSS阅读器可能获得一个已读条目的大列表。这种情况下，我用那个列表创建了一个NSSet，在内存中更新每一个缓存文章的read属性，然后调用-[FMDatabase executeUpdate:]。</p>

<p>让它工作快速的关键是NSMapTable的查找是快速的。如果你找的对象在一个NSArray里，我们该重新考虑。</p>

<p>数据库迁移
Core Data的数据库迁移很酷，当它可行的时候。但是不可避免的，它是代码和数据库中的一层。如果你越直接使用SQLite，你更新数据库越直接。你可以安全容易的做到这点。</p>

<p>比如加一个表：</p>

<pre><code>[self.database executeUpdate:@"CREATE TABLE if not exists tags " 
    "(uniqueID TEXT UNIQUE, name TEXT, deleted INTEGER, deletedModificationDate DATE);"]; 
</code></pre>

<p>或者加一个索引：</p>

<pre><code>[self.database executeUpdate:@"CREATE INDEX if not exists " 
    "archivedSortDateIndex on notes (archived, sortDate);"]; 
</code></pre>

<p>或者加一列：</p>

<pre><code>[self.database executeUpdate:@"ALTER TABLE tags ADD deletedDate DATE"]; 
</code></pre>

<p>应用应该在代码的第一个地方用上面这些代码设置数据库。以后的改变只需加executeUpdate的调用 — 我让他们按顺序执行。因为我的数据库是我设计的，不会有什么问题（我从没碰到性能问题，它很快）。</p>

<p>当然大的改变需要更多代码。如果你的数据通过web获取，有时你可以从一个新数据库模型开始，重新下载你需要的数据。</p>

<p>性能技巧
SQLite可以非常非常快，它也可以非常慢。完全取决于你怎么使用它。</p>

<p>事务
把更新包装在事务里。在更新前调用 -[FMDatabase beginTransaction] ，更新后调用-[FMDatabase commit]。</p>

<p>如果你不得不反规范化（ Denormalize）
反规范化让人很不爽。这个方法是，为了加速检索而添加冗余数据，但是它意味着你需要维护冗余数据。</p>

<p>我总是疯狂避免它，直到这样能有严重的性能区别。然后我会尽可能少得这么做。</p>

<p>使用索引
我的应用中tags表的创建语句像这样：</p>

<pre><code>CREATE TABLE if not exists tags  
  (uniqueID TEXT UNIQUE, name TEXT, deleted INTEGER, deletedModificationDate DATE); 
</code></pre>

<p>uniqueID列是自动索引的，因为它定义为unique。但是如果我想用name来查询表，我可能会在name上创建一个索引，像这样：</p>

<pre><code>CREATE INDEX if not exists tagNameIndex on tags (name); 
</code></pre>

<p>你可以一次性在多列上创建索引，像这样：</p>

<pre><code>CREATE INDEX if not exists archivedSortDateIndex on notes (archived, sortDate); 
</code></pre>

<p>但是注意太多索引会降低你的插入速度。你只需要足够数量并且是对的那些。</p>

<p>使用命令行应用
当我的app在模拟器里运行时，我会打印数据库的路径。我可以通过sqlite3的命令行来打开数据库。（通过man sqlite3命令来了解这个应用的更多信息）。</p>

<p>打开数据库的命令：sqlite3 “数据库的路径”。</p>

<p>打开以后，你可以看schema: type .schema。</p>

<p>你可以更新和查询，这是在使用你的app之前检查SQL是否正确的很好的方式。</p>

<p>这里面最酷的一部分是，SQLite Explain Query Plan命令，你会希望确保你的语句执行的尽可能快。</p>

<p>真实的例子
我的应用显示所有没有归档笔记的标签列表。每当笔记或者标签有变化，这个查询就会重新执行一次，所以它需要很快。</p>

<p>我可以用SQL join来查询，但是很慢（joins都很慢）。</p>

<p>所以我放弃sqlite3并开始尝试别的方法。我又看了一次我的schema，意识到我可以反规范化。一个笔记的归档状态可以存储在notes表里，它也可以存储在tagsNotesLookup表。</p>

<p>然后我可以执行一个查询：</p>

<pre><code>select distinct tagUniqueID from tagsNotesLookup where archived=0; 
</code></pre>

<p>我已经有了一个在tagUniqueID上的索引。所以我用explain query plan来告诉我当我执行这个查询的时候会发生什么。</p>

<pre><code>sqlite&gt; explain query plan select distinct tagUniqueID from tagsNotesLookup where archived=0; 
0|0|0|SCAN TABLE tagsNotesLookup USING INDEX tagUniqueIDIndex (~100000 rows) 
</code></pre>

<p>它用了一个索引，但是SCAN TABLE听起来不太好，最好是一个SEARCH TABLE并且覆盖一个索引。
我在tagUniqueID和archive上建了索引：</p>

<pre><code>CREATE INDEX archivedTagUniqueID on tagsNotesLookup(archived, tagUniqueID); 
</code></pre>

<p>再次执行explain query plan:</p>

<pre><code>sqlite&gt; explain query plan select distinct tagUniqueID from tagsNotesLookup where archived=0; 
0|0|0|SEARCH TABLE tagsNotesLookup USING COVERING INDEX archivedTagUniqueID (archived=?) (~10 rows) 
</code></pre>

<p>好多了。</p>

<p>更多性能提示
FMDB的某处加了缓存statements的能力，所以当创建或打开一个数据库的时候，我总是调用[self.database setShouldCacheStatements:YES] 。这意味着对每个调用你不需要再次编译每个statement。</p>

<p>我从来没有找到使用vacuum的好的指引，如果数据库没有定期压缩，它会越来越慢。我的应用会跑一个vacuum，但只是每周一次（它在NSUserDefaults里存储上次vacuum的时间，然后在开始的时候检查是否过了一周）。</p>

<p>如果能auto_vacuum那更好，看pragma statements supported by SQLite列表。</p>

<p>其他酷的东西
Gus Mueller让我涉及自定义SQLite方法的内容。我并没有真的使用这些东西，既然他指出了，我可以放心的说我能找到它的用处。因为它很酷。</p>

<p>在Gus的帖子里，有一个查询是这样的：</p>

<pre><code>select displayName, key from items where UTTypeConformsTo(uti, ?) order by 2; 
</code></pre>

<p>SQLite完全不知道UITypes。但是你可以加核心方法，查看-[FMDatabase makeFunctionNamed:maximumArguments:withBlock:]。</p>

<p>你可以执行一个大的查询来替代，然后评估每个对象。但是那需要更多工作。最好在SQL级就过滤，而不是在将表格行转为对象以后。</p>

<p>最后
你真的应该使用Core Data，我不是在开玩笑。</p>

<p>我用SQLite和FMDB一段时间了，我对多得的好处感到很兴奋，也得到非同一般的性能。但是记住机器在变快，其他看你代码的人期望看到他已经知道的Core Data, 另一些不打算看你的数据库代码。所以请把这整篇文章看做一个疯子的叫喊，关于他为自己建立的细节的疯狂的世界，并把自己锁在里面。</p>

<p>请享受了不起的Core Data的文章（有点难过的摇头）。</p>

<p>接下来，在查完Gus指出的自定义SQLite方法特性后，我会研究SQLite的full-text search extension. 总有更多的内容需要去学习。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Realm 爆菊 CoreData]]></title>
    <link href="http://al1020119.github.io/blog/2016/07/05/ycoredatayurealm/"/>
    <updated>2016-07-05T04:59:42+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/07/05/ycoredatayurealm</id>
    <content type="html"><![CDATA[<p>本文具有强烈的个人感情色彩,如有观看不适,请尽快关闭。本文仅作为个人学习记录使用，也欢迎在许可协议范围内转载或使用，请尊重版权并且保留原文链接，谢谢您的理解合作。如果您觉得本站对您能有帮助，您可以使用RSS方式订阅本站，这样您将能在第一时间获取本站信息。
碎碎念</p>

<p>OhMyStar 2 也进行了一段时日，我把持久化的方式从CoreData 换到了 Realm。有些感悟，顺手就记录一下吧。以下评论都是自己很主观的感受，无实际测试数据支持。
论 iOS 的持久化</p>

<!--more-->


<p>iOS 持久化其实也没多少选择， 高端一点CoreData、Realm、FMDB、KV类(LevelDB等)。低端一些直接一个 NSArray 就写成 Plist 也能持久化下来。</p>

<p>在网络环境越来越快的当下和大部分应用数据都可能是网络应用，如果业务逻辑并不复杂，其实极端一点就只用写到 JSON 转 Object 就好了。而且一堆这样好用的封装，远有Mantle 近有YYModel。</p>

<p>所以需要持久化的时候，我觉的可以慎重的评估一下需求。想明白了，后面可以节省很多事情。</p>

<p>本文章主要对比 Realm 和 CoreData，其他的就不涉及了。</p>

<p>Realm
优点
入门门槛低</p>

<p>Realm文档就算一个字一个字扣着读完，一个下午就足够了。而且还有中文版本，不要太友好哦，有点不习惯诶。</p>

<p>文档覆盖了80%的使用情况，甚至有些太简陋的嫌疑。但不管怎么样，这种入门条件比起 CoreData 写了三个月都没搞清楚 Context 要好的多。</p>

<p>在库的工具链上，安装一个 Realm Browser 以后就不需要其他辅助了。还是简单。</p>

<p>几乎做到了上手即用的程度。五星好评。</p>

<p>PS：我用了一个通宵把 OhMyStar 2 的持久化从 CoreData 换到了 Realm ，优化调整了大概5天左右达到勉强可以用的情况 。在这之前并没有任何 Realm 的经验。
据说性能好一些</p>

<p>Realm官方介绍Fast一段中</p>

<p>Counts</p>

<p><img src="http://al1020119.github.io/images/benchmarks.001b.png" title="Caption" ></p>

<p>Queries</p>

<p><img src="http://al1020119.github.io/images/benchmarks.002b.png" title="Caption" ></p>

<p>Inserts</p>

<p><img src="http://al1020119.github.io/images/benchmarks.003b.png" title="Caption" ></p>

<p>在写这里的时候我顺手Google了一下 发现一篇Core Data, FMDB, Realm 性能测试。我就多说几句</p>

<p>总觉得大家对 CoreData 误会蛮深，代码 Fork 看了一下， 总觉得不应该这样写来比性能的，但是一时半会也不知道怎么改。我只能说我在优化 CoreData 的时候根据 WWDC 上教的还是提升很高，另外一个事情是 CoreData 一般都用 Sqlite 做后端。所以如果你的查询是经过优化的，确认打出来的SQL语句科学以后，Sqlite(CoreData) 跟 Sqlite(FMDB)我觉得性能就算有差距，这差距没有能大到选择方案的决定性因素。如果使用 CoreData 遇到性能瓶颈，你应该仔细的研究 WWDC 和几篇很好的文章。确保你的 CoreData 使用方式是正确科学的。
没有需要架构Context那种烦人的东西</p>

<p>应该也算Realm简单的一个方面，Realm 只要保持自己线程里面，自己的 Realm Store 操作是正确的即可。如果是 CoreData，怎么架构一个科学的 Context Stack 就足够让我头疼一整，iOS 还好，界面是一个接着一个(VC跟VC之间的层级关系很清晰)。而 OhMyStar 2 这种 OS X 桌面应用场景VC之间很复杂，线程之间Context的关系让出现很多问题。
支持 NSPredicate</p>

<p>从 CoreData 转过来并没有太多的不适应
很简单的使用多个存储文件</p>

<p>举个例子，多用户登陆情况下。用户是单独的存储文件，和全部用户使用同一个存储文件。后者需要每条用户数据都要关联一次当前用户，所有查询用户数据的时候，你都必须加上当前用户的查询项。而使用每个用户单独一个数据文件的时候，整个存储结构会清爽很多。
技术支持</p>

<p>至少实在没法的时候还可以去微博上吐槽他们，他们其实也有极大的热情来解决你遇到的问题。CoreData 这种遇到问题就只能自己默默的吞下。
缺点
关联关系弱的一逼</p>

<p>简单说来就是对象跟对象之间的一对多关系和多对多关系。并不能映射，需要在双方里面都写上属性，此外还需要在设置的时候两边同时设置。查询时候也是 NSPredicate 也仅仅只支持一些一层的查询，没法做出带SUBQUERY的复杂查询出来。
强制内省容错机制导致存储文件不断变大</p>

<p>Realm本身感觉有一个数据容错机制。但是这个机制在数据库文件有错误的情况自己修复的时候，会无限增大。具体我这里表现为，打开看只有3000条数据，但是文件大小已经有3GB。重现Bug也很容易，只要你在写数据库的时候,用Realm Browser查看一下，crash之后在打开就很容易出现。</p>

<p>官方文档里面有说到会造成这种情形的原因，我在尽我所能的避免问题以后。存储文件还是会有可能不那么夸张的变大一些。但是用Realm Browser查看数据是正常的。所以我觉得官方应该提供一个函数，可以删除掉那些容易的东西。保持存储文件的干净。
没有细粒化通知</p>

<p>也就是说，当我在某个地方做出修改。 我其他地方只知道Realm有修改，但是没法知道我是增加、修改还是删除了数据。不知道我更新的是那一条数据。据文档说，将来会解决这个问题，就只有拭目以待。
增加包体积</p>

<p>据官方说会增加1MB左右的包大小，如果你是一个小体积应用，或者是一个几千万用户的主流应用。对包大小敏感的话慎用。
核心代码目前闭源</p>

<p>对于在我们这样一个作恶满天飞的天朝长大的孩子来说，有些孩子对闭源这个事情还是挺在意的。不过官方说将来会开源，我还是倾向于相信 Realm 他们的人品。
CoreData</p>

<p>CoreData 相关资料相对多一些我就简单说
优点
官方支持 &amp;&amp; 亲儿子</p>

<p>系统自带，Apple支持
带图形化的Model编辑</p>

<p>对于视觉化动物来说比较友好，也可以清楚的知道自己设计的 Model 之间的关系
强大的关联关系</p>

<p>以前不觉得，用了 Realm 才发现 CoreData 的关联关系如此好用，一对多，多对多。想怎么查询就怎么查询，可以写出很复杂的查询逻辑来。
强大的查询</p>

<p>虽然可能在设置NSFetchRequest的时候感觉很多东西要弄，但是复杂也带来了强大的功能，NSFetchRequest 可以设置很多，比如限制查询数量， 限制只返回某些属性值等等。就不展开说了。
精细化的通知</p>

<p>可以知道具体插入了什么、更新了什么、删除了什么。这样在刷UI，比如一个tableview的时候，你就可以控制的很准确。
缺点
入门门槛高</p>

<pre><code>CoreData 是一个博大精深的技术，不要妄想几天之内可以用的很溜。
CoreData 是一个博大精深的技术，不要妄想几天之内可以用的很溜。
CoreData 是一个博大精深的技术，不要妄想几天之内可以用的很溜。
</code></pre>

<p>如果没有足够的时间和精力去接入 CoreData。 那选型的时候应当慎重考虑。
需要一些工具才感觉好使</p>

<p>不管是老手还是新手，使用一些第三方的封装库和工具都会大大的提高使用 CoreData 的幸福指数。</p>

<p>mogenerator 是必须必须要的。</p>

<p>MagicalRecord 无愧 CoreData 第一库，据小道消息 主要贡献者 Saul Mora 可能去了微信了。
Context</p>

<p>其实还是 CoreData 门槛高的问题，对我来说。Context之间的关系和线程之间的处理让我感到很头痛，特别是 OS X  是一大堆VC铺到屏幕上，我水平又菜，出的问题很多。
多个持久化文件很麻烦</p>

<p>不是说不可以，但是真的好麻烦。</p>

<p>有个第三方库有解决CoreData这个问题 CoreStore 但是我用着不是很顺手最后弃用.
总结</p>

<p>其实吧用啥持久化都行，具体还是需要看你的需求和方案上来说哪一个方案更加适合。</p>

<p>如果简单说来，就是 Realm 更加适合一些业务逻辑不怎么复杂的场景，团队配置要求不高，有经验的人稍微看一下午就能上手。</p>

<p>CoreData 更加适合业务逻辑复杂的情况，团队配置要求比较高，有经验的老手也需要几周甚至更长的时间才能科学的使用CoreData。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CoreData装逼技能？]]></title>
    <link href="http://al1020119.github.io/blog/2016/07/04/coredatedzhuangbi/"/>
    <updated>2016-07-04T14:59:42+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/07/04/coredatedzhuangbi</id>
    <content type="html"><![CDATA[<p>正文：</p>

<p>在之前的文章中，已经讲了很多关于CoreData使用相关的知识点。这篇文章中主要讲两个方面，NSFetchedResultsController和版本迁移。</p>

<p>文章题目中虽然有“高级”两个字，其实讲的东西并不高级，只是因为上一篇文章中东西太多了，把两个较复杂的知识点挪到这篇文章中。</p>

<!--more-->


<p>文章中如有疏漏或错误，还请各位及时提出，谢谢！</p>

<p>NSFetchedResultsController</p>

<p>在开发过程中会经常用到UITableView这样的视图类，这些视图类需要自己管理其数据源，包括网络获取、本地存储都需要写代码进行管理。</p>

<p>而在CoreData中提供了NSFetchedResultsController类(fetched results controller，也叫FRC)，FRC可以管理UITableView或UICollectionView的数据源。这个数据源主要指本地持久化的数据，也可以用这个数据源配合着网络请求数据一起使用，主要看业务需求了。</p>

<p>本篇文章会使用UITableView作为视图类，配合NSFetchedResultsController进行后面的演示，UICollectionView配合NSFetchedResultsController的使用也是类似，这里就不都讲了。</p>

<p>简单介绍</p>

<p>就像上面说到的，NSFetchedResultsController就像是上面两种视图的数据管理者一样。FRC可以监听一个MOC的改变，如果MOC执行了托管对象的增删改操作，就会对本地持久化数据发生改变，FRC就会回调对应的代理方法，回调方法的参数会包括执行操作的类型、操作的值、indexPath等参数。</p>

<p>实际使用时，通过FRC“绑定”一个MOC，将UITableView嵌入在FRC的执行流程中。在任何地方对这个“绑定”的MOC存储区做修改，都会触发FRC的回调方法，在FRC的回调方法中嵌入UITableView代码并做对应修改即可。</p>

<p>由此可以看出FRC最大优势就是，始终和本地持久化的数据保持统一。只要本地持久化的数据发生改变，就会触发FRC的回调方法，从而在回调方法中更新上层数据源和UI。这种方式讲的简单一点，就可以叫做数据带动UI。</p>

<p><img src="http://al1020119.github.io/images/4001.png" title="Caption" ></p>

<p>FRC</p>

<p>但是需要注意一点，在FRC的初始化中传入了一个MOC参数，FRC只能监测传入的MOC发生的改变。假设其他MOC对同一个存储区发生了改变，FRC则不能监测到这个变化，不会做出任何反应。</p>

<p>所以使用FRC时，需要注意FRC只能对一个MOC的变化做出反应，所以在CoreData持久化层设计时，尽量一个存储区只对应一个MOC，或设置一个负责UI的MOC，这在后面多线程部分会详细讲解。</p>

<p>修改模型文件结构</p>

<p>在写代码之前，先对之前的模型文件结构做一些修改。</p>

<p><img src="http://al1020119.github.io/images/4002.png" title="Caption" ></p>

<p>Employee结构</p>

<p>讲FRC的时候，只需要用到Employee这一张表，其他表和设置直接忽略。需要在Employee原有字段的基础上，增加一个String类型的sectionName字段，这个字段就是用来存储section title的，在下面的文章中将会详细讲到。</p>

<p>初始化FRC</p>

<p>下面例子是比较常用的FRC初始化方式，初始化时指定的MOC，还用之前讲过的MOC初始化代码，UITableView初始化代码这里也省略了，主要突出FRC的初始化。</p>

<pre><code>// 创建请求对象，并指明操作Employee表
NSFetchRequest *request = [NSFetchRequest fetchRequestWithEntityName:@"Employee"];
// 设置排序规则，指明根据height字段升序排序
NSSortDescriptor *heightSort = [NSSortDescriptor sortDescriptorWithKey:@"height" ascending:YES];
request.sortDescriptors = @[heightSort];
// 创建NSFetchedResultsController控制器实例，并绑定MOC
NSError *error = nil;
fetchedResultController = [[NSFetchedResultsController alloc] initWithFetchRequest:request
                                                 managedObjectContext:context
                                        sectionNameKeyPath:@"sectionName"
                                               cacheName:nil];
// 设置代理，并遵守协议
fetchedResultController.delegate = self;
// 执行获取请求，执行后FRC会从持久化存储区加载数据，其他地方可以通过FRC获取数据
[fetchedResultController performFetch:&amp;error];
// 错误处理
if (error) {
    NSLog(@"NSFetchedResultsController init error : %@", error);
}
// 刷新UI
[tableView reloadData];
</code></pre>

<p>在上面初始化FRC时，传入的sectionNameKeyPath:参数，是指明当前托管对象的哪个属性当做section的title，在本文中就是Employee表的sectionName字段为section的title。从NSFetchedResultsSectionInfo协议的indexTitle属性获取这个值。</p>

<p>在sectionNameKeyPath:设置属性名后，就以这个属性名作为分组title，相同的title会被分到一个section中。</p>

<p>初始化FRC时参数managedObjectContext:传入了一个MOC参数，FRC只能监测这个传入的MOC发生的本地持久化改变。就像上面介绍时说的，其他MOC对同一个持久化存储区发生的改变，FRC则不能监测到这个变化。</p>

<p>再往后面看到cacheName:参数，这个参数我设置的是nil。参数的作用是开启FRC的缓存，对获取的数据进行缓存并指定一个名字。可以通过调用deleteCacheWithName:方法手动删除缓存。</p>

<p>但是这个缓存并没有必要，缓存是根据NSFetchRequest对象来匹配的，如果当前获取的数据和之前缓存的相匹配则直接拿来用，但是在获取数据时每次获取的数据都可能不同，缓存不能被命中则很难派上用场，而且缓存还占用着内存资源。</p>

<p>在FRC初始化完成后，调用performFetch:方法来同步获取持久化存储区数据，调用此方法后FRC保存数据的属性才会有值。获取到数据后，调用tableView的reloadData方法，会回调tableView的代理方法，可以在tableView的代理方法中获取到FRC的数据。调用performFetch:方法第一次获取到数据并不会回调FRC代理方法。</p>

<p>代理方法</p>

<p>FRC中包含UITableView执行过程中需要的相关数据，可以通过FRC的sections属性，获取一个遵守协议的对象数组，数组中的对象就代表一个section。</p>

<p>在这个协议中有如下定义，可以看出这些属性和UITableView的执行流程是紧密相关的。</p>

<pre><code>@protocol NSFetchedResultsSectionInfo
/* Name of the section */
@property (nonatomic, readonly) NSString *name;
/* Title of the section (used when displaying the index) */
@property (nullable, nonatomic, readonly) NSString *indexTitle;
/* Number of objects in section */
@property (nonatomic, readonly) NSUInteger numberOfObjects;
/* Returns the array of objects in the section. */
@property (nullable, nonatomic, readonly) NSArray *objects;
@end // NSFetchedResultsSectionInfo
</code></pre>

<p>在使用过程中应该将FRC和UITableView相互嵌套，在FRC的回调方法中嵌套UITableView的视图改变逻辑，在UITableView的回调中嵌套数据更新的逻辑。这样可以始终保证数据和UI的同步，在下面的示例代码中将会演示FRC和UITableView的相互嵌套。</p>

<pre><code>Table View Delegate

// 通过FRC的sections数组属性，获取所有section的count值
- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView {
    return fetchedResultController.sections.count;
}
// 通过当前section的下标从sections数组中取出对应的section对象，并从section对象中获取所有对象count
- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section {
    return fetchedResultController.sections[section].numberOfObjects;
}
// FRC根据indexPath获取托管对象，并给cell赋值
- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {
    Employee *emp = [fetchedResultController objectAtIndexPath:indexPath];
    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@"identifier" forIndexPath:indexPath];
    cell.textLabel.text = emp.name;
    return cell;
}
// 创建FRC对象时，通过sectionNameKeyPath:传递进去的section title的属性名，在这里获取对应的属性值
- (NSString *)tableView:(UITableView *)tableView titleForHeaderInSection:(NSInteger)section {
    return fetchedResultController.sections[section].indexTitle;
}
// 是否可以编辑
- (BOOL)tableView:(UITableView *)tableView canEditRowAtIndexPath:(NSIndexPath *)indexPath {
    return YES;
}
// 这里是简单模拟UI删除cell后，本地持久化区数据和UI同步的操作。在调用下面MOC保存上下文方法后，FRC会回调代理方法并更新UI
- (void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath {
     if (editingStyle == UITableViewCellEditingStyleDelete) {
        // 删除托管对象
        Employee *emp = [fetchedResultController objectAtIndexPath:indexPath];
        [context deleteObject:emp];
        // 保存上下文环境，并做错误处理
        NSError *error = nil;
        if (![context save:&amp;error]) {
            NSLog(@"tableView delete cell error : %@", error);
        }
    }
}
</code></pre>

<p>上面是UITableView的代理方法，代理方法中嵌套了FRC的数据获取代码，这样在刷新视图时就可以保证使用最新的数据。并且在代码中简单实现了删除cell后，通过MOC调用删除操作，使本地持久化数据和UI保持一致。</p>

<p>就像上面cellForRowAtIndexPath:方法中使用的一样，FRC提供了两个方法轻松转换indexPath和NSManagedObject的对象，在实际开发中这两个方法非常实用，这也是FRC和UITableView、UICollectionView深度融合的表现。</p>

<pre><code>- (id)objectAtIndexPath:(NSIndexPath *)indexPath;
- (nullable NSIndexPath *)indexPathForObject:(id)object;
</code></pre>

<p>Fetched Results Controller Delegate</p>

<pre><code>// Cell数据源发生改变会回调此方法，例如添加新的托管对象等
- (void)controller:(NSFetchedResultsController *)controller didChangeObject:(id)anObject atIndexPath:(nullable NSIndexPath *)indexPath forChangeType:(NSFetchedResultsChangeType)type newIndexPath:(nullable NSIndexPath *)newIndexPath {
    switch (type) {
        case NSFetchedResultsChangeInsert:
            [tableView insertRowsAtIndexPaths:@[newIndexPath] withRowAnimation:UITableViewRowAnimationAutomatic];
            break;
        case NSFetchedResultsChangeDelete:
            [tableView deleteRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationAutomatic];
            break;
        case NSFetchedResultsChangeMove:
            [tableView deleteRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationAutomatic];
            [tableView insertRowsAtIndexPaths:@[newIndexPath] withRowAnimation:UITableViewRowAnimationAutomatic];
            break;
        case NSFetchedResultsChangeUpdate: {
            UITableViewCell *cell = [tableView cellForRowAtIndexPath:indexPath];
            Employee *emp = [fetchedResultController objectAtIndexPath:indexPath];
            cell.textLabel.text = emp.name;
        }
            break;
    }
}
// Section数据源发生改变回调此方法，例如修改section title等。
- (void)controller:(NSFetchedResultsController *)controller didChangeSection:(id &lt;nsfetchedresultssectioninfo&gt;)sectionInfo atIndex:(NSUInteger)sectionIndex forChangeType:(NSFetchedResultsChangeType)type {
    switch (type) {
        case NSFetchedResultsChangeInsert:
            [tableView insertSections:[NSIndexSet indexSetWithIndex:sectionIndex] withRowAnimation:UITableViewRowAnimationAutomatic];
            break;
        case NSFetchedResultsChangeDelete:
            [tableView deleteSections:[NSIndexSet indexSetWithIndex:sectionIndex] withRowAnimation:UITableViewRowAnimationAutomatic];
            break;
        default:
            break;
    }
}
// 本地数据源发生改变，将要开始回调FRC代理方法。
- (void)controllerWillChangeContent:(NSFetchedResultsController *)controller {
    [tableView beginUpdates];
}
// 本地数据源发生改变，FRC代理方法回调完成。
- (void)controllerDidChangeContent:(NSFetchedResultsController *)controller {
    [tableView endUpdates];
}
// 返回section的title，可以在这里对title做进一步处理。这里修改title后，对应section的indexTitle属性会被更新。
- (nullable NSString *)controller:(NSFetchedResultsController *)controller sectionIndexTitleForSectionName:(NSString *)sectionName {
    return [NSString stringWithFormat:@"sectionName %@", sectionName];
}&lt;/nsfetchedresultssectioninfo&gt;
</code></pre>

<p>上面就是当本地持久化数据发生改变后，被回调的FRC代理方法的实现，可以在对应的实现中完成自己的代码逻辑。</p>

<p>在上面的章节中讲到删除cell后，本地持久化数据同步的问题。在删除cell后在tableView代理方法的回调中，调用了MOC的删除方法，使本地持久化存储和UI保持同步，并回调到下面的FRC代理方法中，在代理方法中对UI做删除操作，这样一套由UI的改变引发的删除流程就完成了。</p>

<p>目前为止已经实现了数据和UI的双向同步，即UI发生改变后本地存储发生改变，本地存储发生改变后UI也随之改变。可以通过下面添加数据的代码来测试一下，NSFetchedResultsController就讲到这里了。</p>

<pre><code>- (void)addMoreData {
    Employee *employee = [NSEntityDescription insertNewObjectForEntityForName:@"Employee" inManagedObjectContext:context];
    employee.name = [NSString stringWithFormat:@"lxz 15"];
    employee.height = @(15);
    employee.brithday = [NSDate date];
    employee.sectionName = [NSString stringWithFormat:@"3"];
    NSError *error = nil;
    if (![context save:&amp;error]) {
        NSLog(@"MOC save error : %@", error);
    }
}
</code></pre>

<p>版本迁移</p>

<p>CoreData版本迁移的方式有很多，一般都是先在Xcode中，原有模型文件的基础上，创建一个新版本的模型文件，然后在此基础上做不同方式的版本迁移。</p>

<p>本章节将会讲三种不同的版本迁移方案，但都不会讲太深，都是从使用的角度讲起，可以满足大多数版本迁移的需求。</p>

<p>为什么要版本迁移？</p>

<p>在已经运行程序并通过模型文件生成数据库后，再对模型文件进行的修改，如果只是修改已有实体属性的默认值、最大最小值、Fetch Request等属性自身包含的参数时，并不会发生错误。如果修改模型文件的结构，或修改属性名、实体名等，造成模型文件的结构发生改变，这样再次运行程序就会导致崩溃。</p>

<p>在开发测试过程中，可以直接将原有程序卸载就可以解决这个问题，但是本地之前存储的数据也会消失。如果是线上程序，就涉及到版本迁移的问题，否则会导致崩溃，并提示如下错误：</p>

<pre><code>CoreData: error: Illegal attempt to save to a file that was never opened. "This NSPersistentStoreCoordinator has no persistent stores (unknown).  It cannot perform a save operation.". No last error recorded.
</code></pre>

<p>然而在需求不断变化的过程中，后续版本肯定会对原有的模型文件进行修改，这时就需要用到版本迁移的技术，下面开始讲版本迁移的方案。</p>

<p>创建新版本模型文件</p>

<p>本文中讲的几种版本迁移方案，在迁移之前都需要对原有的模型文件创建新版本。</p>

<p>选中需要做迁移的模型文件 -> 点击菜单栏Editor -> Add Model Version -> 选择基于哪个版本的模型文件(一般都是选择目前最新的版本)，新建模型文件完成。</p>

<p>对于新版本模型文件的命名，我在创建新版本模型文件时，一般会拿当前工程版本号当做后缀，这样在模型文件版本比较多的时候，就可以很容易将模型文件版本和工程版本对应起来。</p>

<p><img src="http://al1020119.github.io/images/4003.png" title="Caption" ></p>

<p>创建新版本模型文件</p>

<p>添加完成后，会发现之前的模型文件会变成一个文件夹，里面包含着多个模型文件。</p>

<p><img src="http://al1020119.github.io/images/4004.png" title="Caption" >
模型文件夹</p>

<p>在新建的模型文件中，里面的文件结构和之前的文件结构相同。后续的修改都应该在新的模型文件上，之前的模型文件不要再动了，在修改完模型文件后，记得更新对应的模型类文件。</p>

<p>基于新的模型文件，对Employee实体做如下修改，下面的版本迁移也以此为例。</p>

<p><img src="http://al1020119.github.io/images/4005.png" title="Caption" ></p>

<p>修改之前</p>

<p>添加一个String类型的属性，设置属性名为sectionName。</p>

<p><img src="http://al1020119.github.io/images/4006.png" title="Caption" ></p>

<p>修改之后</p>

<p>此时还应该选中模型文件，设置当前模型文件的版本。这里选择将最新版本设置为刚才新建的1.1.0版本，模型文件设置工作完成。</p>

<pre><code>Show The File Inspector -&gt; Model Version -&gt; Current 设置为最新版本。
</code></pre>

<p><img src="http://al1020119.github.io/images/4007.png" title="Caption" ></p>

<p>设置版本</p>

<p>对模型文件的设置已经完成了，接下来系统还要知道我们想要怎样迁移数据。在迁移过程中可能会存在多种可能，苹果将这个灵活性留给了我们完成。剩下要做的就是编写迁移方案以及细节的代码。</p>

<p>轻量级版本迁移</p>

<p>轻量级版本迁移方案非常简单，大多数迁移工作都是由系统完成的，只需要告诉系统迁移方式即可。在持久化存储协调器(PSC)初始化对应的持久化存储(NSPersistentStore)对象时，设置options参数即可，参数是一个字典。PSC会根据传入的字典，自动推断版本迁移的过程。</p>

<p>字典中设置的key：</p>

<pre><code>    NSMigratePersistentStoresAutomaticallyOption设置为YES，CoreData会试着把低版本的持久化存储区迁移到最新版本的模型文件。

    NSInferMappingModelAutomaticallyOption设置为YES，CoreData会试着以最为合理地方式自动推断出源模型文件的实体中，某个属性到底对应于目标模型文件实体中的哪一个属性。
</code></pre>

<p>版本迁移的设置是在创建MOC时给PSC设置的，为了使代码更直观，下面只给出发生变化部分的代码，其他MOC的初始化代码都不变。</p>

<pre><code>// 设置版本迁移方案
NSDictionary *options = @{NSMigratePersistentStoresAutomaticallyOption : @YES,
                                NSInferMappingModelAutomaticallyOption : @YES};
// 创建持久化存储协调器，并将迁移方案的字典当做参数传入
[coordinator addPersistentStoreWithType:NSSQLiteStoreType configuration:nil URL:[NSURL fileURLWithPath:dataPath] options:options error:nil];
</code></pre>

<p>修改实体名</p>

<p>假设需要对已存在实体进行改名操作，需要将重命名后的实体Renaming ID，设置为之前的实体名。下面是Employee实体进行操作。</p>

<p><img src="http://al1020119.github.io/images/4008.png" title="Caption" ></p>

<p>修改实体名</p>

<p>修改后再使用实体时，应该将实体名设为最新的实体名，这里也就是Employee2，而且数据库中的数据也会迁移到Employee2表中。</p>

<pre><code>Employee2 *emp = [NSEntityDescription insertNewObjectForEntityForName:@"Employee2" inManagedObjectContext:context];
emp.name = @"lxz";
emp.brithday = [NSDate date];
emp.height = @1.9;
[context save:nil];
</code></pre>

<p>Mapping Model 迁移方案</p>

<p>轻量级迁移方案只是针对增加和改变实体、属性这样的一些简单操作，假设有更复杂的迁移需求，就应该使用Xcode提供的迁移模板(Mapping Model)。通过Xcode创建一个后缀为.xcmappingmodel的文件，这个文件是专门用来进行数据迁移用的，一些变化关系也会体现在模板中，看起来非常直观。</p>

<p>这里还以上面更改实体名，并迁移实体数据为例子，将Employee实体迁移到Employee2中。首先将Employee实体改名为Employee2，然后创建Mapping Model文件。</p>

<p>Command + N 新建文件 -> 选择 Mapping Model -> 选择源文件 Source Model -> 选择目标文件 Target Model -> 命名 Mapping Model 文件名 -> Create 创建完成。</p>

<p><img src="http://al1020119.github.io/images/4009.png" title="Caption" ></p>

<p>Mapping Model 文件</p>

<p>现在就创建好一个Mapping Model文件，文件中显示了实体、属性、Relationships，源文件和目标文件之间的关系。实体命名是EntityToEntity的方式命名的，实体包含的属性和关联关系，都会被添加到迁移方案中(Entity Mapping，Attribute Mapping，Relationship Mapping)。</p>

<p>在迁移文件的下方是源文件和目标文件的关系。</p>

<p><img src="http://al1020119.github.io/images/4010.png" title="Caption" ></p>

<p>对应关系</p>

<p>在上面图中改名后的Employee2实体并没有迁移关系，由于是改名后的实体，系统还不知道实体应该怎样做迁移。所以选中Mapping Model文件的Employee2 Mappings，可以看到右侧边栏的Source为invalid value。因为要从Employee实体迁移数据过来，所以将其选择为Employee，迁移关系就设置完成了。</p>

<p>设置完成后，还应该将之前EmployeeToEmployee的Mappings删除，因为这个实体已经被Employee2替代，它的Mappings也被Employee2 Mappings所替代，否则会报错。</p>

<p><img src="http://al1020119.github.io/images/4011.png" title="Caption" ></p>

<p>设置迁移关系</p>

<p>在实体的迁移过程中，还可以通过设置Predicate的方式，来简单的控制迁移过程。例如只需要迁移一部分指定的数据，就可以通过Predicate来指定。可以直接在右侧Filter Predicate的位置设置过滤条件，格式是$source.height &lt; 100，$source代表数据源的实体。</p>

<p><img src="http://al1020119.github.io/images/4012.png" title="Caption" ></p>

<p>Filter Predicate</p>

<p>更复杂的迁移需求</p>

<p>如果还存在更复杂的迁移需求，而且上面的迁移方式不能满足，可以考虑更复杂的迁移方式。假设要在迁移过程中，对迁移的数据进行更改，这时候上面的迁移方案就不能满足需求了。</p>

<p>对于上面提到的问题，在Mapping Model文件中选中实体，可以看到Custom Policy这个选项，选项对应的是NSEntityMigrationPolicy的子类，可以创建并设置一个子类，并重写这个类的方法来控制迁移过程。</p>

<pre><code>- (BOOL)createDestinationInstancesForSourceInstance:(NSManagedObject *)sInstance entityMapping:(NSEntityMapping *)mapping manager:(NSMigrationManager *)manager error:(NSError **)error;
</code></pre>

<p>版本迁移总结</p>

<p>版本迁移在需求的变更中肯定是要发生的，但是我们应该尽量避免这样的情况发生。在最开始设计模型文件数据结构的时候，就应该设计一个比较完善并且容易应对变化的结构，这样后面就算发生变化也不会对结构主体造成大的改动。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CoreData还有撒？]]></title>
    <link href="http://al1020119.github.io/blog/2016/07/04/coredatechaiyousa/"/>
    <updated>2016-07-04T06:59:42+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/07/04/coredatechaiyousa</id>
    <content type="html"><![CDATA[<p>之前两篇文章都比较偏理论，文字表达比较多一些，但都是干货！学习时先理解理论知识，才能更好的帮助后面的理解。在这篇文章中，将会涉及关于CoreData的一些复杂操作，这些操作会涉及分页查询、模糊查询、批处理等高级操作。通过这些操作可以更好的使用CoreData，提升CoreData性能。文章中将会出现大量示例代码，通过代码的方式更有助于理解。</p>

<p>文章内容还会比较多，希望各位耐心看完。文章中如有疏漏或错误，还请各位及时提出，谢谢！</p>

<p>NSPredicate</p>

<!--more-->


<p>概述</p>

<p>在iOS开发过程中，很多需求都需要用到过滤条件。例如过滤一个集合对象中存储的对象，可以通过Foundation框架下的NSPredicate类来执行这个操作。</p>

<p>CoreData中可以通过设置NSFetchRequest类的predicate属性，来设置一个NSPredicate类型的谓词对象当做过滤条件。通过设置这个过滤条件，可以只获取符合过滤条件的托管对象，不会将所有托管对象都加载到内存中。这样是非常节省内存和加快查找速度的，设计一个好的NSPredicate可以优化CoreData搜索性能。</p>

<p>语法</p>

<p>NSPredicate更加偏向于自然语言，不像SQLite一样有很多固定的语法，看起来也更加清晰易懂。例如下面需要查找条件为年龄30岁以上，并且包括30岁的条件。
1</p>

<pre><code>[NSPredicate predicateWithFormat:@"age &gt;= 30"]
</code></pre>

<p>过滤集合对象</p>

<p>可以通过NSPredicate对iOS中的集合对象执行过滤操作，可以是NSArray、NSSet及其子类。</p>

<p>对不可变数组NSArray执行的过滤，过滤后会返回一个NSArray类型的结果数组，其中存储着符合过滤条件的对象。
1</p>

<pre><code>NSArray *results = [array filteredArrayUsingPredicate:predicate]
</code></pre>

<p>对可变数组NSMutableArray执行的过滤条件，过滤后会直接改变原集合对象内部存储的对象，删除不符合条件的对象。
1</p>

<pre><code>[arrayM filterUsingPredicate:predicate]
</code></pre>

<p>复合过滤条件</p>

<p>谓词不只可以过滤简单条件，还可以过滤复杂条件，设置复合过滤条件。
1</p>

<pre><code>[NSPredicate predicateWithFormat:@"(age &lt; 25) AND (firstName = XiaoZhuang)"]
</code></pre>

<p>当然也可以通过NSCompoundPredicate对象来设置复合过滤条件，返回结果是一个NSPredicate的子类NSCompoundPredicate对象。
1</p>

<pre><code>[[NSCompoundPredicate alloc] initWithType:NSAndPredicateType subpredicates:@[predicate1, predicate2]]
</code></pre>

<p>枚举值NSCompoundPredicateType参数，可以设置三种复合条件，枚举值非常直观很容易看懂。</p>

<pre><code>NSNotPredicateType

NSAndPredicateType

NSOrPredicateType
</code></pre>

<p>基础语法</p>

<p>下面是列举的一些NSPredicate的基础语法，这些语法看起来非常容易理解，更复杂的用法可以去看苹果的官方API。</p>

<p><img src="http://al1020119.github.io/images/3001.png" title="Caption" ></p>

<p>正则表达式</p>

<p>NSPredicate中还可以使用正则表达式，可以通过正则表达式完成一些复杂需求，这使得谓词的功能更加强大，例如下面是一个手机号验证的正则表达式。
1
2</p>

<pre><code>NSString *mobile = @"^1(3[0-9]|5[0-35-9]|8[025-9])\\d{8}$";
NSPredicate *regexmobile = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", mobile];
</code></pre>

<p>模糊查询</p>

<p>NSPredicate支持对数据的模糊查询，例如下面使用通配符来匹配包含lxz的结果，具体CoreData中的使用在下面会讲到。
1</p>

<pre><code>[NSPredicate predicateWithFormat:@"name LIKE %@", @"*lxz*"]
</code></pre>

<p>keyPath</p>

<p>NSPredicate在创建查询条件时，还支持设置被匹配目标的keyPath，也就是设置更深层被匹配的目标。例如下面设置employee的name属性为查找条件，就是用点语法设置的keyPath。
1</p>

<pre><code>[NSPredicate predicateWithFormat:@"employee.name = %@", @"lxz"]
</code></pre>

<p>设置查询条件</p>

<p>在之前的文章中，执行下面MOC的fetchRequest方法，一般都需要传入一个NSFetchRequest类型的参数。这个request参数可以做一些设置操作，这样就可以以较优的性能获取指定的数据。
1</p>

<pre><code>- (nullable NSArray *)executeFetchRequest:(NSFetchRequest *)request error:(NSError **)error;
</code></pre>

<p>NSFetchRequest</p>

<p>在执行fetch操作前，可以给NSFetchRequest设置一些参数，这些参数包括谓词、排序等条件，下面是一些基础的设置。</p>

<pre><code>设置查找哪个实体，从数据库的角度来看就是查找哪张表，通过fetchRequestWithEntityName:或初始化方法来指定表名。

通过NSPredicate类型的属性，可以设置查找条件，这个属性在开发中用得最多。NSPredicate可以包括固定格式的条件以及正则表达式。

通过sortDescriptors属性，可以设置获取结果数组的排序方式，这个属性是一个数组类型，也就是可以设置多种排序条件。(但是注意条件不要冲突)

通过fetchOffset属性设置从查询结果的第几个开始获取，通过fetchLimit属性设置每次获取多少个。主要用于分页查询，后面会讲。
</code></pre>

<p>MOC执行fetch操作后，获取的结果是以数组的形式存储的，数组中存储的就是托管对象。NSFetchRequest提供了参数resultType，参数类型是一个枚举类型。通过这个参数，可以设置执行fetch操作后返回的数据类型。</p>

<pre><code>NSManagedObjectResultType: 返回值是NSManagedObject的子类，也就是托管对象，这是默认选项

NSManagedObjectIDResultType: 返回NSManagedObjectID类型的对象，也就是NSManagedObject的ID，对内存占用比较小。MOC可以通过NSManagedObjectID对象获取对应的托管对象，并且可以通过缓存NSManagedObjectID参数来节省内存消耗

NSDictionaryResultType: 返回字典类型对象

NSCountResultType: 返回请求结果的count值，这个操作是发生在数据库层级的，并不需要将数据加载到内存中
</code></pre>

<p>设置获取条件</p>

<pre><code>// 建立获取数据的请求对象，并指明操作Employee表
NSFetchRequest *request = [NSFetchRequest fetchRequestWithEntityName:@"Employee"];
// 设置请求条件，通过设置的条件，来过滤出需要的数据
NSPredicate *predicate = [NSPredicate predicateWithFormat:@"name = %@", @"lxz"];
request.predicate = predicate;
// 设置请求结果排序方式，可以设置一个或一组排序方式，最后将所有的排序方式添加到排序数组中
NSSortDescriptor *sort = [NSSortDescriptor sortDescriptorWithKey:@"height" ascending:YES];
// NSSortDescriptor的操作都是在SQLite层级完成的，不会将对象加载到内存中，所以对内存的消耗是非常小的
request.sortDescriptors = @[sort];
// 执行获取请求操作，获取的托管对象将会被存储在一个数组中并返回
NSError *error = nil;
NSArray *employees = [context executeFetchRequest:request error:&amp;error];
[employees enumerateObjectsUsingBlock:^(Employee * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
    NSLog(@"Employee Name : %@, Height : %@, Brithday : %@", obj.name, obj.height, obj.brithday);
}];
// 错误处理
if (error) {
    NSLog(@"CoreData Fetch Data Error : %@", error);
}
</code></pre>

<p>这里设置NSFetchRequest对象的一些请求条件，设置查找Employee表中name为lxz的数据，并且将所有符合的数据用height值升序的方式排列。</p>

<p>有实体关联关系</p>

<p>一个模型文件中的不同实体间，可以设置实体间的关联关系，这个在之前的文章中讲过。实体关联关系分为对一或对多，也可以设置是否双向关联。</p>

<p>这里演示的实体只是简单的To One的关系，并且下面会给出设置是否双向关联的区别对比。</p>

<p>插入实体</p>

<pre><code>// 创建托管对象，并将其关联到指定的MOC上
Employee *zsEmployee = [NSEntityDescription insertNewObjectForEntityForName:@"Employee" inManagedObjectContext:context];
zsEmployee.name = @"zhangsan";
zsEmployee.height = @1.9f;
zsEmployee.brithday = [NSDate date];
Employee *lsEmployee = [NSEntityDescription insertNewObjectForEntityForName:@"Employee" inManagedObjectContext:context];
lsEmployee.name = @"lisi";
lsEmployee.height = @1.7f;
lsEmployee.brithday = [NSDate date];
Department *iosDepartment = [NSEntityDescription insertNewObjectForEntityForName:@"Department" inManagedObjectContext:context];
iosDepartment.departName = @"iOS";
iosDepartment.createDate = [NSDate date];
iosDepartment.employee = zsEmployee;
Department *androidDepartment = [NSEntityDescription insertNewObjectForEntityForName:@"Department" inManagedObjectContext:context];
androidDepartment.departName = @"android";
androidDepartment.createDate = [NSDate date];
androidDepartment.employee = lsEmployee;
// 执行存储操作
NSError *error = nil;
if (context.hasChanges) {
    [context save:&amp;error];
}
// 错误处理
if (error) {
    NSLog(@"Association Table Add Data Error : %@", error);
}
</code></pre>

<p>上面创建了四个实体，并且将Employee都关联到Department上，完成关联操作后通过MOC存储到本地。</p>

<p>可以看到上面所有的托管对象创建时，都使用NSEntityDescription的insert方法创建，并和上下文建立关系。这时就想问了，我能直接采用传统的init方法创建吗？</p>

<p>会崩的！创建托管对象时需要指定MOC，在运行时动态的生成set、get方法。但是直接通过init方法初始化的对象，系统是不知道这里是需要系统自身生成set、get方法的，而且系统也不知道应该对应哪个MOC，会导致方法未实现的崩溃。所以就出现了开发中经常出现的错误，如下面崩溃信息：
1</p>

<pre><code>-[Employee setName:]: unrecognized selector sent to instance 0x7fa665900f60
</code></pre>

<p>双向关联</p>

<p>在上一篇文章中提到过双向关联的概念，也就是设置Relationship时Inverse是否为空。下面是Employee和Department在数据库中，设置inverse和没有设置inverse的两种数据存储，可以很清晰的对比出设置双向关联的区别。</p>

<p>测试代码还是用上面插入实体的代码，只是更改inverse选项。</p>

<p>设置双向关联</p>

<p><img src="http://al1020119.github.io/images/3002.png" title="Caption" ></p>

<p>Employee</p>

<p><img src="http://al1020119.github.io/images/3003.png" title="Caption" ></p>

<p>Department</p>

<p>未设置双向关联</p>

<p><img src="http://al1020119.github.io/images/3004.png" title="Caption" ></p>

<p>Employee</p>

<p><img src="http://al1020119.github.io/images/3005.png" title="Caption" ></p>

<p>Department</p>

<p>从图中可以看出，未设置双向关联的实体，Department关联Employee为属性并存储后，Department表中的关系是存在的，但Employee表中的关系依然是空的。而设置双向关联后的实体，在Department关联Employee为属性并存储后，Employee在表中自动设置了和Department的关系。</p>

<p>双向关联的关系不只体现在数据库中，在程序运行过程中托管对象的关联属性，也是随着发生变化的。双向关联的双方，一方的关联属性设置关系后，另一方关联属性的关系也会发生变化。用下面的代码打印一下各自的关联属性，结果和上面数据库的变化是一样的。
1</p>

<pre><code>NSLog(@"Department : %@, Employee : %@", androidDepartment.employee, lsEmployee.department);
</code></pre>

<p>查询操作</p>

<pre><code>// 创建获取数据的请求对象，并指明操作Department表
NSFetchRequest *request = [NSFetchRequest fetchRequestWithEntityName:@"Department"];
// 设置请求条件，设置employee的name为请求条件。NSPredicate的好处在于，可以设置keyPath条件
NSPredicate *predicate = [NSPredicate predicateWithFormat:@"employee.name = %@", @"lxz"];
request.predicate = predicate;
// 执行查找操作
NSError *error = nil;
NSArray *departments = [context executeFetchRequest:request error:&amp;error];
[departments enumerateObjectsUsingBlock:^(Department * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
    NSLog(@"Department Search Result DepartName : %@, employee name : %@", obj.departName, obj.employee.name);
}];
// 错误处理
if (error) {
    NSLog(@"Department Search Error : %@", error);
}
</code></pre>

<p>查找Department实体，并打印实体内容。就像上面讲的双向关系一样，有关联关系的实体，自己被查找出来后，也会将与之关联的其他实体也查找出来，并且查找出来的实体都是关联着MOC的。</p>

<p>分页查询</p>

<p>在从本地存储区获取数据时，可以指定从第几个获取，以及本次查询获取多少个数据，联合起来使用就是分页查询。当然也可以根据需求，单独使用这两个API。</p>

<p>这种需求在实际开发中非常常见，例如TableView中，上拉加载数据，每次加载20条数据，就可以利用分页查询轻松实现。</p>

<pre><code>// 创建获取数据的请求对象，并指明操作Employee表
NSFetchRequest *request = [NSFetchRequest fetchRequestWithEntityName:@"Employee"];
// 设置查找起始点，这里是从搜索结果的第六个开始获取
request.fetchOffset = 6;
// 设置分页，每次请求获取六个托管对象
request.fetchLimit = 6;
// 设置排序规则，这里设置身高升序排序
NSSortDescriptor *descriptor = [NSSortDescriptor sortDescriptorWithKey:@"height" ascending:YES];
request.sortDescriptors = @[descriptor];
// 执行查询操作
NSError *error = nil;
NSArray *employees = [context executeFetchRequest:request error:&amp;error];
[employees enumerateObjectsUsingBlock:^(Employee * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
    NSLog(@"Page Search Result Name : %@, height : %@", obj.name, obj.height);
}];
// 错误处理
if (error) {
    NSLog(@"Page Search Data Error : %@", error);
}
</code></pre>

<p>上面是一个按照身高升序排序，分页获取搜索结果的例子。查找Employee表中的实体，将结果按照height字段升序排序，并从结果的第六个开始查找，并且设置获取的数量也是六个。</p>

<p>模糊查询</p>

<p>有时需要获取具有某些相同特征的数据，这样就需要对查询的结果做模糊匹配。在CoreData执行模糊匹配时，可以通过NSPredicate执行这个操作。</p>

<pre><code>// 创建获取数据的请求对象，设置对Employee表进行操作
NSFetchRequest *request = [NSFetchRequest fetchRequestWithEntityName:@"Employee"];
// 创建模糊查询条件。这里设置的带通配符的查询，查询条件是结果包含lxz
NSPredicate *predicate = [NSPredicate predicateWithFormat:@"name LIKE %@", @"*lxz*"];
request.predicate = predicate;
// 执行查询操作
NSError *error = nil;
NSArray *employees = [context executeFetchRequest:request error:&amp;error];
[employees enumerateObjectsUsingBlock:^(Employee * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
    NSLog(@"Fuzzy Search Result Name : %@, height : %@", obj.name, obj.height);
}];
// 错误处理
if (error) {
    NSLog(@"Fuzzy Search Data Error : %@", error);
}
</code></pre>

<p>上面是使用通配符的方式进行模糊查询，NSPredicate支持多种形式的模糊查询，下面列举一些简单的匹配方式。模糊查询条件对大小写不敏感，所以查询条件大小写均可。</p>

<pre><code>以lxz开头
</code></pre>

<p>1</p>

<pre><code>NSPredicate *predicate = [NSPredicate predicateWithFormat:@"name BEGINSWITH %@", @"lxz"];

以lxz结尾
</code></pre>

<p>1</p>

<pre><code>NSPredicate *predicate = [NSPredicate predicateWithFormat:@"name ENDSWITH %@", @"lxz"];

其中包含lxz
</code></pre>

<p>1</p>

<pre><code>NSPredicate *predicate = [NSPredicate predicateWithFormat:@"name contains %@", @"lxz"];

查询条件结果包含lxz
</code></pre>

<p>1</p>

<pre><code>NSPredicate *predicate = [NSPredicate predicateWithFormat:@"name LIKE %@", @"*lxz*"];
</code></pre>

<p>加载请求模板</p>

<p>在之前的文章中谈到在模型文件中设置请求模板，也就是在.xcdatamodeld文件中，设置Fetch Requests，使用时可以通过对应的NSManagedObjectModel获取设置好的模板。</p>

<p>&hellip;. 省略上下文创建步骤 &hellip;.</p>

<pre><code>// 通过MOC获取模型文件对应的托管对象模型
NSManagedObjectModel *model = context.persistentStoreCoordinator.managedObjectModel;
// 通过.xcdatamodeld文件中设置的模板名，获取请求对象
NSFetchRequest *fetchRequest = [model fetchRequestTemplateForName:@"EmployeeFR"];
// 请求数据，下面的操作和普通请求一样
NSError *error = nil;
NSArray *dataList = [context executeFetchRequest:fetchRequest error:&amp;error];
[dataList enumerateObjectsUsingBlock:^(Employee * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
    NSLog(@"Employee.count = %ld, Employee.height = %f", dataList.count, [obj.height floatValue]);
}];
// 错误处理
if (error) {
    NSLog(@"Execute Fetch Request Error : %@", error);
}
</code></pre>

<p>获取结果Count值</p>

<p>开发过程中有时需要只获取所需数据的Count值，也就是执行获取操作后数组中所存储的对象数量。遇到这个需求，如果像之前一样MOC执行获取操作，获取到数组然后取Count，这样对内存消耗是很大的。</p>

<p>对于这个需求，苹果提供了两种常用的方式获取这个Count值。这两种获取操作，都是在数据库中完成的，并不需要将托管对象加载到内存中，对内存的开销也是很小的。</p>

<pre><code>方法1，设置resultType


// 设置过滤条件，可以根据需求设置自己的过滤条件
NSPredicate *predicate = [NSPredicate predicateWithFormat:@"height &lt; 2"];
// 创建请求对象，并指明操作Employee表
NSFetchRequest *fetchRequest = [NSFetchRequest fetchRequestWithEntityName:@"Employee"];
fetchRequest.predicate = predicate;
// 这一步是关键。设置返回结果类型为Count，返回结果为NSNumber类型
fetchRequest.resultType = NSCountResultType;
// 执行查询操作，返回的结果还是数组，数组中只存在一个对象，就是计算出的Count值
NSError *error = nil;
NSArray *dataList = [context executeFetchRequest:fetchRequest error:&amp;error];
NSInteger count = [dataList.firstObject integerValue];
NSLog(@"fetch request result Employee.count = %ld", count);
// 错误处理
if (error) {
    NSLog(@"fetch request result error : %@", error);
}
</code></pre>

<p>方法1中设置NSFetchRequest对象的resultType为NSCountResultType，获取到结果的Count值。这个枚举值在之前的文章中提到过，除了Count参数，还可以设置其他三种参数。</p>

<pre><code>方法2，使用MOC提供的方法


// 设置过滤条件
NSPredicate *predicate = [NSPredicate predicateWithFormat:@"height &lt; 2"];
// 创建请求对象，指明操作Employee表
NSFetchRequest *fetchRequest = [NSFetchRequest fetchRequestWithEntityName:@"Employee"];
fetchRequest.predicate = predicate;
// 通过调用MOC的countForFetchRequest:error:方法，获取请求结果count值，返回结果直接是NSUInteger类型变量
NSError *error = nil;
NSUInteger count = [context countForFetchRequest:fetchRequest error:&amp;error];
NSLog(@"fetch request result count is : %ld", count);
// 错误处理
if (error) {
    NSLog(@"fetch request result error : %@", error);
}
</code></pre>

<p>MOC提供了专门获取请求结果Count值的方法，通过这个方法可以直接返回一个NSUInteger类型的Count值，使用起来比上面的方法更方便点，其他都是一样的。</p>

<p>位运算</p>

<p>假设有需求是对Employee表中，所有托管对象的height属性计算总和。这个需求在数据量比较大的情况下，将所有托管对象加载到内存中是非常消耗内存的，就算批量加载也比较耗时耗内存。</p>

<p>CoreData对于这样的需求，提供了位运算的功能。MOC在执行请求时，是支持对数据进行位运算的。这个操作依然是在数据库层完成的，对内存的占用非常小。</p>

<pre><code>// 创建请求对象，指明操作Employee表
NSFetchRequest *fetchRequest = [NSFetchRequest fetchRequestWithEntityName:@"Employee"];
// 设置返回值为字典类型，这是为了结果可以通过设置的name名取出，这一步是必须的
fetchRequest.resultType = NSDictionaryResultType;
// 创建描述对象
NSExpressionDescription *expressionDes = [[NSExpressionDescription alloc] init];
// 设置描述对象的name，最后结果需要用这个name当做key来取出结果
expressionDes.name = @"sumOperatin";
// 设置返回值类型，根据运算结果设置类型
expressionDes.expressionResultType = NSFloatAttributeType;
// 创建具体描述对象，用来描述对那个属性进行什么运算(可执行的运算类型很多，这里描述的是对height属性，做sum运算)
NSExpression *expression = [NSExpression expressionForFunction:@"sum:" arguments:@[[NSExpression expressionForKeyPath:@"height"]]];
// 只能对应一个具体描述对象
expressionDes.expression = expression;
// 给请求对象设置描述对象，这里是一个数组类型，也就是可以设置多个描述对象
fetchRequest.propertiesToFetch = @[expressionDes];
// 执行请求，返回值还是一个数组，数组中只有一个元素，就是存储计算结果的字典
NSError *error = nil;
NSArray *resultArr = [context executeFetchRequest:fetchRequest error:&amp;error];
// 通过上面设置的name值，当做请求结果的key取出计算结果
NSNumber *number = resultArr.firstObject[@"sumOperatin"];
NSLog(@"fetch request result is %f", [number floatValue]);
// 错误处理
if (error) {
    NSLog(@"fetch request result error : %@", error);
}
</code></pre>

<p>执行结果：</p>

<p><img src="http://al1020119.github.io/images/3006.png" title="Caption" ></p>

<p>从执行结果可以看到，MOC对所有查找到的托管对象height属性执行了求和操作，并将结果放在字典中返回。位运算主要是通过NSFetchRequest对象的propertiesToFetch属性设置，这个属性可以设置多个描述对象，最后通过不同的name当做key来取出结果即可。</p>

<p>NSExpression类可以描述多种运算，可以在NSExpression.h文件中的注释部分，看到所有支持的运算类型，大概看了一下有二十多种运算。而且除了上面NSExpression调用的方法，此类还支持点语法的位运算，例如下面的例子。
1</p>

<pre><code>[NSExpression expressionWithFormat:@"@sum.height"];
</code></pre>

<p>批处理</p>

<p>在使用CoreData之前，我和公司同事也讨论过，假设遇到需要大量数据处理的时候怎么办。CoreData对于大量数据处理的灵活性肯定不如SQLite，这时候还需要自己使用其他方式优化数据处理。虽然在移动端这种情况很少出现，但是在持久层设计时还是要考虑这方面。</p>

<p>当需要进行数据的处理时，CoreData需要先将数据加载到内存中，然后才能对数据进行处理。这样对于大量数据来说，都加载到内存中是非常消耗内存的，而且容易导致崩溃的发生。如果遇到更改所有数据的某个字段这样的简单需求，需要将相关的托管对象都加载到内存中，然后进行更改、保存。</p>

<p>对于上面这样的问题，CoreData在iOS8推出了批量更新API，通过这个API可以直接在数据库一层就完成更新操作，而不需要将数据加载到内存。除了批量更新操作，在iOS9中还推出了批量删除API，也是在数据库一层完成的操作。关于批处理的API很多都是iOS8、iOS9出来的，使用时需要注意版本兼容。</p>

<p>但是有个问题，批量更新和批量删除的两个API，都是直接对数据库进行操作，更新完之后会导致MOC缓存和本地持久化数据不同步的问题。所以需要手动刷新受影响的MOC中存储的托管对象，使MOC和本地统一。假设你使用了NSFetchedResultsController，为了保证界面和数据的统一，这一步更新操作更需要做。</p>

<p>批量更新</p>

<pre><code>// 创建批量更新对象，并指明操作Employee表。
NSBatchUpdateRequest *updateRequest = [NSBatchUpdateRequest batchUpdateRequestWithEntityName:@"Employee"];
// 设置返回值类型，默认是什么都不返回(NSStatusOnlyResultType)，这里设置返回发生改变的对象Count值
updateRequest.resultType = NSUpdatedObjectsCountResultType;
// 设置发生改变字段的字典
updateRequest.propertiesToUpdate = @{@"height" : [NSNumber numberWithFloat:5.f]};
// 执行请求后，返回值是一个特定的result对象，通过result的属性获取返回的结果。MOC的这个API是从iOS8出来的，所以需要注意版本兼容。
NSError *error = nil;
NSBatchUpdateResult *result = [context executeRequest:updateRequest error:&amp;error];
NSLog(@"batch update count is %ld", [result.result integerValue]);
// 错误处理
if (error) {
    NSLog(@"batch update request result error : %@", error);
}
// 更新MOC中的托管对象，使MOC和本地持久化区数据同步
[context refreshAllObjects];
</code></pre>

<p>上面对Employee表中所有的托管对象height值做了批量更新，在更新时通过设置propertiesToUpdate字典来控制更新字段和更新的值，设置格式是字段名 : 新值。通过设置批处理对象的predicate属性，设置一个谓词对象来控制受影响的对象。</p>

<p>还可以对多个存储区(数据库)做同样批处理操作，通过设置其父类的affectedStores属性，类型是一个数组，可以包含受影响的存储区，多个存储区的操作对批量删除同样适用。</p>

<p>MOC在执行请求方法时，发现方法名也不一样了，执行的是executeRequest: error:方法，这个方法是从iOS8之后出来的。方法传入的参数是NSBatchUpdateRequest类，此类并不是继承自NSFetchRequest类，而是直接继承自NSPersistentStoreRequest，和NSFetchRequest是平级关系。</p>

<p>批量删除</p>

<pre><code>// 创建请求对象，并指明对Employee表做操作
NSFetchRequest *fetchRequest = [NSFetchRequest fetchRequestWithEntityName:@"Employee"];
// 通过谓词设置过滤条件，设置条件为height小于1.7
NSPredicate *predicate = [NSPredicate predicateWithFormat:@"height &lt; %f", 1.7f];
fetchRequest.predicate = predicate;
// 创建批量删除请求，并使用上面创建的请求对象当做参数进行初始化
NSBatchDeleteRequest *deleteRequest = [[NSBatchDeleteRequest alloc] initWithFetchRequest:fetchRequest];
// 设置请求结果类型，设置为受影响对象的Count
deleteRequest.resultType = NSBatchDeleteResultTypeCount;
// 使用NSBatchDeleteResult对象来接受返回结果，通过id类型的属性result获取结果
NSError *error = nil;
NSBatchDeleteResult *result = [context executeRequest:deleteRequest error:&amp;error];
NSLog(@"batch delete request result count is %ld", [result.result integerValue]);
// 错误处理
if (error) {
    NSLog(@"batch delete request error : %@", error);
}
// 更新MOC中的托管对象，使MOC和本地持久化区数据同步
[context refreshAllObjects];
</code></pre>

<p>大多数情况下，涉及到托管对象的操作，都需要将其加载到内存中完成。所以使用CoreData时，需要注意内存的使用，不要在内存中存在过多的托管对象。在已经做系统兼容的情况下，进行大量数据的操作时，应该尽量使用批处理来完成操作。</p>

<p>需要注意的是，refreshAllObjects是从iOS9出来的，在iOS9之前因为要做版本兼容，所以需要使用refreshObject: mergeChanges:方法更新托管对象。</p>

<p>异步请求</p>

<pre><code>// 创建请求对象，并指明操作Employee表
NSFetchRequest *fetchRequest = [NSFetchRequest fetchRequestWithEntityName:@"Employee"];
// 创建异步请求对象，并通过一个block进行回调，返回结果是一个NSAsynchronousFetchResult类型参数
NSAsynchronousFetchRequest *asycFetchRequest = [[NSAsynchronousFetchRequest alloc] initWithFetchRequest:fetchRequest completionBlock:^(NSAsynchronousFetchResult * _Nonnull result) {
    [result.finalResult enumerateObjectsUsingBlock:^(Employee * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
        NSLog(@"fetch request result Employee.count = %ld, Employee.name = %@", result.finalResult.count, obj.name);
    }];
}];
// 执行异步请求，和批量处理执行同一个请求方法
NSError *error = nil;
[context executeRequest:asycFetchRequest error:&amp;error];
// 错误处理
if (error) {
    NSLog(@"fetch request result error : %@", error);
}
</code></pre>

<p>上面通过NSAsynchronousFetchRequest对象创建了一个异步请求，并通过block进行回调。如果有多个请求同时发起，不需要担心线程安全的问题，系统会将所有的异步请求添加到一个操作队列中，在前一个任务访问数据库时，CoreData会将数据库加锁，等前面的执行完成才会继续执行后面的操作。</p>

<p>NSAsynchronousFetchRequest提供了cancel方法，也就是可以在请求过程中，将这个请求取消。还可以通过一个NSProgress类型的属性，获取请求完成进度。NSAsynchronousFetchRequest类从iOS8开始可以使用，所以低版本需要做版本兼容。</p>

<p>需要注意的是，执行请求时MOC并发类型不能是NSConfinementConcurrencyType，这个并发类型已经被抛弃，会导致崩溃。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CoreData怎么用？]]></title>
    <link href="http://al1020119.github.io/blog/2016/07/04/coredatebzmshiyong/"/>
    <updated>2016-07-04T04:59:42+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/07/04/coredatebzmshiyong</id>
    <content type="html"><![CDATA[<p>第一篇文章中并没有讲CoreData的具体用法，只是对CoreData做了一个详细的介绍，算是一个开始和总结吧。</p>

<p>这篇文章中会主要讲CoreData的基础使用，以及在使用中需要注意的一些细节。因为文章中会插入代码和图片，内容可能会比较多，比较考验各位耐心。</p>

<p>文章中如有疏漏或错误，还请各位及时提出，谢谢！??</p>

<p>创建自带CoreData的工程</p>

<!--more-->


<p>在新建一个项目时，可以勾选Use Core Data选项，这样创建出来的工程系统会默认生成一些CoreData的代码以及一个.xcdatamodeld后缀的模型文件，模型文件默认以工程名开头。这些代码在AppDelegate类中，也就是代表可以在全局使用AppDelegate.h文件中声明的CoreData方法和属性。</p>

<p>系统默认生成的代码是非常简单的，只是生成了基础的托管对象模型、托管对象上下文、持久化存储调度器，以及MOC的save方法。但是这些代码已经可以完成基础的CoreData操作了。</p>

<p>1469788227988682.png</p>

<p>系统生成代码</p>

<p>这部分代码不应该放在AppDelegate中，尤其对于大型项目来说，更应该把这部分代码单独抽离出去，放在专门的类或模块来管理CoreData相关的逻辑。所以我一般不会通过这种方式创建CoreData，我一般都是新建一个“干净”的项目，然后自己往里面添加，这样对于CoreData的完整使用流程掌握的也比较牢固。</p>

<p>CoreData模型文件的创建</p>

<p>构建模型文件</p>

<p>使用CoreData的第一步是创建后缀为.xcdatamodeld的模型文件，使用快捷键Command + N，选择Core Data -> Data Model -> Next，完成模型文件的创建。</p>

<p>创建完成后可以看到模型文件左侧列表，有三个选项Entities、Fetch Requests、Configurations，分别对应着实体、请求模板、配置信息。</p>

<p><img src="http://al1020119.github.io/images/2001.png" title="Caption" >
模型文件</p>

<p>添加实体</p>

<p>现在可以通过长按左侧列表下方的Add Entity按钮，会弹出Add Entity、Add Fetch Request、Add Configuration选项，可以添加实体、请求模板、配置信息。这里先选择Add Entity来添加一个实体，命名为Person。</p>

<p>添加Person实体后，会发现一个实体对应着三部分内容，Attributes、Relationships、Fetched Properties，分别对应着属性、关联关系、获取操作。</p>

<p><img src="http://al1020119.github.io/images/2002.png" title="Caption" ></p>

<p>空实体</p>

<p>现在对Person实体添加两个属性，添加age属性并设置type为Integer 16，添加name属性并设置type为String。</p>

<p><img src="http://al1020119.github.io/images/2003.png" title="Caption" >
添加属性</p>

<p>实体属性类型</p>

<p>在模型文件的实体中，参数类型和平时创建继承自NSObject的模型类大体类似，但是还是有一些关于类型的说明，下面简单的列举了一下。</p>

<pre><code>Undefined: 默认值，参与编译会报错

Integer 16: 整数，表示范围 -32768 ~ 32767

Integer 32: 整数，表示范围 -2147483648 ~ 2147483647

Integer 64: 整数，表示范围 –9223372036854775808 ~ 9223372036854775807

Float: 小数，通过MAXFLOAT宏定义来看，最大值用科学计数法表示是 0x1.fffffep+127f

Double: 小数，小数位比Float更精确，表示范围更大

String: 字符串，用NSString表示

Boolean: 布尔值，用NSNumber表示

Date: 时间，用NSDate表示

Binary Data: 二进制，用NSData表示

Transformable: OC对象，用id表示。可以在创建托管对象类文件后，手动改为对应的OC类名。使用的前提是，这个OC对象必须遵守并实现NSCoding协议
</code></pre>

<p>添加实体关联关系</p>

<p>创建两个实体Department和Employee，并且在这两个实体中分别添加一些属性，下面将会根据这两个实体来添加关联关系。
<img src="http://al1020119.github.io/images/2004.png" title="Caption" ></p>

<p>创建实体</p>

<p>给Employee实体添加关系，在Relationships的位置点击加号，添加一个关联关系。添加关系的名称设为department，类型设置为Department，Inverse设置为employee(后面会讲解这个inverse的作用)。</p>

<p><img src="http://al1020119.github.io/images/2005.png" title="Caption" ></p>

<p>添加Relationships</p>

<p>选择Department实体，点击Relationships位置的加号，添加关联关系。</p>

<p>Department实体添加Relationships的操作和Employee都一样，区别在于用红圈标出的Type，这里设置的To Many一对多的关系。这里默认是To One一对一，上面的Employee就是一对一的关系。也就符合一个Department可以有多个Employee，而Employee只能有一个Department的情况，这也是符合常理的。</p>

<p><img src="http://al1020119.github.io/images/2006.png" title="Caption" ></p>

<p>添加Relationships</p>

<p>Relationships类似于SQLite的外键，定义了在同一个模型中，实体与实体之间的关系。可以定义为对一关系或对多关系，也可以定义单向或双向的关系，根据需求来确定。如果是对多的关系，默认是使用NSSet集合来存储模型。</p>

<p>Inverse是两个实体在Relationships中设置关联关系后，通过设置inverse为对应的实体，这样可以从一个实体找到另一个实体，使两个实体具有双向的关联关系。</p>

<p>Fetched Properties</p>

<p>在实体最下面，有一个Fetched Properties选项，这个选项用的不多，这里就不细讲了。</p>

<p>Fetched Properties用于定义查询操作，和NSFetchRequest功能相同。定义fetchedProperty对象后，可以通过NSManagedObjectModel类的fetchRequestFromTemplateWithName:substitutionVariables:方法或其他相关方法获取这个fetchedProperty对象。</p>

<p><img src="http://al1020119.github.io/images/2007.png" title="Caption" ></p>

<p>fetched Property</p>

<p>获取这个对象后，系统会默认将这个对象缓存到一个字典中，缓存之后也可以通过fetchedProperty字典获取fetchedProperty对象。</p>

<p>Data Model Inspector</p>

<p>选中一个实体后，右侧的侧边栏(Data Model Inspector)还有很多选项，这些选项可以对属性进行配置。根据不同的属性类型，侧边栏的显示也不太一样，下面是一个String类型的属性。</p>

<p><img src="http://al1020119.github.io/images/2008.png" title="Caption" ></p>

<p>Data Model Inspector</p>

<p>属性设置</p>

<pre><code>default Value: 设置默认值，除了二进制不能设置，其他类型几乎都能设置。

optional: 在使用时是否可选，也可以理解为如果设置为NO，只要向MOC进行save操作，这个属性是否必须有值。否则MOC进行操作时会失败并返回一个error，该选项默认为YES。

transient: 设置当前属性是否只存在于内存，不被持久化到本地，如果设置为YES，这个属性就不参与持久化操作，属性的其他操作没有区别。transient非常适合存储一些在内存中缓存的数据，例如存储临时数据，这些数据每次都是不同的，而且不需要进行本地持久化，所以可以声明为transient的属性。

indexed: 设置当前属性是否是索引。添加索引后可以有效的提升检索操作的速度。但是对于删除这样的操作，删除索引后其他地方还需要做出相应的变化，所以速度会比较慢。

Validation: 通过Validation可以设置Max Value和Min Value，通过这两个条件来约定数据，对数据的存储进行一个验证。数值类型都有相同的约定方式，而字符串则是约定长度，date是约定时间。

Reg. Ex.(Regular Expression): 可以设置正则表达式，用来验证和控制数据，不对数据自身产生影响。(只能应用于String类型)

Allows External Storage: 当存储二进制文件时，如果遇到比较大的文件，是否存储在存储区之外。如果选择YES，存储文件大小超过1MB的文件，都会存储在存储区之外。否则大型文件存储在存储区内，会造成SQLite进行表操作时，效率受到影响。
</code></pre>

<p>Relationships设置</p>

<pre><code>delete rule: 定义关联属性的删除规则。在当前对象和其他对象有关联关系时，当前对象被删除后与之关联对象的反应。这个参数有四个枚举值，代码对应着模型文件的相同选项。

NSNoActionDeleteRule 删除后没有任何操作，也不会将关联对象的关联属性指向nil。删除后使用关联对象的关联属性，可能会导致其他问题。

NSNullifyDeleteRule 删除后会将关联对象的关联属性指向nil，这是默认值。

NSCascadeDeleteRule 删除当前对象后，会将与之关联的对象也一并删除。

NSDenyDeleteRule 在删除当前对象时，如果当前对象还指向其他关联对象，则当前对象不能被删除。

Type: 主要有两种类型，To One和To Many，表示当前关系是一对多还是一对一。
</code></pre>

<p>实体</p>

<pre><code>Parent Entity: 可以在实体中创建继承关系，在一个实体的菜单栏中通过Parent Entity可以设置父实体，这样就存在了实体的继承关系，最后创建出来的托管模型类也是具有继承关系的。注意继承关系中属性名不要相同。
</code></pre>

<p>使用了这样的继承关系后，系统会将子类继承父类的数据，存在父类的表中，所有继承自同一父类的子类都会将父类部分存放在父类的表中。这样可能会导致父类的表中数据量过多，造成性能问题。</p>

<p>Fetch Requests</p>

<p>在模型文件中Entities下面有一个Fetch Requests，这个也是配置请求对象的。但是这个使用起来更加直观，可以很容易的完成一些简单的请求配置。相对于上面讲到的Fetched Properties，这个还是更方便使用一些。</p>

<p><img src="http://al1020119.github.io/images/2009.png" title="Caption" ></p>

<p>Fetch Requests</p>

<p>上面是对Employee实体的height属性配置的Fetch Request，这里配置的height要小于2米。配置之后可以通过NSManagedObjectModel类的fetchRequestTemplateForName:方法获取这个请求对象，参数是这个请求配置的名称，也就是EmployeeFR。</p>

<p>Editor Style</p>

<p>这是我认为CoreData最大的优势之一，可视化的模型文件结构。可以很清楚的看到实体和属性的关系，以及实体之间的对应关系。</p>

<p><img src="http://al1020119.github.io/images/2010.png" title="Caption" ></p>

<p>Editor Style</p>

<p>一个.xcdatamodeld模型文件的展示风格有两种，一种是列表的形式(Table)，另一种是图表的形式展示(Graph)。</p>

<p>图表看起来更加直观，而图表在操作上也有一些比Table更方便的地方。例如在Table的状态下添加两个实体的关联关系，如果只做一次关联操作，默认是单向的关系。而在Graph的状态下，按住Control对两个图表进行连线，两个实体的结果就是双向关联的关系。</p>

<p>手动创建实体</p>

<p>假设不使用.xcdatamodeld模型文件，全都是纯代码，怎么在项目里创建实体啊？这样的话就需要通过代码创建实体描述、关联描述等信息，然后设置给NSManagedObjectModel对象。而使用模型文件的话一般都是通过NSManagedObjectModel对象来读取文件。</p>

<p>如果是纯代码的话，苹果更推荐使用KVC的方式存取值，然后所有托管对象都用NSManagedObject创建。但是这样存在的问题很多，开发成本比较大、使用不方便等等。最大的问题就是写属性名的key字符串，很容易出错，而且这样失去了CoreData原有的优点。所以还是推荐使用.xcdatamodeld模型文件的开发方式。</p>

<p>创建托管对象类文件</p>

<p>创建文件</p>

<p>创建实体后，就可以根据对应的实体，生成开发中使用的基于NSManagedObject类的托管对象类文件。</p>

<p>还是按照上面Department和Employee的例子，先创建一个Department实体。因为Department实体有对多关系，生成托管对象类文件的关联属性不一样，可以体现出和对一关系的区别，所以使用Department实体生成文件。</p>

<p>快捷键Command + N -> NSManagedObject subclass -> 选择模型文件 -> 选择实体，生成Department实体对应的托管对象类文件。</p>

<p><img src="http://al1020119.github.io/images/2012.png" title="Caption" ></p>

<p>生成的托管对象类文件</p>

<p>可以看到上面生成了四个文件，以实体名开头的.h和.m文件，另外两个是这个实体的Category文件。为什么生成Category文件？一会再说，先打开类文件进去看看。</p>

<p>Category</p>

<p><img src="http://al1020119.github.io/images/2013.png" title="Caption" ></p>

<p>实体Category</p>

<p>可以看到类文件中有两个Category，分别是CoreDataProperties和CoreDataGeneratedAccessors。其中如果没有设置对多关系的实体，只会有CoreDataProperties，而设置了对多关系的实体系统会为其生成CoreDataGeneratedAccessors。</p>

<p>CoreDataProperties中会生成实体中声明的Attributes和Relationships中的属性，其中对多关系是用NSSet存储的属性，如果是对一的关系则是非集合的对象类型属性。再看.m文件中，所有属性都用@dynamic修饰，CoreData会在运行时动态为所有Category中的属性生成实现代码，所以这里用@dynamic修饰。</p>

<p>对多属性生成的CoreDataGeneratedAccessors，是系统自动生成管理对多属性集合的方法，一般都是一个属性对应四个方法，方法的实现也是在运行时动态实现的，方法都是用来操作集合对象的。</p>

<p>托管对象类文件</p>

<p>点击系统生成的托管对象类文件，此类是继承自NSManagedObject类的。可以看到里面非常干净，没有其他逻辑代码。</p>

<p>根据苹果的注释代码：Insert code here to declare functionality of your managed object subclass，提示应该在这个文件中编写此类相关的逻辑代码。这里就是编写此类逻辑代码的地方，当然也可以什么都不写，看需求啦。</p>

<p>任意类型属性</p>

<p>实体支持创建任意继承自NSObject类的属性，例如项目中手动创建的类。项目中创建的类在下拉列表中并不会体现，可以在属性类型选择transformable类型，然后生成托管对象类文件的时候，系统会将这个属性声明为id类型，在创建类文件后，可以直接手动更改这个属性的类型为我们想要的类型。</p>

<p>对于手动设置的属性有一个要求，属性所属的类必须是遵守NSCoding协议，因为这个属性要被归档到本地。</p>

<p>标量类型</p>

<p>创建托管对象类文件时，实体属性的类型无论是选择的integer32还是float，只要是基础数据类型，最后创建出来的默认都是NSNumber类型的，这是Xcode默认的。</p>

<p>如果需要生成的属性类型是基础数据类型，可以在创建文件时勾选Use scalar properties for primitive data types选项，这样就告诉系统需要生成标量类型属性，创建出来的属性就是int64_t、float这样的基础数据类型。</p>

<p><img src="http://al1020119.github.io/images/2014.png" title="Caption" ></p>

<p>标量类型</p>

<p>更新文件</p>

<p>当前模型对应的实体发生改变后，需要重新生成模型Category文件。生成步骤和上面一样，主要是替换Category文件，托管对象文件不会被替换。生成文件时不需要删除，直接替换文件。</p>

<p>CoreData增删改查</p>

<p>下面关于CoreData的相关操作，还是基于上面Department和Employee的例子。并且引入了Company当做.xcdatamodeld模型文件，前面两个实体被包含在Company中。</p>

<p>先讲讲NSManagedObjectContext</p>

<p>在iOS5之前创建NSManagedObjectContext对象时，都是直接通过init方法来创建。iOS5之后苹果更加推荐使用initWithConcurrencyType:方法来创建，在创建的时候指定当前是什么类型的并发队列，初始化方法参数是一个枚举值。这里简单说说MOC，后面多线程部分还会涉及MOC多线程相关的东西。</p>

<p>NSManagedObjectContext初始化方法的枚举值参数主要有三个类型：</p>

<pre><code>NSConfinementConcurrencyType 如果使用init方法初始化上下文，默认就是这个并发类型。在iOS9之后已经被苹果废弃，不建议用这个API，调用某些比较新的CoreData的API可能会导致崩溃。

NSPrivateQueueConcurrencyType 私有并发队列类型，操作都是在子线程中完成的。

NSMainQueueConcurrencyType 主并发队列类型，如果涉及到UI相关的操作，应该考虑使用这个参数初始化上下文。
</code></pre>

<p>如果还使用init方法，可能会对后面推出的一些API不兼容，导致多线程相关的错误。例如下面的错误，因为如果没有显式的设置并发类型，默认是一个已经弃用的NSConfinementConcurrencyType类型，就会导致新推出的API发生不兼容的崩溃错误。</p>

<pre><code>Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: 'NSConfinementConcurrencyType context
</code></pre>

<p>创建MOC</p>

<p>下面是根据Company模型文件，创建了一个主队列并发类型的MOC。</p>

<pre><code>// 创建上下文对象，并发队列设置为主队列
NSManagedObjectContext *context = [[NSManagedObjectContext alloc] initWithConcurrencyType:NSMainQueueConcurrencyType];
// 创建托管对象模型，并使用Company.momd路径当做初始化参数
NSURL *modelPath = [[NSBundle mainBundle] URLForResource:@"Company" withExtension:@"momd"];
NSManagedObjectModel *model = [[NSManagedObjectModel alloc] initWithContentsOfURL:modelPath];
// 创建持久化存储调度器
NSPersistentStoreCoordinator *coordinator = [[NSPersistentStoreCoordinator alloc] initWithManagedObjectModel:model];
// 创建并关联SQLite数据库文件，如果已经存在则不会重复创建
NSString *dataPath = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).lastObject;
dataPath = [dataPath stringByAppendingFormat:@"/%@.sqlite", @"Company"];
[coordinator addPersistentStoreWithType:NSSQLiteStoreType configuration:nil URL:[NSURL fileURLWithPath:dataPath] options:nil error:nil];
// 上下文对象设置属性为持久化存储器
context.persistentStoreCoordinator = coordinator;
</code></pre>

<p>这段代码创建了一个MOC，我们从上往下看这段代码。</p>

<p>momd文件</p>

<p>关于MOC的并发队列类型上面已经简单说了，MOC下面出现了momd的字样，这是什么东西？</p>

<p><img src="http://al1020119.github.io/images/2015.png" title="Caption" ></p>

<p>momd文件</p>

<p>在创建后缀为.xcdatamodeld的模型文件后，模型文件在编译期将会被编译为后缀为.momd的文件，存放在.app中，也就是Main Bundle中。在存在多个模型文件时，我们需要通过加载不同的.momd文件，来创建不同的NSManagedObjectModel对象，每个NSManagedObjectModel对应着不同的模型文件。</p>

<p>NSManagedObjectModel类中包含了模型文件中的所有entities、configurations、fetchRequests的描述。虽然.momd文件是支持存放在.app中的，其他人可以通过打开.app包看到这个文件。但是这个文件是经过编码的，并不会知道这个.momd文件中的内容，所以这个文件是非常安全的。通过NSManagedObjectModel获取模型文件描述后，来创建和关联数据库，并交给PSC管理。</p>

<p>如果不指定NSManagedObjectModel对应哪个模型文件，直接使用init方法初始化NSManagedObjectModel类，系统会默认将所有模型文件的表都放在一个SQLite数据库中。所以需要使用mainBundle中的不同.momd文件，对不同的NSManagedObjectModel进行初始化，这样在创建数据库时就会创建不同的数据库文件。</p>

<p>持久化存储调度器(PSC)</p>

<p>在NSManagedObjectModel下面就是NSPersistentStoreCoordinator，这个类在CoreData框架体系中起到了“中枢”的作用。对上层起到了提供简单的调用接口，并向上层隐藏持久化实现逻辑。对下层起到了协调多个持久化存储对象(NSPersistentStore)，使下层只需要专注持久化相关逻辑。</p>

<p><img src="http://al1020119.github.io/images/2016.png" title="Caption" ></p>

<p>持久化存储调度器</p>

<p>addPersistentStoreWithType: configuration: URL: options: error:方法是PSC创建并关联数据库的部分，关联本地数据库后会返回一个NSPersistentStore类型对象，这个对象负责具体持久化存储的实现。可以看到这个方法是一个实例方法，也就是可以添加多个持久化存储对象，并且多个持久化存储对象都关联一个PSC，这是允许的，在上面的图中也看到了这样的结构。但是这样的需求并不多，而且管理起来比较麻烦，一般都不会这样做。</p>

<p>PSC有四种可选的持久化存储方案，用得最多的是SQLite的方式。其中Binary和XML这两种方式，在进行数据操作时，需要将整个文件加载到内存中，这样对内存的消耗是很大的。</p>

<pre><code>NSSQLiteStoreType : SQLite数据库

NSXMLStoreType : XML文件

NSBinaryStoreType : 二进制文件

NSInMemoryStoreType : 直接存储在内存中
</code></pre>

<p>插入操作</p>

<pre><code>// 创建托管对象，并指明创建的托管对象所属实体名
Employee *emp = [NSEntityDescription insertNewObjectForEntityForName:@"Employee" inManagedObjectContext:context];
emp.name = @"lxz";
emp.height = @1.7;
emp.brithday = [NSDate date];
// 通过上下文保存对象，并在保存前判断是否有更改
NSError *error = nil;
if (context.hasChanges) {
    [context save:&amp;error];
}
// 错误处理
if (error) {
    NSLog(@"CoreData Insert Data Error : %@", error);
}
</code></pre>

<p>通过NSEntityDescription的insert类方法，生成并返回一个Employee托管对象，并将这个对象插入到指定的上下文中。</p>

<p>MOC将操作的数据存放在缓存层，只有调用MOC的save方法后，才会真正对数据库进行操作，否则这个对象只是存在内存中，这样做避免了频繁的数据库访问。</p>

<p>删除操作</p>

<pre><code>// 建立获取数据的请求对象，指明对Employee实体进行删除操作
NSFetchRequest *request = [NSFetchRequest fetchRequestWithEntityName:@"Employee"];
// 创建谓词对象，过滤出符合要求的对象，也就是要删除的对象
NSPredicate *predicate = [NSPredicate predicateWithFormat:@"name = %@", @"lxz"];
request.predicate = predicate;
// 执行获取操作，找到要删除的对象
NSError *error = nil;
NSArray *employees = [context executeFetchRequest:request error:&amp;error];
// 遍历符合删除要求的对象数组，执行删除操作
[employees enumerateObjectsUsingBlock:^(Employee * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
    [context deleteObject:obj];
}];
// 保存上下文
if (context.hasChanges) {
    [context save:nil];
}
// 错误处理
if (error) {
    NSLog(@"CoreData Delete Data Error : %@", error);
}
</code></pre>

<p>首先获取需要删除的托管对象，遍历获取的对象数组，逐个删除后调用MOC的save方法保存。</p>

<p>修改操作</p>

<pre><code>// 建立获取数据的请求对象，并指明操作的实体为Employee
NSFetchRequest *request = [NSFetchRequest fetchRequestWithEntityName:@"Employee"];
// 创建谓词对象，设置过滤条件
NSPredicate *predicate = [NSPredicate predicateWithFormat:@"name = %@", @"lxz"];
request.predicate = predicate;
// 执行获取请求，获取到符合要求的托管对象
NSError *error = nil;
NSArray *employees = [context executeFetchRequest:request error:&amp;error];
[employees enumerateObjectsUsingBlock:^(Employee * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
    obj.height = @3.f;
}];
// 将上面的修改进行存储
if (context.hasChanges) {
    [context save:nil];
}
// 错误处理
if (error) {
    NSLog(@"CoreData Update Data Error : %@", error);
}
</code></pre>

<p>和上面一样，首先获取到需要更改的托管对象，更改完成后调用MOC的save方法持久化到本地。</p>

<p>查找操作</p>

<pre><code>// 建立获取数据的请求对象，指明操作的实体为Employee
NSFetchRequest *request = [NSFetchRequest fetchRequestWithEntityName:@"Employee"];
// 执行获取操作，获取所有Employee托管对象
NSError *error = nil;
NSArray *employees = [context executeFetchRequest:request error:&amp;error];
[employees enumerateObjectsUsingBlock:^(Employee * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
    NSLog(@"Employee Name : %@, Height : %@, Brithday : %@", obj.name, obj.height, obj.brithday);
}];
// 错误处理
if (error) {
    NSLog(@"CoreData Ergodic Data Error : %@", error);
}
</code></pre>

<p>查找操作最简单粗暴，因为是演示代码，所以直接将所有Employee表中的托管对象加载出来。在实际开发中肯定不会这样做，只需要加载需要的数据。后面还会讲到一些更高级的操作，会涉及到获取方面的东西。</p>

<p>总结</p>

<p>在CoreData中所有的托管对象被创建出来后，都是关联着MOC对象的。所以在对象进行任何操作后，都会被记录在MOC中。在最后调用MOC的save方法后，MOC会将操作交给PSC去处理，PSC将会将这个存储任务指派给NSPersistentStore对象。</p>

<p>上面的增删改查操作，看上去大体流程都差不多，都是一些最基础的简单操作，在下一篇文章中将会将一些比较复杂的操作。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CoreData是什么？]]></title>
    <link href="http://al1020119.github.io/blog/2016/07/04/coredateashishemme/"/>
    <updated>2016-07-04T02:59:42+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/07/04/coredateashishemme</id>
    <content type="html"><![CDATA[<p>这段时间公司一直比较忙，和组里小伙伴一起把公司项目按照之前逻辑重写了一下。由于项目比较大，还要兼顾之前项目的迭代和其他项目，目前为止只写完第一阶段。</p>

<p>之前项目本地持久化方案主要用的是SQLite，这次重写项目打算换一种持久化方案，于是我们经过讨论选择了苹果的“亲儿子”CoreData。</p>

<p>在使用CoreData的过程中，我也是一边学习一边实践。在学习的过程中，一些写的质量比较高的博客对我的帮助也很大，例如objc.io等博客，在这里就不一一列举出来了，非常感谢这些作者。</p>

<!--more-->


<p>先不说项目中用不用得到，其实很多人都是不了解CoreData的，但是经过我的学习发现CoreData还是挺不错的。所以正如这系列文章的名字一样-认识CoreData，打算写这系列文章来认识一下CoreData。</p>

<p>这系列博客将从简单到复杂的来讲一下CoreData，其中除了基础使用还会包括多线程、批量数据处理等内容，这些很多都是我公司项目开发过程中接触到的，我们也设想了一些极端的情况，解决方案都会体现在这系列博客中。</p>

<p>本人接触CoreData时间并不长，只是专门花了一段时间学习CoreData。</p>

<p>本系列文章偏重于通过图形化界面使用CoreData，不会全部采取纯代码进行CoreData的所有操作，而且那样操作起来也确实比较麻烦，反而就失去了CoreData的优势和本质。</p>

<p>文章中如有疏漏或错误，还请各位及时提出，谢谢！</p>

<p>写在前面</p>

<p>在CoreData中有一些常用的类，称呼可能各不相同。所以这里先约定一些关键字，以便理解后面的一些内容，这些约定很多都是出现在苹果的官方文档中的。</p>

<pre><code>NSPersistentStoreCoordinator(Persistent Store Coordinator)，缩写为PSC。

NSManagedObjectContext(Managed Object Context)，缩写为MOC。

NSManagedObjectModel(Managed Object Model)，缩写为MOM。

NSManagedObject及其子类，根据英文翻译和其作用，称之为托管对象。

后缀名为.xcdatamodeld的文件，因为存储着所有实体的数据结构和表示，所以称之为模型文件。
</code></pre>

<p>什么是CoreData？</p>

<p>简单介绍一下</p>

<p>CoreData出现在iOS 3中，是苹果推出的一个数据存储框架。CoreData提供了一种对象关系映射(ORM)的存储关系，类似于Java的hibernate框架。CoreData可以将OC对象存储到数据库中，也可以将数据库中的数据转化为OC对象，在这个过程中不需要手动编写任何SQL语句，这是系统帮我们完成。</p>

<p>CoreData最大的优势就是使用过程中不需要编写任何SQL语句，CoreData封装了数据库的操作过程，以及数据库中数据和OC对象的转换过程。所以在使用CoreData的过程中，很多操作就像是对数据库进行操作一样，也有过滤条件、排序等操作。</p>

<p>这就相当于CoreData完成了Model层的大量工作，例如Model层的表示和持久化，有效的减少了开发的工作量，使Model层的设计更加面向对象。</p>

<p>CoreData好用吗？</p>

<p>之前听人说过，CoreData比较容易入手，但是很难学精。这也是很多人说CoreData不好用的原因之一，只是因为使用方式有问题，或者说并没有真正掌握CoreData。</p>

<p>如果从性能上来说，CoreData比SQLite确实略差一些。但是对于移动端来说，并不需要大型网站的高并发，所以这点性能差别几乎是没有影响的，所以这点可以忽略不计。在后面的文章中，将会给出CoreData的优点和缺点对比，以及详细的性能测评。</p>

<p>CoreData主要的几个类</p>

<pre><code>NSManagedObjectContext
</code></pre>

<p>托管对象上下文，进行数据操作时大多都是和这个类打交道。</p>

<pre><code>NSManagedObjectModel
</code></pre>

<p>托管对象模型，一个托管对象模型关联一个模型文件(.xcdatamodeld)，存储着数据库的数据结构。</p>

<pre><code>NSPersistentStoreCoordinator
</code></pre>

<p>持久化存储协调器，负责协调存储区和上下文之间的关系。</p>

<pre><code>NSManagedObject
</code></pre>

<p>托管对象类，所有CoreData中的托管对象都必须继承自当前类，根据实体创建托管对象类文件。</p>

<p>CoreData简单创建流程</p>

<p>模型文件操作</p>

<pre><code>1.1 创建模型文件，后缀名为.xcdatamodeld。创建模型文件之后，可以在其内部进行添加实体等操作(用于表示数据库文件的数据结构)

1.2 添加实体(表示数据库文件中的表结构)，添加实体后需要通过实体，来创建托管对象类文件。

1.3 添加属性并设置类型，可以在属性的右侧面板中设置默认值等选项。(每种数据类型设置选项是不同的)

1.4 创建获取请求模板、设置配置模板等。

1.5 根据指定实体，创建托管对象类文件(基于NSManagedObject的类文件)
</code></pre>

<p>实例化上下文对象</p>

<pre><code>2.1 创建托管对象上下文(NSManagedObjectContext)

2.2 创建托管对象模型(NSManagedObjectModel)

2.3 根据托管对象模型，创建持久化存储协调器(NSPersistentStoreCoordinator)

2.4 关联并创建本地数据库文件，并返回持久化存储对象(NSPersistentStore)

2.5 将持久化存储协调器赋值给托管对象上下文，完成基本创建。
</code></pre>

<p>CoreData结构</p>

<p>CoreData的结构构成</p>

<p>之前看到过几张介绍CoreData结构的图片，感觉其表示的结构比较清晰。可以通过这几张图片初步认识一下CoreData，在后面的文章中还会对这几个类进行详细解释。</p>

<p><img src="http://al1020119.github.io/images/1001.png" title="Caption" ></p>

<p>整体结构</p>

<p>上图中是初始化MOC所涉及到的一些类，由这些类实例化并最终构成可以使用的MOC。图中编号是实例化一个具备数据处理能力的MOC过程，这个过程和上面介绍过的实例化上下文对象相同。</p>

<p><img src="http://al1020119.github.io/images/1002.png" title="Caption" ></p>

<p>NSManagedObjectContext</p>

<p>在PSC创建并关联本地数据库，并设置为MOC的persistentStoreCoordinator属性后，MOC就具备对当前存储区所有托管对象操作的能力。但是需要注意的是，MOC对托管对象是懒加载的，在使用时才会被加载到MOC的缓存中。</p>

<p><img src="http://al1020119.github.io/images/1003.png" title="Caption" ></p>

<p>NSManagedObjectModel</p>

<p>MOM对象加载模型文件后，获取到模型文件中所有实体的构成结构。由于MOM中存储着模型文件的结构，PSC需要通过MOM对象实例化本地数据库。</p>

<p><img src="http://al1020119.github.io/images/1004.png" title="Caption" ></p>

<p>Entity</p>

<p>所有属性都存在Entity中，以及有关联关系的属性和请求模板，这都会在后面的章节中讲到。</p>

<p><img src="http://al1020119.github.io/images/1005.png" title="Caption" ></p>

<p>NSManagedObject</p>

<p>可以通过Entity创建继承自NSManagedObject类的文件，这个文件就是开发中使用的托管对象，具备模型对象的表示功能，CoreData的本地持久化都是通过这个类及其子类完成的。</p>

<p>持久化存储调度器</p>

<p>在CoreData的整体结构中，主要分为两部分。一个是NSManagedObjectContext管理的模型部分，管理着所有CoreData的托管对象。一个是SQLite实现的本地持久化部分，负责和SQL数据库进行数据交互，主要由NSPersistentStore类操作。这就构成了CoreData的大体结构。</p>

<p><img src="http://al1020119.github.io/images/1006.png" title="Caption" ></p>

<p>结构图</p>

<p>从图中可以看出，这两部分都是比较独立的，两部分的交互由一个持久化存储调度器(NSPersistentStoreCoordinator)来控制。上层NSManagedObjectContext存储的数据都是交给持久化调度器，由调度器调用具体的持久化存储对象(NSPersistentStore)来操作对应的数据库文件，NSPersistentStore负责存储的实现细节。这样就很好的将两部分实现了分离。</p>

<p>个人随想</p>

<p>对于CoreData的整体结构，因为CoreData底层存储本来就是用SQLite实现的，所以我用CoreData的结构和SQLite对比了一下，发现还是很多相似之处的。</p>

<p>.xcdatamodeld文件代表着数据库文件结构，通过.xcdatamodeld编译后的.momd文件生成数据库。每个实体代表一张数据表，实体之间的关联关系就是SQLite的外键。</p>

<p>下图就是CoreData底层存储的结构，用红圈圈住的部分指向关联表的主键下标。例如1就指向关联表的主键下标为1的行。</p>

<p><img src="http://al1020119.github.io/images/1007.png" title="Caption" ></p>

<p>外键</p>

<p>CoreData杂谈</p>

<p>CoreData数据存储安全</p>

<p>CoreData本质还是使用SQLite进行存储，并没有另外提供加密功能，具体的数据加解密还需要自己完成。</p>

<p>CoreData在硬盘上的数据存储结构：</p>

<p><img src="http://al1020119.github.io/images/1008.png" title="Caption" ></p>

<p>数据库存储结构</p>

<p>通过PSC指定创建SQLite目录后，会在指定的目录下生成一个数据库文件，同时还会生成两个同名但后缀不同的文件，其中只有后缀.sqlite的文件是存储数据的文件。</p>

<p>这个数据库文件中会默认生成三个表，Z_METADATA、Z_PRIMARYKEY、Z_MODELCACHE，其他我们自己的表也都是大写Z开头的。</p>

<p>在每个表中，系统还会默认生成三个字段，Z_PK、Z_ENT、Z_OPT三个字段，也都是大写Z开头并且带下划线的。其他字段就是我们自己的字段了，大写Z开头但不带下划线。</p>

<p>CoreData执行效率</p>

<p>现在市面上的大多数项目，都是使用SQLite作为持久化的方案，而CoreData的使用并不是很普遍。对于这个问题，我认为首先是很多项目开始的比较早，那时候好多iOS程序员都是从其他语言转过来的，更加熟悉SQLite，所以用SQLite比较多一些。后面如果不进行大的项目重构，就很难换其他的持久化方案了。</p>

<p>还有就是不熟悉CoreData，也不想去了解和深入学习CoreData，我认为这是很大的原因。所以项目中用CoreData的人并不多，而真正掌握CoreData技术的人更少。</p>

<p>之前听其他人说CoreData的执行效率不如SQLite高，这个如果深究的话，确实CoreData要比SQLite效率差一些，只不过并没有太大区别。CoreData本质也是在底层执行SQL语句，只是CoreData的SQL语句执行逻辑比较耗时，没有手动编写SQL语句更加直接。我们可以将CoreData的调试功能打开，具体看一下SQL语句的执行。</p>

<p>这里要说一点，客户端毕竟不是服务端，不需要像服务器那样大量的数据查询，所以CoreData是完全可以应对客户端的查询量的。如果从灵活性来说，CoreData确实没有SQLite的灵活性高，一些SQLite的复杂功能可能也不能实现，但是就目前大多数项目来说，CoreData已经能够满足项目持久化需求了。</p>

<p>导致执行效率差异的原因还体现在对象转换上，CoreData在执行SQL语句的基础上，还多了一层将数据映射给托管对象的操作，这样得到的就是OC的托管对象，而SQLite得到的则不是。如果给SQLite执行完成后，也加一层创建托管对象并赋值的操作，这时候对比性能两者的差距可能就会更小了。</p>

<p>性能评测</p>

<p>下面是一篇关于CoreData、FMDB、Realm性能测试结果的博客，最后的结果我也没有去验证，只是大致看了一下代码还是比价靠谱的。作者测试Demo和原文地址。</p>

<p>测试数据的数量是以K为单位，最少为1K的数据量。涉及到的操作主要是下面四种：</p>

<pre><code>新建数据库并插入1K条数据。

已有数据库，插入1K条数据。

查询总量为10K条数据，连续查询单次为1K数据。

10K条数据总量，更新其中1K条数据的部分字段性能。
</code></pre>

<p>性能评测结果：</p>

<p>根据测试结果可以发现，在前面两种插入操作，CoreData的性能比FMDB和Realm要快很多。</p>

<p>而对于查询操作，CoreData比其他两种操作耗时多很多，大概多出三四倍。这很可能和CoreData将查询结果的数据转为托管对象有关系，抛去CoreData这部分转换操作性能会比现在好很多。</p>

<p>而更新操作则直接基于SQLite封装的FMDB有绝对的优势，FMDB和其他两种操作差距大概是十倍左右，而其他两种操作性能差不多。当然CoreData也存在着上面提到的对象转换操作，CoreData抛去这步结果可能会比现在好很多。</p>

<p>测试图表</p>

<p>下面的测试数据中，取得是三次测试结果的平均值。</p>

<p><img src="http://al1020119.github.io/images/1009.png" title="Caption" ></p>

<p><img src="http://al1020119.github.io/images/1010.png" title="Caption" ></p>

<p>新建数据库并插入1K条数据</p>

<p><img src="http://al1020119.github.io/images/1011.png" title="Caption" ></p>

<p>已有数据库，插入1K条数据</p>

<p><img src="http://al1020119.github.io/images/1012.png" title="Caption" ></p>

<p>查询总量为10K条数据，连续查询单次为1K数据</p>

<p><img src="http://al1020119.github.io/images/1013.png" title="Caption" ></p>

<p>10K条数据总量，更新其中1K条数据的部分字段性能</p>

<p>CoreData调试</p>

<p>Xcode调试命令</p>

<p>CoreData本质上是对SQLite的一个封装，在内部将对象的持久化转化为SQL语句执行，可以在项目中将CoreData调试打开，从而可以看到CoreData的SQL语句执行和一些其他log信息。</p>

<p>打开Product，选择Edit Scheme.</p>

<p>选择Arguments，在下面的ArgumentsPassed On Launch中添加下面两个选项。</p>

<pre><code>(1)-com.apple.CoreData.SQLDebug

(2)1

    终端调试命令

    如果是在模拟器上调试程序，可以通过 sqlite3 /数据库路径/ 命令来查看和操作数据库。

    .tables 查看当前数据库文件中所有的表名

    select *from tableName 执行查询的SQL语句

    &lt;img src="http://al1020119.github.io/images/1014.png" title="Caption" &gt; 

    终端调试命令
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Realm精华篇]]></title>
    <link href="http://al1020119.github.io/blog/2016/07/03/realmjinghuapian/"/>
    <updated>2016-07-03T22:59:42+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/07/03/realmjinghuapian</id>
    <content type="html"><![CDATA[<p>Realm 是一个跨平台的移动数据库引擎，于 2014 年 7 月发布，准确来说，它是专门为移动应用所设计的数据持久化解决方案之一。</p>

<p>Realm 可以轻松地移植到您的项目当中，并且绝大部分常用的功能（比如说插入、查询等等）都可以用一行简单的代码轻松完成！</p>

<p>Realm 并不是对 Core Data 的简单封装，相反地， Realm 并不是基于 Core Data ，也不是基于 SQLite 所构建的。它拥有自己的数据库存储引擎，可以高效且快速地完成数据库的构建操作。</p>

<p>之前我们提到过，由于 Realm 使用的是自己的引擎，因此， Realm 就可以在 iOS 和 Android 平台上共同使用（完全无缝），并且支持 Swift 、 Objective-C 以及 Java 语言来编写（ Android 平台和 iOS 平台使用不同的 SDK ）。</p>

<!--more-->


<p>数以万计的使用 Realm 的开发者都会发现，使用 Realm 比使用 SQLite 以及 Core Data 要快很多。下面我们给出一个例子，分别展示 Core Data 和 Realm 在执行一个断言查询请求并且排序结果所使用的代码量：</p>

<pre><code>// Core Data
let fetchRequest = NSFetchRequest(entityName: "Specimen")
let predicate = NSPredicate(format: "name BEGINSWITH [c]%@", searchString)
fetchRequest.predicate = predicate
let sortDescriptor = NSSortDescriptor(key: "name", ascending: true)
fetchRequest.sortDescriptors = [sortDescriptor]
let error = NSError()
let results = managedObjectContext?.executeFetchRequest(fetchRequest, error:&amp;error)
</code></pre>

<p>而换成了 Realm 呢？您会惊叹于 Realm 的简单的：</p>

<pre><code>// Realm
let predicate = NSPredicate(format: "name BEGINSWITH [c]%@", searchString);
let specimens = Specimen.objectsWithPredicate(predicate).arraySortedByProperty("name", ascending: true)
</code></pre>

<p>使用 Realm 可以让代码变得十分简洁，从而让您的代码易读易写。</p>

<p>综上所述，我们之所以使用 Realm 的理由不外乎如下几点：</p>

<pre><code>跨平台 ：现在绝大多数的应用开发并不仅仅只在 iOS 平台上进行开发，还要兼顾到 Android 平台的开发。为两个平台设计不同的数据库是愚蠢的，而使用 Realm 数据库， iOS 和 Android 无需考虑内部数据的架构，调用 Realm 提供的 API 就可以完成数据的交换，实现 “ 一个数据库，两个平台无缝衔接 ” 。

简单易用 ： Core Data 和 SQLite 冗余、繁杂的知识和代码足以吓退绝大多数刚入门的开发者，而换用 Realm ，则可以极大地减少学习代价和学习时间，让应用及早用上数据存储功能。

可视化 ： Realm 还提供了一个轻量级的数据库查看工具，借助这个工具，开发者可以查看数据库当中的内容，执行简单的插入和删除数据的操作。毕竟，很多时候，开发者使用数据库的理由是因为要提供一些所谓的 “ 知识库 ” 。
</code></pre>

<p>本教程将会向您介绍 Realm 在 iOS 平台上的简单应用，即导入 Realm 框架、创建数据模型、执行查询以及插入、更新和删除记录，以及使用既有的数据库。</p>

<p>提示：原文教程写于 2014 年，而 Realm 的版本更新得十分快，因此，本教程并不会拘泥于原文教程所述内容，而是根据 Realm 的版本更新进行相关修改。
原文作者提到，要在 Realm 抵达 1.0 版本的时候再来更新这篇教程，大家尽请期待吧！</p>

<p>让我们开始吧</p>

<p>我们将会以一个实际的项目来进行教程：假设您在西双版纳自然保护区觅得了一份职位 “ 监测员 ” ，职责是记录这个 “ 动植物王国 ” 当中所发现物种的相关信息，包括种群数量、发现区域、年龄结构等等。因此，您需要一个助手来帮忙记录您的发现，但是很可惜的是，保护区并没有多余的人手来做您的助手（主要是没钱）。所以没有办法，我们必须为自己制作一个虚拟的 “ 助手 ” ，也就是一个以 “ 物种监测 ” 命名的 APP ，这样就可以随手记录我们的发现了！</p>

<p>点击此处下载本教程所使用的起始项目</p>

<p>在 Xcode 当中打开我们的起始项目。此时， MapKit 已经在项目当中建立好了，而且项目已经拥有了一些简单的创建、更新和删除物种信息的功能。</p>

<p>提示：如果您对 MapKit 的相关知识感兴趣，可以查看 Introduction to MapKit tutorial ，这篇教程将会深入阐述 MapKit 是如何工作的。</p>

<p>现在，让我们前往 Realm 的官网去下载 Realm 的框架吧： <a href="http://static.realm.io/downloads/cocoa/latest">http://static.realm.io/downloads/cocoa/latest</a></p>

<p>Realm 的使用需求如下：</p>

<pre><code>iOS ≥ 7 或者 Mac OS X ≥  10.9

Xcode ≥ 6

现在 Realm 的版本为： 0.91.5
</code></pre>

<p>解压下载下来的 Realm 压缩包。在压缩包中，我们可以看到一个名为 iOS 的文件夹。打开这个文件夹，然后将 Realm.framework 文件拖入到我们的起始项目中，最好拖放到 “Frameworks” 文件夹中以确保文件有序（强迫症患者 ~ ）。</p>

<p><img src="http://al1020119.github.io/images/realmjinghua0001.png" title="Caption" ></p>

<p>将框架文件拖入到项目当中</p>

<p>之后，一定要确保勾选了 Copy Items if needed 选项，然后单击 Finish 按钮就完成了往项目中添加框架的操作。</p>

<p>之后，定位到项目设置中 SISpeciesNotes 的 General 选项卡，然后在 Link Binary with Libraries 栏目中添加 libc++.dylib 动态库文件。</p>

<p>然后回到解压的 Realm 文件夹中，打开名为 Swift 的文件夹，然后将里面的 RLMSupport.swift 文件拖入到项目当中。这个文件包含了用于 Realm 相关类的 Swift 简便方法，比如说 RLMResults 中的 Generator 方法，这样就可以像使用原生数组一样使用 Realm 数组了。</p>

<p>好的，我们的准备工作就完成了！您可以尝试运行一下起始项目，以确保没有任何错误产生。如果出现错误的话，请仔细查看上面所述的一些步骤，确保没有任何疏漏发生。运行成功后的基本界面如下所示：</p>

<p><img src="http://al1020119.github.io/images/realmjinghua0002.png" title="Caption" ></p>

<p>应用界面</p>

<p>Realm Browser 介绍</p>

<p>Realm 资源包中包含了一个很有用的实用工具，可以帮助我们更好地管理 Realm 数据库，那就是 Realm Browser 。</p>

<p>Realm Browser 可以让您轻松地读写 Realm 数据库（以 .realm 结尾），因此我们无需头疼如何去查看 Realm 专有数据库的逻辑结构以及其中的数据，可视化的操作就如同 SQLite 的其他数据库查看工具一样，十分简单、易用（虽然 Realm Browser 的功能还十分简陋，真的只能读写而已）。</p>

<p><img src="http://al1020119.github.io/images/realmjinghua0003.png" title="Caption" ></p>

<p>Realm Browser</p>

<p>Realm Browser 可以在解压的 Realm 文件夹中的 browser 文件夹中找到。您也可以访问 Realm GitHub repository 然后在其中的 tools/RealmBrowser 目录中找到它。</p>

<p>您可以尝试在 Realm Browser 中选择 Tools -> Generate demo database 来试着探索一下 Realm Browser 的功能。</p>

<p>Realm 相关术语和主要类</p>

<p>为了帮助您更好地理解 Realm 的使用，下面我们将会对 Realm 的相关术语和主要类进行一个大致的介绍：</p>

<pre><code>RLMRealm ： RLMRealm 是框架的核心所在，是我们构建数据库的访问点，就如同 Core Data 的管理对象上下文（ managed  object context ）一样。出于简单起见， realm 提供了一个名为 defaultRealm 的单例，在本教程中我们就仅使用这个单例来完成我们所需的功能。当然，我们也可以导入外部已经编写好的 realm 数据库文件，也可以在我们不需要将数据保存在硬盘上时使用 “ 内存实例对象 ” （ in-memory realm instance ），此外，还可以同时使用多个数据库文件。

RLMObject ：这是我们自定义的 realm 数据模型。创建数据模型的行为将会影响到数据库的结构。要创建一个数据模型，我们只需要继承 RLMObject ，然后设计我们想要存储的属性即可。

关系 (Relationships) ：通过简单地在数据模型中声明一个 RLMObject 类型的属性，我们就可以创建一个 “ 一对多 ” 的对象关系。同样地，借助 RLMArray 我们还可以创建 “ 多对一 ” 和 “ 多对多 ” 的关系。

写操作事务 (Write Transactions) ：数据库中的所有操作，比如创建、编辑，或者删除对象，都必须在事务中完成。 “ 事务 ” 是指位于 beginWriteTransaction() 以及 commitWriteTransaction() 操作之间的代码段。

查询 (Queries) ：要在数据库中检索信息，我们需要用到 “ 检索 ” 操作。检索最简单的形式是对 RLMObject 对象发送 allObjects() 消息。如果需要检索更复杂的数据，那么还可以使用断言（ predicates ）、复合查询以及结果排序等等操作。

RLMResults ：这个类是执行任何查询请求后所返回的类，其中包含了一系列的 RLMObjects 对象。和 NSArray 类似，我们可以用下标语法来对其进行访问，并且还可以决定它们之间的关系。不仅如此，它还拥有许多更强大的功能，包括排序、查找等等操作。
</code></pre>

<p>现在您应该对 Realm 有了一个大概的了解了，现在是时候来试着使用 Realm 来完成起始项目的剩余工作了。</p>

<p>创建第一个数据模型</p>

<p>好了，前面我们废话了这么多，现在终于要开始使用数据库了。首先我们要创建一个数据模型，也相当于创建数据库的一个 “ 表 ” 。</p>

<p>右键选择 Xcode 项目导航器中的 Model 组，然后选择 New File -> iOS -> Source -> Swift File ，创建一个新的 swift 文件，将其命名为 SpeciesModel 并且确保选中了 SISpeciesNotes 对象。</p>

<p>提示：您也许查看过 Realm 的开发文档，它里面介绍说可以使用 “ 插件 ” 来完成数据模型的简单创建（也就是新建文件时，可以像新建 Core Data 数据模型文件一样创建一个既定的模板数据模型），但是很遗憾的是，现在这个功能还只支持创建 OC 版本的数据模型文件，我们为了代码的 “ 干净 ” ，就不采用这种方法。</p>

<p>打开 SpeciesModel.swift 文件，然后用以下代码替换文件中的内容：</p>

<pre><code>import UIKit
import Realm
class SpeciesModel: RLMObject {
dynamic var name = ""
dynamic var speciesDescription = ""
dynamic var latitude: Double = 0
dynamic var longitude: Double = 0
dynamic var created = NSDate()
}
</code></pre>

<p>上面的代码添加了一些属性来存储信息： name 属性存储物种名称， speciesDescription 存储物种的描述信息。对于 Realm 中的一些特定的数据类型，比如说字符串，必须要初始化。在本例中，我们使用空字符串来进行初始化。</p>

<p>latitude 以及 longitude 存储了物种的经纬度信息。在这里我们将其类型设置为 Double （ CLLocationDegrees 是 Double 的别名），并且使用 0 来进行初始化。</p>

<p>最后， created 存储了这个物种所创建的时间信息。 NSDate() 将会返回当前时间，因此我们就用这个值来初始化这个属性</p>

<p>好了，现在我们就成功创建了第一个 Realm 数据模型了，要不要动动脑来完成一个小小的挑战呢？</p>

<p>我们知道，这些物种将会被划分为不同的 “ 类别 ” ，您的任务就是自行创建一个 “ 类别 ” 数据模型，这个文件将被命名为 CategoryModel.swift ，然后这个新的数据模型只要一个字符串类型的属性 ——name 。</p>

<p>以下是解决方案的代码：</p>

<pre><code>import UIKit
import Realm
class CategoryModel: RLMObject {
dynamic var name = ""
}
</code></pre>

<p>我们现在拥有了 CategoryModel 数据模型了，下面我们将通过某种方式将其与 SpeciesModel 数据模型关联起来，搭建起 “ 关系 ” 。</p>

<p>重新回顾一下上一节的内容，我们可以通过简单地声明一个属性来创建数据模型之间的关系。</p>

<p>打开 SpeciesModel.swift 文件，然后在 created 属性下面添加如下语句：
1</p>

<pre><code>dynamic var category = CategoryModel()
</code></pre>

<p>这个语句设置了 “ 物种 ” 和 “ 类别 ” 之间的 “ 一对多 ” 关系，这就意味着每个物种都只能够拥有一个类别，但是一个类别可以从属于多个物种。</p>

<p>好的，我们创建完了一个基础数据模型了，现在是时候向数据库中添加数据了！</p>

<p>添加数据</p>

<p>每当用户添加了一个新的物种标记，用户就可以对这个标记进行修改，比如说设置物种名字，选择类别等等。打开 CategoriesTableViewController.swift 文件。这个视图控制器将要在这个表视图中显示类别清单，以便用户可以选择。</p>

<p>因此，我们需要在应用初始运行时，给用户提供几个默认的类别以供选择。</p>

<p>在类定义当中添加以下方法，别忘了在文件顶部导入 Realm 框架（ import Realm ）：</p>

<pre><code>private func populateDefaultCategories() {
self.results = CategoryModel.allObjects() // 1
if results.count == 0 { // 2
let realm = RLMRealm.defaultRealm() // 3
realm.beginWriteTransaction() // 4
let defaultCategories = Categories.allValues // 5
for category in defaultCategories {
// 6
let newCategory = CategoryModel()
newCategory.name = category
realm.addObject(newCategory)
}
realm.commitWriteTransaction() // 7
self.results = CategoryModel.allObjects()
}
}
</code></pre>

<p>对应的标号注释如下：</p>

<pre><code>allobjects() 方法将会返回指定对象的所有元素，在本例中，我们向数据库中的 CategoryModel 对象发送了一个查询请求，返回这个表当中的所有行信息。注意的是，这里我们得到的是一个 RLMResults 对象，这个对象用来存放我们的查询结果。

如果查询结果中的元素数量为 0 ，那么就说明数据库当中没有类别信息的相关记录，那么就意味着这是用户第一次启动应用。

我们访问默认的 realm 单例对象，然后将其用 realm 变量简单表示，以供访问

这一步将在默认 realm 数据库中启动一个事务 —— 现在，我们就可以向数据库当中添加记录了。

这里我们使用已经定义过的 Categories 枚举来创建一个含有全部默认类别的数组。

对于每个类别名称来说，我们创建了一个对应的 CategoryModel 实例对象，然后设置其 name 属性，最后将这个对象添加到 realm 当中。

当我们添加完所有的类别之后，调用 commitWriteTransaction() 方法来关闭事务，并且向数据库提交数据。
</code></pre>

<p>只有调用了 commitWriteTransaction() 方法，我们之前做的所有关于事务的操作才能够被成功运行，因为这涉及到 Realm 的内部处理的问题了。您可以像上面我们做的那样，执行一些简单的创建操作，或者您可以执行一些复杂的操作，比如说同时创建、更新、删除多个对象等等。</p>

<p>然后在 viewDidLoad() 方法的底部加入以下代码：
1</p>

<pre><code>populateDefaultCategories()
</code></pre>

<p>这个方法将会在视图加载的过程中，添加我们的测试用类别，并且执行向数据库写入数据的操作。</p>

<p>好了，现在我们的数据库当中已经有了一些数据了，我们需要更新一下表试图数据源相关方法，以显示这些类别。找到 tableView(_:cellForRowAtIndexPath:) 方法，然后用以下代码替换它：</p>

<pre><code>override func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell {
let cell = tableView.dequeueReusableCellWithIdentifier("CategoryCell", forIndexPath: indexPath) as! UITableViewCell
cell.textLabel?.text = (results[UInt(indexPath.row)] as! CategoryModel).name
return cell
}
</code></pre>

<p>这个声明语句从 results 对象当中读取对应行的名称，然后设置到单元格的文本标签上面显示。</p>

<p>接下来，添加一个新的属性：
1</p>

<pre><code>var selectedCategory: CategoryModel!
</code></pre>

<p>我们用这个属性来存储当前选中的类别。</p>

<p>找到 tableView(_: willSelectedRowAtIndexPath:) ，然后用以下代码替换它：
1
2
3
4</p>

<pre><code>override func tableView(tableView: UITableView, willSelectRowAtIndexPath indexPath: NSIndexPath) -&gt; NSIndexPath? {
selectedCategories = self.results[UInt(indexPath.row)] as! CategoryModel
return indexPath
}
</code></pre>

<p>上面声明的方法将会在用户点击某个单元格的时候，将用户点击的类别存储在 selectedCategory 属性当中。</p>

<p>编译并运行这个应用，然后尝试定位到某个您感兴趣的位置（使用模拟器的位置模拟），然后点击右上角的 “+” 按钮创建一个新的标记点。点选地图上的这个标记点，然后点击其弹出来的气泡，接下来会弹出这个标记点的详细信息。随后，点击类别文本框，就可以看到如下图所示的类别列表了：</p>

<p><img src="http://al1020119.github.io/images/realmjinghua0004.png" title="Caption" ></p>

<p>类别列表</p>

<p>您可以选择其中一个类别，不过这个操作仅仅只是将其保存到属性当中。如果您感兴趣，可以前往模拟器的 Documents 目录下面，使用 Realm Browser 查看我们生成的数据库，在里面就可以看到我们写入的数据了，这是不是很令人激动呢？</p>

<p>使用 Realm Browser</p>

<p>通常情况下，使用 defaultRealm() 方法生成的数据库文件将会存放在 /Users/(Your Account)/Library/Developer/CoreSimulator/Devices/(Simulator ID)/data/Containers/Data/Application/(Application ID)/Documents/ 路径下面，名为 default.realm 。 Simulator ID 指的是您运行的模拟器的 ID ， Application ID 指的是这个应用所分配到的 ID 。</p>

<p>如果您仍然不清楚这个 Realm 数据库在哪儿的话，那么使用如下语句，就可以打印处这个数据库所在的完整位置了：
1</p>

<pre><code>println(RLMRealm.defaultRealm().path)
</code></pre>

<p>在这个 Documents 目录下面，我们可能会看到两个文件。一个是 default.realm 文件，这个是数据库文件，里面就是数据的存放点了。而另一个则是 default.realm.lock 文件，这个文件也有可能不会存在，它是用来当数据库文件被使用时，防止其它应用对其进行修改的一个文件。</p>

<p>双击这个 default.realm 文件，就可以使用 Realm Browser 打开了：</p>

<p><img src="http://al1020119.github.io/images/realmjinghua0005.png" title="Caption" ></p>

<p>Realm Browser 打开的 default.realm 文件</p>

<p>注意：如果 default.realm 已经在其它应用中打开了，那么强行打开它就可能会出现异常。</p>

<p>.lock 文件就可以防止对 default.realm 文件的重复操作，在使用 Realm Browser 打开数据库文件前，请先确保应用没有在运行，然后删除 .lock 文件，才能打开。</p>

<p>一旦数据库在 Realm Browser 中被打开，您将会看到 CategoryModel 类中拥有 6 个对象，这就意味着这个 “ 表 ” 中已经存放了 6 个记录了。点击这个类就可以查看这个类当中拥有的具体对象信息。</p>

<p>增加类别</p>

<p>好了，现在我们就可以来实现 “ 为某个物种添加类别 ” 的功能了。</p>

<p>打开 AddNewEntryController.swift ，然后向类中添加以下属性：
1</p>

<pre><code>var selectedCategory: CategoryModel!
</code></pre>

<p>我们将会用这个属性来存储我们在 CategoriesTableViewController 选中的类别。</p>

<p>接下来，找到 unwindFromCategories(segue:) 方法，然后在方法底部添加以下代码：
1
2</p>

<pre><code>selectedCategory = categoriesController.selectedCategories
categoryTextField.text = selectedCategory.name
</code></pre>

<p>这个方法会在用户从 categoriesTableViewController 中选择了一个类别后被调用。在这里，我们获取到了这个选择的类别，然后将其存储在本地属性 selectedCategory 当中，接着，我们将它的值填充到文本框里面。</p>

<p>现在，我们已经完成了类别的获取，接下来就是要创建第一个物种了！</p>

<p>仍然还是在 AddNewEntryController.swift 当中，向类中再添加一个属性：
1</p>

<pre><code>var species: SpeciesModel!
</code></pre>

<p>这个属性将会存储一个新的物种数据模型对象。</p>

<p>接下来，导入 Realm 框架，然后向类中添加以下方法：</p>

<pre><code>func addNewSpecies() {
let realm = RLMRealm.defaultRealm() // 1
realm.beginWriteTransaction() // 2
let newSpecies = SpeciesModel() // 3
// 4
newSpecies.name = nameTextField.text
newSpecies.category = selectedCategory
newSpecies.speciesDescription = descriptionTextView.text
newSpecies.latitude = selectedAnnotation.coordinate.latitude
newSpecies.longitude = selectedAnnotation.coordinate.longitude
realm.addObject(newSpecies) // 5
realm.commitWriteTransaction() // 6
self.species = newSpecies
}
</code></pre>

<p>对应的标号注释如下：</p>

<pre><code>获取默认的 Realm 数据库

开启一个事务序列，准备写入数据

创建一个 Species 对象实例

接着，设置这个对象的相关值。这些值来自于用户界面的文本输入框。

向 realm 中写入新的 Species 对象

最后，使用 commitWriteTransaction() 提交写操作事务
</code></pre>

<p>在这里，我们需要使用 “ 输入验证 ” ，来确保用户的输入是正确的。在工程中已经有了一个存在的 validateFields() 方法来执行输入验证的工作，以确保物种名称和描述不能为空。我们刚刚增加了设置类别的功能，那么我们应该也要确保类别选择不能为空。</p>

<p>在 validateFields() 方法中找到以下代码：
1</p>

<pre><code>if nameTextField.text.isEmpty || descriptionTextView.text.isEmpty {
</code></pre>

<p>将其变更为：
1</p>

<pre><code>if nameTextField.text.isEmpty || descriptionTextView.text.isEmpty || selectedCategory == nil {
</code></pre>

<p>这个方法经能够确保所有的文本框都有值，并且用户也已经选择了一个类别。</p>

<p>接下来，向类中添加以下方法：</p>

<pre><code>override func shouldPerformSegueWithIdentifier(identifier: String?, sender: AnyObject?) -&gt; Bool {
if validateFields() {
if species == nil {
addNewSpecies()
}
return true
} else {
return false
}
}
</code></pre>

<p>在上面的代码中，我们调用了输入验证的方法，如果所有文本框都有值的话，那么就可以添加一个新的物种。</p>

<p>编译并运行您的应用，单击 “+” 按钮来创建一个新的物种。然后输入其名称和描述，选择一个类别，接着单击 “ 保存 ” 按钮来将这个物种添加到数据库中。</p>

<p><img src="http://al1020119.github.io/images/realmjinghua0006.png" title="Caption" ></p>

<p>添加新的数据</p>

<p>视图消失了 —— 等等，怎么什么都没有发生呢？什么情况？</p>

<p>哦对了，我们已经向 Realm 数据库提交了一个数据，但是我们还没有在地图上做出相应的设置和改变。</p>

<p>检索数据</p>

<p>既然我们已经向数据库中添加了一个物种了，那么现在我们希望它能够在地图上显示出来。</p>

<p>如果您想要检视这个心数据，那么打开 Realm Browser 就可以查看数据了。记住要先退出模拟器。</p>

<p>添加的物种信息</p>

<p><img src="http://al1020119.github.io/images/realmjinghua0007.png" title="Caption" ></p>

<p>添加的物种信息</p>

<p>我们仅仅只能够看见孤零零的一条记录，里面存储了记录的名称、描述信息、经纬度信息、添加的时间。还有最重要的，就是我们看到了连接到 CategoryModel 的 category 记录，这就意味着我们已经创建好了物种和类别的 “ 一对多 ” 关系。点击这个蓝色的超链接，我们就可以查看 CategoryModel 的相关数据了。</p>

<p>好的，回到正题，我们现在需要在地图上显示新添加的数据。</p>

<p>打开 SpeciesAnnotation.swift ，然后向类中添加一个新的属性：
1</p>

<pre><code>var species: SpeciesModel?
</code></pre>

<p>这个属性将会为这个标记点保存它所拥有的物种信息。</p>

<p>接下来，用以下代码替换构造器：</p>

<pre><code>init(coordinate: CLLocationCoordinate2D, title: String, sub: Categories, species: SpeciesModel? = nil) {
self.coordinate = coordinate
self.title = title
self.subtitle = sub.rawValue
self.species = species
}
</code></pre>

<p>我们所做的改变，就是给这个构造器方法添加了一个带默认值的构造器参数，以便可以对 species 属性进行赋值。默认值为 nil ，这意味着我们可以忽略这个参数，使用前面三个参数进行初始化也是没有任何问题的。</p>

<p>打开 MapViewController.swift ，然后向类中添加一个新属性（同样地，别忘了导入 Realm ）：
1</p>

<p>var results: RLMResults?</p>

<p>如果我们想要在用属性来存储一系列物种，那么我们需要将这个属性声明为 RLMResults 类型。要记住，我们是不能够初始化 RLMResults 对象的，我们必须要通过查询操作来获取它的值。</p>

<p>现在我们需要一些方法来获取所有的物种数据。仍然还是在 MapViewController.swift 当中，向类中添加如下方法：</p>

<pre><code>func populateMap() {
mapView.removeAnnotations(mapView.annotations) // 1
if let results = SpeciesModel.allObjects() { // 2
self.results = results
for result in results {
let species = result as! SpeciesModel
let coordinate = CLLocationCoordinate2DMake(species.latitude, species.longitude)
let speciesAnnotation = SpeciesAnnotation(coordinate: coordinate, title: species.name, sub: Categories(rawValue: species.category.name)!, species: species) // 3
mapView.addAnnotation(speciesAnnotation) // 4
}
}
}
</code></pre>

<p>对应的标号注释如下：</p>

<pre><code>首先，我们先清除了地图上所有存在的标记点，这样我们就不用考虑其他的要素

然后，我们从 Realm 数据库中获取 Species 的全部数据

我们在此创建了一个自定义的 SpeciesAnnotation

最后，我们往 MKMapView 上添加这个标记点
</code></pre>

<p>好的，现在我们可以在某处地方吊用这个方法了。找到 viewDidLoad() 然后将这个方法加入到这个方法底部：
1</p>

<p>populateMap()</p>

<p>这样就确保了每当地图视图控制器加载的时候，地图就能够显示 Species 标记点。</p>

<p>接着，我们仅需要修改标记点的名称和类别即可。找到 unwindFromAddNewEntry() ，然后使用下列代码替换掉该方法：</p>

<pre><code>@IBAction func unwindFromAddNewEntry(segue: UIStoryboardSegue) {
let addNewEntryController = segue.sourceViewController as! AddNewEntryController
let addedSpecies = addNewEntryController.species
let addedSpeciesCoordinate = CLLocationCoordinate2DMake(addedSpecies.latitude, addedSpecies.longitude)
if lastAnnotation != nil {
mapView.removeAnnotation(lastAnnotation)
} else {
for annotation in mapView.annotations {
let currentAnnotation = annotation as! SpeciesAnnotation
if currentAnnotation.coordinate.latitude == addedSpeciesCoordinate.latitude &amp;&amp; currentAnnotation.coordinate.longitude == addedSpeciesCoordinate.longitude {
mapView.removeAnnotation(currentAnnotation)
break
}
}
}
let annotation = SpeciesAnnotation(coordinate: addedSpeciesCoordinate, title: addedSpecies.name, sub: Categories(rawValue: addedSpecies.category.name)!, species: addedSpecies)
mapView.addAnnotation(annotation)
lastAnnotation = nil
}
</code></pre>

<p>这个方法将会在我们从 AddNewEntryController 返回的时候被调用，然后这时候就会有一个新的物种被添加到地图上方。当我们添加了一个新的物种到地图上，那么就会产生一个标记图标。然后我们想要根据物种的类别来改变其图标的样式，在这个代码里面，我们就是简单的移除了最后添加的这个标记点，然后将其替换为有名称和类别的标记点。</p>

<p>编译并运行您的应用，创建一些不同的物种种类来查看现在地图是什么样式的吧！</p>

<p><img src="http://al1020119.github.io/images/realmjinghua0008.png" title="Caption" ></p>

<p>添加的标记点效果</p>

<p>另外一个视图</p>

<p>您或许已经注意到在地图视图的左上角有一个 “ 编辑 ” 的按钮。为了更好地管理地图上的记录点，我们这个应用设置了一个基于文本的表视图，用来列出地图上所有的记录点，这个视图我们现在命名为 “ 记录 ” 视图。现在，这个表视图仍然还是空的，现在我们就来向里面填充数据吧！</p>

<p>打开 LogViewController.swift ，然后将 species 属性替换成以下形式（同样地，要导入 Realm ）：
1</p>

<pre><code>var species: RLMResults!
</code></pre>

<p>在上面的代码中，我们用 RLMResults 替换掉了之前的一个空数组占位符，这个操作和我们在 MapViewController 所做的一样。</p>

<p>接下来，找到 viewDidLoad() 方法，然后在 super.viewDidLoad() 语句下添加以下代码：
1</p>

<pre><code>species = SpeciesModel.allObjects().sortedResultsUsingProperty("name", ascending: true)
</code></pre>

<p>这行代码会将数据库中的所有物种全部输出到 species 当中，并且按照名字进行排列。</p>

<p>接下来，用以下代码替换 tableView(_:cellForRowAtIndexPath:) ：</p>

<pre><code>override func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell {
var cell = tableView.dequeueReusableCellWithIdentifier("LogCell") as! LogCell
var speciesModel: SpeciesModel!
speciesModel = species[UInt(indexPath.row)] as! SpeciesModel
cell.titleLabel.text = speciesModel.name
cell.subtitleLabel.text = speciesModel.category.name
cell.iconImageView.image = getImageOfSpecies(speciesModel.category.name)
return cell
}
</code></pre>

<p>这个方法将会展示物种的名字和物种的类别，以及其图标。</p>

<p>编译并运行应用，单击左上角的 “ 编辑 ” 按钮，然后您就会在表视图中看到我们之前录入的物种信息，如图所示：</p>

<p><img src="http://al1020119.github.io/images/realmjinghua0009.png" title="Caption" ></p>

<p>记录界面</p>

<p>删除记录</p>

<p>现在我们已经学习了如何在 Realm 中创建记录数据，但是如果我们不小心添加了错误的标记点，或者想要移除之前添加过的物种数据，那么我们应该要怎么做呢？因此，我们就需要添加从 Realm 中删除数据的功能。您会发现这是一个非常简单的操作。</p>

<p>打开 LogViewController.swift 文件，然后添加以下方法：</p>

<pre><code>func deleteRowAtIndexPath(indexPath: NSIndexPath) {
let realm = RLMRealm.defaultRealm() // 1
let objectToDelete = species[UInt(indexPath.row)] as! SpeciesModel // 2
realm.beginWriteTransaction() // 3
realm.deleteObject(objectToDelete) // 4
realm.commitWriteTransaction() // 5
species = SpeciesModel.allObjects().sortedResultsUsingProperty("name", ascending: true) // 6
tableView.deleteRowsAtIndexPaths([indexPath], withRowAnimation: .Fade) // 7
}
</code></pre>

<p>对应的标号注释如下：</p>

<pre><code>首先，我们获取到默认的 Realm 数据库

然后，我们从数据中找到我们想要删除的对象

启动写操作事务

调用 deleteObject() 方法，将要删除的对象传递进去， realm 会自动帮我们执行删除操作

接着提交写操作事务，将删除操作提交到数据库当中

一旦我们移除了一个物种，我们需要重新读取数据

最后，我们更新 UITableViewCell ，将单元格移除
</code></pre>

<p>接着，找到 tableView(_:commitEditingStyle: forRowAtIndexPath:) 方法，然后将以下代码加入到 if 语句块当中：
1</p>

<pre><code>deleteRowAtIndexPath(indexPath)
</code></pre>

<p>当表视图执行一个单例删除操作时，会调用这个协议代理，我们所需要做的就是调用我们刚刚创建的那个方法。</p>

<p>编译并运行您的应用，查看 “ 记录 ” 界面，然后在某个记录上面左滑删除。随后关闭模拟器，用 Realm Browser 打开数据库，我们就可以看到我们成功执行了更改：</p>

<p><img src="http://al1020119.github.io/images/realmjinghua0010.png" title="Caption" ></p>

<p>执行删除操作</p>

<p>断言匹配</p>

<p>我们仍然还想要给这个应用提供一些碉堡的功能，那么快速查找怎么样？在海量的数据中进行查找还是很麻烦的一件事情，但是有了快速查找，一切就都简单了。我们现在所拥有的这个项目已经包含了一个 UISearchController 控件，您所需要做的就是添加一点小小的修改，让这个功能能够在 Realm 中正常工作。</p>

<p>打开 LogViewController.swift ，然后将 searchResults 属性替换为以下代码：
1</p>

<pre><code>var searchResults: RLMResults!
</code></pre>

<p>因为我们仍然是执行 “ 检索 ” 操作，因此我们的数据是存放在 RLMResults 当中的。</p>

<p>向类中添加以下方法：</p>

<pre><code>func filterResultsWithSearchString(searchString: String) {
let predicate = "name BEGINSWITH [c]'\(searchString)'" // 1
let scopeIndex = searchController.searchBar.selectedScopeButtonIndex
searchResults = SpeciesModel.objectsWhere(predicate) // 2
switch scopeIndex {
case 0:
searchResults = searchResults.sortedResultsUsingProperty("name", ascending: true) // 3
case 1:
searchResults = searchResults.sortedResultsUsingProperty("distance", ascending: true) // 4
case 2:
searchResults = searchResults.sortedResultsUsingProperty("created", ascending: true) 5
default:
return
}
}
</code></pre>

<p>对应的标号注释如下：</p>

<pre><code>首先我们创建了一个字符串版本的 “ 断言 (predicate)” ，在这里，我们搜索以 searchString 开头的 name 属性。 [c] 可以让 BEGINSWITH 以不区分大小写的灵敏度来进行查找，要注意， searchString 是被单引号括起来的。

我们根据这个断言，使用 objectsWhere 这个方法来执行断言检索操作。

如果选中的标签是 “ 名字 ” ，那么结果就按照 “ 名字 A-Z” 排列

如果选中的标签是 “ 距离 ” ，那么就按照距离排列结果

如果选中的标签是 “ 创建时间 ” ，那么就按照时间来进行排列。
</code></pre>

<p>因为搜索会导致表视图调用同样的数据源方法，因此我们需要对 tableView(_:cellForRowAtIndexPath:) 进行小小的修改，以便让其能够处理主要的表视图记录以及查询结果。在这个方法里面，找到以下代码：
1</p>

<pre><code>speciesModel = species[UInt(indexPath.row)] as! SpeciesModel
</code></pre>

<p>将其替换为以下代码：</p>

<pre><code>if searchController.active {
speciesModel = searchResults[UInt(indexPath.row)] as! SpeciesModel
}else {
speciesModel = species[UInt(indexPath.row)] as! SpeciesModel
}
</code></pre>

<p>上面这行代码将会检查 searchController 是否激活。如果激活的话，那么就接收并显示搜索结果的数据；如果不是的话，那么就接收并显示 species 全部数据。</p>

<p>最后，我们需要一个功能，那就是单击范围栏上的按钮时，更变返回结果的排列顺序。</p>

<p>将空 scopeChanged 方法用以下代码来替换：</p>

<pre><code>@IBAction func scopeChanged(sender: UISegmentedControl) {
switch sender.selectedSegmentIndex {
case 0:
species = SpeciesModel.allObjects().sortedResultsUsingProperty("name", ascending: true)
case 1:
break
case 2:
species = SpeciesModel.allObjects().sortedResultsUsingProperty("created", ascending: true)
default:
species = SpeciesModel.allObjects().sortedResultsUsingProperty("name", ascending: true)
}
tableView.reloadData()
}
</code></pre>

<p>在上面的代码中，我们将会检查范围栏上的按钮是哪一个被按下（ A-Z ，距离，以及添加日期），然后调用 sortedResultsUsingProperty 来进行排序。通常情况下，这个列表将按照名字来排序。</p>

<p>您可能会注意到，现在按照距离排序这一块中目前还是空的（ case 1 ），那是因为目前数据模型中还不存在 “ 距离 ” 这么一个玩意儿，因此我们暂时还不需要做这个工作，等到以后添加了再来完善。不过现在，我们已经可以看到它的大致功能了！</p>

<p>编译并运行您的应用，尝试一些搜索操作，然后查看结果！</p>

<p><img src="http://al1020119.github.io/images/realmjinghua0011.png" title="Caption" ></p>

<p>查看不同的结果</p>

<p>提示：在作者的原教程中，搜索功能实际上是无法实现的。如果您在 “ 合适 ” 的地方添加了相关方法，那么实际上程序仍然还是无法执行搜索功能的。它会提示 cell 的 titleLabel 的值为 nil 。因为在原教程中， Cell 是在 Storyboard 里面自定义的，而搜索栏则是要显示一个新的表视图。如果需要重用自定义的 Cell ，那么最好需要在 Xib 文件中进行制作。因为如果没有 init(style:reuseIdentifier:) 方法的 Cell 自定义类，是无法进行重用的。</p>

<p>更新记录</p>

<p>我们现在已经实现了添加和删除记录的功能了，剩下就是更新数据功能了。</p>

<p>如果您试着单击 LogViewController 中的一个单元格，那么就会跳转到 AddNewEntryViewController 页面，但是这些区域都是空白的。当然，我们首先要做的就是让这个页面显示数据库中存放的数据，以便让用户编辑。</p>

<p>打开 AddNewEntryViewController.swift 文件，然后向类中添加以下方法：</p>

<pre><code>func fillTextFields() {
nameTextField.text = species.name
categoryTextField.text = species.category.name
descriptionTextView.text = species.speciesDescription
selectedCategory = species.category
}
</code></pre>

<p>这个方法将会使用 species 中的数据来填充用户界面的文本框。记住， AddNewEntryViewController 只有在添加新物种时才会保持文本框为空的状态。</p>

<p>接下来，向 viewDidLoad() 方法的末尾添加以下语句：</p>

<pre><code>if species == nil {
title = " 添加新的物种 "
}else {
title = " 编辑 \(species.name)"
fillTextFields()
}
</code></pre>

<p>上面这些代码段设置了导航栏的标题，以通知用户当前其是在添加新的物种还是在更新一个已存在的物种信息。如果 species 不为空，那么就调用 fillTextFields 方法来填充文本框。</p>

<p>现在我们需要一个更新功能，以便响应用户的更改操作。向类中添加以下方法：</p>

<pre><code>func updateSpecies() {
let realm = RLMRealm.defaultRealm()
realm.beginWriteTransaction()
species.name = nameTextField.text
species.category = selectedCategory
species.speciesDescription = descriptionTextView.text
realm.commitWriteTransaction()
}
</code></pre>

<p>通常情况下，这种方法一般都先获得默认的 Realm 数据库，然后将数据写入的操作放在 beginWriteTransaction() 和 commitWriteTransaction() 方法之间。在这个事务中，我们只是简单的更新了这三个数据域的值。</p>

<p>这六行短短的代码就足以完成 Species 记录的更新操作了哦 ~O(∩_∩)O~</p>

<p>现在我们只需要在用户单击保存按钮的时候调用上述代码即可。找到 shouldPerformSegueWithIdentifier(_:sender:) ，然后在 return true 语句之前，第一个 if 代码块之内添加以下代码：</p>

<pre><code>else {
updateSpecies()
}
</code></pre>

<p>当恰当的时候，就会调用这个方法来对数据进行更新。</p>

<p>现在打开 LogViewController.swift ，然后将 prepareForSegue(_:sender:) 用以下代码替换：</p>

<pre><code>override func prepareForSegue(segue: UIStoryboardSegue, sender: AnyObject?) {
if segue.identifier == "Edit" {
let controller = segue.destinationViewController as! AddNewEntryController
var selectedSpecies: SpeciesModel!
let indexPath = tableView.indexPathForSelectedRow()
if searchController.active {
let searchResultsController = searchController.searchResultsController as! UITableViewController
let indexPathSearch = searchResultsController.tableView.indexPathForSelectedRow()
selectedSpecies = searchResults[UInt(indexPathSearch!.row)] as! SpeciesModel
}else{
selectedSpecies = species[UInt(indexPath!.row)] as! SpeciesModel
}
controller.species = selectedSpecies
}
}
</code></pre>

<p>我们在这里将选中的物种信息传递给了 AddNewEntryController 。上面的 if/else 代码是因为要根据用户是否是在查看搜索结果来决定的。</p>

<p>编译并运行您的应用，打开记录视图，并且选中一个存在的物种。您应该可以看到文本框中已经填充了数据。</p>

<p><img src="http://al1020119.github.io/images/realmjinghua0012.png" title="Caption" ></p>

<p>更新数据</p>

<p>把剩下的东西结束掉</p>

<p>要让我们的应用变得更加完美，我们就需要实现剩下 的功能。</p>

<p>还记不记得我们没有变法根据距离来排序记录？我们需要在里面添加不少的代码，才能够正常的运行这个功能，但是这个结果是非常值得的。</p>

<p>打开 Species.swift 文件，然后向类中添加一个新的属性。
1</p>

<pre><code>dynamic var distance: Double = 0
</code></pre>

<p>这个属性为保存用户位置和该记录点的距离信息。然而，没有必要去存储 distance 信息，因为用户位置会随时发生改变。我们想让距离成为这个模型的一部分，但是我们并不想 Realm 来存储这个数据。</p>

<p>Realm 支持一种被称为忽视属性 (ignored properties) 的东西，然后向类中添加以下代码：</p>

<pre><code>func ignoredProperties() -&gt; NSArray {
let propertiesToIgnore = [distance]
return propertiesToIgnore
}
</code></pre>

<p>要实现忽视属性，只需要声明一个命名为 ignoredProperties() 的方法，然后返回一个属性数组，里面保存有您不想进行存储的属性。</p>

<p>由于我们并不会存储距离这个属性，很明显地我们需要自己计算距离。</p>

<p>打开 MapViewController.swift ，添加以下方法：</p>

<pre><code>func updateLocationDistance() {
let realm = RLMRealm.defaultRealm()
if results != nil {
for result in results! {
let currentSpecies = result as! SpeciesModel
let currentLocation = CLLocation(latitude: currentSpecies.latitude, longitude: currentSpecies.longitude)
let distance = currentLocation.distanceFromLocation(mapView.userLocation.location)
realm.beginWriteTransaction()
currentSpecies.distance = Double(distance)
realm.commitWriteTransaction()
}
}
}
</code></pre>

<p>对于每个物种，我们计算了这个标记点与用户当前位置之间的距离。即时我们没有存储这个距离信息，我们仍然需要将其存储在记录当中，然后将其在写操作事务中保存这个变化消息。</p>

<p>接下来，在 prepareForSegue(_:sender:) 方法底部添加以下代码：</p>

<pre><code>else if segue.identifier == "Log" {
updateLocationDistance()
}
</code></pre>

<p>现在，在用户打开 “ 记录界面 ” 之前，我们需要调用这个方法来计算距离。</p>

<p>接下来，打开 LogViewController.swift ，然后找到 tableView(_:cellForRowAtIndexPath:) 方法。然后在这个方法底部附近， return 语句之前添加以下代码：</p>

<pre><code>if speciesModel.distance &lt; 0 {
cell.distanceLabel.text = "N/A"
}else {
cell.distanceLabel.text = String(format: "%.2fkm", speciesModel.distance / 1000)
}
</code></pre>

<p>最后，找到 scopeChanged() 然后将 case 1 中的 break 替换成以下代码：</p>

<pre><code>species = SpeciesModel.allObjects().sortedResultsUsingProperty("distance", ascending: true)
</code></pre>

<p>编译并运行应用，然后 …… 呃？怎么崩溃掉了？</p>

<pre><code>'RLMException`, reason: 'Column count does not match interface - migration required'
</code></pre>

<h5>什么鬼？</h5>

<p>当我们向 Species 模型中添加了一个新的 distance 属性的时候，我们就对架构（ schema ） 进行了变更，但是我们并没有告诉 Realm 如何处理这个新增的数据段。从旧版本的数据库迁移（ migrate ） 到新版本的数据库的操作超出了本教程的范围。这并不是 Realm 独有的问题， Core Data 同样也需要在添加、变更或者删除新的数据段的时候进行迁移操作。</p>

<p>本教程的简单解决方案就是将模拟器的应用移除掉即可，然后重新编译并运行应用程序。这将会让应用创建一个全新的数据库，使用新的架构。</p>

<p>从模拟器删除这个应用，接下来编译和运行这个应用。然后添加新的物种，接着打开这个记录视图，这时候我们就可以看到如下所示的距离信息：</p>

<p><img src="http://al1020119.github.io/images/realmjinghua0013.png" title="Caption" ></p>

<p>距离信息</p>

<p>您或许需要模拟一个位置以便能够计算当前距离，在模拟器菜单栏上，选择 Debug\Location ，然后选择列表中的一个位置模拟。</p>

<h5>接下来该何去何从？</h5>

<p>您可以点击此处下载完整的项目</p>

<p>在本教程中，我们学习了如何创建、更新、删除以及查找 Realm 数据库中的数据记录，以及如何使用断言来进行查找，还有按属性名对结果进行排序的方法。</p>

<p>您可能要问了： “ 看起来 Realm 似乎是一个新项目，我感觉在一个完备的应用中使用它可能并不稳定 ” 。</p>

<p>Realm 最近才想公众开放，但是早在 2012 年它就已经在公司级别的产品中使用了。我个人已经在我的既有项目中使用 Realm 了，而且似乎运转起来相当不错。</p>

<p>如果您使用 Objective-C ，那么 Realm 是十分稳定的。对于 Swift 来说，由于 Swift 版本并不稳定，因此在使用 Realm 可能会遭遇到版本更迭所引发的一系列语法问题。不过随着 Swift 的更新，相信 Swift 的版本改动会越来越少， Realm 在 Swift 上也会越来越稳定。</p>

<p>对于 Realm 来说，它还有许多在本教程没有介绍到的特点：</p>

<pre><code>迁移（ Migrations ） ：在本教程中，我们看到了对 Realm 架构的修改导致了错误的产生。要学习关于如何在多版本之间迁移数据库的只是，请查看 Realm 说明文档的 “ 迁移（ migrations） ” 部分。

其他类型的 Realm 数据库 ：在本教程中，我们一直都是使用着 “ 默认 ”Realm 数据库，但是我们仍然还可以使用其他类型的 Realm 数据库，比如说不存储数据的 “ 内存数据库（ in-memory realm ） ” 。我们也可以使用多个 Realm 数据库，如果我们享用多个数据库来保存多种类型的数据的话。
</code></pre>

<p>关于 Realm 的更多信息，您可以查看 官方文档 ，我发现这个文档真的写得十分详尽。</p>

<p>如果您对本教程有什么建议和意见，请到评论区进行讨论，我会尽快处理这些建议和意见的 ~</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Realm基础篇]]></title>
    <link href="http://al1020119.github.io/blog/2016/07/03/realmjichupian/"/>
    <updated>2016-07-03T02:59:42+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/07/03/realmjichupian</id>
    <content type="html"><![CDATA[<p>介绍</p>

<p>realm是一个跨平台移动数据库引擎，支持iOS、OS X（Objective-C和Swift）以及Android。</p>

<p>2014年7月发布。由YCombinator孵化的创业团队历时几年打造，是第一个专门针对移动平台设计的数据库。目标是取代SQLite。</p>

<p>为了彻底解决性能问题，核心数据引擎C++打造，并不是建立在SQLite之上的ORM。如果对数据引擎实现想深入了解可以查看：Realm 核心数据库引擎探秘。因此得到的收益就是比普通的ORM要快很多，甚至比单独无封装的SQLite还要快。</p>

<p>因为是ORM，本身在设计时也针对移动设备（iOS、Android），所以非常简单易用，学习成本很低。</p>

<!--more-->


<p>碾压级性能</p>

<p>数据引自：introducing-realm</p>

<p>每秒能在20万条数据中进行查询后count的次数。realm每秒可以进行30.9次查询后count。</p>

<p><img src="http://al1020119.github.io/images/benchmarks.001b.png" title="Caption" ></p>

<p>在20万条中进行一次遍历查询，数据和前面的count相似：realm一秒可以遍历20万条数据31次，而coredata只能进行两次查询。</p>

<p><img src="http://al1020119.github.io/images/benchmarks.002b.png" title="Caption" ></p>

<p>这是在一次事务每秒插入数据的对比，realm每秒可以插入9.4万条记录，在这个比较里纯SQLite的性能最好，每秒可以插入17.8万条记录。然而封装了SQLite的FMDB的成绩大概是realm的一半。</p>

<p><img src="http://al1020119.github.io/images/benchmarks.003b.png" title="Caption" ></p>

<p>简单易用</p>

<p>实例代码语言是Objective?C。</p>

<p>Realm对象和其他对象没有太大区别，只是需要继承RLMObject</p>

<pre><code>@interface Dog : RLMObject
@property NSString *name;
@property NSInteger age;
@end
Dog *mydog = [[Dog alloc] init];
</code></pre>

<p>存储起来也非常简单，获取数据库实例，在一个事务中进行写入。</p>

<pre><code>RLMRealm *realm = [RLMRealm defaultRealm];
[realm transactionWithBlock:^{
    [realm addObject:mydog];
}];
</code></pre>

<p>方便的查询，可以在一个查询结果中再进行查询。查询的条件有着丰富的支持。</p>

<pre><code>RLMResults *r = [Dog objectsWhere:@"age &gt; 8"];
// Queries are chainable
r = [r objectsWhere:@"name contains 'Rex' AND  name BEGINSWITH '大'"];
</code></pre>

<p>zero-copy和懒加载</p>

<p>在通常的数据库中，数据大多数时间都静静地呆在硬盘当中。当你访问 NSManagedObject 对象中的某个属性的时候，Core Data 会将这个请求转换为一组 SQL 语句，如果还未连接数据库的话则创建一个数据库连接，然后将这个 SQL 语句发送给硬盘，执行检索，从匹配检索的结果中读取所有的数据，然后将它们放到内存当中（也就是内存分配）。然而，这时候你需要对其格式进行反序列化(deserialize)，因为硬盘上存储的格式不能直接在内存中使用，这意味着你需要调整位，以便 CPU 能够对其进行处理。</p>

<p>然而Realm跳过了整个拷贝数据到内存的过程，称之为zero-copy。做到这点是因为文件始终是内存映射的，无论文件是或否在内存当中，你都能够访问文件的任何内容。关于核心文件格式的重要一点就是，确保硬盘上的文件格式都是内存可读的，这样就无需执行任何反序列化操作了。</p>

<p>这样就带来了一个问题，难道数据全加载到内存里了？所以这里懒加载应运而生，比如在查询到一组数据后，只有当你真正访问对象的时候才真正加载进来。</p>

<p>VS SQLite</p>

<p>SQLite第一个版本发布于2000年，至今已16年。以当今的角度来看，它的编程抽象程度非常低。业务上我们其实只想把这些对象存进去，可以查询出来。</p>

<p>即便已经是封装过的FMDB，要写这样的代码心里也依旧难受:</p>

<pre><code>FMDatabase *db = [FMDatabase databaseWithPath:@"/tmp/tmp.db"];
if (![db open]) {
[db release];
return;
}
NSString *sql = @"create table bulktest1 (id integer primary key autoincrement, x text);"
"create table bulktest2 (id integer primary key autoincrement, y text);"
"create table bulktest3 (id integer primary key autoincrement, z text);"
"insert into bulktest1 (x) values ('XXX');"
"insert into bulktest2 (y) values ('YYY');"
"insert into bulktest3 (z) values ('ZZZ');";
success = [db executeStatements:sql];
sql = @"select count(*) as count from bulktest1;"
"select count(*) as count from bulktest2;"
"select count(*) as count from bulktest3;";
success = [self.db executeStatements:sql withResultBlock:^int(NSDictionary *dictionary) {
NSInteger count = [dictionary[@"count"] integerValue];
XCTAssertEqual(count, 1, @"expected one record for dictionary %@", dictionary);
return 0;
}];
[db close];
</code></pre>

<p>VS CoreData</p>

<p>详细的比较推荐看这篇：CoreData VS Realm。</p>

<p>下面给出一个查询的比较：</p>

<pre><code>// Core Data
let fetchRequest = NSFetchRequest(entityName: "Specimen")
let predicate = NSPredicate(format: "name BEGINSWITH [c]%@", searchString)
fetchRequest.predicate = predicate
let sortDescriptor = NSSortDescriptor(key: "name", ascending: true)
fetchRequest.sortDescriptors = [sortDescriptor]
let error = NSError()
let results = managedObjectContext?.executeFetchRequest(fetchRequest, error:&amp;error)
</code></pre>

<p>Realm则简单的多：</p>

<pre><code>// Realm
let predicate = NSPredicate(format: "name BEGINSWITH [c]%@", searchString);
let specimens = Specimen.objectsWithPredicate(predicate).arraySortedByProperty("name", ascending: true)
</code></pre>

<h3>总结一下Realm对CoreData的优势：</h3>

<pre><code>不需要架构Context那种烦人的东西

CoreData 是一个博大精深的技术，不要妄想几天之内可以用的很溜。
</code></pre>

<hr />

<pre><code>支持 NSPredicate
</code></pre>

<p>从 CoreData 转过来并没有太多的不适应。</p>

<pre><code>CoreData多个持久化文件很麻烦，Realm轻松支持这个功能
</code></pre>

<h5>劣势：</h5>

<p>是会增加应用大概1MB的体积。CoreData原生支持，不会增加App体积。</p>

<p>虽然看上去很厉害，但是这么新靠谱吗</p>

<p>Realm大部分源码公开在github上：realm。项目在新建不到两年里，已经得到开源社区大量关注：</p>

<p><img src="http://al1020119.github.io/images/benchmarks.004b.png" title="Caption" ></p>

<p>官方也承诺会持续解决用户反馈的各种问题。也可以直接在他们twitter上去@他们。</p>

<p>就算靠谱，有别人在用吗</p>

<p>推荐阅读这篇博客，作者介绍了他痛下决心抛弃CoreData后，如何安全迁移至Realm：《高速公路换轮胎——为遗留系统替换数据库》（文／凉粉小刀，简书作者）。</p>

<p>在多年以前，人们做了个决策，用CoreData做本地存储，替换掉NSUserDefaults。这之间的历史已经远不可考，但自从我加入项目以来，整个团队已经被它高昂的学习曲线、复杂的数据Migration流程以及过时陈旧的设计折磨的苦不堪言。于是我们决心把CoreData换掉。</p>

<p>再看下SO的情况：</p>

<p><img src="http://al1020119.github.io/images/benchmarks.005b.png" title="Caption" ></p>

<p>已经有大概两万条相关结果，你不是一个人！</p>

<p>需要知道的一些问题</p>

<pre><code>其实我自己觉得这些是可以接受的问题。技术很多时候就是权衡，为了达到一些目的，总是要牺牲掉一些东西。
</code></pre>

<p>所有的存储对象需要继承RealmObject</p>

<p>比如我现在的项目的数据从网络请求回来都会继承自己写的一个方便解析的基类，在这里就需要做出一些适应。</p>

<p>但是该问题在swift中是不存在的。因为swift是天生的面向协议编程范式。</p>

<pre><code>不能自定义getter、setter
</code></pre>

<p>realm会自动生成getter、setter，如果自定义getter、setter存储就会有影响。如果要规避这个问题，可以通过设置这个对象的忽略属性。</p>

<p>比如有个属性id，需要自定义setter。可以在对象属性里把id设置为忽略属性，这样realm就不会为它自动生成getter、setter，但是也不会把id存入数据库。接着自定义一个用于存储的属性比如realm_id。在id的setter中可以把把值也赋给realm_id。</p>

<p>这个问题在swift中也是不存在的，因为swfit中使用的是willset、didset这种通知机制。</p>

<pre><code>查询的结果不是数组
</code></pre>

<p>为了能够支持查询结果的链式查询，realm自定义了一个集合类型。可以枚举，但是不是熟悉的数组了。又因为realm的懒加载机制，所以不建议在数据层把这个枚举转成数组类型。这样的缺点就是上层知道了数据的存储逻辑。严格的说这里不应该让上层知道。但是这样设计也许是为了方便上层进行再次检索，realm有着优越的查询性能。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[FMDB封装篇]]></title>
    <link href="http://al1020119.github.io/blog/2016/07/02/fmdbzfenghuznag/"/>
    <updated>2016-07-02T22:59:42+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/07/02/fmdbzfenghuznag</id>
    <content type="html"><![CDATA[<p>前言：</p>

<p>在自己开发中，每次用到数据库都会纠结是使用CoreData还是FMDB。CoreData虽然Api简单，但是调用栈非常复杂，要初始化一个Context需要至少20行代码。。。</p>

<p>显然，对于这种这么恶心的情况，我们的大Github必须有人会跳出来解决这种问题。于是就出现了MagicRecord这个对CoreData的封装库。一开始遇到这个库的时候，好用到几乎让我想把所有项目的数据库都换成CoreData了。两句话解决CoreData调用栈的初始化，一句话完成数据库版本升级和自动数据合并更新（虽然我们很少用到）。</p>

<p>然而这并不能解决一个根本性的问题，CoreData中的每个Object都要和一个context进行绑定，导致我们很多业务需求需要创建自己的私有context，然后再需要更新的时候保存到主context中。这又导致了我们在controller中或者在自己的业务类中维护多一个私有context属性。</p>

<!--more-->


<p>所以，最后还是选择了FMDB进行封装。</p>

<p>之前自己搞过Java后台，将FMDB进行Hibernate式的封装，使用runtime解析，不用继承任何基类（swift中要继承NSObject），只要实现一个持久化协议并实现方法即可，屏蔽基本的数据库和表操作。</p>

<p>项目简介：</p>

<h5>JRDB：一个对FMDB进行类Hibernate封装的iOS库，支持Objective-C 和 Swift。</h5>

<p>Description</p>

<pre><code>使用分类的模式，模仿Hibernate，对FMDB进行简易封装

支持pod 安装 『pod 'JRDB'』，Podfile需要添加 use_framework!

使用协议，不用继承基类，对任意NSObject可以进行入库操作

支持swift 和 Objective-C

支持数据类型：基本数据类型（int，double，等），String，NSData，NSNumber，NSDate
</code></pre>

<h5>注：Swift的基本数据类型，不支持Option类型，既不支持Int？Int！等，对象类型支持Option类型</h5>

<p>Installation（安装）</p>

<pre><code>use_frameworks!
pod 'JRDB'
@import JRDB;
</code></pre>

<p>Usage</p>

<p>。。。</p>

<p>Save（保存）</p>

<p>Objective-C</p>

<pre><code>Person *p = [[Person alloc] init];
p.a_int = 1;
p.b_unsigned_int = 2;
p.c_long = 3;
p.d_long_long = 4;
p.e_unsigned_long = 5;
p.f_unsigned_long_long = 6;
p.g_float = 7.0;
p.h_double = 8.0;
p.i_string = @"9";
p.j_number = @10;
p.k_data = [NSData data];
p.l_date = [NSDate date];
[p jr_save];
</code></pre>

<p>Swift</p>

<p>Swift中需要入库的类需要继承NSObject（使用到runtime）</p>

<pre><code>The Object that you want to persistent should inherit from NSObject

let p = Person()
p.name = "name"
p.age = 10
p.birthday = NSDate()
p.jr_save()
</code></pre>

<h5>Update（更新）</h5>

<pre><code>Person *p = [Person jr_findAll].firstObject;
p.name = @"abc";
[p jr_update columns:nil];
</code></pre>

<p>column: 需要更新的字段名，传入空为全量更新</p>

<h5>Delete（删除）</h5>

<pre><code>Person *p = [Person jr_findAll].firstObject;
[p jr_delete];
</code></pre>

<h5>Select（查找）</h5>

<h5>常规查找</h5>

<pre><code>Person *p = [Person jr_findByPrimaryKey:@"111"];
NSArray *list = [Person jr_findAll];
NSArray *list1 = [Person jr_findAllOrderBy:@"_age" isDesc:YES];
</code></pre>

<h5>条件查询</h5>

<pre><code>NSArray *condis = @[
     [JRQueryCondition condition:@"_l_date &lt; ?" args:@[[NSDate date]] type:JRQueryConditionTypeAnd],
     [JRQueryCondition condition:@"_a_int &gt; ?" args:@[@9] type:JRQueryConditionTypeAnd],];
NSArray *arr = [Person jr_findByConditions:condis
                      groupBy:@"_room"
                      orderBy:@"_age"
                      limit:@" limit 0,13 "
                      isDesc:YES];
</code></pre>

<p>SQL</p>

<pre><code>NSString *sql = @"select * from Person where age = ?";
NSArray *list = [Person jr_executeSql:sql args:@[@10]];
</code></pre>

<p>Other（其他）</p>

<p>协议：JRPersistent</p>

<pre><code>@protocol JRPersistent @required
- (void)setID:(NSString * _Nullable)ID;
- (NSString * _Nullable)ID;
@optional
/**
 *  返回不用入库的对象字段数组
 *  The full property names that you want to ignore for persistent
 *  @return array
 */
+ (NSArray * _Nullable)jr_excludePropertyNames;
/**
 *  返回自定义主键字段
 *  @return 字段全名
 */
+ (NSString * _Nullable)jr_customPrimarykey;
/**
 *  返回自定义主键值
 *  @return 主键值
 */
- (id _Nullable)jr_customPrimarykeyValue;
@end
</code></pre>

<p>主键</p>

<p>默认每个Object的主键为ID， UUID字符串。</p>

<p>可以实现 jr_customPrimarykey 以及 jr_customPrimarykeyValue 方法，自定义主键。</p>

<p>默认NSObject分类实现</p>

<pre><code>@interface NSObject (JRDB) (...methods)
@end
JRDBMgr
@interface JRDBMgr : NSObject
@property (nonatomic, strong) FMDatabase *defaultDB;
+ (instancetype)shareInstance;
+ (FMDatabase *)defaultDB;
- (FMDatabase *)createDBWithPath:(NSString *)path;
- (void)deleteDBWithPath:(NSString *)path;
/**
 *  在这里注册的类，使用本框架的数据库将全部建有这些表
 *  @param clazz 类名
 */
- (void)registerClazzForUpdateTable:(Class)clazz;
- (NSArray *)registedClazz;
/**
 * 更新默认数据库的表（或者新建没有的表）
 * 更新的表需要在本类先注册
 */
- (void)updateDefaultDB;
- (void)updateDB:(FMDatabase *)db;
@end
</code></pre>

<p>JRDBMgr持有一个默认数据库（~/Documents/jrdb/jrdb.sqlite），任何不指定数据库的操作，都在此数据库进行操作。默认数据库可以自行设置。</p>

<p>Method</p>

<pre><code>- (void)registerClazzForUpdateTable:(Class)clazz;
</code></pre>

<p>在JRDBMgr中注册的类，可以使用</p>

<pre><code>-(void)updateDB:(FMDatabase *)db
</code></pre>

<p>进行统一更新或者创建表。</p>

<p>Table Operation（表操作）</p>

<p>Create（建表）</p>

<pre><code>// FMDatabase+JRDB 方法
[[JRDBMgr defaultDB] createTable4Clazz:[Person class]];
[Person jr_createTable];
// 删除原有的表，重新创建
[[JRDBMgr defaultDB] truncateTable4Clazz:[Person class]];
[Person jr_truncateTable];
//保存时，若发现没有表，将自动创建
[person jr_save];
Update 【更新表】
[[JRDBMgr defaultDB] updateTable4Clazz:[Person class]];
[Person jr_updateTable];
</code></pre>

<p>更新表时，只会添加不存在的字段，不会修改字段属性，不会删除字段，若有需要，需要自行写sql语句进行修改</p>

<p>Drop（删表）</p>

<pre><code>[[JRDBMgr defaultDB] dropTable4Clazz:[Person class]];
[Person jr_dropTable];
</code></pre>

<p>Thread Operation（线程操作）</p>

<p>多线程操作使用FMDB自带的 FMDatabaseQueue</p>

<pre><code>[person jr_saveWithComplete:^(BOOL success) {
    NSLog(@"%d", success);
}];
</code></pre>

<p>任何带complete block的操作，都将放入到FMDatabaseQueue进行顺序执行</p>

<p>注：所有需要立刻返回结果，或者影响其他操作的数据库操作，都建议放在主线程进行更新，大批量更新以及多线程操作数据库时，请使用带complete block的操作。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[FMDB精华篇]]></title>
    <link href="http://al1020119.github.io/blog/2016/07/02/fmdbjinghua/"/>
    <updated>2016-07-02T12:59:42+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/07/02/fmdbjinghua</id>
    <content type="html"><![CDATA[<p>由于FMDB是建立在SQLite的之上的，所以你至少也该把这篇文章从头到尾读一遍。与此同时，把SQLite的文档页 加到你的书签中。自动引用计数（APC）还是手动内存管理呢？</p>

<p>两种都行，FMDB会在编译的时候知道你是用的哪一种，然后进行相应处理。</p>

<h5>使用方法</h5>

<p>FMDB有三个主要的类</p>

<pre><code>1.FMDatabase – 表示一个单独的SQLite数据库。 用来执行SQLite的命令。
2.FMResultSet – 表示FMDatabase执行查询后结果集
3.FMDatabaseQueue – 如果你想在多线程中执行多个查询或更新，你应该使用该类。这是线程安全的。
</code></pre>

<!--more-->


<h5>数据库创建</h5>

<p>创建FMDatabase对象时参数为SQLite数据库文件路径。该路径可以是以下三种之一：</p>

<pre><code>1..文件路径。该文件路径无需真实存，如果不存在会自动创建。
2..空字符串(@”")。表示会在临时目录创建一个空的数据库，当FMDatabase 链接关闭时，文件也被删除。
3.NULL. 将创建一个内在数据库。同样的，当FMDatabase连接关闭时，数据会被销毁。
</code></pre>

<p>(如需对临时数据库或内在数据库进行一步了解，请继续阅读：<a href="http://www.sqlite.org/inmemorydb.html">http://www.sqlite.org/inmemorydb.html</a>)</p>

<pre><code>FMDatabase *db = [FMDatabase databaseWithPath:@"/tmp/tmp.db"];   
</code></pre>

<h5>打开数据库</h5>

<p>在和数据库交互 之前，数据库必须是打开的。如果资源或权限不足无法打开或创建数据库，都会导致打开失败。</p>

<pre><code>if (![db open]) {    
        [db release];   
        return;    
    }  
</code></pre>

<h5>执行更新</h5>

<p>一切不是SELECT命令的命令都视为更新。这包括  CREATE, UPDATE, INSERT,ALTER,COMMIT, BEGIN, DETACH, DELETE, DROP, END, EXPLAIN, VACUUM, and REPLACE  （等）。
简单来说，只要不是以SELECT开头的命令都是UPDATE命令。</p>

<p>执行更新返回一个BOOL值。YES表示执行成功，否则表示有那些错误 。你可以调用 -lastErrorMessage 和 -lastErrorCode方法来得到更多信息。</p>

<h5>执行查询</h5>

<p>SELECT命令就是查询，执行查询的方法是以 -excuteQuery开头的。</p>

<p>执行查询时，如果成功返回FMResultSet对象， 错误返回nil. 与执行更新相当，支持使用 NSError**参数。同时，你也可以使用 -lastErrorCode和-lastErrorMessage获知错误信息。</p>

<p>为了遍历查询结果，你可以使用while循环。你还需要知道怎么跳到下一个记录。使用FMDB，很简单实现，就像这样：</p>

<pre><code>FMResultSet *s = [db executeQuery:@"SELECT * FROM myTable"];   
while ([s next]) {   
    //retrieve values for each record   
}   
</code></pre>

<p>你必须一直调用   -[FMResultSet next]   在你访问查询返回值之前，甚至你只想要一个记录：</p>

<pre><code>FMResultSet *s = [db executeQuery:@"SELECT COUNT(*) FROM myTable"];   
  if ([s next]) {    
       int totalCount = [s intForColumnIndex:0];   
  }   
</code></pre>

<p>FMResultSet  提供了很多方法来获得所需的格式的值：</p>

<pre><code>intForColumn:
longForColumn:
longLongIntForColumn:
boolForColumn:
doubleForColumn:
stringForColumn:
dataForColumn:
dataNoCopyForColumn:
UTF8StringForColumnIndex:
objectForColumn:
</code></pre>

<p>这些方法也都包括 {type}ForColumnIndex 的这样子的方法，参数是查询结果集的列的索引位置。</p>

<p>你无需调用  [FMResultSet close]来关闭结果集, 当新的结果集产生，或者其数据库关闭时，会自动关闭。</p>

<h5>关闭数据库</h5>

<p>当使用完数据库，你应该 -close 来关闭数据库连接来释放SQLite使用的资源。
    [db close];</p>

<h5>事务</h5>

<p>FMDatabase是支持事务的。</p>

<p>数据净化（数据格式化）</p>

<p>使用FMDB，插入数据前，你不要花时间审查你的数据。你可以使用标准的SQLite数据绑定语法。</p>

<pre><code>INSERT INTO myTable VALUES (?, ?, ?)   
</code></pre>

<p>SQLite会识别 “?” 为一个输入的点位符， 这样的执行会接受一个可变参数（或者表示为其他参数，如NSArray, NSDictionary,或va_list等），会正确为您转义。</p>

<p>你也可以选择使用命名参数语法。</p>

<pre><code>INSERT INTO myTable VALUES (:id, :name, :value)   
</code></pre>

<p>参数名必须以冒名开头。SQLite本身支持其他字符，当Dictionary key的内部实现是冒号开头。注意你的NSDictionary key不要包含冒号。</p>

<pre><code>NSDictionary *argsDict = [NSDictionary dictionaryWithObjectsAndKeys:@"My Name", @"name", nil];    
    [db executeUpdate:@"INSERT INTO myTable (name) VALUES (:name)" withParameterDictionary:argsDict];   
</code></pre>

<p>而且，代码不能这么写（为什么？想想吧。）</p>

<pre><code>[db executeUpdate:@"INSERT INTO myTable VALUES (?)", @"this has \" lots of ' bizarre \" quotes '"]; 
</code></pre>

<p>你应该：</p>

<pre><code>[db executeUpdate:@"INSERT INTO myTable VALUES (?)", @"this has " lots of ' bizarre " quotes '"];   
</code></pre>

<p>提供给 -executeUpdate: 方法的参数都必须是对象。就像以下的代码就无法工作，且会产生崩溃。</p>

<pre><code>[db executeUpdate:@"INSERT INTO myTable VALUES (?)", 42];   
</code></pre>

<p> 正确有做法是把数字打包成 NSNumber对象</p>

<pre><code>[db executeUpdate:@"INSERT INTO myTable VALUES (?)", [NSNumber numberWithInt:42]];   
</code></pre>

<p>或者，你可以使用  -execute*WithFormat: ，这是NSString风格的参数</p>

<pre><code>[db executeUpdateWithFormat:@"INSERT INTO myTable VALUES (%d)", 42];   
</code></pre>

<p> -execute*WithFormat:  的方法的内部实现会帮你封装数据， 以下这些修饰符都可以使用： %@, %c, %s, %d, %D,%i, %u, %U, %hi, %hu, %qi, %qu, %f, %g, %ld, %lu, %lld, and %llu.  除此之外的修饰符可能导致无法预知的结果。 一些情况下，你需要在SQL语句中使用 % 字符，你应该使用 %%。</p>

<p>使用FMDatabaseQueue 及线程安全
在多个线程中同时使用一个FMDatabase实例是不明智的。现在你可以为每个线程创建一个FMDatabase对象。 不要让多个线程分享同一个实例，它无法在多个线程中同时使用。 若此，坏事会经常发生，程序会时不时崩溃，或者报告异常，或者陨石会从天空中掉下来砸到你Mac Pro.  总之很崩溃。所以，不要初始化FMDatabase对象，然后在多个线程中使用。请使用 FMDatabaseQueue，它是你的朋友而且会帮助你。以下是使用方法：</p>

<h5>首先创建队列。</h5>

<pre><code>FMDatabaseQueue *queue = [FMDatabaseQueue databaseQueueWithPath:aPath]; 
</code></pre>

<h5>这样使用。</h5>

<pre><code>[queue inDatabase:^(FMDatabase *db) {    
          [db executeUpdate:@"INSERT INTO myTable VALUES (?)", [NSNumber numberWithInt:1]];    
          [db executeUpdate:@"INSERT INTO myTable VALUES (?)", [NSNumber numberWithInt:2]];    
          [db executeUpdate:@"INSERT INTO myTable VALUES (?)", [NSNumber numberWithInt:3]];    
          FMResultSet *rs = [db executeQuery:@"select * from foo"];    
         while([rs next]) {   
            …    
         }    
}];   
</code></pre>

<h5>像这样，轻松地把简单任务包装到事务里：</h5>

<pre><code>[queue inTransaction:^(FMDatabase *db, BOOL *rollback) {    
            [db executeUpdate:@"INSERT INTO myTable VALUES (?)", [NSNumber numberWithInt:1]];    
            [db executeUpdate:@"INSERT INTO myTable VALUES (?)", [NSNumber numberWithInt:2]];    
            [db executeUpdate:@"INSERT INTO myTable VALUES (?)", [NSNumber numberWithInt:3]];    
            if (whoopsSomethingWrongHappened) {    
                    *rollback = YES; return;    
            }   
            // etc…    
            [db executeUpdate:@"INSERT INTO myTable VALUES (?)", [NSNumber numberWithInt:4]];    
    }];   
</code></pre>

<p> FMDatabaseQueue  后台会建立系列化的G-C-D队列，并执行你传给G-C-D队列的块。这意味着 你从多线程同时调用调用方法，GDC也会按它接收的块的顺序来执行。谁也不会吵到谁的脚 ，每个人都幸福。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SQLite封装篇]]></title>
    <link href="http://al1020119.github.io/blog/2016/07/01/sqlzfengzhuang/"/>
    <updated>2016-07-01T12:59:42+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/07/01/sqlzfengzhuang</id>
    <content type="html"><![CDATA[<p>最近写的项目中有用到数据库,写了不少蛋疼的sql语句,每次都是好几行代码,而且每次都是重复的没有一点技术含量的代码,虽然也有不少基于sqlite的封装,不过用起来还是感觉不够面向对象! 为了不再写重复的代码,花了几天时间,基于SQLite3简单封装了下,实现了一行代码解决增删改查等常用的功能!并没有太过高深的知识,主要用了runtime和KVC:</p>

<!--more-->


<p>首先我们创建个大家都熟悉的Person类,并声明两个属性,下面将以类此展开分析</p>

<pre><code>@interface Person : NSObject
@property(nonatomic, copy) NSString *name;
@property(nonatomic, assign) NSInteger age;
@end
</code></pre>

<h5>创建表格</h5>

<p>相信下面这句创表语句大家都熟悉吧,就不做介绍了</p>

<pre><code>create table if not exists Person (id integer primary key autoincrement,name text,age integer)
</code></pre>

<p>然而开发中我们都是基于模型开发的,基本上都是一个模型对应数据库的一张表,那么每个模型的属性都不一样,那么我们又该如何生成类似上面的语句呢? 我想到了runtime,通过runtime获取一个类的属性列表,所以有了下面这个方法:</p>

<pre><code>/// 获取当前类的所有属性
+ (NSArray *)getAttributeListWithClass:(id)className {
    // 记录属性个数
    unsigned int count;
    objc_property_t *properties = class_copyPropertyList([className class], &amp;count);
    NSMutableArray *tempArrayM = [NSMutableArray array];
    for (int i = 0; i &lt; count; i++) {
        // objc_property_t 属性类型
        objc_property_t property = properties[i];
        // 转换为Objective C 字符串
        NSString *name = [NSString stringWithCString:property_getName(property) encoding:NSUTF8StringEncoding];
        NSAssert(![name isEqualToString:@"index"], @"禁止在model中使用index作为属性,否则会引起语法错误");
        if ([name isEqualToString:@"hash"]) {
            break;
        }
        [tempArrayM addObject:name];
    }
    free(properties);
    return [tempArrayM copy];
}
</code></pre>

<p>通过这个方法我们可以获取一个类的所有属性列表并将其保存到数组中(index是数据库中保留的关键字,所以在这里用了个断言),然而仅仅是拿到属性列表还是不够的,我们还需要将对应的OC类型转换为SQL对应的数据类型,相信通过上面获取属性名的方法,大家也知道通过runtime能拿到属性对应的数据类型了,那么我们可以通过下面方法将其转换为SQLite需要的类型</p>

<pre><code>/// OC类型转SQL类型
+ (NSString *)OCConversionTyleToSQLWithString:(NSString *)String {
    if ([String isEqualToString:@"long"] || [String isEqualToString:@"int"] || [String isEqualToString:@"BOOL"]) {
        return @"integer";
    }
    if ([String isEqualToString:@"NSData"]) {
        return @"blob";
    }
    if ([String isEqualToString:@"double"] || [String isEqualToString:@"float"]) {
        return @"real";
    }
    // 自定义数组标记
    if ([String isEqualToString:@"NSArray"] || [String isEqualToString:@"NSMutableArray"]) {
        return @"customArr";
    }
    // 自定义字典标记
    if ([String isEqualToString:@"NSDictionary"] || [String isEqualToString:@"NSMutableDictionary"]) {
        return @"customDict";
    }
    return @"text";
}
</code></pre>

<p>通过上面方法我们将OC的数据类型转换为了SQL的数据类型并保存到了数组中(上面有两个自定义的类型,后面使用到的时候再做介绍),通过上面的方法我们成功的拿到了一个模型类的属性名和对应的SQL数据类型,然后使用键值对的形式将其保存到了一个字典中,比如:</p>

<pre><code>@{@"name" : @"text",@"age":"integer"};
</code></pre>

<p>获取到这些之后那么创表语句就不难了吧,</p>

<p>// 该方法接收一个类型,内部通过遍历类的属性,字符串拼接获取完整的创表语句,并在内部执行sql语句,并返结果</p>

<pre><code>    - (BOOL)creatTableWithClassName:(id)className;
</code></pre>

<p>介绍完了怎么创表,那么我们再来说说怎么将数据插入到数据库中: 我们先看一看插入数据的sql语句:insert into Person (name,age) values (&lsquo;花菜ChrisCai98&rsquo;,89); 前面都是固定格式的,同样我们可以通过字符串的拼接获取完整的创表语句; 在上面我们已经可以拿到Person类的所有属性列表,那么我们如何拼接sql语句呢? 在这里我定义了这么一个方法</p>

<pre><code>/// 该方法接收一个对象作为参数(模型对象),并返回是否插入成功
- (BOOL)insertDataFromObject:(id)object;
/// 我们可以这样
Person * p = [[Person alloc]init];
p.name = @"花菜ChrisCai";
p.age = 18;
[[GKDatabaseManager sharedManager] insertDataFromObject:p];
</code></pre>

<h5>插入数据</h5>

<p>通过上面这么简单的一句代码实现将数据插入到数据库中,在该方法内部我们通过上面所述的方法获取Person类的所有属性列表,那么我们可以就可以拼接插入语句的前半句了,然后通过KVC的形式完成后半部分赋值的操作;</p>

<pre><code>/// 插入数据
- (BOOL)insertDataFromObject:(id)object {
    // 创建可变字符串用于拼接sql语句
    NSMutableString * sqlString = [NSMutableString stringWithFormat:@"insert into %@ (",NSStringFromClass([object class])];
    [[GKObjcProperty getUserNeedAttributeListWithClass:[object class]] enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
        // 拼接字段名
        [sqlString appendFormat:@"%@,",obj];
    }];
    // 去掉后面的逗号
    [sqlString deleteCharactersInRange:NSMakeRange(sqlString.length-1, 1)];
    // 拼接values
    [sqlString appendString:@") values ("];

    // 拼接字段值
    [[GKObjcProperty getSQLProperties:[object class]] enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull key, id  _Nonnull obj, BOOL * _Nonnull stop) {
        // 拼接属性
        if ([object valueForKey:key]){
            if ([obj isEqualToString:@"text"]) {
                [sqlString appendFormat:@"'%@',",[object valueForKey:key]];
            } else if ([obj isEqualToString:@"customArr"] || [obj isEqualToString:@"customDict"]) { // 数组字典转处理
                NSData * data = [NSJSONSerialization dataWithJSONObject:[object valueForKey:key] options:0 error:nil];
                NSString * jsonString = [[NSString alloc] initWithData:data encoding:(NSUTF8StringEncoding)];
                [sqlString appendFormat:@"'%@',",jsonString];
            }else if ([obj isEqualToString:@"blob"]){ // NSData处理
                NSString * jsonString = [[NSString alloc] initWithData:[object valueForKey:key] encoding:(NSUTF8StringEncoding)];
                [sqlString appendFormat:@"'%@',",jsonString];
            }else {
                [sqlString appendFormat:@"%@,",[object valueForKey:key]];
            }
        }else {// 没有值就存NULL
            [sqlString appendFormat:@"'%@',",[object valueForKey:key]];
        }
    }];
    // 去掉后面的逗号
    [sqlString deleteCharactersInRange:NSMakeRange(sqlString.length-1, 1)];
    // 添加后面的括号
    [sqlString appendFormat:@");"];
    // 执行语句
    return [self executeSqlString:sqlString];
}
</code></pre>

<p>在上面方法中,我们用到了之前提到的自定义的类型,通过该自定的类型我们知道需要存储的是字典或者数组,在这里,我们将数组和字典转换为JSON字符串的形式存入数据库中;
到此我们完成了创表和插入向表格中插入数据的操作,下面我们再看看如何从实现一行代码从数据库中将值取出来,在这里我们提供了6中查询的接口,</p>

<h5>提供的接口如下:</h5>

<pre><code>- (NSArray *)selecteDataWithClass:(id)className;// 根据类名查询对应表格内所有数据
- (NSInteger)getTotalRowsFormClass:(id)className; // 获取表的总行数
- (id)selecteFormClass:(id)className index:(NSInteger)index;// 获取指定行数据
- (NSArray *)selectObject:(Class)className key:(id)key operate:(NSString *)operate value:(id)value;// 指定条件查询
- (NSArray *)selecteDataWithSqlString:(NSString *)sqlString class:(id)className;// 自定义语句查询
- (NSArray *)selectObject:(Class)className propertyName:(NSString *)propertyName type:(GKDatabaseSelectLocation)type content:(NSString *)content;// 模糊查询
</code></pre>

<p>通过第一个方法(该方法接收一个类名作为参数)就能简单的实现一行代码查询表格中的数据了</p>

<pre><code> NSArray * persons = [[GKDatabaseManager sharedManager] selecteDataWithClass:[Person class]];
</code></pre>

<p>下面我们着重介绍下核心方法,其他所有方法都是基于该方法实现的</p>

<pre><code>/// 自定义语句查询
- (NSArray *)selecteDataWithSqlString:(NSString *)sqlString class:(id)className  {
    // 创建模型数组
    NSMutableArray *models = nil;
    // 1.准备查询
    sqlite3_stmt *stmt; // 用于提取数据的变量
    int result = sqlite3_prepare_v2(database, sqlString.UTF8String, -1, &amp;stmt, NULL);
    // 2.判断是否准备好
    if (SQLITE_OK == result) {
        models = [NSMutableArray array];
        // 获取属性列表名数组 比如name
        NSArray * arr = [GKObjcProperty getUserNeedAttributeListWithClass:[className class]];
        // 获取属性列表名和sql数据类型 比如  name : text
        NSDictionary * dict = [GKObjcProperty getSQLProperties:[className class]];
        // 准备好了
        while (SQLITE_ROW == sqlite3_step(stmt)) { // 提取到一条数据
            __block id objc = [[[className class] alloc]init];
            for ( int i = 0; i &lt; arr.count; i++) {
                // 默认第0个元素为表格主键 所以元素从第一个开始
                // 使用KVC完成赋值
                if ([dict[arr[i]] isEqualToString:@"text"]) {
                    [objc setValue:[NSString stringWithFormat:@"%@",[self textForColumn:i + 1  stmt:stmt]] forKey:arr[i]];

                } else if ([dict[arr[i]] isEqualToString:@"real"]) {
                    [objc setValue:[NSString stringWithFormat:@"%f",[self doubleForColumn:i + 1  stmt:stmt]] forKey:arr[i]];

                } else if ([dict[arr[i]] isEqualToString:@"integer"]) {

                    [objc setValue:[NSString stringWithFormat:@"%i",[self intForColumn:i + 1  stmt:stmt]] forKey:arr[i]];

                } else if ([dict[arr[i]] isEqualToString:@"customArr"]) { // 数组处理

                    NSString * str = [self textForColumn:i + 1 stmt:stmt];
                    NSData * data = [str dataUsingEncoding:NSUTF8StringEncoding];
                    NSArray * resultArray = [NSJSONSerialization JSONObjectWithData:data options:0 error:nil];
                    [objc setValue:resultArray forKey:arr[i]];
                }  else if ([dict[arr[i]] isEqualToString:@"customDict"]) { // 字典处理

                    NSString * str = [self textForColumn:i + 1 stmt:stmt];
                    NSData * data = [str dataUsingEncoding:NSUTF8StringEncoding];
                    NSDictionary * resultDict = [NSJSONSerialization JSONObjectWithData:data options:0 error:nil];
                    [objc setValue:resultDict forKey:arr[i]];
                } else if ([dict[arr[i]] isEqualToString:@"blob"]) { // 二进制处理

                    NSString * str = [self textForColumn:i + 1 stmt:stmt];
                    NSData * data = [str dataUsingEncoding:NSUTF8StringEncoding];
                    [objc setValue:data forKey:arr[i]];
                }
            }
            [models addObject:objc];
        }
    }
    return [models copy];
}
</code></pre>

<p>在该方法内部,我们根据传递进来的类创建了一个对象(使用__block是因为在block内部需要修改对象的属性),通过之前的方法我们拿到了对应的sql类型,和属性名,这里就不重复介绍了,通过对应的sql类型执行对应的方法从数据中将数据取出来,并通过KVC的形式给对象赋值,值得一提的是这里我们通过自定义的字段(customArr,customDict)可以知道我们取的是数组或者字典,然后数据库中的JSON字符串转换为数组或者字典,然后再利用KVC赋值给对象!</p>

<p>到此基本上所有的功能就都实现了,其他的诸如更新数据,删除数据,删除表格等有提供具体的接口,这里就不一一介绍了,源码中有详细的注释,同时也有DEMO,有需要的可以自行下载,</p>

<p>以上均为个人这段时间的总结,如有不对的地方,可以在下面评论 也可以通过QQ:4593679联系我,如觉得好用记得star一下哦~,谢谢!!! 源码地址:<a href="https://github.com/ChrisCaixx/GKDatabase">https://github.com/ChrisCaixx/GKDatabase</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SQLite精华篇]]></title>
    <link href="http://al1020119.github.io/blog/2016/07/01/sqljinghua/"/>
    <updated>2016-07-01T02:59:42+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/07/01/sqljinghua</id>
    <content type="html"><![CDATA[<h4>概述</h4>

<p>iOS系统自带Core Data来进行持久化处理，而且Core Data可以使用图形化界面来创建对象，但是Core Data不是关系型数据库，对于Core Data来说比较擅长管理在设备上创建的数据持久化存储用户创建的对象，但是要处理大量的数据时就应该优先选择SQL关系型数据库来存储这些数据。
Core Data在后台也是使用SQLite来存储数据的，但是开发人员不能直接访问这些数据，只能通过Core Data提供的API来操作，如果一旦人为的通过SQLite修改这些数据那么使用Core Data再次访问这些数据时就会发生错误。</p>

<!--more-->


<h3>SQLite库</h3>

<p>SQLite是使用C语言写的开源库，实现了一个自包含的SQL关系型数据库引擎，可以使用SQLite存储操作大量的数据，作为关系型数据库我们可以在一个数据库中建立多张相关联的表来解决大量数据重复的问题。而且SQLite库也针对移动设备上的使用进行了优化。
因为SQLite的接口使用C写的，而且Objective-C是C的超集所以可以直接在项目中使用SQLite。</p>

<h3>设计一个数据库</h3>

<p>开始之前首先要想到需要存什么数据，然后怎么设计这个数据库。
首先我们设计一个数据库用来存储人员信息如下：</p>

<p><img src="http://al1020119.github.io/images/sql0004.png" title="Caption" ></p>

<p>上面是所有的人员信息，实际可能比这个多很多。但是我们发现region这一行中有很多的数据重复出现。很多人可能来自同一个地方，为了避免这种情况我们应该再重新创建一张表来单独存储region这列的信息然后在这个表中引用region表中的信息。当然我们还可以在region表中添加更多的信息比如详细地址。现在创建两张表people与region如下所示</p>

<pre><code>people表
</code></pre>

<p><img src="http://al1020119.github.io/images/sql0001.png" title="Caption" ></p>

<pre><code>region表
</code></pre>

<p><img src="http://al1020119.github.io/images/sql0002.png" title="Caption" ></p>

<h5>使用SQLite创建数据库</h5>

<p>为了熟悉SQLite语句，打开shell使用SQLite命令行来创建一个数据库</p>

<pre><code>打开创建数据库

打开shell切换到指定目录输入



sqlite3 database.db
</code></pre>

<p>这行命令是启动sqlite命令行并且创建新的数据库database.db并附加该数据到命令行</p>

<p>此时已经进入sqlite命令行通过输入.help可以显示可以使用哪些命令，通过输入.databases来查看当前有哪些数据库附加到当前的命令行工具中。输入.quit或.exit退出当前命令行工具</p>

<h5>创建表</h5>

<pre><code>create table "main"."people" ("id" integer primary key autoincrement not null, "name" text,"age" integer,"email" text,"region" integer);
</code></pre>

<p>这条命令是创建一个people的表，并且将id字段设为primary key主键将其指定为一个autoincrement自动增长的字段。表示不用提供id的值数据库将自动生成。后面的表示该张表中所含有的字段。</p>

<p>因为要设计两张表所以还需要创建region表</p>

<pre><code>create table "main"."region" ("regionid" integer primary key autoincrement not null, "regioninfo" text,"address" text not null);
</code></pre>

<h5>添加数据</h5>

<p>此时已经成功创建了两张表我们要添加数据进去</p>

<pre><code>insert into "main"."people" ("name","age","email","region") values ('jhon','20','jhon@mail','1');
</code></pre>

<p>这样成功往people表成功的插入了一条数据。这样写效率比较低。每次只能插入一条数据不要担心SQLite支持将文件直接导入数据库中。可以是普通的文件文件也可以是excel文件。下面我们创建一个people.txt文件格式如下：</p>

<pre><code>1 jhon 20 jhon@mail 12 peter 20 peter@mail 23 july 20 july@mail 14 elev 20 elev@mail 35 ribet 20 ribet@mail
</code></pre>

<p>注意每个字段之间的空隙是用制表符来分割的，也就是创建文件是每个字段用tab键进行分割。字段的顺序必须和表中的顺序相同然后将people.txt文件导入people表中</p>

<p>.separator &ldquo;&rdquo;</p>

<p>根据来分割字段，然后接着输入</p>

<pre><code>.import "people.txt" people
</code></pre>

<p>导入people.txt文件到people表中此时会提示如下错误信息</p>

<pre><code>people.txt:1: INSERT failed: UNIQUE constraint failed: people.id
</code></pre>

<p>不用担心这个意思是说已经存在了一个id为1的数据所以这条数据插入失败，是因为我们之前手动了插入了一条数据。可以通过以下指令来查插入的数据</p>

<pre><code>select * from people;
</code></pre>

<p>然后用同样的方法创建一个region.txt的文件并将其导入region表中。</p>

<h5>注意</h5>

<p>使用SQLite命令行可能会出现&hellip;>这表示指令输入错误，按ctrl+d即可退出</p>

<p>查询数据上面已经添加完数据通过select指令可以查询这些数据</p>

<pre><code>select * from people;11
</code></pre>

<p>查询popple表中的所有数据</p>

<p>链接表数据</p>

<pre><code>select name,regioninfo from people,region where people.region=region.regionid;
</code></pre>

<p>输出结果</p>

<pre><code>jhon beijing
peter shanghai
july beijing
elev shenzhen
ribet beijing
</code></pre>

<p>从people和region表中查找name与regioninfo字段并且只查询people.region=region.regionid相匹配的结果，如果没有这个条件那么将出现5*3=15条数据</p>

<p>如果要查找某个地区的人使用where来筛选条件</p>

<pre><code>select name,regioninfo from people,region where people.region=region.regionid and region.regioninfo="beijing";
</code></pre>

<p>输出结果</p>

<pre><code>jhon beijing
july beijing
ribet beijing
</code></pre>

<h3>iOS中SQLite的使用</h3>

<p>开始之前应该在项目中引用SQLite库。TARGETS->General->Linked Frameworks and Libraries如下图所示</p>

<p><img src="http://al1020119.github.io/images/sql0003.png" title="Caption" ></p>

<p>将之前创建好的database.db文件导入项目中，并引入sqlite3.h头文件</p>

<pre><code>#import
</code></pre>

<p>使用SQLite需要一下几个步骤：</p>

<pre><code>声明类变量sqlite3来保存对数据库的引用

使用sqlite3_open打开数据库

创建SQLite语句

创建SQLite语句对象sqlite3_stmt

准备SQLite语句sqlite3_prepare_v2

开始遍历结果sqlite3_step
</code></pre>

<h5>初始化打开数据库</h5>

<pre><code>sqlite3 * database;
-(void)initDatabase
{ NSString *path = [[NSBundle mainBundle] pathForResource:@"database" ofType:@"db"];
if (sqlite3_open([path UTF8String], &amp;database) == SQLITE_OK) { NSLog(@"open database");
} else{
sqlite3_close(database); NSLog(@"error %s",sqlite3_errmsg(database));
}
</code></pre>

<p>}</p>

<p>打开数据库如果返回的状态码不是SQLITE_OK那么打开失败关闭数据库并且输出错误信息</p>

<h5>查询数据</h5>

<pre><code>-(void)operateDatabase
{ const char * sql = "select name,regioninfo from people,region where people.region=region.regionid";
sqlite3_stmt *statement; //创建sql语句对象
int sqlResult = sqlite3_prepare_v2(database, sql, -1, &amp;statement, NULL); //准备sql语句
if ( sqlResult== SQLITE_OK) //是否准备结束
{ while (sqlite3_step(statement) == SQLITE_ROW) //开始遍历查询结果
{ NSLog(@"name %s, region %s",sqlite3_column_text(statement, 0),sqlite3_column_text(statement, 1));
}
}
}
</code></pre>

<p>输出结果：</p>

<pre><code>name jhon, region beijingname peter, region shanghainame july, region beijingname elev, region shenzhenname ribet, region beijing1234512345
</code></pre>

<p>sqlite3_prepare_v2的参数第一个是数据库连接，第二个是sql语句，第三个是这个语句的长度传入-1表示地道第一个null终止符为止，第四个是返回一个语句对象，第五个是返回一个指向该sql语句的第一个字节的指针。</p>

<p>当sqlite3_prepare_v2返回状态码SQLITE_OK时开始遍历结果。</p>

<p>sqlite3_step用来遍历结果如果返回为SQLITE_ROW表示下一行准备结束可以开始查询。所以此处用一个while来便利所以查询的结果</p>

<p>遍历的过程中要取到结果通过一下的函数获取遍历结果</p>

<pre><code>SQLITE_API const void *SQLITE_STDCALL sqlite3_column_blob(sqlite3_stmt*, int iCol);
SQLITE_API int SQLITE_STDCALL sqlite3_column_bytes(sqlite3_stmt*, int iCol);
SQLITE_API int SQLITE_STDCALL sqlite3_column_bytes16(sqlite3_stmt*, int iCol);
SQLITE_API double SQLITE_STDCALL sqlite3_column_double(sqlite3_stmt*, int iCol);
SQLITE_API int SQLITE_STDCALL sqlite3_column_int(sqlite3_stmt*, int iCol);
SQLITE_API sqlite3_int64 SQLITE_STDCALL sqlite3_column_int64(sqlite3_stmt*, int iCol);
SQLITE_API const unsigned char *SQLITE_STDCALL sqlite3_column_text(sqlite3_stmt*, int iCol);
SQLITE_API const void *SQLITE_STDCALL sqlite3_column_text16(sqlite3_stmt*, int iCol);
SQLITE_API int SQLITE_STDCALL sqlite3_column_type(sqlite3_stmt*, int iCol);
SQLITE_API sqlite3_value *SQLITE_STDCALL sqlite3_column_value(sqlite3_stmt*, int iCol);
</code></pre>

<p>上面是所支持的结果类型，第一个参数为sql语句对象，第二个为获取哪一列的信息。</p>

<h5>参数化查询</h5>

<p>上面的情况每次sql语句都写死了，如果想要改变某个条件就需要重新写一条语句，幸好sqlite支持参数化查询，每次只需要更改查询条件就可以而不用更改整条sql语句，如果现在只想查询北京地区的人口信息使用参数化查询如下：</p>

<pre><code>-(void)operateDatabase
{ const char * sql = "select name,regioninfo from people,region where people.region=region.regionid and regioninfo=?";
sqlite3_stmt *statement; //创建sql语句对象
int sqlResult = sqlite3_prepare_v2(database, sql, -1, &amp;statement, NULL); //准备sql语句
sqlite3_bind_text(statement, 1, "beijing", -1,SQLITE_TRANSIENT); //绑定参数
if ( sqlResult== SQLITE_OK) //是否准备结束
{ while (sqlite3_step(statement) == SQLITE_ROW) //开始遍历查询结果
{ NSLog(@"name %s, region %s",sqlite3_column_text(statement, 0),sqlite3_column_text(statement, 1));
}
}
}
</code></pre>

<p>输出结果：</p>

<pre><code>name jhon, regionbeijingname july, regionbeijingname ribet, regionbeijing
</code></pre>

<p>可见需要更改的条件sql中用?来代替，然后用sqlite3_bind_text函数来绑定参数。根据类型不同绑定的函数也不同</p>

<pre><code>SQLITE_API int SQLITE_STDCALL sqlite3_bind_blob(sqlite3_stmt*, int, const void*, int n, void(*)(void*));
SQLITE_API int SQLITE_STDCALL sqlite3_bind_blob64(sqlite3_stmt*, int, const void*, sqlite3_uint64,void(*)(void*));
SQLITE_API int SQLITE_STDCALL sqlite3_bind_double(sqlite3_stmt*, int, double);
SQLITE_API int SQLITE_STDCALL sqlite3_bind_int(sqlite3_stmt*, int, int);
SQLITE_API int SQLITE_STDCALL sqlite3_bind_int64(sqlite3_stmt*, int, sqlite3_int64);
SQLITE_API int SQLITE_STDCALL sqlite3_bind_null(sqlite3_stmt*, int);
SQLITE_API int SQLITE_STDCALL sqlite3_bind_text(sqlite3_stmt*,int,const char*,int,void(*)(void*));
SQLITE_API int SQLITE_STDCALL sqlite3_bind_text16(sqlite3_stmt*, int, const void*, int, void(*)(void*));
SQLITE_API int SQLITE_STDCALL sqlite3_bind_text64(sqlite3_stmt*, int, const char*, sqlite3_uint64,void(*)(void*), unsigned char encoding);
SQLITE_API int SQLITE_STDCALL sqlite3_bind_value(sqlite3_stmt*, int, const sqlite3_value*);
SQLITE_API int SQLITE_STDCALL sqlite3_bind_zeroblob(sqlite3_stmt*, int, int n);
</code></pre>

<p>上面列出了所有支持绑定类型的函数。</p>

<blockquote><p>结束</p>

<p>本篇只是列出了SQLite常用的基础方法，实际开发中数据库可能要比这复杂许多，而且还要考虑数据竞争线程安全的问题。具体还是要自己在开发中实践。</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Socketudp]]></title>
    <link href="http://al1020119.github.io/blog/2016/06/22/socketudp/"/>
    <updated>2016-06-22T00:00:00+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/06/22/socketudp</id>
    <content type="html"><![CDATA[<hr />

<p>layout: post
title: &ldquo;Socket编程-UDP篇&rdquo;
date: 2016-06-22 13:53:19 +0800
comments: true
categories: Senior
description: iCocos博客
keywords: iCocos, iOS开发, 博客, 技术分析, 文章, 学习, 曹黎, 曹理鹏</p>

<hr />

<h3>1. UDP Socket编程</h3>

<p>先讲一讲UDP编程，因为比TCP要简单多了。首先，我们需要明白UDP是用户数据报协议，英文名为User Datagram Protocol，它是面向无连接的。</p>

<p>注意：Socket通信一定有要服务端和客户端。</p>

<h4>1.1 UDP Socket客户端</h4>

<p>客户端的工作流程：首先调用socket函数创建一个Socket，然后指定服务端的IP地址和端口号，就可以调用sendto将字符串传送给服务器端，并可以调用recvfrom接收服务器端返回的字符串，最后关闭该socket。</p>

<p>笔者这里分成了四步：</p>

<pre><code>第一步：创建socket并配置socket，如服务端ip地址和端口号
第二步：调用sendto发送消息到服务器端
第三步：调用recvfrom接收来自服务器端的消息
第四步：调用close关闭socket
</code></pre>

<h4>1.1.1 客户端的代码实现：</h4>

<pre><code>- (void)udpClient {
  int clientSocketId;
  ssize_t len;
  socklen_t addrlen;
  struct sockaddr_in client_sockaddr;
  char buffer[256] = "Hello, server, how are you?";

  // 第一步：创建Socket
  clientSocketId = socket(AF_INET, SOCK_DGRAM, 0);
  if(clientSocketId &lt; 0) {
    NSLog(@"creat client socket fail\n");
    return;
  }

  addrlen = sizeof(struct sockaddr_in);
  bzero(&amp;client_sockaddr, addrlen);
  client_sockaddr.sin_family = AF_INET;
  client_sockaddr.sin_addr.s_addr = inet_addr("192.168.1.107");
  client_sockaddr.sin_port = htons(1024);

  int count = 10;
  do {
    bzero(buffer, sizeof(buffer));
    sprintf(buffer, "%s", "Hello, server, how are you?");

    // 第二步：发送消息到服务端
    // 注意:UDP是面向无连接的，因此不用调用connect()
    // 将字符串传送给server端
   len = sendto(clientSocketId, buffer, sizeof(buffer), 0, (struct sockaddr *)&amp;client_sockaddr, addrlen);

    if (len &gt; 0) {
      NSLog(@"发送成功");
    } else {
      NSLog(@"发送失败");
    }

    // 第三步：接收来自服务端返回的消息
    // 接收server端返回的字符串
    bzero(buffer, sizeof(buffer));
    len = recvfrom(clientSocketId, buffer, sizeof(buffer), 0, (struct sockaddr *)&amp;client_sockaddr, &amp;addrlen);
    NSLog(@"receive message from server: %s", buffer);

    count--;
  } while (count &gt;= 0);

  // 第四步：关闭socket
  // 由于是面向无连接的，消息发出处就可以了，不用管它收不收得到，发完就可以关闭了
  close(clientSocketId);
}
</code></pre>

<h4>1.1.2 客户端的打印日志</h4>

<pre><code>2015-12-06 15:38:36.095 iOS-Socket-C-Version-Client[9709:4234848] 发送成功
2015-12-06 15:38:36.286 iOS-Socket-C-Version-Client[9709:4234848] receive message from server: Hello, server, how are you?
2015-12-06 15:38:36.286 iOS-Socket-C-Version-Client[9709:4234848] 发送成功
2015-12-06 15:38:36.291 iOS-Socket-C-Version-Client[9709:4234848] receive message from server: Hello, server, how are you?
2015-12-06 15:38:36.291 iOS-Socket-C-Version-Client[9709:4234848] 发送成功
2015-12-06 15:38:36.296 iOS-Socket-C-Version-Client[9709:4234848] receive message from server: Hello, server, how are you?
2015-12-06 15:38:36.296 iOS-Socket-C-Version-Client[9709:4234848] 发送成功
2015-12-06 15:38:36.316 iOS-Socket-C-Version-Client[9709:4234848] receive message from server: Hello, server, how are you?
2015-12-06 15:38:36.317 iOS-Socket-C-Version-Client[9709:4234848] 发送成功
2015-12-06 15:38:36.324 iOS-Socket-C-Version-Client[9709:4234848] receive message from server: Hello, server, how are you?
2015-12-06 15:38:36.324 iOS-Socket-C-Version-Client[9709:4234848] 发送成功
2015-12-06 15:38:36.328 iOS-Socket-C-Version-Client[9709:4234848] receive message from server: Hello, server, how are you?
2015-12-06 15:38:36.329 iOS-Socket-C-Version-Client[9709:4234848] 发送成功
2015-12-06 15:38:36.339 iOS-Socket-C-Version-Client[9709:4234848] receive message from server: Hello, server, how are you?
2015-12-06 15:38:36.339 iOS-Socket-C-Version-Client[9709:4234848] 发送成功
2015-12-06 15:38:36.355 iOS-Socket-C-Version-Client[9709:4234848] receive message from server: Hello, server, how are you?
2015-12-06 15:38:36.356 iOS-Socket-C-Version-Client[9709:4234848] 发送成功
2015-12-06 15:38:36.366 iOS-Socket-C-Version-Client[9709:4234848] receive message from server: Hello, server, how are you?
2015-12-06 15:38:36.366 iOS-Socket-C-Version-Client[9709:4234848] 发送成功
2015-12-06 15:38:36.372 iOS-Socket-C-Version-Client[9709:4234848] receive message from server: Hello, server, how are you?
2015-12-06 15:38:36.373 iOS-Socket-C-Version-Client[9709:4234848] 发送成功
2015-12-06 15:38:36.392 iOS-Socket-C-Version-Client[9709:4234848] receive message from server: Hello, server, how are you?
</code></pre>

<h4>1.2 UDP Socket服务器端</h4>

<p>服务器端的工作流程：首先调用socket函数创建一个套接字，然后调用bind函数将其与本机地址以及一个本地端口号绑定，接收到一个客户端时，服务器显示该客户端的IP地址，并将字串返回给客户端。</p>

<p>笔者这里分成了五步：</p>

<pre><code>第一步：创建socket并配置socket
第二步：调用bind绑定服务器本机ip及端口号
第三步：调用recvfrom接收来自客户端的消息
第四步：调用sendto将接收到服务器端的信息返回给客户端
第四步：调用close关闭socket
</code></pre>

<h4>1.2.1 服务器端代码实现</h4>

<pre><code>- (void)udpServer {
  int serverSockerId = -1;
  ssize_t len = -1;
  socklen_t addrlen;
  char buff[1024];
  struct sockaddr_in ser_addr;

  // 第一步：创建socket
  // 注意，第二个参数是SOCK_DGRAM，因为udp是数据报格式的
  serverSockerId = socket(AF_INET, SOCK_DGRAM, 0);

  if(serverSockerId &lt; 0) {
    NSLog(@"Create server socket fail");
    return;
  }

  addrlen = sizeof(struct sockaddr_in);
  bzero(&amp;ser_addr, addrlen);

  ser_addr.sin_family = AF_INET;
  ser_addr.sin_addr.s_addr = htonl(INADDR_ANY);
  ser_addr.sin_port = htons(1024);

  // 第二步：绑定端口号
  if(bind(serverSockerId, (struct sockaddr *)&amp;ser_addr, addrlen) &lt; 0) {
    NSLog(@"server connect socket fail");
    return;
  }

  do {
    bzero(buff, sizeof(buff));

    // 第三步：接收客户端的消息
    len = recvfrom(serverSockerId, buff, sizeof(buff), 0, (struct sockaddr *)&amp;ser_addr, &amp;addrlen);
    // 显示client端的网络地址
    NSLog(@"receive from %s\n", inet_ntoa(ser_addr.sin_addr));
    // 显示客户端发来的字符串
    NSLog(@"recevce:%s", buff);

    // 第四步：将接收到的客户端发来的消息，发回客户端
    // 将字串返回给client端
    sendto(serverSockerId, buff, len, 0, (struct sockaddr *)&amp;ser_addr, addrlen);
  } while (strcmp(buff, "exit") != 0);

  // 第五步：关闭socket
  close(serverSockerId);
}
</code></pre>

<h4>1.2.2 服务器端的打印日志</h4>

<pre><code>2015-12-06 15:38:36.268 iOS-Socket-C-Version-Server[39130:2473780] receive from 192.168.1.100
2015-12-06 15:38:36.269 iOS-Socket-C-Version-Server[39130:2473780] recevce:Hello, server, how are you?
2015-12-06 15:38:36.372 iOS-Socket-C-Version-Server[39130:2473780] receive from 192.168.1.100
2015-12-06 15:38:36.372 iOS-Socket-C-Version-Server[39130:2473780] recevce:Hello, server, how are you?
2015-12-06 15:38:36.377 iOS-Socket-C-Version-Server[39130:2473780] receive from 192.168.1.100
2015-12-06 15:38:36.377 iOS-Socket-C-Version-Server[39130:2473780] recevce:Hello, server, how are you?
2015-12-06 15:38:36.382 iOS-Socket-C-Version-Server[39130:2473780] receive from 192.168.1.100
2015-12-06 15:38:36.382 iOS-Socket-C-Version-Server[39130:2473780] recevce:Hello, server, how are you?
2015-12-06 15:38:36.405 iOS-Socket-C-Version-Server[39130:2473780] receive from 192.168.1.100
2015-12-06 15:38:36.405 iOS-Socket-C-Version-Server[39130:2473780] recevce:Hello, server, how are you?
2015-12-06 15:38:36.409 iOS-Socket-C-Version-Server[39130:2473780] receive from 192.168.1.100
2015-12-06 15:38:36.410 iOS-Socket-C-Version-Server[39130:2473780] recevce:Hello, server, how are you?
2015-12-06 15:38:36.414 iOS-Socket-C-Version-Server[39130:2473780] receive from 192.168.1.100
2015-12-06 15:38:36.415 iOS-Socket-C-Version-Server[39130:2473780] recevce:Hello, server, how are you?
2015-12-06 15:38:36.425 iOS-Socket-C-Version-Server[39130:2473780] receive from 192.168.1.100
2015-12-06 15:38:36.426 iOS-Socket-C-Version-Server[39130:2473780] recevce:Hello, server, how are you?
2015-12-06 15:38:36.441 iOS-Socket-C-Version-Server[39130:2473780] receive from 192.168.1.100
2015-12-06 15:38:36.441 iOS-Socket-C-Version-Server[39130:2473780] recevce:Hello, server, how are you?
2015-12-06 15:38:36.452 iOS-Socket-C-Version-Server[39130:2473780] receive from 192.168.1.100
2015-12-06 15:38:36.452 iOS-Socket-C-Version-Server[39130:2473780] recevce:Hello, server, how are you?
2015-12-06 15:38:36.472 iOS-Socket-C-Version-Server[39130:2473780] receive from 192.168.1.100
2015-12-06 15:38:36.473 iOS-Socket-C-Version-Server[39130:2473780] recevce:Hello, server, how are you?
</code></pre>

<p>我们这里打印出了客户端发来的消息，由于上面实现的代码中，只发10次，所以这里只有10条。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cockettcp]]></title>
    <link href="http://al1020119.github.io/blog/2016/06/21/cockettcp/"/>
    <updated>2016-06-21T00:00:00+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/06/21/cockettcp</id>
    <content type="html"><![CDATA[<hr />

<p>layout: post
title: &ldquo;Socket编程-TCP篇&rdquo;
date: 2016-06-21 13:53:19 +0800
comments: true
categories: Senior
description: iCocos博客
keywords: iCocos, iOS开发, 博客, 技术分析, 文章, 学习, 曹黎, 曹理鹏</p>

<hr />

<h3>1. TCP Socket编程</h3>

<p>TCP是面向连接的，安全可靠的传输层协议。TCP的程序基本框架设计图：</p>

<p>image</p>

<p>注意：Socket通信一定有要服务端和客户端。</p>

<h4>1.1 TCP Socket客户端</h4>

<p>客户端的工作流程：首先调用socket函数创建一个Socket，然后指定服务端的IP地址和端口号，就可以调用sendto将字符串传送给服务器端，并可以调用recvfrom接收服务器端返回的字符串，最后关闭该socket。</p>

<p>笔者这里分成了六步：</p>

<pre><code>第一步：创建socket并配置socket
第二步：调用bind绑定监听ip和端口号
第三步：调用connect连接服务器
第四步：调用getsockname获取套接字信息
第五步：调用send发送消息到服务器端
第六步：调用close关闭socket
</code></pre>

<p>这里没有写接收来自服务器端的消息，大家可以自行添加。</p>

<h4>1.1.1 客户端的代码实现：</h4>

<pre><code>- (void)tcpClient {
  // 第一步：创建soket
  // TCP是基于数据流的，因此参数二使用SOCK_STREAM
  int error = -1;
  int clientSocketId = socket(AF_INET, SOCK_STREAM, 0);
  BOOL success = (clientSocketId != -1);
  struct sockaddr_in addr;

  // 第二步：绑定端口号
  if (success) {
    NSLog(@"client socket create success");
    // 初始化
    memset(&amp;addr, 0, sizeof(addr));
    addr.sin_len = sizeof(addr);

    // 指定协议簇为AF_INET，比如TCP/UDP等
    addr.sin_family = AF_INET;

    // 监听任何ip地址
    addr.sin_addr.s_addr = INADDR_ANY;
    error = bind(clientSocketId, (const struct sockaddr *)&amp;addr, sizeof(addr));
    success = (error == 0);
  }

  if (success) {
    // p2p
    struct sockaddr_in peerAddr;
    memset(&amp;peerAddr, 0, sizeof(peerAddr));
    peerAddr.sin_len = sizeof(peerAddr);
    peerAddr.sin_family = AF_INET;
    peerAddr.sin_port = htons(1024);

    // 指定服务端的ip地址，测试时，修改成对应自己服务器的ip
    peerAddr.sin_addr.s_addr = inet_addr("192.168.1.107");

    socklen_t addrLen;
    addrLen = sizeof(peerAddr);
    NSLog(@"will be connecting");

    // 第三步：连接服务器
    error = connect(clientSocketId, (struct sockaddr *)&amp;peerAddr, addrLen);
    success = (error == 0);

    if (success) {
      // 第四步：获取套接字信息
      error = getsockname(clientSocketId, (struct sockaddr *)&amp;addr, &amp;addrLen);
      success = (error == 0);

      if (success) {
        NSLog(@"client connect success, local address:%s,port:%d",
              inet_ntoa(addr.sin_addr),
              ntohs(addr.sin_port));

        // 这里只发送10次
        int count = 10;
        do {
          // 第五步：发送消息到服务端
          send(clientSocketId, "哈哈，server您好！", 1024, 0);
          count--;

          // 告诉server，客户端退出了
          if (count == 0) {
            send(clientSocketId, "exit", 1024, 0);
          }
        } while (count &gt;= 1);

        // 第六步：关闭套接字
        close(clientSocketId);
      }
    } else {
      NSLog(@"connect failed");

      // 第六步：关闭套接字
      close(clientSocketId);
    }
  }
}
</code></pre>

<h4>1.1.2 客户端的打印日志</h4>

<pre><code>2015-12-06 18:35:00.385 iOS-Socket-C-Version-Client[9726:4256295] client socket create success
2015-12-06 18:35:00.386 iOS-Socket-C-Version-Client[9726:4256295] will be connecting
2015-12-06 18:35:00.507 iOS-Socket-C-Version-Client[9726:4256295] client connect success, local address:192.168.1.100,port:50311
</code></pre>

<p>说明连接服务器成功，然后发送了消息到服务器端。
1.2 TCP Socket服务器端</p>

<p>服务器端的工作流程：首先调用socket函数创建一个套接字，然后调用bind函数将其与本机地址以及一个本地端口号绑定，接收到一个客户端时，服务器显示该客户端的IP地址，并将字串返回给客户端。</p>

<p>笔者这里分成了五步：</p>

<pre><code>第一步：创建socket并配置socket
第二步：调用bind绑定服务器本机ip及端口号
第三步：调用listen监听客户端的连接，并指定同时最多可让accept的数量
第四步：调用accept等待客户端的连接
第五步：调用recvfrom接收来自客户端的消息
第六步：调用close关闭socket
</code></pre>

<h4>1.2.1 服务器端代码实现</h4>

<pre><code>- (void)tcpServer {
  // 第一步：创建socket
  int error = -1;

  // 创建socket套接字
  int serverSocketId = socket(AF_INET, SOCK_STREAM, 0);
  // 判断创建socket是否成功
  BOOL success = (serverSocketId != -1);

  // 第二步：绑定端口号
  if (success) {
    NSLog(@"server socket create success");
    // Socket address
    struct sockaddr_in addr;

    // 初始化全置为0
    memset(&amp;addr, 0, sizeof(addr));

    // 指定socket地址长度
    addr.sin_len = sizeof(addr);

    // 指定网络协议，比如这里使用的是TCP/UDP则指定为AF_INET
    addr.sin_family = AF_INET;

    // 指定端口号
    addr.sin_port = htons(1024);

    // 指定监听的ip，指定为INADDR_ANY时，表示监听所有的ip
    addr.sin_addr.s_addr = INADDR_ANY;

    // 绑定套接字
    error = bind(serverSocketId, (const struct sockaddr *)&amp;addr, sizeof(addr));
    success = (error == 0);
  }

  // 第三步：监听
  if (success) {
    NSLog(@"bind server socket success");
    error = listen(serverSocketId, 5);
    success = (error == 0);
  }

  if (success) {
    NSLog(@"listen server socket success");

    while (true) {
      // p2p
      struct sockaddr_in peerAddr;
      int peerSocketId;
      socklen_t addrLen = sizeof(peerAddr);

      // 第四步：等待客户端连接
      // 服务器端等待从编号为serverSocketId的Socket上接收客户连接请求
      peerSocketId = accept(serverSocketId, (struct sockaddr *)&amp;peerAddr, &amp;addrLen);
      success = (peerSocketId != -1);

      if (success) {
        NSLog(@"accept server socket success,remote address:%s,port:%d",
              inet_ntoa(peerAddr.sin_addr),
              ntohs(peerAddr.sin_port));
        char buf[1024];
        size_t len = sizeof(buf);

        // 第五步：接收来自客户端的信息
        // 当客户端输入exit时才退出
        do {
          // 接收来自客户端的信息
          recv(peerSocketId, buf, len, 0);
          if (strlen(buf) != 0) {
            NSString *str = [NSString stringWithCString:buf encoding:NSUTF8StringEncoding];
            if (str.length &gt;= 1) {
              NSLog(@"received message from client：%@",str);
            }
          }
        } while (strcmp(buf, "exit") != 0);

        NSLog(@"收到exit信号，本次socket通信完毕");

        // 第六步：关闭socket
        close(peerSocketId);
      }
    }
  }
}
</code></pre>

<h4>1.2.2 服务器端的打印日志</h4>

<pre><code>2015-12-06 18:34:31.258 iOS-Socket-C-Version-Server[39929:2622200] server socket create success
2015-12-06 18:34:31.258 iOS-Socket-C-Version-Server[39929:2622200] bind server socket success
2015-12-06 18:34:31.259 iOS-Socket-C-Version-Server[39929:2622200] listen server socket success
2015-12-06 18:35:00.743 iOS-Socket-C-Version-Server[39929:2622200] accept server socket success,remote address:192.168.1.100,port:50311
2015-12-06 18:35:00.743 iOS-Socket-C-Version-Server[39929:2622200] received message from client：哈哈，server您好！
2015-12-06 18:35:00.743 iOS-Socket-C-Version-Server[39929:2622200] received message from client：哈哈，server您好！
2015-12-06 18:35:00.743 iOS-Socket-C-Version-Server[39929:2622200] received message from client：哈哈，server您好！
2015-12-06 18:35:00.744 iOS-Socket-C-Version-Server[39929:2622200] received message from client：哈哈，server您好！
2015-12-06 18:35:00.744 iOS-Socket-C-Version-Server[39929:2622200] received message from client：哈哈，server您好！
2015-12-06 18:35:00.744 iOS-Socket-C-Version-Server[39929:2622200] received message from client：哈哈，server您好！
2015-12-06 18:35:00.744 iOS-Socket-C-Version-Server[39929:2622200] received message from client：哈哈，server您好！
2015-12-06 18:35:00.744 iOS-Socket-C-Version-Server[39929:2622200] received message from client：哈哈，server您好！
2015-12-06 18:35:00.744 iOS-Socket-C-Version-Server[39929:2622200] received message from client：哈哈，server您好！
2015-12-06 18:35:00.745 iOS-Socket-C-Version-Server[39929:2622200] received message from client：哈哈，server您好！
2015-12-06 18:35:00.745 iOS-Socket-C-Version-Server[39929:2622200] received message from client：exit
2015-12-06 18:35:00.745 iOS-Socket-C-Version-Server[39929:2622200] 收到exit信号，本次socket通信完毕
</code></pre>

<p>我们这里打印出了客户端发来的消息，由于上面实现的代码中，只发10次，所以这里只有10条。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cocketjichu]]></title>
    <link href="http://al1020119.github.io/blog/2016/06/20/cocketjichu/"/>
    <updated>2016-06-20T00:00:00+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/06/20/cocketjichu</id>
    <content type="html"><![CDATA[<hr />

<p>layout: post
title: &ldquo;Socket编程-精华篇&rdquo;
date: 2016-06-20 13:53:19 +0800
comments: true
categories: Senior
description: iCocos博客
keywords: iCocos, iOS开发, 博客, 技术分析, 文章, 学习, 曹黎, 曹理鹏</p>

<hr />

<p>本序列文章关于Socket编程，摘自<a href="http://www.huangyibiao.com/">大神标哥</a>的精华</p>

<h2>序言</h2>

<p>网络七层由下往上分别为物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。 其中物理层、数据链路层和网络层通常被称作媒体层，是网络工程师所研究的对象； 传输层、会话层、表示层和应用层则被称作主机层，是用户所面向和关心的内容。</p>

<pre><code>http协议对应于应用层
tcp/udp协议对应于传输层
ip协议对应于网络层
</code></pre>

<!--more-->


<p>三者本质上没有可比性。何况HTTP协议是基于TCP连接的。TCP/IP是传输层协议，主要解决数据如何在网络中传输；而HTTP是应用层协议，主要解决如何包装数据。我们在传输数据时，可以只使用传输层（TCP/IP），但是那样的话，由于没有应用层，便无法识别数据内容，如果想要使传输的数据有意义，则必须使用应用层协议，应用层协议很多，有HTTP、FTP、TELNET等等，也可以自己定义应用层协议。WEB使用HTTP作传输层协议，以封装HTTP文本信息，然后使用TCP/IP做传输层协议将它发送到网络上。Socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口（API），通过Socket，我们才能使用TCP/IP协议。</p>

<h4>什么是Socket?</h4>

<p>Socket又称之为“套接字”，是系统提供的用于网络通信的方法。它的实质并不是一种协议，没有规定计算机应当怎么样传递消息，只是给程序员提供了一个发送消息的接口，程序员使用这个接口提供的方法，发送与接收消息。</p>

<p>Socket描述了一个IP、端口对。它简化了程序员的操作，知道对方的IP以及PORT就可以给对方发送消息，再由服务器端来处理发送的这些消息。所以，Socket一定包含了通信的双方，即客户端（Client）与服务端（server）。</p>

<h4>TCP</h4>

<p>TCP是面向连接的、传输可靠(保证数据正确性且保证数据顺序)、用于传输大量数据(流模式)、速度慢，建立连接需要开销较多(时间，系统资源)。</p>

<p>TCP是一种流模式的协议，是面向连接的，也就是说，在连接持续的过程中，socket中收到的数据都是由同一台主机发出的（劫持什么的不考虑），因此，知道保证数据是有序的到达就行了，至于每次读取多少数据不关心。</p>

<h4>TCP三次握手</h4>

<p>所谓三次握手(Three-way Handshake)，是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。三次握手的目的是连接服务器指定端口，建立TCP连接,并同步连接双方的序列号和确认号并交换TCP窗口大小信息。在socket编程中，客户端执行connect()时，将触发三次握手（图片来源于网络）：</p>

<p><img src="http://al1020119.github.io/images/socket0001.png" title="Caption" >
SYN（synchronous）是同步标志；ACK (Acknowledgement）是确认标志，seq是序列号。</p>

<pre><code>第一次握手：客户端发送一个TCP的SYN标志位置1的包，指明客户打算连接的服务器的端口，以及初始序号X,保存在包头的序列号字段里。
第二次握手：服务器发回确认包(ACK)应答。即SYN标志位和ACK标志位均为1同时，将确认序号设置为客户的序列号加1以，即X+1。
第三次握手：客户端再次发送确认包(ACK) SYN标志位为0，ACK标志位为1。并且把服务器发来ACK的序号字段+1，放在确定字段中发送给对方.并且在数据段放写序列号的+1。
</code></pre>

<p>关于三次握手，知乎上有个段子我觉得挺好的。</p>

<p>「喂喂喂，能听到吗？」
「没问题。能听到就回一声。」
「没问题。」</p>

<h4>TCP四次挥手</h4>

<p>四次挥手的流程：</p>

<p><img src="http://al1020119.github.io/images/socket0002.png" title="Caption" ></p>

<p>当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。
TCP客户端-服务器程序设计基本框架</p>

<p><img src="http://al1020119.github.io/images/socket0003.png" title="Caption" ></p>

<h4>UDP</h4>

<p>UDP是面向无连接、传输不可靠、用于传输少量数据(数据包模式)、速度快的传输层协议。注意，UDP传输的是数据报包，而TCP是流。</p>

<p>UDP是面向无连接的协议，只要知道接收端的IP和端口，且网络是可达的，任何主机都可以向接收端发送数据。这时候，如果一次能读取超过一个报文的数据，则会乱套。比如，主机A向发送了报文P1，主机B发送了报文P2，如果能够读取超过一个报文的数据，那么就会将P1和P2的数据合并在了一起，这样的数据是没有意义的。
UDP客户端-服务端程序设计基本框架</p>

<p><img src="http://al1020119.github.io/images/socket0004.png" title="Caption" >
Socket的通信过程</p>

<p>每一个应用或者说服务都有一个端口。比如DNS的端口号53，http的端口号80都是对应一个应用或者服务的端口。我们能由DNS请求到查询信息，是因为DNS服务器时时刻刻都在监听53端口，当收到我们的查询请求以后，就能够返回我们想要的IP信息。所以，从程序设计上来讲，应该包含以下步骤：</p>

<pre><code>服务端利用Socket监听端口；
客户端发起连接；
服务端返回信息，建立连接，开始通信；
客户端，服务端断开连接。
</code></pre>

<h4>Socket原理</h4>

<p>套接字（socket）是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元。它是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息：连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口。</p>

<p>应用层通过传输层进行数据通信时，TCP会遇到同时为多个应用程序进程提供并发服务的问题。多个TCP连接或多个应用程序进程可能需要通过同一个 TCP协议端口传输数据。为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与TCP／IP协议交互提供了套接字(Socket)接口。应用层可以和传输层通过Socket接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。</p>

<h4>Socket连接</h4>

<p>建立Socket连接至少需要一对套接字，其中一个运行于客户端，称为ClientSocket，另一个运行于服务器端，称为ServerSocket。</p>

<p>套接字之间的连接过程分为三个步骤：</p>

<pre><code>服务器监听：服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求
客户端请求：指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求
连接确认：当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户端，一旦客户端确认了此描述，双方就正式建立连接。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求
</code></pre>
]]></content>
  </entry>
  
</feed>
