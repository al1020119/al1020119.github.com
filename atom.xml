<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[iOS梦工厂]]></title>
  <link href="http://al1020119.github.io/atom.xml" rel="self"/>
  <link href="http://al1020119.github.io/"/>
  <updated>2015-12-08T01:03:25+08:00</updated>
  <id>http://al1020119.github.io/</id>
  <author>
    <name><![CDATA[iCocos]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS9+Xcode总结]]></title>
    <link href="http://al1020119.github.io/blog/2015/12/14/ios9-plus-xcodezong-jie/"/>
    <updated>2015-12-14T23:56:09+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/12/14/ios9-plus-xcodezong-jie</id>
    <content type="html"><![CDATA[<p>刚更新了Xcode 9 beat 2，运行了之前的工程，发现了一些问题，就针对性的做了一下iOS9的适配。</p>

<h4>1，默认使用HTTPS请求</h4>

<p>如果在Xcode 9之前使用的时http请求，那么在XCode 9上编译的App是不能联网的，会提示如下错误:</p>

<pre><code>App Transport Security has blocked a cleartext HTTP (http://) resource load since it is insecure. Temporary exceptions can be configured via your app's Info.plist file.
</code></pre>

<p>修改方法是要么使服务器支持https访问，要么关闭https的使用。第一种方法对于个人开发者来说代价还是比较大的，因此推荐使用后面一种方法，具体的做法是:在工程的Info.plist文件里添加NSAppTransportSecurity字典类型的，添加一个元素：key为NSAllowsArbitraryLoads，值为YES。</p>

<h4>2，iOS 9使用URL scheme必须将其加入白名单</h4>

<p>否则会提示类似如下错误:</p>

<!--more-->


<pre><code>    canOpenURL: failed for URL: "mqqopensdkapiV2://qqapp" - error: "This app is not allowed to query for scheme mqqopensdkapiV2”
</code></pre>

<p>修正方法是，Info.plist文件中添加一个key为LSApplicationQueriesSchemes的数组值，里面包含需要添加白名单的string类型的scheme。特酷吧在项目中使用了qq，微信等分享登录功能，需要添加的值为：</p>

<ul>
<li>mqqopensdkapiV2</li>
<li>mqqOpensdkSSoLogin</li>
<li>mqq</li>
<li>mqzoneopensdkapiV2</li>
<li>mqzoneopensdkapi19</li>
<li>mqzoneopensdkapi</li>
<li>mqzoneopensdk</li>
<li>mqzone</li>
<li>weixin</li>
<li>wechat
更多其他适配点后续不断跟进。</li>
</ul>


<h4>3，bitcode</h4>

<p>使用Xcode7编译提示：</p>

<pre><code>XXX does not contain bitcode. You must rebuild it with bitcode enabled (Xcode setting ENABLE_BITCODE), obtain an updated library from the vendor, or disable bitcode for this target. for architecture arm64
</code></pre>

<p>bitcode是被编译程序的一种中间形式的代码。包含bitcode配置的程序将会在App store上被编译和链接。bitcode允许苹果在后期重新优化我们程序的二进制文件，而不需要我们重新提交一个新的版本到App store上。
Xcode7 默认开启了bitcode，如果App使用的第三方类库不支持bitcode会提示错误，只需要在”Build Settings”->”Enable Bitcode”选项中看关闭bitcode即可。</p>

<blockquote><p>开启Bitcode编译后，编译产生的文件体积会变大 (因为是中间代码，不是用户下载的包)，且dSYM文件不能用来崩溃日志的符号化 (用户下载的包是Apple服务重新编译产生的，有产生新的符号文件)。通过Archive方式上传AppStore的包，可以在 Xcode的Organizer工具中下载对应安装包的新的符号文件。
转载请注明来自特酷吧,本文地址:www.tekuba.net/program/364/
 
 </p>

<h4>4，使用XCode7链接第三方库提示warning</h4>

<pre><code>Lots of warnings when building with Xcode 7 with 3rd party libraries
warning: Could not resolve external type c:objc(cs)NSString
warning: Could not resolve external type c:objc(cs)NSDictionary
warning: Could not resolve external type c:objc(cs)NSMutableString
warning: Could not resolve external type c:objc(cs)NSError
</code></pre>

<p><a href="https://forums.developer.apple.com/thread/17921">https://forums.developer.apple.com/thread/17921</a>
目前没发现好的解决办法，可以尝试如下:
I had this problem too.  Here&rsquo;s how I fixed it.</p></blockquote>

<ul>
<li>1)  Go to Build Settings -> Build Options -> Debug Information Format</li>
<li>2)  Change the Debug setting from &ldquo;DWARF with dSYM File&rdquo; to &ldquo;DWARF&rdquo;</li>
<li>3)  Leave the Release setting at &ldquo;DWARF with dSYM File&rdquo;</li>
</ul>


<p>The problem appears to be that Xcode was trying to create dSYM files for Debug builds.  You don&rsquo;t need dSYM files for Debug builds &ndash; it&rsquo;s release builds where you need them. </p>

<hr />

<h6>既然提到了Xcode7，那么Xcode7中也有几个需要注意的地方（Xcode7是随着ios9一起出来的，其实也就是ios9的新特性，只是不是sdk），</h6>

<p>升级到XCode7之后，编译和上传到itunes connect中遇到了一些问题（特酷吧XCode版本7.0.1），在这里总结下：</p>

<h4>1，was built for newer iOS version (9.0) than being linked (7.0)</h4>

<p>解决方法参考：<a href="http://qaseeker.com/32270491-xcode-7-warning-was-built-for-newer-ios-version-5-1-1-than-being-linked-5-1/">http://qaseeker.com/32270491-xcode-7-warning-was-built-for-newer-ios-version-5-1-1-than-being-linked-5-1/</a></p>

<pre><code>the -w flag can be added to Build Settings -&gt; Other Linker Flags
</code></pre>

<h4>2，Could not resolve external type c:objc(cs)</h4>

<p>解决方法参考：</p>

<pre><code>https://community.pushwoosh.com/questions/2774/lot-of-warnings-with-xcode-70-and-pushwoosh-304
</code></pre>

<p>It looks like a bug of XCode 7. See the discussion here:</p>

<pre><code>https://forums.developer.apple.com/thread/17921
</code></pre>

<hr />

<pre><code>To get rid of this warning you need to change debug information from "DWARF + dSYM" to DWARF.
DWARF seems to be the default setting for new projects created in Xcode 7, but existing projects that are migrating to Xcode 7 probably still have DWARF with dSYM File as the setting.
</code></pre>

<p>特酷吧亲测发现使用XCode7新建工程的时候，Debug模式默认选择了DWARF。</p>

<h4>3，"The resulting API analysis file is too large. We were unable to validate your API usage prior to delivery</h4>

<p><a href="https://forums.developer.apple.com/thread/18493">https://forums.developer.apple.com/thread/18493</a>
建议处理</p>

<ul>
<li>1，export IPA file (after you select Archive from within xCode)</li>
<li>2，Use Application Loader to upload</li>
<li>3，de-select Bitcode and Symbols</li>
</ul>


<p>似乎目前对bitcode的支持还不是很好，建议关闭。再上传。</p>

<h4>4.最后就是和swift相关的。</h4>

<p>如果使用了混编技术，也就是说里面涉及到了swift代码，实现了桥接，那么系统会偶尔出现崩溃的现象，这个时候需要修改一个属性</p>

<ul>
<li>1：选中项目</li>
<li>2：选中target，在build Setting中搜索swift</li>
<li><p>3：在出现的embedded content contains swift code选中对应的值</p>

<ul>
<li>使用了swift就是YES</li>
<li>没有swift就是NO</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS9-WKWebView+SFSafariViewController]]></title>
    <link href="http://al1020119.github.io/blog/2015/12/14/ios9xin-te-xing-wkwebview/"/>
    <updated>2015-12-14T19:35:40+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/12/14/ios9xin-te-xing-wkwebview</id>
    <content type="html"><![CDATA[<h2>一：WKWebView简单介绍</h2>

<p>webkit使用WKWebView来代替IOS的UIWebView和OSX的WebView，并且使用Nitro JavaScript引擎，这意味着所有第三方浏览器运行JavaScript将会跟safari一样快。</p>

<p>先来看看WKWebView和UIWebView有什么区别：</p>

<h6>UIWebView：</h6>

<ul>
<li>始祖级别，支持的iOS版本比较多</li>
<li>可支持打开URL，包括各种URL模式，例如 Https，FTP等</li>
<li>可支持打开各种不同文件格式，例如 txt，docx，ppt,，音视频文件等，很多文档阅读器会经常使用这个特性，感兴趣的可以查一下Apple的文档，支持的格式还是挺多，只是不同iOS 版本的支持程度不太一样，使用时请多留意测试确认~</li>
<li>占用内存比较多，尤其是网页中包含比较多CSS+DIV之类内容时，很容易出现内存警告（Memory Warning）</li>
<li>效率低，不灵活，尤其是和 JavaScript交互时</li>
<li>无法清除本地存储数据（Local Storage）</li>
<li>代理（delegate）之间的回调比较麻烦，提供的内容比较低级，尤其是UI部分。如果想自己定制一个类似 Safari 的内嵌浏览器（Browser），那就坑爹无极限了，例如我们PDF Reader系列中的内嵌Browser，自己* 手动模拟实现Tab切换，底部Tool及各种Menu等，说多了都是泪~~</li>
</ul>


<h6>WKWebView：</h6>

<ul>
<li>iOS 8引入的，比较年轻</li>
<li>在内存和执行效率上要比UIWebView高很多</li>
<li>开放度较高但据说Bug成吨</li>
<li>类似UIWebView，UI定制比较麻烦···</li>
<li>没具体测试使用过，就不继续列举了 L~</li>
</ul>


<!--more-->


<h5>第一、WKWebView增加的属性和方法</h5>

<p>类比UIWebView，跟UIWebView的API对比，
增加的属性：</p>

<pre><code>* 1、estimatedProgress 加载进度条，在IOS8之前我们是通过一个假的进度条来实现
* 2、backForwardList 表示historyList
* 3、WKWebViewConfiguration *configuration; 初始化webview的配置
</code></pre>

<p>增加的方法：</p>

<pre><code>- (instancetype)initWithFrame:(CGRect)frame configuration:(WKWebViewConfiguration *)configuration 
</code></pre>

<p>初始化</p>

<pre><code>    - (WKNavigation *)goToBackForwardListItem:(WKBackForwardListItem *)item; 
</code></pre>

<p>跳到历史的某个页面</p>

<!--more-->


<h5>第二、相同的属性和方法</h5>

<ul>
<li>goBack、</li>
<li>goForward、</li>
<li>canGoBack、</li>
<li>canGoForward、</li>
<li>stopLoading、</li>
<li>loadRequest、</li>
<li>scrollView</li>
</ul>


<h5>第三、被删去的属性和方法：</h5>

<pre><code>- (NSString *)stringByEvaluatingJavaScriptFromString:(NSString *)script;
</code></pre>

<p>在跟js交互时，我们使用这个API，目前WKWebView完档没有给出实现类似功能的API</p>

<ul>
<li>无法设置缓存
在UIWebView，使用NSURLCache缓存，通过setSharedURLCache可以设置成我们自己的缓存，但WKWebView不支持NSURLCache

<h5>第四、delegate方法的不同</h5>

<p>UIWebView支持的代理是UIWebViewDelegate，WKWebView支持的代理是WKNavigationDelegate和
WKUIDelegate
WKNavigationDelegate主要实现了涉及到导航跳转方面的回调方法
WKUIDelegate主要实现了涉及到界面显示的回调方法：如WKWebView的改变和js相关内容
具体来说WKNavigationDelegate除了有开始加载、加载成功、加载失败的API外，还具有额外的三个代理方法：</p>

<pre><code>  -(void)webView:(WKWebView *)webView didReceiveServerRedirectForProvisionalNavigation:(WKNavigation *)navigation
</code></pre>

<p>这个代理是服务器redirect时调用</p>

<pre><code>  -(void)webView:(WKWebView *)webView decidePolicyForNavigationResponse:(WKNavigationResponse *)navigationResponse decisionHandler:(void (^)(WKNavigationResponsePolicy))decisionHandler
</code></pre>

<p>这个代理方法表示当客户端收到服务器的响应头，根据response相关信息，可以决定这次跳转是否可以继续进行。</p>

<pre><code>  -(void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler
</code></pre>

<p>根据webView、navigationAction相关信息决定这次跳转是否可以继续进行,这些信息包含HTTP发送请求，如头部包含User-Agent,Accept</p></li>
</ul>


<hr />

<h2>二、WKWebView新特性</h2>

<ul>
<li>在性能、稳定性、功能方面有很大提升（最直观的体现就是加载网页是占用的内存，模拟器加载百度与开源中国* 网站时，WKWebView占用23M，而UIWebView占用85M）；</li>
<li>允许JavaScript的Nitro库加载并使用（UIWebView中限制）；</li>
<li>支持了更多的HTML5特性；</li>
<li>高达60fps的滚动刷新率以及内置手势；</li>
<li>将UIWebViewDelegate与UIWebView重构成了14类与3个协议（查看苹果官方文档）；</li>
</ul>


<hr />

<h2>三：基本使用</h2>

<p>WKWebView相对于UIWebView强大了很多，内存的消耗相对少了，所提供的接口也丰富了。
现在谈一谈WKWebView的基本使用</p>

<h4>1. navigationDelegate</h4>

<pre><code>- (void)webView:(WKWebView *)webView didStartProvisionalNavigation:(WKNavigation *)navigation { // 类似UIWebView的 -webViewDidStartLoad:  
    NSLog(@"didStartProvisionalNavigation");  
    [UIApplication sharedApplication].networkActivityIndicatorVisible = YES;  
}  

- (void)webView:(WKWebView *)webView didCommitNavigation:(WKNavigation *)navigation {  
    NSLog(@"didCommitNavigation");  
}  

- (void)webView:(WKWebView *)webView didFinishNavigation:(WKNavigation *)navigation { // 类似 UIWebView 的 －webViewDidFinishLoad:  
    NSLog(@"didFinishNavigation");  
    [self resetControl];  
    if (webView.title.length &gt; 0) {  
        self.title = webView.title;  
    }  

}  
- (void)webView:(WKWebView *)webView didFailProvisionalNavigation:(WKNavigation *)navigation withError:(NSError *)error {  
    // 类似 UIWebView 的- webView:didFailLoadWithError:  

    NSLog(@"didFailProvisionalNavigation");  

}  
- (void)webView:(WKWebView *)webView decidePolicyForNavigationResponse:(WKNavigationResponse *)navigationResponse decisionHandler:(void (^)(WKNavigationResponsePolicy))decisionHandler {  

    decisionHandler(WKNavigationResponsePolicyAllow);  
}  


- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler {  
    // 类似 UIWebView 的 -webView: shouldStartLoadWithRequest: navigationType:  

    NSLog(@"4.%@",navigationAction.request);  


    NSString *url = [navigationAction.request.URL.absoluteString stringByReplacingPercentEscapesUsingEncoding:NSUTF8StringEncoding];  



    decisionHandler(WKNavigationActionPolicyAllow);  

}  
- (void)webView:(WKWebView *)webView didReceiveAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition, NSURLCredential *))completionHandler {  

}  
</code></pre>

<h4>2 UIDelegate</h4>

<pre><code>- (WKWebView *)webView:(WKWebView *)webView createWebViewWithConfiguration:(WKWebViewConfiguration *)configuration forNavigationAction:(WKNavigationAction *)navigationAction windowFeatures:(WKWindowFeatures *)windowFeatures {  
    // 接口的作用是打开新窗口委托  
    [self createNewWebViewWithURL:webView.URL.absoluteString config:configuration];  

    return currentSubView.webView;  
}  

- (void)webView:(WKWebView *)webView runJavaScriptAlertPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)())completionHandler  
{    // js 里面的alert实现，如果不实现，网页的alert函数无效  
    UIAlertController *alertController = [UIAlertController alertControllerWithTitle:message  
                                                                             message:nil  
                                                                      preferredStyle:UIAlertControllerStyleAlert];  
    [alertController addAction:[UIAlertAction actionWithTitle:@"确定"  
                                                        style:UIAlertActionStyleCancel  
                                                      handler:^(UIAlertAction *action) {  
                                                          completionHandler();  
                                                      }]];  

    [self presentViewController:alertController animated:YES completion:^{}];  

}  


- (void)webView:(WKWebView *)webView runJavaScriptConfirmPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(BOOL))completionHandler {  
    //  js 里面的alert实现，如果不实现，网页的alert函数无效  ,   

    UIAlertController *alertController = [UIAlertController alertControllerWithTitle:message  
                                                                             message:nil  
                                                                      preferredStyle:UIAlertControllerStyleAlert];  
    [alertController addAction:[UIAlertAction actionWithTitle:@"确定"  
                                                        style:UIAlertActionStyleDefault  
                                                      handler:^(UIAlertAction *action) {  
                                                          completionHandler(YES);  
                                                      }]];  
    [alertController addAction:[UIAlertAction actionWithTitle:@"取消"  
                                                        style:UIAlertActionStyleCancel  
                                                      handler:^(UIAlertAction *action){  
                                                          completionHandler(NO);  
                                                      }]];  

    [self presentViewController:alertController animated:YES completion:^{}];  

}  

- (void)webView:(WKWebView *)webView runJavaScriptTextInputPanelWithPrompt:(NSString *)prompt defaultText:(NSString *)defaultText initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(NSString *))completionHandler {  

    completionHandler(@"Client Not handler");  

}  
</code></pre>

<h4>3. WKWebView 执行脚本方法</h4>

<pre><code>- (void)evaluateJavaScript:(NSString *)javaScriptString completionHandler:(void (^)(id, NSError *))completionHandler;  

completionHandler 拥有两个参数，一个是返回错误，一个可以返回执行脚本后的返回值  
</code></pre>

<h4>4. WKWebView 的Cookie问题</h4>

<p>UIWebView 中会自动保存Cookie，如果登录了一次，下次再次进入的时候，会记住登录状态
而在WKWebView中，并不会这样，WKWebView在初始化的时候有一个方法</p>

<pre><code>- (instancetype)initWithFrame:(CGRect)frame configuration:(WKWebViewConfiguration *)configuration  
</code></pre>

<p>通过这个方法，设置 configuration 让WKWebView知道登录状态，configuration 可以通过已有的Cookie进行设置，也可以通过保存上一次的configuration进行设置</p>

<p>参考 stackoverflow上回答：</p>

<p><a href="http://stackoverflow.com/questions/26573137/can-i-set-the-cookies-to-be-used-by-a-wkwebview/26577303#26577303">http://stackoverflow.com/questions/26573137/can-i-set-the-cookies-to-be-used-by-a-wkwebview/26577303#26577303</a></p>

<pre><code>WKWebView * webView = /*set up your webView*/  
NSMutableURLRequest * request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"http://example.com/index.html"]];  
[request addValue:@"TeskCookieKey1=TeskCookieValue1;TeskCookieKey2=TeskCookieValue2;" forHTTPHeaderField:@"Cookie"];  
// use stringWithFormat: in the above line to inject your values programmatically  
[webView loadRequest:request];  

[objc] view plaincopyprint?在CODE上查看代码片派生到我的代码片
WKUserContentController* userContentController = WKUserContentController.new;  
WKUserScript * cookieScript = [[WKUserScript alloc]   
    initWithSource: @"document.cookie = 'TeskCookieKey1=TeskCookieValue1';document.cookie = 'TeskCookieKey2=TeskCookieValue2';"  
    injectionTime:WKUserScriptInjectionTimeAtDocumentStart forMainFrameOnly:NO];  
// again, use stringWithFormat: in the above line to inject your values programmatically  
[userContentController addUserScript:cookieScript];  
WKWebViewConfiguration* webViewConfig = WKWebViewConfiguration.new;  
webViewConfig.userContentController = userContentController;  
WKWebView * webView = [[WKWebView alloc] initWithFrame:CGRectMake(/*set your values*/) configuration:webViewConfig];  
</code></pre>

<hr />

<h2>四：WKWebView与js通信</h2>

<p>iOS 8 引入WKWebView, WKWebView 不支持JavaScriptCore的方式但提供message handler的方式为JavaScript 与Objective-C 通信.
在Objective-C 中使用WKWebView的以下方法调用JavaScript:</p>

<pre><code>- (void)evaluateJavaScript:(NSString *)javaScriptString
         completionHandler:(void (^)(id, NSError *))completionHandler
如果JavaScript 代码出错, 可以在completionHandler 进行处理.
在Objective-C 中注册 message handler:
// WKScriptMessageHandler protocol?

- (void)userContentController:(WKUserContentController *)userContentController
    didReceiveScriptMessage:(WKScriptMessage *)message
{
    NSLog(@"Message: %@", message.body);
}

[userContentController addScriptMessageHandler:handler name:@"myName"];
在JavaScript 将信息发给Objective-C:
// window.webkit.messageHandlers.&lt;name&gt;.postMessage();?

function postMyMessage()? {?
    var message = { 'message' : 'Hello, World!', 'numbers' : [ 1, 2, 3 ] };?
    window.webkit.messageHandlers.myName.postMessage(message);?
}
</code></pre>

<hr />

<h2>五：常见问题：</h2>

<p>32 位的app在使用WKWebView的时候，如果运行在64位的设备上，会出现一下问题：</p>

<ul>
<li>（1）iOS8.1 系统，部分网页加载白屏，例如 百度，iOS8.3 似乎没问题</li>
<li>（2）web输入框输入汉字也会出现白屏</li>
</ul>


<p>通过搜索得到问题根源：</p>

<blockquote><p>WKWebView&rsquo;s WebProcess runs out-of-process as a 64-bit process on hardware supporting 64bit. There is a 32bit/64bit marshalling IPC bug for 32 bit apps using the WKWebView client on such hardware. The bug causes the WebProcess to exit, leaving a blank screen.</p></blockquote>

<ul>
<li>也就是一个进程间通讯的bug引起的。</li>
</ul>


<h6>解决方案，可以使app支持arm64，便不会出现问题。</h6>

<hr />

<h2>六：SFSafariViewController：</h2>

<ul>
<li>iOS 9引入，更加年轻，意味着是Apple的新菜，总是有什么优势的</li>
<li>也是用来显示网页内容的</li>
<li>这是一个特殊的View Controller，而不是一个单独的 View，和前面两个的区别</li>
<li>在当前App中使用Safari的UI框架展现Web内容，包括相同的地址栏，工具栏等，类似一个内置于App的小型Safari</li>
<li>共享Safari的一些便利特性，包括：相似的用户体验，和Safari共享Cookie，iCloud Web表单数据，密码、证书自动填充，Safari阅读器（Safari Reader）</li>
<li>可定制性比较差，甚至连地址栏都是不可编辑的，只能在init的时候，传入一个URL来指定网页的地址</li>
<li>只能用来展示单个页面，并且有一个完成按钮用来退出</li>
</ul>


<p><img src="http://al1020119.github.io/images/safari001.png" title="Caption" ></p>

<p>如果你的App需要显示网页，但是又不想自己去定制浏览器界面的话，可以考虑用SFSafariViewController来试试。从好的方面看，SFSafariViewController也去掉了从App中跳转到Safari的撕裂感，不同App之间切换总是让人感觉麻烦和不舒服。</p>

<p>代码例子:</p>

<pre><code>- (IBAction)onButtonClick:(id)sender

{

    NSString *urlString = @"http://www.kdanmobile.com";

    SFSafariViewController *sfViewControllr = [[SFSafariViewController alloc] initWithURL:[NSURL URLWithString:urlString]];

    sfViewControllr.delegate = self;

    [self presentViewController:sfViewControllr animated:YES completion:^{

       //...

    }];

}



// Done 按钮

- (void)safariViewControllerDidFinish:(nonnull SFSafariViewController *)controller

{

    [controller dismissViewControllerAnimated:YES completion:nil];

}
</code></pre>

<p>SFSafariViewController 的接口比较少，就不再继续一一列举了。另外一个定制功能在于SFSafariViewControllerDelegate里面的一个方法：</p>

<pre><code>-(NSArray&lt;UIActivity *&gt; *)safariViewController:(SFSafariViewController *)controller activityItemsForURL:(NSURL *)URL title:(nullable NSString *)title;
</code></pre>

<p>这个代理会在用户点击动作（Action）按钮（底部工具栏中间的按钮）的时候调用，可以传入UIActivity的数组，创建添加一些自定义的各类插件式的服务，比如分享到微信，微博什么的。</p>

<p><img src="http://al1020119.github.io/images/safari001.png" title="Caption" ></p>

<blockquote><p>小细节：
SFSafariViewController有保存Cookies的功能，但是貌似不能和Safari浏览器共享，也可能是Beta版的bug</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS9-Unit Test]]></title>
    <link href="http://al1020119.github.io/blog/2015/12/14/ios9-unit-test/"/>
    <updated>2015-12-14T00:59:07+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/12/14/ios9-unit-test</id>
    <content type="html"><![CDATA[<p> XCode7(iOS9)中新增了跟多特性，包括：</p>

<ul>
<li>WKWebView+SFSafariViewController</li>
<li>UI Test</li>
<li>Multitasking</li>
<li>watchOS 2</li>
<li>Swift 2</li>
<li>App Thinning</li>
<li>人工智能和搜索 API</li>
<li>HomeKit，CloudKit，HealthKit 等等杂七杂八的框架</li>
</ul>


<p> 前面的文章中我们已经将WKWebView+SFSafariViewController完整的介绍了一遍，现在我们就开始着手探究一下单元测试（后面的文章中我将会集中介绍一下常用功能新特性），敬请关注：<a href="http://al1020119.github.io/">iOS梦工厂</a></p>

<h3>UI Tests是什么？</h3>

<p>UI Tests是一个自动测试UI与交互的Testing组件</p>

<h3>UI Tests有什么用？</h3>

<p>它可以通过编写代码、或者是记录开发者的操作过程并代码化，来实现自动点击某个按钮、视图，或者自动输入文字等功能。</p>

<h3>UI Tests的重要性</h3>

<p>在实际的开发过程中，随着项目越做越大，功能越来越多，仅仅靠人工操作的方式来覆盖所有测试用例是非常困难的，尤其是加入新功能以后，旧的功能也要重新测试一遍，这导致了测试需要花非常多的时间来进行回归测试，这里产生了大量重复的工作，而这些重复的工作有些是可以自动完成的，这时候UI Tests就可以帮助解决这个问题了</p>

<h2>使用方法</h2>

<h6>第一步：添加UI Tests</h6>

<p>如果是新项目，则创建工程的时候可以直接勾选选项，如下图</p>

<p><img src="http://al1020119.github.io/images/unittest001.png" title="Caption" ></p>

<p>如果是已有的项目，可以通过添加target的方式添加一个UI Tests，点击xcode的菜单，找到target栏</p>

<p><img src="http://al1020119.github.io/images/unittest002.png" title="Caption" ></p>

<p>在Test选项中选择Cocoa Touch UI Testing Bundle</p>

<p><img src="http://al1020119.github.io/images/unittest003.png" title="Caption" ></p>

<p>这时候test组件添加成功，它在项目中的位置如下图所示</p>

<p><img src="http://al1020119.github.io/images/unittest004.png" title="Caption" ></p>

<h6>第二步：创建测试代码</h6>

<p>手动创建测试代码
打开测试文件，在testExample()方法中添加测试代码</p>

<p><img src="http://al1020119.github.io/images/unittest005.png" title="Caption" ></p>

<p>如果不知道如何写测试代码，则可以参考自动生成的代码样式</p>

<h5>自动生成测试步骤</h5>

<p>选择测试文件后，点击录制按钮</p>

<p><img src="http://al1020119.github.io/images/unittest006.png" title="Caption" ></p>

<p>这时候开始进行操作，它会记录你的操作步骤，并生成测试代码
下图就是在一些操作后自动生成的测试代码</p>

<p><img src="http://al1020119.github.io/images/unittest007.png" title="Caption" ></p>

<p>这时候可以分析测试代码的语法，以便你自己手动修改或者手写测试代码</p>

<h6>第三步：开始测试</h6>

<p>点击testExample方法旁边的播放按钮，它就开始进行自动测试了，这时候你会看到app在自动操作</p>

<p><img src="http://al1020119.github.io/images/unittest008.png" title="Caption" ></p>

<h6>下面介绍一下测试元素的语法</h6>

<p>XCUIApplication：
继承XCUIElement，这个类掌管应用程序的生命周期，里面包含两个主要方法</p>

<pre><code>launch():
</code></pre>

<p>启动程序</p>

<pre><code>terminate():
</code></pre>

<p>终止程序</p>

<h6>XCUIElement:</h6>

<p>继承NSObject，实现协议XCUIElementAttributes, XCUIElementTypeQueryProvider
可以表示系统的各种UI元素</p>

<pre><code>exist:
</code></pre>

<p>可以让你判断当前的UI元素是否存在，如果对一个不存在的元素进行操作，会导致测试组件抛出异常并中断测试</p>

<pre><code>descendantsMatchingType(type:XCUIElementType)-&gt;XCUIElementQuery:
</code></pre>

<p>取某种类型的元素以及它的子类集合</p>

<pre><code>childrenMatchingType(type:XCUIElementType)-&gt;XCUIElementQuery:
</code></pre>

<p>取某种类型的元素集合，不包含它的子类</p>

<p>这两个方法的区别在于，你仅使用系统的UIButton时，用childrenMatchingType就可以了，如果你还希望查询自己定义的子Button，就要用descendantsMatchingType</p>

<p>另外UI元素还有一些交互方法</p>

<pre><code>tap():
</code></pre>

<p>点击</p>

<pre><code>doubleTap():
</code></pre>

<p>双击</p>

<pre><code>pressForDuration(duration: NSTimeInterval):
</code></pre>

<p>长按一段时间，在你需要进行延时操作时，这个就派上用场了</p>

<pre><code>swipeUp():
</code></pre>

<p>这个响应不了pan手势，暂时没发现能用在什么地方，也可能是beta版的bug，先不解释</p>

<pre><code>typeText(text: String):
</code></pre>

<p>用于textField和textView输入文本时使用，使用前要确保文本框获得输入焦点，可以使用tap()函数使其获得焦点</p>

<h6>XCUIElementAttributes协议</h6>

<p>里面包含了UIAccessibility中的部分属性
如下图</p>

<p><img src="http://al1020119.github.io/images/unittest009.png" title="Caption" ></p>

<p>可以方便你查看当前元素的特征，其中identifier属性可用于直接读取元素，不过该属性在UITextField中有bug，暂时不清楚原因</p>

<p>XCUIElementTypeQueryProvider协议
里面包含了系统中大部分UI控件的类型，可通过读属性的方式取得某种类型的UI集合
部分属性截图如下</p>

<p><img src="http://al1020119.github.io/images/unittest010.png" title="Caption" ></p>

<h3>创建Demo</h3>

<p>首先创建一个登录页面</p>

<p><img src="http://al1020119.github.io/images/unittest011.png" title="Caption" ></p>

<p>点击login按钮进行登录验证，点击clear按钮会清除文本
登录成功后可以去到个人信息页面</p>

<p>个人信息页面如下</p>

<p><img src="http://al1020119.github.io/images/unittest012.png" title="Caption" ></p>

<p>点击modify按钮可以修改个人信息，点击Message按钮可以查看个人消息</p>

<p>最后是消息界面</p>

<p><img src="http://al1020119.github.io/images/unittest013.png" title="Caption" ></p>

<h4>登录页面的测试</h4>

<ul>
<li>输入一个错误的账号</li>
<li>验证结果</li>
<li>关闭警告窗</li>
<li>清除输入记录</li>
<li>输入一个正确的账号</li>
<li>验证结果</li>
<li>进入个人信息页面</li>
</ul>


<p>测试代码如下:</p>

<pre><code>func testLoginView() {
    let app = XCUIApplication()

    // 由于UITextField的id有问题，所以只能通过label的方式遍历元素来读取
    let nameField = self.getFieldWithLbl("nameField")
    if self.canOperateElement(nameField) {
        nameField!.tap()
        nameField!.typeText("xiaoming")
    }

    let psdField = self.getFieldWithLbl("psdField")
    if self.canOperateElement(psdField) {
        psdField!.tap()
        psdField!.typeText("1234321")
    }

    // 通过UIButton的预设id来读取对应的按钮
    let loginBtn = app.buttons["Login"]
    if self.canOperateElement(loginBtn) {
        loginBtn.tap()
    }

    // 开始一段延时，由于真实的登录是联网请求，所以不能直接获得结果，demo通过延时的方式来模拟联网请求
    let window = app.windows.elementAtIndex(0)
    if self.canOperateElement(window) {
        // 延时3秒, 3秒后如果登录成功，则自动进入信息页面，如果登录失败，则弹出警告窗
        window.pressForDuration(3)
    }

    // alert的id和labe都用不了，估计还是bug，所以只能通过数量判断
    if app.alerts.count &gt; 0 {
        // 登录失败
        app.alerts.collectionViews.buttons["确定"].tap()

        let clear = app.buttons["Clear"]
        if self.canOperateElement(clear) {
            clear.tap()

            if self.canOperateElement(nameField) {
                nameField!.tap()
                nameField!.typeText("sun")
            }

            if self.canOperateElement(psdField) {
                psdField!.tap()
                psdField!.typeText("111111")
            }

            if self.canOperateElement(loginBtn) {
                loginBtn.tap()
            }
            if self.canOperateElement(window) {
                // 延时3秒, 3秒后如果登录成功，则自动进入信息页面，如果登录失败，则弹出警告窗
                window.pressForDuration(3)
            }
            self.loginSuccess()
        }
    } else {
        // 登录成功
        self.loginSuccess()
    }
}
</code></pre>

<blockquote><p>这里有几个需要特别注意的点：
当你的元素不存在时，它仍然可能返回一个元素对象，但这时候不能对其进行操作
当你要点击的元素被键盘或者UIAlertView遮挡时，执行tap方法会抛异常
详细实现可参照demo:
<a href="https://github.com/sunljz/demo/tree/master/iOS9/UITestDemo">https://github.com/sunljz/demo/tree/master/iOS9/UITestDemo</a></p></blockquote>

<h4>个人信息页测试</h4>

<ul>
<li>修改性别</li>
<li>修改年龄</li>
<li>修改心情</li>
<li>保存修改</li>
</ul>


<p>测试代码如下：</p>

<pre><code>    func testInfo() {
        let app = XCUIApplication()
        let window = app.windows.elementAtIndex(0)
        if self.canOperateElement(window) {
            // 延时2秒, 加载数据需要时间
            window.pressForDuration(2)
        }

        let modifyBtn = app.buttons["modify"];
        modifyBtn.tap()

        let sexSwitch = app.switches["sex"]
        sexSwitch.tap()

        let incrementButton = app.buttons["Increment"]
        incrementButton.tap()
        incrementButton.tap()
        incrementButton.tap()
        app.buttons["Decrement"].tap()

        let textView = app.textViews["feeling"]
        textView.tap()
        app.keys["Delete"].tap()
        app.keys["Delete"].tap()
        textView.typeText(" abc ")

        // 点击空白区域
        let clearBtn = app.buttons["clearBtn"]
        clearBtn.tap()

        // 保存数据
        modifyBtn.tap()
        window.pressForDuration(2)

        let messageBtn = app.buttons["message"]
        messageBtn.tap();

        // 延时1秒, push view需要时间
        window.pressForDuration(1)

        self.testMessage()
    }
</code></pre>

<blockquote><p>这里需要特别注意以下两点：
textview获取焦点时无法选择焦点的位置
tap事件的触发位置是view的中心，所以当view的中心被遮挡时，要考虑使用其他view来代替</p></blockquote>

<h4>个人消息界面测试</h4>

<p>单元格的点击
测试代码如下：</p>

<pre><code>    func testMessage() {
        let app = XCUIApplication()
        let window = app.windows.elementAtIndex(0)
        if self.canOperateElement(window) {
            // 延时2秒, 加载数据需要时间
            window.pressForDuration(2)
        }

        let table = app.tables
        table.childrenMatchingType(.Cell).elementAtIndex(8).tap()
        table.childrenMatchingType(.Cell).elementAtIndex(1).tap()

    }
</code></pre>

<blockquote><p>这里需要注意一点：
暂时无法获取到tableView的元素指针</p></blockquote>

<h3>总结</h3>

<p>总的来说，UI Tests只能用于一些基础功能的测试，验证app的功能是否可以正常使用，是否存在崩溃问题。但它也有很多不足之处，编写测试用例的过程非常繁琐，自动生成的代码几乎无法运行，功能单一，很多用例无法覆盖，而且bug很多，大大地限制了UI Tests在实际开发中的应用。希望正式版出来的时候能够修复这些问题，并开放更多的功能。</p>

<p>demo地址：</p>

<p><a href="https://github.com/sunljz/demo/tree/master/iOS9/UITestDemo">https://github.com/sunljz/demo/tree/master/iOS9/UITestDemo</a></p>

<p>最后介绍几个常见的第三方测试框架：</p>

<p>Frank， KIF， Subliminal， Apple 的 UIAutomation，我把他们都试了一遍。你要是希望了解更多可以访问我的故障特征测试框架。它不是开发者的失败，而是因为 Apple 对待测试只有有限的开放性。这使得这些框架有一系列的补丁，而在这些补丁之上，这些框架不外乎都成为了一堆破碎的工具。
没有涉及到的更多细节：</p>

<ul>
<li>Frank 一直被遗弃。</li>
<li>KIF 已经与主要的 iOS 修订版本决裂。</li>
<li>Subliminal 不能在命令行中可靠地运行。</li>
<li>UIAutomation 是用 JavaScript 和 clunky 写的。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[移动端性能优化]]></title>
    <link href="http://al1020119.github.io/blog/2015/12/13/yi-dong-duan-xing-neng-you-hua/"/>
    <updated>2015-12-13T14:16:31+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/12/13/yi-dong-duan-xing-neng-you-hua</id>
    <content type="html"><![CDATA[<p>之前写过一篇</p>

<p><a href="http://al1020119.github.io/blog/2015/03/02/uitableviewxing-neng-you-hua-yu-qia-dun-wen-ti/">UItableView性能优化和卡顿问题</a></p>

<p>还有一篇</p>

<p><a href="http://al1020119.github.io/blog/2015/11/16/appqia-dun-liao-zen-yao-ban-%3F/">App卡顿了怎么办</a></p>

<p>今天看到一篇总结的非常好的文章（<a href="http://tgideas.qq.com/webplat/info/news_version3/804/808/811/m579/201412/293834.shtml">移动端性能优化</a>），就移过来，后期我也会根据自己所做的项目做一个开发中性能优化的总结，希望你们喜欢！</p>

<p>随着移动互联网的发展，我们越发要关注移动页面的性能优化，今天跟大家谈谈这方面的事情。</p>

<!--more-->


<h3>首先，为什么要最移动页面进行优化？</h3>

<p>先来一篇前端优化的文章：腾讯一个大神的分享：</p>

<p><a href="http://www.cocoachina.com/webapp/20150126/11020.html">http://www.cocoachina.com/webapp/20150126/11020.html</a></p>

<p>纵观目前移动网络的现状，</p>

<p><img src="http://al1020119.github.io/images/xn001.png" title="Caption" ></p>

<p>   移动页面布局越来越复杂，效果越来越炫，直接导致了文件越来越大，下载和运行速度越来越低，而速度低会造成不良影响，据统计：</p>

<p><img src="http://al1020119.github.io/images/xn002.png" title="Caption" ></p>

<p> 71%的用户期望移动页面跟pc页面一样快，74%的用户能容忍的响应时间为5秒，所以我们必须保证移动端页面有足够的速度。</p>

<p> 移动页面的速度跟三个因素有关，分别是：移动网络带宽速度，设备性能（CPU，GPU，浏览器），页面本身。</p>

<ul>
<li>目前主流的移动网络制式为3g</li>
</ul>


<p><img src="http://al1020119.github.io/images/xn003.png" title="Caption" ></p>

<p> 今年，我们还看到了4g网络制式在快速发展，这再一次提升了移动页面的加载速度；</p>

<p> 而移动设备本身，截止到目前，以iphong6三星Note4等设备为首，智能设备已经变得比以往屏幕更大，CPU、GPU、内存更靠谱</p>

<p><img src="http://al1020119.github.io/images/xn004.png" title="Caption" ></p>

<p> 而与其同时，浏览器产商也为提升页面的速度做出了不可磨灭的努力，这里大家可以看一个视频<a href="http://www.iqiyi.com/w_19rsgfld99.html">http://www.iqiyi.com/w_19rsgfld99.html</a></p>

<p> 网络制式供应商，手机制造商，浏览器产商如此给力，我们呢？我们能做什么。</p>

<p> 我们能做得是对移动端页面本身优化，这也是我们专业价值的体现，所以我们必须做移动端页面性能优化。</p>

<h3>那怎么做移动端页面优化呢？</h3>

<p> 在说这个前，要提一下pc常用的优化手段：</p>

<ul>
<li>代码优化（css、html、js优化）</li>
<li>减少HTTP请求（雪碧图，文件合并&hellip;）</li>
<li>减少DOM节点</li>
<li>无阻塞（内联CSS，JS置后&hellip;）</li>
<li>缓存</li>
<li>&hellip;</li>
</ul>


<p> 这些手段大部分适用于移动端，这都是一些耳熟能详的手段，今天这里就讲了，有兴趣可以参考PDI课程《网站性能优化》。</p>

<p> 今天要讲的主要是一些适用于移动端的优化手段，现在进入正题。</p>

<p> 首先我们得关注一下一个页面从开始到呈现完毕需要经历什么阶段，主要有四个阶段：</p>

<p><img src="http://al1020119.github.io/images/xn005.png" title="Caption" ></p>

<p> 每个阶段的主要工作如上图所示，而我们的优化目标是：</p>

<p><img src="http://al1020119.github.io/images/xn006.png" title="Caption" ></p>

<p> 下面我们来针对上面的几个阶段细说一下都有哪些优化手段。</p>

<p> 首先，来看看加载中有哪些优化手段：</p>

<h5>1. 预加载</h5>

<p> 预加载方式有两种：</p>

<ul>
<li>A.显性加载</li>
</ul>


<p><img src="http://al1020119.github.io/images/xn007.png" title="Caption" ></p>

<p> 类似这种用户能明显感知的，我把它称为&ldquo;显性加载&rdquo;，互动页面都建议加上这种加载方式，它一方面能增加页面的趣味性，另一方面能让后续页面体验更流畅</p>

<ul>
<li>B.隐性加载</li>
</ul>


<p><img src="http://al1020119.github.io/images/xn008.png" title="Caption" ></p>

<p>这种在加载第一张图片的时候已经预先加载了第二张图片，从而使得页面体验更流畅的方式，我把它称为隐性加载，这种方式的好处是节省流量之余又能使得体验增强。</p>

<h5>2.    按需加载</h5>

<p>按需加载是不可或缺的优化手段，主要有以下两种方式：</p>

<p><img src="http://al1020119.github.io/images/xn009.png" title="Caption" ></p>

<p> 对于这种方式，在首屏加载的时候把首屏的内容加载尽量，而位于首屏之外的元素都只在出现在首屏时才加载，很大程度地节省了流量，提升了首次加载时间。</p>

<p><img src="http://al1020119.github.io/images/xn010.jpg" title="Caption" ></p>

<p> 这种叫响应式加载方式，意思是利用js或者css判断分辨率，从而选择不同尺寸的图片进行引入，这种的好处显而易见，同样可以加快加载速度和节省流量。</p>

<h5>3.    压缩图片</h5>

<p> 对于压缩图片，首先要提的是jpg文件：</p>

<p><img src="http://al1020119.github.io/images/xn011.png" title="Caption" ></p>

<p> 对于移动端的Jpg文件，有这样的结论：</p>

<pre><code>  a.使用大尺寸大有损压缩比的jpg

  b.使用jpegtran进行无损压缩
</code></pre>

<p><img src="http://al1020119.github.io/images/xn012.png" title="Caption" ></p>

<p> 而对于png有以下结论：</p>

<pre><code>  a.多彩图片使用png24

  b.低彩图片使用png8

  c.推荐使用pngquant
</code></pre>

<h5>4.尽量避免重定向</h5>

<p> 为什么要尽量避免重定向呢？因为如图：</p>

<p><img src="http://al1020119.github.io/images/xn013.png" title="Caption" ></p>

<p> 这是一个同一网速下的测试结果，重定向之所以会比较慢，是因为它重复了域名查找，tcp链接，发送请求。</p>

<h5>5. 使用其他方式代替图片</h5>

<p> 有两种方式，第一种是：依靠css3绘制图片</p>

<p><img src="http://al1020119.github.io/images/xn014.png" title="Caption" ></p>

<p> 第二种：使用iconfont代替图片</p>

<p><img src="http://al1020119.github.io/images/xn015.png" title="Caption" ></p>

<p> 但iconfont不一定比图片好，这里做了个实验：</p>

<p><img src="http://al1020119.github.io/images/xn016.png" title="Caption" ></p>

<p> 对于大图片，iconfont并不比雪碧图好，建议单侧小尺寸图标才使用iconfont.</p>

<p> 然后，针对脚本执行中有哪些优化手段，这里只提两点：</p>

<h5>1.尽量避免DataURI</h5>

<p> DataUri在移动端并不如它在pc端吃香，因为：</p>

<p><img src="http://al1020119.github.io/images/xn017.png" title="Caption" ></p>

<p> 经测试，DataURI要比简单的外链资源慢6倍，生成的代码文件相对图片文件体积没有减少反而增大，而且浏览器在对这种base64解码过程中需要消耗内存和cpu，这个在移动端坏处特别明显。</p>

<h5>2.点击事件优化</h5>

<p> 在移动端请适当使用touchstart，touchend，touch等事件代替延迟比较大的click事件。Click之所以慢是因为mousedown导致的：</p>

<p><img src="http://al1020119.github.io/images/xn018.png" title="Caption" ></p>

<p> 然后，针对渲染阶段中有哪些优化手段，这里也只提两点：</p>

<h5>1. 动画优化</h5>

<p>   a) 尽量使用css3动画</p>

<ul>
<li><p>优点：</p>

<ul>
<li><p>不占用js主线程</p></li>
<li><p>可利用硬件加速</p></li>
<li><p>浏览器可对动画做优化</p></li>
</ul>
</li>
<li><p>缺点：</p>

<ul>
<li>不支持中间状态监听</li>
</ul>


<p> b) 适当使用canvas动画</p></li>
<li><p>优点：</p>

<ul>
<li>可规避渲染树的计算渲染更快</li>
</ul>
</li>
<li><p>缺点：</p>

<ul>
<li><p>开发成本高</p></li>
<li><p>维护较麻烦</p></li>
</ul>
</li>
</ul>


<p> 通过对css3动画和canvas动画对比：</p>

<p><img src="http://al1020119.github.io/images/xn019.png" title="Caption" ></p>

<p> 得到结论：5个元素以内使用css3动画，5个以上使用canvas动画。</p>

<p>   c) 合理使用RAF(requestAnimationFrame)</p>

<ul>
<li><p> 优点：</p>

<ul>
<li><p>能解决脚本问题引起的丢帧，卡顿问题</p></li>
<li><p>支持中间状态监听</p></li>
</ul>
</li>
<li><p> 缺点：</p>

<ul>
<li>兼容问题</li>
</ul>
</li>
</ul>


<p><img src="http://al1020119.github.io/images/xn020.png" title="Caption" ></p>

<p> 通过RAF动画与settimeout动画对比：</p>

<p><img src="http://al1020119.github.io/images/xn021.png" title="Caption" ></p>

<p> 得到结论：不需要兼容android 4.3浏览器的情况下，请使用RAF制作脚本动画</p>

<ol>
<li>高频事件优化</li>
</ol>


<p><img src="http://al1020119.github.io/images/xn022.png" title="Caption" ></p>

<p> 类似touchmove，scroll这类的事件可导致多次渲染，对于这种事件可以通过以下手段进行优化：</p>

<ul>
<li><p>1.使用requestAnimationFrame监听帧变化，使得在正确的时间进行渲染</p></li>
<li><p>2.增加响应变化的时间间隔，减少重绘次数。</p></li>
</ul>


<p> 最后，针对合成/绘制只提一个优化手段：</p>

<p>   GPU加速</p>

<p> 触发GPU加速的方式有：</p>

<ul>
<li><p>CSS3 transitions</p></li>
<li><p>CSS3 3D transforms</p></li>
<li><p>WebGL 3D 绘制</p></li>
<li><p>Video</p></li>
<li><p>&hellip;</p></li>
</ul>


<p> 使用GPU加速前有对比实验：</p>

<p><img src="http://al1020119.github.io/images/xn023.png" title="Caption" ></p>

<p> GPU加速实际上是大幅减少了合成/绘制时间，从而大大地提高了页面速度，但GPU加速有自己的缺点：</p>

<p> 过多的GPU层会带来性能开销，主要原因是使用GPU加速其实是利用了GPU层的缓存，让渲染资源可以重复使用，所以一旦层多了，缓存增大，就会引起别的性能问题。</p>

<p>总结</p>

<p><img src="http://al1020119.github.io/images/xn024.png" title="Caption" ></p>

<blockquote><p>本文针对页面呈现的四个阶段提出了比较典型的优化手段，到最后，再提醒读者一下：其实优化是双刃剑。
  按需加载提升速度，但可能导致大量重绘；
  Touch响应快，但很多场景不适合；
  GPU加速效率高，但内存开销大等等
  Loading会让整体体验流畅，但容易造成用户流失
  图片压缩让带宽成本降低，但可能会导致视觉效果变差
 类似这样的矛盾点还有很多，请结合业务按照实际情况进行优化。</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NSProxy&amp;NSObject初探]]></title>
    <link href="http://al1020119.github.io/blog/2015/12/13/nsproxy-and-nsobjectchu-tan/"/>
    <updated>2015-12-13T13:20:37+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/12/13/nsproxy-and-nsobjectchu-tan</id>
    <content type="html"><![CDATA[<p>NSObject类属于根类。根类在层级结构中处于最高级，也就是说除此以外没有更高层级。而且Objective-c中还有其他根类，不像Java里只有一个java.lang.Object根类，其他所有的类都直接或间接的继承于它。因此，</p>

<p>Java代码可以依据任何对象来实现它的基本方法。Cocoa有多个根类，除了NSObject还有NSProxy等其他等级的根类。这只是部分原因，NSObject协议定义了一套所有的根类都可以实现的基础方法，这样在编码时就容易找到了。</p>

<p>NSObject类遵循NSObject协议，这就是说，NSObject类实现了下面这些基础方法：</p>

<pre><code>@interface NSObject  
</code></pre>

<p>NSProxy同样遵循NSObject协议：</p>

<pre><code>@interface NSProxy      
</code></pre>

<!--more-->


<p>NSObject协议包含了hash，isEqual:，description等方法。事实上，NSProxy遵循NSObject协议意味着你可以依靠实现NSProxy来实现NSObject方法。</p>

<h3>NSObjetc：</h3>

<p>NSObject协议组对所有的Object－C下的objects都生效。
如果objects遵从该协议，就会被看作是first－class objects（一级类）。
另外，遵从该协议的objects的retain，release，autorelease等方法也服从objects的管理和在Foundation中定义的释放方法。一些容器中的对象也可以管理这些objects，比如
说NSArray 和NSDictionary定义的对象。
Cocoa的根类也遵循该协议，所以所有继承NSObjects的objects都有遵循该协议的特性。</p>

<h3>NSProXY：</h3>

<p>NSProxy 是一个虚基类，它为一些表现的像是其它对象替身或者并不存在的对象定义一套API。一般的，发送给代理的消息被转发给一个真实的对象或者代理本身load(或者将本身转换成)一个真实的对象。NSProxy的基类可以被用来透明的转发消息或者耗费巨大的对象的lazy 初始化。</p>

<p>NSProxy实现了包括NSObject协议在内基类所需的基础方法，但是作为一个虚拟的基类并没有提供初始化的方法。它接收到任何自己没有定义的方法他都会产生一个异常，所以一个实际的子类必须提供一个初始化方法或者创建方法，并且重载forwardInvocation:方法和methodSignatureForSelector:方法来处理自己没有实现的消息。一个子类的forwardInvocation:实现应该采取所有措施来处理invocation,比如转发网络消息，或者加载一个真实的对象，并把invocation转发给他。methodSignatureForSelector:需要为给定消息提供参数类型信息，子类的实现应该有能力决定他应该转发消息的参数类型，并构造相对应的NSMethodSignature对象。详细信息可以查看NSDistantObject, NSInvocation, and NSMethodSignature的类型说明。</p>

<h4>简单使用</h4>

<h6>NSProxy</h6>

<pre><code>// MyProxy.h
#import&lt;Foundation/Foundation.h&gt;

@interface MyProxy :NSProxy {
    NSObject *object;
}

- (id)transformToObject:(NSObject *)anObject;

@end

// MyProxy.m
#import"MyProxy.h"

@implementation MyProxy

- (void)dealloc
{
    [objectrelease];
    object = nil;
    [superdealloc];
}

- (void)fun
{
   // Do someting virtual
    //先做一些代理工作，然后创建一个后台线程，在后台线程中再调用真正的[object fun];
}

// Stupid transform implementation just by assigning a passed in object as transformation target. You can write your factory here and use passed in object as id for object that need ot be created.
- (id)transformToObject:(NSObject *)anObject 
{
    if(object != anObject) {
        [objectrelease];
    }
    object = [anObject retain];
    return object;
}

- (void)forwardInvocation:(NSInvocation *)invocation 
{
    if (object != nil) {
        [invocation setTarget:object];    

        [invocation invoke];
    }
}

- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel 
{
   NSMethodSignature *result;
    if (object != nil) {
        result = [objectmethodSignatureForSelector:sel];
    } else {
       // Will throw an exception as default implementation
        result = [supermethodSignatureForSelector:sel];
    }
    return result;
}

@end
</code></pre>

<hr />

<h6>NSObject</h6>

<pre><code>// RealSubject.h
#import&lt;Foundation/Foundation.h&gt;
@implementation RealSubject : NSObject

- (void)fun;

@end

// RealSubject.m
#import"RealSubject.h"

@implementation RealSubject

- (void)fun
{
    //这个方法需要代理进行惰性调用
   // Do something real
}

- (void)otherFun
{
    //这个方法不需要代理做任何处理，可直接被调用
   // Do something real
}

@end

// main.m
int main(int argc,char *argv[]) 
{
   NSAutoreleasePool * pool = [[NSAutoreleasePoolalloc] init];

    MyProxy *myProxy = [MyProxy alloc];
    RealSubject *realSub = [[RealSubject alloc] init];
    [myProxytransformToObject:realSub];
    [myProxyfun]; // 直接调用myProxy的fun，执行代理工作
    [myProxyotherFun]; // 依次调用myProxy的methodSignatureForSelector和forwardInvocation转发给realSub，realSub调用otherFun

    [realSubject release];
    [myProxyrelease];

    [pool release];
    return 0;
}
</code></pre>

<blockquote><p>注意，调用MyProxy中未定义的方法otherFun会出现'MyProxy' may not respond to &lsquo;fun'的警告，可通过使用私有范畴或通过performSelector:withObject:来避免，如果有更好的方法，请告知。</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[安全机制]]></title>
    <link href="http://al1020119.github.io/blog/2015/12/12/an-quan-ji-zhi/"/>
    <updated>2015-12-12T22:46:51+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/12/12/an-quan-ji-zhi</id>
    <content type="html"><![CDATA[<p>关于安全机制，作为一个程序员必须要时刻记住的，不然你的app不仅没有人用，还会被举报甚至更加严重，所以这里大概的总结了一下。</p>

<ul>
<li>苹果安全机制</li>
<li>ios开发安全处理</li>
</ul>


<!--more-->


<hr />

<p>苹果的安全机制</p>

<p><img src="http://al1020119.github.io/images/anquanjizhi001.png" title="Caption" ></p>

<p>客户端开发安全机制</p>

<p><img src="http://al1020119.github.io/images/anquanjizhi002.png" title="Caption" ></p>

<p>其中网络安全是非常重要的，所以总结了几个网络相关技术。</p>

<p><img src="http://al1020119.github.io/images/anquanjizhi003.png" title="Caption" ></p>

<hr />

<p>概述：iOS应用程序因为其特殊性，被攻击的可能也是很高的。在开发过程中，需要从三个方面考虑程序安全性。</p>

<ul>
<li>iOS应用程序安全开发须知(一)</li>
<li>iOS应用程序安全开发须知(二)</li>
<li>iOS应用程序安全开发须知(三)</li>
</ul>


<h3>网络安全</h3>

<h6>安全地传输用户密码</h6>

<p>大 部分的iOS应用都需要连网，通过和服务器端进行通信，获得最新的信息并且将内容展现给用户。由于网络传输过程中有可能经过不安全的中间节点，所以我们应 该对敏感数据加密，用于保证用户信息的安全。黑客可以在受害者的手机上设置网络通信的代理服务器，从而截获所有的网络请求。即使是HTTPS的加密通信， 黑客也可以通过中间人攻击（Man-In-The-Middle Attack，指的是攻击者与通信的两端分别创建独立的联系，并交换其所收到的数据，使通信的两端认为他们正在通过一个私密的连接与对方直接对话，但事实 上，整个会话都被攻击者完全控制）来截取通信内容。</p>

<p>黑客可以在Mac下使用Charles软件（如果在Windows下，可以使用 Fiddler软件）来将自己的电脑设置成代理服务器，从而截取应用的网络请求，分析目标应用在通信协议上是否有安全问题。为了测试，我选取了在国内最大 的两家租车公司（神州租车和一嗨租车）的iOS应用。</p>

<p><img src="http://al1020119.github.io/images/anquanjizhixiangjie001.jpg" title="Caption" ></p>

<p>从图1可以看到，神州租车和一嗨租车在用户登录时，均采用明文的方式，将密码直接发送给服务器。其中一嗨租车不但采用明文方式发送密码，而且在发送 时使用了Http Get的方式，而GET的URL数据一般都会保存在服务器的Access Log中，所以黑客一旦攻破服务器，只需要扫描Acesss Log，则可以轻易获得所有用户的明文密码（在本文发表前，一嗨租车已修改了登录协议，采用了POST的方式来登录，但仍然传递的是明文密码）。</p>

<p>如 果每一个移动应用都像以上两种应用那样，明文传输用户密码，那么我们可以想象这样一个场景：黑客在咖啡馆或机场等一些公共场所，将自己的电脑设置成与该场 所一样名字的免费Wi-Fi，受害者只要不小心使用了该Wi-Fi，则可能泄漏自己的明文密码。对于大多数普通人来说，他们会使用一样的密码登录他的所有 的账号，这就意味着他的其他账号：例如淘宝或网上银行账号也有被盗的风险。</p>

<p>正 确的做法应该是这样：事先生成一对用于加密的公私钥，客户端在登录时，使用公钥将用户的密码加密后，将密文传输到服务器。服务器使用私钥将密码解密，然后 加盐（Salt，在密码学中是指，通过在密码任意固定位置插入特定的字符串，让散列后的结果和使用原始密码的散列结果不相符，这个过程称为“加盐”），之 后再多次求MD5，然后再和服务器原来存储的用同样方法处理过的密码匹配，如果一致，则登录成功。这样的做法保证黑客即使截获了加密后的密文，由于没有私 钥，也无法还原出原始的密码。而服务器即使被黑客攻陷，黑客除了暴力尝试，也无法从加盐和多次MD5后的密码中还原出原始的密码。这就保证了用户密码的安 全。</p>

<h6>防止通信协议被轻易破解</h6>

<p>除了上面提到的明文传输密码的问题外，移动端应用还要面对黑客对于通信协议的破解的威胁。</p>

<p>在 成功破解了通信协议后，黑客可以模拟客户端登录，进而伪造一些用户行为，可能对用户数据造成危害。例如腾讯出品的消除游戏《天天爱消除》，在淘宝上就有很 多售价仅为1元的代练服务，如果真正是人工代练，是不可能卖这么便宜的，只有可能是该游戏的通信协议被破解，黑客制作出了代练的机器人程序。通信协议被破 解除了对于移动端游戏有严重危害外，对于应用也有很大的危害。例如针对微信，黑客可以制作一些僵尸账号，通过向微信公共账号后台发送垃圾广告，达到赢利的 目的。而iPhone设备上的iMessage通信协议居然也被破解了，所以很多iPhone用户会收到来自iMessage的垃圾广告。</p>

<p>对 于以上提到的问题，开发者可以选择类似ProtoBuf（Google提供的一个开源数据交换格式，其最大的特点是基于二进制，因此比传统的JSON格式 要短小得多）之类的二进制通信协议或自己实现通信协议，对于传输的内容进行一定程度的加密，以增加黑客破解协议的难度。图2是我截取的淘宝客户端的通信数 据，可以看到其中的值都不能直观地猜出内容，所以这对于通信协议是有一定的保护作用。</p>

<p><img src="http://al1020119.github.io/images/anquanjizhixiangjie002.jpg" title="Caption" ></p>

<h6>验证应用内支付的凭证</h6>

<p>iOS 应用内支付（IAP）是众多应用赢利的方式，通过先让用户免费试用或试玩，然后提供应用内支付来为愿意付费的用户提供更强大的功能，这种模式特别适合不习 惯一开始就掏钱的中国用户。但国内越狱用户的比例较大，所以我们也需要注意应用内支付环节中的安全问题。简单来说，越狱后的手机由于没有沙盒作为保护，黑 客可对系统进行任意地修改，所以在支付过程中，苹果返回的已付款成功的凭证可能是伪造的。客户端拿到付款凭证后，还需要将凭证上传到自己的服务器上，进行 二次验证，以保证凭证的真实性。</p>

<p>另外，我们发现越狱用户的手机上，很可能被黑客用中间人攻击技术来劫持支付凭证。这对于黑客有什么好处呢？ 因为苹果为了保护用户的隐私，支付凭证中并不包含任何用户的账号信息，所以我们的应用和服务器无法知道这个凭证是谁买的，而只能知道这个凭证是真的还是假 的。所以在验证凭证时，哪个账号发起了验证请求，我们就默认这个凭证是该账号拥有的。如果黑客将凭证截获，就可以伪装成真实用户来验证凭证或者转手出售获 利。</p>

<p>打个比方，这就类似于很多商场的购物卡一样，由于是不记名的，黑客如果将你买的购物卡偷窃然后去刷卡购物，商场是无法简单地区分出来的。因此，对于应用内支付，开发者除了需要仔细地验证购买凭证外，也需要告知用户在越狱手机上进行支付的风险。</p>

<h3>本地文件和数据安全</h3>

<h6>程序文件的安全</h6>

<p>iOS 应用的大部分逻辑都是在编译后的二进制文件中，但由于近年来混合式（Hybrid）编程方式的兴起，很多应用的部分功能也采用内嵌Web浏览器的方式来实 现。例如腾讯QQ iOS客户端的内部，就有部分逻辑是用Web方式实现的。由于iOS安装文件其实就是一个zip包，所以我们可以通过解压，看到包内的内容。以下是我解开 腾讯QQ客户端，看到的其qqapi.js文件的内容。</p>

<p><img src="http://al1020119.github.io/images/anquanjizhixiangjie003.jpg" title="Caption" ></p>

<p>可以看到，这些文件都有着完整清晰的注释。通过分析这些JavaScript文件，黑客可以很轻松地知道其调用逻辑。在越狱手机上，还可以修改这些JavaScript代码，达到攻击的目的。</p>

<p>我也曾尝试查看支付宝客户端中的彩票功能，通过分析，也可以找到其完整的、带着清晰注释的JavaScript代码，如图3所示（支付宝现在已对相应代码进行了加密）。</p>

<p>支付宝应用内的JavaScript文件
图3  支付宝应用内的JavaScript文件</p>

<p><img src="http://al1020119.github.io/images/anquanjizhixiangjie004.jpg" title="Caption" ></p>

<p>通过将JavaScript源码进行混淆和加密，可以防止黑客轻易地阅读和篡改相关的逻辑，也可以防止自己的Web端与Native端的通信协议泄漏。</p>

<h6>本地数据安全</h6>

<p>iOS 应用的数据在本地通常保存在本地文件或本地数据库中。如果对本地的数据不进行加密处理，很可能被黑客篡改。比如一款名为《LepsWorld 3》的游戏，打开它的本地文件，可以很容易地找到，它使用了一个名为ItempLifes的变量保存生命数值（如图4所示）。于是我们可以简单修改该值， 达到修改游戏参数的目的。而在某宝上，也可以找到许多以此挣钱的商家。对于本地的重要数据，我们应该加密存储或将其保存到keychain中，以保证其不被篡改。</p>

<p><img src="http://al1020119.github.io/images/anquanjizhixiangjie005.jpg" title="Caption" ></p>

<h3>源代码安全</h3>

<p>通过file、class-dump、theos、otool等工具，黑客可以分析编译之后的二进制程序文件，不过相对于这些工具来说，IDA的威胁最大。 IDA是一个收费的反汇编工具，对于Objective-C代码，它常常可以反汇编到可以方便阅读的程度，这对于程序的安全性，也是一个很大的危害。因为 通过阅读源码，黑客可以更加方便地分析出应用的通信协议和数据加密方式。</p>

<p>下面分别示例了一段代码的原始内容和通过IDA反汇编之后的结果。可以看到，IDA几乎还原了原本的逻辑，而且可读性也非常高。</p>

<p>原始代码：</p>

<p><img src="http://al1020119.github.io/images/anquanjizhixiangjie006.jpg" title="Caption" ></p>

<p>反汇编后：</p>

<p><img src="http://al1020119.github.io/images/anquanjizhixiangjie007.jpg" title="Caption" ></p>

<p>反 汇编的代码被获得后，由于软件内部逻辑相比汇编代码来说可读性高了很多。黑客可以用来制作软件的注册机，也可以更加方便地破解网络通信协议，从而制作出机 器人（“僵尸”）账号。最极端的情况下，黑客可以将反汇编的代码稍加修改，植入木马，然后重新打包发布在一些越狱渠道上，这将对用户产生巨大的危害。</p>

<p>对于IDA这类工具，我们的应对措施就比较少了。除了可以用一些宏来简单混淆类名外，也可以通过市面上收费的加密工具来实现，如：.NET Reactor v4.9  Dotfuscator DashO Pro v7.3 Zend Guard等，也达到复用的目的。</p>

<p>总结</p>

<p>由于移动互联网的快速发展，人们的购物、理财等需求也在移动端出现，使得移动应用的安全性越来越重要。由于部署在用户终端上，移动应用比服务器应用更容易被攻击，大家也需要在移动应用的网络通信、本地文件和数据、源代码三方面做好防范，只有这样才能保证应用安全。</p>

<h6>最后分享一份最近加密的demo，由于公司项目的需要，所以就整了一下这个！</h6>

<pre><code>@interface ViewController ()
@property (weak, nonatomic) IBOutlet UITextField *username;
@property (weak, nonatomic) IBOutlet UITextField *pwd;
- (IBAction)login;
@end

@implementation ViewController

- (void)viewDidLoad
{
    [super viewDidLoad];
    // Do any additional setup after loading the view, typically from a nib.
}

- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event
{
    [self.view endEditing:YES];
}

- (IBAction)login {
    // 1.用户名
    NSString *usernameText = self.username.text;
    if (usernameText.length == 0) {
        [MBProgressHUD showError:@"请输入用户名"];
        return;
    }

    // 2.密码
    NSString *pwdText = self.pwd.text;
    if (pwdText.length == 0) {
        [MBProgressHUD showError:@"请输入密码"];
        return;
    }

    // 增加蒙板
    [MBProgressHUD showMessage:@"正在拼命登录中...."];

    // 3.发送用户名和密码给服务器(走HTTP协议)
    // 创建一个URL ： 请求路径
    NSURL *url = [NSURL URLWithString:@"http://218.83.161.124:8080/job/login"];

    // 创建一个请求
    NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url];

    // 5秒后算请求超时（默认60s超时）
    request.timeoutInterval = 15;

    request.HTTPMethod = @"POST";

#warning 对pwdText进行加密
    pwdText = [self MD5Reorder:pwdText];

    // 设置请求体
    NSString *param = [NSString stringWithFormat:@"username=%@&amp;pwd=%@", usernameText, pwdText];

    NSLog(@"%@", param);

    // NSString --&gt; NSData
    request.HTTPBody = [param dataUsingEncoding:NSUTF8StringEncoding];

    // 设置请求头信息
    [request setValue:@"iPhone 6" forHTTPHeaderField:@"User-Agent"];

    // 发送一个同步请求(在主线程发送请求)
    // queue ：存放completionHandler这个任务
    NSOperationQueue *queue = [NSOperationQueue mainQueue];
    [NSURLConnection sendAsynchronousRequest:request queue:queue completionHandler:
     ^(NSURLResponse *response, NSData *data, NSError *connectionError) {
         // 隐藏蒙板
         [MBProgressHUD hideHUD];

        // 这个block会在请求完毕的时候自动调用
        if (connectionError || data == nil) { // 一般请求超时就会来到这
            [MBProgressHUD showError:@"请求失败"];
            return;
        }

        // 解析服务器返回的JSON数据
        NSDictionary *dict = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableLeaves error:nil];
        NSString *error = dict[@"error"];
        if (error) {
            [MBProgressHUD showError:error];
        } else {
            NSString *success = dict[@"success"];
            [MBProgressHUD showSuccess:success];
        }
     }];
}

/**
 *  MD5($pass.$salt)
 *
 *  @param text 明文
 *
 *  @return 加密后的密文
 */
- (NSString *)MD5Salt:(NSString *)text
{
    // 撒盐：随机地往明文中插入任意字符串
    NSString *salt = [text stringByAppendingString:@"aaa"];
    return [salt md5String];
}

/**
 *  MD5(MD5($pass))
 *
 *  @param text 明文
 *
 *  @return 加密后的密文
 */
- (NSString *)doubleMD5:(NSString *)text
{
    return [[text md5String] md5String];
}

/**
 *  先加密，后乱序
 *
 *  @param text 明文
 *
 *  @return 加密后的密文
 */
- (NSString *)MD5Reorder:(NSString *)text
{
    NSString *pwd = [text md5String];

    // 加密后pwd == 3f853778a951fd2cdf34dfd16504c5d8
    NSString *prefix = [pwd substringFromIndex:2];
    NSString *subfix = [pwd substringToIndex:2];

    // 乱序后 result == 853778a951fd2cdf34dfd16504c5d83f
    NSString *result = [prefix stringByAppendingString:subfix];

    NSLog(@"\ntext=%@\npwd=%@\nresult=%@", text, pwd, result);

    return result;
}
</code></pre>

<p>资源分享：</p>

<p>原文地址：<a href="http://www.csdn.net/article/2014-05-28/2819994">http://www.csdn.net/article/2014-05-28/2819994</a></p>

<p>通信安全工具：</p>

<p><a href="http://www.evget.com/product/170">IP*Works! Internet Toolkit v9.0</a></p>

<p><a href="http://www.evget.com/product/178">IP*Works! EDI/AS2 v9.0</a></p>

<p><a href="http://www.evget.com/product/173">IP*Works! S/MIME v9.0</a></p>

<p><a href="http://www.evget.com/product/1915">IP*Works! SSH</a></p>

<p><a href="http://www.evget.com/product/171">IP*Works! SSL</a></p>

<p>代码混淆工具：</p>

<p><a href="http://www.evget.com/product/2399">.NET Reactor v4.9</a></p>

<p><a href="http://www.evget.com/product/676">Dotfuscator</a></p>

<p><a href="http://www.evget.com/product/1339">DashO Pro v7.3</a></p>

<p><a href="http://www.evget.com/product/1339">Zend Guard</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[KeyChain初探]]></title>
    <link href="http://al1020119.github.io/blog/2015/12/12/keychainchu-tan/"/>
    <updated>2015-12-12T22:46:16+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/12/12/keychainchu-tan</id>
    <content type="html"><![CDATA[<p>iOS的keychain服务提供了一种安全的保存私密信息（密码，序列号，证书等）的方式，每个ios程序都有一个独立的keychain存储。相对于NSUserDefaults、文件保存等一般方式，keychain保存更为安全，而且keychain里保存的信息不会因App被删除而丢失，所以在重装App后，keychain里的数据还能使用。</p>

<blockquote><p>“yourAppID.com.yourCompany.whatever”就是你要起的公共区名称，除了whatever字段可以随便定之外，其他的都必须如实填写。这个文件的路径要配置在 Project->build setting->Code Signing Entitlements里，否则公共区无效，配置好后，须用你正式的证书签名编译才可通过，否则xcode会弹框告诉你code signing有问题。所以，苹果限制了你只能同公司的产品共享KeyChain数据，别的公司访问不了你公司产品的KeyChain。</p></blockquote>

<!--more-->


<h3>一.基本知识</h3>

<h6>1.方法</h6>

<ul>
<li>SecItemAdd 增</li>
<li>SecItemUpdate 改</li>
<li>SecItemDelete 删</li>
<li>SecItemCopyMatching 查</li>
</ul>


<h6>2.权限</h6>

<p>文档上说iOS的keyChain是一个相对独立的空间，当程序替换，删除时并不会删除keyChain的内容，这个要比Library/Cache好。刷机，恢复出厂应该就没有了。关于备份，只会备份数据，到那时不会备份设备的密钥，换句话说，即使拿到数据，也没有办法解密里面的内容。有人说似乎破解的手机就能破解keyChain,本人并不清楚，希望有大神能指教。但个人认为，keyChain只是沙盒的升级版，可以存放一些非私密的信息，即使破解也不影响其它用户，只影响那个破解了的设备。（比如针对该设备的一个密钥）。</p>

<p>可访问性一般来说，自己的程序只能访问自己的keychain,相同bundle的程序通过设置group可以互相共享同组的keychain，从而实现程序间可以共同访问一些数据。详细后面介绍一些我测试下来的经验。</p>

<h6>3.如何查询keyChain</h6>

<pre><code>[objc] view plaincopyprint?在CODE上查看代码片派生到我的代码片
genericPasswordQuery = [[NSMutableDictionary alloc] init];   
[genericPasswordQuery setObject:(id)kSecClassGenericPassword forKey:(id)kSecClass];//1  
[genericPasswordQuery setObject:identifier forKey:(id)kSecAttrGeneric];//2  
if (accessGroup != nil){  
    [genericPasswordQuery setObject:accessGroup forKey:(id)kSecAttrAccessGroup];//3  
}  
[genericPasswordQuery setObject:(id)kSecMatchLimitOne forKey:(id)kSecMatchLimit];//4  
[genericPasswordQuery setObject:(id)kCFBooleanTrue forKey:(id)kSecReturnAttributes];//5  
NSDictionary *tempQuery = [NSDictionary dictionaryWithDictionary:genericPasswordQuery];  
NSMutableDictionary *outDictionary = nil;      
if (SecItemCopyMatching((CFDictionaryRef)tempQuery, (CFTypeRef *)&amp;outDictionary) == noErr){//6  
//found and outDicitionary is not nil  
}else{  
//not found  
}  
</code></pre>

<ul>
<li>1.设置Class值，每个Class对应的都有不同的参数类型</li>
<li>2.用户确定的参数，一般是程序中使用的类别，比如说是"Password"或"Account Info"，作为search的主力条件</li>
<li>3.设置Group,如果不同程序都拥有这个组，那么不同程序间可以共享这个组的数据</li>
<li>4.只返回第一个匹配数据，查询方法使用，还有值kSecMatchLimitAll</li>
<li>5.返回数据为CFDicitionaryRef，查询方法使用</li>
<li>6.执行查询方法，判断返回值</li>
</ul>


<blockquote><p>eg:这个是none-ARC的代码哦！ARC情况下会有bridge提示。</p></blockquote>

<h6>4.类型转换</h6>

<p>介绍增删改方法调用前，先介绍转换方法，如何将NSDictionary转换成KeyChain方法可以设置的Dicitionary，一般在写程序过程中，应该尽量避免直接访问KeyChain，一般会创建一个NSDictionary来同步对应的数据，所以两者需要做转换。</p>

<pre><code>//data to secItem  
- (NSMutableDictionary *)dictionaryToSecItemFormat:(NSDictionary *)dictionaryToConvert  
{  
    // Create a dictionary to return populated with the attributes and data.  
    NSMutableDictionary *returnDictionary = [NSMutableDictionary dictionaryWithDictionary:dictionaryToConvert];  

    //设置kSecClass  
    [returnDictionary setObject:(id)kSecClassGenericPassword forKey:(id)kSecClass];  
    //将Dictionary里的kSecValueData(一般就是这个keyChain里主要内容，比如说是password),NSString转换成NSData  
    NSString *passwordString = [dictionaryToConvert objectForKey:(id)kSecValueData];  
    [returnDictionary setObject:[passwordString dataUsingEncoding:NSUTF8StringEncoding] forKey:(id)kSecValueData];  
    return returnDictionary;  
}  
//secItem to data  
- (NSMutableDictionary *)secItemFormatToDictionary:(NSDictionary *)dictionaryToConvert  
{  
    NSMutableDictionary *returnDictionary = [NSMutableDictionary dictionaryWithDictionary:dictionaryToConvert];  

    // Add the proper search key and class attribute.  
    [returnDictionary setObject:(id)kCFBooleanTrue forKey:(id)kSecReturnData];  
    [returnDictionary setObject:(id)kSecClassGenericPassword forKey:(id)kSecClass];  

    // Acquire the password data from the attributes.  
    NSData *passwordData = NULL;  
    if (SecItemCopyMatching((CFDictionaryRef)returnDictionary, (CFTypeRef *)&amp;passwordData) == noErr)  
    {  
        // 删除多余的kSecReturnData数据  
        [returnDictionary removeObjectForKey:(id)kSecReturnData];  

        // 对应前面的步骤，将数据从NSData转成NSString  
        NSString *password = [[[NSString alloc] initWithBytes:[passwordData bytes] length:[passwordData length]  
                                                     encoding:NSUTF8StringEncoding] autorelease];  
        [returnDictionary setObject:password forKey:(id)kSecValueData];  
    }  
    else  
    {  
        NSAssert(NO, @"Serious error, no matching item found in the keychain.\n");  
    }  
    [passwordData release];   
    return returnDictionary;  
}  
</code></pre>

<h6>5.增删改</h6>

<p>用代码来说明</p>

<pre><code>- (void)writeToKeychain  
{  
    NSDictionary *attributes = NULL;  
    NSMutableDictionary *updateItem = NULL;  
    OSStatus result;  
    //判断是增还是改  
    if (SecItemCopyMatching((CFDictionaryRef)genericPasswordQuery, (CFTypeRef *)&amp;attributes) == noErr)  
    {  
            // First we need the attributes from the Keychain.  
            updateItem = [NSMutableDictionary dictionaryWithDictionary:attributes];  
        // Second we need to add the appropriate search key/values.  
            [updateItem setObject:[genericPasswordQuery objectForKey:(id)kSecClass] forKey:(id)kSecClass];  
            // Lastly, we need to set up the updated attribute list being careful to remove the class.  
            NSMutableDictionary *tempCheck = [self dictionaryToSecItemFormat:keychainItemData];  
            //删除kSecClass update不能update该字段，否则会报错  
            [tempCheck removeObjectForKey:(id)kSecClass];  
        //参数1表示search的，参数2表示需要更新后的值  
            result = SecItemUpdate((CFDictionaryRef)updateItem, (CFDictionaryRef)tempCheck);  
    }else{  
            //增加  
            result = SecItemAdd((CFDictionaryRef)[self dictionaryToSecItemFormat:keychainItemData], NULL);  
    }  
}  
</code></pre>

<p>删除很简单，就不写注释了</p>

<pre><code>- (void)resetKeychainItem  
{  
    OSStatus junk = noErr;  
    if (!keychainItemData)  
    {  
        self.keychainItemData = [[NSMutableDictionary alloc] init];  
    }  
    else if (keychainItemData)  
    {  
        NSMutableDictionary *tempDictionary = [self dictionaryToSecItemFormat:keychainItemData];  
        junk = SecItemDelete((CFDictionaryRef)tempDictionary);  
        NSAssert( junk == noErr || junk == errSecItemNotFound, @"Problem deleting current dictionary." );  
    }  

    // Default attributes for keychain item.  
    [keychainItemData setObject:@"" forKey:(id)kSecAttrAccount];  
    [keychainItemData setObject:@"" forKey:(id)kSecAttrLabel];  
    [keychainItemData setObject:@"" forKey:(id)kSecAttrDescription];  

    // Default data for keychain item.  
    [keychainItemData setObject:@"" forKey:(id)kSecValueData];  
}  
</code></pre>

<p>二.Group的配置
配置Target的Code Signing Entitlements.</p>

<p><img src="http://al1020119.github.io/images/keyChain001.png" title="Caption" ></p>

<p>配置该文件</p>

<p><img src="http://al1020119.github.io/images/keyChain002.png" title="Caption" ></p>

<p><img src="http://al1020119.github.io/images/keyChain003.png" title="Caption" ></p>

<p>可以配置一个Array列表，表示该程序可以支持多个group
这样就可以在创建secItem时候添加kSecAttrAccessGroup了。
经过测试有以下经验同大家分享：</p>

<ul>
<li><p>1.相同bundle下生成的程序都可以共享相同group的keyChain.
相同bundle解释下就是：比如:2个程序分别使用的provision对应bundle是com.jv.key1和com.jv.key2，那你配置文件肯定是{Identifer}.com.jv.{name},其中identifer是苹果生成的随机串号，可以在申请证书时看到，复制过来即可，name可以自己取，程序中指定属于哪个Group即可。</p></li>
<li><p>2.如果你在 addkey时，没有指定group,则会默认添加你keychain-access-groups里第一个group，如果你没有设置Entitlements,则默认使用对应的程序的bundle name,比如com.jv.key1,表示只能给自己程序使用。</p></li>
<li><p>3.如果你程序添加的group并不存在你的配置文件中，程序会奔溃，表示无法添加。因此你只能添加你配置文件中支持的keychain。</p></li>
</ul>


<p>三、保存私密信息（工具）
在应用里使用使用keyChain，我们需要导入Security.framework ，keychain的操作接口声明在头文件SecItem.h里。直接使用SecItem.h里方法操作keychain，需要写的代码较为复杂，为减轻咱们程序员的开发，我们可以使用一些已经封装好了的工具类，下面我会简单介绍下我用过的两个工具类：KeychainItemWrapper和SFHFKeychainUtils。</p>

<p>（一）KeychainItemWrapper是apple官方例子“GenericKeychain”里一个访问keychain常用操作的封装类，在官网上下载了GenericKeychain项目后，只需要
把“KeychainItemWrapper.h”和“KeychainItemWrapper.m”拷贝到我们项目，并导入Security.framework 。KeychainItemWrapper的用法：</p>

<pre><code>/** 初始化一个保存用户帐号的KeychainItemWrapper */
KeychainItemWrapper *wrapper = [[KeychainItemWrapper alloc] initWithIdentifier:@"Account Number"
                                                                   accessGroup:@"YOUR_APP_ID_HERE.com.yourcompany.AppIdentifier"];  

//保存帐号
[
wrapper setObject:@"&lt;帐号&gt;" forKey:(id)kSecAttrAccount];    

//保存密码
[
wrapper setObject:@"&lt;帐号密码&gt;" forKey:(id)kSecValueData];    

//从keychain里取出帐号密码
NSString *password = [wrapper objectForKey:(id)kSecValueData];      

//清空设置
[
wrapper resetKeychainItem];
</code></pre>

<p>其中方法“- (void)setObject:(id)inObject forKey:(id)key;”里参数“forKey”的值应该是Security.framework 里头文件“SecItem.h”里定义好的key，用其他字符串做key程序会崩溃！</p>

<p>（二）SFHFKeychainUtils 提供了在 iOS keychain中安全的存储密码的工具</p>

<p>下载地址<a href="https://github.com/ldandersen/scifihifi-iphone/tree/master/security">https://github.com/ldandersen/scifihifi-iphone/tree/master/security</a></p>

<ul>
<li><p>1、引入Security.frameWork框架。</p></li>
<li><p>2、引入头文件：SFHKeychainUtils.h.</p></li>
<li><p>3、存密码：</p></li>
</ul>


<hr />

<pre><code>[SFHFKeychainUtils storeUsername:@"dd" andPassword:@"aa"forServiceName:SERVICE_NAME updateExisting:1 error:nil];

[SFHFKeychainUtils deleteItemForUsername:@"dd" andServiceName:SERVICE_NAME error:nil];
</code></pre>

<ul>
<li>4、取密码：</li>
</ul>


<hr />

<pre><code>NSString *passWord =  [SFHFKeychainUtils getPasswordForUsername:@"dd"andServiceName:SERVICE_NAME error:nil];
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SVN实战总结]]></title>
    <link href="http://al1020119.github.io/blog/2015/12/12/svnshi-zhan-zong-jie/"/>
    <updated>2015-12-12T22:44:29+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/12/12/svnshi-zhan-zong-jie</id>
    <content type="html"><![CDATA[<ul>
<li>A：add，新增</li>
<li>C：conflict，冲突</li>
<li>D：delete，删除</li>
<li>M：modify，本地已经修改</li>
<li>G：modify and merGed，本地文件修改并且和服务器的进行合并</li>
<li>U：update，从服务器更新</li>
<li>R：replace，从服务器替换</li>
<li>I：ignored，忽略</li>
</ul>


<p>常见提示图标：</p>

<h6>黄色感叹号(有冲突):</h6>

<pre><code>--这是有冲突了，冲突就是说你对某个文件进行了修改，别人也对这个文件进行了修改，别人抢在你提交之前先提交了，这时你再提交就会被提示发生冲突，而不允许你提交，防止你的提交覆盖了别人的修改。要解决冲突，如果你确认你的修改是无效的，则用TSVN还原你的修改就行了；如果认为你的修改是正确的，别人的提交是无效的，那么用TSVN先标记为“解决冲突”，然后就可以提交了；如果你认为你的修改和别人的修改都有一部分是有效的，那么你就把别人的修改手动合并到你的修改中，然后使用TSVN标注为“解决冲突”，然后就可以提交了。进入文件夹，寻找有黄色感叹号的文件，这些文件就是发生冲突的地方，根据实际情况处理冲突
</code></pre>

<!--more-->


<h6>米字号(有本地修改代码)：</h6>

<pre><code>--这是说明你有未提交的本地代码。
</code></pre>

<h6>问好(新加入的资源):</h6>

<pre><code>--这说明该文件是项目中新增文件资源，新增资源可以是文件、图片、代码等。
</code></pre>

<h6>红色感叹号(本地代码与库没有保持一致)：</h6>

<pre><code>--这说明本地代码跟库上没有保持一致，如果用户想修复，可以将带红色感叹号图标文件删除，直接update即可。
</code></pre>

<h6>灰色向右箭头(本地修改过)</h6>

<pre><code>--本地代码没有及时上库。
</code></pre>

<h6>蓝色向左箭头(SVN上修改过)</h6>

<pre><code>--记得更新代码后修改，提交前跟svn对比习惯。
</code></pre>

<h6>灰色向右且中间有个加号的箭头(本地比SVN上多出的文件)</h6>

<pre><code>--修改完记得跟svn保持一致
</code></pre>

<h6>蓝色向左且中间有个加号的箭头(SVN上比本地多出的文件)</h6>

<pre><code>--删除该文件后，再次更新，将svn上文件全部更新下来。
</code></pre>

<h6>灰色向右且中间有个减号的箭头(本地删除了,而SVN上未删除的文件)</h6>

<pre><code>--也就是说你删除确认后，一定要记得上库，跟svn保持一致
</code></pre>

<h6>蓝色向左且中间有个减号的箭头(SVN上删除了,而本地未删除的文件)</h6>

<pre><code>--比对svn库上代码，确定需要删除后，更新svn(删除无用代码)。
</code></pre>

<h6>红色双向箭头(SVN上修改过,本地也修改过的文件 )</h6>

<pre><code>--这个表示本地和svn上都修改过，最好就是把本地修改合并到svn，修改代码前最后先更新。
</code></pre>

<h4>版本回退</h4>

<ul>
<li><p>本地版本回退：</p>

<ul>
<li>右键选中对应的项目或者文件，弹出菜单中选中Revert</li>
<li>提示你当前工程有一些修改，但是还没提交，"Discard XXX"-点击后当前修改的内容会被取消，“Copy XXX”-点击会会先复制一份代码到废纸篓</li>
<li>点击 “Discard XXX”后，本地工程已更新至选择的版本，如果想将服务器上的也更新到选择的版本，可以再commit。</li>
</ul>
</li>
<li><p>服务器版本回退：误将错误的文件上传到了svn服务器，回滚的办法是：</p>

<ul>
<li>1：svn merge -r100:99 .  （注意有个点，表示当前路径）</li>
<li>2：svn ci -m &ldquo;revert version&rdquo; . （代码提交，实际上删除之前误传的文件）</li>
</ul>
</li>
</ul>


<h4>.a（库文件）</h4>

<ul>
<li>首先打开软件左上角 CornerStone-Preferences-SubVersion</li>
<li>第一个地方把对号去掉，第二个地方把.a那个删除，然后save。</li>
<li>然后把你的.a文件放到本地的相应文件夹下，</li>
<li>但是 CornerStone（我的是v2.7.10 版本的） 里相应文件夹下看不到带问号的.a文件的话，点击上边 View-Show Ignored  Items</li>
<li>到这里就ok了，选中你的静态库 点击底部Add 问号会变成A，然后就可以提交了。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[爬虫必备-java抓包]]></title>
    <link href="http://al1020119.github.io/blog/2015/12/11/java/"/>
    <updated>2015-12-11T12:03:23+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/12/11/java</id>
    <content type="html"><![CDATA[<p>前面我们介绍了怎么使用青花瓷和正则表达式抓包，今天就来介绍一下最后一篇：使用java抓包</p>

<p>java是大家再熟悉不过了，所以不用太担心有多难，因为里面涉及的java技术几乎为0（有点夸张），所以想想看完这篇之后你就会知道怎么使用java快速抓包，还能根据自己的喜好选择对应的方式！</p>

<p>我们开始吧！</p>

<p>前提：熟悉java语法（能看懂就行）</p>

<ul>
<li>准备阶段：从网页中获取html代码</li>
<li>实战阶段：将对应的html代码使用java语言解析出来，最后保存到plist文件</li>
</ul>


<!--more-->


<h2>一:准备阶段－－》获取html代码</h2>

<h6>1:打开你对应想要获取数据的网页，使用firefox打开（因为他有一个自带的神器叫：firebug，关于firebug这里就多说了，反正对于网页开发来说她就是神器），这里我们使用的是dota首页英雄的介绍。</h6>

<p>首先来看看我们需要的数据</p>

<p><img src="http://al1020119.github.io/images/ava001.png" title="Caption" ></p>

<h6>2:由于在网页开发中也是分模块开发的，所以一定的区域在html中对应对应的html代码模块，所以我们选取界面中一个小的模块作为练习。</h6>

<p>找到对应的模块，点击右键在firebug中查看元素</p>

<p><img src="http://al1020119.github.io/images/ava002.png" title="Caption" ></p>

<p>（确保已安装firebug，没有安装的去火狐工具栏中工具标签里面的一个附加组件搜索并下载安装就可以）</p>

<p>这个时候网页的下面就会显示对应模块的html代码，我们需要找到我们想要获取的数据对应的html模块代码，点击右键拷贝我们需要的html。</p>

<p> <img src="http://al1020119.github.io/images/ava003.png" title="Caption" ></p>

<h6>3:在界面简一个html文件将拷贝好的html代码粘贴到文件中，然后就需要哪么一丢丢的html相关知识了，就是补充html中的数据，使他成为完整的html文件</h6>

<p><img src="http://al1020119.github.io/images/ava004.png" title="Caption" ></p>

<p>这里注意一下编码方式：开发中常用的都是utf－8的格式</p>

<h2>二:实战阶段－－》抓取html（网页数据）</h2>

<p>然后我们就要正式开工了，后面才是重点，前面那都是傻瓜是的操作（后面的才做中需要有那么一丢丢的java或者android开发的基础，当然不会耶没有关系，笔者会完整的介绍流程）</p>

<h6>1:代开Eclipse</h6>

<p><img src="http://al1020119.github.io/images/ava005.png" title="Caption" ></p>

<p>新建一个java项目，并且点击项目中的src新建一个class专门用来实现数据的解析</p>

<p><img src="http://al1020119.github.io/images/ava006.png" title="Caption" ></p>

<h6>2:新建好项目之后就要用到我们的一个java的jar包，专门用来抓取网络数据的包：关于包的下载后面笔者会给出下载链接</h6>

<p><img src="http://al1020119.github.io/images/ava007.png" title="Caption" ></p>

<p>将下载好的jar包导入到java工程项目中。</p>

<p>然后我们需要将他添加到build路径（这里是一个常识，java中的jar包没有添加到build路径是不能使用的，添加之后对应的咖啡图标会变成奶瓶）</p>

<p><img src="http://al1020119.github.io/images/ava008.png" title="Caption" ></p>

<p>成功之后的显示</p>

<p><img src="http://al1020119.github.io/images/ava009.png" title="Caption" ></p>

<p>下面开始使用java正式抓取并解析html（网页）数据</p>

<p>根据下面的图片在java工程项目中书写html数据解析的代码：（注意里面的步骤）</p>

<p><img src="http://al1020119.github.io/images/ava0010.png" title="Caption" ></p>

<p>java核心代码：</p>

<pre><code>try {

　　　　　　//文件路径

　　　　　　　　String path = " /Users/icocos/Desktop/iCocos.html";



　　　　　　　　//加载网页

　　　　　　　　Document doc = Jsoup.parse(new File(path), "UTF-8");



　　　　　　　　//解析网页

　　　　　　　　Elements lis = doc.select("li");



　　　　　　　 //遍历数组

　　　　　　　　for(int i = 0; i &lt; eles.size(); i++) {

　　　　　　　　//根据i获取对应的元素

　　　　　　　　Element li = lis.get(i);



　　　　　　　　//取图片

　　　　　　　　Element img = li.select("img").get(0);

　　　　　　　　// System.out.println(img.attr("src"));



　　　　　　　　//获取图片名

　　　　　　　　String imgName = img.attr("src");



　　　　　　　 Element p = li.select("p").get(0);

　　　　　　　　String personName = p.text();



　　　　　　　　//打印数据

　　　　　　　　System.out.println(imgName + "," + personName);



　　　　　　}

　　　　　} catch {

　　　　//错误（异常）处理

　　　　e.printStackTrace();

}
</code></pre>

<p>此时点击Run运行之后，Eclipse就会根据你的代码输出对应的信息</p>

<p><img src="http://al1020119.github.io/images/ava011.png" title="Caption" ></p>

<p>但是这个时候我并不能直接使用数据所以需要在java代码中做一些相应的修改，使得输出的数据可以直接拷贝并且读到plist中，其实就是数组或者字典数据</p>

<p>我们知道在ios开发中从plist文件中读取数据时最常见的，当然你也可以使用其他方式，但是没有比这更简单了。</p>

<p>下面我给java代码做一些调整</p>

<p>1:在for循环之前输入这一行代码，实现数据拼接并且数据</p>

<pre><code>System.out.println("NSArray *apps = @[");
</code></pre>

<p>2:接着就需要在for循环结束之后输入预知对应的拼接数组结尾标志</p>

<pre><code>System.out.println("]");
</code></pre>

<p>3:在for循环内部的最后面我们需要在每次循环的时候都要使用上面的代码进行拼接并且使用逗号做相应的分割</p>

<pre><code>System.out.println("@{@\"name\":@\"" + personName + "\", @\"icon\":@\""+ imgName + "\"},");
</code></pre>

<p>最后完整的java获取并且解析html数据如下；</p>

<pre><code>public class iCocos {

public static void main (String[] args) {

　　　 try {

　　　　　　//文件路径

　　　　　　String path = " /Users/icocos/Desktop/iCocos.html";

　　　　　　//加载网页
　　　　　　Document doc = Jsoup.parse(new File(path), "UTF-8");

　　　　　　//解析网页
　　　　　　Elements lis = doc.select("li");

　　　　　　System.out.println("NSArray *apps = @[");


　　　　　　//遍历数组

　　　　　　for(int i = 0; i &lt; eles.size(); i++) {

　　　　　　//根据i获取对应的元素

　　　　　　Element li = lis.get(i);


　　　　　　//取图片

　　　　　　Element img = li.select("img").get(0);

　　　　　　// System.out.println(img.attr("src"));

　　　　　　//获取图片名

　　　　　　String imgName = img.attr("src");

　　　　　　Element p = li.select("p").get(0);

　　　　　　String personName = p.text();

　　　　　　//打印数据
　　　　　　// System.out.println(imgName + "," + personName);

　　　　　　System.out.println("@{@\"name\":@\"" + personName + "\", @\"icon\":@\""+ imgName + "\"},");
　　　　　　}
　　　　　　System.out.println("]");

　　　　} catch {

　　　　　　//错误（异常）处理
　　　　　　e.printStackTrace();

　　　　}

　　}

}
</code></pre>

<p>这个时候回打印输出下面的代码，</p>

<p><img src="http://al1020119.github.io/images/ava012.png" title="Caption" ></p>

<p>下面我们就需要在xcode中做事情了，做什么事呢，就是将输出的以NSArray开头的所有数据在Xcode中转换为plist的数据，当然你也可以不转换，做少部分的修改之后直接使用JSON解析技术去解析，但是那样不是最好的办法。</p>

<p>在Xcode中新建一个项目工程，在ViewDidLoad中粘贴拷贝过来的代码，这个时候是不是看起来非常熟悉，对了，她就是我吗开发中常用到的数组数据。</p>

<p>下面我就使用循环遍历去讲NSArray数组数据写到plist文件中。</p>

<pre><code>- (void)viewDidLoad

{

    [super viewDidLoad];



    NSArray *apps = @[

  @{@"name":@"敌法师", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/dfss.jpg"},

  @{@"name":@"火枪", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/arjj.jpg"},

  @{@"name":@"德鲁伊", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/dlyy.jpg"},

  @{@"name":@"月骑", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/yzqs.jpg"},

  @{@"name":@"变体精灵", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/btjl.jpg"},

  @{@"name":@"娜迦海妖", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/njhy.gif"},

  @{@"name":@"猴子", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/hycm.jpg"},

  @{@"name":@"白虎", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/yzjs.jpg"},

  @{@"name":@"隐形刺客", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/yxck.jpg"},

  @{@"name":@"巨魔", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/jmzj.jpg"},

  @{@"name":@"直升机", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/arzs.jpg"},

  @{@"name":@"赏金猎人", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/Naka.gif"},

  @{@"name":@"骷髅射手", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/KLSS.gif"},

  @{@"name":@"育母蜘蛛", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/YMZZ.gif"},

  @{@"name":@"血魔", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/XM.gif"},

  @{@"name":@"黑暗游侠", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/Nbrn.gif"},

  @{@"name":@"虚空假面", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/EC45.gif"},

  @{@"name":@"蛇发女妖", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/H00V.gif"},

  @{@"name":@"地卜师", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/H00I.gif"},

  @{@"name":@"地穴刺客", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/DXCK.gif"},

  @{@"name":@"蚂蚁", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/DXBZ.gif"},

  @{@"name":@"幻影刺客", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/HYCK.gif"},

  @{@"name":@"闪电幽魂", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/E002.gif"},

  @{@"name":@"影魔", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/YM01.gif"},

  @{@"name":@"小鱼人", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/yryx.gif"},

  @{@"name":@"幽鬼", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/YG1.gif"},

  @{@"name":@"圣堂刺客", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/E01Y.gif"},

  @{@"name":@"灵魂守卫", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/LHSW.gif"},

  @{@"name":@"熊战士", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/Huth.gif"},

  @{@"name":@"剧毒术士", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/JDSS.gif"},

  @{@"name":@"冥界亚龙", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/MJYL.gif"},

  @{@"name":@"复仇之魂", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/Hvwd.jpg"},

  @{@"name":@"剑圣", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/jsjs.jpg"}

  ];



    [newApps writeToFile:@"/Users/icocos/Desktop/apps.plist" atomically:YES];
</code></pre>

<p>这个时候我吗的左面就有了这个plist文件，打开之后你会看到</p>

<p><img src="http://al1020119.github.io/images/ava013.png" title="Caption" ></p>

<p>最后的步骤就是图片的下载，</p>

<pre><code>//简单写入

//    for (NSDictionary *dict in apps) {

//        NSString *icon = dict[@"icon"];

//        

//        // 新建网络图片的URL路径

//        NSURL *url = [NSURL URLWithString:icon];

//        

//        // 下载图片的二进制数据

//        NSData *data = [NSData dataWithContentsOfURL:url];

//        

//        // 截取文件名

//        NSString *filename = [icon lastPathComponent];

//        

//        // 文件路径

//        NSString *iconPath = [NSString stringWithFormat:@"/Users/icocos/Desktop/Icons/%@", filename];

//        

//        [data writeToFile:iconPath atomically:YES];

//    }
</code></pre>

<p>由于plist中图片名使用的都是对应链接的最后一个名字，所以我们不能使用上面的方法，还需要做一些处理，才能真正使用</p>

<pre><code>NSMutableArray *newApps = [NSMutableArray array];

    for (NSDictionary *dict in apps) {

        NSMutableDictionary *newDict = [NSMutableDictionary dictionary];

        newDict[@"name"] = dict[@"name"];

        newDict[@"icon"] = [dict[@"icon"] lastPathComponent];

        [newApps addObject:newDict];

    }



    [newApps writeToFile:@"/Users/icocos/Desktop/apps.plist" atomically:YES];



}
</code></pre>

<p><img src="http://al1020119.github.io/images/ava014.png" title="Caption" ></p>

<p>图片下载完成之后你会回看到对应的文件夹中快速的出现了好多的图片</p>

<p><img src="http://al1020119.github.io/images/ava015.png" title="Caption" ></p>

<p>此时我们就得到了一份和网页想相对应比较完整的plist数据，后面我们要做的就是将我们的plist数据显示到界面，后面我就不介绍了，详细请看：plist文件读取</p>

<blockquote><p>最后总结一下，如果以后遇到了关于需要抓取网络数据实现网络爬虫的功能的时候，我们基本上想到的第一种方法就是使用java语言，当然公司一般不会有这样的要求，公司一般都是使用自己服务器的api来实现，特殊情况除外。</p></blockquote>

<p>当然你也可以使用正则表达式或者Python，关于正则表达式相对来说还是比较难的，主要是细节比较多。而Python本人还没有研究过，有机会尝试一下，如果您还有什么好的方法欢迎笔者联系，相互学习与讨论。</p>

<p>我们基本上可以按照上面的思路去实现，只需要做少部分的修改，这里大致说一下</p>

<ul>
<li>1:准备阶段根据你需要的数据会有不同的html产生</li>
<li>2:产生不同的html之后你html内部的结构就会做响应的变化，这个时候你就要去把java那段核心代码搞懂来就没问题了，最重要的还是这里。</li>
<li>3:根据对应的NSArray数据写入到plist文件中，这里是iOS开发中常用的技术我就不多说。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[爬虫必备-Phthon抓包]]></title>
    <link href="http://al1020119.github.io/blog/2015/12/11/pa-chong-bi-bei-phthonzhua-bao/"/>
    <updated>2015-12-11T11:03:23+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/12/11/pa-chong-bi-bei-phthonzhua-bao</id>
    <content type="html"><![CDATA[<p>由于最近都在研究网络爬虫技术，自己也总结了一些。接住一个朋友（boyXiong）的博文，了解到了python抓包技术，所以就整理到这里，希望你能喜欢！</p>

<h4>准备搭建环境</h4>

<p>因为是MAC电脑，所以自动安装了Python 2.7的版本</p>

<p>添加一个 库 Beautiful Soup ,方法这里说两种</p>

<ul>
<li>1.在终端输入 pip install BeautifulSoup</li>
<li>2.手动下载包后，终端切换到 解压的文件夹，输入 sudo python setup.py install 下载地址BeautifulSoup</li>
</ul>


<!--more-->


<h4>开始写代码吧</h4>

<p>先找一个想要抓取东西的网站，这里我就随便找一个吧 地址是：<a href="http://movie.douban.com/chart">http://movie.douban.com/chart</a>
好了在终端输入 vim 我知道这个东西，对于新手来说，就是一个挑战，这里我也建议使用轻量的Sublime
代码如下 (注意python是严格的缩进,以下代码要顶格写)</p>

<pre><code>#-*- coding:utf-8 -*-
import urllib2
import urllib
html=urllib2.urlopen("http://movie.douban.com/chart").read()
print html
</code></pre>

<p>输出的结果就是一个HTML的网页，这里我就看到自己想要抓取的图片和图片名的文字片段</p>

<pre><code>&lt;a class="nbg" href="http://movie.douban.com/subject/24879839/"  title="道士下山"&gt;
           &lt;img src="http://img3.douban.com/view/movie_poster_cover/ipst/public/p2251450614.jpg" alt="道士下山" class=""/&gt;
&lt;/a&gt;
</code></pre>

<p>分析我们想要的，一个是图片的名称，一个是图片的链接地址，直接上Python代码
    #-<em>- coding:utf-8 -</em>-
    import urllib2
    from bs4 import BeautifulSoup</p>

<pre><code>import sys  
reload(sys)  
sys.setdefaultencoding('utf8')

# 函数
def  printPlistCode():
    #1.得到这个网页的 html 代码 #
    html = urllib2.urlopen("http://movie.douban.com/chart").read()

    #2.转换 一种格式，方便查找
    soup = BeautifulSoup(html)
    #3.  得到 找到的所有 包含 a 属性是class = nbg 的代码块,数组
    liResutl = soup.findAll('a', attrs = {"class" : "nbg"})
    #4.用于拼接每个字典的字符串
    tmpDictM = ''

    #5. 遍历这个代码块  数组
    for li in liResutl:

        #5.1 找到 img 标签的代码块 数组
        imageEntityArray = li.findAll('img')

        #5.2 得到每个image 标签
        for image in imageEntityArray:
            #5.3 得到src 这个属性的 value  后面也一样 类似 key value
            link = image.get('src')
            imageName = image.get('alt')
            #拼接 由于 py中 {} 是一种数据处理格式，类似占位符
            tmpDict = '''@{0}@\"name\" : @\"{1}\", @\"imageUrl\" : @\"{2}\"{3},'''

            tmpDict =  tmpDict.format('{',imageName,link,'}')

            tmpDictM = tmpDictM + tmpDict

    #6.去掉最后一个 , 
    tmpDictM = tmpDictM[0:len(tmpDictM) - 1].decode('utf8')

    #7 拼接全部
    restultStr = '@[{0}];'.format(tmpDictM)

    print restultStr


if __name__ == '__main__':
    printPlistCode()
</code></pre>

<p>输出结果就是Objective-C的 数组</p>

<pre><code>@[@{@"name" : @"进击的巨人真人版：前篇", @"imageUrl" : @"http://img3.douban.com/view/movie_poster_cover/ipst/public/p2251690571.jpg"},@{@"name" : @"花与爱丽丝杀人事件", @"imageUrl" : @"http://img3.douban.com/view/movie_poster_cover/ipst/public/p2222398443.jpg"},@{@"name" : @"小黄人大眼萌", @"imageUrl" : @"http://img4.douban.com/view/movie_poster_cover/ipst/public/p2258235689.jpg"},@{@"name" : @"小森林 冬春篇", @"imageUrl" : @"http://img4.douban.com/view/movie_poster_cover/ipst/public/p2215147728.jpg"},@{@"name" : @"道士下山", @"imageUrl" : @"http://img3.douban.com/view/movie_poster_cover/ipst/public/p2251450614.jpg"},@{@"name" : @"深夜食堂 电影版", @"imageUrl" : @"http://img3.douban.com/view/movie_poster_cover/ipst/public/p2205014862.jpg"},@{@"name" : @"小男孩", @"imageUrl" : @"http://img4.douban.com/view/movie_poster_cover/ipst/public/p2230105606.jpg"},@{@"name" : @"头脑特工队", @"imageUrl" : @"http://img4.douban.com/view/movie_poster_cover/ipst/public/p2231021196.jpg"},@{@"name" : @"百元之恋", @"imageUrl" : @"http://img4.douban.com/view/movie_poster_cover/ipst/public/p2205471169.jpg"},@{@"name" : @"杀破狼2", @"imageUrl" : @"http://img4.douban.com/view/movie_poster_cover/ipst/public/p2246885606.jpg"}];
</code></pre>

<p>使用Xcode 写到Plist中去</p>

<pre><code>#import &lt;Foundation/Foundation.h&gt;

int main(int argc, const char * argv[]) {


NSArray *plistArray = @[@{@"name" : @"进击的巨人真人版：前篇", @"imageUrl" : @"http://img3.douban.com/view/movie_poster_cover/ipst/public/p2251690571.jpg"},@{@"name" : @"花与爱丽丝杀人事件", @"imageUrl" : @"http://img3.douban.com/view/movie_poster_cover/ipst/public/p2222398443.jpg"},@{@"name" : @"小黄人大眼萌", @"imageUrl" : @"http://img4.douban.com/view/movie_poster_cover/ipst/public/p2258235689.jpg"},@{@"name" : @"小森林 冬春篇", @"imageUrl" : @"http://img4.douban.com/view/movie_poster_cover/ipst/public/p2215147728.jpg"},@{@"name" : @"道士下山", @"imageUrl" : @"http://img3.douban.com/view/movie_poster_cover/ipst/public/p2251450614.jpg"},@{@"name" : @"深夜食堂 电影版", @"imageUrl" : @"http://img3.douban.com/view/movie_poster_cover/ipst/public/p2205014862.jpg"},@{@"name" : @"小男孩", @"imageUrl" : @"http://img4.douban.com/view/movie_poster_cover/ipst/public/p2230105606.jpg"},@{@"name" : @"头脑特工队", @"imageUrl" : @"http://img4.douban.com/view/movie_poster_cover/ipst/public/p2231021196.jpg"},@{@"name" : @"百元之恋", @"imageUrl" : @"http://img4.douban.com/view/movie_poster_cover/ipst/public/p2205471169.jpg"},@{@"name" : @"杀破狼2", @"imageUrl" : @"http://img4.douban.com/view/movie_poster_cover/ipst/public/p2246885606.jpg"}];
//路径可以自己选择
[plistArray writeToFile:@"/Users/xxx/Desktop/test/movie.plist" atomically:YES];

return 0;
</code></pre>

<p>到这里，就可以看到plist 文件可以用于测试了</p>

<p><img src="http://al1020119.github.io/images/python001.png" title="Caption" ></p>

<p>这里写图片描述
如果想要复制粘贴这里面的代码，那就选择Sublime编辑器</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[爬虫必备-正则表达式抓包]]></title>
    <link href="http://al1020119.github.io/blog/2015/12/11/zhengze/"/>
    <updated>2015-12-11T10:03:23+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/12/11/zhengze</id>
    <content type="html"><![CDATA[<p>第一篇我们有介绍到使用青花瓷抓包，也提到了后面会介绍java和python实现，本篇就介绍一下怎么使用python抓取网络数据。</p>

<p>先来看看网络爬虫的基本原理：</p>

<p>一个通用的网络爬虫的框架如图所示：</p>

<p><img src="http://al1020119.github.io/images/zhengze001.png" title="Caption" ></p>

<!--more-->


<h5>网络爬虫的基本工作流程如下：</h5>

<ol>
<li><p>首先选取一部分精心挑选的种子URL；</p></li>
<li><p>将这些URL放入待抓取URL队列；</p></li>
<li><p>从待抓取URL队列中取出待抓取在URL，解析DNS，并且得到主机的ip，并将URL对应的网页下载下来，存储进已下载网页库中。此外，将这些URL放进已抓取URL队列。</p></li>
<li><p>分析已抓取URL队列中的URL，分析其中的其他URL，并且将URL放入待抓取URL队列，从而进入下一个循环。</p></li>
</ol>


<p>以下内容均为本人个人理解。</p>

<p>网络数据抓取</p>

<ol>
<li>概念：网络数据抓取，也叫网络爬虫。是在我们iOS程序中，获取要抓取到的网页上的数据。</li>
<li>用处：如果要用到某网站的一些数据，这个时候我们就要用到抓取数据技术。</li>
<li>建议：建议抓取过程中，多利用分类，多写一些分类方法，有助于提高程序可读性，也可提高效率。</li>
</ol>


<p>今天先来介绍一下第一种：正则表达式</p>

<blockquote><p>注意点：其实网络抓取数据很简单，但是有用到正则表达式，这个有人说难，有人说很难，有人说非常难，其实我们抓取数据只会用到“.&ldquo; 、&rdquo;*&ldquo;、&rdquo;?&ldquo;这三个符号！</p></blockquote>

<p>正则表达式中：“.”是包括任何字符不包括换行符，“*”是任意多个的字符，“？”是指到最近的一个URL，如果没有就是到最远的一个！</p>

<pre><code> NSString *pantten = [NSString stringWithFormat:@"&lt;ul class=\"cs_list\"&gt;(.*?)&lt;/ul&gt;"];

 NSRegularExpression *regx = [NSRegularExpression regularExpressionWithPattern:pantten options:NSRegularExpressionCaseInsensitive |NSRegularExpressionDotMatchesLineSeparators error:NULL];
</code></pre>

<p>其中有两个参数需要大家了解一下，很重要</p>

<ul>
<li>NSRegularExpressionCaseinsensitive 不区分大小写</li>
<li>NSRegularExpressionDotMatcheLineSeparators 让“点”字符可以匹配换行符</li>
</ul>


<p>抓数据，其实主要会写匹配字符串就行</p>

<pre><code>(.*?)表示要抓到的内容
.*?表示要忽略的内容，爱是啥是啥
字符串转义双引号用\转义括号用\\
</code></pre>

<p>在开发项目的过程，很多情况下我们需要利用互联网上的一些数据，在这种情况下，我们可能要写一个爬虫来爬我们所需要的数据。一般情况下都是利用正则表达式来匹配Html,获取我们所需要的数据。一般情况下分以下三步。</p>

<ul>
<li>1、获取网页的html</li>
<li>2、利用正则表达式，获取我们所需要的数据</li>
<li>3、分析，使用获取到的数据，（例如，保存到数据库）</li>
</ul>


<p>接下来我们分析代码：</p>

<h3>1、获取网页的html</h3>

<p>　　对于一些网页，不需要提交Post提交数据时，我们可以简单的利用NSURL类来获取我们所需要的html，交将其转换中kCFStringEncodingGB_18030_2000格式，解决中文乱码问题。</p>

<p>　　</p>

<pre><code>+(NSString*) urlstring:(NSString*)strurl{
　　　　NSURL *url = [NSURL URLWithString:strurl];
　　　　NSData *data = [NSData dataWithContentsOfURL:url];

　　　　NSStringEncoding enc = CFStringConvertEncodingToNSStringEncoding(kCFStringEncodingGB_18030_2000); 
　　　　NSString *retStr = [[NSString alloc] initWithData:data encoding:enc];

　　　　//NSLog(@" html = %@",retStr);

　　　　return retStr;
　　}
</code></pre>

<p> 对于需要Post提交数据的网页，我们可以利用强大的ASIFormDataRequest类来实现，例如：</p>

<pre><code>+(void)getPostResult:(NSString*)startqi{
　　　　ASIFormDataRequest *request = [[ASIFormDataRequest alloc] initWithURL:[NSURL URLWithString:URLPost]];

　　　　[request setPostValue:startqi forKey:@"startqi"];
　　　　[request setPostValue:@"20990101001" forKey:@"endqi"];
　　　　[request setPostValue:@"qihao" forKey:@"searchType"];//网页的中的搜索方式
　　　　[request startSynchronous];

　　　　NSData* data = [request responseData];

　　if (data==nil) {
　　　　FCLOG(@"has not data");
　　}
　　else{
　　　　NSStringEncoding enc = CFStringConvertEncodingToNSStringEncoding(kCFStringEncodingGB_18030_2000); 
　　　　NSString *retStr = [[NSString alloc] initWithData:data encoding:enc];
　　　　FCLOG(@"html = %@",retStr); 
　　}
}
</code></pre>

<p>这样的话，我们就通过了两种方式获取了我们所需要的html</p>

<h3>2、分析html</h3>

<p>　　关于利用正则表达式匹配问题，我又对NSString类扩展了一个方法-(NSMutableArray <em>)substringByRegular:(NSString </em>)regular。根据传入的正则表达式，返回所有匹配的数组。</p>

<p>　　</p>

<pre><code>@implementation NSString(StringRegular)


-(NSMutableArray *)substringByRegular:(NSString *)regular{

  　　　　　NSString * reg=regular;

　　　　　　NSRange r= [self rangeOfString:reg options:NSRegularExpressionSearch];

　　　　　　NSMutableArray *arr=[NSMutableArray array];

　　　　　　if (r.length != NSNotFound &amp;&amp;r.length != 0) {

　　　　　　int i=0;

　　　　　　while (r.length != NSNotFound &amp;&amp;r.length != 0) {

　　　　　　FCLOG(@"index = %i regIndex = %d loc = %d",(++i),r.length,r.location);

　　　　　　NSString* substr = [self substringWithRange:r];

　　　　　　FCLOG(@"substr = %@",substr);

　　　　　　[arr addObject:substr];

　　　　　　NSRange startr=NSMakeRange(r.location+r.length, [self length]-r.location-r.length);

　　　　　　r=[self rangeOfString:reg options:NSRegularExpressionSearch range:startr];
　　　　}
　　}
　　return arr;
}
@end
</code></pre>

<p>在这种情况下，我们首先我得到我们要获取数据的正则表达式，关于正则表达式这种火星文我就不多说了，我也很纠结，我就不多说了，但是有一点就是，所写的正则表达式一定是我们所需要的数据，并且能够屏蔽无效信息的，有可能在一次匹配中无法获取，可以多次利用正则表达式来分段获取。下面是我的语句，在我的例子中，就是两次利用正则表达式。</p>

<pre><code>NSString *regstr = @"&lt;td class=\'z_bg_05\'&gt;\\w{11}&lt;/td&gt;&lt;td class=\'z_bg_13\'&gt;(\\w{2}\\s{0,1})*&lt;/td&gt;";
NSMutableArray *arr=[strhtml substringByRegular:regstr];
</code></pre>

<h3>3、分析或利用数据，在这里，我只是利用上一篇博客上所述方法简单的把这些数据保存到了数据库（sqlite3）中。</h3>

<p>其实在这个arr数组中一条就是对应我数据库表中的一条记录，但是像td class等这些信息我是不需要的，所以再次利用正则表达式来分析NSString</p>

<pre><code>if (arr!=nil&amp;&amp;[arr count]&gt;0) {

　　　　　　NSString *prereg=@"\\w{11}";
　　　　　　NSString *backreg=@"(\\w{2}\\s{0,1}){8}";

　　　　　　TicketResultService *service=[[TicketResultService alloc] init];
　　　　　　[[Sqlite3Helper Instance] openDB];
　　　　for (NSString *sub in arr) {

　　　　　　TicketResult* r=[[[TicketResult alloc] init] autorelease];

　　　　　　NSMutableArray* prearr=[sub substringByRegular:prereg];

　　　　　　if (prearr!=nil&amp;&amp;[prearr count]&gt;0) {
　　　　　　　　r.sectionID=(NSString*)[prearr objectAtIndex:0];
　　　　　　}
　　　　　　else{
　　　　　　　　continue;
　　　　　　}

　　　　　　NSMutableArray *backarr=[sub substringByRegular:backreg];
　　　　　　if (backarr!=nil&amp;&amp;[backarr count]&gt;0) {
　　　　　　r.result=[backarr objectAtIndex:0];
　　　　　　}
　　　　　　else{
　　　　　　　　continue;
　　　　　　}

　　　　　　if([service isExist:r.sectionID]){
　　　　　　　　continue;
　　　　　　}

　　　　r.type=[NSNumber numberWithInt:1];

　　　　[service addModel:r];

　　}
　　[[Sqlite3Helper Instance] closeDB];

　　[service release];
}
</code></pre>

<blockquote><p>以上爬虫才算正式完成，其实，在此之前还有一个第0步，即判断设备目前的网络状态，如果没有联网的就没有必要去爬虫了，因为你也爬不到任何的数据。判断网络状态我是利用Apple官方的一个例子Reachability，网上也有很多关于这个的例子，我就不再细说了，非常感谢网上的各位大牛们提供的很好的办法，让我能更快的写出这些。</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[爬虫必备-青花瓷抓包]]></title>
    <link href="http://al1020119.github.io/blog/2015/12/11/qinghuaci/"/>
    <updated>2015-12-11T09:03:23+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/12/11/qinghuaci</id>
    <content type="html"><![CDATA[<p>在之前个人学习ios开发的时候听过抓包相关的技术，但是自己没有实现，所以也只是当听听。</p>

<p>这段时间，由于公司新项目的原因，但是后台和UI都还没有，而又需要我先开始封装对应的工具或者一下大概的逻辑，我当时就蒙了，最后还是乖乖的来做。</p>

<p>网上找了一些接口，也找了不少类似的网站，但是发现再美我用不了有什么用呢？最后我想到了之前听别人说的网络爬虫，找了不少资料研究了一番。发现效果还不错，就在这里记录下来，希望对你有用！</p>

<p>关于网络数据抓取不仅仅在iOS开发中有，其他开发中也有，也叫网络爬虫，大致分为三种方式实现</p>

<ul>
<li>1: 青花瓷</li>
<li>2: 正则表达</li>
<li>3: 利用其他语言的工具包：java／Python</li>
</ul>


<p>写本文的契机主要是前段时间有次用青花瓷抓包有一步忘了，在网上查了半天也没找到写的完整的教程，于是待问题解决后抽时间截了图，自己写一遍封存在博客园中以便以后随时查阅。</p>

<!--more-->


<p>charles又名青花瓷，在iOS开发中的抓包中具有重要作用。最大的三点用处，一就是拦截别人软件的发送的请求和后端接口，练习开发。二是自己后端返回的response拦截修改后再接收以达到测试临界数据的作用。三写脚本重复拦截抓取别人的数据。(因为不太道德，本文不提第三点)</p>

<p>如果你不是在董铂然博客园看到本文，请点击查看原文。</p>

<h3>1.开始之前的准备工作</h3>

<p>首先安装一下这个软件</p>

<p>这个相信很多人电脑里应该都安装了，没安装的搜charles破解版也能很容易搜到。如果没安装java环境，首次进入charles会提示让你安装java包得，直接给你链接是苹果官网的，去下一个一键安装就行了。</p>

<p> <img src="http://al1020119.github.io/images/qinghuaci001.jpg" title="Caption" ></p>

<p>安装完成后先打开，在进行下面操作。</p>

<p>然后去自己电脑的系统偏好设置-》网络-》选中现在连着的网(大部分人应该都是WiFi吧)可以查到自己这个电脑在现在这个wifi里的IP地址，比如我现在这个就是192.168.0.105(建议最好用私人网络，用公司网络的话可能会有限制会出现没反应的问题)</p>

<p><img src="http://al1020119.github.io/images/qinghuaci002.jpg" title="Caption" ></p>

<p>然后找到自己手机也连着这个同名的wifi，然后选中右边的蓝色i。</p>

<p> <img src="http://al1020119.github.io/images/qinghuaci003.jpg" title="Caption" ></p>

<p><img src="http://al1020119.github.io/images/qinghuaci004.jpg" title="Caption" ></p>

<p>然后进入到了这个无线局域网的高级设置页面。进去之后拉到最下方，找到HTTP代理字样。然后选中手动代理，并在服务器中填自己电脑查到的ip地址，然后把端口调8888，最后点击左上角返回。返回值后系统会自动设置代理重新连接。</p>

<p>这时候你的手机上网的过程中就要经过你的电脑了。刚用手机打开一个联网的程序，你的电脑上应该会显示一个弹窗问你【allow】还是【deny】肯定不能拒绝啊就点allow吧。这个只有第一次才弹窗，图没截上，你到时候看见肯定能看懂的。点了同意之后你手机发出的每一个请求都会被拦截出痕迹。</p>

<h3>2.拦截某个软件的接口数据</h3>

<p>拿网易新闻举例，以前就练习这写过网易新闻的项目，其中网易的接口全是用charles拦截的。拦截到了网易发请求时发的是什么，然后在练习项目中需要获取数据的地方也把这一串链接直接拿过来用即可。</p>

<p><img src="http://al1020119.github.io/images/qinghuaci005.jpg" title="Caption" ></p>

<p>当然这上面拦到的比较多，如果有过开发经验的话应该能很快看出来右边哪个是真正返回json数据的接口。或者一个一个点看内容也行啊。</p>

<p>比如选中一个url然后右键点击copy。</p>

<p><img src="http://al1020119.github.io/images/qinghuaci006.jpg" title="Caption" ></p>

<p>放到浏览器地址栏里打一下。能看到</p>

<p><img src="http://al1020119.github.io/images/qinghuaci007.jpg" title="Caption" ></p>

<p>这就说明这个接口是对的了。可以获取到数据。然后可以给他转化一下看的更清楚。虽然很多人都是用bash看，但我还是推荐一个网址<a href="http://www.w3cschool.cc/jsontool">http://www.w3cschool.cc/jsontool</a>。转JSON之后看的非常清晰。大部分软件json整理后都是默认把大括号全都打开，而仅有这个网站是默认全给你把大括号关上。想点哪个再点开，而且能知道字典里有多少个键值对，所以看着非常清晰。</p>

<p><img src="http://al1020119.github.io/images/qinghuaci008.jpg" title="Caption" ></p>

<p>到此就已经完成了一次完整的，拉取接口，和获得数据。</p>

<p>这里有两点我想说下：</p>

<p>①就是如果这个App发的请求加密了或是RSA什么的，这个就算拦截了你也弄不到数据。网易是没有做任何加密，所以可以抓取到数据。以前试了拦截百度医生的就不行。他设置的是一分钟内能获取到数据，超过了1分钟这个复制过来的接口就取不到数据了。怀疑可能是用的HMAC方法加密，并且在里面加入了时间判断。32分和33分发出的请求经过编码后是不一样的，后台可能做了容错，会把32分和31分都和你判断下，只要有一个对上就让你过，但是超过了整整一分钟后是肯定获取不到数据了。</p>

<p>②就是很多比较大型的网站，一般会开放一个开发者平台，里面注册开发者账号后会向你公开一个接口文档，你不用再去费事的拦截了。像新浪微博和大众点评都有开发者平台。</p>

<h3>3.更改返回数据来测试临界情况</h3>

<p>这个是重点了。因为这种做法可以让一个iOS前端的开发人员独立完成测试而不用拉过来一个后端一起联调。并且各种特殊维度，或是临界的账号也不用再去辛苦找了，仅仅自己在青花瓷上改来改去就可以达到效果了。比如这个地方如果返回了nil程序会不会崩，直接改response就行了。下面是具体操作方案。</p>

<p>打开青花瓷切换成结构页面</p>

<p><img src="http://al1020119.github.io/images/qinghuaci009.jpg" title="Caption" ></p>

<p>这里可以看到断点和调试信息</p>

<p><img src="http://al1020119.github.io/images/qinghuaci010.jpg" title="Caption" ><br/>
<img src="http://al1020119.github.io/images/qinghuaci011.jpg" title="Caption" ></p>

<p>然后找一个我们公司的页面。这个页面本来应该返回是这样的：如上图右边</p>

<p>你先正常的打开这个页面把玩几下，这个青花瓷就会抓取很多接口和域名分类了。在这里找到你这个页面所属的域名分类应该不难。然后打上断点。这里要注意是在域名上打断点而不是在下面的单个请求上打断点。</p>

<p>再次用手机进入这个页面，就会通过你刚才打断点的那个域名来请求数据，就会被断点拦住，如下图所示。</p>

<p><img src="http://al1020119.github.io/images/qinghuaci012.jpg" title="Caption" ></p>

<p>右边的信息也很清晰，一开始可以编辑请求。如果点击单步执行，等一下相应回来了也可以编辑响应。</p>

<p><img src="http://al1020119.github.io/images/qinghuaci013.jpg" title="Caption" ></p>

<p><img src="http://al1020119.github.io/images/qinghuaci014.jpg" title="Caption" ></p>

<p>这里的有好几种查看的方式，但是推荐使用JSON Text看的比较清楚。 现在我们对拦截回来的数据进行修改，我把这些统计数据全改成999如下图</p>

<p> <img src="http://al1020119.github.io/images/qinghuaci015.jpg" title="Caption" ></p>

<p>然后再次点击下方的Execute单步执行，更改后的数据就会像正常返回回来的数据那样显示到，APP的页面上展示。</p>

<p><img src="http://al1020119.github.io/images/qinghuaci016.jpg" title="Caption" ></p>

<p>能来到这一步就说明已经完整的掌握了用青花瓷篡改返回数据测试App的技术。</p>

<p>如果你不是在董铂然博客园看到本文，请点击查看原文。</p>

<p>这么做的意义：</p>

<p>这里只是简单的更改了一些数字，在页面显示更加直观。实际的操作中，你可以经常用来把某些值改为临界情况以看到App在处理这些临界状况时的反应，这样比找那些临界数据的测试账号成本要低得多。也可以把一些可能不会反回数值的字段找到，直接将里面的值删成nil，看看会不会报异常等等。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[H5应用实战]]></title>
    <link href="http://al1020119.github.io/blog/2015/12/10/h5ying-yong-shi-zhan/"/>
    <updated>2015-12-10T11:03:23+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/12/10/h5ying-yong-shi-zhan</id>
    <content type="html"><![CDATA[<blockquote><p>前言:
ObjectiveC与Js交互是常见的需求，可对于新手或者所谓的高手而言，其实并不是那么简单明了。</p></blockquote>

<p>标准通用标记语言下的一个应用HTML标准自1999年12月发布的HTML4.01后，后继的HTML5和其它标准被束之高阁，为了推动Web标准化运动的发展，一些公司联合起来，成立了一个叫做 Web Hypertext Application Technology Working Group （Web超文本应用技术工作组 -WHATWG） 的组织。WHATWG 致力于 Web 表单和应用程序，而W3C（World Wide Web Consortium，万维网联盟） 专注于XHTML2.0。在 2006 年，双方决定进行合作，来创建一个新版本的 HTML。</p>

<p>这段时间在研究H5相关，由于本人主攻的是ios开发，所以后期主要的任务就是，使用H5+Css+JP编写好的代码在OC中使用，或者相互调用。</p>

<p>这里就给大家介绍一下后面的内容，关于前面的内容后期会陆续更新相关文章与总结。</p>

<!--more-->


<h3>OC——调用——HTML</h3>

<p>这里有两种方式
直接使用网络链接（接口）
使用本地的html</p>

<p>由于没有完成一个完整的html项目，这里就以链接演示。</p>

<p>先来看看官方链接显示情况
<img src="http://al1020119.github.io/images/html&oc001.png" title="Caption" ></p>

<p>1.使用WebView，设置代理，加载对应的Html（略过部分细节），并且增加一个指示器</p>

<pre><code>// 加载网页
NSURL *url = [NSURL URLWithString:@"http://www.xianhua.cn/m/"];
NSURLRequest *request = [NSURLRequest requestWithURL:url];
[self.webView loadRequest:request];

self.webView.scrollView.hidden = YES;
self.webView.backgroundColor = [UIColor grayColor];

UIActivityIndicatorView *displayView = [[UIActivityIndicatorView alloc] initWithActivityIndicatorStyle:UIActivityIndicatorViewStyleWhiteLarge];
[displayView startAnimating];
self.displayView = displayView;
displayView.center = self.view.center;
[self.webView addSubview:displayView];
</code></pre>

<p>2.在WebView加载完成的方法中实现我们想要的功能需求</p>

<pre><code>#pragma mark -&lt;UIWebViewDelegate&gt;
- (void)webViewDidFinishLoad:(UIWebView *)webView{

    // 改变标题
    NSString *str = @"document.getElementsByTagName('h1')[0].innerText = 'iCocos鲜花网';";
    [webView stringByEvaluatingJavaScriptFromString:str];

    // 删除广告
    NSString *str2 =@"document.getElementsByClassName('detail_btns2')[0].remove();";
    [webView stringByEvaluatingJavaScriptFromString:str2];

    // 改变尾部
    NSString *str3 = @"document.getElementById('xiazaiapp').getElementsByTagName('a')[0].innerText='iCocos鲜花网App';";
    [webView stringByEvaluatingJavaScriptFromString:str3];

    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.25 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
        self.webView.scrollView.hidden = NO;
        [self.displayView stopAnimating];
    });
}
</code></pre>

<p>修改后子在手机就是这样的效果</p>

<p><img src="http://al1020119.github.io/images/html&oc002.png" title="Caption" ></p>

<h3>HTML——调用——OC</h3>

<p>这里的例子是通过在html中点击一个按钮去调用OC代码，访问系统系相册</p>

<h6>先来看看OC中需要怎么写：</h6>

<p>1.使用WebView，设置代理，加载对应的Html（略过部分细节）</p>

<pre><code>// 加载网页
NSURL *url = [[NSBundle mainBundle] URLForResource:@"test" withExtension:@"html"];
NSURLRequest *request = [NSURLRequest requestWithURL:url];
[self.webView loadRequest:request];
</code></pre>

<p>2.在Web开始加载请求的代理方法中拼接方法（包装）</p>

<pre><code>#pragma mark - &lt;UIWebViewDelegate&gt;
- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType{
//    NSLog(@"------%@", request.URL.absoluteString);
    NSString *requestUrl = request.URL.absoluteString;
    NSRange range = [requestUrl rangeOfString:@"ds3q:///"];
    NSUInteger location = range.location;
    if (location != NSNotFound) {
        NSString *str = [requestUrl substringFromIndex:location + range.length];
        NSLog(@"%@", str);
        // 包装SEL
        SEL method = NSSelectorFromString(str);
        [self performSelector:method];
    }

    return YES;
}
</code></pre>

<p>3.实现打开相册的OC方法</p>

<pre><code>// 打开相册
- (void)openCamera{
    UIImagePickerController *vc = [[UIImagePickerController alloc] init];
    vc.sourceType = UIImagePickerControllerSourceTypePhotoLibrary;
    [self presentViewController:vc animated:YES completion:nil];
}
</code></pre>

<p>4.再来看看html中简单的写法</p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head lang="en"&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;style&gt;
        body{
            margin-top: 50px;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;button onclick="openCamera();"&gt;访问相册&lt;/button&gt;
    &lt;script type="text/javascript"&gt;
        function openCamera(){
            window.location.href = 'ds3q:///openCamera';
        }
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p> 显示效果</p>

<p> <img src="http://al1020119.github.io/images/html&oc003.png" title="Caption" ></p>

<hr />

<p>  <img src="http://al1020119.github.io/images/html&oc004.png" title="Caption" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Core Image 初探]]></title>
    <link href="http://al1020119.github.io/blog/2015/12/10/core-image-chu-tan/"/>
    <updated>2015-12-10T10:09:37+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/12/10/core-image-chu-tan</id>
    <content type="html"><![CDATA[<blockquote><p>前言：
Core Image 是 IOS 的图片处理框架，有使用方便、易于管理，性能优异的特点。</p>

<ul>
<li>用途

<ul>
<li>在照片、视频处理，把滤镜作为最后一步，添加水印</li>
<li>给照相机提供实时效果</li>
<li>面部检测，自动滤镜增益,图片分析算法</li>
<li>更多</li>
</ul>
</li>
</ul>
</blockquote>

<!--more-->


<h2>coreimage framework 组成</h2>

<p>apple 已经帮我们把image的处理分类好，来看看它的结构：</p>

<p><img src="http://al1020119.github.io/images/coreimage001.png" title="Caption" ></p>

<p>主要分为三部分：</p>

<h5>定义部分：</h5>

<p> CoreImage 何CoreImageDefines。见名思义，代表了CoreImage 这个框架和它的定义。</p>

<h5>操作部分：</h5>

<pre><code>滤镜（CIFliter）：CIFilter 产生一个CIImage。典型的，接受一到多的图片作为输入，经过一些过滤操作，产生指定输出的图片。

检测（CIDetector）：CIDetector 检测处理图片的特性，如使用来检测图片中人脸的眼睛、嘴巴、等等。

特征（CIFeature）：CIFeature 代表由 detector处理后产生的特征。
</code></pre>

<h5>图像部分：</h5>

<pre><code>画布（CIContext）：画布类可被用与处理Quartz 2D 或者 OpenGL。可以用它来关联CoreImage类。如滤镜、颜色等渲染处理。

颜色（CIColor）：   图片的关联与画布、图片像素颜色的处理。

向量（CIVector）： 图片的坐标向量等几何方法处理。

图片（CIImage）： 代表一个图像，可代表关联后输出的图像。　　
</code></pre>

<p><img src="http://al1020119.github.io/images/coreimage002.jpg" title="Caption" ></p>

<h2>2.  处理步骤：</h2>

<pre><code>  1）create a ciimage object;

  2) create a cifilter object and set input values

  3)  create a cicontext object.

  4) render the filter output image into a cgimage
</code></pre>

<p>　　　　</p>

<h2>3.注意</h2>

<p>　　　　a。关注Ciimage 产生的途径：</p>

<p>　　　　　　　　1）通过URL和Data</p>

<p>　　　　　　　　 2）通过其他图片类转换，CGImageRef或其他图片。</p>

<p>　　　　　　　　 3）通过CVpixelBufferRef。</p>

<p>　　　　　　　　 4）一组像素Data。</p>

<p>　　　　b.  图片颜色，KCCImageColorSpace 来重载默认颜色空间。</p>

<p>　　　　c. 图片Metadata。</p>

<p>　　　　</p>

<h2>4. 使用滤镜。</h2>

<p>　　　　CISepiaTone、CiColorControls、CIHueBlendMode。</p>

<p><img src="http://al1020119.github.io/images/coreimage003.png" title="Caption" ></p>

<p>处理过程：多个CImage输入 －－ 》 CIHeBlendMode  －－》 CiSepiatone。</p>

<p><img src="http://al1020119.github.io/images/coreimage004.jpg" title="Caption" ></p>

<p>渲染输出：</p>

<p><img src="http://al1020119.github.io/images/coreimage005.jpg" title="Caption" ></p>

<p>流程： 获取context  －》 转成CIimage －》 渲染成CGImageRef  －》 转换为UIimage －》 释放 CGImageRef －》 使用UIImage。</p>

<h2>5.脸部检测</h2>

<p>　　自动增强： CIRedEyeCorrection  、CIFaceBalance（调整图片来给出更好的皮肤色调）、CIVibrance（在不扭曲皮肤色调的情况下，增加饱和度）、CIToneCurve（调整图片对比）、高亮阴影调整。
　　
　　</p>

<hr />

<p>&mdash;-基本使用&mdash;-</p>

<hr />

<h5>Core Image 处理图片的工作流程</h5>

<ul>
<li>创建新的CIImage</li>
<li>创建新的CIFilter，通过键-值编码设置输入值，一定要给inputImage加入一个值，这个属性是图像数据源</li>
<li>从CIFilter中生成输出图片。通过访问CIFilter的outputImage属性，可以得到输出图像，这是一个新的CIImage对象，包含了原始图片的数据以及一个滤镜链。 在得到输出图像后，可以使用滤镜来渲染出最终的效果图像。也可以将其作为一个新滤镜的输入图像，这样会产生出一条滤镜链</li>
<li>用CIContext 渲染CIImage 对象，这个CIContext 可以是基于CPU的，输出为CGImageRef，通过 LibDispatch（GCD）渲染 ，更加可靠，也更加易用。也可以是基于GPU的，开发者可通过Open ES 2.0 画出来。使用GPU渲染时CPU没有负担，更好地性能，但无法在后台运行</li>
</ul>


<p>使用例子：</p>

<pre><code> CIImage *myCoreImage = [CIImage imageWithCGImage:self.myImageView.image.CGImage options:nil];  

// 创建Filter，@"CISepiaTone"这个名字是系统指定的  
CIFilter *sepia = [CIFilter filterWithName:@"CISepiaTone"];  

// 设置Filter  
[sepia setValue:myCoreImage forKey:@"inputImage"];  

NSNumber *intensity = [NSNumber numberWithFloat:.5f];  
[sepia setValue:intensity forKey:@"inputIntensity"];  

// 生成新的 CIImage  
CIImage *outputImage = [sepia outputImage];  

// 取出UIImage  
CGImageRef renderImage = [_imageContext createCGImage:outputImage fromRect:[outputImage extent]];  
[self.myImageView setImage:[UIImage imageWithCGImage:renderImage]];
</code></pre>

<blockquote><p>DemoCoreImage 是直接从IOS 核心框架拿过来的。
CoreImageMySelf 是我自己提取的只为实现优化功能的demo
提取的功能模块有，filter的使用、自动优化的使用、脸部检测</p></blockquote>

<p>再来看看常见的使用方式</p>

<ul>
<li>CIImage</li>
</ul>


<p>保存图像数据的类，可以通过UIImage，图像文件或者像素数据来创建，包括未处理的像素数据如：</p>

<pre><code>- imageWithCVPixelBuffer:

- imageWithData:
</code></pre>

<p>方法等等。</p>

<p>也可以通过图像数据类比如UIImage，CGImageRef等等。</p>

<ul>
<li>CIFilter</li>
</ul>


<p>滤镜类，这个框架中对图片属性进行细节处理的类。它对所有的像素进行操作，用一些键-值设置来决定具体操作的程度。</p>

<ul>
<li>CIContext</li>
</ul>


<p>上下文类，如CoreGraphics以及CoreData中的上下文用于处理绘制渲染以及处理托管对象一样，CoreImage的上下文也是实现对图像处理的具体对象。</p>

<p>这里需要注意的是在Context创建的时候，我们需要给它设定为是基于GPU还是CPU。(这里使用GPU)</p>

<blockquote><p>基于GPU的话，处理速度更快，因为利用了GPU硬件的并行优势。但是GPU受限于硬件纹理尺寸，而且如果你的程序在后台继续处理和保存图片的话，那么需要使用CPU，因为当app切换到后台状态时GPU处理会被打断。</p></blockquote>

<h3>使用步骤：</h3>

<h6>0.导入CIImage图片</h6>

<pre><code>CIImage *ciImage = [[CIImage alloc]initWithImage:[UIImage imageNamed:@"test.jpg"]];
</code></pre>

<h6>1.创建出Filter滤镜</h6>

<pre><code>CIFilter *filterOne = [CIFilter filterWithName:@"CIPixellate"];
[filterOne setValue:ciImage forKey:kCIInputImageKey];
[filterOne setDefaults];

CIImage *outImage = [filterOne valueForKey:kCIOutputImageKey];
</code></pre>

<h6>2.用CIContext将滤镜中的图片渲染出来</h6>

<pre><code>CIContext *context = [CIContext contextWithOptions:nil];

CGImageRef cgImage = [context createCGImage:outImage fromRect:[outImage extent]];
</code></pre>

<h6>3.导出图片</h6>

<pre><code>UIImage *showImage = [UIImage imageWithCGImage:cgImage];
CGImageRelease(cgImage);
</code></pre>

<h6>4.加载图片</h6>

<pre><code> _image.image = showImage;
</code></pre>

<hr />

<h3>如果要使用组合滤镜</h3>

<h6>在步骤1中设置组合滤镜，只需要将上一个滤镜的输出变为下一个滤镜的输入就行了</h6>

<pre><code>//第一个滤镜
CIFilter *filterOne = [CIFilter filterWithName:@"CIPixellate"];
[filterOne setValue:ciImage forKey:kCIInputImageKey];
[filterOne setDefaults];
CIImage *outImage = [filterOne valueForKey:kCIOutputImageKey];
//第二个滤镜
CIFilter *filterTwo = [CIFilter filterWithName:@"CIHueAdjust"];
[filterTwo setValue:outImage forKey:kCIInputImageKey];
[filterTwo setDefaults];
[filterTwo setValue:@(1.f) forKey:kCIInputAngleKey];
CIImage *outputImage = [filterTwo valueForKey:kCIOutputImageKey];
</code></pre>

<h6>记住渲染的时候，步骤2，要将最后输出的CIImage传入</h6>

<pre><code>CIContext *context = [CIContext contextWithOptions:nil];

CGImageRef cgImage = [context createCGImage:outputImage fromRect:[outImage extent]];
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[玩转定时器]]></title>
    <link href="http://al1020119.github.io/blog/2015/12/09/wan-zheng-ding-shi-qi/"/>
    <updated>2015-12-09T18:17:51+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/12/09/wan-zheng-ding-shi-qi</id>
    <content type="html"><![CDATA[<p> <img src="http://al1020119.github.io/images/dingshiqi.png" title="Caption" ></p>

<p>在软件开发过程中，我们常常需要在某个时间后执行某个方法，或者是按照某个周期一直执行某个方法。在这个时候，我们就需要用到定时器。</p>

<blockquote><p>然而，在iOS中有很多方法完成以上的任务，到底有多少种方法呢？经过查阅资料，大概有三种方法：NSTimer、CADisplayLink、GCD。接下来我就一一介绍它们的用法。</p></blockquote>

<!--more-->


<h2>一、NSTimer</h2>

<h5>1. 创建方法</h5>

<pre><code>1     // 设置定时器
2     [NSTimer scheduledTimerWithTimeInterval:.1 target:self selector:@selector(timeChange) userInfo:nil repeats:YES];
3     
4     // 0.1 setNeedsDisplay 绑定一个标识,等待下次刷新的时候才会调用drawRect方法
5     // 0.15 屏幕的刷新时间
</code></pre>

<ul>
<li><p>TimerInterval : 执行之前等待的时间。比如设置成1.0，就代表1秒后执行方法</p></li>
<li><p>target : 需要执行方法的对象。</p></li>
<li><p>selector : 需要执行的方法</p></li>
<li><p>repeats : 是否需要循环</p></li>
</ul>


<h5>2. 释放方法</h5>

<pre><code> [timer invalidate]; 
</code></pre>

<blockquote><p>注意 :
调用创建方法后，target对象的计数器会加1，直到执行完毕，自动减1。如果是循环执行的话，就必须手动关闭，否则可以不执行释放方法。</p></blockquote>

<h5>3. 特性</h5>

<ul>
<li>存在延迟</li>
</ul>


<p>不管是一次性的还是周期性的timer的实际触发事件的时间，都会与所加入的RunLoop和RunLoop Mode有关，如果此RunLoop正在执行一个连续性的运算，timer就会被延时出发。重复性的timer遇到这种情况，如果延迟超过了一个周期，则会在延时结束后立刻执行，并按照之前指定的周期继续执行。</p>

<ul>
<li>必须加入Runloop</li>
</ul>


<p>使用上面的创建方式，会自动把timer加入MainRunloop的NSDefaultRunLoopMode中。如果使用以下方式创建定时器，就必须手动加入Runloop:</p>

<pre><code>NSTimer *timer = [NSTimer timerWithTimeInterval:5 target:self &lt;span style="color: #3366ff;"&gt;selector&lt;/span&gt;:@selector(timerAction) userInfo:nil repeats:YES];&lt;br&gt;&lt;br&gt;
[[NSRunLoop mainRunLoop] &lt;span style="color: #3366ff;"&gt;addTimer&lt;/span&gt;:timer forMode:NSDefaultRunLoopMode];
</code></pre>

<p> 注意NSTimer还有一个方法，因为每次用的时候都是使用带target的这个方法，突然有一天很好奇就研究了一下，他的使用也很简单，只是相对上面那个有点繁琐，</p>

<h5>1:创建一个签名：</h5>

<pre><code> NSMethodSignature *singature = [NSMethodSignature signatureWithObjCTypes:"v@:"]; 2  
</code></pre>

<p>这里我想如果你仔细的话肯定注意到了：后面的“v@：”，这里是运行时的语法</p>

<p>在这里是指一个方法</p>

<pre><code>v放回viod类型
@一个id类型的对象
：对应SEL
</code></pre>

<p>关于运行时这里不多介绍请查看笔者之前的文章，或者查看官方文档，这是一个iOS开发者必须会的知识点</p>

<h5>2:通过前面创建一个请求，并且设置对应的target和SEL</h5>

<pre><code>&lt;span style="color: #3366ff;"&gt;    NSInvocation&lt;/span&gt; *vocation = [NSInvocation invocationWithMethodSignature:singature];
    vocation.target = self;
    vocation.selector = @selector(timeChange);
</code></pre>

<h5>3:在讲请求传到NSTimer中去实现定时</h5>

<pre><code>[NSTimer scheduledTimerWithTimeInterval:1 invocation:vocation repeats:YES]; 
</code></pre>

<h2>二、CADisplayLink</h2>

<h5>1. 创建方法</h5>

<pre><code>self.displayLink = [CADisplayLink displayLinkWithTarget:self &lt;span style="color: #3366ff;"&gt;selector&lt;/span&gt;:@selector(handleDisplayLink:)];   
[self.displayLink &lt;span style="color: #3366ff;"&gt;addToRunLoop&lt;/span&gt;:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];
</code></pre>

<h5>2. 停止方法</h5>

<pre><code>self.displayLink &lt;span style="color: #3366ff;"&gt;invalidate&lt;/span&gt;]; 
self.displayLink = nil;
</code></pre>

<p> 当把CADisplayLink对象add到runloop中后，selector就能被周期性调用，类似于重复的NSTimer被启动了；执行invalidate操作时，CADisplayLink对象就会从runloop中移除，selector调用也随即停止，类似于NSTimer的invalidate方法。</p>

<h5>3. 特性</h5>

<ul>
<li>屏幕刷新时调用</li>
</ul>


<p>CADisplayLink是一个能让我们以和屏幕刷新率同步的频率将特定的内容画到屏幕上的定时器类。CADisplayLink以特定模式注册到runloop后，每当屏幕显示内容刷新结束的时候，runloop就会向CADisplayLink指定的target发送一次指定的selector消息， CADisplayLink类对应的selector就会被调用一次。所以通常情况下，按照iOS设备屏幕的刷新率60次/秒</p>

<ul>
<li>延迟</li>
</ul>


<p>iOS设备的屏幕刷新频率是固定的，CADisplayLink在正常情况下会在每次刷新结束都被调用，精确度相当高。但如果调用的方法比较耗时，超过了屏幕刷新周期，就会导致跳过若干次回调调用机会。</p>

<p>如果CPU过于繁忙，无法保证屏幕60次/秒的刷新率，就会导致跳过若干次调用回调方法的机会，跳过次数取决CPU的忙碌程度。</p>

<ul>
<li>使用场景</li>
</ul>


<p>从原理上可以看出，CADisplayLink适合做界面的不停重绘，比如视频播放的时候需要不停地获取下一帧用于界面渲染。</p>

<h5>4. 重要属性</h5>

<ul>
<li>frameInterval</li>
</ul>


<p>NSInteger类型的值，用来设置间隔多少帧调用一次selector方法，默认值是1，即每帧都调用一次。</p>

<ul>
<li>duration</li>
</ul>


<p>readOnly的CFTimeInterval值，表示两次屏幕刷新之间的时间间隔。需要注意的是，该属性在target的selector被首次调用以后才会被赋值。selector的调用间隔时间计算方式是：调用间隔时间 = duration × frameInterval。</p>

<h5>CADisplayLink底层实现：</h5>

<pre><code> setNeedsDisplay:底层并不会马上调用drawRect,只会给当前的控件绑定一个刷新的标识,每次屏幕刷新的时候,就会把绑定了刷新(重绘)标识的控件重新刷新(绘制)一次,就会调用drawRect去重绘
</code></pre>

<blockquote><p> 注意：如果以后每隔一段时间需要重绘,一般不使用NSTimer,使用CADisplayLink,不会刷新的时候有延迟</p></blockquote>

<h2>三、GCD方式</h2>

<h5>执行一次</h5>

<pre><code>1 double delayInSeconds = 2.0;
2 dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, delayInSeconds * NSEC_PER_SEC); 
3 dispatch_after(popTime, dispatch_get_main_queue(), ^(void){ 
4     //执行事件
5 });
</code></pre>

<h5>重复执行</h5>

<pre><code>1 NSTimeInterval period = 1.0; //设置时间间隔
2 dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
3 dispatch_source_t _timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);
4 dispatch_source_set_timer(_timer, dispatch_walltime(NULL, 0), period * NSEC_PER_SEC, 0); //每秒执行
5 dispatch_source_set_event_handler(_timer, ^{
6     //在这里执行事件
7 });
8 dispatch_resume(_timer);
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[事件处理与图像渲染深究]]></title>
    <link href="http://al1020119.github.io/blog/2015/12/09/shi-jian-chu-li-yu-tu-xiang-xuan-ran-shen-jiu/"/>
    <updated>2015-12-09T09:47:11+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/12/09/shi-jian-chu-li-yu-tu-xiang-xuan-ran-shen-jiu</id>
    <content type="html"><![CDATA[<h3>iOS 事件处理机制与图像渲染过程</h3>

<ul>
<li>iOS RunLoop都干了什么</li>
<li>iOS 为什么必须在主线程中操作UI</li>
<li>事件响应</li>
<li>CALayer</li>
<li>CADisplayLink 和 NSTimer</li>
<li>iOS 渲染过程</li>
<li>渲染时机</li>
<li>CPU 和 GPU渲染</li>
<li>Core Animation</li>
<li>Facebook Pop介绍</li>
<li>AsyncDisplay介绍</li>
<li>参考文章</li>
</ul>


<!--more-->


<h5>iOS RunLoop都干了什么</h5>

<p>RunLoop是一个接收处理异步消息事件的循环，一个循环中：等待事件发生，然后将这个事件送到能处理它的地方。
如图1-1所示，描述了一个触摸事件从操作系统层传送到应用内的main runloop中的简单过程。</p>

<p><img src="http://al1020119.github.io/images/tupianxuanran001.jpg" title="Caption" ></p>

<p>简单的说，RunLoop是事件驱动的一个大循环，如下代码所示</p>

<pre><code>int main(int argc, char * argv[]) {
     //程序一直运行状态
     while (AppIsRunning) {
          //睡眠状态，等待唤醒事件
          id whoWakesMe = SleepForWakingU  p();
          //得到唤醒事件
          id event = GetEvent(whoWakesMe);
          //开始处理事件
          HandleEvent(event);
     }
     return 0;
}
</code></pre>

<p>RunLoop主要处理以下6类事件：</p>

<pre><code>static void __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__();
static void __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__();
static void __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__();
static void __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__();
static void __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__();
static void __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__();
</code></pre>

<ul>
<li><p>Observer事件，runloop中状态变化时进行通知。（微信卡顿监控就是利用这个事件通知来记录下最近一次main runloop活动时间，在另一个check线程中用定时器检测当前时间距离最后一次活动时间过久来判断在主线程中的处理逻辑耗时和卡主线程）。这里还需要特别注意，CAAnimation是由RunloopObserver触发回调来重绘，接下来会讲到。</p></li>
<li><p>Block事件，非延迟的NSObject PerformSelector立即调用，dispatch_after立即调用，block回调。</p></li>
<li><p>Main_Dispatch_Queue事件：GCD中dispatch到main queue的block会被dispatch到main loop执行。</p></li>
<li><p>Timer事件：延迟的NSObject PerformSelector，延迟的dispatch_after，timer事件。</p></li>
<li><p>Source0事件：处理如UIEvent，CFSocket这类事件。需要手动触发。触摸事件其实是</p></li>
<li>Source1接收系统事件后在回调 <em>_IOHIDEventSystemClientQueueCallback() 内触发的 Source0，Source0 再触发的 </em>UIApplicationHandleEventQueue()。source0一定是要唤醒runloop及时响应并执行的，如果runloop此时在休眠等待系统的 mach_msg事件，那么就会通过source1来唤醒runloop执行。</li>
</ul>


<blockquote><p>Source1事件：处理系统内核的mach_msg事件。（推测CADisplayLink也是这里触发）。</p></blockquote>

<p>RunLoop执行顺序的伪代码</p>

<pre><code>SetupThisRunLoopRunTimeoutTimer(); // by GCD timer
//通知即将进入runloop__CFRUNLLOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(KCFRunLoopEntry);
do {
     __CFRunLoopDoObservers(kCFRunLoopBeforeTimers);
     __CFRunLoopDoObservers(kCFRunLoopBeforeSources);

     __CFRunLoopDoBlocks();  //一个循环中会调用两次，确保非延迟的NSObject PerformSelector调用和非延迟的dispatch_after调用在当前runloop执行。还有回调block
     __CFRunLoopDoSource0(); //例如UIKit处理的UIEvent事件

     CheckIfExistMessagesInMainDispatchQueue(); //GCD dispatch main queue

     __CFRunLoopDoObservers(kCFRunLoopBeforeWaiting); //即将进入休眠，会重绘一次界面
     var wakeUpPort = SleepAndWaitForWakingUpPorts();
     // mach_msg_trap，陷入内核等待匹配的内核mach_msg事件
     // Zzz...
     // Received mach_msg, wake up
     __CFRunLoopDoObservers(kCFRunLoopAfterWaiting);
     // Handle msgs
     if (wakeUpPort == timerPort) {
          __CFRunLoopDoTimers();
     } else if (wakeUpPort == mainDispatchQueuePort) {
          //GCD当调用dispatch_async(dispatch_get_main_queue(),block)时，libDispatch会向主线程的runloop发送mach_msg消息唤醒runloop，并在这里执行。这里仅限于执行dispatch到主线程的任务，dispatch到其他线程的仍然是libDispatch来处理。
          __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__()
     } else {
          __CFRunLoopDoSource1();  //CADisplayLink是source1的mach_msg触发？
     }
 __CFRunLoopDoBlocks();
} while (!stop &amp;&amp; !timeout);

//通知observers，即将退出runloop
__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBERVER_CALLBACK_FUNCTION__(CFRunLoopExit);
</code></pre>

<p>结合上面的Runloop事件执行顺序，思考下面代码逻辑中为什么可以标识tableview是否reload完成</p>

<pre><code>dispatch_async(dispatch_get_main_queue(), ^{
    _isReloadDone = NO;
    [tableView reload]; //会自动设置tableView layoutIfNeeded为YES，意味着将会在runloop结束时重绘table
    dispatch_async(dispatch_get_main_queue(),^{
        _isReloadDone = YES;
    });
});
</code></pre>

<blockquote><p>提示：这里在GCD dispatch main queue中插入了两个任务，一次RunLoop有两个机会执行GCD dispatch main queue中的任务，分别在休眠前和被唤醒后。</p></blockquote>

<h5>iOS 为什么必须在主线程中操作UI</h5>

<blockquote><p>因为UIKit不是线程安全的。试想下面这几种情况：</p></blockquote>

<p>两个线程同时设置同一个背景图片，那么很有可能因为当前图片被释放了两次而导致应用崩溃。
两个线程同时设置同一个UIView的背景颜色，那么很有可能渲染显示的是颜色A，而此时在UIView逻辑树上的背景颜色属性为B。
两个线程同时操作view的树形结构：在线程A中for循环遍历并操作当前View的所有subView，然后此时线程B中将某个subView直接删除，这就导致了错乱还可能导致应用崩溃。
iOS4之后苹果将大部分绘图的方法和诸如 UIColor 和 UIFont 这样的类改写为了线程安全可用，但是仍然强烈建议讲UI操作保证在主线程中执行。</p>

<h6>事件响应</h6>

<p>苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。</p>

<p>当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。</p>

<ul>
<li><p>SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。</p></li>
<li><p>_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。</p></li>
</ul>


<h6>CALayer</h6>

<p>在iOS当中，所有的视图都从一个叫做UIVIew的基类派生而来，UIView可以处理触摸事件，可以支持基于Core Graphics绘图，可以做仿射变换（例如旋转或者缩放），或者简单的类似于滑动或者渐变的动画。</p>

<p>CALayer类在概念上和UIView类似，同样也是一些被层级关系树管理的矩形块，同样也可以包含一些内容（像图片，文本或者背景色），管理子图层的位置。它们有一些方法和属性用来做动画和变换。和UIView最大的不同是CALayer不处理用户的交互。CALayer并不清楚具体的响应链。</p>

<p>UIView和CALayer是一个平行的层级关系，每一个UIView都有一个CALayer实例的图层属性，也就是所谓的backing layer，视图的职责就是创建并管理这个图层，以确保当子视图在层级关系中添加或者被移除的时候，他们关联的图层也同样对应在层级关系树当中有相同的操作。实际上这些背后关联的Layer图层才是真正用来在屏幕上显示和做动画，UIView仅仅是对它的一个封装，提供了一些iOS类似于处理触摸的具体功能，以及Core Animation底层方法的高级接口。</p>

<h6>UIView 的 Layer 在系统内部，被维护着三份同样的树形数据结构，分别是：</h6>

<pre><code>图层树（这里是代码可以操纵的，设置属性的最终值会立刻在这里更新）；
呈现树（是一个中间层，系统就在这一层上更改属性，进行各种渲染操作。比如一个动画是更改alpha值从0到1，那么在逻辑树上此属性会被立刻更新为最终属性1，而在动画树上会根据设置的动画时间从0逐步变化到1）；
渲染树（其属性值就是当前正被显示在屏幕上的属性值）；
</code></pre>

<h5>CADisplayLink 和 NSTimer</h5>

<p>NSTimer 其实就是 CFRunLoopTimerRef。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。</p>

<ul>
<li><p>RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。</p></li>
<li><p>RunLoop 是用GCD的 dispatch_source_t 实现的 Timer。 当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。</p></li>
<li><p>CADisplayLink 是一个和屏幕刷新率（每秒刷新60次）一致的定时器（但实际实现原理更复杂，和 NSTimer 并不一样，其内部实际是操作了一个 Source）。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去，造成界面卡顿的感觉。</p></li>
</ul>


<h5>iOS 渲染过程</h5>

<p><img src="http://al1020119.github.io/images/tupianxuanran002.png" title="Caption" ></p>

<p>通常来说，计算机系统中 CPU、GPU、显示器是以上面这种方式协同工作的。CPU 计算好显示内容提交到 GPU，GPU 渲染完成后将渲染结果放入帧缓冲区，随后视频控制器会按照 VSync 信号如下图1-4所示，逐行读取帧缓冲区的数据，经过可能的数模转换传递给显示器显示。</p>

<p><img src="http://al1020119.github.io/images/tupianxuanran003.png" title="Caption" ></p>

<p>在 VSync 信号到来后，系统图形服务会通过 CADisplayLink 等机制通知 App，App 主线程开始在 CPU 中计算显示内容，比如视图的创建、布局计算、图片解码、文本绘制等。随后 CPU 会将计算好的内容提交到 GPU 去，由 GPU 进行变换、合成、渲染。随后 GPU 会把渲染结果提交到帧缓冲区去，等待下一次 VSync 信号到来时显示到屏幕上。由于垂直同步的机制，如果在一个 VSync 时间内，CPU 或者 GPU 没有完成内容提交，则那一帧就会被丢弃，等待下一次机会再显示，而这时显示屏会保留之前的内容不变。这就是界面卡顿的原因。从上图中可以看到，CPU 和 GPU 不论哪个阻碍了显示流程，都会造成掉帧现象。所以开发时，也需要分别对 CPU 和 GPU 压力进行评估和优化。</p>

<p><img src="http://al1020119.github.io/images/tupianxuanran004.png" title="Caption" ></p>

<p>iOS 的显示系统是由 VSync 信号驱动的，VSync 信号由硬件时钟生成，每秒钟发出 60 次（这个值取决设备硬件，比如 iPhone 真机上通常是 59.97）。iOS 图形服务接收到 VSync 信号后，会通过 IPC 通知到 App 内。App 的 Runloop 在启动后会注册对应的 CFRunLoopSource 通过 mach_port 接收传过来的时钟信号通知，随后 Source 的回调会驱动整个 App 的动画与显示。</p>

<p>Core Animation 在 RunLoop 中注册了一个 Observer，监听了 BeforeWaiting 和 Exit 事件。当一个触摸事件到来时，RunLoop 被唤醒，App 中的代码会执行一些操作，比如创建和调整视图层级、设置 UIView 的 frame、修改 CALayer 的透明度、为视图添加一个动画；这些操作最终都会被 CALayer 标记，并通过 CATransaction 提交到一个中间状态去。当上面所有操作结束后，RunLoop 即将进入休眠（或者退出）时，关注该事件的 Observer 都会得到通知。这时 Core Animation 注册的那个 Observer 就会在回调中，把所有的中间状态合并提交到 GPU 去显示；如果此处有动画，通过 DisplayLink 稳定的刷新机制会不断的唤醒runloop，使得不断的有机会触发observer回调，从而根据时间来不断更新这个动画的属性值并绘制出来。</p>

<blockquote><p>为了不阻塞主线程，Core Animation 的核心是 OpenGL ES 的一个抽象物，所以大部分的渲染是直接提交给GPU来处理。 而Core Graphics/Quartz 2D的大部分绘制操作都是在主线程和CPU上同步完成的，比如自定义UIView的drawRect里用CGContext来画图。</p></blockquote>

<h5>渲染时机</h5>

<p>上面已经提到过：Core Animation 在 RunLoop 中注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件 。当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。当Oberver监听的事件到来时，回调执行函数中会遍历所有待处理的UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。</p>

<p>这个函数内部的调用栈大概是这样的：</p>

<pre><code>_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()
    QuartzCore:CA::Transaction::observer_callback:
        CA::Transaction::commit();
            CA::Context::commit_transaction();
                CA::Layer::layout_and_display_if_needed();
                    CA::Layer::layout_if_needed();
                          [CALayer layoutSublayers];
                          [UIView layoutSubviews];
                    CA::Layer::display_if_needed();
                          [CALayer display];
                          [UIView drawRect];
</code></pre>

<h5>CPU 和 GPU渲染</h5>

<p>OpenGL中，GPU屏幕渲染有以下两种方式：</p>

<ul>
<li>On-Screen Rendering</li>
</ul>


<p>意为当前屏幕渲染，指的是GPU的渲染操作是在当前用于显示的屏幕缓冲区中进行。</p>

<ul>
<li>Off-Screen Rendering</li>
</ul>


<p>意为离屏渲染，指的是GPU在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。</p>

<blockquote><p>按照这样的说法，如果将不在GPU的当前屏幕缓冲区中进行的渲染都称为离屏渲染，那么就还有另一种特殊的“离屏渲染”方式：CPU渲染。如果我们重写了drawRect方法，并且使用任何Core Graphics的技术进行了绘制操作，就涉及到了CPU渲染。整个渲染过程由CPU在App内同步地完成，渲染得到的bitmap最后再交由GPU用于显示。</p></blockquote>

<p>相比于当前屏幕渲染，离屏渲染的代价是很高的，主要体现在两个方面：</p>

<pre><code>创建新缓冲区 
要想进行离屏渲染，首先要创建一个新的缓冲区。
上下文切换 
</code></pre>

<p>离屏渲染的整个过程，需要多次切换上下文环境：</p>

<ul>
<li>先是从当前屏幕（On-Screen）切换到离屏（Off-Screen）</li>
<li>等到离屏渲染结束以后，将离屏缓冲区的渲染结果显示到屏幕上有需要将上下文环境从离屏切换到当前屏幕</li>
<li><p>而上下文环境的切换是要付出很大代价的。</p></li>
<li><p>设置了以下属性时，都会触发离屏绘制：</p></li>
</ul>


<hr />

<pre><code>shouldRasterize（光栅化）
masks（遮罩）
shadows（阴影）
edge antialiasing（抗锯齿）
group opacity（不透明） 
</code></pre>

<blockquote><p>需要注意的是，如果shouldRasterize被设置成YES，在触发离屏绘制的同时，会将光栅化后的内容缓存起来，如果对应的layer及其sublayers没有发生改变，在下一帧的时候可以直接复用。这将在很大程度上提升渲染性能。</p></blockquote>

<p>而其它属性如果是开启的，就不会有缓存，离屏绘制会在每一帧都发生。
在开发时需要根据实际情况来选择最优的实现方式，尽量使用On-Screen Rendering。简单的Off-Screen Rendering可以考虑使用Core Graphics让CPU来渲染。</p>

<h5>Core Animation</h5>

<ol>
<li>隐式动画</li>
</ol>


<p>隐式动画是系统框架自动完成的。Core Animation在每个runloop周期中自动开始一次新的事务，即使你不显式的用[CATransaction begin]开始一次事务，任何在一次runloop循环中属性的改变都会被集中起来，然后做一次0.25秒的动画。</p>

<pre><code>在iOS4中，苹果对UIView添加了一种基于block的动画方法：+animateWithDuration:animations:。 
</code></pre>

<p>这样写对做一堆的属性动画在语法上会更加简单，但实质上它们都是在做同样的事情。
CATransaction的+begin和+commit方法在+animateWithDuration:animations:内部自动调用，这样block中所有属性的改变都会被事务所包含。</p>

<p>Core Animation通常对CALayer的所有属性（可动画的属性）做动画，但是UIView是怎么把它关联的图层的这个特性关闭了呢？
每个UIView对它关联的图层都扮演了一个委托，并且提供了-actionForLayer:forKey的实现方法。当不在一个动画块的实现中，UIView对所有图层行为返回nil，但是在动画block范围之内，它就返回了一个非空值。</p>

<pre><code>@interface ViewController ()

@property (nonatomic, weak) IBOutlet UIView *layerView;

@end

@implementation ViewController

- (void)viewDidLoad
{
    [super viewDidLoad];
    //test layer action when outside of animation block
    NSLog(@"Outside: %@", [self.layerView actionForLayer:self.layerView.layer forKey:@"backgroundColor"]);
    //begin animation block
    [UIView beginAnimations:nil context:nil];
    //test layer action when inside of animation block
    NSLog(@"Inside: %@", [self.layerView actionForLayer:self.layerView.layer forKey:@"backgroundColor"]);
    //end animation block
    [UIView commitAnimations];
}

@end
</code></pre>

<hr />

<pre><code>$ LayerTest[21215:c07] Outside: &lt;null&gt;
$ LayerTest[21215:c07] Inside: &lt;CABasicAnimation: 0x757f090&gt;
</code></pre>

<ol>
<li>显式动画</li>
</ol>


<p>Core Animation提供的显式动画类型，既可以直接对退曾属性做动画，也可以覆盖默认的图层行为。</p>

<p>我们经常使用的CABasicAnimation，CAKeyframeAnimation，CATransitionAnimation，CAAnimationGroup等都是显式动画类型，这些CAAnimation类型可以直接提交到CALayer上。</p>

<p>无论是隐式动画还是显式动画，提交到layer后，经过一系列处理，最后都经过上文描述的绘制过程最终被渲染出来。</p>

<h5>Facebook Pop介绍</h5>

<p>在计算机的世界里面，其实并不存在绝对连续的动画，你所看到的屏幕上的动画本质上都是离散的，只是在一秒的时间里面离散的帧多到一定的数量人眼就觉得是连续的了，</p>

<p>在iOS中，最大的帧率是60帧每秒。 iOS提供了Core Animation框架，只需要开发者提供关键帧信息，比如提供某个animatable属性终点的关键帧信息，然后中间的值则通过一定的算法进行插值计算，从而实现补间动画。 Core Aniamtion中进行插值计算所依赖的时间曲线由CAMediaTimingFunction提供。</p>

<blockquote><p>Pop Animation在使用上和Core Animation很相似，都涉及Animation对象以及Animation的载体的概念，不同的是Core Animation的载体只能是CALayer，而Pop Animation可以是任意基于NSObject的对象。当然大多数情况Animation都是界面上显示的可视的效果，所以动画执行的载体一般都直接或者间接是UIView或者CALayer。</p></blockquote>

<p>但是如果你只是想研究Pop Animation的变化曲线，你也完全可以将其应用于一个普通的数据对象。Pop Animation应用于CALayer时，在动画运行的任何时刻，layer和其presentationLayer的相关属性值始终保持一致，而Core Animation做不到。 Pop Animation可以应用任何NSObject的对象，而Core Aniamtion必须是CALayer。</p>

<p>下面这个例子就是自定义Pop readBlock和writeBlock处理自定义的动画属性：</p>

<pre><code>prop = [POPAnimatableProperty propertyWithName:@"com.foo.radio.volume" initializer:^(POPMutableAnimatableProperty *prop) {
    // read value
    prop.readBlock = ^(id obj, CGFloat values[]) {
        values[0] = [obj volume];
    };
    // write value
    prop.writeBlock = ^(id obj, const CGFloat values[]) {
        [obj setVolume:values[0]];
    };
    // dynamics threshold
    prop.threshold = 0.01;
}];

POPSpringAnimation *anim = [POPSpringAnimation animation];
anim.property = prop;
</code></pre>

<p>Pop实现依赖的核心就是CADisplayLink。</p>

<p>最后附上一篇介绍Facebook Pop如何使用的文章 《Introducing Facebook Pop》</p>

<h5>AsyncDisplay介绍</h5>

<p>阻塞主线程的绘制任务主要是这三大类：</p>

<ul>
<li><p>Layout计算视图布局文本宽高</p></li>
<li><p>Rendering文本渲染图片解码图片绘制</p></li>
<li><p>UIKit对象创建更新释放。</p></li>
</ul>


<p>除了UIKit和CoreAnimation相关操作必须在主线程中进行，其他的都可以挪到后台线程异步执行。</p>

<p>AsyncDisplay通过抽象UIView的关系创建了ASDisplayNode类，ASDisplayNode是线程安全的，它可以在后台线程创建和修改。Node 刚创建时，并不会在内部新建 UIView 和 CALayer，直到第一次在主线程访问 view 或 layer 属性时，它才会在内部生成对应的对象。当它的属性（比如frame/transform）改变后，它并不会立刻同步到其持有的 view 或 layer 去，而是把被改变的属性保存到内部的一个中间变量，稍后在需要时，再通过某个机制一次性设置到内部的 view 或 layer。从而可以实现异步并发操作。</p>

<p>AsyncDisplay实现依赖如同Core Animation在runloop中注册observer事件来触发。
同样附上一篇介绍AsyncDisplay的好文 《iOS保持界面流畅的技巧和AsyncDisplay介绍》</p>

<hr />

<p>参考文章</p>

<p><a href="https://github.com/ming1016/study/wiki/CFRunLoop">runloop原理</a></p>

<p><a href="http://blog.ibireme.com/2015/05/18/runloop/">深入理解runloop</a></p>

<p><a href="http://objccn.io/issue-2-4/">线程安全类的设计</a></p>

<p><a href="http://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/">iOS保持界面流畅的技巧和AsyncDisplay介绍</a></p>

<p><a href="http://foggry.com/blog/2015/05/06/chi-ping-xuan-ran-xue-xi-bi-ji/">离屏渲染</a></p>

<p><a href="https://zsisme.gitbooks.io/ios-/content/index.html">ios核心动画高级技巧</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Watch OS2 初探]]></title>
    <link href="http://al1020119.github.io/blog/2015/12/08/watch-os2-chu-tan/"/>
    <updated>2015-12-08T17:44:31+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/12/08/watch-os2-chu-tan</id>
    <content type="html"><![CDATA[<blockquote><p>这一年的WWDC大会上,苹果公司推出了watchOS 2,这标志着Apple Watch的开发产生了巨大的变化。现在,你可以开发能运行在你手表上原生的app了。 在这篇watchOS 2教程中,你会开发一个简单但是功能齐全的watchOS 2的app。
在这个过程中,你会学到:</p></blockquote>

<ul>
<li>如何为iOS app添加watchOS 2的target</li>
<li>如何在两个target之间共享数据</li>
<li>如何添加一个watchOS 2界面控制器到Storyboard,并放置界面对象</li>
<li>如何创建WKInterfaceController的子类并连线</li>
</ul>


<!--more-->


<p>正式开始吧</p>

<p>首先下载教程的起始项目吧。</p>

<p>在Xcode中打开它然后编译运行。你应该会看到一个空白界面:</p>

<p><img src="http://al1020119.github.io/images/watchOS001.png" title="Caption" ></p>

<p>这个项目没有太多的文件,只包含一些你需要的最基本的文件。</p>

<p>添加WatchKit App</p>

<p>选择File\New\Target…,在出现的对话框中选择watchOS\Application\WatchKit App然后点击Next:</p>

<p><img src="http://al1020119.github.io/images/watchOS002.png" title="Caption" ></p>

<p>在接下来的界面中,设置项目名字为Watch,确保语言设置为Swift,然后取消选中任何复选框。点击Finish:</p>

<p><img src="http://al1020119.github.io/images/watchOS003.png" title="Caption" ></p>

<p>之后会询问你是否想要激活watch scheme,你需要这么做,所以确保选择了激活:</p>

<p><img src="http://al1020119.github.io/images/watchOS004.png" title="Caption" ></p>

<p>祝贺,你刚刚创建了你的第一个手表app!这真的很容易。</p>

<p>你会注意到,这个操作实际上创建了两个target,而不是一个,在项目导航中看到两个对应的组。这是因为手表app的代码实际是作为一个扩展形式存在的,类似iOS上的Today extensions。</p>

<p>当你在项目导航中点开Watch和Watch Extensions组的时候,你会看到所有storyboard放在Watch组,当前target创建的所有的类文件放在Watch Extensions组中:</p>

<p><img src="http://al1020119.github.io/images/watchOS005.png" title="Caption" ></p>

<p>你需要遵循如下的原则:任何你添加的代码必须放在Watch Extension组中然后添加到Watch Extension target,而所有的assets或者storyboards需要放在Watch组里。</p>

<p><img src="http://al1020119.github.io/images/watchOS006.png" title="Caption" ></p>

<p>在继续前,你需要删掉一些target模板添加的你不需要的文件。</p>

<p>在项目导航里面右键点击InterfaceController.swift然后选择删除。 当弹出提示,选择Move to Trash来确保文件确实从项目中删掉了:</p>

<p><img src="http://al1020119.github.io/images/watchOS007.png" title="Caption" ></p>

<p>下一步,打开Interface.storyboard,选择其中仅有的界面控制器,按下backspace键来删除它。现在就剩下一个空storyboard,或者是我认为的,一个空白画布。</p>

<p>共享数据和代码</p>

<p>起始项目包含一个记录所有Aber航空公司航班信息的JSON文件,一个模型类表示飞行数据。这正是应该共享的数据,因为iOS app和手表app使用相同的模型类和数据-你记得DRY(不要写重复的代码)原则吗?</p>

<p>在项目导航中点开Shared组然后选择Flights.json。之后,在File Inspector中找到Target Membership区域,选中Watch Extension</p>

<p><img src="http://al1020119.github.io/images/watchOS008.png" title="Caption" ></p>

<p>文件现在应该被AirAber和Watch Extensions这两个target所包含。 为其他Shared组的文件重复这个步骤,比如说Flight.swift。 这些都做完后,你可以开始开发航班详情界面了!</p>

<p>构造界面</p>

<p>打开 Watch\Interface.storyboard,从对象库拖一个界面控制器到storyboard里面.选中这个界面控制器,打开属性检查器设置它的Identificer为Flight,然后勾选Is Initial Controller:</p>

<p><img src="http://al1020119.github.io/images/watchOS009.png" title="Caption" ></p>

<p>你设置的这个Identifier让你可以在代码中引用这个界面控制器。选中Is Initial Controller简单告诉WatchKit你希望当应用程序启动的时候首先显示这个界面。</p>

<p>下一步,从对象库中拖动一个组到界面控制器:</p>

<p><img src="http://al1020119.github.io/images/watchOS010.png" title="Caption" ></p>

<p>之后这个组会包含Aber公司的logo,航班号和路线。</p>

<p>选中这个组,在属性检查器的顶部改变它的Insets为Custom。这会显示四个额外的文本框让你可以手动的设置组的上下左右。设置Top为6:</p>

<p><img src="http://al1020119.github.io/images/watchOS011.png" title="Caption" ></p>

<p>这仅仅让你的组到顶部有个额外的空隙。</p>

<p>下一步,拖动Image到组中。组会相应的收缩来改变Top inset(感谢Xcode!),之后在文档大纲中检查来确保Image是组的子节点,而不是同级:</p>

<p><img src="http://al1020119.github.io/images/watchOS012.png" title="Caption" ></p>

<p>现在需要显示一张图片,下载logo图片然后把它拖动到Watch\Assets.xcassets中。这会创建一个新的logo图片,存放在2x的部分。</p>

<p><img src="http://al1020119.github.io/images/watchOS013.png" title="Caption" ></p>

<p>为了给图片染色,选中这张图片,在属性检查器中修改Render As为Template Image。</p>

<p>重新打开 Watch\Interface.storyboard 选中之前的image.使用属性检查器,做如下的改变:</p>

<ul>
<li>设置图片为Logo - 当下拉列表没有出现,你可以自己输入;</li>
<li>设置Tint为#FA114F(也可以在颜色面板中输入值);</li>
<li>设置Width为Fixed,值为40;</li>
<li>设置Height为Fixed,值为40。</li>
</ul>


<p>属性检查器现在应该像下面这样:</p>

<p><img src="http://al1020119.github.io/images/watchOS014.png" title="Caption" ></p>

<p>不要担心看不到logo,因为Xcode设计时无法给模板图片染色!</p>

<p>下一步,往已经存在的组中拖动另外一个组,确保它出现在image的右侧,使用属性检查器设置Layout属性为Vertical.同样修改Spacing为0、Width为Size to Fit Content。然后拖动两个label到新的组中,放置一个到另一个的下面。</p>

<p><img src="http://al1020119.github.io/images/watchOS015.png" title="Caption" ></p>

<p>选择上面的label,使用属性检查器,设置文本为Flight 123,文字颜色为#FA114F。</p>

<p>选择下面的label,设置文本为MAM to SFO。界面控制器最后看起来像下面这样:</p>

<p><img src="http://al1020119.github.io/images/watchOS016.png" title="Caption" ></p>

<p>这些文本仅仅充当占位符,之后会被控制器中设置的文本取代。</p>

<p>下一步,拖动另一个组到界面控制器中,但是这次确保与第一个组同级。当不能设置组级别关系请使用文档大纲(Document Outline)。</p>

<p><img src="http://al1020119.github.io/images/watchOS017.png" title="Caption" ></p>

<p>选中新的组,设置它的Layout为Vertical、Spacing为0。</p>

<p>现在,拖动三个label到新的组中:</p>

<p><img src="http://al1020119.github.io/images/watchOS018.png" title="Caption" ></p>

<p>确保label都在group中,而不是与group同级!</p>

<p>选择顶部的label使用属性检查器修改它的文本为AA123 Boards。</p>

<p>选中中间的label,修改文本颜色为#FA114F,字体选择System,Regulaer样式和54.0的size.最后,修改Height为Fixed,值是44。</p>

<p>选中底部的label修改文本为On time,文本颜色为#04DE71。 你的界面控制器应该现在像下面这样:</p>

<p><img src="http://al1020119.github.io/images/watchOS019.png" title="Caption" ></p>

<p>从对象库中拖动一个新的组到下面的组,这次确保它是在子节点而不是在同级,之后向其中添加两个label,你完全的界面对象关系应该像这样:</p>

<p><img src="http://al1020119.github.io/images/watchOS020.png" title="Caption" ></p>

<p>使用属性检查器,设置左边的label文本为Gate 1A。右边的label设置为Seat 64A,之后设置它的Horizontal alignment为Right 完全的界面应该像如下这样:</p>

<p><img src="http://al1020119.github.io/images/watchOS021.png" title="Caption" ></p>

<p>恭喜,你已经完成你的第一个watch app界面的布局了,现在是时候给它填充一些真实的数据然后在模拟器上运行。</p>

<p>创建控制器</p>

<p>在项目导航中右击Watch Extensions组,选择New File,在出现的对话框中选择watchOS\Source\WatchKit Class然后点击Next。命名新的类为FlightInterfaceController,确保它为WKInterfaceController的子类,语言设置为Swift:</p>

<p><img src="http://al1020119.github.io/images/watchOS022.png" title="Caption" ></p>

<p>点击Next,之后是Create</p>

<p>可以看到新的文件在代码编辑器中打开了,删除其中的三个空方法,只剩下import语句和类定义。</p>

<p>添加这些Outlets到FlightInterfaceController的顶部:</p>

<pre><code>@IBOutlet var flightLabel: WKInterfaceLabel!
@IBOutlet var routeLabel: WKInterfaceLabel!
@IBOutlet var boardingLabel: WKInterfaceLabel!
@IBOutlet var boardTimeLabel: WKInterfaceLabel!
@IBOutlet var statusLabel: WKInterfaceLabel!
@IBOutlet var gateLabel: WKInterfaceLabel!
@IBOutlet var seatLabel: WKInterfaceLabel!
</code></pre>

<p>这里仅仅为之前的每个label添加一个Outlet。稍后会把他们连接起来。</p>

<p>下一步,在outlets下面添加flight属性和对应的属性观察器:</p>

<pre><code>// 1
var flight: Flight? {
  // 2
  didSet {
    // 3
    if let flight = flight {
      // 4
      flightLabel.setText("Flight \(flight.shortNumber)")
      routeLabel.setText(flight.route)
      boardingLabel.setText("\(flight.number) Boards")
      boardTimeLabel.setText(flight.boardsAt)
      // 5
      if flight.onSchedule {
        statusLabel.setText("On Time")
      } else {
        statusLabel.setText("Delayed")
        statusLabel.setTextColor(UIColor.redColor())
      }
      gateLabel.setText("Gate \(flight.gate)")
      seatLabel.setText("Seat \(flight.seat)")
    }
  }
}
</code></pre>

<p>会一步步讲解发生的事情:</p>

<ul>
<li><p>1.你定义了一个可选的属性类型为Flight。这个类在Flight.swift中定义;</p></li>
<li><p>2.你添加了一个属性观察器,当属性设值时候会触发它;</p></li>
<li><p>3.在可选属性中确保有一个真的flight而不是nil,当flight存在才会去设置labels的值;</p></li>
<li><p>4.使用flight的相关属性去设置labels</p></li>
<li><p>5.如果航班被延误，那么你就将标签的文本颜色改为红色</p></li>
</ul>


<p>在控制器第一次显示时候设置航班。添加以下声明：</p>

<pre><code>override func awakeWithContext(context: AnyObject?) {
  super.awakeWithContext(context)
  flight = Flight.allFlights().first!
}
</code></pre>

<p>本后面的教程会修改为在上下文中传递值给它,但现在你只需要从共享的JSON文件中加载所有的航班,然后使用数组中的第一个。</p>

<p>在后面的教程你将学到更多关于awakeWithContext（_：)的知识,但是现在你仅仅需要知道它是界面控制器生命周期第一环节,一个设置flight值的地方。 现在仅剩最后一步你就可以编译运行了,就是去连接outlets</p>

<p>连接outlets</p>

<p>打开 Watch\Interface.storyboard 选择界面控制器,使用Identity Inspector,设置Class\Custom Class为FlightInterfaceController</p>

<p>下一步,右击界面控制器顶部的黄色图片弹出窗口:</p>

<p><img src="http://al1020119.github.io/images/watchOS023.png" title="Caption" ></p>

<p>现在,按下面的列表连接outlets:</p>

<pre><code>boardingLabel: AA123 Boards
boardTimeLabel: 15:06
flightLabel: Flight 123
gateLabel: Gate 1A
routeLabel: MAN to SFO
seatLabel: Seat 64A
statusLabel: On time
</code></pre>

<p>在运行之前,有一件事情要做。本教程的实例app专为42mm的Apple Watch开发的,所以你需要确保正确设置了模拟器,否则界面元素看起来会有点小。对于一个现实app,需要确保界面能很好运行在两种大小的手表上,但这在本教程的范围之外。</p>

<p>在Xcode中,选择Window\Devices打开设备管理器,点击右下角的 + 图标.在弹出的对话框中,命名模拟器为iPhone 6 - 42mm,设置设备类型为iPhone 6,修改配对的Apple watch为Apple Watch - 42mm (WatchOS 2.0)然后点击Create:</p>

<p><img src="http://al1020119.github.io/images/watchOS024.png" title="Caption" ></p>

<p>关闭设备管理器,选择Watch Scheme,然后选中新的模拟器:</p>

<p><img src="http://al1020119.github.io/images/watchOS025.png" title="Caption" ></p>

<p>编译运行。一段模拟器启动完成你会看到下面界面:</p>

<p><img src="http://al1020119.github.io/images/watchOS026.png" title="Caption" ></p>

<blockquote><p>注意:如果收到一条错误消息,说明安装失败,然后你可以再次尝试使用Xcode,或者在手表模拟器上手动安装app。为此,打开iOS模拟器中的手表app,点击AirAber,在Apple Watch弹出我们的app。一旦这么做了,返回手表模拟器,按Shift + Ctrl + H导航到主界面, 然后点击AirAber图片来启动手表app。</p></blockquote>

<p>恭喜!你已经完成WatchKit初始界面,并使用真实的数据使它很好运行在手表模拟器上。</p>

<p>稍后会做什么?</p>

<p>下面是这个系列教程完整示例项目。</p>

<p>在这个练习中你已经学会了如何往现有的iOS app中添加手表app，如何创建一个界面控制器和使用嵌套组构造一个非常复杂的界面，以及使用WKInterfaceController类来配合这项工作。那么，接下来呢？</p>

<p>本教程系列的第二部分，你将学习所有关于表和导航WatchKit的使用。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[方法缓存]]></title>
    <link href="http://al1020119.github.io/blog/2015/12/08/fang-fa-huan-cun/"/>
    <updated>2015-12-08T17:42:41+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/12/08/fang-fa-huan-cun</id>
    <content type="html"><![CDATA[<blockquote><p>摘要
只要用到Objective-C，我们每天都会跟方法调用打交道。我们都知道Objective-C的方法决议是动态的，但是在底层一个方法究竟是怎么找到的，方法缓存又是怎么运作的却鲜为人知。本文主要从源码角度探究了Objective-C在runtime层的方法决议（Method resolving）过程和方法缓存（Method cache）的实现。</p></blockquote>

<p>简介
本文作者来自美团酒店旅游事业群iOS研发组。我们致力于创造价值、提升效率、追求卓越。欢迎大家加入我们（简历请发送到邮箱 <a href="&#109;&#97;&#x69;&#x6c;&#x74;&#x6f;&#58;&#109;&#97;&#x6a;&#105;&#97;&#x30;&#51;&#x40;&#x6d;&#x65;&#105;&#116;&#117;&#97;&#110;&#x2e;&#x63;&#x6f;&#x6d;">&#x6d;&#97;&#x6a;&#105;&#97;&#48;&#51;&#64;&#x6d;&#101;&#x69;&#x74;&#117;&#x61;&#x6e;&#46;&#x63;&#111;&#109;</a> ）。</p>

<p>本文系学习Objective-C的runtime源码时整理所成，主要剖析了Objective-C在runtime层的方法决议过程和方法缓存，内容包括：</p>

<ul>
<li>从消息决议说起</li>
<li>缓存为谁而生</li>
<li>追本溯源，何为方法缓存</li>
<li>缓存和散列</li>
<li>十万个为什么</li>
<li>缓存 - 性能优化的万金油？</li>
<li>优化，永无止境</li>
<li>从消息决议说起</li>
</ul>


<!--more-->


<p>我们都知道，在Objective-C里调用一个方法是这样的：</p>

<pre><code>[object methodA];
</code></pre>

<p>这表示我们想去调用object的methodA。
但是在Objective-C里面调用一个方法到底意味着什么呢，是否和C++一样，任何一个非虚方法都会被编译成一个唯一的符号，在调用的时候去查找符号表，找到这个方法然后调用呢？
答案是否定的。在Objective-C里面调用一个方法的时候，runtime层会将这个调用翻译成</p>

<pre><code>objc_msgSend(id self, SEL op, ...)
</code></pre>

<p>而objc_msgSend具体又是如何分发的呢？ 我们来看下runtime层objc_msgSend的源码。
在objc-msg-arm.s中，objc_msgSend的代码如下：
（ps：Apple为了高度优化objc_msgSend的性能，这个文件是汇编写成的，不过即使我们不懂汇编，详尽的注释也可以让我们一窥其真面目）</p>

<pre><code>ENTRY objc_msgSend
# check whether receiver is nil
teq     a1, #0
    beq     LMsgSendNilReceiver

# save registers and load receiver's class for CacheLookup
stmfd   sp!, {a4,v1}
ldr     v1, [a1, #ISA]

# receiver is non-nil: search the cache
CacheLookup a2, v1, LMsgSendCacheMiss

# cache hit (imp in ip) and CacheLookup returns with nonstret (eq) set, restore registers and call
ldmfd   sp!, {a4,v1}
bx      ip

# cache miss: go search the method lists
LMsgSendCacheMiss:
ldmfd sp!, {a4,v1}
b _objc_msgSend_uncached

LMsgSendNilReceiver:
    mov     a2, #0
    bx      lr

LMsgSendExit:
END_ENTRY objc_msgSend


STATIC_ENTRY objc_msgSend_uncached

# Push stack frame
stmfd sp!, {a1-a4,r7,lr}
add     r7, sp, #16

# Load class and selector
ldr a3, [a1, #ISA] /* class = receiver-&gt;isa  */
/* selector already in a2 */
/* receiver already in a1 */

# Do the lookup
MI_CALL_EXTERNAL(__class_lookupMethodAndLoadCache3)
MOVE    ip, a1

# Prep for forwarding, Pop stack frame and call imp
teq v1, v1 /* set nonstret (eq) */
ldmfd sp!, {a1-a4,r7,lr}
bx ip
</code></pre>

<p>从上述代码中可以看到，objc_msgSend（就arm平台而言）的消息分发分为以下几个步骤：</p>

<p>判断receiver是否为nil，也就是objc_msgSend的第一个参数self，也就是要调用的那个方法所属对象
从缓存里寻找，找到了则分发，否则
利用objc-class.mm中_class_lookupMethodAndLoadCache3（为什么有个这么奇怪的方法。本文末尾会解释）方法去寻找selector</p>

<p>如果支持GC，忽略掉非GC环境的方法（retain等）
从本class的method list寻找selector，如果找到，填充到缓存中，并返回selector，否则
寻找父类的method list，并依次往上寻找，直到找到selector，填充到缓存中，并返回selector，否则
调用_class_resolveMethod，如果可以动态resolve为一个selector，不缓存，方法返回，否则
转发这个selector，否则
报错，抛出异常
缓存为谁而生
从上面的分析中我们可以看到，当一个方法在比较“上层”的类中，用比较“下层”（继承关系上的上下层）对象去调用的时候，如果没有缓存，那么整个查找链是相当长的。就算方法是在这个类里面，当方法比较多的时候，每次都查找也是费事费力的一件事情。
考虑下面的一个调用过程：</p>

<pre><code>for ( int i = 0; i &lt; 100000; ++i) {
    MyClass *myObject = myObjects[i];
    [myObject methodA];
}
</code></pre>

<p>当我们需要去调用一个方法数十万次甚至更多地时候，查找方法的消耗会变的非常显著。
就算我们平常的非大规模调用，除非一个方法只会调用一次，否则缓存都是有用的。在运行时，那么多对象，那么多方法调用，节省下来的时间也是非常可观的。</p>

<p>追本溯源，何为方法缓存
本着源码面前，了无秘密的原则，我们看下源码中的方法缓存到底是什么，在objc-cache.mm中，objc_cache的定义如下：</p>

<pre><code>struct objc_cache {
    uintptr_t mask;            /* total = mask + 1 */
    uintptr_t occupied;       
    cache_entry *buckets[1];
};
</code></pre>

<p>嗯，objc_cache的定义看起来很简单，它包含了下面三个变量：</p>

<ul>
<li>1)、mask：可以认为是当前能达到的最大index（从0开始的），所以缓存的size（total）是mask+1</li>
<li>2)、occupied：被占用的槽位，因为缓存是以散列表的形式存在的，所以会有空槽，而occupied表示当前被占用的数目</li>
<li>3)、buckets：用数组表示的hash表，cache_entry类型，每一个cache_entry代表一个方法缓存
(buckets定义在objc_cache的最后，说明这是一个可变长度的数组)</li>
</ul>


<p>而cache_entry的定义如下：</p>

<pre><code>typedef struct {
    SEL name;     // same layout as struct old_method
    void *unused;
    IMP imp;  // same layout as struct old_method
} cache_entry;
</code></pre>

<p>cache_entry定义也包含了三个字段，分别是：</p>

<ul>
<li>1)、name，被缓存的方法名字</li>
<li>2)、unused，保留字段，还没被使用。</li>
<li>3)、imp，方法实现</li>
</ul>


<p>缓存和散列
缓存的存储使用了散列表。
为什么要用散列表呢？因为散列表检索起来更快，我们来看下是方法缓存如何散列和检索的：</p>

<pre><code>// Scan for the first unused slot and insert there.
// There is guaranteed to be an empty slot because the 
// minimum size is 4 and we resized at 3/4 full.
buckets = (cache_entry **)cache-&gt;buckets;
for (index = CACHE_HASH(sel, cache-&gt;mask); 
     buckets[index] != NULL; 
     index = (index+1) &amp; cache-&gt;mask)
{
    // empty
}
buckets[index] = entry;
</code></pre>

<p>这是往方法缓存里存放一个方法的代码片段，我们可以看到sel被散列后找到一个空槽放在buckets中，而CACHE_HASH的定义如下：</p>

<pre><code>#define CACHE_HASH(sel, mask) (((uintptr_t)(sel)&gt;&gt;2) &amp; (mask))
</code></pre>

<p>这段代码就是利用了sel的指针地址和mask做了一下简单计算得出的。
而从散列表取缓存则是利用汇编语言写成的（是为了高度优化objc_msgSend而使用汇编的）。我们看objc-msg-arm.mm 里面的CacheLookup方法：</p>

<pre><code>.macro CacheLookup /* selReg, classReg, missLabel */

 MOVE r9, $0, LSR #2          /* index = (sel &gt;&gt; 2) */
 ldr     a4, [$1, #CACHE]        /* cache = class-&gt;cache */
 add     a4, a4, #BUCKETS        /* buckets = &amp;cache-&gt;buckets */

/* search the cache */
/* a1=receiver, a2 or a3=sel, r9=index, a4=buckets, $1=method */
1:
 ldr     ip, [a4, #NEGMASK]      /* mask = cache-&gt;mask */
 and     r9, r9, ip              /* index &amp;= mask           */
 ldr     $1, [a4, r9, LSL #2]    /* method = buckets[index] */
 teq     $1, #0                  /* if (method == NULL)     */
 add     r9, r9, #1              /* index++                 */
 beq     $2                      /*     goto cacheMissLabel */

 ldr     ip, [$1, #METHOD_NAME]  /* load method-&gt;method_name        */
 teq     $0, ip                  /* if (method-&gt;method_name != sel) */
 bne     1b                      /*     retry                       */

/* cache hit, $1 == method triplet address */
/* Return triplet in $1 and imp in ip      */
 ldr     ip, [$1, #METHOD_IMP]   /* imp = method-&gt;method_imp */

.endmacro
</code></pre>

<p>虽然是汇编，但是注释太详尽了，理解起来并不难，还是求hash，去buckets里找，找不到按照hash冲突的规则继续向下，直到最后。</p>

<p>十万个为什么
了解了方法缓存的定义之后，我们提出几个问题并一一解答</p>

<p>方法缓存存在什么地方？
让我们去翻看类的定义，在Objective-C 2.0中，Class的定义大致是这样的（见objc-runtime.mm）</p>

<pre><code>  struct _class_t {
  struct _class_t *isa;
  struct _class_t *superclass;
  void *cache;
  void *vtable;
  struct _class_ro_t *ro;
  };
</code></pre>

<p>我们看到在类的定义里就有cache字段，没错，类的所有缓存都存在metaclass上，所以每个类都只有一份方法缓存，而不是每一个类的object都保存一份。
父类方法的缓存只存在父类么，还是子类也会缓存父类的方法？
在第一节对objc_msgSend的追溯中我们可以看到，即便是从父类取到的方法，也会存在类本身的方法缓存里。而当用一个父类对象去调用那个方法的时候，也会在父类的metaclass里缓存一份。
类的方法缓存大小有没有限制？
要回答这个问题，我们需要再看一下源码，在objc-cache.mm有一个变量定义如下：</p>

<pre><code>  /* When _class_slow_grow is non-zero, any given cache is actually grown
   * only on the odd-numbered times it becomes full; on the even-numbered
   * times, it is simply emptied and re-used.  When this flag is zero,
   * caches are grown every time. */
  static const int _class_slow_grow = 1;
</code></pre>

<p>其实不用再看进一步的代码片段，仅从注释我们就可以看到问题的答案。注释中说明，当<em>class_slow_grow是非0值的时候，只有当方法缓存第奇数次满（使用的槽位超过3/4）的时候，方法缓存的大小才会增长（会清空缓存，否则hash值就不对了）；当第偶数次满的时候，方法缓存会被清空并重新利用。 如果</em>class_slow_grow值为0，那么每一次方法缓存满的时候，其大小都会增长。
所以单就问题而言，答案是没有限制，虽然这个值被设置为1，方法缓存的大小增速会慢一点，但是确实是没有上限的。
为什么类的方法列表不直接做成散列表呢，做成list，还要单独缓存，多费事？
这个问题么，我觉得有以下三个原因：</p>

<p>散列表是没有顺序的，Objective-C的方法列表是一个list，是有顺序的；Objective-C在查找方法的时候会顺着list依次寻找，并且category的方法在原始方法list的前面，需要先被找到，如果直接用hash存方法，方法的顺序就没法保证。
list的方法还保存了除了selector和imp之外其他很多属性
散列表是有空槽的，会浪费空间
缓存 - 性能优化的万金油？
非也，就算有了有了Objective-C本身的方法缓存，我们还是有很多调用方法的优化空间，对于这件事情，这篇文章讲的非常详细，大家可以自行移步观摩<a href="http://www.mulle-kybernetik.com/artikel/Optimization/opti-3-imp-deluxe.html">http://www.mulle-kybernetik.com/artikel/Optimization/opti-3-imp-deluxe.html</a> （强烈推荐，虽然我们一般不会遇到需要这么强度优化的地方，但是这种精神和思想是值得我们学习的）</p>

<p>优化，永无止境
在文章末尾，我们再来回答一下第一节提出的问题：“为什么会有_class_lookupMethodAndLoadCache3这个方法？”
这个方法的实现如下所示：</p>

<pre><code>/***********************************************************************
* _class_lookupMethodAndLoadCache.
* Method lookup for dispatchers ONLY. OTHER CODE SHOULD USE lookUpImp().
* This lookup avoids optimistic cache scan because the dispatcher
* already tried that.
**********************************************************************/
IMP _class_lookupMethodAndLoadCache3(id obj, SEL sel, Class cls)
{
    return lookUpImpOrForward(cls, sel, obj, 
                              YES/*initialize*/, NO/*cache*/, YES/*resolver*/);
}
</code></pre>

<p>如果单纯看方法名，这个方法应该会从缓存和方法列表中查找一个方法，但是如第一节所讲，在调用这个方法之前，我们已经是从缓存无法找到这个方法了，所以这个方法避免了再去扫描缓存查找方法的过程，而是直接从方法列表找起。从Apple代码的注释，我们也完全可以了解这一点。不顾一切地追求完美和性能，是一种品质。</p>

<p>后记
本文是Objective-C runtime源码研究的第二篇，主要对Objective-C的方法决议和方法缓存做了剖析。runtime的源代码可以在 <a href="http://www.opensource.apple.com/tarballs/">http://www.opensource.apple.com/tarballs/</a> 下载。如有错误，敬请指正。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iBeacon初探]]></title>
    <link href="http://al1020119.github.io/blog/2015/12/08/ibeaconchu-tan/"/>
    <updated>2015-12-08T17:42:15+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/12/08/ibeaconchu-tan</id>
    <content type="html"><![CDATA[<blockquote><p>iBeacon 是苹果公司在 iOS 7 中新推出的一种近场定位技术，可以感知一个附近的 iBeacon 信标的存在。
当一个 iBeacon 兼容设备进入/退出一个 iBeacon 信标标识的区域时，iOS 和支持 iBeacon 的 app 就能得知这一信息，从而对用户发出相应的通知。</p></blockquote>

<p>典型的应用场景例如博物馆实时推送附近展品的相关信息，商场内即时通知客户折扣信息
等。苹果在 Apple Store 中也部署了 iBeacon 来推送优惠、活动信息。</p>

<!--more-->


<h4>Apple Store 中的 iBeacon 支持</h4>

<h6>特点</h6>

<pre><code>iBeacon 基于低功耗蓝牙技术（Bluetooth Low Energy, BLE）这一开放标准，因此也继承了 BLE 的一些特点。
</code></pre>

<h6>范围广</h6>

<pre><code>相比于 NFC 的数厘米的识别范围，iBeacon 的识别范围可以达到数十米，并且能够估计距离的远近。
</code></pre>

<h6>兼容性</h6>

<pre><code>iBeacon 是基于 BLE 做的一个简单封装，因此大部分支持 BLE 的设备都可以兼容。
例如可以使用一个普通的蓝牙芯片作为信标，使用 Android 设备检测信标的存在。
</code></pre>

<h6>低能耗</h6>

<pre><code>不少 beacon 实现宣称可以不依赖外部能源独立运行两年。
</code></pre>

<h6>使用场景</h6>

<pre><code>我们以一个连锁商场的例子来讲解 iBeacon 的一个流程。在一个连锁商场中，店家需要在商场中的不同地方推送不同的优惠信息，比如服装和家居柜台推送的消息就很有可能不同。
</code></pre>

<p>当消费者走进某个商场时，会扫描到一个 beacon。这个 beacon 有三个标志符，proximityUUID 是一个整个公司（所有连锁商场）统一的值，可以用来标识这个公司，major 值用来标识特定的连锁商场，比如消费者正在走进的商场，minor 值标识了特定的一个位置的 beacon，例如定位到消费者正在门口。</p>

<p>这时商场的 app 会被系统唤醒，app 可以运行一个比较短的时间。在这段时间内，app 可以根据 beacon 的属性查询到用户的地理位置（通过查询服务器或者本地数据），例如在化妆品专柜，之后就可以通过一个 local notification 推送化妆品的促销信息。用户可以点击这次 local notification 来查看更详细的信息，这样一次促销行为就完成了。</p>

<h6>API</h6>

<pre><code>闲话少说，我们来看下 iBeacon 具体怎么使用：
</code></pre>

<h6>Beacon 的表示</h6>

<pre><code>iBeacon 本质上来说是一个位置（区域）信息，所以 Apple 把 iBeacon 功能集成在了 Core Location 里面。
</code></pre>

<p>iBeacon 信标在 Core Location 中表现为一个 CLBeacon，它圈定的范围则表现为 CLBeaconRegion，这是一个 CLRegion 的子类。</p>

<p>CLBeaconRegion 主要用三个属性来标识一个 iBeacon，proximityUUID、major 和 minor。
proximityUUID 是一个 NSUUID，用来标识公司，每个公司、组织使用的 iBeacon 应该拥有同样的 proximityUUID。
major 用来识别一组相关联的 beacon，例如在连锁超市的场景中，每个分店的 beacon 应该拥有同样的 major。
minor 则用来区分某个特定的 beacon。</p>

<pre><code>这些属性如果不指定（即 nil），匹配的时候就会忽略这个属性。例如只指定 proximityUUID 的 CLBeaconRegion 可以匹配某公司的所有 beacons。
</code></pre>

<h6>Monitoring</h6>

<pre><code>Apple 在 iOS 4 中增加了地理围栏 API，可以用来在设备进入/退出某个地理区域时获得通知，这些 API 包括 -startMonitoringForRegion:、-locationManager:didEnterRegion:、-locationManager:didExitRegion: 等。
</code></pre>

<p>CLBeaconRegion 作为 CLRegion 的子类也可以复用这些 API，这种检测 iBeacon 的方式叫做 monitoring。</p>

<p>使用这种方法可以在程序在后台运行时检测 iBeacon，但是只能同时检测 20 个 region，也不能推测设备与 beacon 的距离。</p>

<h6>Ranging</h6>

<pre><code>除了使用地理围栏 API 的方式，Apple 还在 iOS 7 中新增加了 iBeacon 专用的检测方式，也就是 ranging。
</code></pre>

<p>通过 CLLocationManager 的 -startRangingBeaconsInRegion: 方法可以开始检测特定的 iBeacon。</p>

<p>当检测到 beacon 的时候，CLLocationManager 的 delegate 方法 -locationManager:didRangeBeacons:inRegion: 会被调用，通知调用者现在被检测到的 beacons。
这个方法会返回一个 CLBeacon 的数组，根据 CLBeacon 的 proximity 属性就可以判断设备和 beacon 之间的距离。</p>

<blockquote><p>proximity 属性有四个可能的值，unknown、immediate、near 和 far。
另外 CLBeacon 还有 accuracy 和 rssi 两个属性能提供更详细的距离数据。</p></blockquote>

<h6>使用 iOS 设备作为 iBeacon</h6>

<p>我们可以使用 Core Bluetooth 框架来广播特定的 payload 来让 iOS 设备成为一个 iBeacon。
这个 payload 可以由 CLBeaconRegion 的 -peripheralDataWithMeasuredPower: 方法来获取。
之后交给 CBPeripheralManager 广播出去就可以了。</p>

<p>需要注意的是，广播 iBeacon 信息的时候 app 必须在前台运行。</p>

<h6>行为</h6>

<p>iBeacon 的 API 并不十分复杂，但他的行为比较难弄清楚，特别是当应用运行在后台时，检测到 beacon 的时间延迟会让开发者难以推测。在做了一些实验和合理的推测后，我们得出了一些</p>

<blockquote><p>结论：
检测到 beacon 的时间跟设备进行蓝牙扫描的时间间隔有关，每当设备进行扫描的时候，就能发现 iBeacon region 的变化。
在 ranging 打开的情况下，设备会每秒钟做一次扫描，也就是说状态更新最多延迟一秒。
程序在后台运行，并且 monitoring 打开的时候，设备可能每隔数分钟做一次扫描。iOS 7 的响应速度较慢，iOS 7.1 有比较大的改善。
如果存在设置 notifyEntryStateOnDisplay=YES 的 beacon，iOS 会在屏幕点亮的时候（锁屏状态下按下 home 键，或者因为收到推送点亮等）进行一次扫描。
设备重启并不影响 iBeacon 后台检测的执行。
iOS 7 中，在多任务界面中杀掉程序会终止 iBeacon 检测的执行，iOS 7.1 上改变了这一行为，被杀掉的 app 还可以继续进行 iBeacon 检测。</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[怎么封装一个控件]]></title>
    <link href="http://al1020119.github.io/blog/2015/12/07/zen-yao-feng-zhuang-%5B%3F%5D-ge-kong-jian/"/>
    <updated>2015-12-07T17:44:16+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/12/07/zen-yao-feng-zhuang-[?]-ge-kong-jian</id>
    <content type="html"><![CDATA[<p>一个控件从外在特征来说，主要是封装这几点：</p>

<ul>
<li>交互方式</li>
<li>显示样式</li>
<li>数据使用</li>
</ul>


<p>对外在特征的封装，能让我们在多种环境下达到 PM 对产品的要求，并且提到代码复用率，使维护工作保持在一个相对较小的范围内；而一个好的控件除了有对外一致的体验之外，还有其内在特征：</p>

<ul>
<li>灵活性</li>
<li>低耦合</li>
<li>易拓展</li>
<li>易维护</li>
</ul>


<!--more-->


<p>通常特征之间需要做一些取舍，比如灵活性与耦合度，有时候接口越多越能适应各种环境，但是接口越少对外产生的依赖就越少，维护起来也更容易。通常一些前期看起来还不错的代码，往往也会随着时间加深慢慢“成长”，功能的增加也会带来新的接口，很不自觉地就加深了耦合度，在开发中时不时地进行一些重构工作很有必要。总之，尽量减少接口的数量，但有足够的定制空间，可以在一开始把接口全部隐藏起来，再根据实际需要慢慢放开。</p>

<p>自定义控件在 iOS 项目里很常见，通常页面之间入口很多，而且使用场景极有可能大不相同，比如一个 UIView 既可以以代码初始化，也可以以 xib 的形式初始化，而我们是需要保证这两种操作都能产生同样的行为。本文将会讨论到以下几点：</p>

<ul>
<li>选择正确的初始化方式</li>
<li>调整布局的时机</li>
<li>正确的处理 touches 方法</li>
<li>drawRectCALayer 与动画</li>
<li>UIControl 与 UIButton</li>
<li>更友好的支持 xib</li>
<li>不规则图形和事件触发范围（事件链的简单介绍以及处理）</li>
<li>合理使用 KVO</li>
</ul>


<p>如果这些问题你一看就懂的话就不用继续往下看了。</p>

<p>设计方针</p>

<p>选择正确的初始化方式</p>

<p>UIView 的首要问题就是既能从代码中初始化，也能从 xib 中初始化，两者有何不同? UIView 是支持 NSCoding 协议的，当在 xib 或 storyboard 里存在一个 UIView 的时候，其实是将 UIView 序列化到文件里（xib 和 storyboard 都是以 XML 格式来保存的），加载的时候反序列化出来，所以：</p>

<ul>
<li>当从代码实例化 UIView 的时候，initWithFrame 会执行；</li>
<li>当从文件加载 UIView 的时候，initWithCoder 会执行。</li>
</ul>


<p>从代码中加载</p>

<p>虽然 initWithFrame 是 UIView 的Designated Initializer，理论上来讲你继承自 UIView 的任何子类，该方法最终都会被调用，但是有一些类在初始化的时候没有遵守这个约定，如 UIImageView 的 initWithImage 和 UITableViewCell 的 initWithStyle:reuseIdentifier: 的构造器等，所以我们在写自定义控件的时候，最好只假设父视图的 Designated Initializer 被调用。</p>

<p>如果控件在初始化或者在使用之前必须有一些参数要设置，那我们可以写自己的 Designated Initializer 构造器，如：</p>

<pre><code>- (instancetype)initWithName:(NSString *)name;
</code></pre>

<p>在实现中一定要调用父类的 Designated Initializer，而且如果你有多个自定义的 Designated Initializer，最终都应该指向一个全能的初始化构造器：</p>

<pre><code>- (instancetype)initWithName:(NSString *)name {
    self = [self initWithName:name frame:CGRectZero];
    return self;
}
- (instancetype)initWithName:(NSString *)name frame:(CGRect)frame {
    self = [super initWithFrame:frame];
    if (self) {
        self.name = name;
    }
    return self;
}
</code></pre>

<p>并且你要考虑到，因为你的控件是继承自 UIView 或 UIControl 的，那么用户完全可以不使用你提供的构造器，而直接调用基类的构造器，所以最好重写父类的 Designated Initializer，使它调用你提供的 Designated Initializer ，比如父类是个 UIView：</p>

<pre><code>- (instancetype)initWithFrame:(CGRect)frame {
    self = [self initWithName:nil frame:frame];
    return self;
}
</code></pre>

<p>这样当用户从代码里初始化你的控件的时候，就总是逃脱不了你需要执行的初始化代码了，哪怕用户直接调用 init 方法，最终还是会回到父类的 Designated Initializer 上。</p>

<p>从 xib 或 storyboard 中加载</p>

<p>当控件从 xib 或 storyboard 中加载的时候，情况就变得复杂了，首先我们知道有 initWithCoder 方法，该方法会在对象被反序列化的时候调用，比如从文件加载一个 UIView 的时候：</p>

<pre><code>UIView *view = [[UIView alloc] init];
NSData *data = [NSKeyedArchiver archivedDataWithRootObject:view];
[[NSUserDefaults standardUserDefaults] setObject:data forKey:@"KeyView"];
[[NSUserDefaults standardUserDefaults] synchronize];
data = [[NSUserDefaults standardUserDefaults] objectForKey:@"KeyView"];
view = [NSKeyedUnarchiver unarchiveObjectWithData:data];
NSLog(@"%@", view);
</code></pre>

<p>执行 unarchiveObjectWithData 的时候， initWithCoder 会被调用，那么你有可能会在这个方法里做一些初始化工作，比如恢复到保存之前的状态，当然前提是需要在 encodeWithCoder 中预先保存下来。</p>

<p>不过我们很少会自己直接把一个 View 保存到文件中，一般是在 xib 或 storyboard 中写一个 View，然后让系统来完成反序列化的工作，此时在 initWithCoder 调用之后，awakeFromNib 方法也会被执行，既然在 awakeFromNib 方法里也能做初始化操作，那我们如何抉择?</p>

<p>一般来说要尽量在 initWithCoder 中做初始化操作，毕竟这是最合理的地方，只要你的控件支持序列化，那么它就能在任何被反序列化的时候执行初始化操作，这里适合做全局数据、状态的初始化工作，也适合手动添加子视图。</p>

<p>awakeFromNib 相较于 initWithCoder 的优势是：当 awakeFromNib 执行的时候，各种 IBOutlet 也都连接好了；而 initWithCoder 调用的时候，虽然子视图已经被添加到视图层级中，但是还没有引用。如果你是基于 xib 或 storyboard 创建的控件，那么你可能需要对 IBOutlet 连接的子控件进行初始化工作，这种情况下，你只能在 awakeFromNib 里进行处理。同时 xib 或 storyboard 对灵活性是有打折的，因为它们创建的代码无法被继承，所以当你选择用 xib 或 storyboard 来实现一个控件的时候，你已经不需要对灵活性有很高的要求了，唯一要做的是要保证用户一定是通过 xib 创建的此控件，否则可能是一个空的视图，可以在 initWithFrame 里放置一个 断言 或者异常来通知控件的用户。</p>

<p>最后还要注意视图层级的问题，比如你要给 View 放置一个背景，你可能会在 initWithCoder 或 awakeFromNib 中这样写：</p>

<pre><code>[self addSubview:self.backgroundView]; // 通过懒加载一个背景 View，然后添加到视图层级上
</code></pre>

<p>你的本意是在控件的最下面放置一个背景，却有可能将这个背景覆盖到控件的最上方，原因是用户可能会在 xib 里写入这个控件，然后往它上面添加一些子视图，这样一来，用户添加的这些子视图会在你添加背景之前先进入视图层级，你的背景被添加后就挡住了用户的子视图。如果你想支持用户的这种操作，可以把 addSubview 替换成 insertSubview:atIndex:。</p>

<p>同时支持从代码和文件中加载</p>

<p>如果你要同时支持 initWithFrame 和 initWithCoder ，那么你可以提供一个 commonInit 方法来做统一的初始化：</p>

<pre><code>- (id)initWithCoder:(NSCoder *)aDecoder {
    self = [super initWithCoder:aDecoder];
    if (self) {
        [self commonInit];
    }
    return self;
}
- (id)initWithFrame:(CGRect)frame {
    self = [super initWithFrame:frame];
    if (self) {
        [self commonInit];
    }
    return self;
}
- (void)commonInit {
    // do something ...
}
</code></pre>

<p>awakeFromNib 方法里就不要再去调用 commonInit 了。</p>

<p>调整布局的时机</p>

<p>当一个控件被初始化以及开始使用之后，它的 frame 仍然可能发生变化，我们也需要接受这些变化，因为你提供的是 UIView 的接口，UIView 有很多种初始化方式：initWithFrame、initWithCoder、init 和类方法 new，用户完全可以在初始化之后再设置 frame 属性，而且用户就算使用 initWithFrame 来初始化也避免不了 frame 的改变，比如在横竖屏切换的时候。为了确保当它的 Size 发生变化后其子视图也能同步更新，我们不能一开始就把布局写死（使用约束除外）。</p>

<p>基于 frame</p>

<p>如果你是直接基于 frame 来布局的，你应该确保在初始化的时候只添加视图，而不去设置它们的frame，把设置子视图 frame 的过程全部放到 layoutSubviews 方法里：</p>

<pre><code>- (instancetype)initWithCoder:(NSCoder *)aDecoder {
    self = [super initWithCoder:aDecoder];
    if (self) {
        [self commonInit];
    }
    return self;
}
- (instancetype)initWithFrame:(CGRect)frame {
    self = [super initWithFrame:frame];
    if (self) {
        [self commonInit];
    }
    return self;
}
- (void)layoutSubviews {
    [super layoutSubviews];
    self.label.frame = CGRectInset(self.bounds, 20, 0);
}
- (void)commonInit {
    [self addSubview:self.label];
}
- (UILabel *)label {
    if (_label == nil) {
        _label = [UILabel new];
        _label.textColor = [UIColor grayColor];
    }
    return _label;
}
</code></pre>

<p>这么做就能保证 label 总是出现在正确的位置上。</p>

<p>使用 layoutSubviews 方法有几点需要注意：</p>

<p>不要依赖前一次的计算结果，应该总是根据当前最新值来计算
由于 layoutSubviews 方法是在自身的 bounds 发生改变的时候调用， 因此 UIScrollView 会在滚动时不停地调用，当你只关心 Size 有没有变化的时候，可以把前一次的 Size 保存起来，通过与最新的 Size 比较来判断是否需要更新，在大多数情况下都能改善性能
基于 Auto Layout 约束</p>

<p>如果你是基于 Auto Layout 约束来进行布局，那么可以在 commonInit 调用的时候就把约束添加上去，不要重写 layoutSubviews 方法，因为这种情况下它的默认实现就是根据约束来计算 frame。最重要的一点，把 translatesAutoresizingMaskIntoConstraints 属性设为 NO，以免产生 NSAutoresizingMaskLayoutConstraint 约束，如果你使用 Masonry 框架的话，则不用担心这个问题，mas_makeConstraints 方法会首先设置这个属性为 NO:</p>

<pre><code>- (void)commonInit {
    ...
    [self setupConstraintsForSubviews];
}
- (void)setupConstraintsForSubviews {
    [self.label mas_makeConstraints:^(MASConstraintMaker *make) {
        ...
    }];
}
</code></pre>

<p>支持 sizeToFit</p>

<p>如果你的控件对尺寸有严格的限定，比如有一个统一的宽高比或者是固定尺寸，那么最好能实现系统给出的约定成俗的接口。</p>

<p>sizeToFit 用在基于 frame 布局的情况下，由你的控件去实现 sizeThatFits: 方法：</p>

<pre><code>- (CGSize)sizeThatFits:(CGSize)size {
    CGSize fitSize = [super sizeThatFits:size];
    fitSize.height += self.label.frame.size.height;
    // 如果是固定尺寸，就像 UISwtich 那样返回一个固定 Size 就 OK 了
    return fitSize;
}
</code></pre>

<p>然后在外部调用该控件的 sizeToFit 方法，这个方法内部会自动调用 sizeThatFits 并更新自身的 Size：</p>

<p>[self.customView sizeToFit];
在 ViewController 里调整视图布局</p>

<p>当执行 viewDidLoad 方法时，不要依赖 self.view 的 Size。很多人会这样写：</p>

<pre><code>- (void)viewDidLoad {
    ...
    self.label.width = self.view.width;
}
</code></pre>

<p>这样是不对的，哪怕看上去没问题也只是碰巧没问题而已。当 viewDidLoad 方法被调用的时候，self.view 才刚刚被初始化，此时它的容器还没有对它的 frame 进行设置，如果 view 是从 xib 加载的，那么它的 Size 就是 xib 中设置的值；如果它是从代码加载的，那么它的 Size 和屏幕大小有关系，除了 Size 以外，Origin 也不会准确。整个过程看起来像这样：</p>

<p>当访问 ViewController 的 view 的时候，ViewController 会先执行 loadViewIfRequired 方法，如果 view 还没有加载，则调用 loadView，然后是 viewDidLoad 这个钩子方法，最后是返回 view，容器拿到 view 后，根据自身的属性（如 edgesForExtendedLayout、判断是否存在 tabBar、判断 navigationBar 是否透明等）添加约束或者设置 frame。</p>

<p>你至少应该设置 autoresizingMask 属性：</p>

<pre><code>- (void)viewDidLoad {
    ...
    self.label.width = self.view.width;
    self.label.autoresizingMask = UIViewAutoresizingFlexibleWidth;
}
</code></pre>

<p>或者在 viewDidLayoutSubviews 里处理：</p>

<pre><code>- (void)viewDidLayoutSubviews {
    [super viewDidLayoutSubviews];
    self.label.width = self.view.width;
}
</code></pre>

<p>如果是基于 Auto Layout 来布局，则在 viewDidLoad 里添加约束即可。</p>

<p>正确的处理 touches 方法</p>

<p>如果你需要重写 touches 方法，那么应该完整的重写这四个方法：</p>

<pre><code>- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event;
- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event;
- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event;
- (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event;
</code></pre>

<p>当你的视图在这四个方法执行的时候，如果已经对事件进行了处理，就不要再调用 super 的 touches 方法，super 的 touches 方法默认实现是在响应链里继续转发事件（UIView 的默认实现）。如果你的基类是 UIScrollView 或者 UIButton 这些已经重写了事件处理的类，那么当你不想处理事件的时候可以调用 self.nextResponder 的 touches 方法来转发事件，其他的情况就调用 super 的 touches 方法来转发，比如 UIScrollView 可以这样来转发 触摸 事件：</p>

<pre><code>- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event {
    if (!self.dragging) {
        [self.nextResponder touchesBegan: touches withEvent:event]; 
    }       
    [super touchesBegan: touches withEvent: event];
}
- (void)touchesMoved...
- (void)touchesEnded...
- (void)touchesCancelled...
</code></pre>

<p>这么实现以后，当你仅仅只是“碰”一个 UIScrollView 的时候，该事件就有可能被 nextResponder 处理。</p>

<p>如果你没有实现自己的事件处理，也没有调用 nextResponder 和 super，那么响应链就会断掉。另外，尽量用手势识别器去处理自定义事件，它的好处是你不需要关心响应链，逻辑处理起来也更加清晰，事实上，UIScrollView 也是通过手势识别器实现的：</p>

<pre><code>@property(nonatomic, readonly) UIPanGestureRecognizer *panGestureRecognizer NS_AVAILABLE_IOS(5_0); 
@property(nonatomic, readonly) UIPinchGestureRecognizer *pinchGestureRecognizer NS_AVAILABLE_IOS(5_0);
</code></pre>

<p>drawRect、CALayer 与动画</p>

<p>drawRect 方法很适合做自定义的控件，当你需要更新 UI 的时候，只要用 setNeedsDisplay 标记一下就行了，这么做又简单又方便；控件也常常用于封装动画，但是动画却有可能被移除掉。</p>

<p>需要注意的地方：</p>

<ol>
<li>在 drawRect 里尽量用 CGContext 绘制 UI。如果你用 addSubview 插入了其他的视图，那么当系统在每次进入绘制的时候，会先把当前的上下文清除掉（此处不考虑 clearsContextBeforeDrawing 的影响），然后你也要清除掉已有的 subviews，以免重复添加视图；用户可能会往你的控件上添加他自己的子视图，然后在某个情况下清除所有的子视图（我就喜欢这么做）：</li>
</ol>


<p>[subviews makeObjectsPerformSelector:@selector(removeFromSuperview)];
2. 用 CALayer 代替 UIView。CALayer 节省内存，而且更适合去做一个“图层”，因为它不会接收事件、也不会成为响应链中的一员，但是它能够响应父视图（或 layer）的尺寸变化，这种特性很适合做单纯的数据展示：</p>

<pre><code>CALayer *imageLayer = [CALayer layer];
imageLayer.frame = rect;
imageLayer.contents = (id)image;
[self.view.layer addSublayer:imageLayer];
</code></pre>

<ol>
<li><p>如果有可能的话使用 setNeedsDisplayInRect 代替 setNeedsDisplay 以优化性能，但是遇到性能问题的时候应该先检查自己的绘图算法和绘图时机，我个人其实从来没有使用过 setNeedsDisplayInRect。</p></li>
<li><p>当你想做一个无限循环播放的动画的时候，可能会创建几个封装了动画的 CALayer，然后把它们添加到视图层级上，就像我在 iOS 实现脉冲雷达以及动态增减元素 By Swift 中这么做的：</p></li>
</ol>


<p><img src="http://al1020119.github.io/images/kongjianfengzhuang001.gif" title="Caption" ></p>

<p>效果还不错，实现又简单，但是当你按下 Home 键并再次返回到 app 的时候，原本好看的动画就变成了一滩死水：</p>

<p>这是因为在按下 Home 键的时候，所有的动画被移除了，具体的，每个 layer 都调用了 removeAllAnimations 方法。</p>

<p>如果你想重新播放动画，可以监听 UIApplicationDidBecomeActiveNotification 通知，就像我在 上述博客 中做的那样。</p>

<ol>
<li><p>UIImageView 的 drawRect 永远不会被调用：</p>

<pre><code> Special Considerations
 The UIImageView class is optimized to draw its images to the display. UIImageView will not call drawRect: in a subclass. If your subclass needs custom drawing code, it is recommended you use UIView as the base class.
</code></pre></li>
<li>UIView 的 drawRect 也不一定会调用，我在 12 年的博客：定制UINavigationBar 中曾经提到过 UIKit 框架的实现机制：</li>
</ol>


<p>众所周知一个视图如何显示是取决于它的 drawRect 方法，因为调这个方法之前 UIKit 也不知道如何显示它，但其实 drawRect 方法的目的也是画图（显示内容），而且我们如果以其他的方式给出了内容（图）的话， drawRect 方法就不会被调用了。</p>

<p>注：实际上 UIView 是 CALayer 的delegate，如果 CALayer 没有内容的话，会回调给 UIView 的 displayLayer: 或者 drawLayer:inContext: 方法，UIView 在其中调用 drawRect ，draw 完后的图会缓存起来，除非使用 setNeedsDisplay 或是一些必要情况，否则都是使用缓存的图。</p>

<p>UIView 和 CALayer 都是模型对象，如果我们以这种方式给出内容的话，drawRect 也就不会被调用了：</p>

<pre><code>self.customView.layer.contents = (id)[UIImage imageNamed:@"AppIcon"];
// 哪怕是给它一个 nil，这两句等价
self.customView.layer.contents = nil;
</code></pre>

<p>我猜测是在 CALayer 的 setContents 方法里有个标记，无论传入的对象是什么都会将该标记打开，但是调用 setNeedsDisplay 的时候会将该标记去除。</p>

<p>UIControl 与 UIButton</p>

<p>如果要做一个可交互的控件，那么把 UIControl 作为基类就是首选，这个完美的基类支持各种状态：</p>

<ul>
<li>enabled</li>
<li>selected</li>
<li>highlighted</li>
<li>tracking</li>
<li><p>……
还支持多状态下的观察者模式：</p>

<pre><code>  @property(nonatomic,readonly) UIControlState state;
  - (void)addTarget:(id)target action:(SEL)action forControlEvents:(UIControlEvents)controlEvents;
  - (void)removeTarget:(id)target action:(SEL)action forControlEvents:(UIControlEvents)controlEvents;
</code></pre>

<p>这个基类可以很方便地为视图添加各种点击状态，最常见的用法就是将 UIViewController 的 view 改成 UIControl，然后就能快速实现 resignFirstResponder。</p></li>
</ul>


<p>UIButton 自带图文接口，支持更强大的状态切换，titleEdgeInsets 和 imageEdgeInsets 也比较好用，配合两个基类的属性更好，先设置对齐规则，再设置 insets：</p>

<pre><code>@property(nonatomic) UIControlContentVerticalAlignment contentVerticalAlignment;    
@property(nonatomic) UIControlContentHorizontalAlignment contentHorizontalAlignment;
</code></pre>

<p>UIControl 和 UIButton 都能很好的支持 xib，可以设置各种状态下的显示和 Selector，但是对 UIButton 来说这些并不够，因为 Normal 、Highlighted 和 Normal | Highlighted 是三种不同的状态，如果你需要实现根据当前状态显示不同高亮的图片，可以参考我下面的代码：</p>

<p><img src="http://al1020119.github.io/images/kongjianfengzhuang002.png" title="Caption" ></p>

<pre><code>- (void)updateStates {
    [super setTitle:[self titleForState:UIControlStateNormal] forState:UIControlStateNormal | UIControlStateHighlighted];
    [super setImage:[self imageForState:UIControlStateNormal] forState:UIControlStateNormal | UIControlStateHighlighted];
    [super setTitle:[self titleForState:UIControlStateSelected] forState:UIControlStateSelected | UIControlStateHighlighted];
    [super setImage:[self imageForState:UIControlStateSelected] forState:UIControlStateSelected | UIControlStateHighlighted];
}
</code></pre>

<p>或者使用初始化设置：</p>

<pre><code>- (void)commonInit {
    [self setImage:[UIImage imageNamed:@"Normal"] forState:UIControlStateNormal];
    [self setImage:[UIImage imageNamed:@"Selected"] forState:UIControlStateSelected];
    [self setImage:[UIImage imageNamed:@"Highlighted"] forState:UIControlStateHighlighted];
    [self setImage:[UIImage imageNamed:@"Selected_Highlighted"] forState:UIControlStateSelected | UIControlStateHighlighted];
}
</code></pre>

<p>总之尽量使用原生类的接口，或者模仿原生类的接口。</p>

<p>大多数情况下根据你所需要的特性来选择现有的基类就够了，或者用 UIView + 手势识别器 的组合也是一个好方案，尽量不要用 touches 方法（userInteractionEnabled 属性对 touches 和手势识别器的作用一样），这是我在 DKCarouselView 中内置的一个可点击的 ImageView，也可以继承 UIButton，不过 UIButton 更侧重于状态，ImageView 侧重于图片本身：</p>

<pre><code>typedef void(^DKCarouselViewTapBlock)();
@interface DKClickableImageView : UIImageView
@property (nonatomic, assign) BOOL enable;
@property (nonatomic, copy) DKCarouselViewTapBlock tapBlock;
@end
@implementation DKClickableImageView
- (instancetype)initWithFrame:(CGRect)frame {
    if ((self = [super initWithFrame:frame])) {
        [self commonInit];
    }
    return self;
}
- (instancetype)initWithCoder:(NSCoder *)aDecoder {
    if ((self = [super initWithCoder:aDecoder])) {
        [self commonInit];
    }
    return self;
}
- (void)commonInit {
    self.userInteractionEnabled = YES;
    self.enable = YES;
    UITapGestureRecognizer *tapGesture = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(onTap:)];
    [self addGestureRecognizer:tapGesture];
}
- (IBAction)onTap:(id)sender {
    if (!self.enable) return;
    if (self.tapBlock) {
        self.tapBlock();
    }
}
@end
</code></pre>

<p>更友好的支持 xib</p>

<p>你的控件现在应该可以正确的从文件、代码中初始化了，但是从 xib 中初始化以后可能还需要通过代码来进行一些设置，你或许觉得像上面那样设置 Button 的状态很恶心而且不够直观，但是也没办法，这是由于 xib 虽然对原生控件，如 UIView、UIImageView、UIScrollView 等支持较好（想设置圆角、边框等属性也没办法，只能通过 layer 来设置），但是对自定义控件却没有什么办法，当你拖一个 UIView 到 xib 中，然后把它的 Class 改成你自己的子类后，xib 如同一个瞎子一样，不会有任何变化。————好在这些都成了过去。</p>

<p>Xcode 6 引入了两个新的宏：IBInspectable 和 IBDesignable。</p>

<p>IBInspectable</p>

<p>该宏会让 xib 识别属性，它支持这些数据类型：布尔、字符串、数字（NSNumber）、 CGPoint、CGSize、CGRect、UIColor 、 NSRange 和 UIImage。</p>

<p>比如我们要让自定义的 Button 能在 xib 中设置 UIControlStateSelected | UIControlStateHighlighted 状态的图片，就可以这么做：</p>

<pre><code>// CustomButton
@property (nonatomic, strong) IBInspectable UIImage *highlightSelectedImage;
- (void)setHighlightSelectedImage:(UIImage *)highlightSelectedImage {
    _highlightSelectedImage = highlightSelectedImage;
    [self setImage:highlightSelectedImage forState:UIControlStateHighlighted | UIControlStateSelected];
}
</code></pre>

<p>只需要在属性上加个 IBInspectable 宏即可，然后 xib 中就能显示这个自定义的属性：</p>

<p><img src="http://al1020119.github.io/images/kongjianfengzhuang003.png" title="Caption" ></p>

<p>xib 会把属性名以大驼峰样式显示，如果有多个属性，xib 也会自动按属性名的第一个单词分组显示，如：</p>

<p><img src="http://al1020119.github.io/images/kongjianfengzhuang004.png" title="Caption" ></p>

<p>通过使用 IBInspectable 宏，你可以把原本只能通过代码来设置的属性，也放到 xib 里来，代码就显得更加简洁了。</p>

<p>IBDesignable</p>

<p>xib 配合 IBInspectable 宏虽然可以让属性设置变得简单化，但是只有在运行期间你才能看到控件的真正效果，而使用 IBDesignable 可以让 Interface Builder 实时渲染控件，这一切只需要在类名加上 IBDesignable 宏即可：</p>

<pre><code>IB_DESIGNABLE
@interface CustomButton : UIButton
@property (nonatomic, strong) IBInspectable UIImage *highlightSelectedImage;
@end
</code></pre>

<p>这样一来，当你在 xib 中调整属性的时候，画布也会实时更新。</p>

<p>关于对 IBInspectable / IBDesignable 的详细介绍可以看这里：<a href="http://nshipster.cn/ibinspectable-ibdesignable/">http://nshipster.cn/ibinspectable-ibdesignable/</a></p>

<p>这是 Twitter 上其他开发者做出的效果：</p>

<p><img src="http://al1020119.github.io/images/kongjianfengzhuang005.png" title="Caption" ></p>

<p><img src="http://al1020119.github.io/images/kongjianfengzhuang006.png" title="Caption" ></p>

<p>相信通过使用 IBInspectable / IBDesignable ，会让控件使用起来更加方便、也更加有趣。</p>

<p>不规则图形和事件触发范围</p>

<p>不规则图形在 iOS 上并不多见，想来设计师也怕麻烦。不过 iOS 上的控件说到底都是各式各样的矩形，就算你修改 cornerRadius，让它看起来像这样：</p>

<p><img src="http://al1020119.github.io/images/kongjianfengzhuang007.png" title="Caption" ></p>

<p>也只是看起来像这样罢了，它的实际事件触发范围还是一个矩形。</p>

<p>问题描述</p>

<p>想象一个复杂的可交互的控件，它并不是单独工作的，可能需要和另一个控件交互，而且它们的事件触发范围可能会重叠，像这个选择联系人的列表：</p>

<p><img src="http://al1020119.github.io/images/kongjianfengzhuang008.gif" title="Caption" ></p>

<p>在设计的时候让上面二级菜单在最大的范围内可以被点击，下面的一级菜单也能在自己的范围内很好的工作，正常情况下它们的触发范围是这样的：</p>

<p><img src="http://al1020119.github.io/images/kongjianfengzhuang009.png" title="Caption" ></p>

<p>我们想要的是这样的：</p>

<p><img src="http://al1020119.github.io/images/kongjianfengzhuang010.png" title="Caption" ></p>

<p>想要实现这样的效果需要对事件分发有一定的了解。首先我们来想想，当触摸屏幕的时候发生了什么?</p>

<p>当触摸屏幕的时候发生了什么?</p>

<p>当屏幕接收到一个 touch 的时候，iOS 需要找到一个合适的对象来处理事件（ touch 或者手势），要寻找这个对象，需要用到这个方法：</p>

<ul>
<li>(UIView <em>)hitTest:(CGPoint)point withEvent:(UIEvent </em>)event;
该方法会首先在 application 的 keyWindow 上调用（UIWindow 也是 UIView 的子类），并且该方法的返回值将被用来处理事件。如果这个 view（无论是 window 还是普通的 UIView） 的 userInteractionEnabled 属性被设置为 NO，则它的 hitTest: 永远返回 nil，这意味着它和它的子视图没有机会去接收和处理事件。如果 userInteractionEnabled 属性为 YES，则会先判断产生触摸的 point 是否发生在自己的 bounds 内，如果没有也将返回 nil；如果 point 在自己的范围内，则会为自己的每个子视图调用 hitTest: 方法，只要有一个子视图通过这个方法返回一个 UIView 对象，那么整个方法就一层一层地往上返回；如果没有子视图返回 UIView 对象，则父视图将会把自己返回。</li>
</ul>


<p>所以，在事件分发中，有这么几个关键点：</p>

<p>如果父视图不能响应事件（userInteractionEnabled 为 NO），则其子视图也将无法响应事件。</p>

<p>如果子视图的 frame 有一半在外面，就像这样：</p>

<p><img src="http://al1020119.github.io/images/kongjianfengzhuang011.png" title="Caption" ></p>

<p>则在外面的部分是无法响应事件的，因为它超出了父视图的范围。</p>

<p>整个事件链只会返回一个 Hit-Test View 来处理事件。</p>

<p>子视图的顺序会影响到 Hit-Test View 的选择：最先通过 hitTest: 方法返回的 UIView 才会被返回，假如有两个子视图平级，并且它们的 frame 一样，但是谁是后添加的谁就优先返回。</p>

<p>了解了事件分发的这些特点后，还需要知道最后一件事：UIView 如何判断产生事件的 point 是否在自己的范围内? 答案是通过 pointInside 方法，这个方法的默认实现类似于这样：</p>

<pre><code>// point 被转化为对应视图的坐标系统
- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event {
    return CGRectContainsPoint(self.bounds, point);
}
</code></pre>

<p>所以，当我们想改变一个 View 的事件触发范围的时候，重写 pointInside 方法就可以了。</p>

<p>回到问题</p>

<p>针对这种视图一定要处理它们的事件触发范围，也就是 pointInside 方法，一般来说，我们先判断 point 是不是在自己的范围内（通过调用 super 来判断），然后再判断该 point 符不符合我们的处理要求：</p>

<p>这个例子我用 Swift 来写</p>

<pre><code>override func pointInside(point: CGPoint, withEvent event: UIEvent?) -&gt; Bool {
    let inside = super.pointInside(point, withEvent: event)
    if inside {
        let radius = self.layer.cornerRadius
        let dx = point.x - self.bounds.size.width / 2
        let dy = point.y - radius
        let distace = sqrt(dx * dx + dy * dy)
        return distace &lt; radius
    }
    return inside
}
</code></pre>

<p>如果你要实现非矩形的控件，那么请在开发时处理好这类问题。</p>

<p>这里附上一个很容易测试的小 Demo：</p>

<pre><code>class CustomView: UIControl {
    override init(frame: CGRect) {
        super.init(frame: frame)
        self.backgroundColor = UIColor.redColor()
    }
    required init(coder aDecoder: NSCoder) {
        super.init(coder: aDecoder)
        self.backgroundColor = UIColor.redColor()
    }
    override func layoutSubviews() {
        super.layoutSubviews()
        self.layer.cornerRadius = self.bounds.size.width / 2
    }
    override func beginTrackingWithTouch(touch: UITouch, withEvent event: UIEvent) -&gt; Bool {
        self.backgroundColor = UIColor.grayColor()
        return super.beginTrackingWithTouch(touch, withEvent: event)
    }
    override func endTrackingWithTouch(touch: UITouch, withEvent event: UIEvent) {
        super.endTrackingWithTouch(touch, withEvent: event)
        self.backgroundColor = UIColor.redColor()
    }
    override func pointInside(point: CGPoint, withEvent event: UIEvent?) -&gt; Bool {
        let inside = super.pointInside(point, withEvent: event)
        if inside {
            let radius = self.layer.cornerRadius
            let dx = point.x - self.bounds.size.width / 2
            let dy = point.y - radius
            let distace = sqrt(dx * dx + dy * dy)
            return distace &lt; radius
        }
        return inside
    }
}
</code></pre>

<h4>合理使用 KVO</h4>

<p>某些视图的接口比较宝贵，被你用掉后外部的使用者就无法使用了，比如 UITextField 的 delegate，好在 UITextField 还提供了通知和 UITextInput 方法可以使用；像 UIScrollView 或者基于 UIScrollView 的控件，你既不能设置它的 delegate，又没有其他的替代方法可以使用，对于像以下这种需要根据某些属性实时更新的控件来说，KVO 真是极好的：</p>

<p>这是一个动态高度 Header 的例子（DKStickyHeaderView）：</p>

<p>两者都是基于 UIScrollView、基于 KVO ，不依赖外部参数：</p>

<pre><code>override func observeValueForKeyPath(keyPath: String, ofObject object: AnyObject, change: [NSObject : AnyObject], context: UnsafeMutablePointer) {
    if keyPath == KEY_PATH_CONTENTOFFSET {
        let scrollView = self.superview as! UIScrollView
        var delta: CGFloat = 0.0
        if scrollView.contentOffset.y &lt; 0.0 {
            delta = fabs(min(0.0, scrollView.contentOffset.y))
        }
        var newFrame = self.frame
        newFrame.origin.y = -delta
        newFrame.size.height = self.minHeight + delta
        self.frame = newFrame
    } else {
        super.observeValueForKeyPath(keyPath, ofObject: object, change: change, context: context)
    }
}
</code></pre>

<p>对容器类的 ViewController 来说也一样有用。在 iOS8 之前没有 UIContentContainer 这个正式协议，如果你要实现一个很长的、非列表、可滚动的 ViewController，那么你可能会将其中的功能分散到几个 ChildViewController 里，然后把它们组合起来，这样一来，这些 ChildViewController 既能被单独作为一个 ViewController 展示，也可以被组合到一起。作为组合到一起的前提，就是需要一个至少有以下两个方法的协议：</p>

<p>提供一个统一的输入源，大多是一个 Model 或者像 userId 这样的
能够返回你所需要的高度，比如设置 preferredContentSize 属性
ChildViewController 动态地设置 contentSize，容器监听 contentSize 的变化动态地设置约束或者 frame。</p>
]]></content>
  </entry>
  
</feed>
