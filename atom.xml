<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[iOS梦工厂]]></title>
  <link href="http://al1020119.github.io/atom.xml" rel="self"/>
  <link href="http://al1020119.github.io/"/>
  <updated>2016-08-31T12:33:40+08:00</updated>
  <id>http://al1020119.github.io/</id>
  <author>
    <name><![CDATA[iCocos]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[多线程安全？应该不止这些😂！]]></title>
    <link href="http://al1020119.github.io/blog/2016/08/31/duo-xian-cheng-an-quan-%3Fying-gai-bu-zhi-zhe-xie-%3F!/"/>
    <updated>2016-08-31T12:33:27+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/08/31/duo-xian-cheng-an-quan-?ying-gai-bu-zhi-zhe-xie-?!</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[修行篇-数据结构常见操作与总结]]></title>
    <link href="http://al1020119.github.io/blog/2016/08/31/xiu-xing-pian-shu-ju-jie-gou-chang-jian-cao-zuo-yu-zong-jie/"/>
    <updated>2016-08-31T12:33:11+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/08/31/xiu-xing-pian-shu-ju-jie-gou-chang-jian-cao-zuo-yu-zong-jie</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[修行篇-算法之精华-算法&amp;冒泡]]></title>
    <link href="http://al1020119.github.io/blog/2016/08/31/xiu-xing-pian-suan-fa-zhi-jing-hua-suan-fa-and-mou-pao/"/>
    <updated>2016-08-31T12:32:56+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/08/31/xiu-xing-pian-suan-fa-zhi-jing-hua-suan-fa-and-mou-pao</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[修行篇-23种设计模式]]></title>
    <link href="http://al1020119.github.io/blog/2016/08/31/xiu-xing-pian-23chong-she-ji-mo-shi/"/>
    <updated>2016-08-31T12:32:39+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/08/31/xiu-xing-pian-23chong-she-ji-mo-shi</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[修行篇-七大查找算法]]></title>
    <link href="http://al1020119.github.io/blog/2016/08/31/xiu-xing-pian-qi-da-cha-zhao-suan-fa/"/>
    <updated>2016-08-31T12:32:08+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/08/31/xiu-xing-pian-qi-da-cha-zhao-suan-fa</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[修行篇-五大常用算法]]></title>
    <link href="http://al1020119.github.io/blog/2016/08/31/xiu-xing-pian-wu-da-chang-yong-suan-fa/"/>
    <updated>2016-08-31T12:31:31+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/08/31/xiu-xing-pian-wu-da-chang-yong-suan-fa</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[修行篇-常见排序算法]]></title>
    <link href="http://al1020119.github.io/blog/2016/08/31/xiu-xing-pian-chang-jian-pai-xu-suan-fa/"/>
    <updated>2016-08-31T12:31:14+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/08/31/xiu-xing-pian-chang-jian-pai-xu-suan-fa</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[修行篇-数据结构]]></title>
    <link href="http://al1020119.github.io/blog/2016/08/31/xiu-xing-pian-shu-ju-jie-gou/"/>
    <updated>2016-08-31T12:30:55+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/08/31/xiu-xing-pian-shu-ju-jie-gou</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[修行篇-探程序之精华]]></title>
    <link href="http://al1020119.github.io/blog/2016/08/08/oneday/"/>
    <updated>2016-08-08T23:53:19+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/08/08/oneday</id>
    <content type="html"><![CDATA[<blockquote><p>做了这么久ios开发，由于最近发现自己在性能和底层相关方面，还有有待提高，一句话总结就是：知其然，而不知其所以然。</p></blockquote>

<p>最近也一直在研究相关方面的技术，包括ios相关技术的底层实现，但是这还是远远不够的，一个真正的程序员是必须做到“学无止境”。</p>

<p>经过这几年的开发与学习，包括和同行朋友的了解，作为一个程序员，必备的技术有以下四种。</p>

<ul>
<li>算法</li>
<li>数据结构

<ul>
<li>程序=算法+数据结构</li>
</ul>
</li>
<li>设计模式</li>
<li>数据库</li>
</ul>


<!--more-->


<p>当然可能还有其他的，比如操作系统，软件工程，当然C语音是不能再基础的基础，但是除了上面四点，笔者可能不会专门去研究，最多作为了解。</p>

<blockquote><p>从今天开始，我将从上面四点开始人生的第二次攀爬，希望能爬到一个属于我自己的高峰，也希望能对和我有意义心态的人有所帮助。</p></blockquote>

<h4>路线</h4>

<ol>
<li>算法，数据结构，设计模式，数据库，相关概念的介绍与理解(可能会有部分的软件工程和操作系统相关)</li>
<li>简单代码演示以便更加深刻理解</li>
<li>实际应用以便更加深入理解</li>
<li>举一反三</li>
<li>相关总结</li>
</ol>


<hr />

<p>更新中，敬请关注。。。。。。</p>

<pre><code>Q Q：2211523682/790806573

微信：18370997821/13148454507

微博WB:http://weibo.com/u/3288975567?is_hot=1

git博文：http://al1020119.github.io/

github：https://github.com/al1020119
</code></pre>

<p><img src="http://al1020119.github.io/images/iCocosCoder.jpg" title="Caption" ></p>

<p><img src="http://al1020119.github.io/images/iCocosPublic.jpg" title="Caption" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS开发各种底层实现--包你满意😘！]]></title>
    <link href="http://al1020119.github.io/blog/2016/08/01/gezhongdicenshixian/"/>
    <updated>2016-08-01T23:30:19+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/08/01/gezhongdicenshixian</id>
    <content type="html"><![CDATA[<p>iOS开发常用技术底层实现（精简概述）</p>

<p>本章将对ios开发技术底层实现的总结，其实关于ios开发中各种底层的实现，网上相关文章多到数不过来，而不且非常不错，我也没有自信我能比他们做的更好，因为毕竟每个人专研的东西不一样，本文主要正对三类用户！</p>

<ol>
<li>资深的ios开发者，对底层做过专门研究，但是没有一个系统整理，或者说不能很清楚的表达。</li>
<li>ios开发初学者，没有专门研究过底层或者相关源码的初学者，但是不太建议一开始就看，因为如果你没有过一点接触，看了也看不懂，或者看了也白看，最多就是留个印象在脑子了，对初学者来说，切记不能靠背或者了解，而且细细研究每一个技术点，再慢慢深入挖掘。</li>
<li>ios开发待业程序员（面试）专用，不管你有没有接触过ios开发相关的底层，只要你是在准备找工作的程序员，我相信你看了绝对有用，但是并不能正面你就真的理解了，所以希望这对你来说只是短暂的，后续得花大量时间去专门研究才能在这条路上走得更远，不然你永远只是个码农！</li>
</ol>


<p>好了，废话也不多说了，我们开始吧。。。。。</p>

<h6>系统篇</h6>

<ul>
<li>内存管理</li>
<li>Runtime</li>
</ul>


<h6>事件篇</h6>

<ul>
<li>事件传递</li>
<li>事件响应</li>
</ul>


<h6>代码篇</h6>

<ul>
<li>Block</li>
<li>__Block</li>
</ul>


<!--more-->


<h6>实战</h6>

<ul>
<li>KVO</li>
<li>KVC</li>
</ul>


<h6>高级</h6>

<ul>
<li>GCD</li>
</ul>


<h6>全栈篇</h6>

<ul>
<li>JSPatch</li>
<li>React Native</li>
</ul>


<h6>必备篇</h6>

<ul>
<li>多线程</li>
<li>网络</li>
<li>数据持久化</li>
</ul>


<h6>通用篇</h6>

<ul>
<li>数组</li>
<li>字典</li>
<li>集合</li>
</ul>


<h6>#写在最后</h6>

<hr />

<h1>系统篇</h1>

<hr />

<h3>内存管理</h3>

<ul>
<li><p>黄金法则</p>

<ul>
<li>如果一个对象使用了alloc，[mutable] copy，retain，那么你必须使用相应的release或autonrelease</li>
</ul>
</li>
</ul>


<p>MRC:</p>

<pre><code> 手动管理内存（retain, release, autorelease,不多说） 持有对象,retain +1 ,引用计数加1, 释放对象:release -1, 引用计数减1,当引用计数为0时,会自动释放内存.  autorelease对象内存的管理放到autoreleasepool中, 当pool drain时,回收内存. (这是基于 objective-c的运行时特性和垃圾回收机制)
</code></pre>

<p>ARC:</p>

<pre><code> 手动管理内存, 这是xcode4.x版本的特性,(4.1及以前没有,我从4.6开始的), 原理是:在编译代码的时候为你自动在合适的位置插入release 和 autorelease, (运行时处理垃圾回收就如何MRC一样).
</code></pre>

<p>总结: ARC机制拥有和MRC一样的效率, ARC通过在部分优化和在最合适的地方完成引用计数的维护,所以支持使用ARC.</p>

<p>规则</p>

<p>规则：</p>

<ul>
<li><p>1、Objective-C类中实现了引用计数器，对象知道自己当前被引用的次数</p></li>
<li><p>2、最初对象的计数器为1</p></li>
<li><p>3、如果需要引用对象，可以给对象发送一个retain消息，这样对象的计数器就加1</p></li>
<li><p>4、当不需要引用对象了，可以给对象发送release消息，这样对象计数器就减1</p></li>
<li><p>5、当计数器减到0，自动调用对象的dealloc函数，对象就会释放内存</p></li>
<li><p>6、计数器为0的对象不能再使用release和其他方法</p></li>
</ul>


<h3>Runtime</h3>

<p>一套纯低层的C语言库
平时我们编写的OC代码都会转成Runtime去执行</p>

<p>特性：</p>

<pre><code>动态类型：程序直到执行时才能确定所属的类。

动态绑定：程序直到执行时才能确定实际要调用的方法。

动态加载：根据需求加载所需要的资源
</code></pre>

<p>Runtime消息机制</p>

<p>首先通过obj的isa指针找到obj对应的class。</p>

<ul>
<li>首先检测这个 selector 是不是要忽略。比如 Mac OS X 开发，有了垃圾回收就不理会 retain，release 这些函数。</li>
<li>检测这个 selector 的 target 是不是 nil，Objc 允许我们对一个 nil 对象执行任何方法不会 Crash，因为运行时会被忽略掉。</li>
<li>如果上面两步都通过了，那么就开始查找这个类的实现 IMP，</li>
<li>在Class中先去cache中 通过SEL查找对应函数method，找到就执行对应的实现。</li>
<li>若cache中未找到，再去methodList中查找，找到就执行对应的实现。</li>
<li>若methodlist中未找到，则取superClass中查找（重复执行以上两个步骤），直到找到最根的类为止。</li>
<li>若任何一部能找到，则将method加 入到cache中，以方便下次查找，并通过method中的函数指针跳转到对应的函数中去执行。</li>
<li>如果以上都不能找到，则会开始进行消息转发</li>
</ul>


<p>消息转发</p>

<ul>
<li>1.动态方法解析：向当前类发送 resolveInstanceMethod: 信号，检查是否动态向该类添加了方法。（迷茫请搜索：@dynamic）</li>
<li>2.快速消息转发：检查该类是否实现了 forwardingTargetForSelector: 方法，若实现了则调用这个方法。若该方法返回值对象非nil或非self，则向该返回对象重新发送消息。</li>
<li>3.标准消息转发：runtime发送methodSignatureForSelector:消息获取Selector对应的方法签名。返回值非空则通过forwardInvocation:转发消息，返回值为空则向当前对象发送doesNotRecognizeSelector:消息，程序崩溃退出</li>
</ul>


<p>总结就是：
在一个函数找不到时，OC提供了三种方式去补救：</p>

<ul>
<li>1、调用resolveInstanceMethod给个机会让类添加这个实现这个函数</li>
<li>2、调用forwardingTargetForSelector让别的对象去执行这个函数</li>
<li>3、调用forwardInvocation（函数执行器）灵活的将目标函数以其他形式执行。
如果都不中，调用doesNotRecognizeSelector抛出异常。</li>
</ul>


<hr />

<h1>事件篇</h1>

<h3>应用如何找到最合适的控件来处理事件？</h3>

<pre><code>1.首先判断主窗口（keyWindow）自己是否能接受触摸事件
2.判断触摸点是否在自己身上
3.子控件数组中从后往前遍历子控件，重复前面的两个步骤（所谓从后往前遍历子控件，就是首先查找子控件数组中最后一个元素，然后执行1、2步骤）
4.view，比如叫做fitView，那么会把这个事件交给这个fitView，再遍历这个fitView的子控件，直至没有更合适的view为止。
5.如果没有符合条件的子控件，那么就认为自己最合适处理这个事件，也就是自己是最合适的view
</code></pre>

<h2>事件的传递和响应的区别：</h2>

<ul>
<li>事件的传递是从上到下（父控件到子控件），事件的响应是从下到上（顺着响应者链条向上传递：子控件到父控件。</li>
</ul>


<h3>事件响应</h3>

<h5>响应者链的事件传递过程:</h5>

<pre><code>1&gt;如果当前view是控制器的view，那么控制器就是上一个响应者，事件就传递给控制器；如果当前view不是控制器的view，那么父视图就是当前view的上一个响应者，事件就传递给它的父视图
2&gt;在视图层次结构的最顶级视图，如果也不能处理收到的事件或消息，则其将事件或消息传递给window对象进行处理
3&gt;如果window对象也不处理，则其将事件或消息传递给UIApplication对象
4&gt;如果UIApplication也不能处理该事件或消息，则将其丢弃
</code></pre>

<h3>事件传递</h3>

<h5>事件处理的整个流程总结：</h5>

<pre><code>　　1.触摸屏幕产生触摸事件后，触摸事件会被添加到由UIApplication管理的事件队列中（即，首先接收到事件的是UIApplication）。
　　2.UIApplication会从事件队列中取出最前面的事件，把事件传递给应用程序的主窗口（keyWindow）。
　　3.主窗口会在视图层次结构中找到一个最合适的视图来处理触摸事件。（至此，第一步已完成)
　　4.最合适的view会调用自己的touches方法处理事件
　　5.touches默认做法是把事件顺着响应者链条向上抛。
</code></pre>

<hr />

<h1>代码篇</h1>

<hr />

<h3>Block的底层实现</h3>

<p>一句话:</p>

<pre><code>栈地址和对地址值的拷贝

block就是一个里面存储了指向函数体中包含定义block时的代码块的函数指针，以及block外部上下文变量等信息的结构体。
</code></pre>

<p>Block结构体中含有isa指针，这就证明了Block其实就是对象，并具有一般对象的所有功能。这个isa指针被初始化为 <em>NSConcreteStackBlock 或者 </em>NSConcreteGlobalBlock 类的地址。在没有开启ARC的情况下，如果Block中包含有局部变量则isa被初始化为前者，否则就被初始化为后者。而当ARC开启后，如果Block中包含有局部变量则isa被初始化为 <em>NSConcreteMallocBlock ，否则就被初始化为 </em>NSConcreteGlobalBlock 。invoke是一个函数指针，它指向的是Block被转换成函数的地址。最后的imported variables部分是Block需要访问的外部的局部变量，他们在编译就会被拷贝到Block中，这样一来Block就是成为一个闭包了。</p>

<h3>__block底层实现</h3>

<pre><code>一句话：传值 和传址
</code></pre>

<p><strong>block打印C++源码可以看到</strong>Block_byref_a_0结构体，这个结构体中含有isa指针，所以也是一个对象，它是用来包装局部变量a的。当block被copy到堆中时，<strong>Person</strong>test_block_impl_0的拷贝辅助函数<strong>Person</strong>test_block_copy_0会将__Block_byref_a_0拷贝至堆中，所以即使局部变量所在堆被销毁，block依然能对堆中的局部变量进行操作</p>

<pre><code>这样做是为了保证操作的值始终是堆中的拷贝，而不是栈中的值。（处理在局部变量所在栈还没销毁，就调用block来改变局部变量值的情况，如果没有__forwarding指针，则修改无效）
</code></pre>

<hr />

<h1>实战篇</h1>

<hr />

<h2>KVO/KVC</h2>

<p>VC/KVO是观察者模式的一种实现，在Cocoa中是以被万物之源NSObject类实现的NSKeyValueCoding/NSKeyValueObserving非正式协议的形式被定义为基础框架的一部分。从协议的角度来说，KVC/KVO本质上是定义了一套让我们去遵守和实现的方法。
当然，KVC/KVO实现的根本是Objective-C的动态性和runtime，这在后文的原理部分会有详述。
另外，KVC/KVO机制离不开访问器方法的实现，这在后文中也有解释。</p>

<p>1、KVC简介</p>

<pre><code>全称是Key-value coding，翻译成键值编码。顾名思义，在某种程度上跟map的关系匪浅。它提供了一种使用字符串而不是访问器方法去访问一个对象实例变量的机制。
</code></pre>

<p>2、KVO简介</p>

<pre><code>全称是Key-value observing，翻译成键值观察。提供了一种当其它对象属性被修改的时候能通知当前对象的机制。再MVC大行其道的Cocoa中，KVO机制很适合实现model和controller类之间的通讯。
</code></pre>

<h3>KVO的底层实现（基于KVC-》运行时）</h3>

<p>当某个类的对象第一次被观察时，系统就会在运行期动态地创建该类的一个派生类，在这个派生类中重写基类中任何被观察属性的 setter 方法。</p>

<pre><code>派生类在被重写的 setter 方法实现真正的通知机制，就如前面手动实现键值观察那样。这么做是基于设置属性会调用 setter 方法，而通过重写就获得了 KVO 需要的通知机制。当然前提是要通过遵循 KVO 的属性设置方式来变更属性值，如果仅是直接修改属性对应的成员变量，是无法实现 KVO 的。

同时派生类还重写了 class 方法以“欺骗”外部调用者它就是起初的那个类。然后系统将这个对象的 isa 指针指向这个新诞生的派生类，因此这个对象就成为该派生类的对象了，因而在该对象上对 setter 的调用就会调用重写的 setter，从而激活键值通知机制。此外，派生类还重写了 dealloc 方法来释放资源
</code></pre>

<p>isa指针指向的其实是类的元类，如果之前的类名为：Person，那么被runtime更改以后的类名会变成：NSKVONotifying_Person。
新的NSKVONotifying_Person类会重写以下方法：
增加了监听的属性对应的set方法，class，dealloc，_isKVOA</p>

<h3>KVC的底层实现</h3>

<p>KVC运用了一个isa-swizzling技术。isa-swizzling就是类型混合指针机制。KVC主要通过isa-swizzling，来实现其内部查找定位的。isa指针，如其名称所指，（就是is a kind of的意思），指向维护分发表的对象的类。该分发表实际上包含了指向实现类中的方法的指针，和其它数据。</p>

<p>一个对象在调用setValue的时候，</p>

<ul>
<li>（1）首先根据方法名找到运行方法的时候所需要的环境参数。</li>
<li>（2）他会从自己isa指针结合环境参数，找到具体的方法实现的接口。</li>
<li>（3）再直接查找得来的具体的方法实现。</li>
</ul>


<hr />

<h1>高级</h1>

<hr />

<h3>GCD底层实现</h3>

<p>GCD内部是怎么实现的</p>

<ul>
<li>1 IOS和OS X的核心是XNU内核，GCD是基于XUN内核实现的</li>
<li>2 GCD的API全部在libdispatch库中</li>
<li><p>3 GCD的底层实现主要有Dispatch Queue 和Dispatch Source</p>

<ul>
<li>Dispatch Queue ：管理block操作</li>
<li>Dispatch Source :处理事件(比如线程间通信)</li>
</ul>
</li>
</ul>


<p>NSOperationQueue 和GCD的区别和类似的地方</p>

<ul>
<li>1 GCD是纯C语言的API， NSOperationQueue是基于GCD的OC版本封装</li>
<li>2 GCD只支持FIFO的队列，NSOperationQueue可以很方便地调整执行顺序 设置最大并发数量</li>
<li>3 NSOperationQueue 可以轻松地在operation 间设置依赖关系，而GCD需要写很多的代码</li>
<li>4 NSOperationQueue支持KVO，可以监测operation是否正在执行(is Executed),是否结束(is finished),是否取消( is canceld);</li>
<li>5 GCD的执行速度比NSOperationQueue快</li>
</ul>


<hr />

<h1>全栈篇</h1>

<hr />

<h3>JSpatch底层实现</h3>

<p>JSPatch 能做到通过 JS 调用和改写 OC 方法最根本的原因是 Objective-C 是动态语言，OC 上所有方法的调用/类的生成都通过 Objective-C Runtime 在运行时进行，我们可以通过类名/方法名反射得到相应的类和方法：</p>

<pre><code>Class class = NSClassFromString("UIViewController");
id viewController = [[class alloc] init];
SEL selector = NSSelectorFromString("viewDidLoad");
[viewController performSelector:selector];
</code></pre>

<p>也可以替换某个类的方法为新的实现：</p>

<pre><code>static void newViewDidLoad(id slf, SEL sel) {}
class_replaceMethod(class, selector, newViewDidLoad, @"");
</code></pre>

<p>还可以新注册一个类，为类添加方法：</p>

<pre><code>Class cls = objc_allocateClassPair(superCls, "JPObject", 0);
objc_registerClassPair(cls);
class_addMethod(cls, selector, implement, typedesc);
</code></pre>

<p>对于 Objective-C 对象模型和动态消息发送的原理已有很多文章阐述得很详细，这里就不详细阐述了。理论上你可以在运行时通过类名/方法名调用到任何 OC 方法，替换任何类的实现以及新增任意类。所以 JSPatch 的基本原理就是：JS 传递字符串给 OC，OC 通过 Runtime 接口调用和替换 OC 方法。这是最基础的原理，实际实现过程还有很多怪要打，接下来看看具体是怎样实现的。</p>

<h6>总结：</h6>

<p>使用JS利用OC的动态特性，执行我们想要执行的代码</p>

<h3>React Native</h3>

<p>RN主要的通信在于java与js之间，平常我们写的jsx代码最终会调用到原生的View。上一篇博客我们也了解到了要新建一个原生模块需要在java层和js层分别写一个Module</p>

<p>特点：</p>

<ul>
<li><p>可以基于 React Native使用 JavaScript 编写应用逻辑，UI 则可以保持全是原生的。这样的话就没有必要就 HTML5 的 UI 做出常见的妥协；</p></li>
<li><p>React 引入了一种与众不同的、略显激进但具备高可用性的方案来构建用户界面。长话短说，应用的 UI 简单通过一个基于应用目前状态的函数来表达。</p></li>
</ul>


<p>RN总共分为三层，java层，C++层，js层</p>

<ul>
<li>Java层：java层就是app原生代码，它通过启动C++层的javascript解析器javascriptCore来执行js代码，从而构建原生UI等。java层依赖于众多优秀开源库，在图片处理使用的是Fresco，网络通信使用的是okhttp，Json解析工具用jackson,动画库用NineOldAndroids等，在java层原生的功能均封装为Module，如Toast和Log等。</li>
<li>C++层：c++层最主要是封装了JavaScriptCore，它是一个全新的支持ES6的webKit。Bridge连接了java与js之间的通信。解析js文件是通过JSCExectutor进行的。</li>
<li>Js层：主要处理事件分发及UI Layout，平常开发最常用的。通用jsx来写业务代码，通过flexbox来实现布局。不依赖DOM。由于react有 DOM diff这个算法，所以它的效率非常高。
通信机制</li>
</ul>


<p>在Java层与Js层的bridge分别存有相同一份模块配置表，Java与Js互相通信时，通过将里配置表中的moduleID，methodID转换成json数据的形式传递给到C++层，C++层传送到js层，通过js层的的模块配置表找到对应的方法进行执行，如果有callback，则回传给java层。这里只是大概介绍。</p>

<p>总结：</p>

<ul>
<li>在程序启动的时候，首先会调用ReactActivity的onCreate函数中，我们会去创建一个ReactInstanceManagerImpl对象。通过ReactRootView的startReactApplication方法开启整个RN世界的大门。</li>
<li>在这个方法中，我们会通过一个AsyncTask去创建ReactContext</li>
<li>在创建ReactContext中，我们把我们自己注入和CoreModulesPackage通过processPackage方法将其中的各个modules注入到了对应的Registry中。最后通过CatalystInstanceImpl中的ReactBridge将NativeModule和JSModule注册表通过jni传输到了JS层。</li>
<li>java调用js时，会在ReactApplicationContext创建的时候存入注册表类JavaScriptModuleRegistry中，同时通过动态代理生成代理实例，并在代理拦截类JavaScriptModuleInvocationHandler中统一处理发向Javascript的所有通信请求。</li>
<li>JSCExecutor将所有来自Java层的通信请求封装成Javascript执行语句。</li>
<li>接着在js层中的MessageQueue里匹配ModuleId和MethodId。找到调用模块。</li>
<li>如果是js层调用java层，js最终都会调用<em>_nativeCall方法，通过flushedQueue将this.</em>queue返回给Bridger。</li>
<li>C++层调用PlatformBridgeCallback对象的onCallNativeModules方法，执行makeJavaCall方法，里面最终通过env->CallVoidMethod调用了Java层的方法。</li>
<li>调用Java层NativeModulesReactCallback的call方法，通过moduleID从保存在其内部的NativeModule映射表，匹配到需要被执行的NativeModule对象，再通过methodID匹配到所要调用的方法。通过invoke反射方式执行NativeModule的方法。</li>
</ul>


<hr />

<h1>必备篇</h1>

<hr />

<h5>多线程</h5>

<h5>网络</h5>

<h5>数据持久化</h5>

<hr />

<hr />

<h1>通用篇</h1>

<hr />

<h5>数组</h5>

<h5>字典</h5>

<h5>集合</h5>

<hr />

<p>更新中，敬请关注。。。。。。</p>

<pre><code>Q Q：2211523682/790806573

微信：18370997821/13148454507

微博WB:http://weibo.com/u/3288975567?is_hot=1

git博文：http://al1020119.github.io/

github：https://github.com/al1020119
</code></pre>

<p><img src="http://al1020119.github.io/images/iCocosCoder.jpg" title="Caption" ></p>

<p><img src="http://al1020119.github.io/images/iCocosPublic.jpg" title="Caption" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[福利：抢红包神器就是这么来的]]></title>
    <link href="http://al1020119.github.io/blog/2016/08/01/weixinhongbao/"/>
    <updated>2016-08-01T11:52:15+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/08/01/weixinhongbao</id>
    <content type="html"><![CDATA[<p>微信红包</p>

<p><img src="http://al1020119.github.io/images/weixinhongbao0001.jpg" title="Caption" ></p>

<p>本文摘自简书大牛<a href="http://www.jianshu.com/p/189afbe3b429">east520</a>.</p>

<p>别告诉我你对红包不感兴趣，如果真的是这样，那么请绕道，哈哈。</p>

<p>现在由于微信和QQ的普及，几乎所有用户都会使用红包这个功能，但是对于一个程序员来说，每看到一个好的功能都会努力试着研究一下，哪怕不能成功，由于看到了一篇比较看的文章，所以就专门花时间去搞一顿，结果大吃一惊。</p>

<p>最近有不少朋友找我要红包尾数的功能，我也不知道他们为什么要这个，可能是笔者太年轻了。但是我觉得这个可能不简单，而且这样的功能做好了也不能外漏，不然笔者的程序员职业生涯估计就到头了！</p>

<pre><code>前言：最近笔者在研究iOS逆向工程，顺便拿微信来练手，在非越狱手机上实现了微信自动抢红包的功能。
</code></pre>

<p>题外话：此教程是一篇严肃的学术探讨类文章，仅仅用于学习研究，也请读者不要用于商业或其他非法途径上，笔者一概不负责哟~~</p>

<p>好了，接下来可以进入正题了！</p>

<!--more-->


<h2>此教程所需要的工具/文件</h2>

<pre><code>yololib
class-dump
dumpdecrypted
iOSOpenDev
iTools
OpenSSH(Cydia)
iFile(Cydia)
Cycript(Cydia)
Command Line Tools
Xcode
苹果开发者证书或企业证书
一台越狱的iPhone
</code></pre>

<p>是的，想要实现在非越狱iPhone上达到自动抢红包的目的，工具用的可能是有点多（工欲善其事必先利其器^_^）。不过，没关系，大家可以按照教程的步骤一步一步来执行，不清楚的步骤可以重复实验，毕竟天上不会掉馅饼嘛。</p>

<h1>解密微信可执行文件(Mach-O)</h1>

<p>因为从Appstore下载安装的应用都是加密过的，所以我们需要用一些工具来为下载的App解密，俗称砸壳。这样才能便于后面分析App的代码结构。</p>

<p>首先我们需要一台已经越狱的iPhone手机(现在市面上越狱已经很成熟，具体越狱方法这里就不介绍了)。然后进入Cydia，安装OpenSSH、Cycript、iFile(调试程序时可以方便地查看日志文件)这三款软件。</p>

<pre><code>PS：笔者的手机是iPhone 6Plus，系统版本为iOS9.1。
</code></pre>

<p>在电脑上用iTunes上下载一个最新的微信，笔者当时下载的微信版本为6.3.13。下载完后，iTunes上会显示出已下载的app。</p>

<p>itnues</p>

<p><img src="http://al1020119.github.io/images/weixinhongbao0002.jpg" title="Caption" ></p>

<p>连上iPhone，用iTunes装上刚刚下载的微信应用。</p>

<p>打开Mac的终端，用ssh进入连上的iPhone(确保iPhone和Mac在同一个网段，笔者iPhone的IP地址为192.168.8.54)。OpenSSH的root密码默认为alpine。</p>

<p>ssh
<img src="http://al1020119.github.io/images/weixinhongbao0003.jpg" title="Caption" ></p>

<p>接下来就是需要找到微信的Bundle id了，，这里笔者有一个小技巧，我们可以把iPhone上的所有App都关掉，唯独保留微信，然后输入命令 ps -e</p>

<p>微信bundle id
<img src="http://al1020119.github.io/images/weixinhongbao0004.jpg" title="Caption" ><br/>
这样我们就找到了微信的可执行文件Wechat的具体路径了。接下来我们需要用Cycript找出微信的Documents的路径，输入命令cycript -p WeChat</p>

<p>cycript
<img src="http://al1020119.github.io/images/weixinhongbao0005.jpg" title="Caption" ></p>

<pre><code>编译dumpdecrypted
先记下刚刚我们获取到的两个路径(Bundle和Documents)，这时候我们就要开始用dumpdecrypted来为微信二进制文件(WeChat)砸壳了。
确保我们从Github上下载了最新的dumpdecrypted源码，进入dumpdecrypted源码的目录，编译dumpdecrypted.dylib，命令如下:
</code></pre>

<p>dumpdecrypted.dylib
<img src="http://al1020119.github.io/images/weixinhongbao0006.jpg" title="Caption" ><br/>
这样我们可以看到dumpdecrypted目录下生成了一个dumpdecrypted.dylib的文件。</p>

<pre><code>scp
拷贝dumpdecrypted.dylib到iPhone上，这里我们用到scp命令.
scp 源文件路径 目标文件路径 。具体如下：
</code></pre>

<p>scp
<img src="http://al1020119.github.io/images/weixinhongbao0007.jpg" title="Caption" ><br/>
    开始砸壳
    dumpdecrypted.dylib的具体用法是：DYLD_INSERT_LIBRARIES=/PathFrom/dumpdecrypted.dylib /PathTo</p>

<p>dumpdecrypted
<img src="http://al1020119.github.io/images/weixinhongbao0008.jpg" title="Caption" ><br/>
这样就代表砸壳成功了，当前目录下会生成砸壳后的文件，即WeChat.decrypted。同样用scp命令把WeChat.decrypted文件拷贝到电脑上,接下来我们要正式的dump微信的可执行文件了。</p>

<h1>dump微信可执行文件</h1>

<pre><code>从Github上下载最新的class-dump源代码，然后用Xcode编译即可生成class-dump(这里比较简单，笔者就不详细说明了)。

导出微信的头文件
使用class-dump命令,把刚刚砸壳后的WeChat.decrypted,导出其中的头文件。./class-dump -s -S -H ./WeChat.decrypted -o ./header6.3-arm64
</code></pre>

<p>导出的头文件
<img src="http://al1020119.github.io/images/weixinhongbao0009.jpg" title="Caption" ><br/>
这里我们可以新建一个Xcode项目，把刚刚导出的头文件加到新建的项目中，这样便于查找微信的相关代码。</p>

<p>微信的头文件
<img src="http://al1020119.github.io/images/weixinhongbao0010.jpg" title="Caption" ><br/>
找到CMessageMgr.h和WCRedEnvelopesLogicMgr.h这两文件，其中我们注意到有这两个方法：- (void)AsyncOnAddMsg:(id)arg1 MsgWrap:(id)arg2; ，- (void)OpenRedEnvelopesRequest:(id)arg1;。没错，接下来我们就是要利用这两个方法来实现微信自动抢红包功能。其实现原理是，通过hook微信的新消息函数，我们判断是否为红包消息，如果是，我们就调用微信的打开红包方法。这样就能达到自动抢红包的目的了。哈哈，是不是很简单，我们一起来看看具体是怎么实现的吧。</p>

<pre><code>新建一个dylib工程，因为Xcode默认不支持生成dylib，所以我们需要下载iOSOpenDev，安装完成后(Xcode7环境会提示安装iOSOpenDev失败，请参考iOSOpenDev安装问题)，重新打开Xcode，在新建项目的选项中即可看到iOSOpenDev选项了。
</code></pre>

<p>iOSOpenDev
<img src="http://al1020119.github.io/images/weixinhongbao0011.jpg" title="Caption" ><br/>
    dylib代码
    选择Cocoa Touch Library，这样我们就新建了一个dylib工程了，我们命名为autoGetRedEnv。</p>

<pre><code>删除autoGetRedEnv.h文件，修改autoGetRedEnv.m为autoGetRedEnv.mm，然后在项目中加入CaptainHook.h

因为微信不会主动来加载我们的hook代码，所以我们需要把hook逻辑写到构造函数中。

__attribute__((constructor)) static void entry()
{
  //具体hook方法
}

hook微信的AsyncOnAddMsg: MsgWrap:方法，实现方法如下：

//声明CMessageMgr类
CHDeclareClass(CMessageMgr);
CHMethod(2, void, CMessageMgr, AsyncOnAddMsg, id, arg1, MsgWrap, id, arg2)
{
  //调用原来的AsyncOnAddMsg:MsgWrap:方法
  CHSuper(2, CMessageMgr, AsyncOnAddMsg, arg1, MsgWrap, arg2);
  //具体抢红包逻辑
  //...
  //调用原生的打开红包的方法
  //注意这里必须为给objc_msgSend的第三个参数声明为NSMutableDictionary,不然调用objc_msgSend时，不会触发打开红包的方法
  ((void (*)(id, SEL, NSMutableDictionary*))objc_msgSend)(logicMgr, @selector(OpenRedEnvelopesRequest:), params);
}
__attribute__((constructor)) static void entry()
{
  //加载CMessageMgr类
  CHLoadLateClass(CMessageMgr);
  //hook AsyncOnAddMsg:MsgWrap:方法
  CHClassHook(2, CMessageMgr, AsyncOnAddMsg, MsgWrap);
}

    项目的全部代码，笔者已放入Github中。

完成好具体实现逻辑后，就可以顺利生成dylib了。
</code></pre>

<h1>重新打包微信App</h1>

<pre><code>为微信可执行文件注入dylib
要想微信应用运行后，能执行我们的代码，首先需要微信加入我们的dylib，这里我们用到一个dylib注入神器:yololib，从网上下载源代码，编译后得到yololib。

使用yololib简单的执行下面一句就可以成功完成注入。注入之前我们先把之前保存的WeChat.decrypted重命名为WeChat，即已砸完壳的可执行文件。
./yololib 目标可执行文件 需注入的dylib
注入成功后即可见到如下信息：

dylib注入
</code></pre>

<p><img src="http://al1020119.github.io/images/weixinhongbao0012.jpg" title="Caption" ><br/>
    新建Entitlements.plist</p>

<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;
&lt;plist version="1.0"&gt;
&lt;dict&gt;
  &lt;key&gt;application-identifier&lt;/key&gt;
  &lt;string&gt;123456.com.autogetredenv.demo&lt;/string&gt;
  &lt;key&gt;com.apple.developer.team-identifier&lt;/key&gt;
  &lt;string&gt;123456&lt;/string&gt;
  &lt;key&gt;get-task-allow&lt;/key&gt;
  &lt;true/&gt;
  &lt;key&gt;keychain-access-groups&lt;/key&gt;
  &lt;array&gt;
      &lt;string&gt;123456.com.autogetredenv.demo&lt;/string&gt;
  &lt;/array&gt;
&lt;/dict&gt;
&lt;/plist&gt;

这里大家也许不清楚自己的证书Teamid及其他信息，没关系，笔者这里有一个小窍门，大家可以找到之前用开发者证书或企业证书打包过的App(例如叫Demo)，然后在终端中输入以下命令即可找到相关信息，命令如下：
./ldid -e ./Demo.app/demo

给微信重新签名
接下来把我们生成的dylib(libautoGetRedEnv.dylib)、刚刚注入dylib的WeChat、以及embedded.mobileprovision文件(可以在之前打包过的App中找到)拷贝到WeChat.app中。

命令格式：codesign -f -s 证书名字 目标文件

    PS:证书名字可以在钥匙串中找到

分别用codesign命令来为微信中的相关文件签名,具体实现如下：

重新签名
</code></pre>

<p><img src="http://al1020119.github.io/images/weixinhongbao0013.jpg" title="Caption" ><br/>
    打包成ipa
    给微信重新签名后，我们就可以用xcrun来生成ipa了，具体实现如下：
    xcrun -sdk iphoneos PackageApplication -v WeChat.app  -o ~/WeChat.ipa</p>

<h1>安装拥有抢红包功能的微信</h1>

<p>以上步骤如果都成功实现的话，那么真的就是万事俱备，只欠东风了~~~</p>

<p>我们可以使用iTools工具，来为iPhone(此iPhone Device id需加入证书中)安装改良过的微信了。</p>

<p>iTools
<img src="http://al1020119.github.io/images/weixinhongbao0014.jpg" title="Caption" ></p>

<h1>大工告成！！</h1>

<p>好了，我们可以看看hook过的微信抢红包效果了~</p>

<p>自动抢红包
<img src="http://al1020119.github.io/images/weixinhongbao0015.gif" title="Caption" ><br/>
哈哈，是不是觉得很爽啊，"妈妈再也不用担心我抢红包了。"。大家如果有兴趣可以继续hook微信的其他函数，这样既加强了学习，又满足了自己的特(zhuang)殊(bi)需求嘛。</p>

<pre><code>Q Q：2211523682/790806573

微信：18370997821/13148454507

微博WB:http://weibo.com/u/3288975567?is_hot=1

git博文：http://al1020119.github.io/

github：https://github.com/al1020119
</code></pre>

<p><img src="http://al1020119.github.io/images/iCocosCoder.jpg" title="Caption" ></p>

<p><img src="http://al1020119.github.io/images/iCocosPublic.jpg" title="Caption" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[重整之道（面试+技术+底层+高级）]]></title>
    <link href="http://al1020119.github.io/blog/2016/07/26/chongzhengzhidao/"/>
    <updated>2016-07-26T13:53:19+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/07/26/chongzhengzhidao</id>
    <content type="html"><![CDATA[<p>重整之道（面试+技术+底层+高级）</p>

<p>不要问我为什么写这篇文章。</p>

<p>我，就是这么有尿性。。。。。。。。。。</p>

<p>前面三部分已经基本上完成，后面部分会陆续更新，敬请期待。但是光靠一篇这么短的文章想将通这些事不可能的，这里主要正对面试族，或者健忘族，亦或者是装逼族。好了废话不多说，我们开始吧！</p>

<ul>
<li>运行时（底层）</li>
<li>RunLoop（底层）</li>
<li>多线程（底层与安全）</li>
</ul>


<hr />

<ul>
<li>网络（底层与安全）</li>
<li>数据持久化（各种使用与区别）（CoreData、SQLite）</li>
<li>Block（底层/__Block）</li>
<li>音视频</li>
<li>直播</li>
<li>安全</li>
<li>优化（性能、卡顿）</li>
<li>常见错误</li>
<li>常用技术</li>
<li>全栈相关</li>
<li>算法（常用、排序）</li>
<li>数据结构</li>
<li>设计模式（32中）</li>
<li>架构设计</li>
<li>逆向工程</li>
<li>实战应用</li>
</ul>


<!--more-->


<h3>运行时（底层）</h3>

<h6>介绍</h6>

<p>runtime是一个c和汇编写的动态库(感谢Lision的指正)，是一套比较底层的C语言API，属于一个C语言库，平时我们所写的OC代码，最终都会转成runtime的C语言代码去执行。</p>

<p>这个系统主要做两件事 ：</p>

<ol>
<li>封装C语言的结构体和函数，让开发者在运行时创建、检查或者修改类、对象和方法等等。</li>
<li>传递消息，找出方法的最终执行代码。</li>
</ol>


<h6>常用关键字</h6>

<p>要想全面了解 Runtime 机制，我们必须先了解 Runtime 的一些术语，他们都对应着数据结构。</p>

<p>SEL</p>

<pre><code>它是selector在 Objc 中的表示(Swift 中是 Selector 类)。selector 是方法选择器，其实作用就和名字一样，日常生活中，我们通过人名辨别谁是谁，注意 Objc 在相同的类中不会有命名相同的两个方法。selector 对方法名进行包装，以便找到对应的方法实现。它的数据结构是：

typedef struct objc_selector *SEL;

我们可以看出它是个映射到方法的 C 字符串，你可以通过 Objc 编译器器命令@selector() 或者 Runtime 系统的 sel_registerName 函数来获取一个 SEL 类型的方法选择器。

注意：
不同类中相同名字的方法所对应的 selector 是相同的，由于变量的类型不同，所以不会导致它们调用方法实现混乱。
</code></pre>

<p>id</p>

<pre><code>id 是一个参数类型，它是指向某个类的实例的指针。定义如下：

以上定义，看到 objc_object 结构体包含一个 isa 指针，根据 isa 指针就可以找到对象所属的类。

注意：
isa 指针在代码运行时并不总指向实例对象所属的类型，所以不能依靠它来确定类型，要想确定类型还是需要用对象的 -class 方法。

PS:KVO 的实现机理就是将被观察对象的 isa 指针指向一个中间类而不是真实类型，详见:KVO章节。
</code></pre>

<p>Class</p>

<pre><code>typedef struct objc_class *Class;

Class 其实是指向 objc_class 结构体的指针。

一个运行时类中关联了它的父类指针、类名、成员变量、方法、缓存以及附属的协议。


由此可见，我们可以动态修改 *methodList 的值来添加成员方法，这也是 Category 实现的原理，同样解释了 Category 不能添加属性的原因。这里可以参考下美团技术团队的文章：深入理解 Objective-C: Category。

objc_ivar_list 结构体用来存储成员变量的列表，而 objc_ivar 则是存储了单个成员变量的信息；同理，objc_method_list 结构体存储着方法数组的列表，而单个方法的信息则由 objc_method 结构体存储。

值得注意的时，objc_class 中也有一个 isa 指针，这说明 Objc 类本身也是一个对象。为了处理类和对象的关系，Runtime 库创建了一种叫做 Meta Class(元类) 的东西，类对象所属的类就叫做元类。Meta Class 表述了类对象本身所具备的元数据。

我们所熟悉的类方法，就源自于 Meta Class。我们可以理解为类方法就是类对象的实例方法。每个类仅有一个类对象，而每个类对象仅有一个与之相关的元类。

当你发出一个类似 [NSObject alloc](类方法) 的消息时，实际上，这个消息被发送给了一个类对象(Class Object)，这个类对象必须是一个元类的实例，而这个元类同时也是一个根元类(Root Meta Class)的实例。所有元类的 isa 指针最终都指向根元类。

所以当 [NSObject alloc] 这条消息发送给类对象的时候，运行时代码 objc_msgSend() 会去它元类中查找能够响应消息的方法实现，如果找到了，就会对这个类对象执行方法调用。



super_class 指针，虚线时 isa 指针。而根元类的父类是 NSObject，isa指向了自己。而 NSObject 没有父类。

最后 objc_class 中还有一个 objc_cache ，缓存，它的作用很重要，后面会提到。
</code></pre>

<p>Method</p>

<pre><code>Method 代表类中某个方法的类型

typedef struct objc_method *Method;

objc_method 存储了方法名，方法类型和方法实现：

方法名类型为 SEL
方法类型 method_types 是个 char 指针，存储方法的参数类型和返回值类型
method_imp 指向了方法的实现，本质是一个函数指针
</code></pre>

<p>Ivar</p>

<pre><code>Ivar 是表示成员变量的类型。

typedef struct objc_ivar *Ivar;


其中 ivar_offset 是基地址偏移字节
</code></pre>

<p>IMP</p>

<pre><code>IMP在objc.h中的定义是：

typedef id (*IMP)(id, SEL, ...);

它就是一个函数指针，这是由编译器生成的。当你发起一个 ObjC 消息之后，最终它会执行的那段代码，就是由这个函数指针指定的。而 IMP 这个函数指针就指向了这个方法的实现。

如果得到了执行某个实例某个方法的入口，我们就可以绕开消息传递阶段，直接执行方法，这在后面 Cache 中会提到。

你会发现 IMP 指向的方法与 objc_msgSend 函数类型相同，参数都包含 id 和 SEL 类型。每个方法名都对应一个 SEL 类型的方法选择器，而每个实例对象中的 SEL 对应的方法实现肯定是唯一的，通过一组 id和 SEL 参数就能确定唯一的方法实现地址。

而一个确定的方法也只有唯一的一组 id 和 SEL 参数。
</code></pre>

<p>Cache</p>

<pre><code>typedef struct objc_cache *Cache

Cache 为方法调用的性能进行优化，每当实例对象接收到一个消息时，它不会直接在 isa 指针指向的类的方法列表中遍历查找能够响应的方法，因为每次都要查找效率太低了，而是优先在 Cache 中查找。

Runtime 系统会把被调用的方法存到 Cache 中，如果一个方法被调用，那么它有可能今后还会被调用，下次查找的时候就会效率更高。就像计算机组成原理中 CPU 绕过主存先访问 Cache 一样。
</code></pre>

<p>Property
    typedef struct objc_property *objc_property_t;//这个更常用</p>

<pre><code>可以通过class_copyPropertyList 和 protocol_copyPropertyList 方法获取类和协议中的属性：

注意：
返回的是属性列表，列表中每个元素都是一个 objc_property_t 指针
</code></pre>

<h6>动态特性</h6>

<pre><code>Objective-C具有相当多的动态特性，基本的，也是经常被提到和用到的有

    动态类型（Dynamic typing）
    动态绑定（Dynamic binding）
    动态加载（Dynamic loading）

动态类型：程序直到执行时才能确定所属的类。

id 数据类型，id 通用的对象类型，可以存储任意类型的对象，id后面没有号，它本身就是个指针，类似于void ，但只可以指向对象类型

静态类型与动态类型

    编译期检查与运行时检查
    静态类型在编译期就能检查出错误
    静态类型声明代码可读性好
    动态类型只有在运行时才能发现错误

动态绑定：程序直到执行时才能确定实际要调用的方法。

动态绑定所做的，即是在实例所属类确定后，将某些属性和相应的方法绑定到实例上。

说明：objective-c 中的BOOL实际上是一种对带符号的字符类型（signed char）的类型定义（typedef），它使用8位的存储空间。通过#define指令把YES定义为1，NO定义为0。

动态加载：根据需求加载所需要的资源

这点很容易理解，对于iOS开发来说，基本就是根据不同的机型做适配。最经典的例子就是在Retina设备上加载@2x的图片，而在老一些的普通屏设备上加载原图。随着Retina iPad的推出，和之后可能的Retina Mac的出现，这个特性相信会被越来越多地使用。
多态的出现时为了让不同的类能使用同名的方法。这个让程序的可读性大大提高，也降低了编程难度。

动态类型与动态绑定是为了解决随多态的便利而引起的弊端，有了动态类型与动态绑定，不用去考虑输出中的方法是哪个类型的方法，会自动判定。

而id类型的出现就是为了更好的承接动态类型与动态方法出来的返回值。
</code></pre>

<h6>常用方法</h6>

<p>Ivar <em>ivars = class_copyIvarList([iCocosObject class], &amp;count);
Method </em>met = class_copyMethodList([iCocosObject class], &amp;meth);
objc_property_t *xsL = class_copyPropertyList([iCocosObject class], &amp;xs);
Method ic =  class_getInstanceMethod(NSClassFromString(@&ldquo;<em>NSArrayM&rdquo;), @selector(iCocosobject:));
Method add =  class_getInstanceMethod(NSClassFromString(@&ldquo;</em>NSArrayM&rdquo;), @selector(addObject:));</p>

<pre><code>objc_msgSend : 给对象发送消息
class_copyMethodList : 遍历某个类所有的方法
class_copyIvarList : 遍历某个类所有的成员变量
class_..... 这是我们学习runtime必须知道的函数！
</code></pre>

<h6>属性与成员变量</h6>

<p>Ivar: 实例变量类型，是一个指向objc_ivar结构体的指针。objc_property_t：声明的属性的类型，是一个指向objc_property结构体的指针</p>

<ol>
<li>属性变量 是已经设置了 setter getter方法的 OC已经自己给设置了</li>
<li>属性变量 你每次调用 self.属性变量 的时候 都要调用getter或者setter方法
封装</li>
</ol>


<p>如果成员变量是private，程序中的其它对象很难直接访问该成员变量。如果是属性，相对更容易用父类方法读写属性。</p>

<p>性能</p>

<pre><code>成员变量地址可以根据实例的内存地址偏移寻址。而属性的读写都需要函数调用，相对更慢。
</code></pre>

<p>非基础类型</p>

<pre><code>对于复杂的C++类型，往往设为成员变量更合适，也许这种类型不支持copy，或者完全复制很麻烦。
</code></pre>

<p>多线程</p>

<pre><code>多线程环境下，为保证数据一致性，在需要同步执行的代码段更应该使用成员变量。如果对需要同步更新的数据用getter/setter 方法，数据更新效率低，会带来更多的获取锁请求失败。
</code></pre>

<p>程序正确性</p>

<pre><code>成员变量可以做直观的内存管理。属性可以一层层继承，还可以复写。容易出错。
</code></pre>

<p>二进制文件的体积</p>

<pre><code>默认用属性，会生成不必要的getter/setter 方法，程序体积会变大。
</code></pre>

<p>1.如果只是单纯的private变量，最好声明在implementation里.
2.如果是类的public属性，就用property写在.h文件里
3.如果自己内部需要setter和getter来实现一些东西，就在.m文件的类目里用property来声明</p>

<h6>消息机制消息机制</h6>

<pre><code>[obj makeText];==objc_msgSend(obj, @selector (makeText));


首先通过obj的isa指针找到obj对应的class。

首先检测这个 selector 是不是要忽略。比如 Mac OS X 开发，有了垃圾回收就不理会 retain，release 这些函数。
检测这个 selector 的 target 是不是 nil，Objc 允许我们对一个 nil 对象执行任何方法不会 Crash，因为运行时会被忽略掉。
如果上面两步都通过了，那么就开始查找这个类的实现 IMP，
在Class中先去cache中 通过SEL查找对应函数method，找到就执行对应的实现。
若cache中未找到，再去methodList中查找，找到就执行对应的实现。
若methodlist中未找到，则取superClass中查找（重复执行以上两个步骤），直到找到最根的类为止。
若任何一部能找到，则将method加 入到cache中，以方便下次查找，并通过method中的函数指针跳转到对应的函数中去执行。
如果以上都不能找到，则会开始进行消息转发
</code></pre>

<h6>消息转发</h6>

<pre><code>1.动态方法解析：向当前类发送 resolveInstanceMethod: 信号，检查是否动态向该类添加了方法。（迷茫请搜索：@dynamic）
2.快速消息转发：检查该类是否实现了 forwardingTargetForSelector: 方法，若实现了则调用这个方法。若该方法返回值对象非nil或非self，则向该返回对象重新发送消息。
3.标准消息转发：runtime发送methodSignatureForSelector:消息获取Selector对应的方法签名。返回值非空则通过forwardInvocation:转发消息，返回值为空则向当前对象发送doesNotRecognizeSelector:消息，程序崩溃退出

总结就是：
在一个函数找不到时，OC提供了三种方式去补救：
1、调用resolveInstanceMethod给个机会让类添加这个实现这个函数
2、调用forwardingTargetForSelector让别的对象去执行这个函数
3、调用forwardInvocation（函数执行器）灵活的将目标函数以其他形式执行。
如果都不中，调用doesNotRecognizeSelector抛出异常。
</code></pre>

<h6>常见用途</h6>

<ul>
<li>增加，删除，修改一个类，属性，成员变量，方法</li>
</ul>


<h6>实际应用</h6>

<ul>
<li>关联对象</li>
<li>方法混淆</li>
<li>NSCoding(归档和解档, 利用runtime遍历模型对象的所有属性)</li>
<li>字典 &ndash;> 模型 (利用runtime遍历模型对象的所有属性, 根据属性名从字典中取出对应的值, 设置到模型的属性上)</li>
<li>KVO(利用runtime动态产生一个类)</li>
<li>用于封装框架(想怎么改就怎么改) 这就是我们runtime机制的只要运用方向</li>
</ul>


<h3>RunLoop（底层）</h3>

<h6>RunLoop 的简单概述</h6>

<p>RunLoop:</p>

<pre><code>   Runloop是事件接收和分发机制的一个实现。

   Runloop提供了一种异步执行代码的机制，不能并行执行任务。

   在主队列中，Main RunLoop直接配合任务的执行，负责处理UI事件、定时器以及其他内核相关事件。
</code></pre>

<p>主要目的：</p>

<pre><code>   保证程序执行的线程不会被系统终止。   
</code></pre>

<p>使用Runloop ？</p>

<pre><code>   当需要和该线程进行交互的时候才会使用Runloop.


   每一个线程都有其对应的RunLoop，但是默认非主线程的RunLoop是没有运行的，需要为RunLoop添加至少一个事件源，然后去run它。


   一般情况下我们是没有必要去启用线程的RunLoop的，除非你在一个单独的线程中需要长久的检测某个事件。
</code></pre>

<p>主线程默认有Runloop。当自己启动一个线程，如果只是用于处理单一的事件，则该线程在执行完之后就退出了。所以当我们需要让该线程监听某项事务
时，就得让线程一直不退出，runloop就是这么一个循环，没有事件的时候，一直卡着，有事件来临了，执行其对应的函数。</p>

<pre><code>   RunLoop,正如其名所示,是线程进入和被线程用来相应事件以及调用事件处理函数的地方.需要在代码中使用控制语句实现RunLoop的循环,也就是说,需要代码提供while或者for循环来驱动RunLoop.


   在这个循环中,使用一个runLoop对象[NSRunloop currentRunloop]执行接收消息,调用对应的处理函数.


    Runloop接收两种源事件:input sources和timer sources。


   input sources 传递异步事件，通常是来自其他线程和不同的程序中的消息；


   timer sources(定时器) 传递同步事件（重复执行或者在特定时间上触发）。


   除了处理input sources，Runloop
</code></pre>

<p>也会产生一些关于本身行为的notificaiton。注册成为Runloop的observer，可以接收到这些notification，做一些额外
的处理。（使用CoreFoundation来成为runloop的observer）。</p>

<p>Runloop工作的特点:</p>

<pre><code>   1&gt;当有时间发生时,Runloop会根据具体的事件类型通知应用程序作出相应;


   2&gt;当没有事件发生时,Runloop会进入休眠状态,从而达到省电的目的;


   3&gt;当事件再次发生时,Runloop会被重新唤醒,处理事件.
</code></pre>

<p>提示:一般在开发中很少会主动创建Runloop,而通常会把事件添加到Runloop中.</p>

<p>苹果提供了两个途径来获取分别是Cocoe里面定义的NSRunLoop以及CoreFoundation里面定义的CFRunLoopRef。</p>

<pre><code>CFRunLoopRef提供了纯C函数的API，所有这些API都是线程安全的。
NSRunLoop提供了面向对象的API，但这些API不是线程安全的。
</code></pre>

<h6>RunLoop 与线程的关系</h6>

<p>iOS 开发中能遇到两个线程对象: pthread_t 和 NSThread。过去苹果有份文档标明了 NSThread 只是 pthread_t 的封装，但那份文档已经失效了，现在它们也有可能都是直接包装自最底层的 mach thread。苹果并没有提供这两个对象相互转换的接口，但不管怎么样，可以肯定的是 pthread_t 和 NSThread 是一一对应的。比如，你可以通过 pthread_main_np() 或 [NSThread mainThread] 来获取主线程；也可以通过 pthread_self() 或 [NSThread currentThread] 来获取当前线程。CFRunLoop 是基于 pthread 来管理的。</p>

<p>苹果不允许直接创建 RunLoop，它只提供了两个自动获取的函数：CFRunLoopGetMain() 和 CFRunLoopGetCurrent()。</p>

<p>线程和 RunLoop 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 RunLoop（主线程除外）。</p>

<h6>RunLoop 的 Mode</h6>

<ol>
<li><p>kCFRunLoopDefaultMode: App的默认 Mode，通常主线程是在这个 Mode 下运行的。</p></li>
<li><p>UITrackingRunLoopMode: 界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响。</p></li>
<li><p>UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用。</p></li>
<li><p>GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到。</p></li>
<li><p>kCFRunLoopCommonModes: 这是一个占位的 Mode，没有实际作用。</p></li>
</ol>


<p>你可以在这里看到更多的苹果内部的 Mode，但那些 Mode 在开发中就很难遇到了。</p>

<p>一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。</p>

<h6>RunLoop 的底层实现(内部逻辑)</h6>

<p>RunLoop 的核心是基于 mach port 的，其进入休眠时调用的函数是 mach_msg()</p>

<p>RunLoop 的核心就是一个 mach_msg() (见上面代码的第7步)，RunLoop 调用这个函数去接收消息，如果没有别人发送 port 消息过来，内核会将线程置于等待状态。例如你在模拟器里跑起一个 iOS 的 App，然后在 App 静止时点击暂停，你会看到主线程调用栈是停留在 mach_msg_trap() 这个地方。</p>

<h6>应用</h6>

<ul>
<li><p>AutoreleasePool</p></li>
<li><p>事件响应</p></li>
<li><p>手势识别</p></li>
<li><p>界面更新</p></li>
<li><p>定时器</p></li>
<li><p>PerformSelecter</p></li>
<li><p>关于GCD</p></li>
<li><p>关于网络请求</p></li>
<li><p>AFNetworking</p></li>
<li><p>AsyncDisplayKit</p></li>
</ul>


<h3>多线程（底层与安全）</h3>

<p>线程：1个进程要想执行任务，必须得有线程.线程是进程的基本执行单元，一个进程（程序）的所有任务都在线程中执行</p>

<p>底层：Mach是第一个以多线程方式处理任务的系统，因此多线程的底层实现机制是基于Mach的线程。</p>

<pre><code> 1》C语言的POSIX接口：#include&lt;pthread.h&gt;POSIX线程（POSIX threads），简称Pthreads，是线程的POSIX标准。该标准定义了创建和操纵线程的一整套API。在类Unix操作系统（Unix、Linux、Mac OS X等）中，都使用Pthreads作为操作系统的线程
 2》OC的NSThread
 3》 C语言的GCD接口（性能最好，代码更精简）  
 4》  OC的NSOperation和NSOperationQueue（基于GCD）
</code></pre>

<p>好处：</p>

<pre><code>1、使用线程可以把程序中占据时间长的任务放到后台去处理，如图片、视频的下载

2、发挥多核处理器的优势，并发执行让系统运行的更快、更流畅，用户体验更好
</code></pre>

<p>缺点：</p>

<pre><code>1、大量的线程降低代码的可读性，

2、更多的线程需要更多的内存空间

3、当多个线程对同一个资源出现争夺的时候要注意线程安全的问题。
</code></pre>

<p>GCD内部怎么实现的</p>

<pre><code>  1》 iOS和OSX的核心是XNU内核（苹果电脑发展的操作系统内核），GCD是基于XNU内核实现的。
  2》GCD的API全部在libdispatch库中
  3》GCD的底层实现主要有：Dispatch Queue和Dispatch Source
    Dispatch Queue :管理block操作
    Dispatch Source：处理事件（比如说线程间的通信）
</code></pre>

<p>6.GCD和NSOperationQueue</p>

<pre><code>   1》GCD是纯C语言的API，NSOperationQueue是基于GCD的OC版本的封装
   2》GCD只支持FIFO的队列，NSOperationQueue可以很方便的调整执行顺序，可以添加依赖设置最大并发数量。
   3》GCD的执行速度比NSOperationQueue快
   4》NSOperationQueue支持KVO，可以检测Operation是否正在执行，是否结束，是否取消。
</code></pre>

<p>如何进行选择？
任务之间不太相互依赖，选用GCD；
任务之间有依赖，或者要监听任务的执行情况：NSOperationQueue</p>

<p>一、前言
     1》只在主线程刷新访问UI
     2》如果要防止资源抢夺，得用synchronize进行加锁保护。
     3》如果异步操作要保证线程安全等问题，尽量使用GCD。（GCD有些函数默认就是安全的）</p>

<p>前段时间看了几个开源项目，发现他们保持线程同步的方式各不相同，有@synchronized、NSLock、dispatch_semaphore、NSCondition、pthread_mutex、OSSpinLock。后来网上查了一下，发现他们的实现机制各不相同，性能也各不一样。不好意思，我们平常使用最多的@synchronized是性能最差的。下面我们先分别介绍每个加锁方式的使用，在使用一个案例来对他们进行性能对比。</p>

<p>二、介绍与使用</p>

<p>2.1、@synchronized</p>

<pre><code>NSObject *obj = [[NSObject alloc] init];
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    @synchronized(obj) {
       NSLog(@"需要线程同步的操作1 开始");
       sleep(3);
       NSLog(@"需要线程同步的操作1 结束");
    }
});
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    sleep(1);
    @synchronized(obj) {
       NSLog(@"需要线程同步的操作2");
    }
});
</code></pre>

<p>@synchronized(obj)指令使用的obj为该锁的唯一标识，只有当标识相同时，才为满足互斥，如果线程2中的@synchronized(obj)改为@synchronized(self),刚线程2就不会被阻塞，@synchronized指令实现锁的优点就是我们不需要在代码中显式的创建锁对象，便可以实现锁的机制，但作为一种预防措施，@synchronized块会隐式的添加一个异常处理例程来保护代码，该处理例程会在异常抛出的时候自动的释放互斥锁。所以如果不想让隐式的异常处理例程带来额外的开销，你可以考虑使用锁对象。</p>

<p>2.2、dispatch_semaphore</p>

<pre><code>dispatch_semaphore_t signal = dispatch_semaphore_create(1);
dispatch_time_t overTime = dispatch_time(DISPATCH_TIME_NOW, 3 * NSEC_PER_SEC);
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    dispatch_semaphore_wait(signal, overTime);
            NSLog(@"需要线程同步的操作1 开始");
            sleep(2);
            NSLog(@"需要线程同步的操作1 结束");
        dispatch_semaphore_signal(signal);
});
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        sleep(1);
        dispatch_semaphore_wait(signal, overTime);
            NSLog(@"需要线程同步的操作2");
        dispatch_semaphore_signal(signal);
});
</code></pre>

<p>dispatch_semaphore是GCD用来同步的一种方式，与他相关的共有三个函数，分别是dispatch_semaphore_create，dispatch_semaphore_signal，dispatch_semaphore_wait。</p>

<p>（1）dispatch_semaphore_create的声明为：</p>

<p>dispatch_semaphore_t dispatch_semaphore_create(long value);</p>

<p>传入的参数为long，输出一个dispatch_semaphore_t类型且值为value的信号量。</p>

<p>值得注意的是，这里的传入的参数value必须大于或等于0，否则dispatch_semaphore_create会返回NULL。</p>

<p>（2）dispatch_semaphore_signal的声明为：</p>

<p>long dispatch_semaphore_signal(dispatch_semaphore_t dsema);</p>

<p>这个函数会使传入的信号量dsema的值加1；</p>

<p>(3) dispatch_semaphore_wait的声明为：</p>

<p>long dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout);</p>

<p>这个函数会使传入的信号量dsema的值减1；这个函数的作用是这样的，如果dsema信号量的值大于0，该函数所处线程就继续执行下面的语句，并且将信号量的值减1；如果desema的值为0，那么这个函数就阻塞当前线程等待timeout（注意timeout的类型为dispatch_time_t，不能直接传入整形或float型数），如果等待的期间desema的值被dispatch_semaphore_signal函数加1了，且该函数（即dispatch_semaphore_wait）所处线程获得了信号量，那么就继续向下执行并将信号量减1。如果等待期间没有获取到信号量或者信号量的值一直为0，那么等到timeout时，其所处线程自动执行其后语句。</p>

<p>dispatch_semaphore 是信号量，但当信号总量设为 1 时也可以当作锁来。在没有等待情况出现时，它的性能比 pthread_mutex 还要高，但一旦有等待情况出现时，性能就会下降许多。相对于 OSSpinLock 来说，它的优势在于等待时不会消耗 CPU 资源。</p>

<p>如上的代码，如果超时时间overTime设置成>2，可完成同步操作。如果overTime&lt;2的话，在线程1还没有执行完成的情况下，此时超时了，将自动执行下面的代码。</p>

<p>2.3、NSLock</p>

<pre><code>NSLock *lock = [[NSLock alloc] init];
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    //[lock lock];
    [lock lockBeforeDate:[NSDate date]];
    NSLog(@"需要线程同步的操作1 开始");
    sleep(2);
    NSLog(@"需要线程同步的操作1 结束");
    [lock unlock];
});
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    sleep(1);
    if ([lock tryLock]) {//尝试获取锁，如果获取不到返回NO，不会阻塞该线程
        NSLog(@"锁可用的操作");
        [lock unlock];
    }else{
        NSLog(@"锁不可用的操作");
    }
    NSDate *date = [[NSDate alloc] initWithTimeIntervalSinceNow:3];
    if ([lock lockBeforeDate:date]) {//尝试在未来的3s内获取锁，并阻塞该线程，如果3s内获取不到恢复线程, 返回NO,不会阻塞该线程
        NSLog(@"没有超时，获得锁");
        [lock unlock];
    }else{
        NSLog(@"超时，没有获得锁");
    }
});
</code></pre>

<p>NSLock是Cocoa提供给我们最基本的锁对象，这也是我们经常所使用的，除lock和unlock方法外，NSLock还提供了tryLock和lockBeforeDate:两个方法，前一个方法会尝试加锁，如果锁不可用(已经被锁住)，刚并不会阻塞线程，并返回NO。lockBeforeDate:方法会在所指定Date之前尝试加锁，如果在指定时间之前都不能加锁，则返回NO。</p>

<pre><code>@protocol NSLocking
- (void)lock;
- (void)unlock;
@end
@interface NSLock : NSObject  {
@private
    void *_priv;
}
- (BOOL)tryLock;
- (BOOL)lockBeforeDate:(NSDate *)limit;
@property (nullable, copy) NSString *name NS_AVAILABLE(10_5, 2_0);
@end
</code></pre>

<p>2.4、NSRecursiveLock递归锁</p>

<pre><code>//NSLock *lock = [[NSLock alloc] init];
NSRecursiveLock *lock = [[NSRecursiveLock alloc] init];
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
       static void (^RecursiveMethod)(int);
       RecursiveMethod = ^(int value) {
       [lock lock];
         if (value &gt; 0) {
                NSLog(@"value = %d", value);
                sleep(1);
                RecursiveMethod(value - 1);
          }
         [lock unlock];
     };
     RecursiveMethod(5);
});
</code></pre>

<p>NSRecursiveLock实际上定义的是一个递归锁，这个锁可以被同一线程多次请求，而不会引起死锁。这主要是用在循环或递归操作中。</p>

<p>这段代码是一个典型的死锁情况。在我们的线程中，RecursiveMethod是递归调用的。所以每次进入这个block时，都会去加一次锁，而从第二次开始，由于锁已经被使用了且没有解锁，所以它需要等待锁被解除，这样就导致了死锁，线程被阻塞住了。调试器中会输出如下信息：</p>

<p>在这种情况下，我们就可以使用NSRecursiveLock。它可以允许同一线程多次加锁，而不会造成死锁。递归锁会跟踪它被lock的次数。每次成功的lock都必须平衡调用unlock操作。只有所有达到这种平衡，锁最后才能被释放，以供其它线程使用。</p>

<p>如果我们将NSLock代替为NSRecursiveLock，上面代码则会正确执行。</p>

<p>如果需要其他功能，源码定义如下：</p>

<pre><code>@interface NSRecursiveLock : NSObject  {
@private
    void *_priv;
}
- (BOOL)tryLock;
- (BOOL)lockBeforeDate:(NSDate *)limit;
@property (nullable, copy) NSString *name NS_AVAILABLE(10_5, 2_0);
@end
</code></pre>

<p>2.5、NSConditionLock条件锁</p>

<pre><code>NSMutableArray *products = [NSMutableArray array];
NSInteger HAS_DATA = 1;
NSInteger NO_DATA = 0;
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    while (1) {
        [lock lockWhenCondition:NO_DATA];
        [products addObject:[[NSObject alloc] init]];
        NSLog(@"produce a product,总量:%zi",products.count);
        [lock unlockWithCondition:HAS_DATA];
        sleep(1);
    }
});
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    while (1) {
       NSLog(@"wait for product");
        [lock lockWhenCondition:HAS_DATA];
       [products removeObjectAtIndex:0];
       NSLog(@"custome a product");
       [lock unlockWithCondition:NO_DATA];
    }
});
</code></pre>

<p>当我们在使用多线程的时候，有时一把只会lock和unlock的锁未必就能完全满足我们的使用。因为普通的锁只能关心锁与不锁，而不在乎用什么钥匙才能开锁，而我们在处理资源共享的时候，多数情况是只有满足一定条件的情况下才能打开这把锁：</p>

<p>在线程1中的加锁使用了lock，所以是不需要条件的，所以顺利的就锁住了，但在unlock的使用了一个整型的条件，它可以开启其它线程中正在等待这把钥匙的临界地，而线程2则需要一把被标识为2的钥匙，所以当线程1循环到最后一次的时候，才最终打开了线程2中的阻塞。但即便如此，NSConditionLock也跟其它的锁一样，是需要lock与unlock对应的，只是lock,lockWhenCondition:与unlock，unlockWithCondition:是可以随意组合的，当然这是与你的需求相关的。</p>

<p>如果你需要其他功能，源码定义如下：</p>

<pre><code>@interface NSConditionLock : NSObject  {
@private
    void *_priv;
}
- (instancetype)initWithCondition:(NSInteger)condition NS_DESIGNATED_INITIALIZER;
@property (readonly) NSInteger condition;
- (void)lockWhenCondition:(NSInteger)condition;
- (BOOL)tryLock;
- (BOOL)tryLockWhenCondition:(NSInteger)condition;
- (void)unlockWithCondition:(NSInteger)condition;
- (BOOL)lockBeforeDate:(NSDate *)limit;
- (BOOL)lockWhenCondition:(NSInteger)condition beforeDate:(NSDate *)limit;
@property (nullable, copy) NSString *name NS_AVAILABLE(10_5, 2_0);
@end
</code></pre>

<p>2.6、NSCondition</p>

<pre><code>NSCondition *condition = [[NSCondition alloc] init];
NSMutableArray *products = [NSMutableArray array];
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        while (1) {
            [condition lock];
            if ([products count] == 0) {
                NSLog(@"wait for product");
                [condition wait];
            }
            [products removeObjectAtIndex:0];
            NSLog(@"custome a product");
            [condition unlock];
        }
    });
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        while (1) {
            [condition lock];
            [products addObject:[[NSObject alloc] init]];
            NSLog(@"produce a product,总量:%zi",products.count);
            [condition signal];
            [condition unlock];
            sleep(1);
        }
});
</code></pre>

<p>一种最基本的条件锁。手动控制线程wait和signal。</p>

<p>[condition lock];一般用于多线程同时访问、修改同一个数据源，保证在同一时间内数据源只被访问、修改一次，其他线程的命令需要在lock 外等待，只到unlock ，才可访问</p>

<p>[condition unlock];与lock 同时使用</p>

<p>[condition wait];让当前线程处于等待状态</p>

<p>[condition signal];CPU发信号告诉线程不用在等待，可以继续执行</p>

<p>2.7、pthread_mutex</p>

<pre><code>__block pthread_mutex_t theLock;
pthread_mutex_init(&amp;theLock, NULL);
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        pthread_mutex_lock(&amp;theLock);
        NSLog(@"需要线程同步的操作1 开始");
        sleep(3);
        NSLog(@"需要线程同步的操作1 结束");
        pthread_mutex_unlock(&amp;theLock);
});
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        sleep(1);
        pthread_mutex_lock(&amp;theLock);
        NSLog(@"需要线程同步的操作2");
        pthread_mutex_unlock(&amp;theLock);
});
</code></pre>

<p>c语言定义下多线程加锁方式。</p>

<p>1：pthread_mutex_init(pthread_mutex_t mutex,const pthread_mutexattr_t attr);</p>

<p>初始化锁变量mutex。attr为锁属性，NULL值为默认属性。</p>

<p>2：pthread_mutex_lock(pthread_mutex_t mutex);加锁</p>

<p>3：pthread_mutex_tylock(<em>pthread_mutex_t </em>mutex);加锁，但是与2不一样的是当锁已经在使用的时候，返回为EBUSY，而不是挂起等待。</p>

<p>4：pthread_mutex_unlock(pthread_mutex_t *mutex);释放锁</p>

<p>5：pthread_mutex_destroy(pthread_mutex_t* mutex);使用完后释放</p>

<p>代码执行操作结果如下：</p>

<p>2.8、pthread_mutex(recursive)</p>

<pre><code> __block pthread_mutex_t theLock;
//pthread_mutex_init(&amp;theLock, NULL);
pthread_mutexattr_t attr;
pthread_mutexattr_init(&amp;attr);
pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE);
pthread_mutex_init(&amp;lock, &amp;attr);
pthread_mutexattr_destroy(&amp;attr);
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    static void (^RecursiveMethod)(int);
    RecursiveMethod = ^(int value) {
            pthread_mutex_lock(&amp;theLock);
            if (value &gt; 0) {
                NSLog(@"value = %d", value);
                sleep(1);
                RecursiveMethod(value - 1);
            }
            pthread_mutex_unlock(&amp;theLock);
     };
    RecursiveMethod(5);
});
</code></pre>

<p>这是pthread_mutex为了防止在递归的情况下出现死锁而出现的递归锁。作用和NSRecursiveLock递归锁类似。</p>

<p>如果使用pthread_mutex_init(&amp;theLock, NULL);初始化锁的话，上面的代码会出现死锁现象。如果使用递归锁的形式，则没有问题。</p>

<p>2.9、OSSpinLock</p>

<pre><code>__block OSSpinLock theLock = OS_SPINLOCK_INIT;
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    OSSpinLockLock(&amp;theLock);
    NSLog(@"需要线程同步的操作1 开始");
    sleep(3);
    NSLog(@"需要线程同步的操作1 结束");
    OSSpinLockUnlock(&amp;theLock);
});
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    OSSpinLockLock(&amp;theLock);
    sleep(1);
    NSLog(@"需要线程同步的操作2");
    OSSpinLockUnlock(&amp;theLock);
});
</code></pre>

<p>OSSpinLock 自旋锁，性能最高的锁。原理很简单，就是一直 do while 忙等。它的缺点是当等待时会消耗大量 CPU 资源，所以它不适用于较长时间的任务。 不过最近YY大神在自己的博客不再安全的 OSSpinLock中说明了OSSpinLock已经不再安全，请大家谨慎使用。</p>

<p>三、性能对比</p>

<pre><code>OSSpinLock和dispatch_semaphore的效率远远高于其他。

@synchronized和NSConditionLock效率较差。

鉴于OSSpinLock的不安全，所以我们在开发中如果考虑性能的话，建议使用dispatch_semaphore。

如果不考虑性能，只是图个方便的话，那就使用@synchronized。
</code></pre>

<h3>网络（底层与安全）</h3>

<h3>数据持久化（各种使用与区别）（CoreData、SQLite）</h3>

<h3>Block（底层/__Block）</h3>

<h3>音视频</h3>

<h3>直播</h3>

<h3>安全</h3>

<h3>优化（性能、卡顿）</h3>

<h3>常见错误</h3>

<h3>常用技术</h3>

<p>KVC</p>

<pre><code>KVC运用了一个isa-swizzling技术。isa-swizzling就是类型混合指针机制。KVC主要通过isa-swizzling，来实现其内部查找定位的。isa指针，如其名称所指，（就是is a kind of的意思），指向维护分发表的对象的类。该分发表实际上包含了指向实现类中的方法的指针，和其它数据
一个对象在调用setValue的时候，（1）首先根据方法名找到运行方法的时候所需要的环境参数。（2）他会从自己isa指针结合环境参数，找到具体的方法实现的接口。（3）再直接查找得来的具体的方法实现。
</code></pre>

<p>KVO</p>

<pre><code>观察者为一个对象的属性进行了注册，被观察对象的isa指针被修改的时候，isa指针就会指向一个中间类（setter/getter方法），而不是真实的类。所以isa指针其实不需要指向实例对象真实的类。所以我们的程序最好不要依赖于isa指针。在调用类的方法的时候，最好要明确对象实例的类名。
熟悉KVO的朋友都知道，只有当我们调用KVC去访问key值的时候KVO才会起作用。所以肯定确定的是，KVO是基于KVC实现的。其实看了上面我们的分析以后，关系KVO的架构的构思也就水到渠成了。
</code></pre>

<p>任何工程产品（注意是任何工程产品）都可以使用以下两种方法之一进行测试。
黑盒测试：已知产品的功能设计规格，可以进行测试证明每个实现了的功能是否符合要求。
白盒测试：已知产品的内部工作过程，可以通过测试证明每种内部操作是否符合设计规格要求，所有内部成分是否以经过检查。</p>

<h5>黑盒测试</h5>

<p>软件的黑盒测试意味着测试要在软件的接口处进行。这种方法是把测试对象看做一个黑盒子，测试人员完全不考虑程序内部的逻辑结构和内部特性，只依据程序的需求规格说明书，检查程序的功能是否符合它的功能说明。因此黑盒测试又叫功能测试或数据驱动测试。</p>

<pre><code>黑盒测试主要是为了发现以下几类错误：
1、是否有不正确或遗漏的功能？
2、在接口上，输入是否能正确的接受？能否输出正确的结果？
3、是否有数据结构错误或外部信息（例如数据文件）访问错误？
4、性能上是否能够满足要求？
5、是否有初始化或终止性错误？
</code></pre>

<h5>白盒测试</h5>

<p>软件的白盒测试是对软件的过程性细节做细致的检查。这种方法是把测试对象看做一个打开的盒子，它允许测试人员利用程序内部的逻辑结构及有关信息，设计或选择测试用例，对程序所有逻辑路径进行测试。通过在不同点检查程序状态，确定实际状态是否与预期的状态一致。因此白盒测试又称为结构测试或逻辑驱动测试。</p>

<pre><code>白盒测试主要是想对程序模块进行如下检查：
1、对程序模块的所有独立的执行路径至少测试一遍。
2、对所有的逻辑判定，取“真”与取“假”的两种情况都能至少测一遍。
3、在循环的边界和运行的界限内执行循环体。
4、测试内部数据结构的有效性，等等。
</code></pre>

<p>以上事实说明，软件测试有一个致命的缺陷，即测试的不完全、不彻底性。由于任何程序只能进行少量（相对于穷举的巨大数量而言）的有限的测试，在未发现错误时，不能说明程序中没有错误。</p>

<h5>灰盒测试</h5>

<p>灰盒测试，是介于白盒测试与黑盒测试之间的，可以这样理解，灰盒测试关注输出对于输入的正确性，同时也关注内部表现，但这种关注不象白盒那样详细、完整，只是通过一些表征性的现象、事件、标志来判断内部的运行状态，有时候输出是正确的，但内部其实已经错误了，这种情况非常多，如果每次都通过白盒测试来操作，效率会很低，因此需要采取这样的一种灰盒的方法。</p>

<h3>全栈相关</h3>

<h3>算法（常用、排序）</h3>

<h3>数据结构</h3>

<h3>设计模式（32中）</h3>

<h3>架构设计</h3>

<h3>逆向工程</h3>

<h3>实战应用</h3>

<pre><code>Q Q：2211523682/790806573

微信：18370997821/13148454507

微博WB:http://weibo.com/u/3288975567?is_hot=1

git博文：http://al1020119.github.io/

github：https://github.com/al1020119
</code></pre>

<p><img src="http://al1020119.github.io/images/iCocosCoder.jpg" title="Caption" ></p>

<p><img src="http://al1020119.github.io/images/iCocosPublic.jpg" title="Caption" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[多线程之葵花宝典]]></title>
    <link href="http://al1020119.github.io/blog/2016/07/10/duoxianc/"/>
    <updated>2016-07-10T14:59:42+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/07/10/duoxianc</id>
    <content type="html"><![CDATA[<h2>一、进程和线程</h2>

<h4>1.什么是进程</h4>

<pre><code>进程是指在系统中正在运行的一个应用程序

每个进程之间是独立的，每个进程均运行在其专用且受保护的内存空间内





比如同时打开QQ、Xcode，系统就会分别启动2个进程

通过“活动监视器”可以查看Mac系统中所开启的进程
</code></pre>

<!--more-->


<h4>2.什么是线程</h4>

<pre><code>1个进程要想执行任务，必须得有线程（每1个进程至少要有1条线程）

线程是进程的基本执行单元，一个进程（程序）的所有任务都在线程中执行

比如使用酷狗播放音乐、使用迅雷下载电影，都需要在线程中执行
</code></pre>

<p> 　　</p>

<h4>3.线程的串行</h4>

<pre><code>1个线程中任务的执行是串行的

如果要在1个线程中执行多个任务，那么只能一个一个地按顺序执行这些任务

也就是说，在同一时间内，1个线程只能执行1个任务

比如在1个线程中下载3个文件（分别是文件A、文件B、文件C）
</code></pre>

<h2>二、多线程</h2>

<h4>1.什么是多线程</h4>

<pre><code>1个进程中可以开启多条线程，每条线程可以并行（同时）执行不同的任务

进程 -&gt;车间，线程-&gt;车间工人

多线程技术可以提高程序的执行效率

比如同时开启3条线程分别下载3个文件（分别是文件A、文件B、文件C）
</code></pre>

<h4>2.多线程的原理</h4>

<pre><code>同一时间，CPU只能处理1条线程，只有1条线程在工作（执行）
多线程并发（同时）执行，其实是CPU快速地在多条线程之间调度（切换）
如果CPU调度线程的时间足够快，就造成了多线程并发执行的假象
思考：如果线程非常非常多，会发生什么情况？
CPU会在N多线程之间调度，CPU会累死，消耗大量的CPU资源
每条线程被调度执行的频次会降低（线程的执行效率降低）
</code></pre>

<h4>3.多线程的优缺点</h4>

<p>多线程的优点</p>

<pre><code>能适当提高程序的执行效率

能适当提高资源利用率（CPU、内存利用率）
</code></pre>

<p>多线程的缺点</p>

<pre><code>开启线程需要占用一定的内存空间（默认情况下，主线程占用1M，子线程占用512KB），如果开启大量的线程，会占用大量的内存空间，降低程序的性能

线程越多，CPU在调度线程上的开销就越大

程序设计更加复杂：比如线程之间的通信、多线程的数据共享
</code></pre>

<h4>4.多线程在iOS开发中的应用</h4>

<pre><code>主线程:一个iOS程序运行后，默认会开启1条线程，称为“主线程”或“UI线程”

主线程的主要作用

显示\刷新UI界面

处理UI事件（比如点击事件、滚动事件、拖拽事件等）
</code></pre>

<p>主线程的使用注意:别将比较耗时的操作放到主线程中。</p>

<p>耗时操作会卡住主线程，严重影响UI的流畅度，给用户一种“卡”的坏体验</p>

<h2>多线程的四中方式</h2>

<h4>1. Pthreads</h4>

<h4>2. NSThread</h4>

<h4>3. GCD</h4>

<h4>4. NSOperation &amp; NSOperationQueue</h4>

<h2>多线程的全解析-看了不信你还不会？</h2>

<p><img src="http://al1020119.github.io/images/multithread.png" title="Caption" ></p>

<pre><code>Q Q：2211523682/790806573

微信：18370997821/13148454507

微博WB:http://weibo.com/u/3288975567?is_hot=1

git博文：http://al1020119.github.io/

github：https://github.com/al1020119
</code></pre>

<p><img src="http://al1020119.github.io/images/iCocosCoder.jpg" title="Caption" ></p>

<p><img src="http://al1020119.github.io/images/iCocosPublic.jpg" title="Caption" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CoreData 😘 SQLite 😍 FMDB]]></title>
    <link href="http://al1020119.github.io/blog/2016/07/05/zsqlfmdbcoredata/"/>
    <updated>2016-07-05T14:59:42+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/07/05/zsqlfmdbcoredata</id>
    <content type="html"><![CDATA[<p>概览</p>

<p>在iOS开发中数据存储的方式可以归纳为两类：一类是存储为文件，另一类是存储到数据库。例如前面IOS开发系列—Objective-C之Foundation框架的文章中提到归档、plist文件存储，包括偏好设置其本质都是存储为文件，只是说归档或者plist文件存储可以选择保存到沙盒中，而偏好设置系统已经规定只能保存到沙盒的Library/Preferences目录。当然，文件存储并不作为本文的重点内容。本文重点还是说数据库存储，做过数据库开发的朋友应该知道，可以通过SQL直接访问数据库，也可以通过ORM进行对象关系映射访问数据库。这两种方式恰恰对应iOS中SQLite和Core Data的内容，在此将重点进行分析:</p>

<h3>1. SQLite</h3>

<h3>2. Core Data</h3>

<h3>3. FMDB</h3>

<!--more-->


<hr />

<h2>SQLite</h2>

<p>SQLite是目前主流的嵌入式关系型数据库，其最主要的特点就是轻量级、跨平台，当前很多嵌入式操作系统都将其作为数据库首选。虽然SQLite是一款轻型数据库，但是其功能也绝不亚于很多大型关系数据库。学习数据库就要学习其相关的定义、操作、查询语言，也就是大家日常说得SQL语句。和其他数据库相比，SQLite中的SQL语法并没有太大的差别，因此这里对于SQL语句的内容不会过多赘述，大家可以参考SQLite中其他SQL相关的内容，这里还是重点讲解iOS中如何使用SQLite构建应用程序。先看一下SQLite数据库的几个特点：</p>

<ol>
<li><p>基于C语言开发的轻型数据库</p></li>
<li><p>在iOS中需要使用C语言语法进行数据库操作、访问（无法使用ObjC直接访问，因为libqlite3框架基于C语言编写）</p></li>
<li><p>SQLite中采用的是动态数据类型，即使创建时定义了一种类型，在实际操作时也可以存储其他类型，但是推荐建库时使用合适的类型（特别是应用需要考虑跨平台的情况时）</p></li>
<li><p>建立连接后通常不需要关闭连接（尽管可以手动关闭）</p></li>
</ol>


<p>要使用SQLite很简单，如果在Mac OSX上使用可以考虑到SQLite官方网站下载命令行工具，也可以使用类似于SQLiteManager、Navicat for SQLite等工具。为了方便大家开发调试，建议在开发环境中安装上述工具。</p>

<p>在iOS中操作SQLite数据库可以分为以下几步（注意先在项目中导入libsqlite3框架）：</p>

<ol>
<li><p>打开数据库，利用sqlite3_open()打开数据库会指定一个数据库文件保存路径，如果文件存在则直接打开，否则创建并打开。打开数据库会得到一个sqlite3类型的对象，后面需要借助这个对象进行其他操作。</p></li>
<li><p>执行SQL语句，执行SQL语句又包括有返回值的语句和无返回值语句。</p></li>
<li><p>对于无返回值的语句（如增加、删除、修改等）直接通过sqlite3_exec()函数执行；</p></li>
<li><p>对于有返回值的语句则首先通过sqlite3_prepare_v2()进行sql语句评估（语法检测），然后通过sqlite3_step()依次取出查询结果的每一行数据，对于每行数据都可以通过对应的sqlite3_column_类型()方法获得对应列的数据，如此反复循环直到遍历完成。当然，最后需要释放句柄。</p></li>
</ol>


<p>在整个操作过程中无需管理数据库连接，对于嵌入式SQLite操作是持久连接（尽管可以通过sqlite3_close()关闭），不需要开发人员自己释放连接。纵观整个操作过程，其实与其他平台的开发没有明显的区别，较为麻烦的就是数据读取，在iOS平台中使用C进行数据读取采用了游标的形式，每次只能读取一行数据，较为麻烦。因此实际开发中不妨对这些操作进行封装：</p>

<p>KCDbManager.h
    //
    //  DbManager.h
    //  DataAccess
    //
    //  Created by Kenshin Cui on 14-3-29.
    //  Copyright &copy; 2014年 Kenshin Cui. All rights reserved.
    //
    #import &lt;Foundation/Foundation.h>
    #import &lt;sqlite3.h>
    #import &ldquo;KCSingleton.h&rdquo;
    @interface KCDbManager : NSObject
    singleton_interface(KCDbManager);
    #pragma mark - 属性
    #pragma mark 数据库引用，使用它进行数据库操作
    @property (nonatomic) sqlite3 <em>database;
    #pragma mark - 共有方法
    /**
     *  打开数据库
     *
     *  @param dbname 数据库名称
     </em>/
    -(void)openDb:(NSString <em>)dbname;
    /**
     *  执行无返回值的sql
     *
     *  @param sql sql语句
     </em>/
    -(void)executeNonQuery:(NSString <em>)sql;
    /**
     *  执行有返回值的sql
     *
     *  @param sql sql语句
     *
     *  @return 查询结果
     </em>/
    -(NSArray <em>)executeQuery:(NSString </em>)sql;
    @end</p>

<pre><code>KCDbManager.m
//
//  DbManager.m
//  DataAccess
//
//  Created by Kenshin Cui on 14-3-29.
//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.
//
#import "KCDbManager.h"
#import &lt;sqlite3.h&gt;
#import "KCSingleton.h"
#import "KCAppConfig.h"
#ifndef kDatabaseName
#define kDatabaseName @"myDatabase.db"
#endif
@interface KCDbManager()
@end
@implementation KCDbManager
singleton_implementation(KCDbManager)
#pragma mark 重写初始化方法
-(instancetype)init{
    KCDbManager *manager;
    if((manager=[super init]))
    {
        [manager openDb:kDatabaseName];
    }
    return manager;
}
-(void)openDb:(NSString *)dbname{
    //取得数据库保存路径，通常保存沙盒Documents目录
    NSString *directory=[NSSearchPathForDirectoriesInDomains(NSDocumentationDirectory, NSUserDomainMask, YES) firstObject];
    NSLog(@"%@",directory);
    NSString *filePath=[directory stringByAppendingPathComponent:dbname];
    //如果有数据库则直接打开，否则创建并打开（注意filePath是ObjC中的字符串，需要转化为C语言字符串类型）
    if (SQLITE_OK ==sqlite3_open(filePath.UTF8String, &amp;_database)) {
        NSLog(@"数据库打开成功!");
    }else{
        NSLog(@"数据库打开失败!");
    }
}
-(void)executeNonQuery:(NSString *)sql{
    char *error;
    //单步执行sql语句，用于插入、修改、删除
    if (SQLITE_OK!=sqlite3_exec(_database, sql.UTF8String, NULL, NULL,&amp;error)) {
        NSLog(@"执行SQL语句过程中发生错误！错误信息：%s",error);
    }
}
-(NSArray *)executeQuery:(NSString *)sql{
    NSMutableArray *rows=[NSMutableArray array];//数据行

    //评估语法正确性
    sqlite3_stmt *stmt;
    //检查语法正确性
    if (SQLITE_OK==sqlite3_prepare_v2(_database, sql.UTF8String, -1, &amp;stmt, NULL)) {
        //单步执行sql语句
        while (SQLITE_ROW==sqlite3_step(stmt)) {
            int columnCount= sqlite3_column_count(stmt);
            NSMutableDictionary *dic=[NSMutableDictionary dictionary];
            for (int i=0; i&lt;columnCount; i++) {
                const char *name= sqlite3_column_name(stmt, i);//取得列名
                const unsigned char *value= sqlite3_column_text(stmt, i);//取得某列的值
                dic[[NSString stringWithUTF8String:name]]=[NSString stringWithUTF8String:(const char *)value];
            }
            [rows addObject:dic];
        }
    }

    //释放句柄
    sqlite3_finalize(stmt);

    return rows;
}
@end
</code></pre>

<p>在上面的类中对于数据库操作进行了封装，封装之后数据操作更加方便，同时所有的语法都由C转换成了ObjC。</p>

<p>下面仍然以微博查看为例进行SQLite演示。当然实际开发中微博数据是从网络读取的，但是考虑到缓存问题，通常会选择将微博数据保存到本地，下面的Demo演示了将数据存放到本地数据库以及数据读取的过程。当然，实际开发中并不会在视图控制器中直接调用数据库操作方法，在这里通常会引入两个概念Model和Service。Model自不必多说，就是MVC中的模型。而Service指的是操作数据库的服务层，它封装了对于Model的基本操作方法，实现具体的业务逻辑。为了解耦，在控制器中是不会直接接触数据库的，控制器中只和模型（模型是领域的抽象）、服务对象有关系，借助服务层对模型进行各类操作，模型的操作反应到数据库中就是对表中数据的操作。具体关系如下：</p>

<p><img src="http://al1020119.github.io/images/CSR001.jpg" title="Caption" ></p>

<p>要完成上述功能，首先定义一个应用程序全局对象进行数据库、表的创建。为了避免每次都创建数据库和表出错，这里利用了偏好设置进行保存当前创建状态（其实这也是数据存储的一部分），如果创建过了数据库则不再创建，否则创建数据库和表。</p>

<p>KCDatabaseCreator.m</p>

<pre><code>//
//  KCDatabaseCreator.m
//  DataAccess
//
//  Created by Kenshin Cui on 14-3-29.
//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.
//
#import "KCDatabaseCreator.h"
#import "KCDbManager.h"
@implementation KCDatabaseCreator
+(void)initDatabase{
    NSString *key=@"IsCreatedDb";
    NSUserDefaults *defaults=[[NSUserDefaults alloc]init];
    if ([[defaults valueForKey:key] intValue]!=1) {
        [self createUserTable];
        [self createStatusTable];
        [defaults setValue:@1 forKey:key];
    }
}
+(void)createUserTable{
    NSString *sql=@"CREATE TABLE User (Id integer PRIMARY KEY AUTOINCREMENT,name text,screenName text, profileImageUrl text,mbtype text,city text)";
    [[KCDbManager sharedKCDbManager] executeNonQuery:sql];
}
+(void)createStatusTable{
    NSString *sql=@"CREATE TABLE Status (Id integer PRIMARY KEY AUTOINCREMENT,source text,createdAt date,\"text\" text,user integer REFERENCES User (Id))";
    [[KCDbManager sharedKCDbManager] executeNonQuery:sql];
}
@end
</code></pre>

<p>其次，定义数据模型，这里定义用户User和微博Status两个数据模型类。注意模型应该尽量保持其单纯性，仅仅是简单的POCO，不要引入视图、控制器等相关内容。</p>

<p>KCUser.h</p>

<pre><code>//
//  KCUser.h
//  UrlConnection
//
//  Created by Kenshin Cui on 14-3-22.
//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.
//
#import &lt;Foundation/Foundation.h&gt;
@interface KCUser : NSObject
#pragma mark 编号
@property (nonatomic,strong) NSNumber *Id;
#pragma mark 用户名
@property (nonatomic,copy) NSString *name;
#pragma mark 用户昵称
@property (nonatomic,copy) NSString *screenName;
#pragma mark 头像
@property (nonatomic,copy) NSString *profileImageUrl;
#pragma mark 会员类型
@property (nonatomic,copy) NSString *mbtype;
#pragma mark 城市
@property (nonatomic,copy) NSString *city;
#pragma mark - 动态方法
/**
 *  初始化用户
 *
 *  @param name 用户名
 *  @param city 所在城市
 *
 *  @return 用户对象
 */
-(KCUser *)initWithName:(NSString *)name screenName:(NSString *)screenName profileImageUrl:(NSString *)profileImageUrl mbtype:(NSString *)mbtype city:(NSString *)city;
/**
 *  使用字典初始化用户对象
 *
 *  @param dic 用户数据
 *
 *  @return 用户对象
 */
-(KCUser *)initWithDictionary:(NSDictionary *)dic;
#pragma mark - 静态方法
+(KCUser *)userWithName:(NSString *)name screenName:(NSString *)screenName profileImageUrl:(NSString *)profileImageUrl mbtype:(NSString *)mbtype city:(NSString *)city;
@end
</code></pre>

<p>KCUser.m</p>

<pre><code>//
//  KCUser.m
//  UrlConnection
//
//  Created by Kenshin Cui on 14-3-22.
//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.
//
#import "KCUser.h"
@implementation KCUser
-(KCUser *)initWithName:(NSString *)name screenName:(NSString *)screenName profileImageUrl:(NSString *)profileImageUrl mbtype:(NSString *)mbtype city:(NSString *)city{
    if (self=[super init]) {
        self.name=name;
        self.screenName=screenName;
        self.profileImageUrl=profileImageUrl;
        self.mbtype=mbtype;
        self.city=city;
    }
    return self;
}
-(KCUser *)initWithDictionary:(NSDictionary *)dic{
    if (self=[super init]) {
        [self setValuesForKeysWithDictionary:dic];
    }
    return self;
}
+(KCUser *)userWithName:(NSString *)name screenName:(NSString *)screenName profileImageUrl:(NSString *)profileImageUrl mbtype:(NSString *)mbtype city:(NSString *)city{
    KCUser *user=[[KCUser alloc]initWithName:name screenName:screenName profileImageUrl:profileImageUrl mbtype:mbtype city:city];
    return user;
}
</code></pre>

<p>@end</p>

<p>KCStatus.h</p>

<pre><code>//
//  KCStatus.h
//  UITableView
//
//  Created by Kenshin Cui on 14-3-1.
//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.
//
#import &lt;Foundation/Foundation.h&gt;
#import "KCUser.h"
@interface KCStatus : NSObject
#pragma mark - 属性
@property (nonatomic,strong) NSNumber *Id;//微博id
@property (nonatomic,strong) KCUser *user;//发送用户
@property (nonatomic,copy) NSString *createdAt;//创建时间
@property (nonatomic,copy) NSString *source;//设备来源
@property (nonatomic,copy) NSString *text;//微博内容
#pragma mark - 动态方法
/**
 *  初始化微博数据
 *
 *  @param createAt        创建日期
 *  @param source          来源
 *  @param text            微博内容
 *  @param user            发送用户
 *
 *  @return 微博对象
 */
-(KCStatus *)initWithCreateAt:(NSString *)createAt source:(NSString *)source text:(NSString *)text user:(KCUser *)user;
/**
 *  初始化微博数据
 *
 *  @param profileImageUrl 用户头像
 *  @param mbtype          会员类型
 *  @param createAt        创建日期
 *  @param source          来源
 *  @param text            微博内容
 *  @param userId          用户编号
 *
 *  @return 微博对象
 */
-(KCStatus *)initWithCreateAt:(NSString *)createAt source:(NSString *)source text:(NSString *)text userId:(int)userId;
/**
 *  使用字典初始化微博对象
 *
 *  @param dic 字典数据
 *
 *  @return 微博对象
 */
-(KCStatus *)initWithDictionary:(NSDictionary *)dic;
#pragma mark - 静态方法
/**
 *  初始化微博数据
 *
 *  @param createAt        创建日期
 *  @param source          来源
 *  @param text            微博内容
 *  @param user            发送用户
 *
 *  @return 微博对象
 */
+(KCStatus *)statusWithCreateAt:(NSString *)createAt source:(NSString *)source text:(NSString *)text user:(KCUser *)user;
/**
 *  初始化微博数据
 *
 *  @param profileImageUrl 用户头像
 *  @param mbtype          会员类型
 *  @param createAt        创建日期
 *  @param source          来源
 *  @param text            微博内容
 *  @param userId          用户编号
 *
 *  @return 微博对象
 */
+(KCStatus *)statusWithCreateAt:(NSString *)createAt source:(NSString *)source text:(NSString *)text userId:(int)userId;
@end
</code></pre>

<p>KCStatus.m</p>

<pre><code>//
//  KCStatus.m
//  UITableView
//
//  Created by Kenshin Cui on 14-3-1.
//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.
//
#import "KCStatus.h"
@implementation KCStatus
-(KCStatus *)initWithDictionary:(NSDictionary *)dic{
    if (self=[super init]) {
        [self setValuesForKeysWithDictionary:dic];
        self.user=[[KCUser alloc]init];
        self.user.Id=dic[@"user"];
    }
    return self;
}
-(KCStatus *)initWithCreateAt:(NSString *)createAt source:(NSString *)source text:(NSString *)text user:(KCUser *)user{
    if (self=[super init]) {
        self.createdAt=createAt;
        self.source=source;
        self.text=text;
        self.user=user;
    }
    return self;
}
-(KCStatus *)initWithCreateAt:(NSString *)createAt source:(NSString *)source text:(NSString *)text userId:(int)userId{
    if (self=[super init]) {
        self.createdAt=createAt;
        self.source=source;
        self.text=text;
        KCUser *user=[[KCUser alloc]init];
        user.Id=[NSNumber numberWithInt:userId];
        self.user=user;
    }
    return self;
}
-(NSString *)source{
    return [NSString stringWithFormat:@"来自 %@",_source];
}
+(KCStatus *)statusWithCreateAt:(NSString *)createAt source:(NSString *)source text:(NSString *)text user:(KCUser *)user{
    KCStatus *status=[[KCStatus alloc]initWithCreateAt:createAt source:source text:text user:user];
    return status;
}
+(KCStatus *)statusWithCreateAt:(NSString *)createAt source:(NSString *)source text:(NSString *)text userId:(int)userId{
    KCStatus *status=[[KCStatus alloc]initWithCreateAt:createAt source:source text:text userId:userId];
    return status;
}
@end
</code></pre>

<p>然后，编写服务类，进行数据的增、删、改、查操作，由于服务类方法同样不需要过多的配置，因此定义为单例，保证程序中只有一个实例即可。服务类中调用前面封装的数据库方法将对数据库的操作转换为对模型的操作。</p>

<p>KCUserService.h</p>

<pre><code>//
//  KCUserService.h
//  DataAccess
//
//  Created by Kenshin Cui on 14-3-29.
//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.
//
#import &lt;Foundation/Foundation.h&gt;
#import "KCUser.h"
#import "KCSingleton.h"
@interface KCUserService : NSObject
singleton_interface(KCUserService)
/**
 *  添加用户信息
 *
 *  @param user 用户对象
 */
-(void)addUser:(KCUser *)user;
/**
 *  删除用户
 *
 *  @param user 用户对象
 */
-(void)removeUser:(KCUser *)user;
/**
 *  根据用户名删除用户
 *
 *  @param name 用户名
 */
-(void)removeUserByName:(NSString *)name;
/**
 *  修改用户内容
 *
 *  @param user 用户对象
 */
-(void)modifyUser:(KCUser *)user;
/**
 *  根据用户编号取得用户
 *
 *  @param Id 用户编号
 *
 *  @return 用户对象
 */
-(KCUser *)getUserById:(int)Id;
/**
 *  根据用户名取得用户
 *
 *  @param name 用户名
 *
 *  @return 用户对象
 */
-(KCUser *)getUserByName:(NSString *)name;
@end
</code></pre>

<p>KCUserService.m</p>

<pre><code>//
//  KCUserService.m
//  DataAccess
//
//  Created by Kenshin Cui on 14-3-29.
//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.
//
#import "KCUserService.h"
#import "KCUser.h"
#import "KCDbManager.h"
@implementation KCUserService
singleton_implementation(KCUserService)
-(void)addUser:(KCUser *)user{
    NSString *sql=[NSString stringWithFormat:@"INSERT INTO User (name,screenName, profileImageUrl,mbtype,city) VALUES('%@','%@','%@','%@','%@')",user.name,user.screenName, user.profileImageUrl,user.mbtype,user.city];
    [[KCDbManager sharedKCDbManager] executeNonQuery:sql];
}
-(void)removeUser:(KCUser *)user{
    NSString *sql=[NSString stringWithFormat:@"DELETE FROM User WHERE Id='%@'",user.Id];
    [[KCDbManager sharedKCDbManager] executeNonQuery:sql];
}
-(void)removeUserByName:(NSString *)name{
    NSString *sql=[NSString stringWithFormat:@"DELETE FROM User WHERE name='%@'",name];
    [[KCDbManager sharedKCDbManager] executeNonQuery:sql];
}
-(void)modifyUser:(KCUser *)user{
    NSString *sql=[NSString stringWithFormat:@"UPDATE User SET name='%@',screenName='%@',profileImageUrl='%@',mbtype='%@',city='%@' WHERE Id='%@'",user.name,user.screenName,user.profileImageUrl,user.mbtype,user.city,user.Id];
    [[KCDbManager sharedKCDbManager] executeNonQuery:sql];
}
-(KCUser *)getUserById:(int)Id{
    KCUser *user=[[KCUser alloc]init];
    NSString *sql=[NSString stringWithFormat:@"SELECT name,screenName,profileImageUrl,mbtype,city FROM User WHERE Id='%i'", Id];
    NSArray *rows= [[KCDbManager sharedKCDbManager] executeQuery:sql];
    if (rows&amp;&amp;rows.count&gt;0) {
        [user setValuesForKeysWithDictionary:rows[0]];
    }
    return user;
}
-(KCUser *)getUserByName:(NSString *)name{
    KCUser *user=[[KCUser alloc]init];
    NSString *sql=[NSString stringWithFormat:@"SELECT Id, name,screenName,profileImageUrl,mbtype,city FROM User WHERE name='%@'", name];
    NSArray *rows= [[KCDbManager sharedKCDbManager] executeQuery:sql];
    if (rows&amp;&amp;rows.count&gt;0) {
        [user setValuesForKeysWithDictionary:rows[0]];
    }
    return user;
}
@end
</code></pre>

<p>KCStatusService.h</p>

<pre><code>//
//  KCStatusService.h
//  DataAccess
//
//  Created by Kenshin Cui on 14-3-29.
//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.
//
#import &lt;Foundation/Foundation.h&gt;
#import "KCSingleton.h"
@class KCStatus;
@interface KCStatusService : NSObject
singleton_interface(KCStatusService)
/**
 *  添加微博信息
 *
 *  @param status 微博对象
 */
-(void)addStatus:(KCStatus *)status;
/**
 *  删除微博
 *
 *  @param status 微博对象
 */
-(void)removeStatus:(KCStatus *)status;
/**
 *  修改微博内容
 *
 *  @param status 微博对象
 */
-(void)modifyStatus:(KCStatus *)status;
/**
 *  根据编号取得微博
 *
 *  @param Id 微博编号
 *
 *  @return 微博对象
 */
-(KCStatus *)getStatusById:(int)Id;
/**
 *  取得所有微博对象
 *
 *  @return 所有微博对象
 */
-(NSArray *)getAllStatus;
@end
</code></pre>

<p>KCStatusService.m</p>

<pre><code>//
//  KCStatusService.m
//  DataAccess
//
//  Created by Kenshin Cui on 14-3-29.
//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.
//
#import "KCStatusService.h"
#import "KCDbManager.h"
#import "KCStatus.h"
#import "KCUserService.h"
#import "KCSingleton.h"
@interface KCStatusService(){

}
@end
@implementation KCStatusService
singleton_implementation(KCStatusService)
-(void)addStatus:(KCStatus *)status{
    NSString *sql=[NSString stringWithFormat:@"INSERT INTO Status (source,createdAt,\"text\" ,user) VALUES('%@','%@','%@','%@')",status.source,status.createdAt,status.text,status.user.Id];
    [[KCDbManager sharedKCDbManager] executeNonQuery:sql];
}
-(void)removeStatus:(KCStatus *)status{
    NSString *sql=[NSString stringWithFormat:@"DELETE FROM Status WHERE Id='%@'",status.Id];
    [[KCDbManager sharedKCDbManager] executeNonQuery:sql];
}
-(void)modifyStatus:(KCStatus *)status{
    NSString *sql=[NSString stringWithFormat:@"UPDATE Status SET source='%@',createdAt='%@',\"text\"='%@' ,user='%@' WHERE Id='%@'",status.source,status.createdAt,status.text,status.user, status.Id];
    [[KCDbManager sharedKCDbManager] executeNonQuery:sql];
}
-(KCStatus *)getStatusById:(int)Id{
    KCStatus *status=[[KCStatus alloc]init];
    NSString *sql=[NSString stringWithFormat:@"SELECT Id, source,createdAt,\"text\" ,user FROM Status WHERE Id='%i'", Id];
    NSArray *rows= [[KCDbManager sharedKCDbManager] executeQuery:sql];
    if (rows&amp;&amp;rows.count&gt;0) {
        [status setValuesForKeysWithDictionary:rows[0]];
        status.user=[[KCUserService sharedKCUserService] getUserById:[(NSNumber *)rows[0][@"user"] intValue]] ;
    }
    return status;
}
-(NSArray *)getAllStatus{
    NSMutableArray *array=[NSMutableArray array];
    NSString *sql=@"SELECT Id, source,createdAt,\"text\" ,user FROM Status ORDER BY Id";
    NSArray *rows= [[KCDbManager sharedKCDbManager] executeQuery:sql];
    for (NSDictionary *dic in rows) {
        KCStatus *status=[self getStatusById:[(NSNumber *)dic[@"Id"] intValue]];
        [array addObject:status];
    }
    return array;
}
@end
</code></pre>

<p>最后，在视图控制器中调用相应的服务层进行各类数据操作，在下面的代码中分别演示了增、删、改、查四类操作。</p>

<pre><code>KCMainViewController.m
//
//  KCMainTableViewController.m
//  DataAccess
//
//  Created by Kenshin Cui on 14-3-29.
//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.
//
#import "KCMainTableViewController.h"
#import "KCDbManager.h"
#import "KCDatabaseCreator.h"
#import "KCUser.h"
#import "KCStatus.h"
#import "KCUserService.h"
#import "KCStatusService.h"
#import "KCStatusTableViewCell.h"
@interface KCMainTableViewController (){
    NSArray *_status;
    NSMutableArray *_statusCells;
}
@end
@implementation KCMainTableViewController
- (void)viewDidLoad {
    [super viewDidLoad];
    [KCDatabaseCreator initDatabase];

//    [self addUsers];
//    [self removeUser];
//    [self modifyUserInfo];

//    [self addStatus];

    [self loadStatusData];

}
-(void)addUsers{
    KCUser *user1=[KCUser userWithName:@"Binger" screenName:@"冰儿" profileImageUrl:@"binger.jpg" mbtype:@"mbtype.png" city:@"北京"];
    [[KCUserService sharedKCUserService] addUser:user1];
    KCUser *user2=[KCUser userWithName:@"Xiaona" screenName:@"小娜" profileImageUrl:@"xiaona.jpg" mbtype:@"mbtype.png" city:@"北京"];
    [[KCUserService sharedKCUserService] addUser:user2];
    KCUser *user3=[KCUser userWithName:@"Lily" screenName:@"丽丽" profileImageUrl:@"lily.jpg" mbtype:@"mbtype.png" city:@"北京"];
    [[KCUserService sharedKCUserService] addUser:user3];
    KCUser *user4=[KCUser userWithName:@"Qianmo" screenName:@"阡陌" profileImageUrl:@"qianmo.jpg" mbtype:@"mbtype.png" city:@"北京"];
    [[KCUserService sharedKCUserService] addUser:user4];
    KCUser *user5=[KCUser userWithName:@"Yanyue" screenName:@"炎月" profileImageUrl:@"yanyue.jpg" mbtype:@"mbtype.png" city:@"北京"];
    [[KCUserService sharedKCUserService] addUser:user5];
}
-(void)addStatus{
    KCStatus *status1=[KCStatus statusWithCreateAt:@"9:00" source:@"iPhone 6" text:@"一只雪猴在日本边泡温泉边玩iPhone的照片，获得了\"2014年野生动物摄影师\"大赛特等奖。一起来为猴子配个词" userId:1];
    [[KCStatusService sharedKCStatusService] addStatus:status1];
    KCStatus *status2=[KCStatus statusWithCreateAt:@"9:00" source:@"iPhone 6" text:@"一只雪猴在日本边泡温泉边玩iPhone的照片，获得了\"2014年野生动物摄影师\"大赛特等奖。一起来为猴子配个词" userId:1];
    [[KCStatusService sharedKCStatusService] addStatus:status2];
    KCStatus *status3=[KCStatus statusWithCreateAt:@"9:30" source:@"iPhone 6" text:@"【我们送iPhone6了 要求很简单】真心回馈粉丝，小编觉得现在最好的奖品就是iPhone6了。今起到12月31日，关注我们，转发微博，就有机会获iPhone6(奖品可能需要等待)！每月抽一台[鼓掌]。不费事，还是试试吧，万一中了呢" userId:2];
    [[KCStatusService sharedKCStatusService] addStatus:status3];
    KCStatus *status4=[KCStatus statusWithCreateAt:@"9:45" source:@"iPhone 6" text:@"重大新闻：蒂姆库克宣布出柜后，ISIS战士怒扔iPhone，沙特神职人员呼吁人们换回iPhone 4。[via Pan-Arabia Enquirer]" userId:3];
    [[KCStatusService sharedKCStatusService] addStatus:status4];
    KCStatus *status5=[KCStatus statusWithCreateAt:@"10:05" source:@"iPhone 6" text:@"小伙伴们，有谁知道怎么往Iphone4S里倒东西？倒入的东西又该在哪里找？用了Iphone这么长时间，还真的不知道怎么弄！有谁知道啊？谢谢！" userId:4];
    [[KCStatusService sharedKCStatusService] addStatus:status5];
    KCStatus *status6=[KCStatus statusWithCreateAt:@"10:07" source:@"iPhone 6" text:@"在音悦台iPhone客户端里发现一个悦单《Infinite 金明洙》，推荐给大家! " userId:1];
    [[KCStatusService sharedKCStatusService] addStatus:status6];
    KCStatus *status7=[KCStatus statusWithCreateAt:@"11:20" source:@"iPhone 6" text:@"如果sony吧mp3播放器产品发展下去，不贪图手头节目源的现实利益，就木有苹果的ipod，也就木有iphone。柯达类似的现实利益，不自我革命的案例也是一种巨头的宿命。" userId:2];
    [[KCStatusService sharedKCStatusService] addStatus:status7];
    KCStatus *status8=[KCStatus statusWithCreateAt:@"13:00" source:@"iPhone 6" text:@"【iPhone 7 Plus】新买的iPhone 7 Plus ，如何？够酷炫么？" userId:2];
    [[KCStatusService sharedKCStatusService] addStatus:status8];
    KCStatus *status9=[KCStatus statusWithCreateAt:@"13:24" source:@"iPhone 6" text:@"自拍神器#卡西欧TR500#，tr350S～价格美丽，行货，全国联保～iPhone6 iPhone6Plus卡西欧TR150 TR200 TR350 TR350S全面到货 招收各种代理！[给力]微信：39017366" userId:3];
    [[KCStatusService sharedKCStatusService] addStatus:status9];
    KCStatus *status10=[KCStatus statusWithCreateAt:@"13:26" source:@"iPhone 6" text:@"猜到猴哥玩手机时所思所想者，再奖iPhone一部。（奖品由“2014年野生动物摄影师”评委会颁发）" userId:3];
    [[KCStatusService sharedKCStatusService] addStatus:status10];
}
-(void)removeUser{
    //注意在SQLite中区分大小写
    [[KCUserService sharedKCUserService] removeUserByName:@"Yanyue"];
}
-(void)modifyUserInfo{
    KCUser *user1= [[KCUserService sharedKCUserService]getUserByName:@"Xiaona"];
    user1.city=@"上海";
    [[KCUserService sharedKCUserService] modifyUser:user1];

    KCUser *user2= [[KCUserService sharedKCUserService]getUserByName:@"Lily"];
    user2.city=@"深圳";
    [[KCUserService sharedKCUserService] modifyUser:user2];
}
#pragma mark 加载数据
-(void)loadStatusData{
    _statusCells=[[NSMutableArray alloc]init];
    _status=[[KCStatusService sharedKCStatusService]getAllStatus];
    [_status enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {
        KCStatusTableViewCell *cell=[[KCStatusTableViewCell alloc]init];
        cell.status=(KCStatus *)obj;
        [_statusCells addObject:cell];
    }];
    NSLog(@"%@",[_status lastObject]);
}
#pragma mark - Table view data source
- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView {
    return 1;
}
- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section {
    return _status.count;
}
- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {
    static NSString *identtityKey=@"myTableViewCellIdentityKey1";
    KCStatusTableViewCell *cell=[self.tableView dequeueReusableCellWithIdentifier:identtityKey];
    if(cell==nil){
        cell=[[KCStatusTableViewCell alloc]initWithStyle:UITableViewCellStyleValue1 reuseIdentifier:identtityKey];
    }
    cell.status=_status[indexPath.row];
    return cell;
}
-(CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath{
    return ((KCStatusTableViewCell *)_statusCells[indexPath.row]).height;
}
-(CGFloat)tableView:(UITableView *)tableView heightForHeaderInSection:(NSInteger)section{
    return 20.0f;
}
@end
</code></pre>

<p>项目目录结构：</p>

<p><img src="http://al1020119.github.io/images/CSR002.jpg" title="Caption" ></p>

<p>运行效果</p>

<p><img src="http://al1020119.github.io/images/CSR003.jpg" title="Caption" >
Core Data</p>

<p>基本概念</p>

<p>当前，各类应用开发中只要牵扯到数据库操作通常都会用到一个概念“对象关系映射（ORM）”。例如在Java平台使用Hibernate，在.NET平台使用Entity Framework、Linq、NHibernate等。在iOS中也不例外，iOS中ORM框架首选Core Data，这是官方推荐的，不需要借助第三方框架。无论是哪种平台、哪种技术，ORM框架的作用都是相同的，那就是将关系数据库中的表（准确的说是实体）转换为程序中的对象，其本质还是对数据库的操作（例如Core Data中如果存储类型配置为SQLite则本质还是操作的SQLite数据库）。细心的朋友应该已经注意到，在上面的SQLite中其实我们在KCMainViewController中进行的数据库操作已经转换为了对象操作，服务层中的方法中已经将对数据库的操作封装起来，转换为了对Model的操作，这种方式已经是面向对象的。上述通过将对象映射到实体的过程完全是手动完成的，相对来说操作比较复杂，就拿对KCStatus对象的操作来说：首先要手动创建数据库（Status表），其次手动创建模型KCStatus，接着创建服务层KCStatusService。Core Data正是为了解决这个问题而产生的，它将数据库的创建、表的创建、对象和表的转换等操作封装起来，简化了我们的操作（注意Core Data只是将对象关系的映射简化了，并不是把服务层替代了，这一点大家需要明白）。</p>

<p>使用Core Data进行数据库存取并不需要手动创建数据库，这个过程完全由Core Data框架完成，开发人员面对的是模型，主要的工作就是把模型创建起来，具体数据库如何创建则不用管。在iOS项目中添加“Data Model”文件。然后在其中创建实体和关系：</p>

<p><img src="http://al1020119.github.io/images/CSR004.jpg" title="Caption" >
<img src="http://al1020119.github.io/images/CSR005.jpg" title="Caption" ></p>

<p>模型创建的过程中需要注意：</p>

<p>1.实体对象不需要创建ID主键，Attributes中应该是有意义属性（创建过程中应该考虑对象的属性而不是数据库中表有几个字段，尽管多数属性会对应表的字段）。</p>

<p>2.所有的属性应该指定具体类型（尽管在SQLite中可以不指定），因为实体对象会对应生成ObjC模型类。</p>

<p>3.实体对象中其他实体对象类型的属性应该通过Relationships建立，并且注意实体之间的对应关系（例如一个用户有多条微博，而一条微博则只属于一个用户,用户和微博形成一对多的关系）。</p>

<p>以上模型创建后，接下来就是根据上面的模型文件（.xcdatamodeld文件）生成具体的实体类。在Xcode中添加“NSManagedObject Subclass”文件，按照步骤选择创建的模型及实体，Xcode就会根据所创建模型生成具体的实体类。</p>

<p>User.h</p>

<pre><code>//
//  User.h
//  CoreData
//
//  Created by Kenshin Cui on 14/03/27.
//  Copyright (c) 2014年 cmjstudio. All rights reserved.
//
#import &lt;Foundation/Foundation.h&gt;
#import &lt;CoreData/CoreData.h&gt;
@class Status;
@interface User : NSManagedObject
@property (nonatomic, retain) NSString * city;
@property (nonatomic, retain) NSString * mbtype;
@property (nonatomic, retain) NSString * name;
@property (nonatomic, retain) NSString * profileImageUrl;
@property (nonatomic, retain) NSString * screenName;
@property (nonatomic, retain) NSSet *statuses;
@end
@interface User (CoreDataGeneratedAccessors)
- (void)addStatusesObject:(Status *)value;
- (void)removeStatusesObject:(Status *)value;
- (void)addStatuses:(NSSet *)values;
- (void)removeStatuses:(NSSet *)values;
@end
</code></pre>

<p>User.m</p>

<pre><code>//
//  User.m
//  CoreData
//
//  Created by Kenshin Cui on 14/03/27.
//  Copyright (c) 2014年 cmjstudio. All rights reserved.
//
#import "User.h"
#import "Status.h"
@implementation User
@dynamic city;
@dynamic mbtype;
@dynamic name;
@dynamic profileImageUrl;
@dynamic screenName;
@dynamic statuses;
@end
</code></pre>

<p>Status.h</p>

<pre><code>//
//  Status.h
//  CoreData
//
//  Created by Kenshin Cui on 14/03/27.
//  Copyright (c) 2014年 cmjstudio. All rights reserved.
//
#import &lt;Foundation/Foundation.h&gt;
#import &lt;CoreData/CoreData.h&gt;
@interface Status : NSManagedObject
@property (nonatomic, retain) NSDate * createdAt;
@property (nonatomic, retain) NSString * source;
@property (nonatomic, retain) NSString * text;
@property (nonatomic, retain) NSManagedObject *user;
@end

Status.m


//
//  Status.m
//  CoreData
//
//  Created by Kenshin Cui on 14/03/27.
//  Copyright (c) 2014年 cmjstudio. All rights reserved.
//
#import "Status.h"
@implementation Status
@dynamic createdAt;
@dynamic source;
@dynamic text;
@dynamic user;
@end
</code></pre>

<p>很显然，通过模型生成类的过程相当简单，通常这些类也不需要手动维护，如果模型发生的变化只要重新生成即可。有几点需要注意：</p>

<p>1.所有的实体类型都继承于NSManagedObject，每个NSManagedObject对象对应着数据库中一条记录。</p>

<p>2.集合属性（例如User中的status）生成了访问此属性的分类方法。</p>

<p>3.使用@dynamic代表具体属性实现，具体实现细节不需要开发人员关心。</p>

<p>当然，了解了这些还不足以完成数据的操作。究竟Core Data具体的设计如何，要完成数据的存取我们还需要了解一下Core Data几个核心的类。</p>

<p><img src="http://al1020119.github.io/images/CSR006.jpg" title="Caption" ></p>

<ol>
<li><p>Persistent Object Store：可以理解为存储持久对象的数据库（例如SQLite，注意Core Data也支持其他类型的数据存储，例如xml、二进制数据等）。</p></li>
<li><p>Managed Object Model：对象模型，对应Xcode中创建的模型文件。</p></li>
<li><p>Persistent Store Coordinator：对象模型和实体类之间的转换协调器，用于管理不同存储对象的上下文。</p></li>
<li><p>Managed Object Context:对象管理上下文，负责实体对象和数据库之间的交互。</p></li>
</ol>


<p>Core Data使用</p>

<p>Core Data使用起来相对直接使用SQLite3的API而言更加的面向对象，操作过程通常分为以下几个步骤：</p>

<p>1.创建管理上下文</p>

<p>创建管理上下可以细分为：加载模型文件->指定数据存储路径->创建对应数据类型的存储->创建管理对象上下方并指定存储。</p>

<p>经过这几个步骤之后可以得到管理对象上下文NSManagedObjectContext，以后所有的数据操作都由此对象负责。同时如果是第一次创建上下文，Core Data会自动创建存储文件（例如这里使用SQLite3存储），并且根据模型对象创建对应的表结构。下图为第一次运行生成的数据库及相关映射文件：</p>

<p><img src="http://al1020119.github.io/images/CSR007.jpg" title="Caption" ></p>

<p>为了方便后面使用，NSManagedObjectContext对象可以作为单例或静态属性来保存，下面是创建的管理对象上下文的主要代码：</p>

<pre><code>-(NSManagedObjectContext *)createDbContext{
    NSManagedObjectContext *context;
    //打开模型文件，参数为nil则打开包中所有模型文件并合并成一个
    NSManagedObjectModel *model=[NSManagedObjectModel mergedModelFromBundles:nil];
    //创建解析器
    NSPersistentStoreCoordinator *storeCoordinator=[[NSPersistentStoreCoordinator alloc]initWithManagedObjectModel:model];
    //创建数据库保存路径
    NSString *dir=[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject];
    NSLog(@"%@",dir);
    NSString *path=[dir stringByAppendingPathComponent:@"myDatabase.db"];
    NSURL *url=[NSURL fileURLWithPath:path];
    //添加SQLite持久存储到解析器
    NSError *error;
    [storeCoordinator addPersistentStoreWithType:NSSQLiteStoreType configuration:nil URL:url options:nil error:&amp;error];
    if(error){
        NSLog(@"数据库打开失败！错误:%@",error.localizedDescription);
    }else{
        context=[[NSManagedObjectContext alloc]init];
        context.persistentStoreCoordinator=storeCoordinator;
        NSLog(@"数据库打开成功！");
    }
    return context;
}
</code></pre>

<p>2.查询数据</p>

<p>对于有条件的查询，在Core Data中是通过谓词来实现的。首先创建一个请求，然后设置请求条件，最后调用上下文执行请求的方法。</p>

<pre><code>-(void)addUserWithName:(NSString *)name screenName:(NSString *)screenName profileImageUrl:(NSString *)profileImageUrl mbtype:(NSString *)mbtype city:(NSString *)city{
    //添加一个对象
    User *us= [NSEntityDescription insertNewObjectForEntityForName:@"User" inManagedObjectContext:self.context];
    us.name=name;
    us.screenName=screenName;
    us.profileImageUrl=profileImageUrl;
    us.mbtype=mbtype;
    us.city=city;
    NSError *error;
    //保存上下文
    if (![self.context save:&amp;error]) {
        NSLog(@"添加过程中发生错误,错误信息：%@！",error.localizedDescription);
    }
}
</code></pre>

<p>如果有多个条件，只要使用谓词组合即可，那么对于关联对象条件怎么查询呢？这里分为两种情况进行介绍：</p>

<p>a.查找一个对象只有唯一一个关联对象的情况，例如查找用户名为“Binger”的微博（一个微博只能属于一个用户），通过keypath查询</p>

<pre><code>-(NSArray *)getStatusesByUserName:(NSString *)name{
    NSFetchRequest *request=[NSFetchRequest fetchRequestWithEntityName:@"Status"];
    request.predicate=[NSPredicate predicateWithFormat:@"user.name=%@",name];
    NSArray *array=[self.context executeFetchRequest:request error:nil];
    return  array;
}
</code></pre>

<p>此时如果跟踪Core Data生成的SQL语句会发现其实就是把Status表和User表进行了关联查询（JOIN连接）。</p>

<p>b.查找一个对象有多个关联对象的情况，例如查找发送微博内容中包含“Watch”并且用户昵称为“小娜”的用户（一个用户有多条微博），此时可以充分利用谓词进行过滤。</p>

<pre><code>-(NSArray *)getUsersByStatusText:(NSString *)text screenName:(NSString *)screenName{
    NSFetchRequest *request=[NSFetchRequest fetchRequestWithEntityName:@"Status"];
    request.predicate=[NSPredicate predicateWithFormat:@"text LIKE '*Watch*'",text];
    NSArray *statuses=[self.context executeFetchRequest:request error:nil];

    NSPredicate *userPredicate= [NSPredicate predicateWithFormat:@"user.screenName=%@",screenName];
    NSArray *users= [statuses filteredArrayUsingPredicate:userPredicate];
    return users;
}
</code></pre>

<p>注意：如果单纯查找微博中包含“Watch”的用户，直接查出对应的微博，然后通过每个微博的user属性即可获得用户，此时就不用使用额外的谓词过滤条件。</p>

<p>3.插入数据</p>

<p>插入数据需要调用实体描述对象NSEntityDescription返回一个实体对象，然后设置对象属性，最后保存当前上下文即可。这里需要注意，增、删、改操作完最后必须调用管理对象上下文的保存方法，否则操作不会执行。</p>

<pre><code>-(void)addUserWithName:(NSString *)name screenName:(NSString *)screenName profileImageUrl:(NSString *)profileImageUrl mbtype:(NSString *)mbtype city:(NSString *)city{
    //添加一个对象
    User *us= [NSEntityDescription insertNewObjectForEntityForName:@"User" inManagedObjectContext:self.context];
    us.name=name;
    us.screenName=screenName;
    us.profileImageUrl=profileImageUrl;
    us.mbtype=mbtype;
    us.city=city;
    NSError *error;
    //保存上下文
    if (![self.context save:&amp;error]) {
        NSLog(@"添加过程中发生错误,错误信息：%@！",error.localizedDescription);
    }
}
</code></pre>

<p>4.删除数据</p>

<p>删除数据可以直接调用管理对象上下文的deleteObject方法，删除完保存上下文即可。注意，删除数据前必须先查询到对应对象。</p>

<pre><code>-(void)removeUser:(User *)user{
    [self.context deleteObject:user];
    NSError *error;
    if (![self.context save:&amp;error]) {
        NSLog(@"删除过程中发生错误，错误信息：%@!",error.localizedDescription);
    }
}
</code></pre>

<p>5.修改数据</p>

<p>修改数据首先也是取出对应的实体对象，然后通过修改对象的属性，最后保存上下文。</p>

<pre><code>-(void)modifyUserWithName:(NSString *)name screenName:(NSString *)screenName profileImageUrl:(NSString *)profileImageUrl mbtype:(NSString *)mbtype city:(NSString *)city{
    User *us=[self getUserByName:name];
    us.screenName=screenName;
    us.profileImageUrl=profileImageUrl;
    us.mbtype=mbtype;
    us.city=city;
    NSError *error;
    if (![self.context save:&amp;error]) {
        NSLog(@"修改过程中发生错误,错误信息：%@",error.localizedDescription);
    }
}
</code></pre>

<p>调试</p>

<p>虽然Core Data（如果使用SQLite数据库）操作最终转换为SQL操作，但是调试起来却不想操作SQL那么方便。特别是对于初学者而言经常出现查询报错的问题，如果能看到最终生成的SQL语句自然对于调试很有帮助。事实上在Xcode中是支持Core Data调试的，具体操作：Product-Scheme-Edit Scheme-Run-Arguments中依次添加两个参数（注意参数顺序不能错）：-com.apple.CoreData.SQLDebug、1。然后在运行程序过程中如果操作了数据库就会将SQL语句打印在输出面板。</p>

<p><img src="http://al1020119.github.io/images/CSR008.jpg" title="Caption" ></p>

<p>注意：如果模型发生了变化，此时可以重新生成实体类文件，但是所生成的数据库并不会自动更新，这时需要考虑重新生成数据库并迁移原有的数据。</p>

<p>FMDB</p>

<p>基本使用</p>

<p>相比于SQLite3来说Core Data存在着诸多优势，它面向对象，开发人员不必过多的关心更多数据库操作知识，同时它基于ObjC操作，书写更加优雅等。但是它本身也存在着一定的限制，例如如果考虑到跨平台，则只能选择SQLite，因为无论是iOS还是Android都可以使用同一个数据库，降低了开发成本和维护成本。其次是当前多数ORM框架都存在的性能问题，因为ORM最终转化为SQL操作，其中牵扯到模型数据转化，其性能自然比不上直接使用SQL操作数据库。那么有没有更好的选择呢？答案就是对SQLite进行封装。</p>

<p>其实通过前面对于SQLite的分析，大家应该已经看到KCDbManager就是对于SQLite封装的结果，开发人员面对的只有SQL和ObjC方法，不用过多libsqlite3的C语言API。但它毕竟只是一个简单的封装，还有更多的细节没有考虑，例如如何处理并发安全性，如何更好的处理事务等。因此，这里推荐使用第三方框架FMDB，整个框架非常轻量级但又不失灵活性，也是很多企业开发的首选。</p>

<p>1.FMDB既然是对于libsqlite3框架的封装，自然使用起来也是类似的，使用前也要打开一个数据库，这个数据库文件存在则直接打开否则会创建并打开。这里FMDB引入了一个MFDatabase对象来表示数据库，打开数据库和后面的数据库操作全部依赖此对象。下面是打开数据库获得MFDatabase对象的代码：</p>

<pre><code>-(void)openDb:(NSString *)dbname{
    //取得数据库保存路径，通常保存沙盒Documents目录
    NSString *directory=[NSSearchPathForDirectoriesInDomains(NSDocumentationDirectory, NSUserDomainMask, YES) firstObject];
    NSLog(@"%@",directory);
    NSString *filePath=[directory stringByAppendingPathComponent:dbname];
    //创建FMDatabase对象
    self.database=[FMDatabase databaseWithPath:filePath];
    //打开数据上
    if ([self.database open]) {
        NSLog(@"数据库打开成功!");
    }else{
        NSLog(@"数据库打开失败!");
    }
}
</code></pre>

<p>注意：dataWithPath中的路径参数一般会选择保存到沙箱中的Documents目录中；如果这个参数设置为nil则数据库会在内存中创建；如果设置为@””则会在沙箱中的临时目录创建,应用程序关闭则文件删除。</p>

<p>2.对于数据库的操作跟前面KCDbManager的封装是类似的，在FMDB中FMDatabase类提供了两个方法executeUpdate:和executeQuery:分别用于执行无返回结果的查询和有返回结果的查询。当然这两个方法有很多的重载这里就不详细解释了。唯一需要指出的是，如果调用有格式化参数的sql语句时，格式化符号使用“?”而不是“%@”、等。下面是两种情况的代码片段：</p>

<p>a.无返回结果</p>

<p>-(void)executeNonQuery:(NSString *)sql{
    //执行更新sql语句，用于插入、修改、删除
    if (![self.database executeUpdate:sql]) {
        NSLog(@&ldquo;执行SQL语句过程中发生错误！&rdquo;);
    }
}</p>

<p>b.有返回结果</p>

<p>-(NSArray <em>)executeQuery:(NSString </em>)sql{
    NSMutableArray <em>array=[NSMutableArray array];
    //执行查询sql语句
    FMResultSet </em>result= [self.database executeQuery:sql];
    while (result.next) {
        NSMutableDictionary *dic=[NSMutableDictionary dictionary];
        for (int i=0; i&lt;result.columnCount; ++i) {
            dic[[result columnNameForIndex:i]]=[result stringForColumnIndex:i];
        }
        [array addObject:dic];
    }
    return array;
}</p>

<p>对于有返回结果的查询而言，查询完返回一个游标FMResultSet，通过遍历游标进行查询。而且FMDB中提供了大量intForColumn、stringForColumn等方法进行取值。</p>

<p>并发和事务</p>

<p>我们知道直接使用libsqlite3进行数据库操作其实是线程不安全的，如果遇到多个线程同时操作一个表的时候可能会发生意想不到的结果。为了解决这个问题建议在多线程中使用FMDatabaseQueue对象，相比FMDatabase而言，它是线程安全的。</p>

<p>创建FMDatabaseQueue的方法是类似的，调用databaseQueueWithPath:方法即可。注意这里不需要调用打开操作。</p>

<pre><code>-(void)openDb:(NSString *)dbname{
    //取得数据库保存路径，通常保存沙盒Documents目录
    NSString *directory=[NSSearchPathForDirectoriesInDomains(NSDocumentationDirectory, NSUserDomainMask, YES) firstObject];
    NSLog(@"%@",directory);
    NSString *filePath=[directory stringByAppendingPathComponent:dbname];
    //创建FMDatabaseQueue对象
    self.database=[FMDatabaseQueue databaseQueueWithPath:filePath];
}
</code></pre>

<p>然后所有的增删改查操作调用FMDatabaseQueue的inDatabase:方法在block中执行操作sql语句即可。</p>

<pre><code>-(void)executeNonQuery:(NSString *)sql{
    //执行更新sql语句，用于插入、修改、删除
    [self.database inDatabase:^(FMDatabase *db) {
        [db executeQuery:sql];
    }];
}
-(NSArray *)executeQuery:(NSString *)sql{
    NSMutableArray *array=[NSMutableArray array];
    [self.database inDatabase:^(FMDatabase *db) {
        //执行查询sql语句
        FMResultSet *result= [db executeQuery:sql];
        while (result.next) {
            NSMutableDictionary *dic=[NSMutableDictionary dictionary];
            for (int i=0; i&lt;result.columnCount; ++i) {
                dic[[result columnNameForIndex:i]]=[result stringForColumnIndex:i];
            }
            [array addObject:dic];
        }
    }];
    return array;
}
</code></pre>

<p>之所以将事务放到FMDB中去说并不是因为只有FMDB才支持事务，而是因为FMDB将其封装成了几个方法来调用，不用自己写对应的sql而已。其实在在使用libsqlite3操作数据库时也是原生支持事务的（因为这里的事务是基于数据库的，FMDB还是使用的SQLite数据库），只要在执行sql语句前加上“begin transaction;”执行完之后执行“commit transaction;”或者“rollback transaction;”进行提交或回滚即可。另外在Core Data中大家也可以发现，所有的增、删、改操作之后必须调用上下文的保存方法，其实本身就提供了事务的支持，只要不调用保存方法，之前所有的操作是不会提交的。在FMDB中FMDatabase有beginTransaction、commit、rollback三个方法进行开启事务、提交事务和回滚事务。</p>

<p>总结：</p>

<p>core data</p>

<p>core data 基于model-view-controller（mvc）模式下，为创建分解的cocoa应用程序提供了一个灵活和强大的数据模型框架。</p>

<p>core data可以使你以图形界面的方式快速的定义app的数据模型，同时在你的代码中容易获取到它。core data提供了基础结构去处理常用的功能，例如保存，恢复，撤销和重做，允许你在app中继续创建新的任务。在使用core data的时候，你不用安装额外的数据库系统，因为core data使用内置的sqlite数据库。</p>

<p>core data提供了一个通用的数据管理解决方案来处理那些所有需要数据模型的app(或大或小)。app使用core data来管理数据对象是很多的益处。</p>

<p>苹果的图形用户界面编译器-interface builder（IB），提供了对core data controller对象的预构建，从而来减少app的用户界面和它的数据模型之间的粘滞代码。在使用core data的时候你不需要考虑sql的语法问题，也不需要管理相关的逻辑树去追踪用户的行为，更不用建立新的永久机制。当你写你app的用户界面到它的 core data模型的时候，它已经为你把所有的东西都做好了。</p>

<p>core data将你app的模型层放入到一组定义在内存中的数据对象。core data会追踪这些对象的改变，同时可以根据需要做相反的改变，例如用户执行撤销命令。当core data在对你app数据的改变进行保存的时候，core data会把这些数据归档，并永久性保存。它保存的数据在一些常规的文件，你可以在Finder中可以进行管理，用spotlight进行搜索，备份到 cd，和email给朋友或者家人。</p>

<p>在使用core data框架的时候，你可以创建一个管理对象的模型，该模型提供了对模型对象的抽象定义，这也就是我们所知道的entities，它可以在我们的程序中使用。</p>

<p>core data是一个实体-关系模型，该模型是使用Xcode的数据模型设计工具来定义的，对数据实体以及他们的关系提供了丰富的环境。</p>

<p>sqlite</p>

<p>mac os x中sqlite库，它是一个轻量级功能强大的关系数据引擎，也很容易嵌入到应用程序。可以在多个平台使用，sqlite是一个轻量级的嵌入式sql数据库编程。与core data框架不同的是，sqlite是使用程序式的，sql的主要的API来直接操作数据表。</p>

<p>fmdb
FMDB框架其实只是一层很薄的封装，主要的类也就两个：FMDatabase和FMResultSet。在使用fmdb的时候还需要导入libsqlite3.0.dylib。</p>

<p>core data允许用户使用代表实体和实体间关系的高层对象来操作数据。它也可以管理串行化的数据，提供对象生存期管理与object_graph 管理，包括存储。Core Data直接与Sqlite交互，避免开发者使用原本的SQL语句.</p>

<p>上面的三种，都是在什么情况下使用呢？
在编写程序的时候尽量使用core data，这样才是最优的选择。
至于sqlite和fmdb的使用情况，这个看个人喜好了，个人觉得没什么标准。fmdb就是对sqlite的封装，使用起来有方便的接口，没那么麻烦而已。</p>

<pre><code>Q Q：2211523682/790806573

微信：18370997821/13148454507

微博WB:http://weibo.com/u/3288975567?is_hot=1

git博文：http://al1020119.github.io/

github：https://github.com/al1020119
</code></pre>

<p><img src="http://al1020119.github.io/images/iCocosCoder.jpg" title="Caption" ></p>

<p><img src="http://al1020119.github.io/images/iCocosPublic.jpg" title="Caption" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CoreData 大战 SQLite]]></title>
    <link href="http://al1020119.github.io/blog/2016/07/05/xsqlyucoredata/"/>
    <updated>2016-07-05T14:59:42+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/07/05/xsqlyucoredata</id>
    <content type="html"><![CDATA[<p>凭良心讲，我不能告诉你不去使用Core Data。它不错，而且也在变好，并且它被很多其他Cocoa开发者所理解，当有新人加入你的组或者需要别人接手你的项目的时候，这点很重要。</p>

<p>更重要的是，不值得花时间和精力去写自己的系统去代替它。真的，使用Core Data吧。</p>

<p>为什么我不使用Core Data<br/>
 Mike Ash写到：就我自己而言，我不是个狂热粉丝。我发现API是笨拙的，并且框架本身对于大量的数据是极其缓慢的。</p>

<p>一个实际的例子：10,000条目
想象一个RSS阅读器，一个用户可以在一个feed上点击右键，并且选择标记所有为已读。</p>

<!--more-->


<p>引擎下，有一个带有read属性的Article实体。把所有条目标记为已读，程序需要加载这个feed的所有文章(可能通过一对多的关系)，然后设置read属性为YES。</p>

<p>大部分情况下这样没关系。但是设想那个feed里有200个文章，为了避免阻塞主线程，你可能考虑在后台线程里做这个工作(特别当你的程序是一个iPhone应用)。当你一开始使用Core Data多线程，事情就开始变的不好处理了。</p>

<p>这可能还凑合，至少不值得切换走Core Data。</p>

<p>但是接下来加同步。</p>

<p>我用过两种不同的获取已读文章ID列表的RSS同步接口。其中一个返回近10,000个ID。</p>

<p>你不会打算在主线程中加载10,000个文章，然后设置read为NO。你甚至不想在后台线程里加载10,000个文章，即使很小心的管理内存，这有太多的工作（如果你频繁的这么做，想一下对电池寿命的影响）。</p>

<p>你真正想要做的是，让数据库给在ID列表里的每一个文章设置read为YES。</p>

<p>SQLite可以做到这个，只用一次调用。假设uniqueID上有索引，这会很快。而且你可以在后台线程执行像在主线程执行一样容易。</p>

<p>另一个例子：快速启动
我想减少我的另一个程序的启动时间，不只是开始的时间，而是在数据显示之前的所有时间。</p>

<p>那是个类似Twitter的应用(虽然它不是)，它显示消息的时间轴。显示时间轴意味着获取消息，加载相关用户。它很快，但是在启动的时候，会填充UI，然后填充数据。</p>

<p>关于iPhone的应用（或者所有应用）我的理论是，启动时间很重要，比其他大部分开发者想的都要重要。应用的启动很慢看起来不像是要启动一样，因为人们潜意识里记得，并且会产生阻止启动应用的想法。减少启动时间就减少了摩擦，让用户更有可能继续使用你的应用，并且推荐给其他人。这是你让你的应用成功的一部分。</p>

<p>因为我不使用Core Data，我手边有一个简单的，保守的解决方案。我把timeline（消息和人物对象）通过NSCoding保存到一个plist文件中。启动的时候它读这个文件，创建消息和人物对象，UI一出现就显示时间轴。</p>

<p>这明显的减少了延迟。</p>

<p>把消息和人物对象作为NSManagedObject的实例对象，这是不可能的。（假设我有编码的并且存储的IDs对象，但是那意味着读plist然后触及数据库。这种方式我完全避免了数据库）。</p>

<p>在更新更快的机器出来后, 我去掉了那些代码。回顾过去，我希望我可以把它留下来。</p>

<p>我怎么考虑这个问题
当考虑是否使用Core Data时，我考虑下面这些事情：</p>

<p>会有难以置信数量的数据吗？
对于一个RSS阅读器或者Twitter应用，答案显而易见：是的。有些人关注上百个人。一个人可能订阅了上千个feeds。</p>

<p>即使你的应用不从网络获取数据，仍然有可能让用户自动添加数据。如果你用一个支持AppleScript的Mac，有些人会写脚本去加载非常多的数据。如果通过web API去加数据也是一样的。</p>

<p>会有一个Web API包含类似于数据库的终端吗（对比类对象终端）？
一个RSS同步API能够返回一个已读文章的uniquelIDs列表。一个记笔记的应用的一个同步API可能返回已存档的和已删除的笔记的uniquelIDs。</p>

<p>用户可能通过操作处理大量对象吗？
在底层，需要考虑和之前一样的问题。当有人删除所有下载的5，000个面食食谱，你的食谱应用可以多好的完成这个功能（在iPhone上？）？</p>

<p>当我决定使用Core Data（我已经发布过使用Core Data的应用），我会小心留意我怎么使用它。为了得到好的性能，我发现我把它当做一个SQL数据库的一个奇怪接口来使用，然后我知道我应该舍弃Core Data，直接使用SQLite。</p>

<p>我怎么使用SQLite
我通过FMDB Wrapper来使用SQLite，FMDB来自Flying Meat Software，由Gus Mueller提供。</p>

<p>基本操作
我在iPhone以前，Core Data以前就使用过SQLite。这是它怎么工作的的要点：</p>

<ol>
<li>所有数据库访问-读和写-发生在连续的队列里，在一个后台线程。在主线程中触及数据库是从来不被允许的。使用一个连续队列来保证每一件事是按顺序发生的。</li>
<li>我大量使用blocks来让异步程序容易点。</li>
<li>模型对象只存在在主线程（但有两个重要的例外），改变会触发一个后台保存。</li>
<li>模型对象列出来他们在数据库中存储的属性。可能在代码里或者在plist文件里。
5, 一些模型对象是唯一的，一些不是。取决于应用的需要（大部分情况是唯一的）。</li>
<li>对关系型数据，我尽可能避免连表查询。</li>
<li>一些对象类型在启动的时候就完全读入内存，另一些对象类型可能只需要创建并维护一个他们的uniqueIDs的。NSMutableSet，所以不需要去触及数据库，我就知道已经有什么。</li>
<li>Web API的调用发生在后台线程，他们使用分开的模型对象。
我会通过我现在的应用的代码来详细描述。</li>
</ol>


<p>数据库更新
在我最近的应用中，有一个单一的数据库控制器-VSDatabaseController，它通过FMDB来与SQLite对话。</p>

<p>FMDB区分更新和查询。更新数据库，app调用：</p>

<pre><code>-[VSDatabaseController runDatabaseBlockInTransaction:(VSDatabaseUpdateBlock)databaseBlock] 
</code></pre>

<p>VSDatabaseUpdateBlock很简单：</p>

<pre><code>typedef void (^VSDatabaseUpdateBlock)(FMDatabase *database); 
</code></pre>

<p>runDatabaseBlockInTransaction也很简单：</p>

<pre><code>- (void)runDatabaseBlockInTransaction:(VSDatabaseUpdateBlock)databaseBlock { 
    dispatch_async(self.serialDispatchQueue, ^{ 
        @autoreleasepool { 
            [self beginTransaction]; 
            databaseBlock(self.database); 
            [self endTransaction]; 
        } 
    }); 
} 
</code></pre>

<p>（注意我用自己的连续调度队列。Gus建议看一下FMDatabaseQueue，也是一个连续调度队列。我还没能去看一下，因为它比FMDB的其他东西都要新。）</p>

<p>beginTransaction和endTransaction的调用是可嵌套的（在我的数据库控制器里）。在合适的时候他们会调用-[FMDatabase beginTransaction] 和 -[FMDatabase commit]。（使用事务是让SQLite变快的关键。）提示：我把当前事务存储在-[NSThread threadDictionary]。它很好获取每一个线程的数据，我几乎从不用其他的。</p>

<p>这儿有个调用更新数据库的简单例子：</p>

<pre><code>- (void)emptyTagsLookupTableForNote:(VSNote *)note { 
    NSString *uniqueID = note.uniqueID; 
    [self runDatabaseBlockInTransaction:^(FMDatabase *database) { 
        [database executeUpdate: 
            @"delete from tagsNotesLookup where noteUniqueID = ?;", uniqueID]; 
    }]; 
} 
</code></pre>

<p>这说明一些事情。首先SQL不可怕。即使你从没见过它，你也知道这行代码做了什么。</p>

<p>像VSDatabaseController的所有其他公共接口，emptyTagsLookupTableForNote应该在主线程中被调用。模型对象只能在主线程中被引用，所以在block中用uniqueID，而不是VSNote对象。</p>

<p>注意在这种情况下，我更新了一个查找表。Notes和tags是多对多关系，一种表现方式是用一个数据库表映射note uniqueIDs和tag uniqueIDs。这些表不会很难维护，但是如果可能，我确实尝试避免他们的使用。</p>

<p>注意在更新字符串中的?。-[FMDatabase executeUpdate:] 是一个可变参数函数。SQLite支持使用占位符?，所以你不需要把正真的值放入字符串。这儿有一个安全问题：它帮助守护程序反对SQL插入。如果你需要避开某些值，它也为你省了麻烦。</p>

<p>最后，在tagsNotesLookup表中，有一个noteUniquelID的索引（索引是SQLite性能的又一个关键）。这行代码在每次启动时都调用：</p>

<pre><code>[self.database executeUpdate: 
    @"CREATE INDEX if not exists noteUniqueIDIndex on tagsNotesLookup (noteUniqueID);"]; 
</code></pre>

<p>数据库获取
要获取对象，app调用：</p>

<pre><code>-[VSDatabaseController runFetchForClass:(Class)databaseObjectClass  
                             fetchBlock:(VSDatabaseFetchBlock)fetchBlock  
                      fetchResultsBlock:(VSDatabaseFetchResultsBlock)fetchResultsBlock]; 
</code></pre>

<p>这两行代码做了大部分工作：</p>

<pre><code>FMResultSet *resultSet = fetchBlock(self.database); 
NSArray *fetchedObjects = [self databaseObjectsWithResultSet:resultSet  
                                                       class:databaseObjectClass]; 
</code></pre>

<p>用FMDB查找数据库返回一个FMResultSet. 通过resultSet你可以逐句循环，创建模型对象。</p>

<p>我建议写通用的代码去转换数据库行到对象。一种我使用的方法是用一个plist，映射column名字到对象属性。它也包含类型，所以你知道是否需要调用 -[FMResultSet dateForColumn:]， -[FMResultSet stringForColumn:]或其他。</p>

<p>在我的最新应用里我做了些简单的事情。数据库行刚好对应模型对象属性的名字。所有属性都是strings，除了那些名字以“Date”结尾的属性。很简单，但是你可以看到需要一个清晰的对应关系。</p>

<p>唯一对象
创建模型对象和从数据库获取数据在同一个后台线程。一获取到，程序会把他们转到主线程。</p>

<p>通常我有uniqued对象。同一个数据库行结果始终对应同一个对象。</p>

<p>为了做到唯一，我创建了一个对象缓存，一个NSMapTable，在init函数里：_objectCache = [NSMapTable weakToWeakObjectsMapTable]。我来解释一下：</p>

<p>例如，当你做一个数据库获取并且把对象转交给一个视图控制器，你希望在视图控制器使用完这些对象后，或者一个不一样的视图控制器显示了，这些对象可以消失。</p>

<p>如果你的对象缓存是一个NSMutableDictionary，你将需要做一些额外的工作来清空缓存中的对象。确定它对应的对象在别的地方是否有引用就变的很痛苦。NSMapTable是弱引用，就会自动处理这个问题。</p>

<p>所以：我们在主线程中让对象唯一。如果一个对象已经在对象缓存中存在，我们就用那个存在的对象。（主线程胜出，因为它可能有新的改变。）如果对象缓存中没有，它会被加上。</p>

<p>保持对象在内存中
有很多次，把整个对象类型保留在内存中是有道理的。我最新的app有一个VSTag对象。虽然可能有成百上千个笔记，但tags的数量很小，基本少于10。一个tag只有6个属性：3个BOOL，两个很小的NSstring，还有一个NSDate。</p>

<p>启动的时候，app获取所有tags并且把他们保存在两个字典里，一个主键是tag的uniqueID，另一个主键是tag名字的小写。</p>

<p>这简化了很多事，不只是tag自动补全系统，这个可以完全在内存中操作，不需要数据库获取。</p>

<p>但是很多次，把所有数据保留在内存中是不实际的。比如我们不会在内存中保留所有笔记。</p>

<p>但是也有很多次，当不能在内存中保留对象时，你希望在内存中保留所有uniqueIDs。你会像这样做一个获取：</p>

<pre><code>FMResultSet *resultSet = [self.database executeQuery:@"select uniqueID from some_table"]; 
</code></pre>

<p>resultSet只包含了uniqueIDs， 你可以存储到一个NSMutableSet里。</p>

<p>我发现有时这个对web APIs很有用。想象一个API调用返回从某个确定的时间以后的，已创建笔记的uniqueIDs列表。如果我本地已经有了一个包含所有笔记uniqueIDs的NSMutableSet，我可以快速检查(通过 -[NSMutableSet minusSet])是否有漏掉的笔记，然后去调用另一个API下载那些漏掉的笔记。这些完全不需要触及数据库。</p>

<p>但是，像这样的事情应该小心处理。app可以提供足够的内存吗？它真的简化编程并且提高性能了吗？</p>

<p>用SQLite和FMDB而不是Core Data，给你带来大量的灵活性和聪明解决办法的空间。记住有的时候聪明是好的，也有的时候聪明是一个大错误。</p>

<p>Web APIs
我的API调用在后台进程（经常用一个NSOperationQueue，所以我可以取消操作）。模型对象只在主线程，但是我还传递模型对象给我的API调用。</p>

<p>是这样的：一个数据库对象有一个detachedCopy方法，可以复制数据库对象。这个复制对象不是引用自我用来唯一化的对象缓存。唯一引用那个对象的地方是API调用，当API调用结束，那个复制的对象就消失了。</p>

<p>这是一个好的系统，因为它意味着我可以在API调用里使用模型对象。方法看起来像这样：</p>

<pre><code>- (void)uploadNote:(VSNote *)note { 
    VSNoteAPICall *apiCall = [[VSNoteAPICall alloc] initWithNote:[note detachedCopy]]; 
    [self enqueueAPICall:apiCall]; 
} 
</code></pre>

<p>VSNoteAPICall从复制的VSNote获取值，并且创建HTTP请求，而不是一个字典或其他笔记的表现形式。</p>

<p>处理Web API返回值
我对web返回值做了一些类似的事情。我会对返回的JSON或者XML创建一个模型对象，这个模型对象也是分离的。它不是存储在为了唯一性的模型缓存里。</p>

<p>这儿有些事情是不确定的。有时有必要用那个模型对象在两个地方做本地修改：在内存缓存和数据库。</p>

<p>数据库通常是容易的部分。比如：我的应用已经有一个方法来保存笔记对象。它用一个SQL insert或者replace字符串。我只需调用那个从web API返回值生成的笔记对象，数据库就会更新。</p>

<p>但是可能那个对象有一个在内存中的版本，幸运的是我们很容易找到：</p>

<pre><code>VSNote *cachedNote = [self.mapTable objectForKey:downloadedNote.uniqueID]; 
</code></pre>

<p>如果cachedNote存在，我会让它从downloadedNote中获取值，而不是替换它（这样可能违反唯一性）。这可以共享detachedCopy方法的代码。</p>

<p>一旦cachedNote更新了，观察者会通过KVO通知笔记，或者我会发送一个NSNotification，或者两者都做。</p>

<p>Web API调用也会返回一些其他值。我提到过RSS阅读器可能获得一个已读条目的大列表。这种情况下，我用那个列表创建了一个NSSet，在内存中更新每一个缓存文章的read属性，然后调用-[FMDatabase executeUpdate:]。</p>

<p>让它工作快速的关键是NSMapTable的查找是快速的。如果你找的对象在一个NSArray里，我们该重新考虑。</p>

<p>数据库迁移
Core Data的数据库迁移很酷，当它可行的时候。但是不可避免的，它是代码和数据库中的一层。如果你越直接使用SQLite，你更新数据库越直接。你可以安全容易的做到这点。</p>

<p>比如加一个表：</p>

<pre><code>[self.database executeUpdate:@"CREATE TABLE if not exists tags " 
    "(uniqueID TEXT UNIQUE, name TEXT, deleted INTEGER, deletedModificationDate DATE);"]; 
</code></pre>

<p>或者加一个索引：</p>

<pre><code>[self.database executeUpdate:@"CREATE INDEX if not exists " 
    "archivedSortDateIndex on notes (archived, sortDate);"]; 
</code></pre>

<p>或者加一列：</p>

<pre><code>[self.database executeUpdate:@"ALTER TABLE tags ADD deletedDate DATE"]; 
</code></pre>

<p>应用应该在代码的第一个地方用上面这些代码设置数据库。以后的改变只需加executeUpdate的调用 — 我让他们按顺序执行。因为我的数据库是我设计的，不会有什么问题（我从没碰到性能问题，它很快）。</p>

<p>当然大的改变需要更多代码。如果你的数据通过web获取，有时你可以从一个新数据库模型开始，重新下载你需要的数据。</p>

<p>性能技巧
SQLite可以非常非常快，它也可以非常慢。完全取决于你怎么使用它。</p>

<p>事务
把更新包装在事务里。在更新前调用 -[FMDatabase beginTransaction] ，更新后调用-[FMDatabase commit]。</p>

<p>如果你不得不反规范化（ Denormalize）
反规范化让人很不爽。这个方法是，为了加速检索而添加冗余数据，但是它意味着你需要维护冗余数据。</p>

<p>我总是疯狂避免它，直到这样能有严重的性能区别。然后我会尽可能少得这么做。</p>

<p>使用索引
我的应用中tags表的创建语句像这样：</p>

<pre><code>CREATE TABLE if not exists tags  
  (uniqueID TEXT UNIQUE, name TEXT, deleted INTEGER, deletedModificationDate DATE); 
</code></pre>

<p>uniqueID列是自动索引的，因为它定义为unique。但是如果我想用name来查询表，我可能会在name上创建一个索引，像这样：</p>

<pre><code>CREATE INDEX if not exists tagNameIndex on tags (name); 
</code></pre>

<p>你可以一次性在多列上创建索引，像这样：</p>

<pre><code>CREATE INDEX if not exists archivedSortDateIndex on notes (archived, sortDate); 
</code></pre>

<p>但是注意太多索引会降低你的插入速度。你只需要足够数量并且是对的那些。</p>

<p>使用命令行应用
当我的app在模拟器里运行时，我会打印数据库的路径。我可以通过sqlite3的命令行来打开数据库。（通过man sqlite3命令来了解这个应用的更多信息）。</p>

<p>打开数据库的命令：sqlite3 “数据库的路径”。</p>

<p>打开以后，你可以看schema: type .schema。</p>

<p>你可以更新和查询，这是在使用你的app之前检查SQL是否正确的很好的方式。</p>

<p>这里面最酷的一部分是，SQLite Explain Query Plan命令，你会希望确保你的语句执行的尽可能快。</p>

<p>真实的例子
我的应用显示所有没有归档笔记的标签列表。每当笔记或者标签有变化，这个查询就会重新执行一次，所以它需要很快。</p>

<p>我可以用SQL join来查询，但是很慢（joins都很慢）。</p>

<p>所以我放弃sqlite3并开始尝试别的方法。我又看了一次我的schema，意识到我可以反规范化。一个笔记的归档状态可以存储在notes表里，它也可以存储在tagsNotesLookup表。</p>

<p>然后我可以执行一个查询：</p>

<pre><code>select distinct tagUniqueID from tagsNotesLookup where archived=0; 
</code></pre>

<p>我已经有了一个在tagUniqueID上的索引。所以我用explain query plan来告诉我当我执行这个查询的时候会发生什么。</p>

<pre><code>sqlite&gt; explain query plan select distinct tagUniqueID from tagsNotesLookup where archived=0; 
0|0|0|SCAN TABLE tagsNotesLookup USING INDEX tagUniqueIDIndex (~100000 rows) 
</code></pre>

<p>它用了一个索引，但是SCAN TABLE听起来不太好，最好是一个SEARCH TABLE并且覆盖一个索引。
我在tagUniqueID和archive上建了索引：</p>

<pre><code>CREATE INDEX archivedTagUniqueID on tagsNotesLookup(archived, tagUniqueID); 
</code></pre>

<p>再次执行explain query plan:</p>

<pre><code>sqlite&gt; explain query plan select distinct tagUniqueID from tagsNotesLookup where archived=0; 
0|0|0|SEARCH TABLE tagsNotesLookup USING COVERING INDEX archivedTagUniqueID (archived=?) (~10 rows) 
</code></pre>

<p>好多了。</p>

<p>更多性能提示
FMDB的某处加了缓存statements的能力，所以当创建或打开一个数据库的时候，我总是调用[self.database setShouldCacheStatements:YES] 。这意味着对每个调用你不需要再次编译每个statement。</p>

<p>我从来没有找到使用vacuum的好的指引，如果数据库没有定期压缩，它会越来越慢。我的应用会跑一个vacuum，但只是每周一次（它在NSUserDefaults里存储上次vacuum的时间，然后在开始的时候检查是否过了一周）。</p>

<p>如果能auto_vacuum那更好，看pragma statements supported by SQLite列表。</p>

<p>其他酷的东西
Gus Mueller让我涉及自定义SQLite方法的内容。我并没有真的使用这些东西，既然他指出了，我可以放心的说我能找到它的用处。因为它很酷。</p>

<p>在Gus的帖子里，有一个查询是这样的：</p>

<pre><code>select displayName, key from items where UTTypeConformsTo(uti, ?) order by 2; 
</code></pre>

<p>SQLite完全不知道UITypes。但是你可以加核心方法，查看-[FMDatabase makeFunctionNamed:maximumArguments:withBlock:]。</p>

<p>你可以执行一个大的查询来替代，然后评估每个对象。但是那需要更多工作。最好在SQL级就过滤，而不是在将表格行转为对象以后。</p>

<p>最后
你真的应该使用Core Data，我不是在开玩笑。</p>

<p>我用SQLite和FMDB一段时间了，我对多得的好处感到很兴奋，也得到非同一般的性能。但是记住机器在变快，其他看你代码的人期望看到他已经知道的Core Data, 另一些不打算看你的数据库代码。所以请把这整篇文章看做一个疯子的叫喊，关于他为自己建立的细节的疯狂的世界，并把自己锁在里面。</p>

<p>请享受了不起的Core Data的文章（有点难过的摇头）。</p>

<p>接下来，在查完Gus指出的自定义SQLite方法特性后，我会研究SQLite的full-text search extension. 总有更多的内容需要去学习。</p>

<pre><code>Q Q：2211523682/790806573

微信：18370997821/13148454507

微博WB:http://weibo.com/u/3288975567?is_hot=1

git博文：http://al1020119.github.io/

github：https://github.com/al1020119
</code></pre>

<p><img src="http://al1020119.github.io/images/iCocosCoder.jpg" title="Caption" ></p>

<p><img src="http://al1020119.github.io/images/iCocosPublic.jpg" title="Caption" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Realm 爆菊 CoreData]]></title>
    <link href="http://al1020119.github.io/blog/2016/07/05/ycoredatayurealm/"/>
    <updated>2016-07-05T04:59:42+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/07/05/ycoredatayurealm</id>
    <content type="html"><![CDATA[<p>本文具有强烈的个人感情色彩,如有观看不适,请尽快关闭。本文仅作为个人学习记录使用，也欢迎在许可协议范围内转载或使用，请尊重版权并且保留原文链接，谢谢您的理解合作。如果您觉得本站对您能有帮助，您可以使用RSS方式订阅本站，这样您将能在第一时间获取本站信息。
碎碎念</p>

<p>OhMyStar 2 也进行了一段时日，我把持久化的方式从CoreData 换到了 Realm。有些感悟，顺手就记录一下吧。以下评论都是自己很主观的感受，无实际测试数据支持。
论 iOS 的持久化</p>

<!--more-->


<p>iOS 持久化其实也没多少选择， 高端一点CoreData、Realm、FMDB、KV类(LevelDB等)。低端一些直接一个 NSArray 就写成 Plist 也能持久化下来。</p>

<p>在网络环境越来越快的当下和大部分应用数据都可能是网络应用，如果业务逻辑并不复杂，其实极端一点就只用写到 JSON 转 Object 就好了。而且一堆这样好用的封装，远有Mantle 近有YYModel。</p>

<p>所以需要持久化的时候，我觉的可以慎重的评估一下需求。想明白了，后面可以节省很多事情。</p>

<p>本文章主要对比 Realm 和 CoreData，其他的就不涉及了。</p>

<p>Realm
优点
入门门槛低</p>

<p>Realm文档就算一个字一个字扣着读完，一个下午就足够了。而且还有中文版本，不要太友好哦，有点不习惯诶。</p>

<p>文档覆盖了80%的使用情况，甚至有些太简陋的嫌疑。但不管怎么样，这种入门条件比起 CoreData 写了三个月都没搞清楚 Context 要好的多。</p>

<p>在库的工具链上，安装一个 Realm Browser 以后就不需要其他辅助了。还是简单。</p>

<p>几乎做到了上手即用的程度。五星好评。</p>

<p>PS：我用了一个通宵把 OhMyStar 2 的持久化从 CoreData 换到了 Realm ，优化调整了大概5天左右达到勉强可以用的情况 。在这之前并没有任何 Realm 的经验。
据说性能好一些</p>

<p>Realm官方介绍Fast一段中</p>

<p>Counts</p>

<p><img src="http://al1020119.github.io/images/benchmarks.001b.png" title="Caption" ></p>

<p>Queries</p>

<p><img src="http://al1020119.github.io/images/benchmarks.002b.png" title="Caption" ></p>

<p>Inserts</p>

<p><img src="http://al1020119.github.io/images/benchmarks.003b.png" title="Caption" ></p>

<p>在写这里的时候我顺手Google了一下 发现一篇Core Data, FMDB, Realm 性能测试。我就多说几句</p>

<p>总觉得大家对 CoreData 误会蛮深，代码 Fork 看了一下， 总觉得不应该这样写来比性能的，但是一时半会也不知道怎么改。我只能说我在优化 CoreData 的时候根据 WWDC 上教的还是提升很高，另外一个事情是 CoreData 一般都用 Sqlite 做后端。所以如果你的查询是经过优化的，确认打出来的SQL语句科学以后，Sqlite(CoreData) 跟 Sqlite(FMDB)我觉得性能就算有差距，这差距没有能大到选择方案的决定性因素。如果使用 CoreData 遇到性能瓶颈，你应该仔细的研究 WWDC 和几篇很好的文章。确保你的 CoreData 使用方式是正确科学的。
没有需要架构Context那种烦人的东西</p>

<p>应该也算Realm简单的一个方面，Realm 只要保持自己线程里面，自己的 Realm Store 操作是正确的即可。如果是 CoreData，怎么架构一个科学的 Context Stack 就足够让我头疼一整，iOS 还好，界面是一个接着一个(VC跟VC之间的层级关系很清晰)。而 OhMyStar 2 这种 OS X 桌面应用场景VC之间很复杂，线程之间Context的关系让出现很多问题。
支持 NSPredicate</p>

<p>从 CoreData 转过来并没有太多的不适应
很简单的使用多个存储文件</p>

<p>举个例子，多用户登陆情况下。用户是单独的存储文件，和全部用户使用同一个存储文件。后者需要每条用户数据都要关联一次当前用户，所有查询用户数据的时候，你都必须加上当前用户的查询项。而使用每个用户单独一个数据文件的时候，整个存储结构会清爽很多。
技术支持</p>

<p>至少实在没法的时候还可以去微博上吐槽他们，他们其实也有极大的热情来解决你遇到的问题。CoreData 这种遇到问题就只能自己默默的吞下。
缺点
关联关系弱的一逼</p>

<p>简单说来就是对象跟对象之间的一对多关系和多对多关系。并不能映射，需要在双方里面都写上属性，此外还需要在设置的时候两边同时设置。查询时候也是 NSPredicate 也仅仅只支持一些一层的查询，没法做出带SUBQUERY的复杂查询出来。
强制内省容错机制导致存储文件不断变大</p>

<p>Realm本身感觉有一个数据容错机制。但是这个机制在数据库文件有错误的情况自己修复的时候，会无限增大。具体我这里表现为，打开看只有3000条数据，但是文件大小已经有3GB。重现Bug也很容易，只要你在写数据库的时候,用Realm Browser查看一下，crash之后在打开就很容易出现。</p>

<p>官方文档里面有说到会造成这种情形的原因，我在尽我所能的避免问题以后。存储文件还是会有可能不那么夸张的变大一些。但是用Realm Browser查看数据是正常的。所以我觉得官方应该提供一个函数，可以删除掉那些容易的东西。保持存储文件的干净。
没有细粒化通知</p>

<p>也就是说，当我在某个地方做出修改。 我其他地方只知道Realm有修改，但是没法知道我是增加、修改还是删除了数据。不知道我更新的是那一条数据。据文档说，将来会解决这个问题，就只有拭目以待。
增加包体积</p>

<p>据官方说会增加1MB左右的包大小，如果你是一个小体积应用，或者是一个几千万用户的主流应用。对包大小敏感的话慎用。
核心代码目前闭源</p>

<p>对于在我们这样一个作恶满天飞的天朝长大的孩子来说，有些孩子对闭源这个事情还是挺在意的。不过官方说将来会开源，我还是倾向于相信 Realm 他们的人品。
CoreData</p>

<p>CoreData 相关资料相对多一些我就简单说
优点
官方支持 &amp;&amp; 亲儿子</p>

<p>系统自带，Apple支持
带图形化的Model编辑</p>

<p>对于视觉化动物来说比较友好，也可以清楚的知道自己设计的 Model 之间的关系
强大的关联关系</p>

<p>以前不觉得，用了 Realm 才发现 CoreData 的关联关系如此好用，一对多，多对多。想怎么查询就怎么查询，可以写出很复杂的查询逻辑来。
强大的查询</p>

<p>虽然可能在设置NSFetchRequest的时候感觉很多东西要弄，但是复杂也带来了强大的功能，NSFetchRequest 可以设置很多，比如限制查询数量， 限制只返回某些属性值等等。就不展开说了。
精细化的通知</p>

<p>可以知道具体插入了什么、更新了什么、删除了什么。这样在刷UI，比如一个tableview的时候，你就可以控制的很准确。
缺点
入门门槛高</p>

<pre><code>CoreData 是一个博大精深的技术，不要妄想几天之内可以用的很溜。
CoreData 是一个博大精深的技术，不要妄想几天之内可以用的很溜。
CoreData 是一个博大精深的技术，不要妄想几天之内可以用的很溜。
</code></pre>

<p>如果没有足够的时间和精力去接入 CoreData。 那选型的时候应当慎重考虑。
需要一些工具才感觉好使</p>

<p>不管是老手还是新手，使用一些第三方的封装库和工具都会大大的提高使用 CoreData 的幸福指数。</p>

<p>mogenerator 是必须必须要的。</p>

<p>MagicalRecord 无愧 CoreData 第一库，据小道消息 主要贡献者 Saul Mora 可能去了微信了。
Context</p>

<p>其实还是 CoreData 门槛高的问题，对我来说。Context之间的关系和线程之间的处理让我感到很头痛，特别是 OS X  是一大堆VC铺到屏幕上，我水平又菜，出的问题很多。
多个持久化文件很麻烦</p>

<p>不是说不可以，但是真的好麻烦。</p>

<p>有个第三方库有解决CoreData这个问题 CoreStore 但是我用着不是很顺手最后弃用.
总结</p>

<p>其实吧用啥持久化都行，具体还是需要看你的需求和方案上来说哪一个方案更加适合。</p>

<p>如果简单说来，就是 Realm 更加适合一些业务逻辑不怎么复杂的场景，团队配置要求不高，有经验的人稍微看一下午就能上手。</p>

<p>CoreData 更加适合业务逻辑复杂的情况，团队配置要求比较高，有经验的老手也需要几周甚至更长的时间才能科学的使用CoreData。</p>

<pre><code>Q Q：2211523682/790806573

微信：18370997821/13148454507

微博WB:http://weibo.com/u/3288975567?is_hot=1

git博文：http://al1020119.github.io/

github：https://github.com/al1020119
</code></pre>

<p><img src="http://al1020119.github.io/images/iCocosCoder.jpg" title="Caption" ></p>

<p><img src="http://al1020119.github.io/images/iCocosPublic.jpg" title="Caption" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MagicalRecord魔法]]></title>
    <link href="http://al1020119.github.io/blog/2016/07/04/coredatedzhuangbimegic/"/>
    <updated>2016-07-04T20:59:42+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/07/04/coredatedzhuangbimegic</id>
    <content type="html"><![CDATA[<p>正文：</p>

<p>到目前为止，已经将CoreData相关的知识点都讲完了。</p>

<p>在这篇文章中，主要讲一个CoreData第三方库-MagicalRecord。目前为止这个第三方在Github上有9500+的Star，是所有CoreData第三方库中使用最多、功能最全的。在文章的后面还会对CoreData做一个总结，以及对本系列所有文章做一个总结。</p>

<p>文章中如有疏漏或错误，还请各位及时提出，谢谢！</p>

<!--more-->


<h4>MagicalRecord</h4>

<p>CoreData是苹果自家推出的一个持久化框架，使用起来更加面向对象。但是在使用过程中会出现大量代码，而且CoreData学习曲线比较陡峭，如果掌握不好，在使用过程中很容易造成其他问题。</p>

<p>国外开发者开源了一个基于CoreData封装的第三方——MagicalRecord，就像是FMDB封装SQLite一样，MagicalRecord封装的CoreData，使得原生的CoreData更加容易使用。并且MagicalRecord降低了CoreData的使用门槛，不用去手动管理之前的PSC、MOC等对象。</p>

<p>根据Github上MagicalRecord的官方文档，MagicalRecord的优点主要有三条：</p>

<ol>
<li><p>清理项目中CoreData代码</p></li>
<li><p>支持清晰、简单、一行式的查询操作</p></li>
<li><p>当需要优化请求时，可以获取NSFetchRequest进行修改</p></li>
</ol>


<p>添加MagicalRecord到项目中</p>

<p>将MagicalRecord添加到项目中，和使用其他第三方一样，可以通过下载源码和CocoaPods两种方式添加。</p>

<ol>
<li><p>从Github下载MagicalRecord源码，将源码直接拖到项目中，后续需要手动更新源码。</p></li>
<li><p>也可以通过CocoaPods安装MagicalRecord，需要在Podfile中加入下面命令，后续只需要通过命令来更新。</p></li>
</ol>


<h6>安装</h6>

<pre><code>pod "MagicalRecord"
</code></pre>

<p>在之前创建新项目时，通过勾选"Use Core Data"的方式添加CoreData到项目中，会在AppDelegate文件中生成大量CoreData相关代码。如果是大型项目，被占用的位置是很重要的。而对于MagicalRecord来说，只需要两行代码即可。</p>

<pre><code>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
// 初始化CoreData堆栈，也可以指定初始化某个CoreData堆栈
[MagicalRecord setupCoreDataStack];
return YES;
}
- (void)applicationWillTerminate:(UIApplication *)application {
// 在应用退出时，应该调用cleanUp方法
[MagicalRecord cleanUp];
}
</code></pre>

<p>MagicalRecord是支持CoreData的.xcdatamodeld文件的，使得CoreData这一优点可以继续使用。建立数据结构时还是像之前使用CoreData一样，通过.xcdatamodeld文件的方式建立。</p>

<p><img src="http://al1020119.github.io/images/coredateduoxianchenganquan004.png" title="Caption" ></p>

<h4>支持iCloud</h4>

<p>CoreData是支持iCloud的，MagicalRecord对iCloud相关的操作也做了封装，只需要使用MagicalRecord+iCloud.h类中提供的方法，就可以进行iCloud相关的操作。</p>

<p>例如下面是MagicalRecord+iCloud.h中的一个方法，需要将相关参数传入即可。</p>

<pre><code>+ (void)setupCoreDataStackWithiCloudContainer:(NSString *)containerID localStoreNamed:(NSString *)localStore;
</code></pre>

<h6>创建上下文</h6>

<p>MagicalRecord对上下文的管理和创建也比较全面，下面是MagicalRecord提供的部分创建和获取上下文的代码。因为是给NSManagedObjectContext添加的Category，可以直接用NSManagedObjectContext类调用，使用非常方便。</p>

<p>但是需要注意，虽然系统帮我们管理了上下文对象，对于耗时操作仍然要放在后台线程中处理，并且在主线程中进行UI操作。</p>

<pre><code>+ [NSManagedObjectContext MR_context]  设置默认的上下文为它的父级上下文，并发类型为NSPrivateQueueConcurrencyType

+ [NSManagedObjectContext MR_newMainQueueContext]  创建一个新的上下文，并发类型为NSMainQueueConcurrencyType

+ [NSManagedObjectContext MR_newPrivateQueueContext]  创建一个新的上下文，并发类型为NSPrivateQueueConcurrencyType

+ [NSManagedObjectContext MR_contextWithParent:]  创建一个新的上下文，允许自定义父级上下文，并发类型为NSPrivateQueueConcurrencyType

+ [NSManagedObjectContext MR_contextWithStoreCoordinator:]  创建一个新的上下文，并允许自定义持久化存储协调器，并发类型为NSPrivateQueueConcurrencyType

+ [NSManagedObjectContext MR_defaultContext]  获取默认上下文对象，项目中最基础的上下文对象，并发类型是NSMainQueueConcurrencyType
</code></pre>

<p>增删改查</p>

<p>MagicalRecord对NSManagedObject添加了一个Category，将增删改查等操作放在这个Category中，使得这些操作可以直接被NSManagedObject类及其子类调用。</p>

<ol>
<li>增</li>
</ol>


<p>对于托管模型的创建非常简单，不需要像之前还需要进行上下文的操作，现在这都是MagicalRecord帮我们完成的。</p>

<pre><code>// 创建并插入到上下文中
Employee *emp = [Employee MR_createEntity];
</code></pre>

<ol>
<li>删</li>
</ol>


<p>删除数据</p>

<pre><code>// 从上下文中删除当前对象
[emp MR_deleteEntity];
</code></pre>

<ol>
<li>改</li>
</ol>


<p>修改数据</p>

<pre><code>// 获取一个上下文对象
NSManagedObjectContext *defaultContext = [NSManagedObjectContext MR_defaultContext];
// 在当前上下文环境中创建一个新的Employee对象
Employee *emp = [Employee MR_createEntityInContext:defaultContext];
emp.name      = @"lxz";
emp.brithday  = [NSDate date];
emp.height    = @1.7;
// 保存修改到当前上下文中
[defaultContext MR_saveToPersistentStoreAndWait];
</code></pre>

<ol>
<li>查</li>
</ol>


<p> 查询数据</p>

<pre><code>// 执行查找操作，并设置排序条件
NSArray *empSorted = [Employee MR_findAllSortedBy:@"height" ascending:YES];
</code></pre>

<h4>自定义NSFetchRequest</h4>

<p>下面示例代码中，Employee根据已有的employeeFilter谓词对象，创建了employeeRequest请求对象，并将请求对象做修改后，从MOC中获取请求结果，实现自定义查找条件。</p>

<pre><code>NSPredicate *employeeFilter = [NSPredicate predicateWithFormat:@"name LIKE %@", @"*lxz*"];
NSFetchRequest *employeeRequest = [Employee MR_requestAllWithPredicate:employeeFilter];
employeeRequest.fetchOffset = 10;
employeeRequest.fetchLimit = 10;
NSArray *employees = [Employee MR_executeFetchRequest:employeeRequest];
</code></pre>

<h6>参数设置</h6>

<ol>
<li><p>可以通过修改MR_LOGGING_DISABLED预编译指令的值，控制log打印。</p>

<ul>
<li>&ldquo;#defne MR_LOGGING_DISABLED 1&rdquo;.</li>
</ul>
</li>
</ol>


<p>2.MagicalRecord在DEBUG模式下，对模型文件发生了更改，并且没有创建新的模型文件版本。MagicalRecord默认会将旧的持久化存储删除，创建新的持久化存储。</p>

<p>MagicalRecord的使用方法还有很多，这里只是将一些比较常用的拿出来讲讲，其他就不一一讲解了。在Github上有国人翻译的MagicalRecord官方文档，翻译的非常全面，而且是实时更新的。</p>

<p>这篇文章关于MagicalRecord的部分，也是参考文章来写的，我这里就犯了个懒……</p>

<h2>MagicalRecord中文文档</h2>

<h4>CoreData优缺点总结</h4>

<p>无论是什么东西，肯定不会是绝对完美的，CoreData也是如此。CoreData被设计出来后，对比其他本地持久化方案有自己独有的优势，也有比较严重的问题。</p>

<p>对于一个本地持久化方案的选取，还是要根据公司业务需求，来选择一个适合项目的方案，并没有哪个方案是万能的。</p>

<h6>优点</h6>

<pre><code>可以设置关联关系，也就是之前讲过的关联属性，关联属性可以和当前对象一起被MOC操作。

例如Company关联一个Person对象，对Company进行操作时，也可以通过点语法从Company中获取Person，Person的修改会随着Company一起被持久化。

如果用SQLite实现起来是很麻烦的，但CoreData可以很容易的完成，这也是CoreData更加面向对象的一种体现。

更加面向对象，将之前Model层的表示和持久化合二为一。把数据库的交互和对象的转换封装起来，使用时不需要接触到任何SQLite相关的代码，直接使用托管对象即可。

开发效率比较快，可以很快的封装一个基于CoreData实现的Model层，而不需要太多的代码就可以实现。

可以很好的防范SQL注入的问题。对于SQLite来说，如果是用FMDB并且用?占位符，也可以防范SQL注入的问题。

可视化化效果好且结构清晰。将模型文件内部的结构，以及实体之间的对应关系等，以可视化的结构展现出来。

对OC原生编程支持非常好，支持keyPath操作方式。例如设置NSPredicate查找条件时，可以使用keyPath的点语法设置属性。而其他持久化存储对于这点支持的不太好，需要编写很复杂的查找条件，看起来也不太好理解。

毕竟是Apple自家推出的，所以对OC融合度比较高，可以很好的配合和使用OC对象。

设置一对一或一对多的关系，设置关系后做存储和查询也非常方便，这是非常便于开发的。如果对于性能没有苛刻的要求，并且持久化对象之间关系比较复杂，比较推荐使用CoreData。
</code></pre>

<h6>缺点</h6>

<pre><code>灵活性不如SQLite，CoreData是对SQLite的一个封装，上层不能直接对数据库进行操作。处理任何数据都要按照CoreData内部的实现逻辑执行，而不能自定义执行逻辑，对执行逻辑没有可控性。

进行大量数据处理时比较吃力，性能明显低于直接操作SQLite数据库，而且内存占用非常大，需要手动做内存控制。

当执行一个操作时涉及的数据比较多，需要将所有相关的托管对象加载到内存中，而且中间还涉及到对象的转换等操作。这样对性能和内存的消耗都是非常大的，和涉及到的数据量成正比。
</code></pre>

<p>因为CoreData底层是用SQLite实现的，可以在CoreData的基础上，直接编写SQL语句对数据库进行操作。但是并不推荐这样做，在一个项目中应该只有一种持久化的主体方案。而且如果这两种方式混用的话，对于后期维护是非常困难的。</p>

<pre><code>如果出现这样的需求，最好直接去用SQLite。

CoreData入门门槛比较高，很难很好的掌握。
</code></pre>

<p>很多人都说CoreData不好用，这个原因很大一部分都是因为使用方式的问题。CoreData框架学习难度比较大，导致很多人都只是简单的使用CoreData，这些用法很多都是不合理的，很多的高级用法并没有用到。</p>

<h4>写在最后</h4>

<p>到目前为止CoreData系列的六篇文章就都写完了，文章中可能存在一些没有注意的问题，还请各位提出。博客中包括CoreData在内的所有文章永久更新维护，会不断将新知识添加到对应的文章中，也会对落后的文章进行重写。</p>

<p>在第一篇文章中也说到，我接触CoreData时间也不是很长，这系列文章更像是我学习的一个总结。但是我确实是很认真的在写，文章内容也是检查了很多遍，防止错字或者语法问题。知识点总结的还是比较全面的，在后续我还会更深入的学习CoreData，也可能会推出后续文章。</p>

<blockquote><p>许多人对于CoreData有很多意见，认为CoreData有各种各样的问题，这并不是空穴来风。在我学习CoreData的过程中，也发现CoreData确实存在诸多问题，例如查询性能略差、灵活性等。所以在使用CoreData的时候，还是根据公司业务需求来权衡是否使用CoreData。</p></blockquote>

<pre><code>Q Q：2211523682/790806573

微信：18370997821/13148454507

微博WB:http://weibo.com/u/3288975567?is_hot=1

git博文：http://al1020119.github.io/

github：https://github.com/al1020119
</code></pre>

<p><img src="http://al1020119.github.io/images/iCocosCoder.jpg" title="Caption" ></p>

<p><img src="http://al1020119.github.io/images/iCocosPublic.jpg" title="Caption" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CoreData安全问题！]]></title>
    <link href="http://al1020119.github.io/blog/2016/07/04/coredatedzhuangbianquang/"/>
    <updated>2016-07-04T18:59:42+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/07/04/coredatedzhuangbianquang</id>
    <content type="html"><![CDATA[<p>正文：</p>

<p>CoreData使用相关的技术点已经讲差不多了，我所掌握的也就这么多了&hellip;.</p>

<p>在本篇文章中主要讲CoreData的多线程，其中会包括并发队列类型、线程安全等技术点。我对多线程的理解可能不是太透彻，文章中出现的问题还请各位指出。在之后公司项目使用CoreData的过程中，我会将其中遇到的多线程相关的问题更新到文章中。</p>

<p>在文章的最后，会根据我对CoreData多线程的学习，以及在工作中的具体使用，给出一些关于多线程结构的设计建议，各位可以当做参考。</p>

<p>文章中如有疏漏或错误，还请各位及时提出，谢谢！</p>

<!--more-->


<h4>MOC并发队列类型</h4>

<p>在CoreData中MOC是支持多线程的，可以在创建MOC对象时，指定其并发队列的类型。当指定队列类型后，系统会将操作都放在指定的队列中执行，如果指定的是私有队列，系统会创建一个新的队列。但这都是系统内部的行为，我们并不能获取这个队列，队列由系统所拥有，并由系统将任务派发到这个队列中执行的。</p>

<p>NSManagedObjectContext并发队列类型:</p>

<pre><code>NSConfinementConcurrencyType : 如果使用init方法初始化上下文，默认就是这个并发类型。这个枚举值是不支持多线程的，从名字上也体现出来了。

NSPrivateQueueConcurrencyType : 私有并发队列类型，操作都是在子线程中完成的。

NSMainQueueConcurrencyType : 主并发队列类型，如果涉及到UI相关的操作，应该考虑使用这个枚举值初始化上下文。
</code></pre>

<p>其中NSConfinementConcurrencyType类型在iOS9之后已经被苹果废弃，不建议使用这个API。使用此类型创建的MOC，调用某些比较新的CoreData的API可能会导致崩溃。</p>

<h4>MOC多线程调用方式</h4>

<p>在CoreData中MOC不是线程安全的，在多线程情况下使用MOC时，不能简单的将MOC从一个线程中传递到另一个线程中使用，这并不是CoreData的多线程，而且会出问题。对于MOC多线程的使用，苹果给出了自己的解决方案。</p>

<p>在创建的MOC中使用多线程，无论是私有队列还是主队列，都应该采用下面两种多线程的使用方式，而不是自己手动创建线程。调用下面方法后，系统内部会将任务派发到不同的队列中执行。可以在不同的线程中调用MOC的这两个方法，这个是允许的。</p>

<pre><code>- (void)performBlock:(void (^)())block         //异步执行的block，调用之后会立刻返回
- (void)performBlockAndWait:(void (^)())block    //同步执行的block，调用之后会等待这个任务完成，才会继续向下执行
</code></pre>

<p>下面是多线程调用的示例代码，在多线程的环境下执行MOC的save方法，就是将save方法放在MOC的block体中异步执行，其他方法的调用也是一样的。</p>

<pre><code>[context performBlock:^{
    [context save:nil];
}];
</code></pre>

<p>但是需要注意的是，这两个block方法不能在NSConfinementConcurrencyType类型的MOC下调用，这个类型的MOC是不支持多线程的，只支持其他两种并发方式的MOC。</p>

<h4>多线程的使用</h4>

<p>在业务比较复杂的情况下，需要进行大量数据处理，并且还需要涉及到UI的操作。对于这种复杂需求，如果都放在主队列中，对性能和界面流畅度都会有很大的影响，导致用户体验非常差，降低屏幕FPS。对于这种情况，可以采取多个MOC配合的方式。</p>

<p>CoreData多线程的发展中，在iOS5经历了一次比较大的变化，之后可以更方便的使用多线程。从iOS5开始，支持设置MOC的parentContext属性，通过这个属性可以设置MOC的父MOC。下面会针对iOS5之前和之后，分别讲解CoreData的多线程使用。</p>

<p>尽管现在的开发中早就不兼容iOS5之前的系统了，但是作为了解这里还是要讲一下，而且这种同步方式在iOS5之后也是可以正常使用的，也有很多人还在使用这种同步方式，下面其他章节也是同理。</p>

<h4>iOS 5之前使用多个MOC</h4>

<p>在iOS 5之前实现MOC的多线程，可以创建多个MOC，多个MOC使用同一个PSC，并让多个MOC实现数据同步。通过这种方式不用担心PSC在调用过程中的线程问题，MOC在使用PSC进行save操作时，会对PSC进行加锁，等当前加锁的MOC执行完操作之后，其他MOC才能继续执行操作。</p>

<p>每一个PSC都对应着一个持久化存储区，PSC知道存储区中数据存储的数据结构，而MOC需要使用这个PSC进行save操作的实现。</p>

<p><img src="http://al1020119.github.io/images/coredateduoxianchenganquan001.png" title="Caption" ></p>

<h4>多线程结构</h4>

<p>这样做有一个问题，当一个MOC发生改变并持久化到本地时，系统并不会将其他MOC缓存在内存中的NSManagedObject对象改变。所以这就需要我们在MOC发生改变时，将其他MOC数据更新。</p>

<p>根据上面的解释，在下面例子中创建了一个主队列的mainMOC，主要用于UI操作。一个私有队列的backgroundMOC，用于除UI之外的耗时操作，两个MOC使用的同一个PSC。</p>

<pre><code>// 获取PSC实例对象
- (NSPersistentStoreCoordinator *)persistentStoreCoordinator {
    // 创建托管对象模型，并指明加载Company模型文件
    NSURL *modelPath = [[NSBundle mainBundle] URLForResource:@"Company" withExtension:@"momd"];
    NSManagedObjectModel *model = [[NSManagedObjectModel alloc] initWithContentsOfURL:modelPath];
       // 创建PSC对象，并将托管对象模型当做参数传入，其他MOC都是用这一个PSC。
    NSPersistentStoreCoordinator *PSC = [[NSPersistentStoreCoordinator alloc] initWithManagedObjectModel:model];
    // 根据指定的路径，创建并关联本地数据库
    NSString *dataPath = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).lastObject;
    dataPath = [dataPath stringByAppendingFormat:@"/%@.sqlite", @"Company"];
    [PSC addPersistentStoreWithType:NSSQLiteStoreType configuration:nil URL:[NSURL fileURLWithPath:dataPath] options:nil error:nil];
    return PSC;
}
// 初始化用于本地存储的所有MOC
- (void)createManagedObjectContext {
    // 创建PSC实例对象，其他MOC都用这一个PSC。
    NSPersistentStoreCoordinator *PSC = self.persistentStoreCoordinator;
    // 创建主队列MOC，用于执行UI操作
    NSManagedObjectContext *mainMOC = [[NSManagedObjectContext alloc] initWithConcurrencyType:NSMainQueueConcurrencyType];
    mainMOC.persistentStoreCoordinator = PSC;
    // 创建私有队列MOC，用于执行其他耗时操作
    NSManagedObjectContext *backgroundMOC = [[NSManagedObjectContext alloc] initWithConcurrencyType:NSPrivateQueueConcurrencyType];
    backgroundMOC.persistentStoreCoordinator = PSC;
    // 通过监听NSManagedObjectContextDidSaveNotification通知，来获取所有MOC的改变消息
    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(contextChanged:) name:NSManagedObjectContextDidSaveNotification object:nil];
}
// MOC改变后的通知回调
- (void)contextChanged:(NSNotification *)noti {
    NSManagedObjectContext *MOC = noti.object;
    // 这里需要做判断操作，判断当前改变的MOC是否我们将要做同步的MOC，如果就是当前MOC自己做的改变，那就不需要再同步自己了。
    // 由于项目中可能存在多个PSC，所以下面还需要判断PSC是否当前操作的PSC，如果不是当前PSC则不需要同步，不要去同步其他本地存储的数据。
    [MOC performBlock:^{
        // 直接调用系统提供的同步API，系统内部会完成同步的实现细节。
        [MOC mergeChangesFromContextDidSaveNotification:noti];
    }];
}
</code></pre>

<p>在上面的Demo中，创建了一个PSC，并将其他MOC都关联到这个PSC上，这样所有的MOC执行本地持久化相关的操作时，都是通过同一个PSC进行操作的。并在下面添加了一个通知，这个通知是监听所有MOC执行save操作后的通知，并在通知的回调方法中进行数据的合并。</p>

<h4>iOS5之后使用多个MOC</h4>

<blockquote><p>在iOS5之后，MOC可以设置parentContext，一个parentContext可以拥有多个ChildContext。在ChildContext执行save操作后，会将操作push到parentContext，由parentContext去完成真正的save操作，而ChildContext所有的改变都会被parentContext所知晓，这解决了之前MOC手动同步数据的问题。</p></blockquote>

<p>需要注意的是，在ChildContext调用save方法之后，此时并没有将数据写入存储区，还需要调用parentContext的save方法。因为ChildContext并不拥有PSC，ChildContext也不需要设置PSC，所以需要parentContext调用PSC来执行真正的save操作。也就是只有拥有PSC的MOC执行save操作后，才是真正的执行了写入存储区的操作。</p>

<pre><code>- (void)createManagedObjectContext {
    // 创建PSC实例对象，还是用上面Demo的实例化代码
    NSPersistentStoreCoordinator *PSC = self.persistentStoreCoordinator;
    // 创建主队列MOC，用于执行UI操作
    NSManagedObjectContext *mainMOC = [[NSManagedObjectContext alloc] initWithConcurrencyType:NSMainQueueConcurrencyType];
    mainMOC.persistentStoreCoordinator = PSC;
    // 创建私有队列MOC，用于执行其他耗时操作，backgroundMOC并不需要设置PSC
    NSManagedObjectContext *backgroundMOC = [[NSManagedObjectContext alloc] initWithConcurrencyType:NSPrivateQueueConcurrencyType];
    backgroundMOC.parentContext = mainMOC;
    // 私有队列的MOC和主队列的MOC，在执行save操作时，都应该调用performBlock:方法，在自己的队列中执行save操作。
    // 私有队列的MOC执行完自己的save操作后，还调用了主队列MOC的save方法，来完成真正的持久化操作，否则不能持久化到本地
    [backgroundMOC performBlock:^{
        [backgroundMOC save:nil];
        [mainMOC performBlock:^{
            [mainMOC save:nil];
        }];
    }];
}
</code></pre>

<p>上面例子中创建一个主队列的mainMOC，来完成UI相关的操作。创建私有队列的backgroundMOC，处理复杂逻辑以及数据处理操作，在实际开发中可以根据需求创建多个backgroundMOC。需要注意的是，在backgroundMOC执行完save方法后，又在mainMOC中执行了一次save方法，这步是很重要的。</p>

<h4>iOS5之前进行数据同步</h4>

<p>就像上面章节中讲到的，在iOS5之前存在多个MOC的情况下，一个MOC发生更改并提交存储区后，其他MOC并不知道这个改变，其他MOC和本地存储的数据是不同步的，所以就涉及到数据同步的问题。</p>

<p>进行数据同步时，会遇到多种复杂情况。例如只有一个MOC数据发生了改变，其他MOC更新时并没有对相同的数据做改变，这样不会造成冲突，可以直接将其他MOC更新。</p>

<p>如果在一个MOC数据发生改变后，其他MOC对相同的数据做了改变，而且改变的结果不同，这样在同步时就会造成冲突。下面将会按照这两种情况，分别讲一下不同情况下的冲突处理方式。</p>

<h4>简单情况下的数据同步</h4>

<p>简单情况下的数据同步，是针对于只有一个MOC的数据发生改变，并提交存储区后，其他MOC更新时并没有对相同的数据做改变，只是单纯的同步数据的情况。</p>

<p>在NSManagedObjectContext类中，根据不同操作定义了一些通知。在一个MOC发生改变时，其他地方可以通过MOC中定义的通知名，来获取MOC发生的改变。在NSManagedObjectContext中定义了下面三个通知：</p>

<pre><code>NSManagedObjectContextWillSaveNotification：MOC将要向存储区存储数据时，调用这个通知。在这个通知中不能获取发生改变相关的NSManagedObject对象。

NSManagedObjectContextDidSaveNotification：MOC向存储区存储数据后，调用这个通知。在这个通知中可以获取改变、添加、删除等信息，以及相关联的NSManagedObject对象。

NSManagedObjectContextObjectsDidChangeNotification：在MOC中任何一个托管对象发生改变时，调用这个通知。例如修改托管对象的属性。
</code></pre>

<p>通过监听NSManagedObjectContextDidSaveNotification通知，获取所有MOC的save操作。</p>

<pre><code>[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(settingsContext:) name:NSManagedObjectContextDidSaveNotification object:nil];
</code></pre>

<p>不需要在通知的回调方法中，编写代码对比被修改的托管对象。MOC为我们提供了下面的方法，只需要将通知对象传入，系统会自动同步数据。</p>

<pre><code>- (void)mergeChangesFromContextDidSaveNotification:(NSNotification *)notification;
</code></pre>

<p>下面是通知中的实现代码，但是需要注意的是，由于通知是同步执行的，在通知对应的回调方法中所处的线程，和发出通知的MOC执行操作时所处的线程是同一个线程，也就是系统performBlock:回调方法分配的线程。</p>

<p>所以其他MOC在通知回调方法中，需要注意使用performBlock:方法，并在block体中执行操作。</p>

<pre><code>- (void)settingsContext:(NSNotification *)noti {
    [context performBlock:^{
        // 调用需要同步的MOC对象的merge方法，直接将通知对象当做参数传进去即可，系统会完成同步操作。
        [context mergeChangesFromContextDidSaveNotification:noti];
    }];
}
</code></pre>

<h4>复杂情况下的数据同步</h4>

<p>在一个MOC对本地存储区的数据发生改变，而其他MOC也对同样的数据做了改变，这样后面执行save操作的MOC就会冲突，并导致后面的save操作失败，这就是复杂情况下的数据合并。</p>

<p>这是因为每次一个MOC执行一次fetch操作后，会保存一个本地持久化存储的状态，当下次执行save操作时会对比这个状态和本地持久化状态是否一样。如果一样，则代表本地没有其他MOC对存储发生过改变；如果不一样，则代表本地持久化存储被其他MOC改变过，这就是造成冲突的根本原因。</p>

<p>对于这种冲突的情况，可以通过MOC对象指定解决冲突的方案，通过mergePolicy属性来设置方案。mergePolicy属性有下面几种可选的策略，默认是NSErrorMergePolicy方式，这也是唯一一个有NSError返回值的选项。</p>

<pre><code>NSErrorMergePolicy : 默认值，当出现合并冲突时，返回一个NSError对象来描述错误，而MOC和持久化存储区不发生改变。

NSMergeByPropertyStoreTrumpMergePolicy : 以本地存储为准，使用本地存储来覆盖冲突部分。

NSMergeByPropertyObjectTrumpMergePolicy : 以MOC的为准，使用MOC来覆盖本地存储的冲突部分。

NSOverwriteMergePolicy : 以MOC为准，用MOC的所有NSManagedObject对象覆盖本地存储的对应对象。

NSRollbackMergePolicy : 以本地存储为准，MOC所有的NSManagedObject对象被本地存储的对应对象所覆盖。
</code></pre>

<p>上面五种策略中，除了第一个NSErrorMergePolicy的策略，其他四种中NSMergeByPropertyStoreTrumpMergePolicy和NSRollbackMergePolicy，以及NSMergeByPropertyObjectTrumpMergePolicy和NSOverwriteMergePolicy看起来是重复的。</p>

<p>其实它们并不是冲突的，这四种策略的不同体现在，对没有发生冲突的部分应该怎么处理。NSMergeByPropertyStoreTrumpMergePolicy和NSMergeByPropertyObjectTrumpMergePolicy对没有冲突的部分，未冲突部分数据并不会受到影响。而NSRollbackMergePolicy和NSOverwriteMergePolicy则是无论是否冲突，直接全部替换。</p>

<blockquote><p>题外话：对于MOC的这种合并策略来看，有木有感觉到CoreData解决冲突的方式，和SVN解决冲突的方式特别像。。。</p></blockquote>

<h4>线程安全</h4>

<p>无论是MOC还是托管对象，都不应该在其他MOC的线程中执行操作，这两个API都不是线程安全的。但MOC可以在其他MOC线程中调用performBlock:方法，切换到自己的线程执行操作。</p>

<p>如果其他MOC想要拿到托管对象，并在自己的队列中使用托管对象，这是不允许的，托管对象是不能直接传递到其他MOC的线程的。但是可以通过获取NSManagedObject的NSManagedObjectID对象，在其他MOC中通过NSManagedObjectID对象，从持久化存储区中获取NSManagedObject对象，这样就是允许的。NSManagedObjectID是线程安全，并且可以跨线程使用的。</p>

<p>可以通过MOC获取NSManagedObjectID对应的NSManagedObject对象，例如下面几个MOC的API。</p>

<pre><code>NSManagedObject *object = [context objectRegisteredForID:objectID];
NSManagedObject *object = [context objectWithID:objectID];
</code></pre>

<p>通过NSManagedObject对象的objectID属性，获取NSManagedObjectID类型的objectID对象。</p>

<p>NSManagedObjectID *objectID = object.objectID;</p>

<h4>CoreData多线程结构设计</h4>

<p>上面章节中写的大多都是怎么用CoreData多线程，在掌握多线程的使用后，就可以根据公司业务需求，设计一套CoreData多线程结构了。对于多线程结构的设计，应该本着尽量减少主线程压力的角度去设计，将所有耗时操作都放在子线程中执行。</p>

<p>对于具体的设计我根据不同的业务需求，给出两种设计方案的建议。</p>

<h4>两层设计方案</h4>

<ol>
<li>在项目中多线程操作比较简单时，可以创建一个主队列mainMOC，和一个或多个私有队列的backgroundMOC。将所有backgroundMOC的parentContext设置为mainMOC，采取这样的两层设计一般就能够满足大多数需求了。</li>
</ol>


<p><img src="http://al1020119.github.io/images/coredateduoxianchenganquan002.png" title="Caption" ></p>

<ol>
<li>将耗时操作都放在backgroundMOC中执行，mainMOC负责所有和UI相关的操作。所有和UI无关的工作都交给backgroundMOC，在backgroundMOC对数据发生改变后，调用save方法会将改变push到mainMOC中，再由mainMOC执行save方法将改变保存到存储区。</li>
</ol>


<p>代码这里就不写了，和上面例子中设置parentContext代码一样，主要讲一下设计思路。</p>

<h4>三层设计方案</h4>

<ul>
<li>但是我们发现，上面的save操作最后还是由mainMOC去执行的，backgroundMOC只是负责处理数据。虽然mainMOC只执行save操作并不会很耗时，但是如果save涉及的数据比较多，这样还是会对性能造成影响的。</li>
</ul>


<p>虽然客户端很少涉及到大量数据处理的需求，但是假设有这样的需求。可以考虑在两层结构之上，给mainMOC之上再添加一个parentMOC，这个parentMOC也是私有队列的MOC，用于处理save操作。</p>

<p><img src="http://al1020119.github.io/images/coredateduoxianchenganquan003.png" title="Caption" ></p>

<ul>
<li>这样CoreData存储的结构就是三层了，最底层是backgroundMOC负责处理数据，中间层是mainMOC负责UI相关操作，最上层也是一个backgroundMOC负责执行save操作。这样就将影响UI的所有耗时操作全都剥离到私有队列中执行，使性能达到了很好的优化。</li>
</ul>


<p>需要注意的是，执行MOC相关操作时，不要阻塞当前主线程。所有MOC的操作应该是异步的，无论是子线程还是主线程，尽量少的使用同步block方法。</p>

<h4>MOC同步时机</h4>

<p>设置MOC的parentContext属性之后，parent对于child的改变是知道的，但是child对于parent的改变是不知道的。苹果这样设计，应该是为了更好的数据同步。</p>

<pre><code>Employee *emp = [NSEntityDescription insertNewObjectForEntityForName:@"Employee" inManagedObjectContext:backgroundMOC];
emp.name = @"lxz";
emp.brithday = [NSDate date];
emp.height = @1.7f;
[backgroundMOC performBlock:^{
    [backgroundMOC save:nil];
    [mainMOC performBlock:^{
        [mainMOC save:nil];
    }];
}];
</code></pre>

<p>在上面这段代码中，mainMOC是backgroundMOC的parentContext。在backgroundMOC执行save方法前，backgroundMOC和mainMOC都不能获取到Employee的数据，在backgroundMOC执行完save方法后，自身上下文发生改变的同时，也将改变push到mainMOC中，mainMOC也具有了Employee对象。</p>

<p>所以在backgroundMOC的save方法执行时，是对内存中的上下文做了改变，当拥有PSC的mainMOC执行save方法后，是对本地存储区做了改变。</p>

<pre><code>Q Q：2211523682/790806573

微信：18370997821/13148454507

微博WB:http://weibo.com/u/3288975567?is_hot=1

git博文：http://al1020119.github.io/

github：https://github.com/al1020119
</code></pre>

<p><img src="http://al1020119.github.io/images/iCocosCoder.jpg" title="Caption" ></p>

<p><img src="http://al1020119.github.io/images/iCocosPublic.jpg" title="Caption" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CoreData装逼技能？]]></title>
    <link href="http://al1020119.github.io/blog/2016/07/04/coredatedzhuangbi/"/>
    <updated>2016-07-04T14:59:42+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/07/04/coredatedzhuangbi</id>
    <content type="html"><![CDATA[<p>正文：</p>

<p>在之前的文章中，已经讲了很多关于CoreData使用相关的知识点。这篇文章中主要讲两个方面，NSFetchedResultsController和版本迁移。</p>

<p>文章题目中虽然有“高级”两个字，其实讲的东西并不高级，只是因为上一篇文章中东西太多了，把两个较复杂的知识点挪到这篇文章中。</p>

<!--more-->


<p>文章中如有疏漏或错误，还请各位及时提出，谢谢！</p>

<p>NSFetchedResultsController</p>

<p>在开发过程中会经常用到UITableView这样的视图类，这些视图类需要自己管理其数据源，包括网络获取、本地存储都需要写代码进行管理。</p>

<p>而在CoreData中提供了NSFetchedResultsController类(fetched results controller，也叫FRC)，FRC可以管理UITableView或UICollectionView的数据源。这个数据源主要指本地持久化的数据，也可以用这个数据源配合着网络请求数据一起使用，主要看业务需求了。</p>

<p>本篇文章会使用UITableView作为视图类，配合NSFetchedResultsController进行后面的演示，UICollectionView配合NSFetchedResultsController的使用也是类似，这里就不都讲了。</p>

<p>简单介绍</p>

<p>就像上面说到的，NSFetchedResultsController就像是上面两种视图的数据管理者一样。FRC可以监听一个MOC的改变，如果MOC执行了托管对象的增删改操作，就会对本地持久化数据发生改变，FRC就会回调对应的代理方法，回调方法的参数会包括执行操作的类型、操作的值、indexPath等参数。</p>

<p>实际使用时，通过FRC“绑定”一个MOC，将UITableView嵌入在FRC的执行流程中。在任何地方对这个“绑定”的MOC存储区做修改，都会触发FRC的回调方法，在FRC的回调方法中嵌入UITableView代码并做对应修改即可。</p>

<p>由此可以看出FRC最大优势就是，始终和本地持久化的数据保持统一。只要本地持久化的数据发生改变，就会触发FRC的回调方法，从而在回调方法中更新上层数据源和UI。这种方式讲的简单一点，就可以叫做数据带动UI。</p>

<p><img src="http://al1020119.github.io/images/4001.png" title="Caption" ></p>

<p>FRC</p>

<p>但是需要注意一点，在FRC的初始化中传入了一个MOC参数，FRC只能监测传入的MOC发生的改变。假设其他MOC对同一个存储区发生了改变，FRC则不能监测到这个变化，不会做出任何反应。</p>

<p>所以使用FRC时，需要注意FRC只能对一个MOC的变化做出反应，所以在CoreData持久化层设计时，尽量一个存储区只对应一个MOC，或设置一个负责UI的MOC，这在后面多线程部分会详细讲解。</p>

<p>修改模型文件结构</p>

<p>在写代码之前，先对之前的模型文件结构做一些修改。</p>

<p><img src="http://al1020119.github.io/images/4002.png" title="Caption" ></p>

<p>Employee结构</p>

<p>讲FRC的时候，只需要用到Employee这一张表，其他表和设置直接忽略。需要在Employee原有字段的基础上，增加一个String类型的sectionName字段，这个字段就是用来存储section title的，在下面的文章中将会详细讲到。</p>

<p>初始化FRC</p>

<p>下面例子是比较常用的FRC初始化方式，初始化时指定的MOC，还用之前讲过的MOC初始化代码，UITableView初始化代码这里也省略了，主要突出FRC的初始化。</p>

<pre><code>// 创建请求对象，并指明操作Employee表
NSFetchRequest *request = [NSFetchRequest fetchRequestWithEntityName:@"Employee"];
// 设置排序规则，指明根据height字段升序排序
NSSortDescriptor *heightSort = [NSSortDescriptor sortDescriptorWithKey:@"height" ascending:YES];
request.sortDescriptors = @[heightSort];
// 创建NSFetchedResultsController控制器实例，并绑定MOC
NSError *error = nil;
fetchedResultController = [[NSFetchedResultsController alloc] initWithFetchRequest:request
                                                 managedObjectContext:context
                                        sectionNameKeyPath:@"sectionName"
                                               cacheName:nil];
// 设置代理，并遵守协议
fetchedResultController.delegate = self;
// 执行获取请求，执行后FRC会从持久化存储区加载数据，其他地方可以通过FRC获取数据
[fetchedResultController performFetch:&amp;error];
// 错误处理
if (error) {
    NSLog(@"NSFetchedResultsController init error : %@", error);
}
// 刷新UI
[tableView reloadData];
</code></pre>

<p>在上面初始化FRC时，传入的sectionNameKeyPath:参数，是指明当前托管对象的哪个属性当做section的title，在本文中就是Employee表的sectionName字段为section的title。从NSFetchedResultsSectionInfo协议的indexTitle属性获取这个值。</p>

<p>在sectionNameKeyPath:设置属性名后，就以这个属性名作为分组title，相同的title会被分到一个section中。</p>

<p>初始化FRC时参数managedObjectContext:传入了一个MOC参数，FRC只能监测这个传入的MOC发生的本地持久化改变。就像上面介绍时说的，其他MOC对同一个持久化存储区发生的改变，FRC则不能监测到这个变化。</p>

<p>再往后面看到cacheName:参数，这个参数我设置的是nil。参数的作用是开启FRC的缓存，对获取的数据进行缓存并指定一个名字。可以通过调用deleteCacheWithName:方法手动删除缓存。</p>

<p>但是这个缓存并没有必要，缓存是根据NSFetchRequest对象来匹配的，如果当前获取的数据和之前缓存的相匹配则直接拿来用，但是在获取数据时每次获取的数据都可能不同，缓存不能被命中则很难派上用场，而且缓存还占用着内存资源。</p>

<p>在FRC初始化完成后，调用performFetch:方法来同步获取持久化存储区数据，调用此方法后FRC保存数据的属性才会有值。获取到数据后，调用tableView的reloadData方法，会回调tableView的代理方法，可以在tableView的代理方法中获取到FRC的数据。调用performFetch:方法第一次获取到数据并不会回调FRC代理方法。</p>

<p>代理方法</p>

<p>FRC中包含UITableView执行过程中需要的相关数据，可以通过FRC的sections属性，获取一个遵守协议的对象数组，数组中的对象就代表一个section。</p>

<p>在这个协议中有如下定义，可以看出这些属性和UITableView的执行流程是紧密相关的。</p>

<pre><code>@protocol NSFetchedResultsSectionInfo
/* Name of the section */
@property (nonatomic, readonly) NSString *name;
/* Title of the section (used when displaying the index) */
@property (nullable, nonatomic, readonly) NSString *indexTitle;
/* Number of objects in section */
@property (nonatomic, readonly) NSUInteger numberOfObjects;
/* Returns the array of objects in the section. */
@property (nullable, nonatomic, readonly) NSArray *objects;
@end // NSFetchedResultsSectionInfo
</code></pre>

<p>在使用过程中应该将FRC和UITableView相互嵌套，在FRC的回调方法中嵌套UITableView的视图改变逻辑，在UITableView的回调中嵌套数据更新的逻辑。这样可以始终保证数据和UI的同步，在下面的示例代码中将会演示FRC和UITableView的相互嵌套。</p>

<pre><code>Table View Delegate

// 通过FRC的sections数组属性，获取所有section的count值
- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView {
    return fetchedResultController.sections.count;
}
// 通过当前section的下标从sections数组中取出对应的section对象，并从section对象中获取所有对象count
- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section {
    return fetchedResultController.sections[section].numberOfObjects;
}
// FRC根据indexPath获取托管对象，并给cell赋值
- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {
    Employee *emp = [fetchedResultController objectAtIndexPath:indexPath];
    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@"identifier" forIndexPath:indexPath];
    cell.textLabel.text = emp.name;
    return cell;
}
// 创建FRC对象时，通过sectionNameKeyPath:传递进去的section title的属性名，在这里获取对应的属性值
- (NSString *)tableView:(UITableView *)tableView titleForHeaderInSection:(NSInteger)section {
    return fetchedResultController.sections[section].indexTitle;
}
// 是否可以编辑
- (BOOL)tableView:(UITableView *)tableView canEditRowAtIndexPath:(NSIndexPath *)indexPath {
    return YES;
}
// 这里是简单模拟UI删除cell后，本地持久化区数据和UI同步的操作。在调用下面MOC保存上下文方法后，FRC会回调代理方法并更新UI
- (void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath {
     if (editingStyle == UITableViewCellEditingStyleDelete) {
        // 删除托管对象
        Employee *emp = [fetchedResultController objectAtIndexPath:indexPath];
        [context deleteObject:emp];
        // 保存上下文环境，并做错误处理
        NSError *error = nil;
        if (![context save:&amp;error]) {
            NSLog(@"tableView delete cell error : %@", error);
        }
    }
}
</code></pre>

<p>上面是UITableView的代理方法，代理方法中嵌套了FRC的数据获取代码，这样在刷新视图时就可以保证使用最新的数据。并且在代码中简单实现了删除cell后，通过MOC调用删除操作，使本地持久化数据和UI保持一致。</p>

<p>就像上面cellForRowAtIndexPath:方法中使用的一样，FRC提供了两个方法轻松转换indexPath和NSManagedObject的对象，在实际开发中这两个方法非常实用，这也是FRC和UITableView、UICollectionView深度融合的表现。</p>

<pre><code>- (id)objectAtIndexPath:(NSIndexPath *)indexPath;
- (nullable NSIndexPath *)indexPathForObject:(id)object;
</code></pre>

<p>Fetched Results Controller Delegate</p>

<pre><code>// Cell数据源发生改变会回调此方法，例如添加新的托管对象等
- (void)controller:(NSFetchedResultsController *)controller didChangeObject:(id)anObject atIndexPath:(nullable NSIndexPath *)indexPath forChangeType:(NSFetchedResultsChangeType)type newIndexPath:(nullable NSIndexPath *)newIndexPath {
    switch (type) {
        case NSFetchedResultsChangeInsert:
            [tableView insertRowsAtIndexPaths:@[newIndexPath] withRowAnimation:UITableViewRowAnimationAutomatic];
            break;
        case NSFetchedResultsChangeDelete:
            [tableView deleteRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationAutomatic];
            break;
        case NSFetchedResultsChangeMove:
            [tableView deleteRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationAutomatic];
            [tableView insertRowsAtIndexPaths:@[newIndexPath] withRowAnimation:UITableViewRowAnimationAutomatic];
            break;
        case NSFetchedResultsChangeUpdate: {
            UITableViewCell *cell = [tableView cellForRowAtIndexPath:indexPath];
            Employee *emp = [fetchedResultController objectAtIndexPath:indexPath];
            cell.textLabel.text = emp.name;
        }
            break;
    }
}
// Section数据源发生改变回调此方法，例如修改section title等。
- (void)controller:(NSFetchedResultsController *)controller didChangeSection:(id &lt;nsfetchedresultssectioninfo&gt;)sectionInfo atIndex:(NSUInteger)sectionIndex forChangeType:(NSFetchedResultsChangeType)type {
    switch (type) {
        case NSFetchedResultsChangeInsert:
            [tableView insertSections:[NSIndexSet indexSetWithIndex:sectionIndex] withRowAnimation:UITableViewRowAnimationAutomatic];
            break;
        case NSFetchedResultsChangeDelete:
            [tableView deleteSections:[NSIndexSet indexSetWithIndex:sectionIndex] withRowAnimation:UITableViewRowAnimationAutomatic];
            break;
        default:
            break;
    }
}
// 本地数据源发生改变，将要开始回调FRC代理方法。
- (void)controllerWillChangeContent:(NSFetchedResultsController *)controller {
    [tableView beginUpdates];
}
// 本地数据源发生改变，FRC代理方法回调完成。
- (void)controllerDidChangeContent:(NSFetchedResultsController *)controller {
    [tableView endUpdates];
}
// 返回section的title，可以在这里对title做进一步处理。这里修改title后，对应section的indexTitle属性会被更新。
- (nullable NSString *)controller:(NSFetchedResultsController *)controller sectionIndexTitleForSectionName:(NSString *)sectionName {
    return [NSString stringWithFormat:@"sectionName %@", sectionName];
}&lt;/nsfetchedresultssectioninfo&gt;
</code></pre>

<p>上面就是当本地持久化数据发生改变后，被回调的FRC代理方法的实现，可以在对应的实现中完成自己的代码逻辑。</p>

<p>在上面的章节中讲到删除cell后，本地持久化数据同步的问题。在删除cell后在tableView代理方法的回调中，调用了MOC的删除方法，使本地持久化存储和UI保持同步，并回调到下面的FRC代理方法中，在代理方法中对UI做删除操作，这样一套由UI的改变引发的删除流程就完成了。</p>

<p>目前为止已经实现了数据和UI的双向同步，即UI发生改变后本地存储发生改变，本地存储发生改变后UI也随之改变。可以通过下面添加数据的代码来测试一下，NSFetchedResultsController就讲到这里了。</p>

<pre><code>- (void)addMoreData {
    Employee *employee = [NSEntityDescription insertNewObjectForEntityForName:@"Employee" inManagedObjectContext:context];
    employee.name = [NSString stringWithFormat:@"lxz 15"];
    employee.height = @(15);
    employee.brithday = [NSDate date];
    employee.sectionName = [NSString stringWithFormat:@"3"];
    NSError *error = nil;
    if (![context save:&amp;error]) {
        NSLog(@"MOC save error : %@", error);
    }
}
</code></pre>

<p>版本迁移</p>

<p>CoreData版本迁移的方式有很多，一般都是先在Xcode中，原有模型文件的基础上，创建一个新版本的模型文件，然后在此基础上做不同方式的版本迁移。</p>

<p>本章节将会讲三种不同的版本迁移方案，但都不会讲太深，都是从使用的角度讲起，可以满足大多数版本迁移的需求。</p>

<p>为什么要版本迁移？</p>

<p>在已经运行程序并通过模型文件生成数据库后，再对模型文件进行的修改，如果只是修改已有实体属性的默认值、最大最小值、Fetch Request等属性自身包含的参数时，并不会发生错误。如果修改模型文件的结构，或修改属性名、实体名等，造成模型文件的结构发生改变，这样再次运行程序就会导致崩溃。</p>

<p>在开发测试过程中，可以直接将原有程序卸载就可以解决这个问题，但是本地之前存储的数据也会消失。如果是线上程序，就涉及到版本迁移的问题，否则会导致崩溃，并提示如下错误：</p>

<pre><code>CoreData: error: Illegal attempt to save to a file that was never opened. "This NSPersistentStoreCoordinator has no persistent stores (unknown).  It cannot perform a save operation.". No last error recorded.
</code></pre>

<p>然而在需求不断变化的过程中，后续版本肯定会对原有的模型文件进行修改，这时就需要用到版本迁移的技术，下面开始讲版本迁移的方案。</p>

<p>创建新版本模型文件</p>

<p>本文中讲的几种版本迁移方案，在迁移之前都需要对原有的模型文件创建新版本。</p>

<p>选中需要做迁移的模型文件 -> 点击菜单栏Editor -> Add Model Version -> 选择基于哪个版本的模型文件(一般都是选择目前最新的版本)，新建模型文件完成。</p>

<p>对于新版本模型文件的命名，我在创建新版本模型文件时，一般会拿当前工程版本号当做后缀，这样在模型文件版本比较多的时候，就可以很容易将模型文件版本和工程版本对应起来。</p>

<p><img src="http://al1020119.github.io/images/4003.png" title="Caption" ></p>

<p>创建新版本模型文件</p>

<p>添加完成后，会发现之前的模型文件会变成一个文件夹，里面包含着多个模型文件。</p>

<p><img src="http://al1020119.github.io/images/4004.png" title="Caption" >
模型文件夹</p>

<p>在新建的模型文件中，里面的文件结构和之前的文件结构相同。后续的修改都应该在新的模型文件上，之前的模型文件不要再动了，在修改完模型文件后，记得更新对应的模型类文件。</p>

<p>基于新的模型文件，对Employee实体做如下修改，下面的版本迁移也以此为例。</p>

<p><img src="http://al1020119.github.io/images/4005.png" title="Caption" ></p>

<p>修改之前</p>

<p>添加一个String类型的属性，设置属性名为sectionName。</p>

<p><img src="http://al1020119.github.io/images/4006.png" title="Caption" ></p>

<p>修改之后</p>

<p>此时还应该选中模型文件，设置当前模型文件的版本。这里选择将最新版本设置为刚才新建的1.1.0版本，模型文件设置工作完成。</p>

<pre><code>Show The File Inspector -&gt; Model Version -&gt; Current 设置为最新版本。
</code></pre>

<p><img src="http://al1020119.github.io/images/4007.png" title="Caption" ></p>

<p>设置版本</p>

<p>对模型文件的设置已经完成了，接下来系统还要知道我们想要怎样迁移数据。在迁移过程中可能会存在多种可能，苹果将这个灵活性留给了我们完成。剩下要做的就是编写迁移方案以及细节的代码。</p>

<p>轻量级版本迁移</p>

<p>轻量级版本迁移方案非常简单，大多数迁移工作都是由系统完成的，只需要告诉系统迁移方式即可。在持久化存储协调器(PSC)初始化对应的持久化存储(NSPersistentStore)对象时，设置options参数即可，参数是一个字典。PSC会根据传入的字典，自动推断版本迁移的过程。</p>

<p>字典中设置的key：</p>

<pre><code>    NSMigratePersistentStoresAutomaticallyOption设置为YES，CoreData会试着把低版本的持久化存储区迁移到最新版本的模型文件。

    NSInferMappingModelAutomaticallyOption设置为YES，CoreData会试着以最为合理地方式自动推断出源模型文件的实体中，某个属性到底对应于目标模型文件实体中的哪一个属性。
</code></pre>

<p>版本迁移的设置是在创建MOC时给PSC设置的，为了使代码更直观，下面只给出发生变化部分的代码，其他MOC的初始化代码都不变。</p>

<pre><code>// 设置版本迁移方案
NSDictionary *options = @{NSMigratePersistentStoresAutomaticallyOption : @YES,
                                NSInferMappingModelAutomaticallyOption : @YES};
// 创建持久化存储协调器，并将迁移方案的字典当做参数传入
[coordinator addPersistentStoreWithType:NSSQLiteStoreType configuration:nil URL:[NSURL fileURLWithPath:dataPath] options:options error:nil];
</code></pre>

<p>修改实体名</p>

<p>假设需要对已存在实体进行改名操作，需要将重命名后的实体Renaming ID，设置为之前的实体名。下面是Employee实体进行操作。</p>

<p><img src="http://al1020119.github.io/images/4008.png" title="Caption" ></p>

<p>修改实体名</p>

<p>修改后再使用实体时，应该将实体名设为最新的实体名，这里也就是Employee2，而且数据库中的数据也会迁移到Employee2表中。</p>

<pre><code>Employee2 *emp = [NSEntityDescription insertNewObjectForEntityForName:@"Employee2" inManagedObjectContext:context];
emp.name = @"lxz";
emp.brithday = [NSDate date];
emp.height = @1.9;
[context save:nil];
</code></pre>

<p>Mapping Model 迁移方案</p>

<p>轻量级迁移方案只是针对增加和改变实体、属性这样的一些简单操作，假设有更复杂的迁移需求，就应该使用Xcode提供的迁移模板(Mapping Model)。通过Xcode创建一个后缀为.xcmappingmodel的文件，这个文件是专门用来进行数据迁移用的，一些变化关系也会体现在模板中，看起来非常直观。</p>

<p>这里还以上面更改实体名，并迁移实体数据为例子，将Employee实体迁移到Employee2中。首先将Employee实体改名为Employee2，然后创建Mapping Model文件。</p>

<p>Command + N 新建文件 -> 选择 Mapping Model -> 选择源文件 Source Model -> 选择目标文件 Target Model -> 命名 Mapping Model 文件名 -> Create 创建完成。</p>

<p><img src="http://al1020119.github.io/images/4009.png" title="Caption" ></p>

<p>Mapping Model 文件</p>

<p>现在就创建好一个Mapping Model文件，文件中显示了实体、属性、Relationships，源文件和目标文件之间的关系。实体命名是EntityToEntity的方式命名的，实体包含的属性和关联关系，都会被添加到迁移方案中(Entity Mapping，Attribute Mapping，Relationship Mapping)。</p>

<p>在迁移文件的下方是源文件和目标文件的关系。</p>

<p><img src="http://al1020119.github.io/images/4010.png" title="Caption" ></p>

<p>对应关系</p>

<p>在上面图中改名后的Employee2实体并没有迁移关系，由于是改名后的实体，系统还不知道实体应该怎样做迁移。所以选中Mapping Model文件的Employee2 Mappings，可以看到右侧边栏的Source为invalid value。因为要从Employee实体迁移数据过来，所以将其选择为Employee，迁移关系就设置完成了。</p>

<p>设置完成后，还应该将之前EmployeeToEmployee的Mappings删除，因为这个实体已经被Employee2替代，它的Mappings也被Employee2 Mappings所替代，否则会报错。</p>

<p><img src="http://al1020119.github.io/images/4011.png" title="Caption" ></p>

<p>设置迁移关系</p>

<p>在实体的迁移过程中，还可以通过设置Predicate的方式，来简单的控制迁移过程。例如只需要迁移一部分指定的数据，就可以通过Predicate来指定。可以直接在右侧Filter Predicate的位置设置过滤条件，格式是$source.height &lt; 100，$source代表数据源的实体。</p>

<p><img src="http://al1020119.github.io/images/4012.png" title="Caption" ></p>

<p>Filter Predicate</p>

<p>更复杂的迁移需求</p>

<p>如果还存在更复杂的迁移需求，而且上面的迁移方式不能满足，可以考虑更复杂的迁移方式。假设要在迁移过程中，对迁移的数据进行更改，这时候上面的迁移方案就不能满足需求了。</p>

<p>对于上面提到的问题，在Mapping Model文件中选中实体，可以看到Custom Policy这个选项，选项对应的是NSEntityMigrationPolicy的子类，可以创建并设置一个子类，并重写这个类的方法来控制迁移过程。</p>

<pre><code>- (BOOL)createDestinationInstancesForSourceInstance:(NSManagedObject *)sInstance entityMapping:(NSEntityMapping *)mapping manager:(NSMigrationManager *)manager error:(NSError **)error;
</code></pre>

<p>版本迁移总结</p>

<p>版本迁移在需求的变更中肯定是要发生的，但是我们应该尽量避免这样的情况发生。在最开始设计模型文件数据结构的时候，就应该设计一个比较完善并且容易应对变化的结构，这样后面就算发生变化也不会对结构主体造成大的改动。</p>

<pre><code>Q Q：2211523682/790806573

微信：18370997821/13148454507

微博WB:http://weibo.com/u/3288975567?is_hot=1

git博文：http://al1020119.github.io/

github：https://github.com/al1020119
</code></pre>

<p><img src="http://al1020119.github.io/images/iCocosCoder.jpg" title="Caption" ></p>

<p><img src="http://al1020119.github.io/images/iCocosPublic.jpg" title="Caption" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CoreData还有撒？]]></title>
    <link href="http://al1020119.github.io/blog/2016/07/04/coredatechaiyousa/"/>
    <updated>2016-07-04T06:59:42+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/07/04/coredatechaiyousa</id>
    <content type="html"><![CDATA[<p>之前两篇文章都比较偏理论，文字表达比较多一些，但都是干货！学习时先理解理论知识，才能更好的帮助后面的理解。在这篇文章中，将会涉及关于CoreData的一些复杂操作，这些操作会涉及分页查询、模糊查询、批处理等高级操作。通过这些操作可以更好的使用CoreData，提升CoreData性能。文章中将会出现大量示例代码，通过代码的方式更有助于理解。</p>

<p>文章内容还会比较多，希望各位耐心看完。文章中如有疏漏或错误，还请各位及时提出，谢谢！</p>

<p>NSPredicate</p>

<!--more-->


<p>概述</p>

<p>在iOS开发过程中，很多需求都需要用到过滤条件。例如过滤一个集合对象中存储的对象，可以通过Foundation框架下的NSPredicate类来执行这个操作。</p>

<p>CoreData中可以通过设置NSFetchRequest类的predicate属性，来设置一个NSPredicate类型的谓词对象当做过滤条件。通过设置这个过滤条件，可以只获取符合过滤条件的托管对象，不会将所有托管对象都加载到内存中。这样是非常节省内存和加快查找速度的，设计一个好的NSPredicate可以优化CoreData搜索性能。</p>

<p>语法</p>

<p>NSPredicate更加偏向于自然语言，不像SQLite一样有很多固定的语法，看起来也更加清晰易懂。例如下面需要查找条件为年龄30岁以上，并且包括30岁的条件。
1</p>

<pre><code>[NSPredicate predicateWithFormat:@"age &gt;= 30"]
</code></pre>

<p>过滤集合对象</p>

<p>可以通过NSPredicate对iOS中的集合对象执行过滤操作，可以是NSArray、NSSet及其子类。</p>

<p>对不可变数组NSArray执行的过滤，过滤后会返回一个NSArray类型的结果数组，其中存储着符合过滤条件的对象。
1</p>

<pre><code>NSArray *results = [array filteredArrayUsingPredicate:predicate]
</code></pre>

<p>对可变数组NSMutableArray执行的过滤条件，过滤后会直接改变原集合对象内部存储的对象，删除不符合条件的对象。
1</p>

<pre><code>[arrayM filterUsingPredicate:predicate]
</code></pre>

<p>复合过滤条件</p>

<p>谓词不只可以过滤简单条件，还可以过滤复杂条件，设置复合过滤条件。
1</p>

<pre><code>[NSPredicate predicateWithFormat:@"(age &lt; 25) AND (firstName = XiaoZhuang)"]
</code></pre>

<p>当然也可以通过NSCompoundPredicate对象来设置复合过滤条件，返回结果是一个NSPredicate的子类NSCompoundPredicate对象。
1</p>

<pre><code>[[NSCompoundPredicate alloc] initWithType:NSAndPredicateType subpredicates:@[predicate1, predicate2]]
</code></pre>

<p>枚举值NSCompoundPredicateType参数，可以设置三种复合条件，枚举值非常直观很容易看懂。</p>

<pre><code>NSNotPredicateType

NSAndPredicateType

NSOrPredicateType
</code></pre>

<p>基础语法</p>

<p>下面是列举的一些NSPredicate的基础语法，这些语法看起来非常容易理解，更复杂的用法可以去看苹果的官方API。</p>

<p><img src="http://al1020119.github.io/images/3001.png" title="Caption" ></p>

<p>正则表达式</p>

<p>NSPredicate中还可以使用正则表达式，可以通过正则表达式完成一些复杂需求，这使得谓词的功能更加强大，例如下面是一个手机号验证的正则表达式。
1
2</p>

<pre><code>NSString *mobile = @"^1(3[0-9]|5[0-35-9]|8[025-9])\\d{8}$";
NSPredicate *regexmobile = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", mobile];
</code></pre>

<p>模糊查询</p>

<p>NSPredicate支持对数据的模糊查询，例如下面使用通配符来匹配包含lxz的结果，具体CoreData中的使用在下面会讲到。
1</p>

<pre><code>[NSPredicate predicateWithFormat:@"name LIKE %@", @"*lxz*"]
</code></pre>

<p>keyPath</p>

<p>NSPredicate在创建查询条件时，还支持设置被匹配目标的keyPath，也就是设置更深层被匹配的目标。例如下面设置employee的name属性为查找条件，就是用点语法设置的keyPath。
1</p>

<pre><code>[NSPredicate predicateWithFormat:@"employee.name = %@", @"lxz"]
</code></pre>

<p>设置查询条件</p>

<p>在之前的文章中，执行下面MOC的fetchRequest方法，一般都需要传入一个NSFetchRequest类型的参数。这个request参数可以做一些设置操作，这样就可以以较优的性能获取指定的数据。
1</p>

<pre><code>- (nullable NSArray *)executeFetchRequest:(NSFetchRequest *)request error:(NSError **)error;
</code></pre>

<p>NSFetchRequest</p>

<p>在执行fetch操作前，可以给NSFetchRequest设置一些参数，这些参数包括谓词、排序等条件，下面是一些基础的设置。</p>

<pre><code>设置查找哪个实体，从数据库的角度来看就是查找哪张表，通过fetchRequestWithEntityName:或初始化方法来指定表名。

通过NSPredicate类型的属性，可以设置查找条件，这个属性在开发中用得最多。NSPredicate可以包括固定格式的条件以及正则表达式。

通过sortDescriptors属性，可以设置获取结果数组的排序方式，这个属性是一个数组类型，也就是可以设置多种排序条件。(但是注意条件不要冲突)

通过fetchOffset属性设置从查询结果的第几个开始获取，通过fetchLimit属性设置每次获取多少个。主要用于分页查询，后面会讲。
</code></pre>

<p>MOC执行fetch操作后，获取的结果是以数组的形式存储的，数组中存储的就是托管对象。NSFetchRequest提供了参数resultType，参数类型是一个枚举类型。通过这个参数，可以设置执行fetch操作后返回的数据类型。</p>

<pre><code>NSManagedObjectResultType: 返回值是NSManagedObject的子类，也就是托管对象，这是默认选项

NSManagedObjectIDResultType: 返回NSManagedObjectID类型的对象，也就是NSManagedObject的ID，对内存占用比较小。MOC可以通过NSManagedObjectID对象获取对应的托管对象，并且可以通过缓存NSManagedObjectID参数来节省内存消耗

NSDictionaryResultType: 返回字典类型对象

NSCountResultType: 返回请求结果的count值，这个操作是发生在数据库层级的，并不需要将数据加载到内存中
</code></pre>

<p>设置获取条件</p>

<pre><code>// 建立获取数据的请求对象，并指明操作Employee表
NSFetchRequest *request = [NSFetchRequest fetchRequestWithEntityName:@"Employee"];
// 设置请求条件，通过设置的条件，来过滤出需要的数据
NSPredicate *predicate = [NSPredicate predicateWithFormat:@"name = %@", @"lxz"];
request.predicate = predicate;
// 设置请求结果排序方式，可以设置一个或一组排序方式，最后将所有的排序方式添加到排序数组中
NSSortDescriptor *sort = [NSSortDescriptor sortDescriptorWithKey:@"height" ascending:YES];
// NSSortDescriptor的操作都是在SQLite层级完成的，不会将对象加载到内存中，所以对内存的消耗是非常小的
request.sortDescriptors = @[sort];
// 执行获取请求操作，获取的托管对象将会被存储在一个数组中并返回
NSError *error = nil;
NSArray *employees = [context executeFetchRequest:request error:&amp;error];
[employees enumerateObjectsUsingBlock:^(Employee * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
    NSLog(@"Employee Name : %@, Height : %@, Brithday : %@", obj.name, obj.height, obj.brithday);
}];
// 错误处理
if (error) {
    NSLog(@"CoreData Fetch Data Error : %@", error);
}
</code></pre>

<p>这里设置NSFetchRequest对象的一些请求条件，设置查找Employee表中name为lxz的数据，并且将所有符合的数据用height值升序的方式排列。</p>

<p>有实体关联关系</p>

<p>一个模型文件中的不同实体间，可以设置实体间的关联关系，这个在之前的文章中讲过。实体关联关系分为对一或对多，也可以设置是否双向关联。</p>

<p>这里演示的实体只是简单的To One的关系，并且下面会给出设置是否双向关联的区别对比。</p>

<p>插入实体</p>

<pre><code>// 创建托管对象，并将其关联到指定的MOC上
Employee *zsEmployee = [NSEntityDescription insertNewObjectForEntityForName:@"Employee" inManagedObjectContext:context];
zsEmployee.name = @"zhangsan";
zsEmployee.height = @1.9f;
zsEmployee.brithday = [NSDate date];
Employee *lsEmployee = [NSEntityDescription insertNewObjectForEntityForName:@"Employee" inManagedObjectContext:context];
lsEmployee.name = @"lisi";
lsEmployee.height = @1.7f;
lsEmployee.brithday = [NSDate date];
Department *iosDepartment = [NSEntityDescription insertNewObjectForEntityForName:@"Department" inManagedObjectContext:context];
iosDepartment.departName = @"iOS";
iosDepartment.createDate = [NSDate date];
iosDepartment.employee = zsEmployee;
Department *androidDepartment = [NSEntityDescription insertNewObjectForEntityForName:@"Department" inManagedObjectContext:context];
androidDepartment.departName = @"android";
androidDepartment.createDate = [NSDate date];
androidDepartment.employee = lsEmployee;
// 执行存储操作
NSError *error = nil;
if (context.hasChanges) {
    [context save:&amp;error];
}
// 错误处理
if (error) {
    NSLog(@"Association Table Add Data Error : %@", error);
}
</code></pre>

<p>上面创建了四个实体，并且将Employee都关联到Department上，完成关联操作后通过MOC存储到本地。</p>

<p>可以看到上面所有的托管对象创建时，都使用NSEntityDescription的insert方法创建，并和上下文建立关系。这时就想问了，我能直接采用传统的init方法创建吗？</p>

<p>会崩的！创建托管对象时需要指定MOC，在运行时动态的生成set、get方法。但是直接通过init方法初始化的对象，系统是不知道这里是需要系统自身生成set、get方法的，而且系统也不知道应该对应哪个MOC，会导致方法未实现的崩溃。所以就出现了开发中经常出现的错误，如下面崩溃信息：
1</p>

<pre><code>-[Employee setName:]: unrecognized selector sent to instance 0x7fa665900f60
</code></pre>

<p>双向关联</p>

<p>在上一篇文章中提到过双向关联的概念，也就是设置Relationship时Inverse是否为空。下面是Employee和Department在数据库中，设置inverse和没有设置inverse的两种数据存储，可以很清晰的对比出设置双向关联的区别。</p>

<p>测试代码还是用上面插入实体的代码，只是更改inverse选项。</p>

<p>设置双向关联</p>

<p><img src="http://al1020119.github.io/images/3002.png" title="Caption" ></p>

<p>Employee</p>

<p><img src="http://al1020119.github.io/images/3003.png" title="Caption" ></p>

<p>Department</p>

<p>未设置双向关联</p>

<p><img src="http://al1020119.github.io/images/3004.png" title="Caption" ></p>

<p>Employee</p>

<p><img src="http://al1020119.github.io/images/3005.png" title="Caption" ></p>

<p>Department</p>

<p>从图中可以看出，未设置双向关联的实体，Department关联Employee为属性并存储后，Department表中的关系是存在的，但Employee表中的关系依然是空的。而设置双向关联后的实体，在Department关联Employee为属性并存储后，Employee在表中自动设置了和Department的关系。</p>

<p>双向关联的关系不只体现在数据库中，在程序运行过程中托管对象的关联属性，也是随着发生变化的。双向关联的双方，一方的关联属性设置关系后，另一方关联属性的关系也会发生变化。用下面的代码打印一下各自的关联属性，结果和上面数据库的变化是一样的。
1</p>

<pre><code>NSLog(@"Department : %@, Employee : %@", androidDepartment.employee, lsEmployee.department);
</code></pre>

<p>查询操作</p>

<pre><code>// 创建获取数据的请求对象，并指明操作Department表
NSFetchRequest *request = [NSFetchRequest fetchRequestWithEntityName:@"Department"];
// 设置请求条件，设置employee的name为请求条件。NSPredicate的好处在于，可以设置keyPath条件
NSPredicate *predicate = [NSPredicate predicateWithFormat:@"employee.name = %@", @"lxz"];
request.predicate = predicate;
// 执行查找操作
NSError *error = nil;
NSArray *departments = [context executeFetchRequest:request error:&amp;error];
[departments enumerateObjectsUsingBlock:^(Department * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
    NSLog(@"Department Search Result DepartName : %@, employee name : %@", obj.departName, obj.employee.name);
}];
// 错误处理
if (error) {
    NSLog(@"Department Search Error : %@", error);
}
</code></pre>

<p>查找Department实体，并打印实体内容。就像上面讲的双向关系一样，有关联关系的实体，自己被查找出来后，也会将与之关联的其他实体也查找出来，并且查找出来的实体都是关联着MOC的。</p>

<p>分页查询</p>

<p>在从本地存储区获取数据时，可以指定从第几个获取，以及本次查询获取多少个数据，联合起来使用就是分页查询。当然也可以根据需求，单独使用这两个API。</p>

<p>这种需求在实际开发中非常常见，例如TableView中，上拉加载数据，每次加载20条数据，就可以利用分页查询轻松实现。</p>

<pre><code>// 创建获取数据的请求对象，并指明操作Employee表
NSFetchRequest *request = [NSFetchRequest fetchRequestWithEntityName:@"Employee"];
// 设置查找起始点，这里是从搜索结果的第六个开始获取
request.fetchOffset = 6;
// 设置分页，每次请求获取六个托管对象
request.fetchLimit = 6;
// 设置排序规则，这里设置身高升序排序
NSSortDescriptor *descriptor = [NSSortDescriptor sortDescriptorWithKey:@"height" ascending:YES];
request.sortDescriptors = @[descriptor];
// 执行查询操作
NSError *error = nil;
NSArray *employees = [context executeFetchRequest:request error:&amp;error];
[employees enumerateObjectsUsingBlock:^(Employee * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
    NSLog(@"Page Search Result Name : %@, height : %@", obj.name, obj.height);
}];
// 错误处理
if (error) {
    NSLog(@"Page Search Data Error : %@", error);
}
</code></pre>

<p>上面是一个按照身高升序排序，分页获取搜索结果的例子。查找Employee表中的实体，将结果按照height字段升序排序，并从结果的第六个开始查找，并且设置获取的数量也是六个。</p>

<p>模糊查询</p>

<p>有时需要获取具有某些相同特征的数据，这样就需要对查询的结果做模糊匹配。在CoreData执行模糊匹配时，可以通过NSPredicate执行这个操作。</p>

<pre><code>// 创建获取数据的请求对象，设置对Employee表进行操作
NSFetchRequest *request = [NSFetchRequest fetchRequestWithEntityName:@"Employee"];
// 创建模糊查询条件。这里设置的带通配符的查询，查询条件是结果包含lxz
NSPredicate *predicate = [NSPredicate predicateWithFormat:@"name LIKE %@", @"*lxz*"];
request.predicate = predicate;
// 执行查询操作
NSError *error = nil;
NSArray *employees = [context executeFetchRequest:request error:&amp;error];
[employees enumerateObjectsUsingBlock:^(Employee * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
    NSLog(@"Fuzzy Search Result Name : %@, height : %@", obj.name, obj.height);
}];
// 错误处理
if (error) {
    NSLog(@"Fuzzy Search Data Error : %@", error);
}
</code></pre>

<p>上面是使用通配符的方式进行模糊查询，NSPredicate支持多种形式的模糊查询，下面列举一些简单的匹配方式。模糊查询条件对大小写不敏感，所以查询条件大小写均可。</p>

<pre><code>以lxz开头
</code></pre>

<p>1</p>

<pre><code>NSPredicate *predicate = [NSPredicate predicateWithFormat:@"name BEGINSWITH %@", @"lxz"];

以lxz结尾
</code></pre>

<p>1</p>

<pre><code>NSPredicate *predicate = [NSPredicate predicateWithFormat:@"name ENDSWITH %@", @"lxz"];

其中包含lxz
</code></pre>

<p>1</p>

<pre><code>NSPredicate *predicate = [NSPredicate predicateWithFormat:@"name contains %@", @"lxz"];

查询条件结果包含lxz
</code></pre>

<p>1</p>

<pre><code>NSPredicate *predicate = [NSPredicate predicateWithFormat:@"name LIKE %@", @"*lxz*"];
</code></pre>

<p>加载请求模板</p>

<p>在之前的文章中谈到在模型文件中设置请求模板，也就是在.xcdatamodeld文件中，设置Fetch Requests，使用时可以通过对应的NSManagedObjectModel获取设置好的模板。</p>

<p>&hellip;. 省略上下文创建步骤 &hellip;.</p>

<pre><code>// 通过MOC获取模型文件对应的托管对象模型
NSManagedObjectModel *model = context.persistentStoreCoordinator.managedObjectModel;
// 通过.xcdatamodeld文件中设置的模板名，获取请求对象
NSFetchRequest *fetchRequest = [model fetchRequestTemplateForName:@"EmployeeFR"];
// 请求数据，下面的操作和普通请求一样
NSError *error = nil;
NSArray *dataList = [context executeFetchRequest:fetchRequest error:&amp;error];
[dataList enumerateObjectsUsingBlock:^(Employee * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
    NSLog(@"Employee.count = %ld, Employee.height = %f", dataList.count, [obj.height floatValue]);
}];
// 错误处理
if (error) {
    NSLog(@"Execute Fetch Request Error : %@", error);
}
</code></pre>

<p>获取结果Count值</p>

<p>开发过程中有时需要只获取所需数据的Count值，也就是执行获取操作后数组中所存储的对象数量。遇到这个需求，如果像之前一样MOC执行获取操作，获取到数组然后取Count，这样对内存消耗是很大的。</p>

<p>对于这个需求，苹果提供了两种常用的方式获取这个Count值。这两种获取操作，都是在数据库中完成的，并不需要将托管对象加载到内存中，对内存的开销也是很小的。</p>

<pre><code>方法1，设置resultType


// 设置过滤条件，可以根据需求设置自己的过滤条件
NSPredicate *predicate = [NSPredicate predicateWithFormat:@"height &lt; 2"];
// 创建请求对象，并指明操作Employee表
NSFetchRequest *fetchRequest = [NSFetchRequest fetchRequestWithEntityName:@"Employee"];
fetchRequest.predicate = predicate;
// 这一步是关键。设置返回结果类型为Count，返回结果为NSNumber类型
fetchRequest.resultType = NSCountResultType;
// 执行查询操作，返回的结果还是数组，数组中只存在一个对象，就是计算出的Count值
NSError *error = nil;
NSArray *dataList = [context executeFetchRequest:fetchRequest error:&amp;error];
NSInteger count = [dataList.firstObject integerValue];
NSLog(@"fetch request result Employee.count = %ld", count);
// 错误处理
if (error) {
    NSLog(@"fetch request result error : %@", error);
}
</code></pre>

<p>方法1中设置NSFetchRequest对象的resultType为NSCountResultType，获取到结果的Count值。这个枚举值在之前的文章中提到过，除了Count参数，还可以设置其他三种参数。</p>

<pre><code>方法2，使用MOC提供的方法


// 设置过滤条件
NSPredicate *predicate = [NSPredicate predicateWithFormat:@"height &lt; 2"];
// 创建请求对象，指明操作Employee表
NSFetchRequest *fetchRequest = [NSFetchRequest fetchRequestWithEntityName:@"Employee"];
fetchRequest.predicate = predicate;
// 通过调用MOC的countForFetchRequest:error:方法，获取请求结果count值，返回结果直接是NSUInteger类型变量
NSError *error = nil;
NSUInteger count = [context countForFetchRequest:fetchRequest error:&amp;error];
NSLog(@"fetch request result count is : %ld", count);
// 错误处理
if (error) {
    NSLog(@"fetch request result error : %@", error);
}
</code></pre>

<p>MOC提供了专门获取请求结果Count值的方法，通过这个方法可以直接返回一个NSUInteger类型的Count值，使用起来比上面的方法更方便点，其他都是一样的。</p>

<p>位运算</p>

<p>假设有需求是对Employee表中，所有托管对象的height属性计算总和。这个需求在数据量比较大的情况下，将所有托管对象加载到内存中是非常消耗内存的，就算批量加载也比较耗时耗内存。</p>

<p>CoreData对于这样的需求，提供了位运算的功能。MOC在执行请求时，是支持对数据进行位运算的。这个操作依然是在数据库层完成的，对内存的占用非常小。</p>

<pre><code>// 创建请求对象，指明操作Employee表
NSFetchRequest *fetchRequest = [NSFetchRequest fetchRequestWithEntityName:@"Employee"];
// 设置返回值为字典类型，这是为了结果可以通过设置的name名取出，这一步是必须的
fetchRequest.resultType = NSDictionaryResultType;
// 创建描述对象
NSExpressionDescription *expressionDes = [[NSExpressionDescription alloc] init];
// 设置描述对象的name，最后结果需要用这个name当做key来取出结果
expressionDes.name = @"sumOperatin";
// 设置返回值类型，根据运算结果设置类型
expressionDes.expressionResultType = NSFloatAttributeType;
// 创建具体描述对象，用来描述对那个属性进行什么运算(可执行的运算类型很多，这里描述的是对height属性，做sum运算)
NSExpression *expression = [NSExpression expressionForFunction:@"sum:" arguments:@[[NSExpression expressionForKeyPath:@"height"]]];
// 只能对应一个具体描述对象
expressionDes.expression = expression;
// 给请求对象设置描述对象，这里是一个数组类型，也就是可以设置多个描述对象
fetchRequest.propertiesToFetch = @[expressionDes];
// 执行请求，返回值还是一个数组，数组中只有一个元素，就是存储计算结果的字典
NSError *error = nil;
NSArray *resultArr = [context executeFetchRequest:fetchRequest error:&amp;error];
// 通过上面设置的name值，当做请求结果的key取出计算结果
NSNumber *number = resultArr.firstObject[@"sumOperatin"];
NSLog(@"fetch request result is %f", [number floatValue]);
// 错误处理
if (error) {
    NSLog(@"fetch request result error : %@", error);
}
</code></pre>

<p>执行结果：</p>

<p><img src="http://al1020119.github.io/images/3006.png" title="Caption" ></p>

<p>从执行结果可以看到，MOC对所有查找到的托管对象height属性执行了求和操作，并将结果放在字典中返回。位运算主要是通过NSFetchRequest对象的propertiesToFetch属性设置，这个属性可以设置多个描述对象，最后通过不同的name当做key来取出结果即可。</p>

<p>NSExpression类可以描述多种运算，可以在NSExpression.h文件中的注释部分，看到所有支持的运算类型，大概看了一下有二十多种运算。而且除了上面NSExpression调用的方法，此类还支持点语法的位运算，例如下面的例子。
1</p>

<pre><code>[NSExpression expressionWithFormat:@"@sum.height"];
</code></pre>

<p>批处理</p>

<p>在使用CoreData之前，我和公司同事也讨论过，假设遇到需要大量数据处理的时候怎么办。CoreData对于大量数据处理的灵活性肯定不如SQLite，这时候还需要自己使用其他方式优化数据处理。虽然在移动端这种情况很少出现，但是在持久层设计时还是要考虑这方面。</p>

<p>当需要进行数据的处理时，CoreData需要先将数据加载到内存中，然后才能对数据进行处理。这样对于大量数据来说，都加载到内存中是非常消耗内存的，而且容易导致崩溃的发生。如果遇到更改所有数据的某个字段这样的简单需求，需要将相关的托管对象都加载到内存中，然后进行更改、保存。</p>

<p>对于上面这样的问题，CoreData在iOS8推出了批量更新API，通过这个API可以直接在数据库一层就完成更新操作，而不需要将数据加载到内存。除了批量更新操作，在iOS9中还推出了批量删除API，也是在数据库一层完成的操作。关于批处理的API很多都是iOS8、iOS9出来的，使用时需要注意版本兼容。</p>

<p>但是有个问题，批量更新和批量删除的两个API，都是直接对数据库进行操作，更新完之后会导致MOC缓存和本地持久化数据不同步的问题。所以需要手动刷新受影响的MOC中存储的托管对象，使MOC和本地统一。假设你使用了NSFetchedResultsController，为了保证界面和数据的统一，这一步更新操作更需要做。</p>

<p>批量更新</p>

<pre><code>// 创建批量更新对象，并指明操作Employee表。
NSBatchUpdateRequest *updateRequest = [NSBatchUpdateRequest batchUpdateRequestWithEntityName:@"Employee"];
// 设置返回值类型，默认是什么都不返回(NSStatusOnlyResultType)，这里设置返回发生改变的对象Count值
updateRequest.resultType = NSUpdatedObjectsCountResultType;
// 设置发生改变字段的字典
updateRequest.propertiesToUpdate = @{@"height" : [NSNumber numberWithFloat:5.f]};
// 执行请求后，返回值是一个特定的result对象，通过result的属性获取返回的结果。MOC的这个API是从iOS8出来的，所以需要注意版本兼容。
NSError *error = nil;
NSBatchUpdateResult *result = [context executeRequest:updateRequest error:&amp;error];
NSLog(@"batch update count is %ld", [result.result integerValue]);
// 错误处理
if (error) {
    NSLog(@"batch update request result error : %@", error);
}
// 更新MOC中的托管对象，使MOC和本地持久化区数据同步
[context refreshAllObjects];
</code></pre>

<p>上面对Employee表中所有的托管对象height值做了批量更新，在更新时通过设置propertiesToUpdate字典来控制更新字段和更新的值，设置格式是字段名 : 新值。通过设置批处理对象的predicate属性，设置一个谓词对象来控制受影响的对象。</p>

<p>还可以对多个存储区(数据库)做同样批处理操作，通过设置其父类的affectedStores属性，类型是一个数组，可以包含受影响的存储区，多个存储区的操作对批量删除同样适用。</p>

<p>MOC在执行请求方法时，发现方法名也不一样了，执行的是executeRequest: error:方法，这个方法是从iOS8之后出来的。方法传入的参数是NSBatchUpdateRequest类，此类并不是继承自NSFetchRequest类，而是直接继承自NSPersistentStoreRequest，和NSFetchRequest是平级关系。</p>

<p>批量删除</p>

<pre><code>// 创建请求对象，并指明对Employee表做操作
NSFetchRequest *fetchRequest = [NSFetchRequest fetchRequestWithEntityName:@"Employee"];
// 通过谓词设置过滤条件，设置条件为height小于1.7
NSPredicate *predicate = [NSPredicate predicateWithFormat:@"height &lt; %f", 1.7f];
fetchRequest.predicate = predicate;
// 创建批量删除请求，并使用上面创建的请求对象当做参数进行初始化
NSBatchDeleteRequest *deleteRequest = [[NSBatchDeleteRequest alloc] initWithFetchRequest:fetchRequest];
// 设置请求结果类型，设置为受影响对象的Count
deleteRequest.resultType = NSBatchDeleteResultTypeCount;
// 使用NSBatchDeleteResult对象来接受返回结果，通过id类型的属性result获取结果
NSError *error = nil;
NSBatchDeleteResult *result = [context executeRequest:deleteRequest error:&amp;error];
NSLog(@"batch delete request result count is %ld", [result.result integerValue]);
// 错误处理
if (error) {
    NSLog(@"batch delete request error : %@", error);
}
// 更新MOC中的托管对象，使MOC和本地持久化区数据同步
[context refreshAllObjects];
</code></pre>

<p>大多数情况下，涉及到托管对象的操作，都需要将其加载到内存中完成。所以使用CoreData时，需要注意内存的使用，不要在内存中存在过多的托管对象。在已经做系统兼容的情况下，进行大量数据的操作时，应该尽量使用批处理来完成操作。</p>

<p>需要注意的是，refreshAllObjects是从iOS9出来的，在iOS9之前因为要做版本兼容，所以需要使用refreshObject: mergeChanges:方法更新托管对象。</p>

<p>异步请求</p>

<pre><code>// 创建请求对象，并指明操作Employee表
NSFetchRequest *fetchRequest = [NSFetchRequest fetchRequestWithEntityName:@"Employee"];
// 创建异步请求对象，并通过一个block进行回调，返回结果是一个NSAsynchronousFetchResult类型参数
NSAsynchronousFetchRequest *asycFetchRequest = [[NSAsynchronousFetchRequest alloc] initWithFetchRequest:fetchRequest completionBlock:^(NSAsynchronousFetchResult * _Nonnull result) {
    [result.finalResult enumerateObjectsUsingBlock:^(Employee * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
        NSLog(@"fetch request result Employee.count = %ld, Employee.name = %@", result.finalResult.count, obj.name);
    }];
}];
// 执行异步请求，和批量处理执行同一个请求方法
NSError *error = nil;
[context executeRequest:asycFetchRequest error:&amp;error];
// 错误处理
if (error) {
    NSLog(@"fetch request result error : %@", error);
}
</code></pre>

<p>上面通过NSAsynchronousFetchRequest对象创建了一个异步请求，并通过block进行回调。如果有多个请求同时发起，不需要担心线程安全的问题，系统会将所有的异步请求添加到一个操作队列中，在前一个任务访问数据库时，CoreData会将数据库加锁，等前面的执行完成才会继续执行后面的操作。</p>

<p>NSAsynchronousFetchRequest提供了cancel方法，也就是可以在请求过程中，将这个请求取消。还可以通过一个NSProgress类型的属性，获取请求完成进度。NSAsynchronousFetchRequest类从iOS8开始可以使用，所以低版本需要做版本兼容。</p>

<p>需要注意的是，执行请求时MOC并发类型不能是NSConfinementConcurrencyType，这个并发类型已经被抛弃，会导致崩溃。</p>

<pre><code>Q Q：2211523682/790806573

微信：18370997821/13148454507

微博WB:http://weibo.com/u/3288975567?is_hot=1

git博文：http://al1020119.github.io/

github：https://github.com/al1020119
</code></pre>

<p><img src="http://al1020119.github.io/images/iCocosCoder.jpg" title="Caption" ></p>

<p><img src="http://al1020119.github.io/images/iCocosPublic.jpg" title="Caption" ></p>
]]></content>
  </entry>
  
</feed>
