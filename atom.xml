<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[iOS梦工厂]]></title>
  <link href="http://al1020119.github.io/atom.xml" rel="self"/>
  <link href="http://al1020119.github.io/"/>
  <updated>2016-07-29T16:52:01+08:00</updated>
  <id>http://al1020119.github.io/</id>
  <author>
    <name><![CDATA[iCocos]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[福利：抢红包神器就是这么来的]]></title>
    <link href="http://al1020119.github.io/blog/2016/09/01/weixinhongbao/"/>
    <updated>2016-09-01T21:52:15+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/09/01/weixinhongbao</id>
    <content type="html"><![CDATA[<p>微信红包</p>

<p><img src="http://al1020119.github.io/images/weixinhongbao0001.jpg" title="Caption" ></p>

<p>别告诉我你对红包不感兴趣，如果真的是这样，那么请绕道，哈哈。</p>

<p>现在由于微信和QQ的普及，几乎所有用户都会使用红包这个功能，但是对于一个程序员来说，每看到一个好的功能都会努力试着研究一下，哪怕不能成功，由于看到了一篇比较看的文章，所以就专门花时间去搞一顿，结果大吃一惊。</p>

<p>最近有不少朋友找我要红包尾数的功能，我也不知道他们为什么要这个，可能是笔者太年轻了。但是我觉得这个可能不简单，而且这样的功能做好了也不能外漏，不然笔者的程序员职业生涯估计就到头了！</p>

<pre><code>前言：最近笔者在研究iOS逆向工程，顺便拿微信来练手，在非越狱手机上实现了微信自动抢红包的功能。
</code></pre>

<p>题外话：此教程是一篇严肃的学术探讨类文章，仅仅用于学习研究，也请读者不要用于商业或其他非法途径上，笔者一概不负责哟~~</p>

<p>好了，接下来可以进入正题了！</p>

<!--more-->


<h2>此教程所需要的工具/文件</h2>

<pre><code>yololib
class-dump
dumpdecrypted
iOSOpenDev
iTools
OpenSSH(Cydia)
iFile(Cydia)
Cycript(Cydia)
Command Line Tools
Xcode
苹果开发者证书或企业证书
一台越狱的iPhone
</code></pre>

<p>是的，想要实现在非越狱iPhone上达到自动抢红包的目的，工具用的可能是有点多（工欲善其事必先利其器^_^）。不过，没关系，大家可以按照教程的步骤一步一步来执行，不清楚的步骤可以重复实验，毕竟天上不会掉馅饼嘛。</p>

<h1>解密微信可执行文件(Mach-O)</h1>

<p>因为从Appstore下载安装的应用都是加密过的，所以我们需要用一些工具来为下载的App解密，俗称砸壳。这样才能便于后面分析App的代码结构。</p>

<p>首先我们需要一台已经越狱的iPhone手机(现在市面上越狱已经很成熟，具体越狱方法这里就不介绍了)。然后进入Cydia，安装OpenSSH、Cycript、iFile(调试程序时可以方便地查看日志文件)这三款软件。</p>

<pre><code>PS：笔者的手机是iPhone 6Plus，系统版本为iOS9.1。
</code></pre>

<p>在电脑上用iTunes上下载一个最新的微信，笔者当时下载的微信版本为6.3.13。下载完后，iTunes上会显示出已下载的app。</p>

<p>itnues</p>

<p><img src="http://al1020119.github.io/images/weixinhongbao0002.jpg" title="Caption" ></p>

<p>连上iPhone，用iTunes装上刚刚下载的微信应用。</p>

<p>打开Mac的终端，用ssh进入连上的iPhone(确保iPhone和Mac在同一个网段，笔者iPhone的IP地址为192.168.8.54)。OpenSSH的root密码默认为alpine。</p>

<p>ssh
<img src="http://al1020119.github.io/images/weixinhongbao0003.jpg" title="Caption" ></p>

<p>接下来就是需要找到微信的Bundle id了，，这里笔者有一个小技巧，我们可以把iPhone上的所有App都关掉，唯独保留微信，然后输入命令 ps -e</p>

<p>微信bundle id
<img src="http://al1020119.github.io/images/weixinhongbao0004.jpg" title="Caption" ><br/>
这样我们就找到了微信的可执行文件Wechat的具体路径了。接下来我们需要用Cycript找出微信的Documents的路径，输入命令cycript -p WeChat</p>

<p>cycript
<img src="http://al1020119.github.io/images/weixinhongbao0005.jpg" title="Caption" ></p>

<pre><code>编译dumpdecrypted
先记下刚刚我们获取到的两个路径(Bundle和Documents)，这时候我们就要开始用dumpdecrypted来为微信二进制文件(WeChat)砸壳了。
确保我们从Github上下载了最新的dumpdecrypted源码，进入dumpdecrypted源码的目录，编译dumpdecrypted.dylib，命令如下:
</code></pre>

<p>dumpdecrypted.dylib
<img src="http://al1020119.github.io/images/weixinhongbao0006.jpg" title="Caption" ><br/>
这样我们可以看到dumpdecrypted目录下生成了一个dumpdecrypted.dylib的文件。</p>

<pre><code>scp
拷贝dumpdecrypted.dylib到iPhone上，这里我们用到scp命令.
scp 源文件路径 目标文件路径 。具体如下：
</code></pre>

<p>scp
<img src="http://al1020119.github.io/images/weixinhongbao0007.jpg" title="Caption" ><br/>
    开始砸壳
    dumpdecrypted.dylib的具体用法是：DYLD_INSERT_LIBRARIES=/PathFrom/dumpdecrypted.dylib /PathTo</p>

<p>dumpdecrypted
<img src="http://al1020119.github.io/images/weixinhongbao0008.jpg" title="Caption" ><br/>
这样就代表砸壳成功了，当前目录下会生成砸壳后的文件，即WeChat.decrypted。同样用scp命令把WeChat.decrypted文件拷贝到电脑上,接下来我们要正式的dump微信的可执行文件了。</p>

<h1>dump微信可执行文件</h1>

<pre><code>从Github上下载最新的class-dump源代码，然后用Xcode编译即可生成class-dump(这里比较简单，笔者就不详细说明了)。

导出微信的头文件
使用class-dump命令,把刚刚砸壳后的WeChat.decrypted,导出其中的头文件。./class-dump -s -S -H ./WeChat.decrypted -o ./header6.3-arm64
</code></pre>

<p>导出的头文件
<img src="http://al1020119.github.io/images/weixinhongbao0009.jpg" title="Caption" ><br/>
这里我们可以新建一个Xcode项目，把刚刚导出的头文件加到新建的项目中，这样便于查找微信的相关代码。</p>

<p>微信的头文件
<img src="http://al1020119.github.io/images/weixinhongbao0010.jpg" title="Caption" ><br/>
找到CMessageMgr.h和WCRedEnvelopesLogicMgr.h这两文件，其中我们注意到有这两个方法：- (void)AsyncOnAddMsg:(id)arg1 MsgWrap:(id)arg2; ，- (void)OpenRedEnvelopesRequest:(id)arg1;。没错，接下来我们就是要利用这两个方法来实现微信自动抢红包功能。其实现原理是，通过hook微信的新消息函数，我们判断是否为红包消息，如果是，我们就调用微信的打开红包方法。这样就能达到自动抢红包的目的了。哈哈，是不是很简单，我们一起来看看具体是怎么实现的吧。</p>

<pre><code>新建一个dylib工程，因为Xcode默认不支持生成dylib，所以我们需要下载iOSOpenDev，安装完成后(Xcode7环境会提示安装iOSOpenDev失败，请参考iOSOpenDev安装问题)，重新打开Xcode，在新建项目的选项中即可看到iOSOpenDev选项了。
</code></pre>

<p>iOSOpenDev
<img src="http://al1020119.github.io/images/weixinhongbao0011.jpg" title="Caption" ><br/>
    dylib代码
    选择Cocoa Touch Library，这样我们就新建了一个dylib工程了，我们命名为autoGetRedEnv。</p>

<pre><code>删除autoGetRedEnv.h文件，修改autoGetRedEnv.m为autoGetRedEnv.mm，然后在项目中加入CaptainHook.h

因为微信不会主动来加载我们的hook代码，所以我们需要把hook逻辑写到构造函数中。

__attribute__((constructor)) static void entry()
{
  //具体hook方法
}

hook微信的AsyncOnAddMsg: MsgWrap:方法，实现方法如下：

//声明CMessageMgr类
CHDeclareClass(CMessageMgr);
CHMethod(2, void, CMessageMgr, AsyncOnAddMsg, id, arg1, MsgWrap, id, arg2)
{
  //调用原来的AsyncOnAddMsg:MsgWrap:方法
  CHSuper(2, CMessageMgr, AsyncOnAddMsg, arg1, MsgWrap, arg2);
  //具体抢红包逻辑
  //...
  //调用原生的打开红包的方法
  //注意这里必须为给objc_msgSend的第三个参数声明为NSMutableDictionary,不然调用objc_msgSend时，不会触发打开红包的方法
  ((void (*)(id, SEL, NSMutableDictionary*))objc_msgSend)(logicMgr, @selector(OpenRedEnvelopesRequest:), params);
}
__attribute__((constructor)) static void entry()
{
  //加载CMessageMgr类
  CHLoadLateClass(CMessageMgr);
  //hook AsyncOnAddMsg:MsgWrap:方法
  CHClassHook(2, CMessageMgr, AsyncOnAddMsg, MsgWrap);
}

    项目的全部代码，笔者已放入Github中。

完成好具体实现逻辑后，就可以顺利生成dylib了。
</code></pre>

<h1>重新打包微信App</h1>

<pre><code>为微信可执行文件注入dylib
要想微信应用运行后，能执行我们的代码，首先需要微信加入我们的dylib，这里我们用到一个dylib注入神器:yololib，从网上下载源代码，编译后得到yololib。

使用yololib简单的执行下面一句就可以成功完成注入。注入之前我们先把之前保存的WeChat.decrypted重命名为WeChat，即已砸完壳的可执行文件。
./yololib 目标可执行文件 需注入的dylib
注入成功后即可见到如下信息：

dylib注入
</code></pre>

<p><img src="http://al1020119.github.io/images/weixinhongbao0012.jpg" title="Caption" ><br/>
    新建Entitlements.plist</p>

<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;
&lt;plist version="1.0"&gt;
&lt;dict&gt;
  &lt;key&gt;application-identifier&lt;/key&gt;
  &lt;string&gt;123456.com.autogetredenv.demo&lt;/string&gt;
  &lt;key&gt;com.apple.developer.team-identifier&lt;/key&gt;
  &lt;string&gt;123456&lt;/string&gt;
  &lt;key&gt;get-task-allow&lt;/key&gt;
  &lt;true/&gt;
  &lt;key&gt;keychain-access-groups&lt;/key&gt;
  &lt;array&gt;
      &lt;string&gt;123456.com.autogetredenv.demo&lt;/string&gt;
  &lt;/array&gt;
&lt;/dict&gt;
&lt;/plist&gt;

这里大家也许不清楚自己的证书Teamid及其他信息，没关系，笔者这里有一个小窍门，大家可以找到之前用开发者证书或企业证书打包过的App(例如叫Demo)，然后在终端中输入以下命令即可找到相关信息，命令如下：
./ldid -e ./Demo.app/demo

给微信重新签名
接下来把我们生成的dylib(libautoGetRedEnv.dylib)、刚刚注入dylib的WeChat、以及embedded.mobileprovision文件(可以在之前打包过的App中找到)拷贝到WeChat.app中。

命令格式：codesign -f -s 证书名字 目标文件

    PS:证书名字可以在钥匙串中找到

分别用codesign命令来为微信中的相关文件签名,具体实现如下：

重新签名
</code></pre>

<p><img src="http://al1020119.github.io/images/weixinhongbao0013.jpg" title="Caption" ><br/>
    打包成ipa
    给微信重新签名后，我们就可以用xcrun来生成ipa了，具体实现如下：
    xcrun -sdk iphoneos PackageApplication -v WeChat.app  -o ~/WeChat.ipa</p>

<h1>安装拥有抢红包功能的微信</h1>

<p>以上步骤如果都成功实现的话，那么真的就是万事俱备，只欠东风了~~~</p>

<p>我们可以使用iTools工具，来为iPhone(此iPhone Device id需加入证书中)安装改良过的微信了。</p>

<p>iTools
<img src="http://al1020119.github.io/images/weixinhongbao0014.jpg" title="Caption" ></p>

<h1>大工告成！！</h1>

<p>好了，我们可以看看hook过的微信抢红包效果了~</p>

<p>自动抢红包
<img src="http://al1020119.github.io/images/weixinhongbao0015.gif" title="Caption" ><br/>
哈哈，是不是觉得很爽啊，"妈妈再也不用担心我抢红包了。"。大家如果有兴趣可以继续hook微信的其他函数，这样既加强了学习，又满足了自己的特(zhuang)殊(bi)需求嘛。</p>

<p>教程中所涉及到的工具及源代码笔者都上传到Github上。
Github地址</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[重整之道（面试+技术+底层+高级）]]></title>
    <link href="http://al1020119.github.io/blog/2016/08/26/chongzhengzhidao/"/>
    <updated>2016-08-26T13:53:19+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/08/26/chongzhengzhidao</id>
    <content type="html"><![CDATA[<!--more-->


<p>重整之道（面试+技术+底层+高级）</p>

<p>不要问我为什么写这篇文章。</p>

<p>我，就是这么有尿性。。。。。。。。。。</p>

<p>前面三部分已经基本上完成，后面部分会陆续更新，敬请期待。但是光靠一篇这么短的文章想将通这些事不可能的，这里主要正对面试族，或者健忘族，亦或者是装逼族。好了废话不多说，我们开始吧！</p>

<ul>
<li>运行时（底层）</li>
<li>RunLoop（底层）</li>
<li>多线程（底层与安全）</li>
</ul>


<hr />

<ul>
<li>网络（底层与安全）</li>
<li>数据持久化（各种使用与区别）（CoreData、SQLite）</li>
<li>Block（底层/__Block）</li>
<li>音视频</li>
<li>直播</li>
<li>安全</li>
<li>优化（性能、卡顿）</li>
<li>常见错误</li>
<li>常用技术</li>
<li>全栈相关</li>
<li>算法（常用、排序）</li>
<li>数据结构</li>
<li>设计模式（32中）</li>
<li>架构设计</li>
<li>逆向工程</li>
<li>实战应用</li>
</ul>


<h3>运行时（底层）</h3>

<h6>介绍</h6>

<p>runtime是一个c和汇编写的动态库(感谢Lision的指正)，是一套比较底层的C语言API，属于一个C语言库，平时我们所写的OC代码，最终都会转成runtime的C语言代码去执行。</p>

<p>这个系统主要做两件事 ：</p>

<ol>
<li>封装C语言的结构体和函数，让开发者在运行时创建、检查或者修改类、对象和方法等等。</li>
<li>传递消息，找出方法的最终执行代码。</li>
</ol>


<h6>常用关键字</h6>

<p>要想全面了解 Runtime 机制，我们必须先了解 Runtime 的一些术语，他们都对应着数据结构。</p>

<p>SEL</p>

<pre><code>它是selector在 Objc 中的表示(Swift 中是 Selector 类)。selector 是方法选择器，其实作用就和名字一样，日常生活中，我们通过人名辨别谁是谁，注意 Objc 在相同的类中不会有命名相同的两个方法。selector 对方法名进行包装，以便找到对应的方法实现。它的数据结构是：

typedef struct objc_selector *SEL;

我们可以看出它是个映射到方法的 C 字符串，你可以通过 Objc 编译器器命令@selector() 或者 Runtime 系统的 sel_registerName 函数来获取一个 SEL 类型的方法选择器。

注意：
不同类中相同名字的方法所对应的 selector 是相同的，由于变量的类型不同，所以不会导致它们调用方法实现混乱。
</code></pre>

<p>id</p>

<pre><code>id 是一个参数类型，它是指向某个类的实例的指针。定义如下：

以上定义，看到 objc_object 结构体包含一个 isa 指针，根据 isa 指针就可以找到对象所属的类。

注意：
isa 指针在代码运行时并不总指向实例对象所属的类型，所以不能依靠它来确定类型，要想确定类型还是需要用对象的 -class 方法。

PS:KVO 的实现机理就是将被观察对象的 isa 指针指向一个中间类而不是真实类型，详见:KVO章节。
</code></pre>

<p>Class</p>

<pre><code>typedef struct objc_class *Class;

Class 其实是指向 objc_class 结构体的指针。

一个运行时类中关联了它的父类指针、类名、成员变量、方法、缓存以及附属的协议。


由此可见，我们可以动态修改 *methodList 的值来添加成员方法，这也是 Category 实现的原理，同样解释了 Category 不能添加属性的原因。这里可以参考下美团技术团队的文章：深入理解 Objective-C: Category。

objc_ivar_list 结构体用来存储成员变量的列表，而 objc_ivar 则是存储了单个成员变量的信息；同理，objc_method_list 结构体存储着方法数组的列表，而单个方法的信息则由 objc_method 结构体存储。

值得注意的时，objc_class 中也有一个 isa 指针，这说明 Objc 类本身也是一个对象。为了处理类和对象的关系，Runtime 库创建了一种叫做 Meta Class(元类) 的东西，类对象所属的类就叫做元类。Meta Class 表述了类对象本身所具备的元数据。

我们所熟悉的类方法，就源自于 Meta Class。我们可以理解为类方法就是类对象的实例方法。每个类仅有一个类对象，而每个类对象仅有一个与之相关的元类。

当你发出一个类似 [NSObject alloc](类方法) 的消息时，实际上，这个消息被发送给了一个类对象(Class Object)，这个类对象必须是一个元类的实例，而这个元类同时也是一个根元类(Root Meta Class)的实例。所有元类的 isa 指针最终都指向根元类。

所以当 [NSObject alloc] 这条消息发送给类对象的时候，运行时代码 objc_msgSend() 会去它元类中查找能够响应消息的方法实现，如果找到了，就会对这个类对象执行方法调用。



super_class 指针，虚线时 isa 指针。而根元类的父类是 NSObject，isa指向了自己。而 NSObject 没有父类。

最后 objc_class 中还有一个 objc_cache ，缓存，它的作用很重要，后面会提到。
</code></pre>

<p>Method</p>

<pre><code>Method 代表类中某个方法的类型

typedef struct objc_method *Method;

objc_method 存储了方法名，方法类型和方法实现：

方法名类型为 SEL
方法类型 method_types 是个 char 指针，存储方法的参数类型和返回值类型
method_imp 指向了方法的实现，本质是一个函数指针
</code></pre>

<p>Ivar</p>

<pre><code>Ivar 是表示成员变量的类型。

typedef struct objc_ivar *Ivar;


其中 ivar_offset 是基地址偏移字节
</code></pre>

<p>IMP</p>

<pre><code>IMP在objc.h中的定义是：

typedef id (*IMP)(id, SEL, ...);

它就是一个函数指针，这是由编译器生成的。当你发起一个 ObjC 消息之后，最终它会执行的那段代码，就是由这个函数指针指定的。而 IMP 这个函数指针就指向了这个方法的实现。

如果得到了执行某个实例某个方法的入口，我们就可以绕开消息传递阶段，直接执行方法，这在后面 Cache 中会提到。

你会发现 IMP 指向的方法与 objc_msgSend 函数类型相同，参数都包含 id 和 SEL 类型。每个方法名都对应一个 SEL 类型的方法选择器，而每个实例对象中的 SEL 对应的方法实现肯定是唯一的，通过一组 id和 SEL 参数就能确定唯一的方法实现地址。

而一个确定的方法也只有唯一的一组 id 和 SEL 参数。
</code></pre>

<p>Cache</p>

<pre><code>typedef struct objc_cache *Cache

Cache 为方法调用的性能进行优化，每当实例对象接收到一个消息时，它不会直接在 isa 指针指向的类的方法列表中遍历查找能够响应的方法，因为每次都要查找效率太低了，而是优先在 Cache 中查找。

Runtime 系统会把被调用的方法存到 Cache 中，如果一个方法被调用，那么它有可能今后还会被调用，下次查找的时候就会效率更高。就像计算机组成原理中 CPU 绕过主存先访问 Cache 一样。
</code></pre>

<p>Property
    typedef struct objc_property *objc_property_t;//这个更常用</p>

<pre><code>可以通过class_copyPropertyList 和 protocol_copyPropertyList 方法获取类和协议中的属性：

注意：
返回的是属性列表，列表中每个元素都是一个 objc_property_t 指针
</code></pre>

<h6>动态特性</h6>

<pre><code>Objective-C具有相当多的动态特性，基本的，也是经常被提到和用到的有

    动态类型（Dynamic typing）
    动态绑定（Dynamic binding）
    动态加载（Dynamic loading）

动态类型：程序直到执行时才能确定所属的类。

id 数据类型，id 通用的对象类型，可以存储任意类型的对象，id后面没有号，它本身就是个指针，类似于void ，但只可以指向对象类型

静态类型与动态类型

    编译期检查与运行时检查
    静态类型在编译期就能检查出错误
    静态类型声明代码可读性好
    动态类型只有在运行时才能发现错误

动态绑定：程序直到执行时才能确定实际要调用的方法。

动态绑定所做的，即是在实例所属类确定后，将某些属性和相应的方法绑定到实例上。

说明：objective-c 中的BOOL实际上是一种对带符号的字符类型（signed char）的类型定义（typedef），它使用8位的存储空间。通过#define指令把YES定义为1，NO定义为0。

动态加载：根据需求加载所需要的资源

这点很容易理解，对于iOS开发来说，基本就是根据不同的机型做适配。最经典的例子就是在Retina设备上加载@2x的图片，而在老一些的普通屏设备上加载原图。随着Retina iPad的推出，和之后可能的Retina Mac的出现，这个特性相信会被越来越多地使用。
多态的出现时为了让不同的类能使用同名的方法。这个让程序的可读性大大提高，也降低了编程难度。

动态类型与动态绑定是为了解决随多态的便利而引起的弊端，有了动态类型与动态绑定，不用去考虑输出中的方法是哪个类型的方法，会自动判定。

而id类型的出现就是为了更好的承接动态类型与动态方法出来的返回值。
</code></pre>

<h6>常用方法</h6>

<p>Ivar <em>ivars = class_copyIvarList([iCocosObject class], &amp;count);
Method </em>met = class_copyMethodList([iCocosObject class], &amp;meth);
objc_property_t *xsL = class_copyPropertyList([iCocosObject class], &amp;xs);
Method ic =  class_getInstanceMethod(NSClassFromString(@&ldquo;<em>NSArrayM&rdquo;), @selector(iCocosobject:));
Method add =  class_getInstanceMethod(NSClassFromString(@&ldquo;</em>NSArrayM&rdquo;), @selector(addObject:));</p>

<pre><code>objc_msgSend : 给对象发送消息
class_copyMethodList : 遍历某个类所有的方法
class_copyIvarList : 遍历某个类所有的成员变量
class_..... 这是我们学习runtime必须知道的函数！
</code></pre>

<h6>属性与成员变量</h6>

<p>Ivar: 实例变量类型，是一个指向objc_ivar结构体的指针。objc_property_t：声明的属性的类型，是一个指向objc_property结构体的指针</p>

<ol>
<li>属性变量 是已经设置了 setter getter方法的 OC已经自己给设置了</li>
<li>属性变量 你每次调用 self.属性变量 的时候 都要调用getter或者setter方法
封装</li>
</ol>


<p>如果成员变量是private，程序中的其它对象很难直接访问该成员变量。如果是属性，相对更容易用父类方法读写属性。</p>

<p>性能</p>

<pre><code>成员变量地址可以根据实例的内存地址偏移寻址。而属性的读写都需要函数调用，相对更慢。
</code></pre>

<p>非基础类型</p>

<pre><code>对于复杂的C++类型，往往设为成员变量更合适，也许这种类型不支持copy，或者完全复制很麻烦。
</code></pre>

<p>多线程</p>

<pre><code>多线程环境下，为保证数据一致性，在需要同步执行的代码段更应该使用成员变量。如果对需要同步更新的数据用getter/setter 方法，数据更新效率低，会带来更多的获取锁请求失败。
</code></pre>

<p>程序正确性</p>

<pre><code>成员变量可以做直观的内存管理。属性可以一层层继承，还可以复写。容易出错。
</code></pre>

<p>二进制文件的体积</p>

<pre><code>默认用属性，会生成不必要的getter/setter 方法，程序体积会变大。
</code></pre>

<p>1.如果只是单纯的private变量，最好声明在implementation里.
2.如果是类的public属性，就用property写在.h文件里
3.如果自己内部需要setter和getter来实现一些东西，就在.m文件的类目里用property来声明</p>

<h6>消息机制消息机制</h6>

<pre><code>[obj makeText];==objc_msgSend(obj, @selector (makeText));


首先通过obj的isa指针找到obj对应的class。

首先检测这个 selector 是不是要忽略。比如 Mac OS X 开发，有了垃圾回收就不理会 retain，release 这些函数。
检测这个 selector 的 target 是不是 nil，Objc 允许我们对一个 nil 对象执行任何方法不会 Crash，因为运行时会被忽略掉。
如果上面两步都通过了，那么就开始查找这个类的实现 IMP，
在Class中先去cache中 通过SEL查找对应函数method，找到就执行对应的实现。
若cache中未找到，再去methodList中查找，找到就执行对应的实现。
若methodlist中未找到，则取superClass中查找（重复执行以上两个步骤），直到找到最根的类为止。
若任何一部能找到，则将method加 入到cache中，以方便下次查找，并通过method中的函数指针跳转到对应的函数中去执行。
如果以上都不能找到，则会开始进行消息转发
</code></pre>

<h6>消息转发</h6>

<pre><code>1.动态方法解析：向当前类发送 resolveInstanceMethod: 信号，检查是否动态向该类添加了方法。（迷茫请搜索：@dynamic）
2.快速消息转发：检查该类是否实现了 forwardingTargetForSelector: 方法，若实现了则调用这个方法。若该方法返回值对象非nil或非self，则向该返回对象重新发送消息。
3.标准消息转发：runtime发送methodSignatureForSelector:消息获取Selector对应的方法签名。返回值非空则通过forwardInvocation:转发消息，返回值为空则向当前对象发送doesNotRecognizeSelector:消息，程序崩溃退出

总结就是：
在一个函数找不到时，OC提供了三种方式去补救：
1、调用resolveInstanceMethod给个机会让类添加这个实现这个函数
2、调用forwardingTargetForSelector让别的对象去执行这个函数
3、调用forwardInvocation（函数执行器）灵活的将目标函数以其他形式执行。
如果都不中，调用doesNotRecognizeSelector抛出异常。
</code></pre>

<h6>常见用途</h6>

<ul>
<li>增加，删除，修改一个类，属性，成员变量，方法</li>
</ul>


<h6>实际应用</h6>

<ul>
<li>关联对象</li>
<li>方法混淆</li>
<li>NSCoding(归档和解档, 利用runtime遍历模型对象的所有属性)</li>
<li>字典 &ndash;> 模型 (利用runtime遍历模型对象的所有属性, 根据属性名从字典中取出对应的值, 设置到模型的属性上)</li>
<li>KVO(利用runtime动态产生一个类)</li>
<li>用于封装框架(想怎么改就怎么改) 这就是我们runtime机制的只要运用方向</li>
</ul>


<h3>RunLoop（底层）</h3>

<h6>RunLoop 的简单概述</h6>

<p>RunLoop:</p>

<pre><code>   Runloop是事件接收和分发机制的一个实现。

   Runloop提供了一种异步执行代码的机制，不能并行执行任务。

   在主队列中，Main RunLoop直接配合任务的执行，负责处理UI事件、定时器以及其他内核相关事件。
</code></pre>

<p>主要目的：</p>

<pre><code>   保证程序执行的线程不会被系统终止。   
</code></pre>

<p>使用Runloop ？</p>

<pre><code>   当需要和该线程进行交互的时候才会使用Runloop.


   每一个线程都有其对应的RunLoop，但是默认非主线程的RunLoop是没有运行的，需要为RunLoop添加至少一个事件源，然后去run它。


   一般情况下我们是没有必要去启用线程的RunLoop的，除非你在一个单独的线程中需要长久的检测某个事件。
</code></pre>

<p>主线程默认有Runloop。当自己启动一个线程，如果只是用于处理单一的事件，则该线程在执行完之后就退出了。所以当我们需要让该线程监听某项事务
时，就得让线程一直不退出，runloop就是这么一个循环，没有事件的时候，一直卡着，有事件来临了，执行其对应的函数。</p>

<pre><code>   RunLoop,正如其名所示,是线程进入和被线程用来相应事件以及调用事件处理函数的地方.需要在代码中使用控制语句实现RunLoop的循环,也就是说,需要代码提供while或者for循环来驱动RunLoop.


   在这个循环中,使用一个runLoop对象[NSRunloop currentRunloop]执行接收消息,调用对应的处理函数.


    Runloop接收两种源事件:input sources和timer sources。


   input sources 传递异步事件，通常是来自其他线程和不同的程序中的消息；


   timer sources(定时器) 传递同步事件（重复执行或者在特定时间上触发）。


   除了处理input sources，Runloop
</code></pre>

<p>也会产生一些关于本身行为的notificaiton。注册成为Runloop的observer，可以接收到这些notification，做一些额外
的处理。（使用CoreFoundation来成为runloop的observer）。</p>

<p>Runloop工作的特点:</p>

<pre><code>   1&gt;当有时间发生时,Runloop会根据具体的事件类型通知应用程序作出相应;


   2&gt;当没有事件发生时,Runloop会进入休眠状态,从而达到省电的目的;


   3&gt;当事件再次发生时,Runloop会被重新唤醒,处理事件.
</code></pre>

<p>提示:一般在开发中很少会主动创建Runloop,而通常会把事件添加到Runloop中.</p>

<p>苹果提供了两个途径来获取分别是Cocoe里面定义的NSRunLoop以及CoreFoundation里面定义的CFRunLoopRef。</p>

<pre><code>CFRunLoopRef提供了纯C函数的API，所有这些API都是线程安全的。
NSRunLoop提供了面向对象的API，但这些API不是线程安全的。
</code></pre>

<h6>RunLoop 与线程的关系</h6>

<p>iOS 开发中能遇到两个线程对象: pthread_t 和 NSThread。过去苹果有份文档标明了 NSThread 只是 pthread_t 的封装，但那份文档已经失效了，现在它们也有可能都是直接包装自最底层的 mach thread。苹果并没有提供这两个对象相互转换的接口，但不管怎么样，可以肯定的是 pthread_t 和 NSThread 是一一对应的。比如，你可以通过 pthread_main_np() 或 [NSThread mainThread] 来获取主线程；也可以通过 pthread_self() 或 [NSThread currentThread] 来获取当前线程。CFRunLoop 是基于 pthread 来管理的。</p>

<p>苹果不允许直接创建 RunLoop，它只提供了两个自动获取的函数：CFRunLoopGetMain() 和 CFRunLoopGetCurrent()。</p>

<p>线程和 RunLoop 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 RunLoop（主线程除外）。</p>

<h6>RunLoop 的 Mode</h6>

<ol>
<li><p>kCFRunLoopDefaultMode: App的默认 Mode，通常主线程是在这个 Mode 下运行的。</p></li>
<li><p>UITrackingRunLoopMode: 界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响。</p></li>
<li><p>UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用。</p></li>
<li><p>GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到。</p></li>
<li><p>kCFRunLoopCommonModes: 这是一个占位的 Mode，没有实际作用。</p></li>
</ol>


<p>你可以在这里看到更多的苹果内部的 Mode，但那些 Mode 在开发中就很难遇到了。</p>

<p>一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。</p>

<h6>RunLoop 的底层实现(内部逻辑)</h6>

<p>RunLoop 的核心是基于 mach port 的，其进入休眠时调用的函数是 mach_msg()</p>

<p>RunLoop 的核心就是一个 mach_msg() (见上面代码的第7步)，RunLoop 调用这个函数去接收消息，如果没有别人发送 port 消息过来，内核会将线程置于等待状态。例如你在模拟器里跑起一个 iOS 的 App，然后在 App 静止时点击暂停，你会看到主线程调用栈是停留在 mach_msg_trap() 这个地方。</p>

<h6>应用</h6>

<ul>
<li><p>AutoreleasePool</p></li>
<li><p>事件响应</p></li>
<li><p>手势识别</p></li>
<li><p>界面更新</p></li>
<li><p>定时器</p></li>
<li><p>PerformSelecter</p></li>
<li><p>关于GCD</p></li>
<li><p>关于网络请求</p></li>
<li><p>AFNetworking</p></li>
<li><p>AsyncDisplayKit</p></li>
</ul>


<h3>多线程（底层与安全）</h3>

<p>线程：1个进程要想执行任务，必须得有线程.线程是进程的基本执行单元，一个进程（程序）的所有任务都在线程中执行</p>

<p>底层：Mach是第一个以多线程方式处理任务的系统，因此多线程的底层实现机制是基于Mach的线程。</p>

<pre><code> 1》C语言的POSIX接口：#include&lt;pthread.h&gt;POSIX线程（POSIX threads），简称Pthreads，是线程的POSIX标准。该标准定义了创建和操纵线程的一整套API。在类Unix操作系统（Unix、Linux、Mac OS X等）中，都使用Pthreads作为操作系统的线程
 2》OC的NSThread
 3》 C语言的GCD接口（性能最好，代码更精简）  
 4》  OC的NSOperation和NSOperationQueue（基于GCD）
</code></pre>

<p>好处：</p>

<pre><code>1、使用线程可以把程序中占据时间长的任务放到后台去处理，如图片、视频的下载

2、发挥多核处理器的优势，并发执行让系统运行的更快、更流畅，用户体验更好
</code></pre>

<p>缺点：</p>

<pre><code>1、大量的线程降低代码的可读性，

2、更多的线程需要更多的内存空间

3、当多个线程对同一个资源出现争夺的时候要注意线程安全的问题。
</code></pre>

<p>GCD内部怎么实现的</p>

<pre><code>  1》 iOS和OSX的核心是XNU内核（苹果电脑发展的操作系统内核），GCD是基于XNU内核实现的。
  2》GCD的API全部在libdispatch库中
  3》GCD的底层实现主要有：Dispatch Queue和Dispatch Source
    Dispatch Queue :管理block操作
    Dispatch Source：处理事件（比如说线程间的通信）
</code></pre>

<p>6.GCD和NSOperationQueue</p>

<pre><code>   1》GCD是纯C语言的API，NSOperationQueue是基于GCD的OC版本的封装
   2》GCD只支持FIFO的队列，NSOperationQueue可以很方便的调整执行顺序，可以添加依赖设置最大并发数量。
   3》GCD的执行速度比NSOperationQueue快
   4》NSOperationQueue支持KVO，可以检测Operation是否正在执行，是否结束，是否取消。
</code></pre>

<p>如何进行选择？
任务之间不太相互依赖，选用GCD；
任务之间有依赖，或者要监听任务的执行情况：NSOperationQueue</p>

<p>一、前言
     1》只在主线程刷新访问UI
     2》如果要防止资源抢夺，得用synchronize进行加锁保护。
     3》如果异步操作要保证线程安全等问题，尽量使用GCD。（GCD有些函数默认就是安全的）</p>

<p>前段时间看了几个开源项目，发现他们保持线程同步的方式各不相同，有@synchronized、NSLock、dispatch_semaphore、NSCondition、pthread_mutex、OSSpinLock。后来网上查了一下，发现他们的实现机制各不相同，性能也各不一样。不好意思，我们平常使用最多的@synchronized是性能最差的。下面我们先分别介绍每个加锁方式的使用，在使用一个案例来对他们进行性能对比。</p>

<p>二、介绍与使用</p>

<p>2.1、@synchronized</p>

<pre><code>NSObject *obj = [[NSObject alloc] init];
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    @synchronized(obj) {
       NSLog(@"需要线程同步的操作1 开始");
       sleep(3);
       NSLog(@"需要线程同步的操作1 结束");
    }
});
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    sleep(1);
    @synchronized(obj) {
       NSLog(@"需要线程同步的操作2");
    }
});
</code></pre>

<p>@synchronized(obj)指令使用的obj为该锁的唯一标识，只有当标识相同时，才为满足互斥，如果线程2中的@synchronized(obj)改为@synchronized(self),刚线程2就不会被阻塞，@synchronized指令实现锁的优点就是我们不需要在代码中显式的创建锁对象，便可以实现锁的机制，但作为一种预防措施，@synchronized块会隐式的添加一个异常处理例程来保护代码，该处理例程会在异常抛出的时候自动的释放互斥锁。所以如果不想让隐式的异常处理例程带来额外的开销，你可以考虑使用锁对象。</p>

<p>2.2、dispatch_semaphore</p>

<pre><code>dispatch_semaphore_t signal = dispatch_semaphore_create(1);
dispatch_time_t overTime = dispatch_time(DISPATCH_TIME_NOW, 3 * NSEC_PER_SEC);
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    dispatch_semaphore_wait(signal, overTime);
            NSLog(@"需要线程同步的操作1 开始");
            sleep(2);
            NSLog(@"需要线程同步的操作1 结束");
        dispatch_semaphore_signal(signal);
});
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        sleep(1);
        dispatch_semaphore_wait(signal, overTime);
            NSLog(@"需要线程同步的操作2");
        dispatch_semaphore_signal(signal);
});
</code></pre>

<p>dispatch_semaphore是GCD用来同步的一种方式，与他相关的共有三个函数，分别是dispatch_semaphore_create，dispatch_semaphore_signal，dispatch_semaphore_wait。</p>

<p>（1）dispatch_semaphore_create的声明为：</p>

<p>dispatch_semaphore_t dispatch_semaphore_create(long value);</p>

<p>传入的参数为long，输出一个dispatch_semaphore_t类型且值为value的信号量。</p>

<p>值得注意的是，这里的传入的参数value必须大于或等于0，否则dispatch_semaphore_create会返回NULL。</p>

<p>（2）dispatch_semaphore_signal的声明为：</p>

<p>long dispatch_semaphore_signal(dispatch_semaphore_t dsema);</p>

<p>这个函数会使传入的信号量dsema的值加1；</p>

<p>(3) dispatch_semaphore_wait的声明为：</p>

<p>long dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout);</p>

<p>这个函数会使传入的信号量dsema的值减1；这个函数的作用是这样的，如果dsema信号量的值大于0，该函数所处线程就继续执行下面的语句，并且将信号量的值减1；如果desema的值为0，那么这个函数就阻塞当前线程等待timeout（注意timeout的类型为dispatch_time_t，不能直接传入整形或float型数），如果等待的期间desema的值被dispatch_semaphore_signal函数加1了，且该函数（即dispatch_semaphore_wait）所处线程获得了信号量，那么就继续向下执行并将信号量减1。如果等待期间没有获取到信号量或者信号量的值一直为0，那么等到timeout时，其所处线程自动执行其后语句。</p>

<p>dispatch_semaphore 是信号量，但当信号总量设为 1 时也可以当作锁来。在没有等待情况出现时，它的性能比 pthread_mutex 还要高，但一旦有等待情况出现时，性能就会下降许多。相对于 OSSpinLock 来说，它的优势在于等待时不会消耗 CPU 资源。</p>

<p>如上的代码，如果超时时间overTime设置成>2，可完成同步操作。如果overTime&lt;2的话，在线程1还没有执行完成的情况下，此时超时了，将自动执行下面的代码。</p>

<p>2.3、NSLock</p>

<pre><code>NSLock *lock = [[NSLock alloc] init];
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    //[lock lock];
    [lock lockBeforeDate:[NSDate date]];
    NSLog(@"需要线程同步的操作1 开始");
    sleep(2);
    NSLog(@"需要线程同步的操作1 结束");
    [lock unlock];
});
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    sleep(1);
    if ([lock tryLock]) {//尝试获取锁，如果获取不到返回NO，不会阻塞该线程
        NSLog(@"锁可用的操作");
        [lock unlock];
    }else{
        NSLog(@"锁不可用的操作");
    }
    NSDate *date = [[NSDate alloc] initWithTimeIntervalSinceNow:3];
    if ([lock lockBeforeDate:date]) {//尝试在未来的3s内获取锁，并阻塞该线程，如果3s内获取不到恢复线程, 返回NO,不会阻塞该线程
        NSLog(@"没有超时，获得锁");
        [lock unlock];
    }else{
        NSLog(@"超时，没有获得锁");
    }
});
</code></pre>

<p>NSLock是Cocoa提供给我们最基本的锁对象，这也是我们经常所使用的，除lock和unlock方法外，NSLock还提供了tryLock和lockBeforeDate:两个方法，前一个方法会尝试加锁，如果锁不可用(已经被锁住)，刚并不会阻塞线程，并返回NO。lockBeforeDate:方法会在所指定Date之前尝试加锁，如果在指定时间之前都不能加锁，则返回NO。</p>

<pre><code>@protocol NSLocking
- (void)lock;
- (void)unlock;
@end
@interface NSLock : NSObject  {
@private
    void *_priv;
}
- (BOOL)tryLock;
- (BOOL)lockBeforeDate:(NSDate *)limit;
@property (nullable, copy) NSString *name NS_AVAILABLE(10_5, 2_0);
@end
</code></pre>

<p>2.4、NSRecursiveLock递归锁</p>

<pre><code>//NSLock *lock = [[NSLock alloc] init];
NSRecursiveLock *lock = [[NSRecursiveLock alloc] init];
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
       static void (^RecursiveMethod)(int);
       RecursiveMethod = ^(int value) {
       [lock lock];
         if (value &gt; 0) {
                NSLog(@"value = %d", value);
                sleep(1);
                RecursiveMethod(value - 1);
          }
         [lock unlock];
     };
     RecursiveMethod(5);
});
</code></pre>

<p>NSRecursiveLock实际上定义的是一个递归锁，这个锁可以被同一线程多次请求，而不会引起死锁。这主要是用在循环或递归操作中。</p>

<p>这段代码是一个典型的死锁情况。在我们的线程中，RecursiveMethod是递归调用的。所以每次进入这个block时，都会去加一次锁，而从第二次开始，由于锁已经被使用了且没有解锁，所以它需要等待锁被解除，这样就导致了死锁，线程被阻塞住了。调试器中会输出如下信息：</p>

<p>在这种情况下，我们就可以使用NSRecursiveLock。它可以允许同一线程多次加锁，而不会造成死锁。递归锁会跟踪它被lock的次数。每次成功的lock都必须平衡调用unlock操作。只有所有达到这种平衡，锁最后才能被释放，以供其它线程使用。</p>

<p>如果我们将NSLock代替为NSRecursiveLock，上面代码则会正确执行。</p>

<p>如果需要其他功能，源码定义如下：</p>

<pre><code>@interface NSRecursiveLock : NSObject  {
@private
    void *_priv;
}
- (BOOL)tryLock;
- (BOOL)lockBeforeDate:(NSDate *)limit;
@property (nullable, copy) NSString *name NS_AVAILABLE(10_5, 2_0);
@end
</code></pre>

<p>2.5、NSConditionLock条件锁</p>

<pre><code>NSMutableArray *products = [NSMutableArray array];
NSInteger HAS_DATA = 1;
NSInteger NO_DATA = 0;
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    while (1) {
        [lock lockWhenCondition:NO_DATA];
        [products addObject:[[NSObject alloc] init]];
        NSLog(@"produce a product,总量:%zi",products.count);
        [lock unlockWithCondition:HAS_DATA];
        sleep(1);
    }
});
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    while (1) {
       NSLog(@"wait for product");
        [lock lockWhenCondition:HAS_DATA];
       [products removeObjectAtIndex:0];
       NSLog(@"custome a product");
       [lock unlockWithCondition:NO_DATA];
    }
});
</code></pre>

<p>当我们在使用多线程的时候，有时一把只会lock和unlock的锁未必就能完全满足我们的使用。因为普通的锁只能关心锁与不锁，而不在乎用什么钥匙才能开锁，而我们在处理资源共享的时候，多数情况是只有满足一定条件的情况下才能打开这把锁：</p>

<p>在线程1中的加锁使用了lock，所以是不需要条件的，所以顺利的就锁住了，但在unlock的使用了一个整型的条件，它可以开启其它线程中正在等待这把钥匙的临界地，而线程2则需要一把被标识为2的钥匙，所以当线程1循环到最后一次的时候，才最终打开了线程2中的阻塞。但即便如此，NSConditionLock也跟其它的锁一样，是需要lock与unlock对应的，只是lock,lockWhenCondition:与unlock，unlockWithCondition:是可以随意组合的，当然这是与你的需求相关的。</p>

<p>如果你需要其他功能，源码定义如下：</p>

<pre><code>@interface NSConditionLock : NSObject  {
@private
    void *_priv;
}
- (instancetype)initWithCondition:(NSInteger)condition NS_DESIGNATED_INITIALIZER;
@property (readonly) NSInteger condition;
- (void)lockWhenCondition:(NSInteger)condition;
- (BOOL)tryLock;
- (BOOL)tryLockWhenCondition:(NSInteger)condition;
- (void)unlockWithCondition:(NSInteger)condition;
- (BOOL)lockBeforeDate:(NSDate *)limit;
- (BOOL)lockWhenCondition:(NSInteger)condition beforeDate:(NSDate *)limit;
@property (nullable, copy) NSString *name NS_AVAILABLE(10_5, 2_0);
@end
</code></pre>

<p>2.6、NSCondition</p>

<pre><code>NSCondition *condition = [[NSCondition alloc] init];
NSMutableArray *products = [NSMutableArray array];
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        while (1) {
            [condition lock];
            if ([products count] == 0) {
                NSLog(@"wait for product");
                [condition wait];
            }
            [products removeObjectAtIndex:0];
            NSLog(@"custome a product");
            [condition unlock];
        }
    });
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        while (1) {
            [condition lock];
            [products addObject:[[NSObject alloc] init]];
            NSLog(@"produce a product,总量:%zi",products.count);
            [condition signal];
            [condition unlock];
            sleep(1);
        }
});
</code></pre>

<p>一种最基本的条件锁。手动控制线程wait和signal。</p>

<p>[condition lock];一般用于多线程同时访问、修改同一个数据源，保证在同一时间内数据源只被访问、修改一次，其他线程的命令需要在lock 外等待，只到unlock ，才可访问</p>

<p>[condition unlock];与lock 同时使用</p>

<p>[condition wait];让当前线程处于等待状态</p>

<p>[condition signal];CPU发信号告诉线程不用在等待，可以继续执行</p>

<p>2.7、pthread_mutex</p>

<pre><code>__block pthread_mutex_t theLock;
pthread_mutex_init(&amp;theLock, NULL);
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        pthread_mutex_lock(&amp;theLock);
        NSLog(@"需要线程同步的操作1 开始");
        sleep(3);
        NSLog(@"需要线程同步的操作1 结束");
        pthread_mutex_unlock(&amp;theLock);
});
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        sleep(1);
        pthread_mutex_lock(&amp;theLock);
        NSLog(@"需要线程同步的操作2");
        pthread_mutex_unlock(&amp;theLock);
});
</code></pre>

<p>c语言定义下多线程加锁方式。</p>

<p>1：pthread_mutex_init(pthread_mutex_t mutex,const pthread_mutexattr_t attr);</p>

<p>初始化锁变量mutex。attr为锁属性，NULL值为默认属性。</p>

<p>2：pthread_mutex_lock(pthread_mutex_t mutex);加锁</p>

<p>3：pthread_mutex_tylock(<em>pthread_mutex_t </em>mutex);加锁，但是与2不一样的是当锁已经在使用的时候，返回为EBUSY，而不是挂起等待。</p>

<p>4：pthread_mutex_unlock(pthread_mutex_t *mutex);释放锁</p>

<p>5：pthread_mutex_destroy(pthread_mutex_t* mutex);使用完后释放</p>

<p>代码执行操作结果如下：</p>

<p>2.8、pthread_mutex(recursive)</p>

<pre><code> __block pthread_mutex_t theLock;
//pthread_mutex_init(&amp;theLock, NULL);
pthread_mutexattr_t attr;
pthread_mutexattr_init(&amp;attr);
pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE);
pthread_mutex_init(&amp;lock, &amp;attr);
pthread_mutexattr_destroy(&amp;attr);
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    static void (^RecursiveMethod)(int);
    RecursiveMethod = ^(int value) {
            pthread_mutex_lock(&amp;theLock);
            if (value &gt; 0) {
                NSLog(@"value = %d", value);
                sleep(1);
                RecursiveMethod(value - 1);
            }
            pthread_mutex_unlock(&amp;theLock);
     };
    RecursiveMethod(5);
});
</code></pre>

<p>这是pthread_mutex为了防止在递归的情况下出现死锁而出现的递归锁。作用和NSRecursiveLock递归锁类似。</p>

<p>如果使用pthread_mutex_init(&amp;theLock, NULL);初始化锁的话，上面的代码会出现死锁现象。如果使用递归锁的形式，则没有问题。</p>

<p>2.9、OSSpinLock</p>

<pre><code>__block OSSpinLock theLock = OS_SPINLOCK_INIT;
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    OSSpinLockLock(&amp;theLock);
    NSLog(@"需要线程同步的操作1 开始");
    sleep(3);
    NSLog(@"需要线程同步的操作1 结束");
    OSSpinLockUnlock(&amp;theLock);
});
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    OSSpinLockLock(&amp;theLock);
    sleep(1);
    NSLog(@"需要线程同步的操作2");
    OSSpinLockUnlock(&amp;theLock);
});
</code></pre>

<p>OSSpinLock 自旋锁，性能最高的锁。原理很简单，就是一直 do while 忙等。它的缺点是当等待时会消耗大量 CPU 资源，所以它不适用于较长时间的任务。 不过最近YY大神在自己的博客不再安全的 OSSpinLock中说明了OSSpinLock已经不再安全，请大家谨慎使用。</p>

<p>三、性能对比</p>

<pre><code>OSSpinLock和dispatch_semaphore的效率远远高于其他。

@synchronized和NSConditionLock效率较差。

鉴于OSSpinLock的不安全，所以我们在开发中如果考虑性能的话，建议使用dispatch_semaphore。

如果不考虑性能，只是图个方便的话，那就使用@synchronized。
</code></pre>

<h3>网络（底层与安全）</h3>

<h3>数据持久化（各种使用与区别）（CoreData、SQLite）</h3>

<h3>Block（底层/__Block）</h3>

<h3>音视频</h3>

<h3>直播</h3>

<h3>安全</h3>

<h3>优化（性能、卡顿）</h3>

<h3>常见错误</h3>

<h3>常用技术</h3>

<p>KVC</p>

<pre><code>KVC运用了一个isa-swizzling技术。isa-swizzling就是类型混合指针机制。KVC主要通过isa-swizzling，来实现其内部查找定位的。isa指针，如其名称所指，（就是is a kind of的意思），指向维护分发表的对象的类。该分发表实际上包含了指向实现类中的方法的指针，和其它数据
一个对象在调用setValue的时候，（1）首先根据方法名找到运行方法的时候所需要的环境参数。（2）他会从自己isa指针结合环境参数，找到具体的方法实现的接口。（3）再直接查找得来的具体的方法实现。
</code></pre>

<p>KVO</p>

<pre><code>观察者为一个对象的属性进行了注册，被观察对象的isa指针被修改的时候，isa指针就会指向一个中间类（setter/getter方法），而不是真实的类。所以isa指针其实不需要指向实例对象真实的类。所以我们的程序最好不要依赖于isa指针。在调用类的方法的时候，最好要明确对象实例的类名。
熟悉KVO的朋友都知道，只有当我们调用KVC去访问key值的时候KVO才会起作用。所以肯定确定的是，KVO是基于KVC实现的。其实看了上面我们的分析以后，关系KVO的架构的构思也就水到渠成了。
</code></pre>

<p>任何工程产品（注意是任何工程产品）都可以使用以下两种方法之一进行测试。
黑盒测试：已知产品的功能设计规格，可以进行测试证明每个实现了的功能是否符合要求。
白盒测试：已知产品的内部工作过程，可以通过测试证明每种内部操作是否符合设计规格要求，所有内部成分是否以经过检查。</p>

<h5>黑盒测试</h5>

<p>软件的黑盒测试意味着测试要在软件的接口处进行。这种方法是把测试对象看做一个黑盒子，测试人员完全不考虑程序内部的逻辑结构和内部特性，只依据程序的需求规格说明书，检查程序的功能是否符合它的功能说明。因此黑盒测试又叫功能测试或数据驱动测试。</p>

<pre><code>黑盒测试主要是为了发现以下几类错误：
1、是否有不正确或遗漏的功能？
2、在接口上，输入是否能正确的接受？能否输出正确的结果？
3、是否有数据结构错误或外部信息（例如数据文件）访问错误？
4、性能上是否能够满足要求？
5、是否有初始化或终止性错误？
</code></pre>

<h5>白盒测试</h5>

<p>软件的白盒测试是对软件的过程性细节做细致的检查。这种方法是把测试对象看做一个打开的盒子，它允许测试人员利用程序内部的逻辑结构及有关信息，设计或选择测试用例，对程序所有逻辑路径进行测试。通过在不同点检查程序状态，确定实际状态是否与预期的状态一致。因此白盒测试又称为结构测试或逻辑驱动测试。</p>

<pre><code>白盒测试主要是想对程序模块进行如下检查：
1、对程序模块的所有独立的执行路径至少测试一遍。
2、对所有的逻辑判定，取“真”与取“假”的两种情况都能至少测一遍。
3、在循环的边界和运行的界限内执行循环体。
4、测试内部数据结构的有效性，等等。
</code></pre>

<p>以上事实说明，软件测试有一个致命的缺陷，即测试的不完全、不彻底性。由于任何程序只能进行少量（相对于穷举的巨大数量而言）的有限的测试，在未发现错误时，不能说明程序中没有错误。</p>

<h5>灰盒测试</h5>

<p>灰盒测试，是介于白盒测试与黑盒测试之间的，可以这样理解，灰盒测试关注输出对于输入的正确性，同时也关注内部表现，但这种关注不象白盒那样详细、完整，只是通过一些表征性的现象、事件、标志来判断内部的运行状态，有时候输出是正确的，但内部其实已经错误了，这种情况非常多，如果每次都通过白盒测试来操作，效率会很低，因此需要采取这样的一种灰盒的方法。</p>

<h3>全栈相关</h3>

<h3>算法（常用、排序）</h3>

<h3>数据结构</h3>

<h3>设计模式（32中）</h3>

<h3>架构设计</h3>

<h3>逆向工程</h3>

<h3>实战应用</h3>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cell重用数据混乱]]></title>
    <link href="http://al1020119.github.io/blog/2016/06/15/cellshujuchongyongchulifangshi/"/>
    <updated>2016-06-15T13:53:19+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/06/15/cellshujuchongyongchulifangshi</id>
    <content type="html"><![CDATA[<p>关于Cell重用，我们经常会遇到cell重用的时候数据不对，或者混乱的情况，这里笔者由于刚好遇到了在项目中，所以解决后整理了一下。</p>

<p>常规配置如下 当超过tableView显示的范围的时候 后面显示的内容将会和前面重复</p>

<!--more-->


<p>这样配置的话超过页面显示的内容会重复出现</p>

<pre><code>- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath
{
    // 定义唯一标识
    static NSString *CellIdentifier = @"Cell";
    // 通过唯一标识创建cell实例
    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier];
    // 判断为空进行初始化  --（当拉动页面显示超过主页面内容的时候就会重用之前的cell，而不会再次初始化）
    if (!cell) {
        cell = [[UITableViewCell alloc]initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier:CellIdentifier];
    }
    // 对cell 进行简单地数据配置
    cell.textLabel.text = @"text";
    cell.detailTextLabel.text = @"text";
    cell.imageView.image = [UIImage imageNamed:@"4.png"];

    return cell;
}
</code></pre>

<p>通过以下3方案可以解决</p>

<p>方案一  取消cell的重用机制，通过indexPath来创建cell 将可以解决重复显示问题 不过这样做相对于大数据来说内存就比较吃紧了</p>

<p>通过不让他重用cell 来解决重复显示</p>

<pre><code>- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath
{
    // 定义唯一标识
    static NSString *CellIdentifier = @"Cell";
    // 通过indexPath创建cell实例 每一个cell都是单独的
    UITableViewCell *cell = [tableView cellForRowAtIndexPath:indexPath];
    // 判断为空进行初始化  --（当拉动页面显示超过主页面内容的时候就会重用之前的cell，而不会再次初始化）
    if (!cell) {
        cell = [[UITableViewCell alloc]initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier:CellIdentifier];
    }
    // 对cell 进行简单地数据配置
    cell.textLabel.text = @"text";
    cell.detailTextLabel.text = @"text";
    cell.imageView.image = [UIImage imageNamed:@"4.png"];

    return cell;
}
</code></pre>

<p>方案二  让每个cell都拥有一个对应的标识 这样做也会让cell无法重用 所以也就不会是重复显示了 显示内容比较多时内存占用也是比较多的和方案一类似
同样通过不让他重用cell 来解决重复显示 不同的是每个cell对应一个标</p>

<pre><code>- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath
{
    // 定义cell标识  每个cell对应一个自己的标识
    NSString *CellIdentifier = [NSString stringWithFormat:@"cell%ld%ld",indexPath.section,indexPath.row];
    // 通过不同标识创建cell实例
    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier];
    // 判断为空进行初始化  --（当拉动页面显示超过主页面内容的时候就会重用之前的cell，而不会再次初始化）
    if (!cell) {
        cell = [[UITableViewCell alloc]initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier:CellIdentifier];
    }
    // 对cell 进行简单地数据配置
    cell.textLabel.text = @"text";
    cell.detailTextLabel.text = @"text";
    cell.imageView.image = [UIImage imageNamed:@"4.png"];

    return cell;
}
</code></pre>

<p>方案三 只要最后一个显示的cell内容不为空，然后把它的子视图全部删除，等同于把这个cell单独出来了 然后跟新数据就可以解决重复显示</p>

<p> 当页面拉动需要显示新数据的时候，把最后一个cell进行删除 就有可以自定义cell 此方案即可避免重复显示，又重用了cell相对内存管理来说是最好的方案 前两者相对比较消耗内存</p>

<pre><code>- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath
{
    // 定义唯一标识
    static NSString *CellIdentifier = @"Cell";
    // 通过唯一标识创建cell实例
    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier];

    // 判断为空进行初始化  --（当拉动页面显示超过主页面内容的时候就会重用之前的cell，而不会再次初始化）
    if (!cell) {
        cell = [[UITableViewCell alloc]initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier:CellIdentifier];
    }
    else//当页面拉动的时候 当cell存在并且最后一个存在 把它进行删除就出来一个独特的cell我们在进行数据配置即可避免
    {
        while ([cell.contentView.subviews lastObject] != nil) {
            [(UIView *)[cell.contentView.subviews lastObject] removeFromSuperview];
        }
    }
    // 对cell 进行简单地数据配置
    cell.textLabel.text = @"text";
    cell.detailTextLabel.text = @"text";
    cell.imageView.image = [UIImage imageNamed:@"4.png"];

    return cell;
}
</code></pre>

<p>以上都是个人理解，本人也是菜鸟，有理解不对的地方希望大家指出，同时也希望能对大家起到一定的帮助！！ Thank you！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[我知道你在找什么？]]></title>
    <link href="http://al1020119.github.io/blog/2016/06/06/wpzhidapnizaizhaosm/"/>
    <updated>2016-06-06T13:53:19+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/06/06/wpzhidapnizaizhaosm</id>
    <content type="html"><![CDATA[<p>不喜欢废话。。。。。来，直接上（不是上我。。。。）</p>

<!--more-->


<p>一：源代码实例</p>

<p>1:快速搭建项目源代码</p>

<p>地址：<a href="https://github.com/wujunyang/MobileProject">https://github.com/wujunyang/MobileProject</a></p>

<p>2:高仿美团iOS版</p>

<p>地址：<a href="https://github.com/lookingstars/meituan">https://github.com/lookingstars/meituan</a></p>

<p>3:模仿网易新闻做的精仿网易新闻</p>

<p>地址：<a href="https://github.com/dsxNiubility/SXNews">https://github.com/dsxNiubility/SXNews</a></p>

<p>4:支付宝高仿版</p>

<p>地址：<a href="https://github.com/gsdios/GSD_ZHIFUBAO">https://github.com/gsdios/GSD_ZHIFUBAO</a></p>

<p>5:高仿百度传课iOS版</p>

<p>地址：<a href="https://github.com/lookingstars/chuanke">https://github.com/lookingstars/chuanke</a></p>

<p>6：模仿一元云购</p>

<p>地址：<a href="https://github.com/JxbSir/YiYuanYunGou">https://github.com/JxbSir/YiYuanYunGou</a></p>

<p>7：wordpress源代码</p>

<p>地址：<a href="https://github.com/wordpress-mobile/WordPress-iOS">https://github.com/wordpress-mobile/WordPress-iOS</a></p>

<p>8：v2ex源代码（文章类型，若报SVProgressHUD错，则把Podfile中的SVProgressHUD移除）</p>

<p>地址：<a href="https://github.com/singro/v2ex">https://github.com/singro/v2ex</a></p>

<p>9:PHPHub客户端(IOS8.0以上)</p>

<p>地址：<a href="https://github.com/Aufree/phphub-ios">https://github.com/Aufree/phphub-ios</a></p>

<p>10:Coding.net客户端</p>

<p>地址：<a href="https://coding.net/u/coding/p/Coding-iOS/git">https://coding.net/u/coding/p/Coding-iOS/git</a></p>

<p>11：如何优化UITableView中Cell加载图片的实例</p>

<p>地址：<a href="https://github.com/allenhsu/UIScrollView-Samples/tree/master/LazyLoad">https://github.com/allenhsu/UIScrollView-Samples/tree/master/LazyLoad</a></p>

<p>12:开源的IOS代码集合</p>

<p>地址：<a href="https://github.com/dkhamsing/open-source-ios-apps">https://github.com/dkhamsing/open-source-ios-apps</a></p>

<p>二：辅助软件</p>

<p>1：XCODE文档注解插件VVDocumenter</p>

<p>地址：<a href="https://github.com/onevcat/VVDocumenter-Xcode">https://github.com/onevcat/VVDocumenter-Xcode</a></p>

<p>2：将JSON格式化输出为模型的属性</p>

<p>地址：<a href="https://github.com/EnjoySR/ESJsonFormat-Xcode">https://github.com/EnjoySR/ESJsonFormat-Xcode</a></p>

<p>3：图片提示插件</p>

<p>地址：<a href="https://github.com/ksuther/KSImageNamed-Xcode">https://github.com/ksuther/KSImageNamed-Xcode</a></p>

<p>4：图片转换插件</p>

<p>地址：<a href="https://github.com/rickytan/RTImageAssets">https://github.com/rickytan/RTImageAssets</a></p>

<p>5:测试模拟苹果通知</p>

<p>地址：<a href="https://github.com/KnuffApp/Knuff">https://github.com/KnuffApp/Knuff</a></p>

<p>6: HOStringSense可以在弹出框写NSString，所见及所得</p>

<p>地址：<a href="https://github.com/holtwick/HOStringSense-for-Xcode">https://github.com/holtwick/HOStringSense-for-Xcode</a></p>

<p>7：cocoapods-xcode-plugin  pod相关的操作可以在xcode菜单进行</p>

<p>地址：<a href="https://github.com/kattrali/cocoapods-xcode-plugin">https://github.com/kattrali/cocoapods-xcode-plugin</a></p>

<p>8：switch枚举的时候会自动生成代码</p>

<p>地址：<a href="https://github.com/stefanceriu/SCXcodeSwitchExpander">https://github.com/stefanceriu/SCXcodeSwitchExpander</a></p>

<p>9：git中关于各个语言的gitignore</p>

<p>地址：<a href="https://github.com/github/gitignore">https://github.com/github/gitignore</a></p>

<p>10：FLEX（Flipboard Explorer）是Flipboard官方发布的一组专门用于iOS开发的应用内调试工具</p>

<p>地址：<a href="https://github.com/Flipboard/FLEX">https://github.com/Flipboard/FLEX</a></p>

<p>11：ponyDebugger是一个远程调试工具包，通过使用Chrome开发者工具来调试iOS应用的网络流量和数据存储</p>

<p>地址：<a href="https://github.com/square/PonyDebugger">https://github.com/square/PonyDebugger</a></p>

<p>12: OC编码风格规范</p>

<p>地址：<a href="https://github.com/NYTimes/objective-c-style-guide">https://github.com/NYTimes/objective-c-style-guide</a></p>

<p>13:FBMemoryProfiler：Facebook出品的一个实时监测内存使用的库。相比于Xcode自带的Instruments</p>

<p>地址：<a href="https://github.com/facebook/FBMemoryProfiler">https://github.com/facebook/FBMemoryProfiler</a></p>

<p>14:app卡顿问题检测&ndash;KMCGeigerCounter(实例可以网上搜索)</p>

<p>地址：<a href="https://github.com/kconner/KMCGeigerCounter/">https://github.com/kconner/KMCGeigerCounter/</a></p>

<p>15:生成类的关系图KSHObjcUML</p>

<p>地址：<a href="https://github.com/kimsungwhee/KSHObjcUML">https://github.com/kimsungwhee/KSHObjcUML</a></p>

<p>16:realm-cocoa实体映射数据库，有自个的数据库（可以替换SQLITE，速度比较快）</p>

<p>地址：<a href="https://github.com/realm/realm-cocoa">https://github.com/realm/realm-cocoa</a></p>

<p>17:创建文档API，可以快速让APP先调用，并行开发</p>

<p>地址：<a href="https://apiary.io/">https://apiary.io/</a></p>

<p>18:直接查看虚拟器上的沙盒路径simpholders</p>

<p>地址：<a href="http://www.maczapp.com/simpholders">http://www.maczapp.com/simpholders</a></p>

<p>19:FastStub实现了类似的功能，能自动解析出某个类头文件，父类，所有protocol里面还没有被实现的方法(ctrl+cmd+k)</p>

<p>地址：<a href="https://github.com/music4kid/FastStub-Xcode">https://github.com/music4kid/FastStub-Xcode</a></p>

<p>三：第三方插件</p>

<p>1:基于响应式编程思想的oc</p>

<p>地址：<a href="https://github.com/ReactiveCocoa/ReactiveCocoa">https://github.com/ReactiveCocoa/ReactiveCocoa</a></p>

<p>2：hud提示框</p>

<p>地址：<a href="https://github.com/jdg/MBProgressHUD">https://github.com/jdg/MBProgressHUD</a></p>

<p>3：XML/HTML解析</p>

<p>地址：<a href="https://github.com/topfunky/hpple">https://github.com/topfunky/hpple</a></p>

<p>4：有文字输入时，能根据键盘是否弹出来调整自身显示内容的位置</p>

<p>地址：<a href="https://github.com/michaeltyson/TPKeyboardAvoiding">https://github.com/michaeltyson/TPKeyboardAvoiding</a></p>

<p>5：状态栏提示框</p>

<p>地址：<a href="https://github.com/jaydee3/JDStatusBarNotification">https://github.com/jaydee3/JDStatusBarNotification</a></p>

<p>6：block工具包。将很多需要用delegate实现的方法整合成了block的形式</p>

<p>地址：<a href="https://github.com/zwaldowski/BlocksKit">https://github.com/zwaldowski/BlocksKit</a></p>

<p>7：图片加载</p>

<p>地址：<a href="https://github.com/rs/SDWebImage">https://github.com/rs/SDWebImage</a></p>

<p>8：正则表达式</p>

<p>地址：<a href="https://github.com/wezm/RegexKitLite">https://github.com/wezm/RegexKitLite</a></p>

<p>9：Masonry代码布局</p>

<p>地址：<a href="https://github.com/SnapKit/Masonry">https://github.com/SnapKit/Masonry</a></p>

<p>10：弹出窗</p>

<p>地址：<a href="https://github.com/sberrevoets/SDCAlertView">https://github.com/sberrevoets/SDCAlertView</a></p>

<p>11:Button的样式</p>

<p>地址：<a href="https://github.com/mattlawer/BButton">https://github.com/mattlawer/BButton</a></p>

<p>12：验证网络连接状态</p>

<p>地址：<a href="https://github.com/tonymillion/Reachability">https://github.com/tonymillion/Reachability</a></p>

<p>13：自动计算表格行高</p>

<p>地址：<a href="https://github.com/forkingdog/UITableView-FDTemplateLayoutCell">https://github.com/forkingdog/UITableView-FDTemplateLayoutCell</a></p>

<p>14：关键帧基础动画框架,如动画效果的启动页</p>

<p>地址：<a href="https://github.com/IFTTT/JazzHands">https://github.com/IFTTT/JazzHands</a></p>

<p>15：iOS快速简单集成国内三大平台分享</p>

<p>地址：<a href="https://github.com/xumeng/XMShareModule">https://github.com/xumeng/XMShareModule</a></p>

<p>16：五项能力值展示的五边形</p>

<p>地址：<a href="https://github.com/dsxNiubility/SXFiveScoreShow">https://github.com/dsxNiubility/SXFiveScoreShow</a></p>

<p>17：自动识别网址号码邮箱和表情的label</p>

<p>地址：<a href="https://github.com/molon/MLEmojiLabel">https://github.com/molon/MLEmojiLabel</a></p>

<p>18：IM对话功能的封装</p>

<p>地址：<a href="https://github.com/ZhipingYang/UUChatTableView">https://github.com/ZhipingYang/UUChatTableView</a></p>

<p>19：字典转模型框架</p>

<p>地址：<a href="https://github.com/CoderMJLee/MJExtension">https://github.com/CoderMJLee/MJExtension</a></p>

<p>20：下拉上拉刷数据</p>

<p>地址：<a href="https://github.com/CoderMJLee/MJRefresh">https://github.com/CoderMJLee/MJRefresh</a></p>

<p>21：表格行左右划动菜单</p>

<p>地址：<a href="https://github.com/MortimerGoro/MGSwipeTableCell">https://github.com/MortimerGoro/MGSwipeTableCell</a></p>

<p>22:图文混搭</p>

<p>地址:<a href="https://github.com/zhouande/TLAttributedLabel">https://github.com/zhouande/TLAttributedLabel</a></p>

<p>23:可以简单展示在UINavigationBar下方，类似Music app的播放列表视图，弹出菜单视图</p>

<p>地址：<a href="https://github.com/DrummerB/BFNavigationBarDrawer">https://github.com/DrummerB/BFNavigationBarDrawer</a></p>

<p>24：比如筛选、模糊、优化、蒙版、调整大小、旋转以及保存等等。同时还提供了一个UIImageView子类从URL异步加载图片，并在下载完毕时展示图片。</p>

<p>地址：<a href="https://github.com/Nyx0uf/NYXImagesKit">https://github.com/Nyx0uf/NYXImagesKit</a></p>

<p>25：底部TabBar</p>

<p>地址：<a href="https://github.com/robbdimitrov/RDVTabBarController">https://github.com/robbdimitrov/RDVTabBarController</a></p>

<p>26:表情面版</p>

<p>地址：<a href="https://github.com/ayushgoel/AGEmojiKeyboard">https://github.com/ayushgoel/AGEmojiKeyboard</a></p>

<p>27:记录框架</p>

<p>地址：<a href="https://github.com/CocoaLumberjack/CocoaLumberjack">https://github.com/CocoaLumberjack/CocoaLumberjack</a></p>

<p>28：IOS与javascript交互</p>

<p>地址：<a href="https://github.com/marcuswestin/WebViewJavascriptBridge">https://github.com/marcuswestin/WebViewJavascriptBridge</a></p>

<p>29：图表统计展示</p>

<p>地址：<a href="https://github.com/kevinzhow/PNChart%EF%BC%88%E6%88%96https://github.com/danielgindi/ios-charts%EF%BC%89">https://github.com/kevinzhow/PNChart%EF%BC%88%E6%88%96https://github.com/danielgindi/ios-charts%EF%BC%89</a></p>

<p>30:appStore评分</p>

<p>地址：<a href="https://github.com/arashpayan/appirater">https://github.com/arashpayan/appirater</a></p>

<p>31：iOS-Categories扩展类大全</p>

<p>地址：<a href="https://github.com/shaojiankui/IOS-Categories">https://github.com/shaojiankui/IOS-Categories</a></p>

<p>32：扫描二维码，仿微信效果，带有扫描条</p>

<p>地址：<a href="https://github.com/JxbSir/JxbScanQR">https://github.com/JxbSir/JxbScanQR</a></p>

<p>33:动效弹出视图(弹出窗里面为文字，可以定义弹出的方向，及显示的时间)&ndash;AMPopTip</p>

<p>地址：<a href="https://github.com/andreamazz/AMPopTip">https://github.com/andreamazz/AMPopTip</a></p>

<p>34:基于Masonry自动计算行高扩展</p>

<p>地址：<a href="https://github.com/632840804/HYBMasonryAutoCellHeight">https://github.com/632840804/HYBMasonryAutoCellHeight</a></p>

<p>35:模仿新浪微博弹出菜单</p>

<p>地址：<a href="https://github.com/wwdc14/HyPopMenuView">https://github.com/wwdc14/HyPopMenuView</a></p>

<p>36:搜索历史标签</p>

<p>地址：<a href="https://github.com/zhiwupei/SearchHistory">https://github.com/zhiwupei/SearchHistory</a></p>

<p>37：快速集成新手引导的类库</p>

<p>地址：<a href="https://github.com/StrongX/XSportLight">https://github.com/StrongX/XSportLight</a></p>

<p>38：设置页面的封装</p>

<p>地址：<a href="https://github.com/renzifeng/ZFSetting">https://github.com/renzifeng/ZFSetting</a></p>

<p>39：带箭头的弹出视图插件</p>

<p>地址：<a href="https://github.com/xiekw2010/DXPopover">https://github.com/xiekw2010/DXPopover</a></p>

<p>40：下拉菜单插件</p>

<p>地址：<a href="https://github.com/dopcn/DOPDropDownMenu/">https://github.com/dopcn/DOPDropDownMenu/</a></p>

<p>41：表格空白提示插件</p>

<p>地址：<a href="https://github.com/dzenbot/DZNEmptyDataSet">https://github.com/dzenbot/DZNEmptyDataSet</a></p>

<p>42:给任意UIView视图四条边框加上阴影，可以自定义阴影的颜色、粗细程度、透明程度以及位置（上下左右边框）</p>

<p>地址：<a href="https://github.com/Seitk/UIView-Shadow-Maker">https://github.com/Seitk/UIView-Shadow-Maker</a></p>

<p>43:不错的日期时间插件</p>

<p>地址：<a href="https://github.com/CoderXL/UUDatePicker">https://github.com/CoderXL/UUDatePicker</a></p>

<p>44:底部弹出选择</p>

<p>地址：<a href="https://github.com/skywinder/ActionSheetPicker-3.0">https://github.com/skywinder/ActionSheetPicker-3.0</a></p>

<p>45:比较不错的引导页面插件</p>

<p>地址：<a href="https://github.com/ealeksandrov/EAIntroView">https://github.com/ealeksandrov/EAIntroView</a></p>

<p>46:两个APP跳转的插件</p>

<p>地址：<a href="https://github.com/usebutton/DeepLinkKit">https://github.com/usebutton/DeepLinkKit</a></p>

<p>47:本地存取NSUserDefaults插件</p>

<p>地址：<a href="https://github.com/gangverk/GVUserDefaults">https://github.com/gangverk/GVUserDefaults</a></p>

<p>48:NSArray和NSDictionary关于LINQ的操作方式，封装一些常用的操作</p>

<p>地址：<a href="https://github.com/ColinEberhardt/LinqToObjectiveC">https://github.com/ColinEberhardt/LinqToObjectiveC</a></p>

<p>49:可以监控网络请求的内容</p>

<p>地址：<a href="https://github.com/coderyi/NetworkEye">https://github.com/coderyi/NetworkEye</a></p>

<p>50：时间帮助插件，可以快速获取时间，比较，增加等操作</p>

<p>地址：<a href="https://github.com/MatthewYork/DateTools">https://github.com/MatthewYork/DateTools</a></p>

<p>51:不错的链式动作</p>

<p>地址：<a href="https://github.com/jhurray/JHChainableAnimations">https://github.com/jhurray/JHChainableAnimations</a></p>

<p>52:弹出层视图，背景效果（可以自定义视图的内容）</p>

<p>地址：<a href="https://github.com/HJaycee/JCAlertView">https://github.com/HJaycee/JCAlertView</a></p>

<p>53:圆形进度条的显示，中间可显示值</p>

<p>地址：<a href="https://github.com/mdinacci/MDRadialProgress">https://github.com/mdinacci/MDRadialProgress</a></p>

<p>54:很帅的数据加载动画（可以用于数据列表加载的展现）</p>

<p>地址：<a href="https://github.com/NghiaTranUIT/FeSpinner">https://github.com/NghiaTranUIT/FeSpinner</a></p>

<p>55:一个开源的AFnetworking上层的封装（猿题库等运用）</p>

<p>地址：<a href="https://github.com/yuantiku/YTKNetwork">https://github.com/yuantiku/YTKNetwork</a></p>

<p>56:CBStoreHouseRefreshControl：一个效果很酷炫的下拉刷新控件</p>

<p>地址：<a href="https://github.com/coolbeet/CBStoreHouseRefreshControl">https://github.com/coolbeet/CBStoreHouseRefreshControl</a></p>

<p>57:AFNetworking-RACExtensions:针对ReactiveCocoa的AF封装</p>

<p>地址：<a href="https://github.com/CodaFi/AFNetworking-RACExtensions">https://github.com/CodaFi/AFNetworking-RACExtensions</a></p>

<p>58:模糊效果（毛玻璃）</p>

<p>地址：<a href="https://github.com/nicklockwood/FXBlurView">https://github.com/nicklockwood/FXBlurView</a></p>

<p>59:UITableView展开效果的插件</p>

<p>地址：<a href="https://github.com/sakkaras/SKSTableView">https://github.com/sakkaras/SKSTableView</a></p>

<p>60:ZIP压缩及解压插件ZipArchive</p>

<p>地址：<a href="https://github.com/ZipArchive/ZipArchive">https://github.com/ZipArchive/ZipArchive</a></p>

<p>61:自定义UIAlertView</p>

<p>地址：<a href="https://github.com/lmcd/LMAlertView">https://github.com/lmcd/LMAlertView</a></p>

<p>62:Facebook开源的动画库Pop</p>

<p>地址：<a href="https://github.com/facebook/pop">https://github.com/facebook/pop</a></p>

<p>63:关于使用facebook动画库的实例集合</p>

<p>地址：<a href="https://github.com/schneiderandre/popping">https://github.com/schneiderandre/popping</a></p>

<p>64:iOS应用视图上添加简单闪烁效果Shimmer</p>

<p>地址：<a href="https://github.com/facebook/Shimmer">https://github.com/facebook/Shimmer</a></p>

<p>65:ios数据持久化插件，使得Core Data使用起来更加的便捷容易</p>

<p>地址：<a href="https://github.com/magicalpanda/MagicalRecord">https://github.com/magicalpanda/MagicalRecord</a></p>

<p>66:创建缩合的iOS应用程序标题栏</p>

<p>地址：<a href="https://github.com/bryankeller/BLKFlexibleHeightBar">https://github.com/bryankeller/BLKFlexibleHeightBar</a></p>

<p>67:PDF阅读器核心库</p>

<p>地址：<a href="https://github.com/vfr/Reader">https://github.com/vfr/Reader</a></p>

<p>68:STPopup使弹出框也有UINavigationController的效果</p>

<p>地址：<a href="https://github.com/kevin0571/STPopup">https://github.com/kevin0571/STPopup</a></p>

<p>69:基于核心音频,有助于进行实时，低延迟音频处理和可视化的iOS和OSX音频可视化框架</p>

<p>地址：<a href="https://github.com/syedhali/EZAudio">https://github.com/syedhali/EZAudio</a></p>

<p>70:一个不错的弹出Sheet,可以前进跟后退，适合多个页面</p>

<p>地址：<a href="https://github.com/m1entus/MZFormSheetController">https://github.com/m1entus/MZFormSheetController</a></p>

<p>71:Aspect库是对面向切面编程的实现，里面封装了Runtime的方法</p>

<p>地址：<a href="https://github.com/steipete/Aspects">https://github.com/steipete/Aspects</a></p>

<p>72：一个不错在无输入源的输入框，如UITableViewCell等</p>

<p>地址：<a href="https://github.com/slackhq/SlackTextViewController">https://github.com/slackhq/SlackTextViewController</a></p>

<p>73:小红点插件，用于提示未读效果</p>

<p>地址：<a href="https://github.com/weng1250/WZLBadge">https://github.com/weng1250/WZLBadge</a></p>

<p>74:不错的照片选择器，视频选择器，支持单多选</p>

<p>地址：<a href="https://github.com/mwaterfall/MWPhotoBrowser">https://github.com/mwaterfall/MWPhotoBrowser</a></p>

<p>75:含10多种的转场动画效果</p>

<p>地址：<a href="https://github.com/ColinEberhardt/VCTransitionsLibrary">https://github.com/ColinEberhardt/VCTransitionsLibrary</a></p>

<p>76:左右菜单显示（类似QQ导航）</p>

<p>地址：<a href="https://github.com/romaonthego/RESideMenu">https://github.com/romaonthego/RESideMenu</a></p>

<p>77:很赞的等待指示动画（比系统自带的帅）</p>

<p>地址：<a href="https://github.com/ninjaprox/DGActivityIndicatorView">https://github.com/ninjaprox/DGActivityIndicatorView</a></p>

<p>78:KVOController一个简单安全的KVO(Key-value Observing,键-值观察)工具,提供简单方便、线程安全的API, Facebook的开源项目之一</p>

<p>地址：<a href="https://github.com/facebook/KVOController">https://github.com/facebook/KVOController</a></p>

<p>79：FormatterKit收集了很多构思优秀的NSFormatter子类</p>

<p>地址：<a href="https://github.com/mattt/FormatterKit">https://github.com/mattt/FormatterKit</a></p>

<p>80:自定义的UIPageControl(可以设置每个的样式)</p>

<p>地址：<a href="https://github.com/Spaceman-Labs/SMPageControl">https://github.com/Spaceman-Labs/SMPageControl</a></p>

<p>81:使用NJKWebViewProgress做webview进度条（解决先前无法获得进度的问题）</p>

<p>地址：<a href="https://github.com/ninjinkun/NJKWebViewProgress">https://github.com/ninjinkun/NJKWebViewProgress</a></p>

<p>82:修改NavigationBar的显示效果</p>

<p>地址：<a href="https://github.com/ltebean/LTNavigationBar/">https://github.com/ltebean/LTNavigationBar/</a></p>

<p>83:FCUUID获得设备号的替代方式</p>

<p>地址：<a href="https://github.com/fabiocaccamo/FCUUID">https://github.com/fabiocaccamo/FCUUID</a></p>

<p>84:多主题色或者白天黑夜模式的运用</p>

<p>地址：<a href="https://github.com/Draveness/DKNightVersion">https://github.com/Draveness/DKNightVersion</a></p>

<p>85:GPUImage是一个基于GPU图像和视频处理的开源框架,提供各种各样的图像处理滤镜</p>

<p>地址：<a href="https://github.com/BradLarson/GPUImage">https://github.com/BradLarson/GPUImage</a></p>

<p>86:YY图片加载插件，可以支持动态，网络本地，渐进式图片加载等</p>

<p>地址：<a href="https://github.com/ibireme/YYWebImage">https://github.com/ibireme/YYWebImage</a></p>

<p>87:封装后的蓝牙帮助库</p>

<p>地址：<a href="https://github.com/coolnameismy/BabyBluetooth">https://github.com/coolnameismy/BabyBluetooth</a></p>

<p>88:一个很通用的需求就是引导教程</p>

<p>地址：<a href="https://github.com/bubudrc/MPCoachMarks">https://github.com/bubudrc/MPCoachMarks</a></p>

<p>89:基于MPMoviePlayerController播放器KRVideoPlayer</p>

<p>地址：<a href="https://github.com/36Kr-Mobile/KRVideoPlayer">https://github.com/36Kr-Mobile/KRVideoPlayer</a></p>

<p>90:UICollection左对齐跟右对齐</p>

<p>地址：<a href="https://github.com/mokagio/UICollectionViewLeftAlignedLayout">https://github.com/mokagio/UICollectionViewLeftAlignedLayout</a></p>

<p>地址：<a href="https://github.com/mokagio/UICollectionViewRightAlignedLayout">https://github.com/mokagio/UICollectionViewRightAlignedLayout</a></p>

<p>91:自定义弹出对话窗，类似系统又可以自定义视图DQAlertView或MMPopupView</p>

<p>地址：<a href="https://github.com/dinhquan/DQAlertView">https://github.com/dinhquan/DQAlertView</a></p>

<p>地址：<a href="https://github.com/adad184/MMPopupView">https://github.com/adad184/MMPopupView</a></p>

<p>92:输入框在焦点获得时会有一个小标题JVFloatLabeledTextField</p>

<p>地址：<a href="https://github.com/jverdi/JVFloatLabeledTextField">https://github.com/jverdi/JVFloatLabeledTextField</a></p>

<p>93:针对一些UI进行显示优化，可以设置一些不同的背景色等</p>

<p>地址：<a href="https://github.com/Grouper/FlatUIKit">https://github.com/Grouper/FlatUIKit</a></p>

<p>94:色彩插件，如果没有设计师又想一些漂亮的色彩就可以运用Chameleon</p>

<p>地址：<a href="https://github.com/ViccAlexander/Chameleon">https://github.com/ViccAlexander/Chameleon</a></p>

<p>95:两个不错的侧边栏显示插件ECSlidingViewController，SWRevealViewController</p>

<p>地址：<a href="https://github.com/ECSlidingViewController/">https://github.com/ECSlidingViewController/</a></p>

<p>ECSlidingViewController</p>

<p>地址：<a href="https://github.com/John-Lluch/SWRevealViewController">https://github.com/John-Lluch/SWRevealViewController</a></p>

<p>96：各式各样的进度条，可以放在不同地方NAV或者图片或者扇形M13ProgressSuite</p>

<p>地址：<a href="https://github.com/Marxon13/M13ProgressSuite">https://github.com/Marxon13/M13ProgressSuite</a></p>

<p>97：拉动UITableView时CELL有一摇动的效果AMWaveTransition</p>

<p>地址：<a href="https://github.com/andreamazz/AMWaveTransition">https://github.com/andreamazz/AMWaveTransition</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[警告与实战]]></title>
    <link href="http://al1020119.github.io/blog/2016/06/03/appjinggaoshizhanchuli/"/>
    <updated>2016-06-03T13:53:19+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/06/03/appjinggaoshizhanchuli</id>
    <content type="html"><![CDATA[<p>App实战中遇到的警告问题及处理方式</p>

<!--more-->


<p>Xcode 升级后，常常遇到的遇到的警告、错误，解决方法</p>

<h5>警告：“xoxoxoxo”  is deprecated</h5>

<pre><code>解决办法：查看xoxoxoxo的这个方法的文档，替换掉这个方法即可。
</code></pre>

<h5>警告：Declaration of &ldquo;struct sockaddr&rdquo; will not be visible outside of this function</h5>

<pre><code>解决办法：在你的开源.m文件中添加 #import &lt;netinet/in.h&gt;
</code></pre>

<h5>警告：Implicit conversion from enumeration type &lsquo;UIInterfaceOrientation&rsquo; to different enumeration type &lsquo;UIDeviceOrientation&rsquo;</h5>

<pre><code>解决办法：类型不匹配。跳到出错的那一行，UIInterfaceOrientation强制转换为UIDeviceOrientation就行了。
</code></pre>

<h5>警告：incompatible pointer types assigning to &lsquo;MyArrayList*'from 'NSMutableArray&rsquo;</h5>

<pre><code>解决办法：加入强制转换(MyArrayList*)
</code></pre>

<h5>警告：'&amp;&amp;&lsquo; within &rsquo;||'</h5>

<p>问题出处：
    if (exists &amp;&amp; !isDirectory || !exists)………</p>

<pre><code>  解决办法： if ((exists &amp;&amp; !isDirectory) || !exists)………
</code></pre>

<h5>警告：Warning：The Copy Bundle Resources build phase contains this target&rsquo;s Info.plist file</h5>

<pre><code>解决办法：将Info.plist文件移到Resources目录下，而不要直接放在target下。
</code></pre>

<h5>警告：在使用ASIHttp…第三方库的，运行报错。</h5>

<pre><code>解决办法：看你的项目中是否添加CFNetwork.framework、SystemConfiguration.framework, MobileCoreServices.framework,
</code></pre>

<p>CoreGraphics.framework和libz.1.2.3.dylib，如果是sdk5.0以上，改添加libz.1.2.5.dylib</p>

<h5>警告：xxxooo，missing required architecture i386 in file</h5>

<pre><code>解决办法：如果是错误信息的话：Target-&gt;Build Settings-&gt;Search Paths, 删除FrameworkSearch Paths 里面内容就可以了。
</code></pre>

<p>要只是一个警告的话，真机调试可以过。具体解决方法待大神出现。</p>

<h5>警告：</h5>

<p>clang: error: no such file or directory: &lsquo;/demo2/控件代码/13/Recorder/Recorder_Prefix.pch&rsquo;
clang: error: no input files
Command /Developer/Platforms/iPhoneSimulator.platform/Developer/usr/bin/clang failed with exit code 1</p>

<pre><code>解决办法： 在你的主工程文件 target搜素，pch ，找到Prefix Header    把它后面的值，都删除，再运行就解决了。
</code></pre>

<h5>警告：</h5>

<p>“ARC forbids synthesizing a property of an Objective-C object with unspecified ownership or storage attribute</p>

<pre><code>解决办法：如果定义了ARC有效，那么必须要有所有者属性的定义;所以代码改成下面这样
@property (nonatomic, strong, readonly) NSString *ss;
</code></pre>

<h5>警告：</h5>

<p>io6一下的xib系统均没有自动选择Use Autolayout， Supporting iOS 5 and below with xib of iOS 6</p>

<pre><code>解决办法：Just un-select “Use Autolayout” in the file inspector of the xib’s view and we are back to the familiar autosizing in size inspector and boom, it supports iOS 5 and below.
</code></pre>

<h5>警告：</h5>

<p>Warning: Multiple build commands for output file xxx.png</p>

<pre><code>解决办法：找到项目里xxx.png重复，删除重复的资源。
</code></pre>

<p>//以下是升级到 xcode 5.0.1 之后使用遇到的警告</p>

<h5>警告：</h5>

<p> “iOS 模拟器”未能安装此应用程序。</p>

<pre><code>解决办法：删除模拟器上当前要运行那个APP，重新运行项目。就ok
</code></pre>

<h5>警告：</h5>

<p>SpringBoard无法启动应用程序 错误:-3</p>

<pre><code>解决办法：退出模拟器，重新运行这个项目。
</code></pre>

<h5>警告：</h5>

<p>The server certificate failed to verify.</p>

<pre><code>解决办法：
1、打开终端（实用工具 --&gt;终端），在终端中输入如下命令：
svn ls https://192.100.1.11?0/svn/xxxxxx（注意下面的url更换成你自己的url地址）
然后直接输入 “ p ”  确认，就可以重新连接了。
</code></pre>

<h5>警告：</h5>

<p>Bitmasking for introspection of Objective-C object pointers is strongly discouraged.</p>

<pre><code>解决办法：
某数字&amp; 0x1的时候是代表要取最低位是否为1，改成了  if(JK_EXPECT_F(((NSUInteger)object)%2))即可。
</code></pre>

<h5>警告：</h5>

<p>Implicit conversion loses integer precision: &lsquo;unsigned long&rsquo; to &lsquo;CC_LONG&rsquo; (aka &lsquo;unsigned int&rsquo;).</p>

<pre><code>解决办法：
CC_MD5(str,strlen(str), r);，改成了     CC_MD5(str, (CC_LONG)strlen(str), r);即可。
</code></pre>

<h5>警告：</h5>

<p>error: failed to launch &lsquo;/private/var/mobile/Applications/xxxxx&rsquo; &ndash; failed to get the task for process 11140.</p>

<pre><code>解决办法：
    重启你的开发手机即可，还有一种可能是你的开发者证书与发布证书搞错了，检查在xcode中证书是否一直 。
</code></pre>

<h5>警告：</h5>

<p>error: ignoring filxxxxxx/libBaiduMobStat.a, missing required architecture x86_64 in filexxxx/libBaiduMobStat.a</p>

<pre><code>解决办法：
    targets -&gt;build setting 下的  architectures 设置为 standard architetures(armv7,armv7s)   vaild architectures 设置为armv7,armv7s。
</code></pre>

<h5>警告：</h5>

<p>error: Directory not found for option &lsquo;-L/Users/joryoubonxx/BaiduStatistic</p>

<pre><code>解决办法：
  删除  targets -&gt;build setting 下的  library search path不正确的地址,如果还不行，重新添加第三库、clean ,重启Xcode.即可。
</code></pre>

<p>遇到相关的警告，一般编译器都会提供解决方案，所以，作为新手，我们应该看懂编译器给我们的提示，这样我们解决问题就会事半功倍。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[反编译App小菜篇]]></title>
    <link href="http://al1020119.github.io/blog/2016/05/01/fanbianyixiaocaipain/"/>
    <updated>2016-05-01T13:53:19+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/05/01/fanbianyixiaocaipain</id>
    <content type="html"><![CDATA[<p>前面介绍了那么多关于反编译的问题，也没有真正实战几下，这里简单的教你装一下13，希望大鸟看到不要笑。</p>

<p>纯属个人即时玩玩，但是对于小菜还有有点用的，或者没有接触过的人！</p>

<!--more-->


<h3>获取App所有.h文件</h3>

<p>第一步安装class-dump（class-dump可以提取.ipa中的.h文件）。
安装：
1. 下载地址 <a href="http://stevenygard.com/projects/class-dump/">http://stevenygard.com/projects/class-dump/</a>
2. 终端中输入open /usr/bin
3. 将解压出来的class-dump放入刚打开的目录。   <br/>
4. 更改class-dump权限     sudo chmod 777 /usr/bin/class-dump</p>

<h5>线下版</h5>

<p>1.新建一个App修改里面相关代码运行。</p>

<p>2.打开Products文件夹下的DecompilingTest.app所在目录</p>

<p>3.显示包内容，拿到二进制文件。</p>

<p>4.复制到桌面，执行以下命令，即可拿到工程中的.h文件</p>

<blockquote><p>class-dump -H Name</p></blockquote>

<h5>线上版</h5>

<p>举例：
1.首先下载一个.ipa文件。</p>

<p>2.将文件名改为.zip结尾</p>

<p>3.然后在解压出对应的文件夹</p>

<p>4.在该文件夹中找到</p>

<p>这个就是目标文件。</p>

<p>最后终端进入到纯在该文件的路径 ，运行class-dump -H Flap.app -o Flap就可以得到一个，这个文件夹中就是flappy中的所有头文件。</p>

<p>但是你可能会发现只有一个.h文件CDStructures.h，而且里面撒野没有，这里就证明苹果进行了加壳。</p>

<p>后面我们就开始怎么先处理这一层壳</p>

<blockquote><p>class-dump 命令的参数可以在终端中运行 class-dump &ndash;help查看</p></blockquote>

<h3>取方法的实现</h3>

<p>安装Hopper Disassembler（这里就不用说了，不像class-dump，傻瓜式操作）</p>

<p>用法很简单，只要将二进制文件拖进去就行了</p>

<p>。。。。。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[逆向工程总结]]></title>
    <link href="http://al1020119.github.io/blog/2016/04/25/nixiangzongjie/"/>
    <updated>2016-04-25T13:32:08+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/04/25/nixiangzongjie</id>
    <content type="html"><![CDATA[<p>不忍心作结，虽然才刚刚开始，很多东西都没有细细总结，只可惜很多东西并非自己想的那么顺利。</p>

<p>才干了一年多的活，就见证了两个项目的死亡，这个世界远远超过自己想象中的残酷。第一个项目只历经一两个版本，无啥感情可言；第二个项目就完完全全经历了诞生到死亡的全过程，若说无感情的话，那我就是彻头彻尾的混蛋了。虽然终结是必然的，但是比预料中的更快更突然。悲剧往往就是在这种感情的强烈碰撞下诞生的。</p>

<!--more-->


<p>祸不单行，我丢了我的iPhone。那一刻我真真实实感觉到，失去自己熟悉的亲密的东西的那种无助。若是人，不敢想象。</p>

<p>好在人有着天生的自愈能力。换了新环境已快两月，感觉以前的那些已经过去很久似的，早已渐渐淡忘。新项目的生活紧张而细致，繁密且高精度的工作会让人无暇关注其它。而且，偶尔偶尔的小波澜，比如说某人被离职了，会在你神经绷得更紧更紧。</p>

<p>不过今天，发现那个当时也凝聚了不少心血的app终于上了AppStore，推迟了足足半年有余，惊讶中夹杂着深深的悲凉。当然这不是最让人伤心的。回想起自己后来去搞了越狱版，于是乎就听到了“我的AppStore版”和“你们的越狱版”之类的言语，似乎这个东西当时几个人搞出来，就算被重构至少还有不少头文件还标记着我的名字的东西，已经被彻头彻尾和我无关了。所以，这个东西上了AppStore，似乎我也没资格感到高兴。不，应该是连感到悲哀的权利都没有。</p>

<p>最后，我没有在Appstore下载它，更别说刷一个五星评论了。这个可能还保留着我那些刚学iOS开发而写出来的无比稚嫩的代码的东西，经历了一次次的延期、需求变更，甚至一度被挂起、拆分，最终上了架，可惜连我都觉得，这东西上不上架，已经无啥意义了。</p>

<p>只是偶尔，即使已经不做越狱版了，我还会到BigBoss的统计页面，看看那个只发了四个版本的越狱版，到底被下载了多少次（BigBoss上的统计是对所有人公开的，其它渠道的下载统计等等数据，对我来说基本不可能拿得到）。看到那个数字居然还在缓慢增长，停止更新后居然还能慢慢多了两万多的下载量，嘴角还是轻轻上扬一下。当然，我知道下载量和日活量是两个完全不同的概念，卸载是个很方便的操作，况且那个支持越狱版通过桌面长按卸载deb的功能还是我做的哩。很二逼的需求，我想，这么一个没啥用户基础的软件，居然还提供快捷卸载方法，二到家了。</p>

<p>说说新项目吧。至少这个长期占据AppStore前100名中一席的app，肯定有其牛逼的原因。果不其然，要融入到这个团队之中，我至少需要先脱层皮，不然拉低整个团队的技术水平和智商水准可是不被容忍的。中途有一段时间没活干，还在内疚着没帮上什么忙，最近接连三个版本两两并行，于是就累得跟狗一样了。效率，以及对工作量的估算，对我来说还是个硬伤。</p>

<p>吐槽了半天，没总结半点和越狱开发相关的东西。可能之后会很少接触这些东西了。以此作结，纪念那段偶尔挺二逼但也挺随意的时光。</p>

<p>改bundleid，启动后改掉取bundleid的方法，让它返回的bundle固定为原来那个，然后重签名就可以了</p>

<p>如果不hook那个取bundleid的方法，登录几次就会提示你用的不是正版，然后让你退出登录</p>

<p>不过要我做盗版或多开监测的话，会加上签名验证</p>

<p>不越狱其实也可以做，二进制文件里有个dylb的map，可以差一条记录上去，挂载你自己的动态库。然后把你自己写的用来hook代码的动态库一起签名放到ipa包里安装就行了。不过略麻烦。</p>

<p>使用load command,在mach o的头里,不过也是需求重新签名</p>

<p>bundleid在二进制中也编译的有吧，仅仅改plots</p>

<p>直接改plist就行</p>

<p>bundleid在二进制中也编译的有吧，仅仅改Plist,好像不行</p>

<p>行的，已验证</p>

<p>这么说ipa重签名是可以的，难道苹果只验证plist文件？</p>

<p>不过为了原有代码里面的判断逻辑啥的正常，最好再didfinishlaunch后hook掉NSBundle 的bundleIdentifier，让其返回原来的。</p>

<p>你改为新的bundleid，然后用你自己的证书签名，苹果就当这个app是你写的了</p>

<p>可以用theos写个tweak，然后用runtime想这么玩就随意你了·</p>

<p>主要还是看能不能分析出原有的逻辑。</p>

<p>用theos就得越狱了吧</p>

<p>噗。。。都在问iOS逆向问题，有没有谁了解Android的防逆向的所谓的『加固』处理，原理是什么呢？各加的加固处理效果如何？</p>

<p>逆向的关键只有一句 找到入口</p>

<p>做过别人 app 的分析,主要 reveal 分析 view 解构，猜测对方怎么做的效果。。。</p>

<p>reveal神器，用越狱的手机+插件来拖界面</p>

<p>然后 dump 二进制文件，可以看别人在一些地方用到了什么库</p>

<p>应该只能逆向出oc的头文件，不能逆向出m文件吧？</p>

<p>另外用 cocoapod 的可以从 dump 的头文件看得出来，因为，每个 pod 都有一个 dummy class[偷笑]一下就知道对方用了什么库了</p>

<p>嗯嗯，是的，不过可以反汇编，其实 hopper 给出来的反汇编代码已经有很大帮助了</p>

<p>reveal只能看到界面相关的东西,分析界面用的,要是想把别人的逻辑都搞清楚还是挺费劲的。了解个大体还行。</p>

<p>全部逻辑搞清楚的话，其实很费劲的。。。</p>

<p>不过找关键逻辑，或者想要的东西的话，还可以了</p>

<p>现在好多https请求是单向验证，一个charles就搞定接口了</p>

<p>之前搞雅虎天气找他们地图图片怎么做的</p>

<p>最无语的是搞金融的都不加双向验证</p>

<p>我们在接口上现在HTTPS+参数加密</p>

<p>不过对于普通抓包还是够了，一开始还用zlib压缩了一层，然后发现安卓会有问题，就放弃zlib只用gzip简单压了一下</p>

<p>大家开发的时候后天接口地址是不是都放在头文件里面？地址都放在.m里面了.不过抓包跟踪一下也差不多能抓出来</p>

<p>我们通信用的ice</p>

<p>reveal感觉用得比较舒服就是调试辅助，例如找别人写的view的名字</p>

<p>用过找别人是用啥控件,唯一设备ID没啥好研究的吧,或者取出指针</p>

<p>哈哈哈，找别人用的控件我也干过。。。Reveal抓出来一看，原来也是用的第三方的View，在github上就找到了。。。</p>

<p>例如一个feed流里一个用户的头像不相似了，想看下用户头像的地址是不是有问题，就直接选中对应imageview，然后看地址，进到xcode里暂停，直接打po [0xxxxxxxxx url] 就好了</p>

<p>url还是sd_url了···忘记了···啊哈哈哈哈哈··反正这个原理···</p>

<p>@飞宇。 有啊，我是做广告相关的。大家拿出去钱砸广告新增用户就是按照这个排重的。idfa可以更改，很多刷榜公司就是靠假良骗钱的。</p>

<p>不是，是反设备清洗,防止一台设备伪造出成千上万设备</p>

<p>这不还有IP可查么</p>

<p>你可能花100w做了100w新增用户，其实是用一台设备搞出来的</p>

<p>ip也可以用vpn自动刷新，没听过刷榜公司么！之前积分墙火的时候，淘宝上一搜一大把。</p>

<p>开发相关的安全问题，除了代码安全，资源文件安全，接口安全，还有什么没？</p>

<p>人员安全？比如别把代码上传到Github里</p>

<p>最主要是别把各种 key 传 github 了，以及自建的 git 的访问权限控制好</p>

<p>别人家的app怎么在xcode里暂停调试呢？之家的···调试别人家的bug干啥···别人家的用lldbserver挂上去，也能断点</p>

<p>因为看到你前面说reveal配合调试imageview了</p>

<p>那个是调试自家的APP时用</p>

<p>ssh+debugserver是能调试 但是不太方便 有没有更好用的工具？iPhoneTunnel</p>

<p>还有一个办法，不过我试了下新版，好像经常卡死，不晓得现在还没好，你可以试试
给你截图</p>

<p>竟然截不了图了············直接说把，直接用xcode的attach proce</p>

<p>想问一下，从iOS8.4后，还有什么方法可以访问到非越狱机子的Document目录吗？</p>

<p>刚才那个方法想成功attch上，得给个啥东西来着··竟然一时想不起来了···</p>

<p>是不是要给debugserver重签名</p>

<p>给大家再说个大家可能不知道的tips，iOS5后用rvictl可以把iPhone的网卡虚拟到mac上，然后···你懂的···</p>

<p>估计现在在非越狱机子上非常难做到了。 毕竟iOS8.4后对沙盒的权限限制较大</p>

<p>iExplorer可以部分备份指定app，间接访问到document目录</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[微信机器人]]></title>
    <link href="http://al1020119.github.io/blog/2016/04/20/weixinjiqiren/"/>
    <updated>2016-04-20T13:32:08+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/04/20/weixinjiqiren</id>
    <content type="html"><![CDATA[<p> 基于iOS逆向工程的微信机器人</p>

<p>本文转自猫头鹰团队</p>

<p>推荐序</p>

<blockquote><p>本文的作者沙梓社和吴航共同编写了《 iOS 应用逆向工程》，文章中介绍的是一些基本的 iOS 领域的安全知识，但是由于普及不够，基本上没有被人们重视，希望本文能让大家重视到 iOS 的源代码安全问题。</p></blockquote>

<p>另外预告一下，我认识的一个做移动安全的白帽子即将公开一个在非越狱手机上通过 App 绕过 sandbox 的 iOS 漏洞视频，并且计划发布一系列 iOS 系统安全方面的文章。我争取到了授权，并在我的公众号上同步发表这些文章，敬请期待：）</p>

<p>以下是文章正文，略有调整。</p>

<!--more-->


<p>讲师介绍-沙梓社</p>

<ul>
<li>湖北武汉人，《iOS 应用逆向工程》系列图书的作者，在 Cydia（最大的越狱 iOS 商店）上有 11 款独立作品，接受过 CSDN 的专访，书的英文版在 GitHub 上开源后收获了 2600+ stars，是首位在 WWJC 上发表演讲的中国人，以「提升中国 iOS 开发者在国际上的地位」为己任。</li>
</ul>


<p>在很多朋友的眼里，iOS 逆向工程是一个小众、神秘的方向，为什么我会选择这个小众的方向呢？这要从我最喜欢的一首诗说起。第一次，我是在李开复的自传《世界因你不同》里看到这首诗，当时就感觉身心得到了非常强烈的震撼：</p>

<p><img src="http://al1020119.github.io/images/nixiangjiqiren001.jpg" title="Caption" ></p>

<p>因为我感觉到自己就是这类人：如果有两条路给我选，我确实会选更少人走的那一条。我发现自己是一个刻意保持自己跟别人不同的人。</p>

<p>在初次读到这首诗时，我还没有开始学习 iOS。在从事 iOS 方面的研究后，又从乔帮主亲自配音的广告中寻找到了灵感，发现苹果跟我的价值观非常一致，就是要追求不同。因此，我更加认定 iOS 就是我的主攻方向。</p>

<p><img src="http://al1020119.github.io/images/nixiangjiqiren002.jpg" title="Caption" ></p>

<p>我的成长之路，就是一条与众不同的未选之路：别人都在学「大众情人」Windows 时，我开始学「小众路人」iOS；别人都在学 iOS 正向开发时，我开始学 iOS 逆向工程。正是因为追求不同，我写的《iOS 应用逆向工程》成为了全球唯一一本 iOS 逆向相关书籍，而且有美国和韩国的出版社想要引进本书，打破了中国 iOS 知识产权零输出的尴尬纪录。我用自己的努力代表中国 iOS 开发者在国际上发声，而且为 iOS 主流社区所认可，作为中国人我感到非常自豪。</p>

<p>简单来说，我所研究的，主要是 iOS 应用层的逆向工程，对内核层的逆向工程只是稍有涉猎，没有入门。应用层的逆向工程，我感觉自己玩得差不多了，应用层的所有逆向工程相关问题，都可以用我那本书上介绍过的知识和技术得到解决，我觉得没有太大挑战性了，主要是劳动量问题。到了这个地步，我的规划主要分为 2 个方向：</p>

<p>继续从事内核研究，这个方向的终点是「越狱」（越狱即通过漏洞利用拿到iOS的root权限，代表了iOS技术研究的最高境界）；</p>

<p>换个脑子，用一些非技术能力武装自己，让自己成为一专多能的人才。这个方向的终点就是创业。</p>

<p>当然，很多朋友会问，IT 人员创业的普遍做法，都是去 BAT 这样的互联网公司干 2 年，观察一下他们的玩法，然后拉一个团队出来干。你问啥不这么干呢？主要是碰到了一个很好的项目。大公司一直都在那里，想什么时候去都可以；而好项目却不常有，机会过去就过去了，不等人，所以我在准备并不算充分的情况下选择了创业这条路。</p>

<p>交代完了我的背景，咱们可以进入正题了😁</p>

<p><img src="http://al1020119.github.io/images/nixiangjiqiren003.jpg" title="Caption" ></p>

<p>大意是「通过研究现有功能的实现原理，理解并融会贯通，在此基础上实现（甚至增强）这个功能。」也就是说，不是照猫画虎，而是师夷长技，「借刀杀人」。</p>

<p>在我的理解里，逆向工程是一种工程师式的高级思维方式。给你水、面粉、糖、芝麻，让你做烧饼，这是正向工程；给你一个烧饼，让你分析出它是由多少水、多少面粉、多少糖、多少芝麻组成的，这是逆向工程。也就是说，根据图纸制作实物的这个过程是正向工程，而根据实物倒推图纸的这个过程则是逆向工程。乔布斯曾说「Good artists copy; Great artists steal.」逆向工程有异曲同工之妙。</p>

<p>举几个通过逆向工程师夷长技的例子：</p>

<p><img src="http://al1020119.github.io/images/nixiangjiqiren004.jpg" title="Caption" ></p>

<p>通过逆向工程分析instagram滤镜算法。一个人可以“steal”一个滤镜算法团队的工作成果；</p>

<p>研究微信的网络传输协议，就像@58沈剑 在博客里说到的那样。就我目前对微信九牛一毛的研究来说，就已经发现了一处可以进一步节省流量的地方，但是估计是因为历史遗留问题，这块代码不好动；</p>

<p>看看1Password做了哪些防护。1Password是专门用于保存密码的，类似于保险柜，安全系数必须很高，它把我们的密码存在了哪里，通过什么方式加密？这些都是值得我们学习借鉴的地方。</p>

<p>除了去学习别人的长处，逆向工程还可以发现自己和别人的短处：</p>

<p><img src="http://al1020119.github.io/images/nixiangjiqiren005.jpg" title="Caption" ></p>

<p>这种低级错误，星巴克可以犯，但1Password不能犯；这取决于你的产品定位。这个错误当然是通过逆向工程发现的。</p>

<p>这是某世界500强企业犯的，通过HTTP协议明文传输用户手机和密码的低级错误：</p>

<p><img src="http://al1020119.github.io/images/nixiangjiqiren006.jpg" title="Caption" ></p>

<p>这是某突破3亿用户的移动App：</p>

<p><img src="http://al1020119.github.io/images/nixiangjiqiren007.jpg" title="Caption" ></p>

<p>把传输协议的密钥硬编码在代码里，有逆向工程基础的朋友可以轻松还原整套网络传输协议。淘宝上一堆堆的这个刷榜那个刷赞，就是这个原理。</p>

<p>阿凹(猫友会吉祥物，一个微信机器人)，是「借刀杀人」最典型的运用之一：</p>

<p><img src="http://al1020119.github.io/images/nixiangjiqiren008.jpg" title="Caption" ></p>

<p>阿凹的实现原理，简单说，就是通过逆向工程的方式找出微信iOS客户端的收发信息等私有接口，然后基于自己的逻辑调用这些接口，实现针对特殊事件的自动化应答功能。</p>

<p>我个人最常用的iOS逆向工程工具主要有这些：</p>

<p><img src="http://al1020119.github.io/images/nixiangjiqiren009.jpg" title="Caption" ></p>

<ol>
<li><p>dumpdecrypted：将苹果加过密的App砸壳。通过AppStore处理的App，都是加过密的，不能直接进行二进制分析，需要先解秘，业界称为「砸壳」。它的原理是等App完全加载进内存，得到解密后，再把解密过的内存给dump出来，形成解密后的二进制文件，可以直接分析。</p></li>
<li><p>class-dump：导出MachO文件里的ObjC类及方法定义。因为ObjC是一门强烈依赖于运行时的语言，它的文件类型是MachO（类比于Windows里的PE文件类型），MachO里存放了大量运行时需要用到的信息，从中可以收集整理，还原出一个App源代码里的ObjC头文件。</p></li>
<li><p>CydiaSubstrate：将第三方动态库注入进程。它是越狱插件的存在前提。在iOS开机时，会把特定目录下的所有库，给加载到指定的进程里，俗称「hook」或「钩子」。</p></li>
<li><p>Cycript：用JS语法写ObjC方法。这是Cydia之父Saurik发明的一门语言，我个人主要用它来测试私有函数。</p></li>
<li><p>Theos：越狱插件开发工具。是我的书序作者DHowett开发的。iOS正向开发用Xcode，逆向开发用Theos。</p></li>
<li><p>IDA：全平台反汇编、反编译工具。搞技术的一般都听说过这个软件，就不多介绍了。</p></li>
<li><p>Hopper：OSX反汇编、反编译工具。比IDA便宜了1000倍，但功能跟IDA差不多；主攻苹果系操作系统。</p></li>
<li><p>debugserver + LLDB：动态调试器。是大名鼎鼎的「苹果版」GDB。</p></li>
</ol>


<p>class-dump的效果，图中显示的是新浪微博App的所有头文件：</p>

<p><img src="http://al1020119.github.io/images/nixiangjiqiren010.jpg" title="Caption" ></p>

<p>Cycript的效果，可以看到微信星号密码的明文：</p>

<p><img src="http://al1020119.github.io/images/nixiangjiqiren011.jpg" title="Caption" ></p>

<p>Theos开发插件的运行效果：</p>

<p><img src="http://al1020119.github.io/images/nixiangjiqiren012.jpg" title="Caption" ></p>

<p>所有进程的[NSDictionary dictionaryWithContentsOfFile:]方法均被「hook」，可以随意篡改。</p>

<p>IDA的效果：</p>

<p><img src="http://al1020119.github.io/images/nixiangjiqiren013.jpg" title="Caption" ></p>

<p>对于熟悉汇编语言（图里是ARM汇编）的朋友来说，所有未加密的二进制文件，均等同于开源。这是什么概念，做技术的都懂。</p>

<h6>接下来我简单介绍下阿凹的制作流程：</h6>

<p>核心在于找到收发微信消息的函数，然后加以修改利用：</p>

<p><img src="http://al1020119.github.io/images/nixiangjiqiren014.jpg" title="Caption" ></p>

<p>用dumpdecrypted给微信砸壳，解密出的文件近50M：</p>

<p><img src="http://al1020119.github.io/images/nixiangjiqiren015.jpg" title="Caption" ></p>

<p>class-dump出微信的所有头文件，近7000个：</p>

<p><img src="http://al1020119.github.io/images/nixiangjiqiren016.jpg" title="Caption" ></p>

<ul>
<li><p>定位到收消息的View，进而定位到V对应的C，找出逻辑层的收消息函数。</p></li>
<li><p>定位到发消息的按钮（也是一个View），进而定位到对应的C，找出逻辑层的发消息函数（这个过程没法用截图表现出来，所以我只简单描述下）。</p></li>
</ul>


<p>组合收发函数，完成阿凹的逻辑，最后写代码：</p>

<p><img src="http://al1020119.github.io/images/nixiangjiqiren017.jpg" title="Caption" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[驱动开发]]></title>
    <link href="http://al1020119.github.io/blog/2016/04/15/qudongkaifa/"/>
    <updated>2016-04-15T13:32:08+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/04/15/qudongkaifa</id>
    <content type="html"><![CDATA[<h4>一、系统架构</h4>

<p><img src="http://al1020119.github.io/images/nixiangqudong001.png" title="Caption" ></p>

<p>我们编写的驱动一般运行在i/o Kit框架下。</p>

<h4>二、一些记录</h4>

<ul>
<li>开发工具 xcode</li>
<li>开发语言：c++, c</li>
</ul>


<p>c++用的是嵌入式c++，是标准c++的子集。</p>

<!--more-->


<p>所以，stl、异常、多重继承、模板和runtime类型信息  都无法使用。</p>

<p>因为这些东西会导致编译出来的文件很大，且容易导致问题。</p>

<p>c++只能编写基于i/o Kit框架的驱动，而c语言则可以编写任意的驱动。</p>

<p>并且c++的驱动反汇编后很难看。</p>

<blockquote><p>所以写驱动还是用c吧。这一点和微软默认的一样。</p></blockquote>

<h4>三、编写一个驱动例子</h4>

<ol>
<li>创建工程</li>
</ol>


<p><img src="http://al1020119.github.io/images/nixiangqudong002.png" title="Caption" ></p>

<p>因为不是设备驱动，只能选择extension；如果是设备驱动，则选择IOKit Driver。</p>

<ol>
<li>写代码</li>
</ol>


<p><img src="http://al1020119.github.io/images/nixiangqudong003.png" title="Caption" ></p>

<p>苹果将studio.h这样的c++库换成了自己的libkern.h。</p>

<ol>
<li>添加引用库
因为代码中使用了libkern.h，所以要修改工程。</li>
</ol>


<p><img src="http://al1020119.github.io/images/nixiangqudong004.png" title="Caption" ></p>

<ol>
<li>驱动入口</li>
</ol>


<p><img src="http://al1020119.github.io/images/nixiangqudong005.png" title="Caption" ></p>

<ol>
<li><p>编译驱动</p></li>
<li><p>在xcode的product菜单里点击build就可以编译驱动了。</p></li>
<li>xcode只是能编辑和编译驱动，无法调试驱动的。</li>
<li>编译驱动时，你需要有一个开发者账号，否则编译不过。</li>
<li>我没有账号，所以后面的操作无法进行，只能把书上的翻译过来。</li>
</ol>


<p>6、运行驱动有2种方式：</p>

<ul>
<li>1、拷贝驱动文件到目录 /system/library/extensions下，重启后自动运行；</li>
<li><p>2、在terminal中运行命令启动驱动：</p>

<ul>
<li>sudo chown -R root:wheel 驱动名.kext   // 设置驱动文件的权限，如果有权限，这步可省略。
sudo kextload 驱动名.kext  // 运行驱动</li>
</ul>
</li>
<li><p>卸载驱动：sudo kextunload 驱动名.kext</p></li>
<li><p>显示当前系统中的驱动：kextstat</p></li>
</ul>


<p><img src="http://al1020119.github.io/images/nixiangqudong006.png" title="Caption" ></p>

<ol>
<li>查看调试信息
printf输出的信息是保存在磁盘上的log文件中。通过tail和cat命令就可以查看。log文件在/var/log/kernel.log或者/Applications/Utilities目录下。</li>
</ol>


<p><img src="http://al1020119.github.io/images/nixiangqudong007.png" title="Caption" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[逆向支付宝]]></title>
    <link href="http://al1020119.github.io/blog/2016/04/10/nixiangzhifubao/"/>
    <updated>2016-04-10T13:32:08+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/04/10/nixiangzhifubao</id>
    <content type="html"><![CDATA[<p>为了了解支付宝app的源码结构，我们可以使用class-dump-z工具来分析支付宝二进制。
1.下载配置class_dump_z</p>

<p>前往 <a href="https://code.google.com/p/networkpx/wiki/class_dump_z">https://code.google.com/p/networkpx/wiki/class_dump_z</a> ，下载tar包，然后解压配置到本地环境</p>

<p>$ tar -zxvf class-dump-z_0.2a.tar.gz<br/>
$ sudo cp mac_x86/class-dump-z /usr/bin/
2.class_dump支付宝app
$ class-dump-z Portal > Portal-dump.txt</p>

<!--more-->


<pre><code>@protocol XXEncryptedProtocol_10764b0  
-(?)XXEncryptedMethod_d109df;  
-(?)XXEncryptedMethod_d109d3;  
-(?)XXEncryptedMethod_d109c7;  
-(?)XXEncryptedMethod_d109bf;  
-(?)XXEncryptedMethod_d109b8;  
-(?)XXEncryptedMethod_d109a4;  
-(?)XXEncryptedMethod_d10990;  
-(?)XXEncryptedMethod_d1097f;  
-(?)XXEncryptedMethod_d10970;  
-(?)XXEncryptedMethod_d10968;  
-(?)XXEncryptedMethod_d10941;  
-(?)XXEncryptedMethod_d10925;  
-(?)XXEncryptedMethod_d10914;  
-(?)XXEncryptedMethod_d1090f;  
-(?)XXEncryptedMethod_d1090a;  
-(?)XXEncryptedMethod_d10904;  
-(?)XXEncryptedMethod_d108f9;  
-(?)XXEncryptedMethod_d108f4;  
-(?)XXEncryptedMethod_d108eb;  
@optional  
-(?)XXEncryptedMethod_d109eb;  
@end
</code></pre>

<p>查看得到的信息是加过密的，这个加密操作是苹果在部署到app store时做的，所以我们还需要做一步解密操作。
3.使用Clutch解密支付宝app</p>

<p>1）下载Clutch
iOS7越狱后的Cydia源里已经下载不到Clutch了，但是我们可以从网上下载好推进iPhone
地址：Clutch传送门</p>

<p>2）查看可解密的应用列表</p>

<p>root</p>

<h1>./Clutch</h1>

<p>Clutch-1.3.2<br/>
usage: ./Clutch [flags] [application name] [&hellip;]<br/>
Applications available: 9P_RetinaWallpapers breadtrip Chiizu CodecademyiPhone FisheyeFree food GirlsCamera IMDb InstaDaily InstaTextFree iOne ItsMe3 linecamera Moldiv MPCamera MYXJ NewsBoard Photo Blur Photo Editor PhotoWonder POCO相机 Portal QQPicShow smashbandits Spark tripcamera Tuding_vITC_01 wantu WaterMarkCamera WeiBo Weibo</p>

<p>3）解密支付宝app</p>

<p>root# ./Clutch Portal</p>

<p>Clutch-1.3.2<br/>
Cracking Portal&hellip;<br/>
Creating working directory&hellip;<br/>
Performing initial analysis&hellip;<br/>
Performing cracking preflight&hellip;<br/>
dumping binary: analyzing load commands<br/>
dumping binary: obtaining ptrace handle<br/>
dumping binary: forking to begin tracing<br/>
dumping binary: successfully forked<br/>
dumping binary: obtaining mach port<br/>
dumping binary: preparing code resign<br/>
dumping binary: preparing to dump<br/>
dumping binary: ASLR enabled, identifying dump location dynamically<br/>
dumping binary: performing dump<br/>
dumping binary: patched cryptid<br/>
dumping binary: writing new checksum<br/>
Censoring iTunesMetadata.plist&hellip;<br/>
Packaging IPA file&hellip;</p>

<p>compression level: 0<br/>
    /var/root/Documents/Cracked/支付宝钱包-v8.0.0-(Clutch-1.3.2).ipa</p>

<p>elapsed time: 7473ms</p>

<p>Applications Cracked: <br/>
Portal</p>

<p>Applications that Failed:</p>

<p>Total Success: 1 Total Failed: 0</p>

<p>4）导出已解密的支付宝app</p>

<p>从上一步骤得知，已解密的ipa位置为：/var/root/Documents/Cracked/支付宝钱包-v8.0.0-(Clutch-1.3.2).ipa
将其拷贝到本地去分析</p>

<p>4.class_dump已解密的支付宝app</p>

<p>解压.ipa后，到 支付宝钱包-v8.0.0-(Clutch-1.3.2)/Payload/Portal.app 目录下，class_dump已解密的二进制文件
1</p>

<p>$ class-dump-z Portal > ~/Portal-classdump.txt</p>

<p>这回就可以得到对应的信息了：</p>

<p>@protocol ALPNumPwdInputViewDelegate <NSObject><br/>
-(void)onPasswordDidChange:(id)onPassword;<br/>
@end</p>

<p>@protocol ALPContactBaseTableViewCellDelegate <NSObject><br/>
-(void)shareClicked:(id)clicked sender:(id)sender;<br/>
@end</p>

<p>@interface MMPPayWayViewController : XXUnknownSuperclass &lt;SubChannelSelectDelegate, UITableViewDataSource, UITableViewDelegate, CellDelegate, UIAlertViewDelegate> {<br/>
@private<br/>
    Item<em> channelSelected;<br/>
    BOOL <em>bCheck;<br/>
    BOOL </em>bOpenMiniPay;<br/>
    BOOL <em>bNeedPwd;<br/>
    BOOL </em>bSimplePwd;<br/>
    BOOL <em>bAutopayon;<br/>
    BOOL </em>bHasSub;<br/>
    BOOL <em>bFirstChannel;<br/>
    BOOL </em>bChangeSub;<br/>
    BOOL _bClickBack;<br/>
    UITableView</em> <em>channelListTableView;<br/>
    NSMutableArray* </em>channelListArray;<br/>
    NSMutableArray<em> _subChanneSelectedlList;<br/>
    NSMutableArray</em> <em>unCheckArray;<br/>
    UIButton* </em>saveButton;<br/>
    UILabel<em> _tipLabel;<br/>
    MMPPasswordSwichView</em> <em>payWaySwitch;<br/>
    MMPPopupAlertView* </em>alertView;<br/>
    UIView<em> <em>setView;<br/>
    int </em>originalSelectedRow;<br/>
    int _currentSelectedRow;<br/>
    NSString</em> <em>statusCode;<br/>
    ChannelListModel* </em>defaultChannelList;<br/>
}<br/>
@property(assign, nonatomic) BOOL bClickBack;<br/>
@property(retain, nonatomic) ChannelListModel<em> defaultChannelList;<br/>
@property(retain, nonatomic) NSString</em> statusCode;<br/>
@property(assign, nonatomic) int currentSelectedRow;<br/>
@property(assign, nonatomic) int originalSelectedRow;<br/>
@property(retain, nonatomic) UIView<em> setView;<br/>
@property(retain, nonatomic) MMPPopupAlertView</em> alertView;<br/>
@property(retain, nonatomic) MMPPasswordSwichView<em> payWaySwitch;<br/>
@property(assign, nonatomic, getter=isSubChannelChanged) BOOL bChangeSub;<br/>
@property(assign, nonatomic) BOOL bFirstChannel;<br/>
@property(assign, nonatomic) BOOL bHasSub;<br/>
@property(assign, nonatomic) BOOL bAutopayon;<br/>
@property(assign, nonatomic) BOOL bSimplePwd;<br/>
@property(assign, nonatomic) BOOL bNeedPwd;<br/>
@property(assign, nonatomic) BOOL bOpenMiniPay;<br/>
@property(assign, nonatomic) BOOL bCheck;<br/>
@property(retain, nonatomic) UILabel</em> tipLabel;<br/>
@property(retain, nonatomic) UIButton<em> saveButton;<br/>
@property(retain, nonatomic) NSMutableArray</em> unCheckArray;<br/>
@property(retain, nonatomic) NSMutableArray<em> subChanneSelectedlList;<br/>
@property(retain, nonatomic) NSMutableArray</em> channelListArray;<br/>
@property(retain, nonatomic) UITableView* channelListTableView;<br/>
-(void).cxx_destruct;<br/>
-(void)subChannelDidSelected:(id)subChannel;<br/>
-(void)switchCheckButtonClicked:(id)clicked;<br/>
-(void)checkboxButtonClicked:(id)clicked;<br/>
-(void)onCellClick:(id)click;<br/>
-(void)showSubChannels;<br/>
-(void)tableView:(id)view didSelectRowAtIndexPath:(id)indexPath;<br/>
-(id)tableView:(id)view cellForRowAtIndexPath:(id)indexPath;<br/>
-(int)tableView:(id)view numberOfRowsInSection:(int)section;<br/>
-(float)tableView:(id)view heightForRowAtIndexPath:(id)indexPath;<br/>
-(int)numberOfSectionsInTableView:(id)tableView;<br/>
-(void)setTableViewFootView:(id)view;<br/>
-(void)setTableViewHeaderView:(id)view;<br/>
-(id)tableView:(id)view viewForHeaderInSection:(int)section;<br/>
-(id)tableView:(id)view viewForFooterInSection:(int)section;<br/>
-(float)tableView:(id)view heightForHeaderInSection:(int)section;<br/>
-(float)tableView:(id)view heightForFooterInSection:(int)section;<br/>
-(void)alertView:(id)view clickedButtonAtIndex:(int)index;<br/>
-(void)clickSave;<br/>
-(void)netWorkRequestWithPwd:(id)pwd;<br/>
-(void)setPayWaySwitchStates:(id)states;<br/>
-(void)changePayWaySwitch:(id)aSwitch;<br/>
-(void)scrollToSelectedRow;<br/>
-(void)didReceiveMemoryWarning;<br/>
-(void)viewDidLoad;<br/>
-(void)applicationEnterBackground:(id)background;<br/>
-(void)dealloc;<br/>
-(void)goBack;<br/>
-(BOOL)isChannelsSetChanged;<br/>
-(id)subChannelCode:(int)code;<br/>
-(id)subChannelDesc:(int)desc;<br/>
-(id)initWithDefaultData:(id)defaultData;<br/>
-(id)initWithNibName:(id)nibName bundle:(id)bundle;<br/>
-(void)commonInit:(id)init;<br/>
@end
5.分析支付宝源码片段</p>

<p>1）使用了@private关键字限制成员访问权限
但是实际上，在Objective-C编程中，使用@private连Keypath访问都拦不住的</p>

<p>2）抛出了冗长的成员对象
这非常有利分析程序结构
6.进一步思考</p>

<p>1）如何利用 class-dump 结果，结合 cycript 进行攻击呢？
2）class-dump-z 如此强大，有什么方法可以减少暴露的信息吗？</p>

<p>接下来的博文将针对上面的思考，继续总结～</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[非6S-实现3D Touch]]></title>
    <link href="http://al1020119.github.io/blog/2016/04/05/fei6sshixian3dtouch/"/>
    <updated>2016-04-05T13:32:08+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/04/05/fei6sshixian3dtouch</id>
    <content type="html"><![CDATA[<p>首先先给我这困难的语言表达能力道个歉哈，真的尽力了。
本章排版是参照<a href="http://bbs.pediy.com/showthread.php?t=205133%E5%A4%A7%E7%A5%9E%E7%9A%84%E6%9D%A5%E6%8E%92%E7%9A%84%EF%BC%8C%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%86%99%E5%BF%83%E5%BE%97%E6%96%87%EF%BC%8C%E4%B9%9F%E6%8A%8A%E6%89%80%E5%AD%A6%E5%88%B0%E7%9A%84%E5%88%86%E4%BA%AB%E7%BB%99%E5%A4%A7%E5%AE%B6">http://bbs.pediy.com/showthread.php?t=205133%E5%A4%A7%E7%A5%9E%E7%9A%84%E6%9D%A5%E6%8E%92%E7%9A%84%EF%BC%8C%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%86%99%E5%BF%83%E5%BE%97%E6%96%87%EF%BC%8C%E4%B9%9F%E6%8A%8A%E6%89%80%E5%AD%A6%E5%88%B0%E7%9A%84%E5%88%86%E4%BA%AB%E7%BB%99%E5%A4%A7%E5%AE%B6</a></p>

<p>最近才接触不久的逆向工程,刷夜,爆肝,把《iOS应用逆向工程》这本书的工具，全部看了一遍，并且尝试了一遍，感觉需要点什么。 那就是实践！  最近6s手机出了3DTouch，无奈手中没有这款机型，恰好最近对逆向小有心得，又听说过已经有插件能实现同样的需求，证明确实有可行性，于是开动。根据点击的判断和出现，初步感觉，这应该不需要多少行代码就能搞定，应该只要添加一个手势，或者是更改一个手势的点击事件，让系统认为发生了3DTouch点击事件，就可以了。</p>

<ul>
<li>所需工具: cycript，openSSH，class-dump</li>
<li>测试环境：iOS9.0.2，iPhone5s</li>
<li>备注：因为自身没有3DTouch，所以需要下载一个插件，让机器拥有3DTouch功能，我使用的是forcy，通过覆盖长按手势，实现</li>
</ul>


<p>通过查阅官方文档，得到关键词  Shortcut Menu peek pop
这个词将来就是要在找关键方法时刻所要用到的</p>

<!--more-->


<h4>现在开始！</h4>

<p>通过ssh连接到手机，然后将cycript注入到SpringBoard</p>

<pre><code>huangjipingde-iPhone:~ root# cycript -p SpringBoard
</code></pre>

<p>首先 先隆重介绍1个方法，2个函数</p>

<ul>
<li>1方法 [view recursiveDescription]  该方法可以当做是Reveal的文字版，用来查看当前页面的布局</li>
<li><p>2函数，原理均是runtime，但是第二个没有怎么看懂。。。</p></li>
<li><p>printMethods 打印出该类所有的方法，后边接的是实现的地址,在这儿补充一下，如果想对某个方法打断点，但是又不想使用ida查看方法偏移，可以直接在这实现的地址处，添加断点，虽然不知道断在什么地方，但是可以肯定一定是在执行该方法的时候。效果如下图：</p></li>
</ul>


<p>代码:</p>

<pre><code>function printMethods(className){
var count = new new Type("I");
var methods = class_copyMethodList(objc_getClass(className),count);
var methodsArray = [];
for (var i = 0; i &lt; *count; i++){
var method = methods[i];
methodsArray.push({selector:method_getName(method), implentation:method_getImplementation(method)});
}
free(methods);
free(count);
return methodsArray;
}
</code></pre>

<p><img src="http://al1020119.github.io/images/nixiangqudong001.png" title="Caption" ></p>

<ol>
<li><p>tryPrintIvars打印出对象所有的属性，效果如下图：
代码:</p>

<p>  function tryPrintIvars(a){
  var x={};
  for(i in <em>a){
  try{
  x[i] = (</em>a)[i];
  } catch(e){}
  }
   return x;}</p></li>
</ol>


<p><img src="http://al1020119.github.io/images/nixiangqudong002.png" title="Caption" ></p>

<p>准备工作都做好了，将两个函数都先输入进去</p>

<p><img src="http://al1020119.github.io/images/nixiangqudong003.png" title="Caption" ></p>

<p>因为最后的目标是应用图标，所以，现在我们从主界面开始着手打印它的UI布局
代码:</p>

<pre><code>[[UIApplication sharedApplication].keyWindow.rootViewController.view recursiveDescription]
</code></pre>

<p><img src="http://al1020119.github.io/images/nixiangqudong004.png" title="Caption" ></p>

<p>然后出来了一大片，红呦呦的代码，看着都眼睛疼，4点钟时看得眼睛都瞎了啊。此时应想，主界面可以滚动，是一个scrollView，是scrollView就得有contentSize，然后一看手机的页面，总共有5页，由于5s机型的宽度是320，所以这时候可以大胆猜测它的contentSize的最大宽度是1600，然后commond+F大法</p>

<p><img src="http://al1020119.github.io/images/nixiangqudong005.png" title="Caption" ></p>

<p>准确命中，同时，还注意到，它的contentOffset是960又此时我的页面正是第4页，基本锁定目标，查找frame的坐标是960，0的view，此时可以得到大量信息了，SBRootIconListView，这个就是用来装一页所有图标的View，SBIconListModel这个里边，我猜是装了该view里边的模型信息，注意，11 icons，正好是我们页面所有的图标数，此时再看后边SBIconView的size 62，62  这和图标尺寸的差距只有2个点，基本锁定，它就是我们要找的目标</p>

<p><img src="http://al1020119.github.io/images/nixiangqudong006.png" title="Caption" ></p>

<ul>
<li><p>此时，让我们找到是什么在处理SBIconView的事件，我们所知道的，view一般是用来展示的，事件的发生一般都会交给代理来负责。让我们使用nextResponder，或者寻找他们的代理，来定位到一个controller文件，很幸运，直接一步就找到了，就是它：SBIconController！</p></li>
<li><p>此时，我们可以class-dump出SpringBoard的头文件了，去查看一下它的里边都有些什么方法和属性，如果想偷懒，去github直接搜索也行。。。
根据关键词和方法名译的意思大致锁定出来以下几个方法</p></li>
</ul>


<p>ps：  这儿的char 是BOOL类型
代码:</p>

<pre><code>-(void)_handleShortcutMenuPeek:(id)arg1 ;
-(SBApplicationShortcutMenu *)presentedShortcutMenu;
-(char)_canRevealShortcutMenu;
-(id)_aggregateLoggingAppKeyForShortcutMenu:(id)arg1 ;
-(void)applicationShortcutMenu:(id)arg1 activateShortcutItem:(id)arg2 index:(int)arg3 ;
-(void)applicationShortcutMenu:(id)arg1 startEditingForIconView:(id)arg2 ;
-(void)applicationShortcutMenu:(id)arg1 launchApplicationWithIconView:(id)arg2 ;
-(void)applicationShortcutMenuDidPresent:(id)arg1 ;
-(void)_revealMenuForIconView:(id)arg1 presentImmediately:(char)arg2 ;
</code></pre>

<p>自己写一个tweak，hook所有的这些函数，给他们所有的实现之前加上一个NSLog（），查看调用的顺序，和传进来的值的类型。 以及一次Peek事件所关联到了哪些方法。
代码:</p>

<pre><code>%hook SBIconController

- (void)_revealMenuForIconView:(id)arg1 presentImmediately:(BOOL)arg2 {
NSLog(@"ZZT3D _revealMenuForIconView:arg1:%s,%@--arg2:%c",object_getClassName(arg1), arg1, arg2);
    %orig;
}

- (void)_handleShortcutMenuPeek:(id)arg1
{
NSLog(@"ZZT3D _handleShortcutMenuPeek:%s,%@",object_getClassName(arg1),arg1);
%orig;
}

-(char)_canRevealShortcutMenu
{
NSLog(@"ZZT3D _canRevealShortcutMenu");
  return %orig;
}
-(id)_aggregateLoggingAppKeyForShortcutMenu:(id)arg1{

 NSLog(@"ZZT3D ggregateLoggingAppKeyForShortcutMenu:%s,%@",object_getClassName(arg1),arg1);
    return %orig;
}

-(void)applicationShortcutMenu:(id)arg1 activateShortcutItem:(id)arg2 index:(int)arg3
{
NSLog(@"ZZT3D activateShortcutItem:arg1%s,%@—arg2%s,%@--arg3:%d",object_getClassName(arg1),arg1,object_getClassName(arg2),arg2,arg3);
%orig;
}


-(void)applicationShortcutMenu:(id)arg1 startEditingForIconView:(id)arg2 {
NSLog(@"ZZT3D startEditingForIconView:arg1%s,%@—arg2%s,%@",object_getClassName(arg1),arg1,object_getClassName(arg2),arg2);
%orig;

}
-(void)applicationShortcutMenu:(id)arg1 launchApplicationWithIconView:(id)arg2{
NSLog(@"ZZT3D launchApplicationWithIconView:arg1%s,%@—arg2%s,%@",object_getClassName(arg1),arg1,object_getClassName(arg2),arg2);
%orig;
}

-(void)applicationShortcutMenuDidPresent:(id)arg1{
NSLog(@"ZZT3D applicationShortcutMenuDidPresent:%s,%@",object_getClassName(arg1),arg1);
%orig;
}

%end
</code></pre>

<p>此时我们拿手机进行一次长按操作，使其弹出ShotcutMenu菜单，然后在openSSH中查看系统日志grep ZZT3D /var/log/syslog查看一下，该事件处理分别使用了那几个方法。</p>

<p><img src="http://al1020119.github.io/images/nixiangqudong007.png" title="Caption" ></p>

<p>因为是要欺骗系统，所以方法应该是在前方，初步定位到这3个方法，第一个顾名思义返回值就是能不能显示shotcutMenu，第二个，我们可以看到，这里传进来了一个手势，通过这手势的信息，基本可以推断，这个就是插件作者用来欺骗系统的手势，而该方法，就是手势的target方法，第三个，根据意思可以得知，从XXiconView，是否立即显示。核心就在于这儿了。最后，我们再打印一遍SBIconView的所有属性，用来确认一下</p>

<p><img src="http://al1020119.github.io/images/nixiangqudong008.png" title="Caption" ></p>

<p>继续搜索关键词，果然又有大收获_shortcutMenuPeekGesture有一个如此手势，里边的东西的手势。</p>

<p><img src="http://al1020119.github.io/images/nixiangqudong009.png" title="Caption" ></p>

<p>猜测得到了极大的肯定，下面就开始编写tweak了
由于是要给每一个iconView都添加手势，并且只添加一次，所以翻看了iconView头文件，查看他的init方法，选择了在initWithContentType中初始化。
贴上Tweak.xm的源码
关于代码的编写，中间也踩过不少坑，比如_revealMenuForIconView中的yes，no的设置，还好一开始猜的时候就全部手动赋值。
至于手势为什么传值需要如此怪异，因为检测发现原方法只识别长按手势，并不识别轻扫手势，但是因为个人习惯，不想覆盖系统的手势，只想单纯的增加一个功能。耿直的楼主尝试将一个轻扫手势，强行变成长按手势。很多属性都是readonly，但是这个使用kvc轻松搞定，现在轻扫一下手机！出现了意想之中的弹窗！
代码:</p>

<pre><code>#import "ZZ3DTouch.h"

%hook SBIconView 

- (id)initWithContentType:(id)arg1{
// 设置3Dtouch手势
  // 手势传过去的就是手势自己本身,本身拥有所在的view
  self.shortcutMenuPeekGesture = [[%c(UISwipeGestureRecognizer) alloc] initWithTarget:[%c(SBIconController) sharedInstance] action:@selector(_handleShortcutMenuPeek:)];
  self.shortcutMenuPeekGesture.direction = UISwipeGestureRecognizerDirectionUp;

  return %orig;
}

%end

%hook SBIconController

- (void)_revealMenuForIconView:(id)arg1 presentImmediately:(BOOL)arg2 {

  // yes 改为no之后没有显示，或者没有设置也会不显示

  %orig(iconView, YES);

}

- (void)_handleShortcutMenuPeek:(id)arg1

{
  UISwipeGestureRecognizer *swipe = arg1;
  UILongPressGestureRecognizer *press = [[UILongPressGestureRecognizer alloc] init];
  [press setValue:@(UIGestureRecognizerStateBegan) forKey:@"state"];
  [press setValue:swipe.view forKey:@"view"];

%orig(press);

}
%end
</code></pre>

<p><img src="http://al1020119.github.io/images/nixiangqudong010.png" title="Caption" ></p>

<p><img src="http://al1020119.github.io/images/nixiangqudong011.png" title="Caption" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[游戏反编译]]></title>
    <link href="http://al1020119.github.io/blog/2016/03/30/youxifanbianyi/"/>
    <updated>2016-03-30T13:32:08+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/03/30/youxifanbianyi</id>
    <content type="html"><![CDATA[<p> ipa游戏反编译
看不懂的请飘过，不要继续。
这不是给新手看的，也代表你不需要解决程序的修改问题。
这些技巧不只用于游戏的修改。</p>

<p>下載 Windows 工具</p>

<p>Windows :
winscp <a href="http://winscp.net/eng/download.php">http://winscp.net/eng/download.php</a>
PuTTY <a href="http://putty.very.rulez.org/latest/x86/putty.exe">http://putty.very.rulez.org/latest/x86/putty.exe</a></p>

<p>Mac / Linux :
用內置的 Terminal 便可</p>

<!--more-->


<p>没 wifi 用 iPhone Tunnel Suite 3.0
<a href="http://bbs.weiphone.com/read-htm-tid-597149.html">http://bbs.weiphone.com/read-htm-tid-597149.html</a></p>

<p>苹果电脑用 iPhoneSSH
<a href="http://bbs.weiphone.com/read-htm-tid-720564.html">http://bbs.weiphone.com/read-htm-tid-720564.html</a></p>

<p>iPhone/iPod Touch 在 cydia 內安裝 deb 包
安装这些 deb 包最方便的方法是在 Cydia 内搜索及直接安装，这里提供的下载包及依赖包的链接下载点是方便手工安装时用</p>

<p>OpenSSH (openssh) 及 OpenSSL(openssl) （与iPhone/iPod Touch 终端操作）
<a href="http://apt.saurik.com/debs/openssh_5.2p1-8_iphoneos-arm.deb">http://apt.saurik.com/debs/openssh_5.2p1-8_iphoneos-arm.deb</a>
<a href="http://apt.saurik.com/debs/openssl_0.9.8k-9_iphoneos-arm.deb">http://apt.saurik.com/debs/openssl_0.9.8k-9_iphoneos-arm.deb</a></p>

<p>unzip 及 zip （解压缩及压缩打包工具）
<a href="http://apt.saurik.com/debs/unzip_5.52-5_iphoneos-arm.deb">http://apt.saurik.com/debs/unzip_5.52-5_iphoneos-arm.deb</a>
<a href="http://apt.saurik.com/debs/zip_2.32-5_iphoneos-arm.deb">http://apt.saurik.com/debs/zip_2.32-5_iphoneos-arm.deb</a></p>

<p>vbindiff (iPhone 上的十六进制查看差异及修改器)
<a href="http://apt.saurik.com/debs/vbindiff_3.0b1-3_iphoneos-arm.deb">http://apt.saurik.com/debs/vbindiff_3.0b1-3_iphoneos-arm.deb</a></p>

<p>Link Identity Editor (ldid) 及 Darwin CC Tools (odcctools)（修改后用 ldid 签名, odcctools 包括 otool, linker , assembler汇编)
<a href="http://apt.saurik.com/debs/ldid_610-5_iphoneos-arm.deb">http://apt.saurik.com/debs/ldid_610-5_iphoneos-arm.deb</a>
<a href="http://apt.saurik.com/debs/odcctools_286-8_iphoneos-arm.deb">http://apt.saurik.com/debs/odcctools_286-8_iphoneos-arm.deb</a>
<a href="http://apt.saurik.com/debs/uuid_1.6.0-2_iphoneos-arm.deb">http://apt.saurik.com/debs/uuid_1.6.0-2_iphoneos-arm.deb</a></p>

<p>Diff Utilities (diffutils) (文本差异工具 diff)
<a href="http://apt.saurik.com/debs/diffutils_2.8.1-6_iphoneos-arm.deb">http://apt.saurik.com/debs/diffutils_2.8.1-6_iphoneos-arm.deb</a></p>

<p>less (文本查看工具)
<a href="http://apt.saurik.com/debs/less_418-3_iphoneos-arm.deb">http://apt.saurik.com/debs/less_418-3_iphoneos-arm.deb</a></p>

<p>Vi IMproved (vim) 或 nano (文本编辑工具)
<a href="http://apt.saurik.com/debs/vim_7.1-3_iphoneos-arm.deb">http://apt.saurik.com/debs/vim_7.1-3_iphoneos-arm.deb</a>
<a href="http://apt.saurik.com/debs/ncurses_5.7-9_iphoneos-arm.deb">http://apt.saurik.com/debs/ncurses_5.7-9_iphoneos-arm.deb</a>
或
<a href="http://apt.saurik.com/debs/nano_2.0.7-5_iphoneos-arm.deb">http://apt.saurik.com/debs/nano_2.0.7-5_iphoneos-arm.deb</a>
<a href="http://apt.saurik.com/debs/ncurses_5.7-9_iphoneos-arm.deb">http://apt.saurik.com/debs/ncurses_5.7-9_iphoneos-arm.deb</a></p>

<p>GNU Debugger (gdb) (程序调试工具) iOS 4.3.x 更新
<a href="http://apt.saurik.com/debs/gdb_1518-11_iphoneos-arm.deb">http://apt.saurik.com/debs/gdb_1518-11_iphoneos-arm.deb</a>
<a href="http://apt.saurik.com/debs/ncurses_5.7-9_iphoneos-arm.deb">http://apt.saurik.com/debs/ncurses_5.7-9_iphoneos-arm.deb</a>
<a href="http://apt.saurik.com/debs/readline_6.0-7_iphoneos-arm.deb">http://apt.saurik.com/debs/readline_6.0-7_iphoneos-arm.deb</a>
<a href="http://apt.saurik.com/debs/sqlite3_3.5.9-12_iphoneos-arm.deb">http://apt.saurik.com/debs/sqlite3_3.5.9-12_iphoneos-arm.deb</a>
<a href="http://apt.saurik.com/debs/sqlite3-lib_3.5.9-2_iphoneos-arm.deb">http://apt.saurik.com/debs/sqlite3-lib_3.5.9-2_iphoneos-arm.deb</a>
<a href="http://apt.saurik.com/debs/sqlite3-dylib_3.5.9-1_iphoneos-arm.deb">http://apt.saurik.com/debs/sqlite3-dylib_3.5.9-1_iphoneos-arm.deb</a></p>

<p>GNU Debugger (gdb) (程序调试工具)
<a href="http://apt.saurik.com/debs/gdb_962-5_iphoneos-arm.deb">http://apt.saurik.com/debs/gdb_962-5_iphoneos-arm.deb</a>
<a href="http://apt.saurik.com/debs/ncurses_5.7-9_iphoneos-arm.deb">http://apt.saurik.com/debs/ncurses_5.7-9_iphoneos-arm.deb</a>
<a href="http://apt.saurik.com/debs/readline_6.0-7_iphoneos-arm.deb">http://apt.saurik.com/debs/readline_6.0-7_iphoneos-arm.deb</a>
<a href="http://apt.saurik.com/debs/sqlite3_3.5.9-12_iphoneos-arm.deb">http://apt.saurik.com/debs/sqlite3_3.5.9-12_iphoneos-arm.deb</a>
<a href="http://apt.saurik.com/debs/sqlite3-lib_3.5.9-1_iphoneos-arm.deb">http://apt.saurik.com/debs/sqlite3-lib_3.5.9-1_iphoneos-arm.deb</a>
<a href="http://apt.saurik.com/debs/sqlite3-dylib_3.5.9-1_iphoneos-arm.deb">http://apt.saurik.com/debs/sqlite3-dylib_3.5.9-1_iphoneos-arm.deb</a></p>

<p>adv-cmds (ps 工具)
<a href="http://apt.saurik.com/debs/adv-cmds_119-5_iphoneos-arm.deb">http://apt.saurik.com/debs/adv-cmds_119-5_iphoneos-arm.deb</a></p>

<p>grep (grep 文本搜索工具)
<a href="http://apt.saurik.com/debs/grep_2.5.4-3_iphoneos-arm.deb">http://apt.saurik.com/debs/grep_2.5.4-3_iphoneos-arm.deb</a></p>

<p>ARM 参考书籍</p>

<p><a href="http://bbs.weiphone.com/read-htm-tid-363306.html">http://bbs.weiphone.com/read-htm-tid-363306.html</a></p>

<p>ARM指令集及使用方法</p>

<p>ARM System Developer&rsquo;s Guide (主要是看第三章 Chapter 3)</p>

<p>ARM Assembly Language Programming</p>

<p>修改及用 gdb 调试游戏流程</p>

<p>(1) 安装及试玩游戏，每个游戏的修改方法都不同，没有玩过这游戏，怎样知道要修改什么呢？
这教程用了 Final Fantasy 2 作例子</p>

<p>(2) 用 iTunes 安装 Final Fantasy 2 破解版本 (未破解的不能反汇编)</p>

<p>(3) 用putty / ssh 连接iPhone / iPod Touch，假设你的iPhone / iPod Touch 的IP地址是192.168.1.104</p>

<p>Connection type: 选 SSH
Port 选 22
按 Open</p>

<p>PuTTY 连接 192.168.1.104 后</p>

<p>Login 打 root
Password(假设你没有更改密码) 打 alpine</p>

<p>Mac / Linux Terminal 内打
ssh <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#58;&#114;&#x6f;&#111;&#x74;&#64;&#49;&#x39;&#50;&#46;&#x31;&#54;&#56;&#x2e;&#49;&#x2e;&#x31;&#x30;&#52;">&#x72;&#111;&#x6f;&#x74;&#x40;&#x31;&#x39;&#50;&#x2e;&#49;&#54;&#56;&#x2e;&#49;&#x2e;&#x31;&#x30;&#x34;</a></p>

<p>(4) 进入游戏路径目录内(先决条件是已用 PuTTy / Terminal 连接iPhone / iPod Touch)
打
复制代码</p>

<pre><code>cd /var/mobile/Applications/*/FinalFantasy2.app
</code></pre>

<p>(5) 到上一层路径目录建立 cheat 临时工作路径目录及游戏程式临时修改档
打
复制代码</p>

<pre><code>cd ..
mkdir -p cheat
cd cheat
cp -p ../FinalFantasy2.app/FinalFantasy2 FinalFantasy2.original
</code></pre>

<p>(6) 反汇编原游戏程式
复制代码</p>

<pre><code>otool -tv FinalFantasy2.original &gt; FinalFantasy2.original.txt
</code></pre>

<p>(7) 查看反汇编代码分析并找出要修改的地方(每个游戏的修改地方都不同, 这点最难)
要修改游戏，你会有以下的困难或问题：</p>

<p>(i) 没有高阶源代码，只有反汇编代码
反汇编代码分析是困难的但绝对不是不可能作分析，你可以找到些不错的ARM Assembly的参考书
在上面亦已提供了一些很好的 ARM 指令参考
常见的是以下这些基本的指令及其执行条件码：</p>

<p>MOV 或 MVN 寄存器数值的传送操作
ADD 或 SUB 加减的算术操作
CMP 或 CMN 比较操作
AND、ORR、EOR 逻辑操作
B、BL、BNE、BGE 分支/跳转指令
MUL 乘法操作 或 LSL 是 二进制左移，左移一位，即十进制乘2倍
LDR 或 STR 加载及存储数据</p>

<p>每个指令都可加上执行条件码根据上一个运算、逻辑或比较指令的结果决定是否执行指令</p>

<p>执行条件码 (Condition Codes)：
① CS 及 CC（Carry）进位条件码，CS＝进位，否则＝CC(不进位).
② EQ 及 NE （Equal 或 Zero）相等或零条件码，EQ＝运算结果为相等或零时，否则＝NE(不相等).
③ VS 及 VC（Overflow）溢出条件码。 VS=溢出，否则＝VC(不溢出)。
④ PL 及 MI 条件码。 PL（Plus/Positive）＝结果为正，MI（Minus/Negative）＝结果为负。</p>

<p>⑤ GT 及 LT 条件码。 GT（Greater Than）＝大于(PL+VC+NE / MI+VS+NE)，LT（Less Than）＝小于(MI+VC / PL+VS)。
⑥ GE 及 LE 条件码。 GE（Greater Than or Equal）＝大或等于(PL+VC / MI+VS)，LE（Less Than or Equal）＝小或等于(MI+VC / PL+VS / EQ)。
⑦ HI 及 LO 条件码。 HI（Higher Than）＝无符号数(unsigned)高于(CS+NE)，LO（Lower Than）＝无符号数(unsigned)低于(CC)。
⑧ HS 及 LS 条件码。 HS（Higher or Same）＝无符号数(unsigned)高于或相等(CS/EQ)，LS（Lower or Same）＝无符号数(unsigned)低于或相等(CC/EQ)。
⑨ AL 及 NV 条件码。 条件码默认为AL（Always）＝无条件执行，NV（Never）是AL的相反＝不执行。</p>

<p>例子及其注解意思
复制代码</p>

<p>CMP R0, R1       @寄存器数值 R0 及 R1 的比较
MOVGT R2, R0     @如果结果 R0 >(大于) R1，则执行MOV R2, R0即 R2＝R0
MOVLE R2, R1     @如果结果 R0 &lt;=(小或等于) R1，则执行MOV R2, R1即 R2＝R1</p>

<p>复制代码</p>

<p>LDR R1, [R0]     @意思是 R1 = <em>R0，从R0指向的地址处的数据载入到寄存器 R1
STR R1, [R0]     @意思是 </em>R0 = R1，把寄存器 R1内的数据写到 R0 内指向的地址处</p>

<p>ARM 指令集及使用方法</p>

<p>(ii) 看不懂游戏程式流程，没法分析
有很多人都喜欢用 IDA Pro Advanced 去做分析， 无疑这软件是个非常好的静态分析工具，它有图形视图显示代码流程作搜索及深层分析。除了可分析反汇编代码外，亦可反汇编一些 otool 不能处理的工作。 但 IDA Pro Advanced 在iPhone 的程式只适合做静态的分析。</p>

<p>你可以在这里下载 IDA Pro Advanced 5.2 及其参考书，建议你使用功能及视图比较强大的 Windows 版本。
<a href="http://bbs.weiphone.com/read-htm-tid-363306.html">http://bbs.weiphone.com/read-htm-tid-363306.html</a></p>

<p>只看代码是不能作分析，要配合动态调试去了解程式的细节在实际运行时发生的数据及变化。在第15步就有用 gdb 作动态调试的例子去设置断点、继续、跟踪及分析代码。gdb 的参考书可在上面的链接下载。</p>

<p>(iii) 找不到游戏的数据例如金钱，经验值，装备，等级暂存在那？</p>

<p>引用</p>

<p>方法一：在 gdb 设置断点分析
ARM CPU 有个特性便是一些加减计算要传送到CPU寄存器(register) 进行，因此你会经常看到这些要找的数据会先从内存用LDR 指令载入到寄存器, 经过一些计算(加或减)后及防溢位判断后便用STR 指令存储这寄存器回内存地址。</p>

<p>另外由于这些程式大多是用 Objective C 或 C++ 语言写成，这些程序员会用一些描述性的函数名，例如带有 Money, Price, Gold, Exp, Item, Life, Level 字段等。</p>

<p>利用这两点便可以将程序锁定在某些函数上，再利用 gdb 调试工具暂停在某些点一步一步地单步执行及查看一些寄存器，印证是否与你要找的数据是否有关。</p>

<pre><code>在FinalFantasy2 的这实例中, 是用这方法找到修改点
用 less 工具去找寻 Money
putty / Terminal 打
</code></pre>

<p>复制代码</p>

<pre><code>less FinalFantasy2.original.txt



在 less 工具內打
</code></pre>

<p>复制代码</p>

<pre><code>/Money


去开始找寻(按 N 键去继续找寻)，便会找到这段代码像是要存储金钱数据(SetMoney)，0007b218是进入这段代码的开始地址
</code></pre>

<p>复制代码</p>

<pre><code>__ZN14cFF2GlobalWork19sysGAMEPrm_SetMoneyEj:
0007b218 e59f300c ldr r3, [pc, #12] ; 0x7b22c
0007b21c e580120c str r1, [r0, #524]
0007b220 e1510003 cmp r1, r3
0007b224 8580320c strhi r3, [r0, #524]
0007b228 e12fff1e bx lr



首先在iPhone或iPod Touch 开始Final Fantasy 2 直至游戏已 Resume及进入游戏。


① 在PuTTY / Terminal 找FinalFantasy2 的运行中的进程编号(process id)

PuTTY / Terminal 打
</code></pre>

<p>复制代码</p>

<pre><code>ps ax



得到
</code></pre>

<p>复制代码</p>

<pre><code>1115   ??  Ss     1:30.86 /var/mobile/Applications/XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX/FinalFantasy2.app/FinalFantasy2



找到FinalFantasy2 游戏现时运行中的进程编号是 1115

② 用gdb 进入调试运行中的进程编号1115
PuTTY / Terminal 打
</code></pre>

<p>复制代码</p>

<pre><code>gdb -p 1115



此时游戏会暂停，音乐也暂停

③ 用gdb 设定断点breakpoint在十六进制地址0x7b218

PuTTY / Terminal 打
</code></pre>

<p>复制代码</p>

<pre><code>break *0x7b218



④ 继续 continue 游戏
PuTTY / Terminal 打
</code></pre>

<p>复制代码</p>

<pre><code>c



⑤ 将Final Fantasy 2 游戏进入战斗，战胜后游戏会在十六进制地址0x7b218处停止

⑥ 暂停后，离开这分支__ZN14cFF2GlobalWork19sysGAMEPrm_SetMoneyEj
PuTTY / Terminal 打
</code></pre>

<p>复制代码</p>

<pre><code>finish



⑦ 反汇编现时地址上面的代码
</code></pre>

<p>复制代码</p>

<pre><code>disassem $pc-28 $pc


得到
</code></pre>

<p>复制代码</p>

<pre><code>0x0003baac &lt;_ZN10FF2cBattle12SENRIHIN_CHKEP12thBATMonsterP6X86REG 180&gt;: bl 0x78e30 &lt;_ZN14cFF2GlobalWork8InstanceEv&gt;
0x0003bab0 &lt;_ZN10FF2cBattle12SENRIHIN_CHKEP12thBATMonsterP6X86REG 184&gt;: mov r4, r0
0x0003bab4 &lt;_ZN10FF2cBattle12SENRIHIN_CHKEP12thBATMonsterP6X86REG 188&gt;: bl 0x78e30 &lt;_ZN14cFF2GlobalWork8InstanceEv&gt;
0x0003bab8 &lt;_ZN10FF2cBattle12SENRIHIN_CHKEP12thBATMonsterP6X86REG 192&gt;: bl 0x7b230 &lt;_ZN14cFF2GlobalWork19sysGAMEPrm_GetMoneyEv&gt;
0x0003babc &lt;_ZN10FF2cBattle12SENRIHIN_CHKEP12thBATMonsterP6X86REG 196&gt;: add r1, r0, r5
0x0003bac0 &lt;_ZN10FF2cBattle12SENRIHIN_CHKEP12thBATMonsterP6X86REG 200&gt;: mov r0, r4
0x0003bac4 &lt;_ZN10FF2cBattle12SENRIHIN_CHKEP12thBATMonsterP6X86REG 204&gt;: bl 0x7b218 &lt;_ZN14cFF2GlobalWork19sysGAMEPrm_SetMoneyEj&gt;



这时会发现在_ZN14cFF2GlobalWork19sysGAMEPrm_GetMoneyEv
</code></pre>

<p>及_ZN14cFF2GlobalWork19sysGAMEPrm_SetMoneyEj
中间0x0003babc 地址的代码add r1, r0, r5 是最可疑的</p>

<pre><code>⑧ 取消断点1及设定新断点breakpoint在十六进制地址0x0003babc 及重新继续continue 游戏
PuTTY / Terminal 打
</code></pre>

<p>复制代码</p>

<pre><code>disable 1
break *0x3babc
c



在iPhone或iPod Touch查看现时游戏的金钱例如是4888，将Final Fantasy 2 游戏进入战斗，战胜后游戏会新断点2地址0x3babc处停止

⑨ 当游戏在新断点2暂停时查看寄存器就发现 r0 是当时的金钱余额及 r5 是战胜后得到的金钱
PuTTY / Terminal 打
</code></pre>

<p>复制代码</p>

<pre><code>i r $r0 $r1 $r5 $pc



⑩ 假设已找到应修改的地址是 0003babc，便可继续下面第(8)步
</code></pre>

<p>引用</p>

<p>方法二：在 gdb 搜索内存数据值及设置观察点(watchpoint)</p>

<pre><code>游戏的数据都会暂存在堆(heap)内存, 于游戏退出前储存在 iPhone 或 iPod Touch的闪存记忆体内, 一些经验值或金钱的数字是比较独特，在内存重复出现的机会不多，这些唯一的数字便可用这方法去进行搜索。

这里用了 Zenonia 2 v1.0 作例子，下面的游戏截图便看到用一个独特的经验值数字 672 去开始这方法



① 在 PuTTY / Terminal 用  ps ax  的指令找到 ZENONIA2 游戏现时运行中的进程编号是 1123

② 使用 gdb 进入运行中的进程编号 1123
PuTTY / Terminal 打
</code></pre>

<p>复制代码</p>

<pre><code>gdb -p 1123



此时游戏会暂停，音乐也暂停

③ 用 gdb 输入这些指令包括，内存开始地址(0x800000)、结束地址(0x880000)及要搜索的数字672如下:

PuTTY / Terminal 打
</code></pre>

<p>复制代码</p>

<pre><code>set $x=0x800000
while(*++$x!=672 &amp;&amp; $x&lt;0x880000)
end



④ 输入 end 之后等候数十秒 ....，待gdb去搜索这段内存地址

⑤ gdb 搜索完毕后
PuTTY / Terminal 打
</code></pre>

<p>复制代码</p>

<pre><code>p/x $x


得到
</code></pre>

<p>复制代码</p>

<pre><code>$1 = 0x85e28c
</code></pre>

<p>这代表 gdb 已找到在 0x85e28c 的内存地址的存储数字是 672</p>

<pre><code>PuTTY / Terminal 打
</code></pre>

<p>复制代码</p>

<pre><code>x/dw 0x85e28c


得到确认 0x85e28c 的内存地址的存储数字是 672
</code></pre>

<p>复制代码</p>

<pre><code>0x85e28c:    672



 ⑥ 用 gdb 继续搜索
PuTTY / Terminal 打 (或按方向键 ↑ 4次，然后回车，免重复输入)
</code></pre>

<p>复制代码</p>

<pre><code>while(*++$x!=672 &amp;&amp; $x&lt;0x880000)
end


再等十多秒，gdb 搜索完毕后
PuTTY / Terminal 打
</code></pre>

<p>复制代码</p>

<pre><code>p/x $x


得到
</code></pre>

<p>复制代码</p>

<pre><code>$2 = 0x880000
</code></pre>

<p>这代表 gdb 已到结束的地址 0x880000，都没有找到。这也表示数字 672 是唯一出现在 0x85e28c 要找的内存范围内。</p>

<pre><code>⑦ 用 gdb 更改内存地址 0x85e28c 的存储数字为 1000
PuTTY / Terminal 打
</code></pre>

<p>复制代码</p>

<pre><code>set {int}0x85e28c=1000



PuTTY / Terminal 打
</code></pre>

<p>复制代码</p>

<pre><code>x/dw 0x85e28c



得到确认已成功更改数字
</code></pre>

<p>复制代码</p>

<pre><code>0x85e28c:    1000



⑧ 继续 continue 游戏
PuTTY / Terminal 打
</code></pre>

<p>复制代码</p>

<pre><code>c



⑨ 在回到游戏里退出 STATUS 画面再进入 STATUS，画面内数据重刷后，确认已成功更改经验值数字为1000


留意:由于游戏数据在堆(heap)内存的地址不是固定的，所以每次运行的进程都要再搜索新的内存地址。另外，搜索的内存地址范围也会改变，如果在 0x800000 至 0x880000 范围内找不到的话，就要往后试 0x880000 至 0x900000 新的范围。

     另外：用相同搜索方法也可以找到金钱数字在这次运行进程是在内存地址 0x874c04

⑩ 找到经验值地址后便可设置观察点(watchpoint)于内存地址 0x85e28c

设置观察点的目的是当内存地址值被读或被写时，会显示数据及暂停程序

PuTTY / Terminal 打
</code></pre>

<p>复制代码</p>

<pre><code>watch *0x85e28c


及继续游戏
PuTTY / Terminal 打
</code></pre>

<p>复制代码</p>

<pre><code>c
</code></pre>

<p>留意:游戏在观察点(watchpoint) 生效下运行是非常的慢，有些游戏是不能正常运作，有时候手机也要重启，所以下面的步骤是不一定可以进行的</p>

<pre><code>⑪ 将游戏进入战斗打怪后程序便会暂停在 0x9f508 地址，gdb 会显示
</code></pre>

<p>复制代码</p>

<pre><code>Hardware watchpoint 1: *8774284
Old value = 1000
New value = 1086
0x0009f508 in CMvPlayer::CheckLevelUp ()



PuTTY / Terminal 打
</code></pre>

<p>复制代码</p>

<pre><code>x/14i $pc-16


得到
</code></pre>

<p>复制代码</p>

<pre><code>0x9f4f8 &lt;_ZN9CMvPlayer12CheckLevelUpEj+60&gt;:    b.n    0x9f508 &lt;_ZN9CMvPlayer12CheckLevelUpEj+76&gt;
0x9f4fa &lt;_ZN9CMvPlayer12CheckLevelUpEj+62&gt;:    adds    r0, r4, #0
0x9f4fc &lt;_ZN9CMvPlayer12CheckLevelUpEj+64&gt;:    movs    r1, #1
0x9f4fe &lt;_ZN9CMvPlayer12CheckLevelUpEj+66&gt;:    movs    r2, #0
0x9f500 &lt;_ZN9CMvPlayer12CheckLevelUpEj+68&gt;:    subs    r5, r5, r3
0x9f502 &lt;_ZN9CMvPlayer12CheckLevelUpEj+70&gt;:    bl    0x9f338 &lt;_ZN9CMvPlayer9OnLevelUpEii&gt;
0x9f506 &lt;_ZN9CMvPlayer12CheckLevelUpEj+74&gt;:    movs    r3, #1
0x9f508 &lt;_ZN9CMvPlayer12CheckLevelUpEj+76&gt;:    str    r5, [r4, r6]
0x9f50a &lt;_ZN9CMvPlayer12CheckLevelUpEj+78&gt;:    cmp    r3, #0
0x9f50c &lt;_ZN9CMvPlayer12CheckLevelUpEj+80&gt;:    beq.n    0x9f516 &lt;_ZN9CMvPlayer12CheckLevelUpEj+90&gt;
0x9f50e &lt;_ZN9CMvPlayer12CheckLevelUpEj+82&gt;:    cmp    r5, #0
0x9f510 &lt;_ZN9CMvPlayer12CheckLevelUpEj+84&gt;:    beq.n    0x9f516 &lt;_ZN9CMvPlayer12CheckLevelUpEj+90&gt;
0x9f512 &lt;_ZN9CMvPlayer12CheckLevelUpEj+86&gt;:    movs    r5, #0
0x9f514 &lt;_ZN9CMvPlayer12CheckLevelUpEj+88&gt;:    b.n    0x9f4c6 &lt;_ZN9CMvPlayer12CheckLevelUpEj+10&gt;



PuTTY / Terminal 打
</code></pre>

<p>复制代码</p>

<pre><code>i r $r5 $r4 $r6 $pc
p/x $r4+$r6


得到
</code></pre>

<p>复制代码</p>

<pre><code>r5             0x43E    1086
r4             0x85DC00    8772608
r6             0x68c    1676
pc             0x9f508    652552
$5 = 0x85e28c



这时确认了 0x9f508 地址这句代码
str    r5, [r4, r6]
的意思是，r4 + r6 = 0x85e28c ，把寄存器 r5 内的数字(1086) 写到 0x85e28c 的地址
</code></pre>

<p>　
    程序因要写进这0x85e28c 的地址，所以暂停了，这就是观察点(watchpoint) 的强大功能。</p>

<pre><code>PuTTY / Terminal 打
</code></pre>

<p>复制代码</p>

<pre><code>bt


得到
</code></pre>

<p>复制代码</p>

<pre><code>#0  0x0009f508 in CMvPlayer::CheckLevelUp ()
#1  0x0009ff2e in CMvPlayer::DoUpdate ()
#2  0x00094744 in CMvObject::Update ()
#3  0x000969cc in CMvObjectMgr::Update ()
#4  0x000662e6 in CMvGameState::UpdateGame ()



这时就可根据上面得到的信息在这段代码的前后范围进行跟踪、设置断点及进一步的分析
</code></pre>

<p>有新的方法时，再继续更新 &hellip;&hellip;&hellip;&hellip;</p>

<p>(iv) 不知道修改点在那及改为什么？</p>

<p>修改程序是不能插入程序代码，主要原因是移位后的程序是不能运行的。一般的做法是找到要修改的位置在原档案位置修改代码改为你需要的指令。 修改点一定要经过分析代码后再不断地用动态分析确定后，在适当的地方重覆试验及调试验证修改后的结果 。</p>

<ul>
<li>一些RPG游戏的特性，例如是金钱或经验值是会在战斗后重算及更新，一般都是要找到及修改更新数据前的指令。金钱的修改点也可以修改在买卖装备时的指令。连续升级的修改主要是看该游戏是怎样升级，例如 Inotia 2是根据经验值去升级，只要找到判断经验值的指令代码地址，修改其判断的指令便可。</li>
</ul>


<p>对于游戏来说，一般的指令修改例子如下：</p>

<p>① 修改寄存器的增加数字例如
    Final Fantasy II 增加战胜后所得金钱
    地址 0003babc
    add r1, r0, r5
    改为
    add r1, r0, r5, lsl #5</p>

<p>② 修改寄存器减少的数字为零例如
    Inotia 2 v 1.1.0 不扣技能点
    地址 00021b9c
    sub r3, #1
    改为
    sub r3, #0</p>

<pre><code>地址 00037b46 
sub r1, #1 
改为 
sub r1, #0 
</code></pre>

<p>③ 修改比较的寄存器例如
    花儿朵朵开-v1.0 不死作弊版 (这里 r2 寄存器是花朵已绽放的数量)
    地址 00004ee8
    cmp r2, r3
    改为
    cmp r2, #1 ; 0x1</p>

<p>④ 修改arm 32 位为两个arm thumb 16 位代码例如
    Inotia 2 v 1.1.0 roll点全18
    地址 0005c404
    bl 0x9914
    改为
    mov r0, #9
    mov r0, #9</p>

<pre><code>地址 0005c404, 0005c40e, 0005c41c, 0005c426 
bl 0x9914 
改为 
mov r0, #9 
mov r0, #9 
</code></pre>

<p>⑤ 要删除代码便要用 nop (no operation) 取代
    thumb 16 bits nop 是 46c0<br/>
    arm 32 bits nop 是 e1a00000</p>

<p>(8) 在FinalFantasy2 的这实例中，假设已找到应修改的地址是 0003babc，代码是 e0801005
复制代码</p>

<pre><code>0003bab8        eb00fddc        bl 0x7b230
0003babc        e0801005        add r1, r0, r5   @意思是 r1 = r0 +r5 ; r0 是当时的金钱余额; r5 是战胜后得到的金钱
0003bac0        e1a00004        mov r0, r4
0003bac4        eb00fdd3        bl 0x7b218     @分支到函数名 __ZN14cFF2GlobalWork19sysGAMEPrm_SetMoneyEj 去更新金錢余额
</code></pre>

<p>(9) 修改目标 : 将所得金钱乘大32倍
0003babc的应修改目标代码是
复制代码</p>

<pre><code>add r1, r0, r5, lsl#5 @意思是 r1 = r0 +( r5 二进制左移五位,即十进制乘大32倍)
</code></pre>

<p>(10) 找新ARM指令代码
add r1, r0, r5 的ARM指令代码是 e0801005
修改目标是要找到 add r1, r0, r5, lsl#5 的ARM指令代码 ?</p>

<p>用 vim 或 nano 建立 armtest.s 如下
复制代码</p>

<pre><code>    .file "armtest.s"
    .globl _main
    .code 32
_main:
    add r1, r0, r5
    add r1, r0, r5, lsl #5
</code></pre>

<p>留意: 一些程式反汇编后是ARM Thumb, ARM Thumb 是16 bits 而ARM 是32 bits. ARM 32 bits 及 ARM Thumb 的分别请找上面 ARM Assembler 的参考(ARM Thumb 的可用指令是比 ARM 32 bits 少)。 如果要找 ARM Thumb 代码要将上面的.code 32改为.code 16 及加上 .thumb_func _main 如下
复制代码</p>

<pre><code>    .code 16
    .thumb_func _main
</code></pre>

<p>汇编 arm 打
复制代码</p>

<pre><code>as armtest.s -o armtest.o ; otool -tv armtest.o
</code></pre>

<p>便看到</p>

<p>复制代码</p>

<pre><code>(__TEXT,__text) section
_main:
00000000    e0801005    add r1, r0, r5
00000004    e0801285    add r1, r0, r5, lsl #5
</code></pre>

<p>及得到add r1, r0, r5, lsl #5 目标ARM指令代码为 e0801285</p>

<p>(11) 建立修改程式第一版FinalFantasy2.v1及用十六进制修改器修改代码</p>

<p>打
复制代码</p>

<pre><code>cp -p FinalFantasy2.original FinalFantasy2.v1      
vbindiff FinalFantasy2.v1
</code></pre>

<p>进入vibindiff 后按G及输入地址3AABC跳到要修改的位置如下</p>

<p>留意: 在第8步时找到的位置是0003Babc，但修改程式的位置要减去十六进制0x1000得到3Aabc
(0x3babc 减 0x1000 等于 0x3aabc)</p>

<p>按E键开始修改，将
05 10 80 E0
改为
85 12 80 E0</p>

<p>然后按Esc键及Y键确认修改</p>

<p>最后按Q键离开 vbindiff 修改器</p>

<p>如下</p>

<p>留意: 修改器显示的05 10 80 E0与反汇编的代码e0801005的位置顺序是倒的</p>

<p>(12) 反汇编修改程式第一版 v1 及比较原版本 original
打
复制代码</p>

<pre><code>otool -tv FinalFantasy2.v1 &gt; FinalFantasy2.v1.txt
diff FinalFantasy2.original.txt FinalFantasy2.v1.txt
</code></pre>

<p>也可以用 otool -otV</p>

<p>得到</p>

<p>复制代码</p>

<pre><code>&lt; FinalFantasy2.original:
---
&gt; FinalFantasy2.v1:
59597c59597
&lt; 0003babc    e0801005    add    r1, r0, r5
---
&gt; 0003babc    e0801285    add    r1, r0, r5, lsl #5
</code></pre>

<p>(13) 对修改程式第一版重新签名
打
复制代码</p>

<pre><code>ldid -s FinalFantasy2.v1
</code></pre>

<p>(14) 将签名后的程式放回程式路径进行测试
首先备份原程式(留意:要用mv移动不要用cp)
打
复制代码</p>

<pre><code>mv ../FinalFantasy2.app/FinalFantasy2 ../FinalFantasy2.app/FinalFantasy2.bak
</code></pre>

<p>安装修改后的程式及更新权限
打
复制代码</p>

<pre><code>cp -p FinalFantasy2.v1 ../FinalFantasy2.app/FinalFantasy2
chown mobile:mobile ../FinalFantasy2.app/FinalFantasy2
chmod 0755 ../FinalFantasy2.app/FinalFantasy2
</code></pre>

<p>(15) 用 gdb 调试游戏</p>

<p>调试是用 gdb，在这里的目的是设置断点使游戏暂停，查看CPU的寄存器，印证修改是否成功。由于游戏占用很多内存，在游戏运行时调试再加ssh 连接很多时候都会崩溃。所以用 iPod Touch 3代 或 iPhone 3GS 做这项工作会有优势。</p>

<p>首先在iPhone或iPod Touch 开始Final Fantasy 2 直至游戏已Resume及进入游戏。</p>

<p>在iPhone或iPod Touch查看现时游戏的金钱例如是 7223</p>

<p>① 在putty / Terminal 找 FinalFantasy2 的运行中的进程编号 (process id)</p>

<p>PuTTY / Terminal 打
复制代码</p>

<pre><code>ps ax
</code></pre>

<p>得到</p>

<p>复制代码</p>

<pre><code>1115   ??  Ss     1:30.86 /var/mobile/Applications/XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX/FinalFantasy2.app/FinalFantasy2
</code></pre>

<p>找到 FinalFantasy2 游戏现时运行中的进程编号是 1115</p>

<p>② 用 gdb 进入调试运行中的进程编号 1115
PuTTY / Terminal 打
复制代码</p>

<pre><code>gdb -p 1115
</code></pre>

<p>此时游戏会暂停，音乐也暂停</p>

<p>③ 用 gdb 设定断点breakpoint在十六进制地址 0x3babc (即在第8步时找到的位置0003babc)
PuTTY / Terminal 打
复制代码</p>

<pre><code>break *0x3babc
</code></pre>

<p>④ 继续 continue 游戏
PuTTY / Terminal 打
复制代码</p>

<pre><code>c
</code></pre>

<p>⑤ 将Final Fantasy 2 游戏进入战斗，战胜后游戏会在十六进制地址 0x3babc处停止</p>

<p>⑥ 暂停后，查看 CPU 寄存器 register (info register 指令)
PuTTY / Terminal 打
复制代码</p>

<pre><code>i r $r0 $r1 $r5 $pc
</code></pre>

<p>得到</p>

<p>复制代码</p>

<pre><code>r0             0x1c37    7223
r1             0x25    37
r5             0x25    37
pc             0x3babc    244412
</code></pre>

<p>印证了 r0=7223 是现时的金钱
游戏暂停在 pc=0x3babc</p>

<p>⑦ 查看下一步将要运行的反汇编指令
PuTTY / Terminal 打
复制代码</p>

<pre><code>x/i $pc
</code></pre>

<p>得到 add r1, r0, r5, lsl #5，印证成功修改指令</p>

<p>复制代码</p>

<pre><code>0x3babc &lt;_ZN10FF2cBattle12SENRIHIN_CHKEP12thBATMonsterP6X86REG+196&gt;:    add    r1, r0, r5, lsl #5
</code></pre>

<p>⑧ 运行下一步 stepi 指令
PuTTY / Terminal 打
复制代码</p>

<pre><code>si
</code></pre>

<p>查看 CPU 寄存器 register (info register 指令)
PuTTY / Terminal 打
复制代码</p>

<pre><code>i r $r0 $r1 $r5 $pc
</code></pre>

<p>得到
复制代码</p>

<pre><code>r0             0x1c37    7223
r1             0x20d7    8407
r5             0x25    37
pc             0x3bac0    244416
</code></pre>

<p>此时印证了 r1 = r0 +( r5 x 32)
            = 7223 + (27 x 32)
            = 8407</p>

<p>查看下一步将要运行的反汇编指令
putty / Terminal 打
复制代码</p>

<pre><code>x/i $pc
</code></pre>

<p>得到</p>

<p>复制代码</p>

<pre><code>0x3bac0 &lt;_ZN10FF2cBattle12SENRIHIN_CHKEP12thBATMonsterP6X86REG+200&gt;:    mov    r0, r4
</code></pre>

<p>⑨ 继续 continue 游戏
PuTTY / Terminal 打
复制代码</p>

<pre><code>c
</code></pre>

<p>⑩ Final Fantasy 2 游戏显示战胜后得到37的金钱，但实际金钱余额是 8407，印证修改游戏已成功。</p>

<p>⑪ 离开 gdb</p>

<p>按下Ctrl+C 组合键停止执行进程</p>

<p>PuTTY / Terminal 打
复制代码</p>

<pre><code>quit
</code></pre>

<p>及按 y 键确认离开 gdb</p>

<p>留意:在上面第⑥步暂停时，你可以输入指令去更改CPU 寄存器 register
例如打
set $r5=1000
去试试增加金钱数目</p>

<p>(16) 假设已调试完成，便可将修改后的程式打包发布</p>

<p>进入游戏路径目录内，打
复制代码</p>

<pre><code>cd /var/mobile/Applications/*/FinalFantasy2.app
</code></pre>

<p>到上一层路径目录
复制代码</p>

<pre><code>cd ..
</code></pre>

<p>建立 IPA 所要的路径及档案及删除不需要的备份档案</p>

<p>复制代码</p>

<pre><code>rm -fr Payload
mkdir -p Payload
cp -pr FinalFantasy2.app Payload/
rm -fr Payload/FinalFantasy2.app/FinalFantasy2*.bak
</code></pre>

<p>打包 ipa 为 FinalFantasy2_v1.ipod4g.ipa
复制代码</p>

<pre><code>zip -r FinalFantasy2_v1.ipod4g.ipa Payload iTunesArtwork
</code></pre>

<p>找现时的路径
复制代码</p>

<pre><code>pwd
</code></pre>

<p>得到</p>

<p>复制代码</p>

<pre><code>/var/mobile/Applications/XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
</code></pre>

<p>用 winscp 或Terminal 的 scp 指令传送这档作发布</p>

<p>复制代码</p>

<pre><code>/var/mobile/Applications/XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX/FinalFantasy2_v1.ipod4g.ipa
</code></pre>

<p>XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX 是随机路径</p>

<p>(17) 其他有用的技巧</p>

<p>① 由于修改游戏的程式代码是很少量, 相对重覆调试及动态分析工作比较多，此教程便介绍了用iPhone 的工具直接做修改及反汇编。这样对于少量修改程式代码及重覆在iPhone调试是比较要传回PC做修改是更有效率的。</p>

<p>② 调试的工具 gdb 是比较难用，但有些方法是可提高使用 gdb 的效率。</p>

<p>例如：在 gdb 建立宏 macro define
在 iphone 建立这档案(~/.gdbinit) 内容为
复制代码</p>

<pre><code>define ascii_char
set $_c=*(unsigned char *)($arg0)
if ( $_c &lt; 0x20 || $_c &gt; 0x7E )
printf "."
else
printf "%c", $_c
end
end
document ascii_char
Print the ASCII value of arg0 or '.' if value is unprintable
end
define hex_quad
printf "%02X %02X %02X %02X  %02X %02X %02X %02X",  \
*(unsigned char*)($arg0), *(unsigned char*)($arg0 + 1),  \
*(unsigned char*)($arg0 + 2), *(unsigned char*)($arg0 + 3), \
*(unsigned char*)($arg0 + 4), *(unsigned char*)($arg0 + 5), \
*(unsigned char*)($arg0 + 6), *(unsigned char*)($arg0 + 7)
end
document hex_quad
Print eight hexadecimal bytes starting at arg0
end
define hexdump
printf "%08X : ", $arg0
hex_quad $arg0
printf " - "
hex_quad ($arg0+8)
printf " "
ascii_char ($arg0)
ascii_char ($arg0+1)
ascii_char ($arg0+2)
ascii_char ($arg0+3)
ascii_char ($arg0+4)
ascii_char ($arg0+5)
ascii_char ($arg0+6)
ascii_char ($arg0+7)
ascii_char ($arg0+8)
ascii_char ($arg0+9)
ascii_char ($arg0+0xA)
ascii_char ($arg0+0xB)
ascii_char ($arg0+0xC)
ascii_char ($arg0+0xD)
ascii_char ($arg0+0xE)
ascii_char ($arg0+0xF)
printf "\n"
end
document hexdump
Display a 16-byte hex/ASCII dump of arg0
end
define hexdump1
hexdump $arg0
x/8h $arg0
printf "\n"
disassem $arg0 $arg0+16
printf "\n"
end
document hexdump1
Display a 16-byte hex/ASCII dump and disassembly of arg0
end
</code></pre>

<p>在用 gdb 调试时打
复制代码</p>

<pre><code>hexdump1 $pc
</code></pre>

<p>便可列出$pc位置后十六位的内容及反汇编的代码</p>

<p>③ 在断点设定一些要自动运行的指令</p>

<p>下面的意思是建立断点１
及在断点１停止时运行查看一些暂存器(i r $r0 $r1 $r5 $pc)及反汇编下四个指令代码(x/4i $pc)</p>

<p>复制代码</p>

<pre><code>break *0x3babc
commands 1
i r $r0 $r1 $r5 $pc
x/4i $pc
end
</code></pre>

<p>④ 在 gdb 断点暂停时，是可改变内存及指令
FinalFantasy2 的例子，0x0003babc地址的指令是
打
复制代码</p>

<pre><code>x/i 0x0003babc
</code></pre>

<p>得到代码是
复制代码</p>

<pre><code>add r1, r0, r5
</code></pre>

<p>打
复制代码</p>

<pre><code>x/xw 0x0003babc
</code></pre>

<p>得到代码数值是
复制代码</p>

<pre><code>0xe0801005
</code></pre>

<p>改变指令代码数值打
复制代码</p>

<pre><code>set {int}0x0003babc = 0xe0801285
</code></pre>

<p>检查改变后的指令打
复制代码</p>

<pre><code>x/i 0x0003babc
</code></pre>

<p>得到改变后的指令代码是
复制代码</p>

<pre><code>add r1, r0, r5, lsl #5
</code></pre>

<p>这样就不用离开 gdb 即时看到修改代码后的效果</p>

<p>⑤ gdb 执行到程序中其他地址的命令</p>

<pre><code>例子：
stepi                           单步执行一个机器指令(命令步入函数)
nexti                           单步执行一个机器指令(命令步过函数)
nexti 2                        继续执行机器指令的数目为 2 个指令
finish                          继续执行至当前函数结束后，停止于其调用点
until *0x7b224            继续执行至特定地址*0x7b224
jump *0x3baac           跳转至特定地址*0x3baac 执行
</code></pre>

<p>⑥ gdb 调试记录的命令</p>

<pre><code>例子：
set logging file ./log1.txt      设定记录档
set logging on                     开始记录
set logging off                     停止记录
</code></pre>

<p>⑦ 学习别人修改程序的方法
看别人修改程序是最好的学习方法，只要你有原版本及修改后的版本，就可以知道修改的地址及方法
例如：
下载花儿朵朵开-v1.0.rar 原版本</p>

<p>下载花儿朵朵开-v1.0.rar 不死作弊修改版</p>

<p>解压后将两个 ipa 文件，用 winscp 传到iPhone 路径 /var/root/flower 内</p>

<p>在 PuTTY / Terminal 连接iPhone / iPod Touch后</p>

<p>打
复制代码</p>

<pre><code>cd /var/root/flower
</code></pre>

<p>解压原游戏版本程序
在 PuTTY / Terminal 打
复制代码</p>

<pre><code>unzip *-v1.0.ipa
mv Payload/FlowerChainCN.app/FlowerChainCN FlowerChainCN.original
</code></pre>

<p>删除不需要的的路径及档案
在 PuTTY / Terminal 打
复制代码</p>

<pre><code>rm -fr Payload/ iTunesArtwork *.ipa
</code></pre>

<p>解压不死作弊修改版程序
在 PuTTY / Terminal 打
复制代码</p>

<pre><code>unzip *-v1.0.ipod4g.ipa
mv Payload/FlowerChainCN.app/FlowerChainCN FlowerChainCN.patched
</code></pre>

<p>删除不需要的的路径及档案
在 PuTTY / Terminal 打
复制代码</p>

<pre><code>rm -fr Payload/ iTunesArtwork *.ipa
</code></pre>

<p>反汇编原游戏程式及保存反汇编文本文件为 FlowerChainCN.original.txt
在 PuTTY / Terminal 打
复制代码</p>

<pre><code>otool -tv FlowerChainCN.original &gt; FlowerChainCN.original.txt
</code></pre>

<p>反汇编不死作弊修改版程式及保存反汇编文本文件为 FlowerChainCN.patched.txt
在 PuTTY / Terminal 打
复制代码</p>

<pre><code>otool -tv FlowerChainCN.patched &gt; FlowerChainCN.patched.txt
</code></pre>

<p>比较两个版本及找出差异
在 PuTTY / Terminal 打
复制代码</p>

<pre><code>diff FlowerChainCN.original.txt FlowerChainCN.patched.txt
</code></pre>

<p>得到
复制代码</p>

<pre><code>&lt; FlowerChainCN.original:
---
&gt; FlowerChainCN.patched:
3060c3060
&lt; 00004ee8 e1520003 cmp r2, r3
---
&gt; 00004ee8 e3520001 cmp r2, #1 ; 0x1
</code></pre>

<p>原版本列在左边及把差异列在右边并输出差异文本保存为 FlowerChainCN.diff.txt
在 PuTTY / Terminal 打
复制代码</p>

<pre><code>diff -y --left-column FlowerChainCN.original.txt FlowerChainCN.patched.txt &gt; FlowerChainCN.diff.txt
</code></pre>

<p>用 less 工具打开差异文本 FlowerChainCN.diff.txt
在 PuTTY / Terminal 打
复制代码</p>

<pre><code>less FlowerChainCN.diff.txt
</code></pre>

<p>在 less 工具内搜寻差异分隔字符 |
在 less 工具内打
复制代码</p>

<pre><code>/\|
</code></pre>

<p>得到下面差异的显示去做进一步分析
复制代码</p>

<pre><code>00004ee8 e1520003 cmp r2, r3 | 00004ee8 e3520001 cmp r2, #1 ; 0x1
</code></pre>

<p>在 PuTTY / Terminal 打这句也可看到原版本上下的代码
复制代码</p>

<pre><code>grep -C5 '|' FlowerChainCN.diff.txt
</code></pre>

<p>或
复制代码</p>

<pre><code>grep -C5 00004ee8  FlowerChainCN.original.txt
</code></pre>

<p>⑧ 最后送上我自购破解的一个很实用的iPhone小工具 - 64位计算器
这小工具除了可以做64位的计算外，还可以输入文字及显示Unicode的代码</p>

<pre><code>64 Bit Calculator

 64_Bit_Calc-v1.2.ipod4g.ipa (788 K) 下载次数:233 




64 Bit Calculator (iPad)   64_Bit_Calc_iPad-v1.2.ipa (1521 K) 下载次数:116 
</code></pre>

<p>关于 FinalFantasy2 1.0.4 版本 ldid 签名时出现错误信息 Segmentation fault</p>

<p>初代 iPhone 使用ARMv6 指令集, 直到3GS, iPad, IPhone 4设备苹果开始采用了 ARMv7 指令集</p>

<p>如果你打指令</p>

<p>复制代码</p>

<pre><code>otool -f FinalFantasy2
</code></pre>

<p>就会看到</p>

<p>复制代码</p>

<pre><code>architecture 0
    cputype 12
    cpusubtype 6
architecture 1
    cputype 12
    cpusubtype 9
</code></pre>

<p>你可以把 FinalFantasy2 切开为 FinalFantasy2V6</p>

<p>复制代码</p>

<pre><code>lipo -thin armv6  FinalFantasy2 -output FinalFantasy2V6
chmod +x FinalFantasy2V6
chown mobile:mobile FinalFantasy2V6
</code></pre>

<p>及切开为 FinalFantasy2V7</p>

<p>复制代码</p>

<pre><code>cp -p FinalFantasy2 FinalFantasy2tmp
echo -ne "\x09" | dd bs=1 seek=15 conv=notrunc status=noxfer of=FinalFantasy2tmp
echo -ne "\x06" | dd bs=1 seek=35 conv=notrunc status=noxfer of=FinalFantasy2tmp
lipo -thin armv6 FinalFantasy2tmp -output FinalFantasy2V7
rm FinalFantasy2tmp
chmod +x FinalFantasy2V7
chown mobile:mobile FinalFantasy2V7
</code></pre>

<p>但 iPhone 的 otool 不支持反汇编 ARMv7 指令集, 你要用新版本的 IDA Pro 反汇编</p>

<p>在 iPhone 你只可以反汇编 FinalFantasy2V6, 修改及用 ldid 去签名</p>

<p>FinalFantasy2V6 签名后便可替代原版本使用, 游戏来说ARMv6 指令集也可以, 只不过在新的设备上使用时不是最优化.</p>

<p>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[获取短信-联系人]]></title>
    <link href="http://al1020119.github.io/blog/2016/03/28/huoqushoujiduanxintongxunlulianxiren/"/>
    <updated>2016-03-28T13:32:08+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/03/28/huoqushoujiduanxintongxunlulianxiren</id>
    <content type="html"><![CDATA[<p>越狱的 ios 如何 获取 读取 提取 手机上的 短信 通话记录 联系人 等信息</p>

<p><a href="http://willson.sinaapp.com/2011/12/iphone">http://willson.sinaapp.com/2011/12/iphone</a> 获取短信脚本.html  Iphone获取短信脚本
<a href="http://bbs.9ria.com/thread-209349-1-1.html">http://bbs.9ria.com/thread-209349-1-1.html</a>          IPhone短信相关部分研究（转载）
<a href="http://blog.csdn.net/slinloss/article/details/8722806">http://blog.csdn.net/slinloss/article/details/8722806</a>       整理：iOS 短信与电话事件的获取
<a href="http://308812025-qq-com.iteye.com/blog/1549756">http://308812025-qq-com.iteye.com/blog/1549756</a>              IOS 5 拦截手机短信(需越狱)</p>

<p><a href="http://www.iteye.com/problems/84131">http://www.iteye.com/problems/84131</a>                                IOS 短信截取 监听到了事件缺不能往下执行。。。</p>

<!--more-->


<p><a href="http://blog.csdn.net/ceko_wu/article/details/8021133">http://blog.csdn.net/ceko_wu/article/details/8021133</a>     短信数据库分析（一）</p>

<p>一般地，ios只要越狱，整体的文件系统就全部暴漏出来，使用ifunbox 工具连接iphone，即可查看。</p>

<p>短信数据库的存放位置在ios的：    /private/var/mobile/Library/SMS/sms.db</p>

<p>联系人数据库存放的位置在ios的：//private/var/mobile/Library/AddressBook/AddressBook.sqlitedb</p>

<pre><code> 联系人的头像估计存放在这里：//private/var/mobile/Library/AddressBook/AddressBookImages.sqlitedb
</code></pre>

<p>通话记录数据库的存放路径是：//private/var/wireless/Library/CallHistory/call_history.db</p>

<p>备忘录数据库的存放路径是：//private/var/mobile/Library/Notes/notes.sqlite</p>

<p>safira 浏览器的收藏夹数据库存放路径是：//private/var/mobile/Library/Safari/Bookmarks.db</p>

<p>日历数据库的存放路径是：//private/var/mobile/Library/Calendar/Calendar.sqlitedb</p>

<p>上面的数据库，无论其后缀名是.db也好，.sqlitedb、.sqlite也好，它们的真实面目是，全部都是sqlite数据库。在实际查看这些数据库时，可以将其后缀名统一改成.sqlite，当然也可以不改。查看这些数据库最好的工具是 火狐浏览器上的插件：Sqlite Manager</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SpringBoard界面结构分析]]></title>
    <link href="http://al1020119.github.io/blog/2016/03/25/springboardjiemianjiegoufenxi/"/>
    <updated>2016-03-25T13:32:08+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/03/25/springboardjiemianjiegoufenxi</id>
    <content type="html"><![CDATA[<p>SpringBoard界面层级结构分析</p>

<p>cycript -p 进程ID</p>

<p>通过cycript注入到SpringBoard进程中
首先SpringBoard有点类似于一般app的结构，只不过它是由好几个window构成的，总共如下：
  锁屏状态下是SBAlertWindow
  正常状态下是SBAppWindow
  通知栏滑下来时显示SBBulletinWindow
主要分析下正常状态的window</p>

<!--more-->


<p>SpringBoard界面层级结构分析</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[分析QQ-微信界面结构]]></title>
    <link href="http://al1020119.github.io/blog/2016/03/22/fenxiQQweixinjiemianjiegou/"/>
    <updated>2016-03-22T13:32:08+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/03/22/fenxiQQweixinjiemianjiegou</id>
    <content type="html"><![CDATA[<p>使用Reveal分析其他APP（如微信、qq等）的界面结构</p>

<p>特别提醒，现已无需按下面的方式注入libReveal.dlib了，只需把libReveal.dylib上传到设备的/Library/MobileSubstrate/DynamicLibraries，然后同时编辑并上传一个libReveal.plist，格式如下：</p>

<p>nixiang0001</p>

<p> 设定BundleID
注意，此时是可以指定多个BundleID的，也就是说，你可以同时监控任意多的app；再扩大一步说，如果你愿意，不上传这个libReveal.plist，你可以监控所有app，只要你不觉得机器很慢。。。
一定确保手机和电脑端处在同一局域网中，不然看不到界面的
Reveal.app 目前能搞到2.0.3的版本且能用注册机破解，但貌似对ios7.0以上的应用无效，需要Reveal2.0.4版，但又无法破解目前，2.0.3版本百度云下载
<a href="http://c.blog.sina.com.cn/profile.php?blogid=cb8a22ea89000gtw&amp;qq-pf-to=pcqq.c2c">http://c.blog.sina.com.cn/profile.php?blogid=cb8a22ea89000gtw&amp;qq-pf-to=pcqq.c2c</a></p>

<!--more-->


<p>打开XCode创建iOSOpenDev&ndash;》Logos Tweak的工程</p>

<p>创建动态加载Reveal的类RevealUtil：</p>

<pre><code>//
//  RevealUtil.h
//  pyu
//
//  Created by whe on 6/23/13.
//
//

#import

@interface RevealUtil : NSObject {
    void *_revealLib;
}

- (void)startReveal;
- (void)stopReveal;

@end

//
//  RevealUtil.m
//  pyu
//
//  Created by whe on 6/23/13.
//
//
#import
#import
#import "RevealUtil.h"

@implementation RevealUtil

- (void)startReveal {
    NSString *revealLibName = @"libReveal.dylib";
    //NSString *revealLibExtension = @"dylib";
    NSString *bundlePath = [[NSBundle mainBundle] bundlePath];
   //此处要先将libReveal.dylib通过iTools上传到需要分析的App的Buldle主目录下（即xxx.app目录）
    NSString *dyLibPath = [NSString stringWithFormat:@"%@/%@",bundlePath,revealLibName];
    UIAlertView *alert = [[UIAlertView alloc]
                          initWithTitle:@"Welcome"  message:[NSString stringWithFormat:@"Loading dynamic library: %@", dyLibPath]
                          delegate:nil cancelButtonTitle:@"Thanks"
                          otherButtonTitles:nil];
    [alert show];
    [alert release];

    void *revealLib = NULL;
    revealLib = dlopen([dyLibPath cStringUsingEncoding:NSUTF8StringEncoding], RTLD_NOW);

    if (revealLib == NULL)
    {
        char *error = dlerror();
        NSLog(@"dlopen error: %s", error);
    }else {
        [[NSNotificationCenter defaultCenter] postNotificationName:@"IBARevealRequestStart" object:self];
    }
}

- (void)stopReveal {
    if (_revealLib)
    {
        [[NSNotificationCenter defaultCenter] postNotificationName:@"IBARevealRequestStop" object:self];
        if (dlclose(_revealLib) == 0)
        {
            NSLog(@"Reveal library unloaded");
            _revealLib = NULL;
        }
        else
        {
            char *error = dlerror();
            NSLog(@"Reveal library could not be unloaded: %s", error);
        }
    }
}

@end
</code></pre>

<p>修改工程的xm文件内容如下：</p>

<pre><code>#import "RevealUtil.h"
</code></pre>

<p>%hook MobileAssistAppDelegate //对应分析APP的AppDelegate文件类名，不同的App这个类名可能不同，这可以先通过class-dump  xxx.app这个二进制文件，得出该APP所有的头文件，然后搜索关键字didFinishLaunchingWithOptions，找到对应文件并查看该文件内的类名即是</p>

<pre><code>- (BOOL)application:(id)arg1 didFinishLaunchingWithOptions:(id)arg2 {
    %orig;

    RevealUtil *ru = [[RevealUtil alloc] init];
    [ru startReveal];

    return YES;
}

%end
</code></pre>

<p>最终项目结构如下：</p>

<p>nixiang0002</p>

<p>注意那个Filter，其实可以不填，但要填一定要是该app的bundle identifier</p>

<p>附：OpenSSH的使用：
       ssh <a href="&#x6d;&#x61;&#105;&#108;&#116;&#x6f;&#58;&#x72;&#111;&#111;&#x74;&#x40;&#49;&#x39;&#x32;&#46;&#49;&#54;&#x38;&#x2e;&#50;&#46;&#x35;">&#114;&#x6f;&#111;&#116;&#64;&#49;&#x39;&#50;&#x2e;&#49;&#54;&#x38;&#x2e;&#x32;&#x2e;&#53;</a> 默认密码alpine
     先通过ssh登录到手机，然后可以通过cycript -p 进程ID   依附在需要分析的应用程序上  ps ax | grep PP</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[私有API]]></title>
    <link href="http://al1020119.github.io/blog/2016/03/20/siyouapi/"/>
    <updated>2016-03-20T13:32:08+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/03/20/siyouapi</id>
    <content type="html"><![CDATA[<p>一．基本知识</p>

<p>iPhone中的API除了公开的 API：Published API外（或者叫文档中记录的API：Documented API），还有两类API：私有API：Private API和未公开的API：UnPublished API(或者叫文档中未记录的API：Undocumented API)。其中私有API是指放在PrivateFrameworks框架中的API，未公开的API是指虽然放在Frameworks框架中，但是却没有在苹果的官方文档中有使用说明、代码介绍等记录的API。后两种API是有区别的，按苹果的说法，未公开的API是还不够成熟，可能还会变动的API，等完全成型了后会变成公开的API，但是目前不对其提供承诺，就是系统版本升级后可能会失效。而私有API是苹果明确不能使用的API。虽然两者有所区别，但是在具体使用方法上是类似的。</p>

<!--more-->


<p>二．具体介绍
1.导出生成私有API的头文件声明
使用私有或未公开的API，首先需要导出其对应的头文件，在头文件里有相关函数的声明。
工具：
class-dump
class-dump可以从编译后的Objective-C的二进制文件中提取对应的数据结构及函数等声明。
使用方法：
为了能在任意目录下使用class-dump命令，首先建议把class-dump文件拷贝到/user/local/bin/目录下，然后就可以在任意目录下执行以下命令：</p>

<p>class-dump /Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator3.0.sdk/System/Library/Frameworks/UIKit.framework/ >UIKit.h</p>

<p>以上命令就可以把 iPhoneSimulator3.0.Sdk中Frameworks框架里的UIKit.Framework框架的数据结构及函数声明等给提取出来，并且放在UIKit.h这个文件中，之后你就可以在这个头文件中找你需要API的声明及其使用方式。以同样的方法，就可以挨个导出你需要那个框架中的API 声明。</p>

<p>也可以用ericasadun写的DumpFrameworks.pl（文件中有部分注释说明）这个文件把私有框架下的API头文件全部提取出来。使用方法也是首先把class-dump文件拷贝到/user/local/bin/目录下，然后在任意一个目录下执行./DumpFrameworks.pl,然后就会在你的家目录下产生一个Headers文件夹，里面罗列了私有框架下的API头文件。</p>

<p>2.使用私有API</p>

<p>导出了私有API的头文件声明后，使用方法就比较简单了，首先在你的工程中包含进头文件，然后导入对应的框架，之后就可以类似提供了静态库的方式在我们的代码中使用这些私有API函数。</p>

<p>三．附加说明</p>

<p>iPhone编程中一些非常精致好玩的API都包含在私有API或未公开的API中，虽然我们可以以这种方式使用这些非常好的API，但是这样做是存在一定风险的，首先为公开的API有变更的可能，这样在每个固件版本中，你的代码都有可能中断。同时，最大的问题是使用了私有API的程序是不能放在App Store上销售的。因此如果我们只是为了好玩体验iPhone中这些精彩的API，那没关系。如果是为了做出程序放在App Store上销售的，那就不要动私有API的主意了。</p>

<hr />

<p>class-dump-x 提取私有库里面的隐藏文件
class-dump</p>

<p>This is a command-line utility for examining the Objective-C runtime information stored in Mach-O files. It generates declarations for the classes, categories and protocols. This is the same information provided by using &lsquo;otool -ov&rsquo;, but presented as normal Objective-C declarations, so it is much more compact and readable.
Why use class-dump?</p>

<p>It&rsquo;s a great tool for the curious. You can look at the design of closed source applications, frameworks, and bundles. Watch the interfaces evolve between releases. Experiment with private frameworks, or see what private goodies are hiding in the AppKit. Learn about the plugin API lurking in Mail.app.</p>

<p>If you find class-dump useful, you can donate to help support its development. Thanks!
Download</p>

<p>Current version: 3.3.3 (Universal, 64 and 32 bit)
Requires Mac OS X 10.5 or later.</p>

<pre><code>class-dump-3.3.3.dmg
class-dump-3.3.3.tar.gz
class-dump-3.3.3.tar.bz2
</code></pre>

<p>Changes - News
Contact</p>

<p>You can email questions and bug reports to me at class-dump@codethecode.com, or nygard at gmail.com.
Usage</p>

<p>class-dump 3.3.3 (64 bit)
Usage: class-dump [options] <mach-o-file></p>

<p>  where options are:
        -a             show instance variable offsets
        -A             show implementation addresses
        &ndash;arch <arch>  choose a specific architecture from a universal binary (ppc, ppc7400, ppc64, i386, x86_64, etc.)
        -C <regex>     only display classes matching regular expression
        -f <str>       find string in method name
        -H             generate header files in current directory, or directory specified with -o
        -I             sort classes, categories, and protocols by inheritance (overrides -s)
        -o <dir>       output directory used for -H
        -r             recursively expand frameworks and fixed VM shared libraries
        -s             sort classes and categories by name
        -S             sort methods by name
        -t             suppress header in output, for testing
        &ndash;list-arches  list the arches in the file, then exit
        &ndash;sdk-root     specify the SDK root path (full path, or 4.1, 4.0, 3.2, 10.6, 10.5, 3.1.3, 3.1.2, 3.1)</p>

<p>License</p>

<p>This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.</p>

<p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.</p>

<p>You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</p>

<p> class-dump -H  /Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator2.1.sdk/System/Library/CoreServices/SpringBoard.app/SpringBoard</p>

<pre><code> -o 
</code></pre>

<p>~/Desktop/SpringBoard</p>

<p>下载：<a href="http://ericasadun.com/HeaderDumpKit/">http://ericasadun.com/HeaderDumpKit/</a></p>

<p>使用：
1 将下载好的 class-dump 放入usr/local/bin 下.
   如果 ‘/usr/local/bin’ 不知道在哪里，可以在terminal 下输入 ‘open -a Finder /usr/local/bin’ 以便打开目录.
   记着 class-dump 要 使用 chmod 修改下执行权限.   例如：在usr/local/bin 对 class-dump 修改，可以这    样在terminal 切换到 usr/local/bin 目录下: chmod 777 class-dump .
2 将DumpFrameworks.pl 放入任意目录下.同样需要修改执行权限.</p>

<ol>
<li>OK..现在所有的准备工作作好了. 我们在 terminal 的任意目录下 输入 ： ./DumpFrameworks.pl
等待&hellip;
会有一个Heards 文件夹在你的主目录下. 里面包含了 Frmeworks 和 privateFrameworks 下所有的私有        API,尽情享用吧.!</li>
</ol>


<hr />

<p> 作为 Objective-C / Cocoa Touch 开发者，在经历了呕心沥血十月怀胎终于孕育出了一个代码包，然后踌躇满志准备提交给天杀的 Apple App Review Team  审核之时，别急，我们仍然需要诚惶诚恐的考虑一个问题，我们的代码里是否用到了 Private API ？</p>

<pre><code>什么是 Private API ？简而言之，就是这个 API 真实存在于 Cocoa Touch 中，但它又不是 Public API （有点绕吧…）。那什么是 Public API 呢？Public API 就是苹果通过 Cocoa Touch 向全世界第三方开发者公开的所有 API 。在哪可以查到 Public API ？在你的 Xcode 工程中就能查到。如这幅截图所示， Xcode 中所有 framework 的头文件都是我们可用肉眼查询的 Public API 列表。



同此同时，民间也流传着一个非官方的 Private API 列表。(iphone-private-frameworks)

于是你说，那问题不就解决了呗，只要我们洁身自好，保证自己的代码里只使用 Cocoa Touch 公布的 API ，我们就肯定不会惹上 Private API 啦。

然而实际情况往往不是这样，当今世界，嗯嗯当今世界，App Store 的竞争越发激烈，每位开发者都希望自己的代码能站在前辈优秀开源代码的基础上高屋建瓴，而不是每新建一个工程就得自己花十天半个月一遍遍 reinvent the wheel 重造车轮。 随手举几个例子， ASIHTTPRequest 、JSON 、Facebook / Three20 、 SFHFKeychainUtils ，这几套知名开源代码包存在于许许多多优秀的 iOS 应用之中。其他名气稍小但是同样流传广泛的开源或者闭源代码包就更数不胜数了。作为开发者，我们不得不频繁面对这样一个问题，我们如何确保这些第三方的代 码报里，不存在 private API ？

苹果提供了几种机器识别方法，比如 string 命令，比如 otool -ov 命令，但都不太好用。江湖上有人做了一套解决方案，名叫 AppScanner ，我老人家决定强烈推荐一下。( 貌似现在用xcode提交项目时会检测一遍是否有私有函数 )

怎么用？很简单，你把AppScanner工程编译好，然后直接将 .app 文件夹整个拖进 AppScanner 窗口里。
免费的么？几乎是免费的，虽然收费（也才 $2.99 ），但是头 14 天免费。
是否有人维护？有，而且只要你愿意出 $2.99 支持他们维护。他们还会继续开发下去。

这是一个实例的截屏，头两项 API 可疑度 100% ，说明它们就是来搞破坏的 Private API。



最后插一则八卦， Facebook / Three20 如雷贯耳，想必很多开发者都使用过。然而要命的事，在 Three20 的第一个版本中，就悄悄的藏着一条因为重名导致的假阳性 Private API 。虽然是假阳性，但那次事故仍然导致了所有使用那个版本 Three20 的 app 被惨拒。当然了，后来他们很快就修正了这个问题。
</code></pre>

<p>使用私有api开启了iphone的蓝牙。现在把方法分享出来，希望能给大家提供一些思路。</p>

<p>1.首先在/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS4.3.sdk/System/Library/PrivateFrameworks路径下找到BluetoothManager.framework（如果我没估计错的话，里面只有一个库文件，没有头文件）
2. 所需的头文件，手动添加到BluetoothManager.framework中，并建立一个Headers文件夹。
3.建立一个工程将以上路径下的BluetoothManager.framework添加到工程中
4.将以下代码添加到工程中。（注意：不需要引入BluetoothManager的头文件，否则会出现编译错误）</p>

<p>-(void)startBluetooth{</p>

<h1>if TARGET_IPHONE_SIMULATOR</h1>

<pre><code>exit( EXIT_SUCCESS ) ;
</code></pre>

<h1>else</h1>

<pre><code>/* this works in iOS 4.2.3 */
Class BluetoothManager = objc_getClass( "BluetoothManager" ) ;
id btCont = [BluetoothManager sharedInstance] ;
[self performSelector:@selector(toggle:) withObject:btCont afterDelay:1.0f] ;
</code></pre>

<h1>endif</h1>

<p>}</p>

<h1>if TARGET_IPHONE_SIMULATOR</h1>

<h1>else</h1>

<ul>
<li>(void)toggle:(id)btCont
{
  BOOL currentState = [btCont enabled] ;
  [btCont setEnabled:!currentState] ;
  [btCont setPowered:!currentState] ;</li>
</ul>


<p>}</p>

<h1>endif</h1>

<p>5.在真机上编译运行，会发现iphone的蓝牙成功开启。</p>

<p>但是，遗憾的是，目前我研究出来的只有开启蓝牙，关于设备匹配，数据传输方面没什么进展。
希望有人能再接再厉，在我的基础上研究出设备匹配和数据传输的方法</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Tweak工程]]></title>
    <link href="http://al1020119.github.io/blog/2016/03/19/shiyongtweakgongcheng/"/>
    <updated>2016-03-19T13:32:08+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/03/19/shiyongtweakgongcheng</id>
    <content type="html"><![CDATA[<p>iOS逆向 - 使用Tweak工程</p>

<p>创建第一个Tweak工程
1、创建工程</p>

<p>在目录下面启动NIC /opt/theos/bin/nic.pl ,可以看到有好多个模板可以选择。 1、4、6、8、9 是Theos自带的模板,其他的是 <a href="https://github.com/DHowett/theos-nic-templates">https://github.com/DHowett/theos-nic-templates</a> 下载的。 这里主要学习tweak的用法，选择9</p>

<pre><code>  NIC 2.0 - New Instance Creator
------------------------------
  [1.] iphone/application
  [2.] iphone/cydget
  [3.] iphone/framework
  [4.] iphone/library
  [5.] iphone/notification_center_widget
  [6.] iphone/preference_bundle
  [7.] iphone/sbsettingstoggle
  [8.] iphone/tool
  [9.] iphone/tweak
  [10.] iphone/xpc_service
Choose a Template (required):
</code></pre>

<!--more-->


<p>输入工程的名字</p>

<pre><code>Project Name (required): reverseDemo
</code></pre>

<p>输入deb包的名字，相当于App的bundle id</p>

<pre><code>Package Name [com.yourcompany.reversedemo]: com.liuchendi.iOSReverse
</code></pre>

<p>输入tweak作者的名字</p>

<pre><code>Author/Maintainer Name [lovelydd]: liuchendi
</code></pre>

<p>输入MobileSubstrate Bundle filter，就是设置tweak作用对象的bundle identifier。就像上一节用Reveal查看别人的App一样，需要知道作用的对象是谁</p>

<pre><code>[iphone/tweak] MobileSubstrate Bundle filter [com.apple.springboard]: com.apple.springboard
</code></pre>

<p>安装完成后需要重启的应用，已进程名表示</p>

<pre><code>[iphone/tweak] List of applications to terminate upon installation (space-separated, '-' for none) [SpringBoard]: SpringBoard
</code></pre>

<p>一个Tweak工程就创建完成了
2、定制工程文件</p>

<p>查看工程里面的文件目录</p>

<pre><code>liuchendi@lovelyddtekiMBP reversedemo$ ls -l
total 40
-rw-r--r--  1 liuchendi  staff   182 12 17 17:30 Makefile
-rw-r--r--  1 liuchendi  staff  1045 12 17 17:30 Tweak.xm
-rw-r--r--  1 liuchendi  staff   222 12 17 17:30 control
-rw-r--r--  1 liuchendi  staff    57 12 17 17:30 reverseDemo.plist
lrwxr-xr-x  1 liuchendi  staff    10 12 17 17:30 theos -&gt; /opt/theos
</code></pre>

<p>Makefile：指定工程用到的文件、框架、库等信息，整个过程自动化。</p>

<p>// 固定写法
    include theos/makefiles/common.mk</p>

<pre><code>// tweak名字,就是工程的名字
TWEAK_NAME = reverseDemo

//tweak包含的源文件(不包括头文件),多个文件以空格分隔
reverseDemo_FILES = Tweak.xm

// 根据Theos工程的不同类型，指定不同的.mk文件。
// 逆向初级阶段一般是Application、 Tweak 、Tool三种类型的程序
// 分别对应的.mk文件是 application.mk 、tweak.mk 、tool.mk
include $(THEOS_MAKE_PATH)/tweak.mk

// 安装完成后,杀掉SpringBoard进程,好让CydiaSubstrate在进程启动时加载对应的dylib
after-install::
  install.exec "killall -9 SpringBoard"
</code></pre>

<p>其他功能：</p>

<pre><code>// 指定处理器架构，arm64架构不兼容armv7/armv7s架构,必须适配arm64的dylib
ARCHS = armv7 arm64

//指定SDK版本
TARGET = iphone:8.1:8.0     // 8.1是指定采用的SDK版本，8.0是可以部署安装的版本
TARGET = iphone:latest:8.0 // Xcode附带的最新版本SDK

//导入framework
reverseDemo_FRAMEWORKS = UIKit CoreTelephony

//导入私有framework
reverseDemo_PRIVATE_FRAMEWORK = AppSupport ChatKit

//链接Mach-O对象(Mach-O object)
// -lx 代表链接libx.a 或者libx.dylib
reverseDemo_LDFLAGS = -lx
</code></pre>

<p>Tweak.xm</p>

<p>默认生成的源文件，x表示支持Logos语法。</p>

<pre><code>/* How to Hook with Logos
Hooks are written with syntax similar to that of an Objective-C @implementation.
You don't need to #include &lt;substrate.h&gt;, it will be done automatically, as will
the generation of a class list and an automatic constructor.

%hook ClassName

// Hooking a class method
+ (id)sharedInstance {
  return %orig;
}

// Hooking an instance method with an argument.
- (void)messageName:(int)argument {
  %log; // Write a message about this call, including its class, name and arguments, to the system log.

  %orig; // Call through to the original function with its original arguments.
  %orig(nil); // Call through to the original function with a custom argument.

  // If you use %orig(), you MUST supply all arguments (except for self and _cmd, the automatically generated ones.)
}

// Hooking an instance method with no arguments.
- (id)noArguments {
  %log;
  id awesome = %orig;
  [awesome doSomethingElse];

  return awesome;
}

// Always make sure you clean up after yourself; Not doing so could have grave consequences!
%end
*/
</code></pre>

<p>主要包括几个命令:</p>

<pre><code>%hook : 指定需要hook的class，必须以%end结尾

%log : 在 %hook 函数内部使用，将函数的类名、参数等信息输出，还能够在结尾输出自定义格式信息

%orig : 执行被hook住的源代码，更改原始函数的参数

%group :将 %hook 分组，以%end结尾。便于代码管理及按条件初始化，不属于自定义的group都会隐式归类到%group_ungrouped中。 必须配合下面的 %init 命令才能生效

%init : 初始化某个group，必须在 hook 或 %ctor 内调用。如果带参数，则初始化指定的group。不带参数则初始化_ungrouped。 只有调用了 %init ，group才能生效

%ctor : 一个构造器，完成初始化工作。如果不显示定义，Theos自动生成一个 %ctor 。并在其中调用%init(_ungrouped), %ctor 不需要%end结尾

%new : 给一个现有的class添加新函数,功能与class_addMethod相同

%c : 等同于 objc_getClass 或者 NSClassFromString , 动态获取一个类的定义,在 %hook 或 %ctor 内使用

control
</code></pre>

<p>control记录了deb包管理系统所需的基本信息, 会被打包进deb里。其内容如下:</p>

<pre><code>Package: com.liuchendi.iOSReverse
Name: reverseDemo
Depends: mobilesubstrate    //依赖条件
Version: 0.0.1
Architecture: iphoneos-arm
Description: An awesome MobileSubstrate tweak!
Maintainer: liuchendi   //deb包的维护人
Author: liuchendi       //tweak作者
Section: Tweaks         //所属程序类别
</code></pre>

<p>更全面的介绍在 这里</p>

<pre><code>reverseDemo.plist
</code></pre>

<p>记录一些配置信息，描述tweak的作用范围。其实就是一个字典， Filter 为外键，里面包含有 :</p>

<pre><code>Bundles : tweak作用对象, 也是app的bundle id
Class : tweak作用的若干类
Executables : 指定若干可执行文件
</code></pre>

<p>注意: 当Filter下有不同的类array时候，需要添加Mode: Any键值对
3、编译 + 打包 + 安装
编译:make</p>

<p>执行make,可能出现的错误</p>

<pre><code>Please run `/Users/liuchendi/Desktop/逆向/Demo/reversedemo/theos/bin/bootstrap.sh substrate` manually, with privileges.
make: *** [before-all] Error 1
</code></pre>

<p>将iOS上的 /Library/Frameworks/CydiaSubstrate.framework/ CydiaSubstrate 拷贝到OSX中，将其重命名为libsubstrate.dylib后放到“/opt/theos/lib/libsubstrate. dylib”中</p>

<pre><code>/bin/sh: ldid: command not found
</code></pre>

<p>重新去 <a href="http://joedj.net/ldid">http://joedj.net/ldid</a> 下载ldid，放在/opt/theos/bin/下面,然后赋予可执行权限 sudo chmod 777</p>

<p>成功后的显示,完成了预处理，编译，签名等一系列工作</p>

<pre><code>Making all for tweak reverseDemo...
Preprocessing Tweak.xm...
Compiling Tweak.xm...
Linking tweak reverseDemo...
Stripping reverseDemo...
Signing reverseDemo...
</code></pre>

<p>发现多了一个obj文件夹</p>

<pre><code>liuchendi@lovelyddtekiMBP reversedemo$ ls -al
total 40
drwxr-xr-x  9 liuchendi  staff   306 12 17 23:20 .
drwxr-xr-x  4 liuchendi  staff   136 12 17 17:31 ..
drwxr-xr-x  4 liuchendi  staff   136 12 17 23:15 .theos
-rw-r--r--  1 liuchendi  staff   182 12 17 17:30 Makefile
-rw-r--r--  1 liuchendi  staff  1045 12 17 17:30 Tweak.xm
-rw-r--r--  1 liuchendi  staff   222 12 17 17:30 control
drwxr-xr-x  5 liuchendi  staff   170 12 17 23:20 obj
-rw-r--r--  1 liuchendi  staff    57 12 17 17:30 reverseDemo.plist
lrwxr-xr-x  1 liuchendi  staff    10 12 17 17:30 theos -&gt; /opt/theos
</code></pre>

<p>打包 make package</p>

<p>出现的错误</p>

<pre><code>make[2]: Nothing to be done for `internal-library-compile'.
Making stage for tweak reverseDemo...
make: *** [internal-package] Error 255
</code></pre>

<p>下载dm.pl文件 <a href="https://raw.githubusercontent.com/DHowett/dm.pl/master/dm.pl">https://raw.githubusercontent.com/DHowett/dm.pl/master/dm.pl</a> ,然后重命名为dpkg-deb.pl,放到/opt/theos/bin/目录下面。 我把pl后缀名字隐藏了</p>

<p>成功执行后的显示,生成一个*.deb的包</p>

<pre><code>liuchendi@lovelyddtekiMBP reversedemo$ make package
Making all for tweak reverseDemo...
Preprocessing Tweak.xm...
Compiling Tweak.xm...
Linking tweak reverseDemo...
Stripping reverseDemo...
Signing reverseDemo...
Making stage for tweak reverseDemo...
dpkg-deb：正在新建软件包“com.liuchendi.iosreverse”，包文件为“./com.liuchendi.iOSReverse_0.0.1-5_iphoneos-arm.deb”。
</code></pre>

<p>多了一个， _ 目录,里面有 DEBIAN 和 Library 文件夹</p>

<pre><code>liuchendi@lovelyddtekiMBP reversedemo$ ls
Makefile
Tweak.xm
_
com.liuchendi.iOSReverse_0.0.1-5_iphoneos-arm.deb
control
obj
reverseDemo.plist
theos
liuchendi@lovelyddtekiMBP reversedemo$ ls _
DEBIAN  Library
</code></pre>

<p><img src="http://al1020119.github.io/images/nixiangtweak001.png" title="Caption" ></p>

<p>用 dpkg -c 查看生成的内容</p>

<pre><code>liuchendi@lovelyddtekiMBP reversedemo$ dpkg -c com.liuchendi.iOSReverse_0.0.1-5_iphoneos-arm.deb
drwxr-xr-x liuchendi/staff   0 2015-12-17 23:48 ./
drwxr-xr-x liuchendi/staff   0 2015-12-17 23:48 ./Library/
drwxr-xr-x liuchendi/staff   0 2015-12-17 23:48 ./Library/MobileSubstrate/
drwxr-xr-x liuchendi/staff   0 2015-12-17 23:48 ./Library/MobileSubstrate/DynamicLibraries/
-rwxr-xr-x liuchendi/staff 49952 2015-12-17 23:48 ./Library/MobileSubstrate/DynamicLibraries/reverseDemo.dylib
-rw-r--r-- liuchendi/staff    57 2015-12-17 23:48 ./Library/MobileSubstrate/DynamicLibraries/reverseDemo.plist
</code></pre>

<p>可以看到内容都是一样的
安装</p>

<pre><code>make package install
</code></pre>

<p>首先在Makefile添加下面的内容,主要是指定安装的手机ip</p>

<pre><code>ARCHS = armv7 arm64
TARGET = iphone:latest:7.0
THEOS_DEVICE_IP = 192.168.1.100
</code></pre>

<p>安装成功后的显示,期间要输入两次密码</p>

<pre><code>liuchendi@lovelyddtekiMBP reversedemo$ make package install
Making all for tweak reverseDemo...
make[2]: Nothing to be done for `internal-library-compile'.
Making stage for tweak reverseDemo...
dpkg-deb：正在新建软件包“com.liuchendi.iosreverse”，包文件为“./com.liuchendi.iOSReverse_0.0.1-7_iphoneos-arm.deb”。
install.exec "cat &gt; /tmp/_theos_install.deb; dpkg -i /tmp/_theos_install.deb &amp;&amp; rm /tmp/_theos_install.deb" &lt; "./com.liuchendi.iOSReverse_0.0.1-7_iphoneos-arm.deb"
root@192.168.1.100's password: 
Selecting previously deselected package com.liuchendi.iosreverse.
(Reading database ... 2389 files and directories currently installed.)
Unpacking com.liuchendi.iosreverse (from /tmp/_theos_install.deb) ...
Setting up com.liuchendi.iosreverse (0.0.1-7) ...
install.exec "killall -9 SpringBoard"
root@192.168.1.100's password:
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[修改图标数字]]></title>
    <link href="http://al1020119.github.io/blog/2016/03/18/xiugaitubiaozhishishuzi/"/>
    <updated>2016-03-18T13:32:08+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/03/18/xiugaitubiaozhishishuzi</id>
    <content type="html"><![CDATA[<p>修改程序图标标示数字</p>

<p>1.修改自身应用图标标示数字：
   [UIApplication sharedApplication].applicationIconBadgeNumber = 10;
2. 修改其他应用图标标示数字：
   ios7.0下的sdk
   Use class-dump to dump the headers for /Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS3.0.sdk/System/Library/PrivateFrameworks/iTunesStore.framework/iTunesStore</p>

<p>涉及的头文件</p>

<pre><code>ISOperation-ISAuthentication.h
ISOperation-ISLoadSoftwareMapAdditions.h
ISOperation-ISLoadURLBagAdditions.h
ISOperation.h
ISOperationDelegate-Protocol.h
ISOperationQueue.h
ISSetApplicationBadgeOperation.h

You may have to edit ISOperation.h:
</code></pre>

<!--more-->


<ol>
<li>Change the #import &ldquo;NSOperation.h&rdquo; to #import</li>
<li>Remove the &ldquo;&rdquo; in the first part of the interface.</li>
<li>So you&rsquo;re just left with &ldquo;id _delegate;&rdquo;</li>
</ol>


<p>Then copy these 3 files into a &ldquo;Headers&rdquo; dir inside of the /Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS3.0.sdk/System/Library/PrivateFrameworks/iTunesStore.framework dir.</p>

<p>You can now add the iTunesStore framework to your xcode project. Just point to the dir above.</p>

<p>Now add &ldquo;#import &rdquo; to your code and, for your convenience, here&rsquo;s an example-function ready for use:</p>

<p>CODE：</p>

<pre><code>ISSetApplicationBadgeOperation *sbadge = [[ISSetApplicationBadgeOperation alloc] init];


[sbadge setBundleIdentifier:bundleIdentifier];
[sbadge setBadgeValue:[NSString stringWithFormat:@"%d",number]];
[sbadge run];
[sbadge release];
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[简单App实战]]></title>
    <link href="http://al1020119.github.io/blog/2016/03/14/jiandanappshizhan/"/>
    <updated>2016-03-14T13:32:08+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/03/14/jiandanappshizhan</id>
    <content type="html"><![CDATA[<p>底层开发之越狱开发第一篇</p>

<p>做越狱开发也有一些时间了，有很多东西想总结一下，希望给他人一些借鉴，也是自己对过去开发经历的一些总结。个人不推荐使用盗版，这里主要以技术介绍为主。</p>

<p>这个系列里面主要介绍怎样进行越狱开发，涉及到以下几个方面:</p>

<ul>
<li>(1)主要涉及到越狱市场的建立，在App内部实现ipa的安装和卸载以及更新。参照的对象就是91助手，25pp，同步推那样的应用。建立一个盗版的App Store.当然了，如果通过299刀的企业证书的话，是不需要通过Cydia的，直接通过网页链接就可以实现app的推广，有一定的风险。这里面涉及到一些协议，后面会进行介绍。</li>
<li>(2)在App内部实现壁纸和铃声的替换。这个过程涉及到的东西很多，特别是铃声的替换，iPhone里面非常麻烦；</li>
<li>(3)一些越狱插件的开发，通过里面有些插件非常好用，合理，而且非常美观漂亮。
这里先从App内部安装ipa包开始讲，后面逐步把上面提到的3点全部讲完。</li>
</ul>


<!--more-->


<p>一般情况下安装91助手，同步推这样的应用需要手机越狱，同时安装AppSync，这样才能使用，所以进行开发的必备条件也是如此。</p>

<p>上传的demo工程的地址，我的github链接：<a href="https://github.com/easonoutlook/IPAInstaller">https://github.com/easonoutlook/IPAInstaller</a></p>

<p>之前一直在fork别人的东西，也没做什么贡献，从现在开始，为开发为开源，做一点自己的贡献。</p>

<p>进入正题：</p>

<p>需要的工具和环境：</p>

<ul>
<li><ol type="a">
<li>iPhone or iPad越狱，安装AppSync</li>
</ol>
</li>
<li><ol type="a">
<li>Xcode安装 Command Line Tools</li>
</ol>
</li>
<li><ol type="a">
<li>下载最新版本的ldid <a href="https://github.com/downloads/rpetrich/ldid/ldid.zip">https://github.com/downloads/rpetrich/ldid/ldid.zip</a></li>
</ol>
</li>
</ul>


<h4>1、修改SDKSettings.plist文件</h4>

<p>我用的是Xcode4.6.3版本，iPhone的版本是6.1.2, 路径为：/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS6.1.sdk/</p>

<p>将这个目录下的 SDKSettings.plist里面的CODE_SIGNING_REQUIRED置为NO</p>

<p>执行命令为：</p>

<p>转到目录下</p>

<pre><code>cd /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS6.1.sdk
</code></pre>

<p>将原有文件备份</p>

<pre><code>sudo cp SDKSettings.plist SDKSettings.plist.orig
</code></pre>

<p>对SDKSettings.plist文件进行编辑</p>

<pre><code>sudo vim SDKSettings.plist
</code></pre>

<p>将下面对应的字段改为NO</p>

<pre><code>&lt;key&gt;CODE_SIGNING_REQUIRED&lt;/key&gt;
&lt;string&gt;YES&lt;/string&gt;  // 默认为YES, 需要改为NO
</code></pre>

<p>此操作参考的路径如下：<a href="http://kqwd.blog.163.com/blog/static/4122344820117191351263/">http://kqwd.blog.163.com/blog/static/4122344820117191351263/</a></p>

<h4>2、给工程添加相应的权限，iOS6里面需要赋予权限才可以，iOS5之前不需要此操作</h4>

<p>新建一个plist文件，命名为entitlements.</p>

<p><img src="http://al1020119.github.io/images/nixiang005.png" title="Caption" ></p>

<p>创建一个plist</p>

<p><img src="http://al1020119.github.io/images/nixiang006.png" title="Caption" ></p>

<p>将plist文件改为：</p>

<p>复制代码
复制代码</p>

<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;
&lt;plist version="1.0"&gt;
    &lt;dict&gt;
        &lt;key&gt;com.apple.private.mobileinstall.allowedSPI&lt;/key&gt;
        &lt;array&gt;
            &lt;string&gt;Install&lt;/string&gt;
            &lt;string&gt;Browse&lt;/string&gt;
            &lt;string&gt;Uninstall&lt;/string&gt;
            &lt;string&gt;Archive&lt;/string&gt;
            &lt;string&gt;RemoveArchive&lt;/string&gt;
        &lt;/array&gt;
    &lt;/dict&gt;
&lt;/plist&gt;
</code></pre>

<p>复制代码
复制代码
将Code Signing 的Code Signing Entilements设置为刚刚创建的entitlements.plist文件</p>

<p><img src="http://al1020119.github.io/images/nixiang007.png" title="Caption" ></p>

<p>后面还需要一个手续，将生产的app文件用ldid签名。后面再介绍。</p>

<p>3、实现越狱安装的代码：</p>

<p>复制代码
复制代码</p>

<pre><code>typedef NSDictionary *(*    PMobileInstallationLookup)(NSDictionary *params, id callback_unknown_usage);
NSDictionary *IPAInstalledApps()
{
    void *lib = dlopen("/System/Library/PrivateFrameworks/MobileInstallation.framework/MobileInstallation", RTLD_LAZY);
    if (lib)
    {
        PMobileInstallationLookup pMobileInstallationLookup = (PMobileInstallationLookup)dlsym(lib, "MobileInstallationLookup");
        if (pMobileInstallationLookup)
        {
            NSArray *wanted = nil;//[NSArray arrayWithObjects:@"com.celeware.IPADeploy",@"com.celeware.celedial",nil]; Lookup specified only
            NSDictionary *params = [NSDictionary dictionaryWithObjectsAndKeys:@"User", @"ApplicationType", wanted, @"BundleIDs",nil];
            NSDictionary *dict = pMobileInstallationLookup(params, NULL);
#ifdef DEBUG
            NSLog(@"%@", dict);
#endif
            return dict;
        }
    }
    return nil;
}
</code></pre>

<p>复制代码
复制代码
所有代码均在之前的github目录中，可以自行查看。</p>

<p>4、编译生成App文件</p>

<p>因为需要给APP签名加权限，所以不要生成IPA文件，而是生成APP文件。等把签名与权限加好后，再手动用APP制作IPA文件。</p>

<p> 在Xcode中选择设备（IOS Device）（图3），编译（Build）（图4）。编译完成后，在工程的Products文件夹中可以看到刚刚编译好的APP文件，右键Show in Finder（图5），就可以在文件夹中显示。将APP复制到一个别的文件夹中，什么地方都可以，后面需要用到。</p>

<p><img src="http://al1020119.github.io/images/nixiang008.png" title="Caption" ></p>

<p>5、制作ipa文件</p>

<p>将之前提到的ldid下载好后，将ldid文件放到/usr/bin中。</p>

<p>比如在 Download 目录下， sudo -i</p>

<p>然后 cp ldid /usr/bin/即可将文件拷贝到/usr/bin中。</p>

<p>然后对之前生成的文件，进行ldid签名</p>

<p><img src="http://al1020119.github.io/images/nixiang009.png" title="Caption" ></p>

<p>这个命令中“ldid -S” ，“ldid”与“-S”之间有一个空格。“-S”与“entitlements.xml”之间没有空格。“entitlements.xml”就是上面说到的XML文件，如果你的XML不是这个名，请将命令修改为你的XML文件名即可。</p>

<p>“-Sentitlements.xm”与“ipainstall.app”之间有一个空格。“ipainstall”是刚刚生成的APP文件，如果你的名字不一样，请修改为你的名字。“/“后面和APP的名字是一样的。  如果没有输出错误信息或是卡住（就是敲回车后没反应）就是添加权限成功了。</p>

<p>6、生成ipa文件，安装</p>

<p>新建一个文件夹，命名为“Payload”。将刚刚添加好权限的APP文件放到这个文件夹中。右键“压缩Payload”，得到一个“.zip”文件，将这个ZIP文件的后缀名改为“.ipa”。好了，IPA文件就制作完成了。</p>

<p>然后通过itools安装，测试刚刚生成的文件</p>

<p><img src="http://al1020119.github.io/images/nixiang010.png" title="Caption" ></p>

<p>整合了很多资源，有些地方弄的比较凌乱，后面加以完善</p>

<p>参考资源链接：</p>

<p><a href="http://since2006.com/blog/240/ios6-mobileinstallationinstall">http://since2006.com/blog/240/ios6-mobileinstallationinstall</a>
<a href="http://blog.sina.com.cn/s/blog_9cd1705d0101l4bo.html">http://blog.sina.com.cn/s/blog_9cd1705d0101l4bo.html</a>
<a href="http://kqwd.blog.163.com/blog/static/4122344820117191351263/">http://kqwd.blog.163.com/blog/static/4122344820117191351263/</a>
<a href="http://blog.csdn.net/linkai5696/article/details/5924356">http://blog.csdn.net/linkai5696/article/details/5924356</a>
<a href="http://www.yonsm.net/post/553">http://www.yonsm.net/post/553</a>
<a href="http://stackoverflow.com/questions/14871748/how-do-i-change-my-applications-entitlements-to-com-apple-backboard-client">http://stackoverflow.com/questions/14871748/how-do-i-change-my-applications-entitlements-to-com-apple-backboard-client</a>
<a href="http://stackoverflow.com/questions/13817569/how-to-programatically-install-a-ipa-file-in-ios-6/15062538#15062538">http://stackoverflow.com/questions/13817569/how-to-programatically-install-a-ipa-file-in-ios-6/15062538#15062538</a>
<a href="http://since2006.com/blog/240/ios6-mobileinstallationinstall">http://since2006.com/blog/240/ios6-mobileinstallationinstall</a>
<a href="http://hi.baidu.com/prognostic/item/831b622202b2dd0f72863e9c">http://hi.baidu.com/prognostic/item/831b622202b2dd0f72863e9c</a>
<a href="http://www.vsyo.com/a/t/89895554d4043c5a">http://www.vsyo.com/a/t/89895554d4043c5a</a>
<a href="http://mobile.dotblogs.com.tw/cmd4shell/archive/2013/03/26/98967.aspx">http://mobile.dotblogs.com.tw/cmd4shell/archive/2013/03/26/98967.aspx</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[资源文件夹获取]]></title>
    <link href="http://al1020119.github.io/blog/2016/03/12/ziyuanwenjianhuoqu/"/>
    <updated>2016-03-12T13:32:08+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/03/12/ziyuanwenjianhuoqu</id>
    <content type="html"><![CDATA[<p>用pngcrush反编译ios app 资源文件</p>

<p>时间：2012-12-27 11:56:45 类别：ios开发 访问: 3705 次</p>

<p>要提高app制作水平，最好的方法就是学习领先者，用pngcrush反编译ios app 资源文件，步骤很简单</p>

<!--more-->


<ol>
<li><p>在电脑的itunes中下载你选中的app，下载完成之后，然后在finder里面找到对应的ipa包，也可以在91等市场中直接下载ipa文件</p></li>
<li><p>ipa文件其实是zip包，重命名为zip后缀文件之后，双击打开
找到 xxx.app 文件，这其实是个目录，点击右键，在菜单中选中“查看包内容”，就可以进入目录，然后看到大量的资源文件，这些png文件都直接放在app的根目录，你可以在finder中直接浏览</p></li>
<li><p>但是这些png文件都是打包过程中被压缩过的，photoshop无法正确识别 （ 注：打包app的时候，你可以在xcode project选项中选择对png文件不压缩）</p></li>
<li><p>要把这些png文件还原，可以通过一个名叫 pngcrush 的开源软件，你可以到 sourceforge 下载，实际上ios的sdk也提供了这个程序（xcode就是利用它压缩png的）xcrun -sdk iphoneos -find pngcrush 可以获得 pngcrush的安装目录，然后直接使用，或者在你的$PATH目录里面做一个符号链接，这样可以在console窗口直接敲pngcrush</p></li>
</ol>


<p>进入资源文件存放目录，打开对应的命令行窗口，执行下面的命令即可</p>

<pre><code>pngcrush -d xxx reverted -revert-iphone-optimizations -q *.png
pngcrush -e xxx reverted -revert-iphone-optimizations -q *.png
</code></pre>

<p>上面提到的方法都是在mac操作系统下面，如果是windows/linux也可以用，pngcrush也提供了对应的版本</p>
]]></content>
  </entry>
  
</feed>
