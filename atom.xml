<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[iOS梦工厂]]></title>
  <link href="http://al1020119.github.io/atom.xml" rel="self"/>
  <link href="http://al1020119.github.io/"/>
  <updated>2015-12-09T12:31:45+08:00</updated>
  <id>http://al1020119.github.io/</id>
  <author>
    <name><![CDATA[iCocos]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Git+SoureTree实战]]></title>
    <link href="http://al1020119.github.io/blog/2015/12/28/git-plus-souretreeshi-zhan/"/>
    <updated>2015-12-28T12:28:06+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/12/28/git-plus-souretreeshi-zhan</id>
    <content type="html"><![CDATA[<p>由于之前一直使用SVN（Cornerstone），最近手痒痒的想弄一下git，听说soureTree不错，就花了一段时间研究了一下，并记录下来！</p>

<p>GitHub相信大家都知道，上面有很多优秀的开源项目供我们学习，比较著名的类似AFNetworking、SDWebImage等等。本篇文章就是教大家如何在Mac系统下提交自己的项目到GitHub上，相信对于新手还是很有帮助的。</p>

<h2>首先我们必须先从git命令开始，没有为什么！</h2>

<h3>需要的工具</h3>

<ul>
<li><p>1.安装Git  <a href="http://git-scm.com/download/mac">http://git-scm.com/download/mac</a> 我下的是2.2.1版本的。</p></li>
<li><p>2.终端 (自带的，请允许我卖个萌。。。)</p></li>
</ul>


<h3>操作流程</h3>

<ul>
<li><p>1.GitHub 上注册账号  <a href="https://github.com/">https://github.com/</a> 去这上面注册下就行（这里就不多说，自己去做吧）。</p></li>
<li><p>2.配置 SSH key</p></li>
</ul>


<!--more-->


<pre><code>-  ①  defaults write com.apple.finder AppleShowAllFiles -bool true     终端 显示隐藏文件（需要重新运行Finder)。

-  ② 点击桌面顶部菜单  前往&gt;个人  看看自己电脑上有没有个 .ssh 的隐藏文件，有的话个人建议删除，新建个。

-  ③  mkdir .ssh    终端新建个 .ssh文件

-  ④  cd .ssh   进入到刚才新建的.ssh文件目录下 

-  ⑤  ssh-Keygen -t rsa -C "your_email@example.com"       后面“ ”里面 随意输入个邮箱就行,回车会提示你输入密码什么的，可以无视一直回车下去。

-  ⑥  ls -la      查看是否存在 id_rsa(私钥)  id_rsa.pub(公钥) 这两个东西，如果存在就成功了。

-  ⑦ pbcopy &lt; ~/.ssh/id_rsa.pub     拷贝 公钥

-  ⑧ 进入GitHub 登入 。 

        添加你刚才生成的SSH Key 到GitHub上，也就是最后一张图的 Add SSH Key 点击 会让你输入秘钥 以及秘钥的名称。 秘钥 pbcopy &lt; ~/.ssh/id_rsa.pub 这个终端命令就已经复制过了  直接command + V 粘贴上去就行，秘钥名称随意。
</code></pre>

<p><img src="http://al1020119.github.io/images/git004.png" title="Caption" ></p>

<p><img src="http://al1020119.github.io/images/git005.png" title="Caption" ></p>

<p>ssh -T <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#111;&#x3a;&#103;&#105;&#x74;&#x40;&#103;&#x69;&#116;&#x68;&#x75;&#98;&#46;&#x63;&#x6f;&#109;">&#103;&#105;&#x74;&#x40;&#x67;&#x69;&#x74;&#104;&#117;&#98;&#x2e;&#x63;&#111;&#109;</a>   新添加到github上的秘钥左边的点一开始是灰色的，终端执行这个命令后，刷新网页会看到灰色点变成了绿色。</p>

<p><img src="http://al1020119.github.io/images/git006.png" title="Caption" ></p>

<ul>
<li>3.在GitHub 上创建公开项目。</li>
</ul>


<p><img src="http://al1020119.github.io/images/git001.png" title="Caption" ></p>

<p><img src="http://al1020119.github.io/images/git002.png" title="Caption" ></p>

<p><img src="http://al1020119.github.io/images/git003.png" title="Caption" ></p>

<ul>
<li><p>4.上传本地项目到GitHub。</p>

<ul>
<li><p> ① 在电脑上新建个项目文件夹 。</p></li>
<li><p> ②  cd + 刚才新建的项目文件夹路径</p></li>
<li><p> ③  git clone + GitHub 上创建的项目地址    （GitHub 上创建的项目地址如下图所示）这样你在GitHub 上创建的项目就克隆下来了</p></li>
<li><p> ④ cd + 克隆下来的项目路径 （如何在终端输入路径，可以直接把你想要知道路径的文件夹拖到终端里 这样自动就要该文件夹的路径了）</p></li>
<li><p> ⑤ git init    (git 仓库的初始化)</p></li>
<li><p> ⑥ git add .    (这里注意：add 空格 再加 .)</p></li>
<li><p> ⑦ git status    (查看add 成功没)</p></li>
<li><p> ⑧ git commit -m &ldquo;描述&rdquo;   （“ ” 引号里面输入你的描述 随意）</p></li>
<li><p> ⑨ git push origin master        (最后push到GitHub上)</p></li>
</ul>
</li>
</ul>


<p><img src="http://al1020119.github.io/images/git007.png" title="Caption" ></p>

<p>到这里大概结束了，祝大家能够在GitHub上发起更多好的项目，发扬光大开源精神！</p>

<p><img src="http://al1020119.github.io/images/git008.png" title="Caption" ></p>

<hr />

<h2>SourceTree</h2>

<blockquote><p>简介
SourceTree 是 Windows 和Mac OS X 下免费的 Git 和 Hg 客户端，拥有可视化界面，容易上手操作。同时它也是Mercurial和Subversion版本控制系统工具。支持创建、提交、clone、push、pull 和merge等操作。
  </p></blockquote>

<p>关于SourceTree的下载，github的账号注册，仓库的创建这里就不介绍了，亦或者没有什么好说的，因为会用电脑都会做，而且前面已经介绍过了，一部分。我们就从上面做好的所用项目中最后一步开始。看卡下面的图片：
  
<img src="http://al1020119.github.io/images/git008.png" title="Caption" ><br/>
  </p>

<h5>SourceTree基本使用</h5>

<blockquote><p>以下以SourceTree For Mac V2.0.5.2中文版为例，托管平台以Github为例</p></blockquote>

<ul>
<li>1.打开我们的SourceTree，点击：“+新仓库”，选择：“从URL克隆”</li>
</ul>


<p><img src="http://al1020119.github.io/images/git009.png" title="Caption" ></p>

<ul>
<li>2.粘贴我们的仓库链接至源URL，SourceTree会自动帮我们生成目标路径（本地仓库路径）以及名称，点击克隆</li>
</ul>


<p><img src="http://al1020119.github.io/images/git010.png" title="Caption" ></p>

<ul>
<li>3.等待数秒后，SourceTree会为我们自动打开我们刚才克隆的仓库，选择master选项，这里我们可以看到我们仓库里的所有文件</li>
</ul>


<p><img src="http://al1020119.github.io/images/git011.png" title="Caption" ></p>

<ul>
<li>4.双击souretree中对应的项目之后。</li>
</ul>


<p><img src="http://al1020119.github.io/images/git012.png" title="Caption" ></p>

<p>后面就是需要熟悉souretree界面，并且使用了，也就是平时开发者们最常用的一些操作。</p>

<p><img src="http://al1020119.github.io/images/git013.png" title="Caption" ></p>

<p>具体的详细步骤，后面我会找机会根据项目实际开发整理好(不过，如果你使用果Coerstone那这个也并不难)。由于时间的原因，这里就到这里了！</p>

<h5>最后总结一下：SourceTree&amp;Git部分名词解释</h5>

<pre><code>克隆(clone)：从远程仓库URL加载创建一个与远程仓库一样的本地仓库
提交(commit)：将暂存文件上传到本地仓库（我们在Finder中对本地仓库做修改后一般都得先提交一次，再推送）
检出(checkout)：切换不同分支
添加（add）：添加文件到暂存区
移除（remove）：移除文件至暂存区
暂存(git stash)：保存工作现场
重置(reset)：回到最近添加(add)/提交(commit)状态
合并(merge)：将多个同名文件合并为一个文件，该文件包含多个同名文件的所有内容，相同内容抵消
抓取(fetch)：从远程仓库获取信息并同步至本地仓库
拉取(pull)：从远程仓库获取信息并同步至本地仓库，并且自动执行合并（merge）操作，即 pull=fetch+merge
推送(push)：将本地仓库同步至远程仓库，一般推送（push）前先拉取（pull）一次，确保一致
分支(branch)：创建/修改/删除分枝
标签(tag):给项目增添标签
工作流(Git Flow):团队工作时，每个人创建属于自己的分枝（branch），确定无误后提交到master分枝
终端(terminal):可以输入git命令行
</code></pre>

<h6>相关链接推荐</h6>

<p>→<a href="https://help.github.com/desktop/">Github help for mac</a></p>

<p>→<a href="https://help.github.com/desktop/">Github help for win</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS9-CoreSpotlight]]></title>
    <link href="http://al1020119.github.io/blog/2015/12/25/ios9-corespotlight/"/>
    <updated>2015-12-25T13:35:30+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/12/25/ios9-corespotlight</id>
    <content type="html"><![CDATA[<p>iOS9 Day-by-Day是作者Chris Grant新开的一个系列博客，覆盖了iOS开发者必须知道的关于iOS 9的新技术与API，并且还进行了实际操作演练，每篇文章中相关的代码Chris都会将其托管到GitHub。</p>

<p>在第一篇文章中，Chris介绍了iOS 9的三种搜索API，分别为：</p>

<ul>
<li><p>NSUserActivity，索引用户活动以及App的状态。</p></li>
<li><p>Web Markup，Web内容可被搜索。</p></li>
<li><p>iOS 9新增的CoreSpotlight.framework提供了增、删、改、查等搜索API，可以索引App的内容。
译文如下：</p></li>
</ul>


<p>在苹果发布iOS 9之前，你只能在Spotlight中输入名称来寻找App，而随着苹果发布了一套全新的iOS 9 Search APIs之后，开发者不但可以自由选择App的部分内容编入索引，还能对Spotlight上的搜索结果以及点击不同结果显示的内容进行设置。</p>

<h3>三大API</h3>

<!--more-->


<h5>NSUserActivity</h5>

<ul>
<li><p>NSUserActivity是iOS 8专为Handoff推出的API，iOS 9之后得到了提升。现在用户只需提供元数据（metadata）就能搜索不同的activity（活动）了。</p></li>
<li><p>换言之，Spotlight可以将activity编入索引，而NSUserActivity就好比网页浏览器的历史堆栈（history stack），使用户能在Spotlight上搜到最近的活动。</p></li>
</ul>


<h5>Web Markup</h5>

<ul>
<li><p>Web Markup在网页上显示App的内容并编入Spotlight索引，如此一来即便没有安装某个App，苹果的索引器也能在网页上搜索特别的标记（markup），在Safari或Spotlight上显示搜索结果。</p></li>
<li><p>显示未安装App的搜索结果是一大亮点，有望为开发者带来更多潜在用户。公布在搜索API上的App深链接则储存在苹果的cloud index中。更多详情，请参阅苹果的“Web Markup使用指南（Use Web Markup to Make App Content Searchable）”。</p></li>
</ul>


<h5>CoreSpotlight</h5>

<ul>
<li>NSUserActivity帮助储存用户历史，而全新的Core Spotlight则能将App中的任何内容编入索引，实质是在用户设备上提供基础的Core Spotlight索引渠道，满足用户另外一个需求。</li>
</ul>


<hr />

<p>至于前面两个这里就不过多介绍，这里只介绍iOS9相关新特性，所以就来说我们应该怎么去学习并使用CoreSpotlight。</p>

<blockquote><p>对于CoreSpotlight可以类比NSUserDefault，都是全局的存储空间。不同的是CoreSpotlight是系统的存储空间，每个App都能访问（可能这个访问有限制，目前还没有时间研究），但是NSUserDefault是每个App私有的。另外对于存储的内容CoreSpotlight存储的是item，即CSSearchableItem，而每个CSSearchableItem又有许多属性，这些属性是通过CSSearchableItemAttributeSet进行设置。具体都有神马属性，大家自己去看头文件吧。</p></blockquote>

<p> 下面写一下简单得步骤：</p>

<ul>
<li><p>1 引入CoreSpotlight.framework</p></li>
<li><p>2 创建CSSearchableItemAttributeSet、CSSearchableItem</p></li>
<li><p>3 调用CSSearchableIndex.defaultSearchableIndex()的相关的方法对item进行操作。</p></li>
</ul>


<blockquote><p>由于本人水平有限，只找到了添加、删除itme的操作，并没有找到更新itme的方法，如果谁清楚了，麻烦告知一下。</p></blockquote>

<p> 下面贴出本人测试的一个简单例子的代码：
    import UIKit</p>

<pre><code>@UIApplicationMain
class AppDelegate: UIResponder, UIApplicationDelegate {

    var window: UIWindow?

    // 从搜索结果点击的时候将会调用这个方法
    func application(application: UIApplication, continueUserActivity userActivity: NSUserActivity, restorationHandler: ([AnyObject]?) -&gt; Void) -&gt; Bool {
        // 这里能够获取到点击搜索结果的identifier 但是不清楚是不是应该这样做
        let identifier = userActivity.userInfo?["kCSSearchableItemActivityIdentifier"]
        print("continueUserActivity \(identifier!)")
        return true
    }


}
</code></pre>

<hr />

<pre><code>import UIKit
import CoreSpotlight

class ViewController: UIViewController {
    let identifier = "com.mxy.test.identifier"
    var index = 1 // 用于标识添加的itme

    override func viewDidLoad() {
        super.viewDidLoad()
        CSSearchableIndex.defaultSearchableIndex().deleteAllSearchableItemsWithCompletionHandler { (error) -&gt; Void in

        }
    }


    @IBAction func insertItem() {
        let attributeSet = CSSearchableItemAttributeSet(itemContentType: "com.mxy.test")
        attributeSet.title = "孟祥月 测试 mxy \(index)"
        attributeSet.contentDescription = "this 这里写点什么好呢 mxy \(index)"
        // 设置搜索结果的缩略图 不知道 为何就是不生效 我给应用程序添加了icon后，搜索结果那里显示的是icon
        attributeSet.thumbnailURL = NSURL(fileURLWithPath: NSBundle.mainBundle().pathForResource("aa", ofType: "png")!)
        attributeSet.thumbnailData = UIImagePNGRepresentation(UIImage(named: "aa")!)
        let item = CSSearchableItem(uniqueIdentifier: "\(identifier) \(index)", domainIdentifier: "mxy", attributeSet: attributeSet)
        let tmpItmes: [CSSearchableItem] = [item]
        CSSearchableIndex.defaultSearchableIndex().indexSearchableItems(tmpItmes) { (error) -&gt; Void in

        }
        index++
    }

    // 貌似是没有更新操作 所以只好根据identifier先删除，修改后再添加进去。
    @IBAction func updateItem() {
        if index &gt; 0 {
            let tmpIdentifier = "\(identifier) \(index - 1)"
            CSSearchableIndex.defaultSearchableIndex().deleteSearchableItemsWithIdentifiers([tmpIdentifier], completionHandler: { (error) -&gt; Void in

            })

            let attributeSet = CSSearchableItemAttributeSet(itemContentType: "com.mxy.test")
            attributeSet.title = "孟祥月 测试 mxy \(index - 1)"
            attributeSet.contentDescription = "this 这里写点更新后 mxy \(index - 1)"
            let item = CSSearchableItem(uniqueIdentifier: tmpIdentifier, domainIdentifier: "mxy", attributeSet: attributeSet)
            let tmpItmes: [CSSearchableItem] = [item]
            CSSearchableIndex.defaultSearchableIndex().indexSearchableItems(tmpItmes) { (error) -&gt; Void in

            }

        }

    }

    @IBAction func deleteItem() {
        let identifiers = ["\(identifier) \(index)"]
        index--
        if index &lt;= 0 {
            return
        }
        CSSearchableIndex.defaultSearchableIndex().deleteSearchableItemsWithIdentifiers(identifiers) { (error) -&gt; Void in

        }
    }

}
</code></pre>

<p>在storyboard中只是添加了三个按钮，关联对应的操作。下面是演示，点击更新的时候会更新最后一个item的内容：</p>

<p><img src="http://al1020119.github.io/images/Spotlight001.gif" title="Caption" ></p>

<p>例子代码的下载地址：<a href="http://download.csdn.net/detail/mengxiangyue/8827141">http://download.csdn.net/detail/mengxiangyue/8827141</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS9-WKWebView+SFSafariViewController]]></title>
    <link href="http://al1020119.github.io/blog/2015/12/24/ios9xin-te-xing-wkwebview/"/>
    <updated>2015-12-24T19:35:40+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/12/24/ios9xin-te-xing-wkwebview</id>
    <content type="html"><![CDATA[<h2>一：WKWebView简单介绍</h2>

<p>webkit使用WKWebView来代替IOS的UIWebView和OSX的WebView，并且使用Nitro JavaScript引擎，这意味着所有第三方浏览器运行JavaScript将会跟safari一样快。</p>

<p>先来看看WKWebView和UIWebView有什么区别：</p>

<h6>UIWebView：</h6>

<ul>
<li>始祖级别，支持的iOS版本比较多</li>
<li>可支持打开URL，包括各种URL模式，例如 Https，FTP等</li>
<li>可支持打开各种不同文件格式，例如 txt，docx，ppt,，音视频文件等，很多文档阅读器会经常使用这个特性，感兴趣的可以查一下Apple的文档，支持的格式还是挺多，只是不同iOS 版本的支持程度不太一样，使用时请多留意测试确认~</li>
<li>占用内存比较多，尤其是网页中包含比较多CSS+DIV之类内容时，很容易出现内存警告（Memory Warning）</li>
<li>效率低，不灵活，尤其是和 JavaScript交互时</li>
<li>无法清除本地存储数据（Local Storage）</li>
<li>代理（delegate）之间的回调比较麻烦，提供的内容比较低级，尤其是UI部分。如果想自己定制一个类似 Safari 的内嵌浏览器（Browser），那就坑爹无极限了，例如我们PDF Reader系列中的内嵌Browser，自己* 手动模拟实现Tab切换，底部Tool及各种Menu等，说多了都是泪~~</li>
</ul>


<h6>WKWebView：</h6>

<ul>
<li>iOS 8引入的，比较年轻</li>
<li>在内存和执行效率上要比UIWebView高很多</li>
<li>开放度较高但据说Bug成吨</li>
<li>类似UIWebView，UI定制比较麻烦···</li>
<li>没具体测试使用过，就不继续列举了 L~</li>
</ul>


<!--more-->


<h5>第一、WKWebView增加的属性和方法</h5>

<p>类比UIWebView，跟UIWebView的API对比，
增加的属性：</p>

<pre><code>* 1、estimatedProgress 加载进度条，在IOS8之前我们是通过一个假的进度条来实现
* 2、backForwardList 表示historyList
* 3、WKWebViewConfiguration *configuration; 初始化webview的配置
</code></pre>

<p>增加的方法：</p>

<pre><code>- (instancetype)initWithFrame:(CGRect)frame configuration:(WKWebViewConfiguration *)configuration 
</code></pre>

<p>初始化</p>

<pre><code>    - (WKNavigation *)goToBackForwardListItem:(WKBackForwardListItem *)item; 
</code></pre>

<p>跳到历史的某个页面</p>

<!--more-->


<h5>第二、相同的属性和方法</h5>

<ul>
<li>goBack、</li>
<li>goForward、</li>
<li>canGoBack、</li>
<li>canGoForward、</li>
<li>stopLoading、</li>
<li>loadRequest、</li>
<li>scrollView</li>
</ul>


<h5>第三、被删去的属性和方法：</h5>

<pre><code>- (NSString *)stringByEvaluatingJavaScriptFromString:(NSString *)script;
</code></pre>

<p>在跟js交互时，我们使用这个API，目前WKWebView完档没有给出实现类似功能的API</p>

<ul>
<li>无法设置缓存
在UIWebView，使用NSURLCache缓存，通过setSharedURLCache可以设置成我们自己的缓存，但WKWebView不支持NSURLCache

<h5>第四、delegate方法的不同</h5>

<p>UIWebView支持的代理是UIWebViewDelegate，WKWebView支持的代理是WKNavigationDelegate和
WKUIDelegate
WKNavigationDelegate主要实现了涉及到导航跳转方面的回调方法
WKUIDelegate主要实现了涉及到界面显示的回调方法：如WKWebView的改变和js相关内容
具体来说WKNavigationDelegate除了有开始加载、加载成功、加载失败的API外，还具有额外的三个代理方法：</p>

<pre><code>  -(void)webView:(WKWebView *)webView didReceiveServerRedirectForProvisionalNavigation:(WKNavigation *)navigation
</code></pre>

<p>这个代理是服务器redirect时调用</p>

<pre><code>  -(void)webView:(WKWebView *)webView decidePolicyForNavigationResponse:(WKNavigationResponse *)navigationResponse decisionHandler:(void (^)(WKNavigationResponsePolicy))decisionHandler
</code></pre>

<p>这个代理方法表示当客户端收到服务器的响应头，根据response相关信息，可以决定这次跳转是否可以继续进行。</p>

<pre><code>  -(void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler
</code></pre>

<p>根据webView、navigationAction相关信息决定这次跳转是否可以继续进行,这些信息包含HTTP发送请求，如头部包含User-Agent,Accept</p></li>
</ul>


<hr />

<h2>二、WKWebView新特性</h2>

<ul>
<li>在性能、稳定性、功能方面有很大提升（最直观的体现就是加载网页是占用的内存，模拟器加载百度与开源中国* 网站时，WKWebView占用23M，而UIWebView占用85M）；</li>
<li>允许JavaScript的Nitro库加载并使用（UIWebView中限制）；</li>
<li>支持了更多的HTML5特性；</li>
<li>高达60fps的滚动刷新率以及内置手势；</li>
<li>将UIWebViewDelegate与UIWebView重构成了14类与3个协议（查看苹果官方文档）；</li>
</ul>


<hr />

<h2>三：基本使用</h2>

<p>WKWebView相对于UIWebView强大了很多，内存的消耗相对少了，所提供的接口也丰富了。
现在谈一谈WKWebView的基本使用</p>

<h4>1. navigationDelegate</h4>

<pre><code>- (void)webView:(WKWebView *)webView didStartProvisionalNavigation:(WKNavigation *)navigation { // 类似UIWebView的 -webViewDidStartLoad:  
    NSLog(@"didStartProvisionalNavigation");  
    [UIApplication sharedApplication].networkActivityIndicatorVisible = YES;  
}  

- (void)webView:(WKWebView *)webView didCommitNavigation:(WKNavigation *)navigation {  
    NSLog(@"didCommitNavigation");  
}  

- (void)webView:(WKWebView *)webView didFinishNavigation:(WKNavigation *)navigation { // 类似 UIWebView 的 －webViewDidFinishLoad:  
    NSLog(@"didFinishNavigation");  
    [self resetControl];  
    if (webView.title.length &gt; 0) {  
        self.title = webView.title;  
    }  

}  
- (void)webView:(WKWebView *)webView didFailProvisionalNavigation:(WKNavigation *)navigation withError:(NSError *)error {  
    // 类似 UIWebView 的- webView:didFailLoadWithError:  

    NSLog(@"didFailProvisionalNavigation");  

}  
- (void)webView:(WKWebView *)webView decidePolicyForNavigationResponse:(WKNavigationResponse *)navigationResponse decisionHandler:(void (^)(WKNavigationResponsePolicy))decisionHandler {  

    decisionHandler(WKNavigationResponsePolicyAllow);  
}  


- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler {  
    // 类似 UIWebView 的 -webView: shouldStartLoadWithRequest: navigationType:  

    NSLog(@"4.%@",navigationAction.request);  


    NSString *url = [navigationAction.request.URL.absoluteString stringByReplacingPercentEscapesUsingEncoding:NSUTF8StringEncoding];  



    decisionHandler(WKNavigationActionPolicyAllow);  

}  
- (void)webView:(WKWebView *)webView didReceiveAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition, NSURLCredential *))completionHandler {  

}  
</code></pre>

<h4>2 UIDelegate</h4>

<pre><code>- (WKWebView *)webView:(WKWebView *)webView createWebViewWithConfiguration:(WKWebViewConfiguration *)configuration forNavigationAction:(WKNavigationAction *)navigationAction windowFeatures:(WKWindowFeatures *)windowFeatures {  
    // 接口的作用是打开新窗口委托  
    [self createNewWebViewWithURL:webView.URL.absoluteString config:configuration];  

    return currentSubView.webView;  
}  

- (void)webView:(WKWebView *)webView runJavaScriptAlertPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)())completionHandler  
{    // js 里面的alert实现，如果不实现，网页的alert函数无效  
    UIAlertController *alertController = [UIAlertController alertControllerWithTitle:message  
                                                                             message:nil  
                                                                      preferredStyle:UIAlertControllerStyleAlert];  
    [alertController addAction:[UIAlertAction actionWithTitle:@"确定"  
                                                        style:UIAlertActionStyleCancel  
                                                      handler:^(UIAlertAction *action) {  
                                                          completionHandler();  
                                                      }]];  

    [self presentViewController:alertController animated:YES completion:^{}];  

}  


- (void)webView:(WKWebView *)webView runJavaScriptConfirmPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(BOOL))completionHandler {  
    //  js 里面的alert实现，如果不实现，网页的alert函数无效  ,   

    UIAlertController *alertController = [UIAlertController alertControllerWithTitle:message  
                                                                             message:nil  
                                                                      preferredStyle:UIAlertControllerStyleAlert];  
    [alertController addAction:[UIAlertAction actionWithTitle:@"确定"  
                                                        style:UIAlertActionStyleDefault  
                                                      handler:^(UIAlertAction *action) {  
                                                          completionHandler(YES);  
                                                      }]];  
    [alertController addAction:[UIAlertAction actionWithTitle:@"取消"  
                                                        style:UIAlertActionStyleCancel  
                                                      handler:^(UIAlertAction *action){  
                                                          completionHandler(NO);  
                                                      }]];  

    [self presentViewController:alertController animated:YES completion:^{}];  

}  

- (void)webView:(WKWebView *)webView runJavaScriptTextInputPanelWithPrompt:(NSString *)prompt defaultText:(NSString *)defaultText initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(NSString *))completionHandler {  

    completionHandler(@"Client Not handler");  

}  
</code></pre>

<h4>3. WKWebView 执行脚本方法</h4>

<pre><code>- (void)evaluateJavaScript:(NSString *)javaScriptString completionHandler:(void (^)(id, NSError *))completionHandler;  

completionHandler 拥有两个参数，一个是返回错误，一个可以返回执行脚本后的返回值  
</code></pre>

<h4>4. WKWebView 的Cookie问题</h4>

<p>UIWebView 中会自动保存Cookie，如果登录了一次，下次再次进入的时候，会记住登录状态
而在WKWebView中，并不会这样，WKWebView在初始化的时候有一个方法</p>

<pre><code>- (instancetype)initWithFrame:(CGRect)frame configuration:(WKWebViewConfiguration *)configuration  
</code></pre>

<p>通过这个方法，设置 configuration 让WKWebView知道登录状态，configuration 可以通过已有的Cookie进行设置，也可以通过保存上一次的configuration进行设置</p>

<p>参考 stackoverflow上回答：</p>

<p><a href="http://stackoverflow.com/questions/26573137/can-i-set-the-cookies-to-be-used-by-a-wkwebview/26577303#26577303">http://stackoverflow.com/questions/26573137/can-i-set-the-cookies-to-be-used-by-a-wkwebview/26577303#26577303</a></p>

<pre><code>WKWebView * webView = /*set up your webView*/  
NSMutableURLRequest * request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"http://example.com/index.html"]];  
[request addValue:@"TeskCookieKey1=TeskCookieValue1;TeskCookieKey2=TeskCookieValue2;" forHTTPHeaderField:@"Cookie"];  
// use stringWithFormat: in the above line to inject your values programmatically  
[webView loadRequest:request];  

[objc] view plaincopyprint?在CODE上查看代码片派生到我的代码片
WKUserContentController* userContentController = WKUserContentController.new;  
WKUserScript * cookieScript = [[WKUserScript alloc]   
    initWithSource: @"document.cookie = 'TeskCookieKey1=TeskCookieValue1';document.cookie = 'TeskCookieKey2=TeskCookieValue2';"  
    injectionTime:WKUserScriptInjectionTimeAtDocumentStart forMainFrameOnly:NO];  
// again, use stringWithFormat: in the above line to inject your values programmatically  
[userContentController addUserScript:cookieScript];  
WKWebViewConfiguration* webViewConfig = WKWebViewConfiguration.new;  
webViewConfig.userContentController = userContentController;  
WKWebView * webView = [[WKWebView alloc] initWithFrame:CGRectMake(/*set your values*/) configuration:webViewConfig];  
</code></pre>

<hr />

<h2>四：WKWebView与js通信</h2>

<p>iOS 8 引入WKWebView, WKWebView 不支持JavaScriptCore的方式但提供message handler的方式为JavaScript 与Objective-C 通信.
在Objective-C 中使用WKWebView的以下方法调用JavaScript:</p>

<pre><code>- (void)evaluateJavaScript:(NSString *)javaScriptString
         completionHandler:(void (^)(id, NSError *))completionHandler
如果JavaScript 代码出错, 可以在completionHandler 进行处理.
在Objective-C 中注册 message handler:
// WKScriptMessageHandler protocol?

- (void)userContentController:(WKUserContentController *)userContentController
    didReceiveScriptMessage:(WKScriptMessage *)message
{
    NSLog(@"Message: %@", message.body);
}

[userContentController addScriptMessageHandler:handler name:@"myName"];
在JavaScript 将信息发给Objective-C:
// window.webkit.messageHandlers.&lt;name&gt;.postMessage();?

function postMyMessage()? {?
    var message = { 'message' : 'Hello, World!', 'numbers' : [ 1, 2, 3 ] };?
    window.webkit.messageHandlers.myName.postMessage(message);?
}
</code></pre>

<hr />

<h2>五：常见问题：</h2>

<p>32 位的app在使用WKWebView的时候，如果运行在64位的设备上，会出现一下问题：</p>

<ul>
<li>（1）iOS8.1 系统，部分网页加载白屏，例如 百度，iOS8.3 似乎没问题</li>
<li>（2）web输入框输入汉字也会出现白屏</li>
</ul>


<p>通过搜索得到问题根源：</p>

<blockquote><p>WKWebView&rsquo;s WebProcess runs out-of-process as a 64-bit process on hardware supporting 64bit. There is a 32bit/64bit marshalling IPC bug for 32 bit apps using the WKWebView client on such hardware. The bug causes the WebProcess to exit, leaving a blank screen.</p></blockquote>

<ul>
<li>也就是一个进程间通讯的bug引起的。</li>
</ul>


<h6>解决方案，可以使app支持arm64，便不会出现问题。</h6>

<hr />

<h2>六：SFSafariViewController：</h2>

<ul>
<li>iOS 9引入，更加年轻，意味着是Apple的新菜，总是有什么优势的</li>
<li>也是用来显示网页内容的</li>
<li>这是一个特殊的View Controller，而不是一个单独的 View，和前面两个的区别</li>
<li>在当前App中使用Safari的UI框架展现Web内容，包括相同的地址栏，工具栏等，类似一个内置于App的小型Safari</li>
<li>共享Safari的一些便利特性，包括：相似的用户体验，和Safari共享Cookie，iCloud Web表单数据，密码、证书自动填充，Safari阅读器（Safari Reader）</li>
<li>可定制性比较差，甚至连地址栏都是不可编辑的，只能在init的时候，传入一个URL来指定网页的地址</li>
<li>只能用来展示单个页面，并且有一个完成按钮用来退出</li>
</ul>


<p><img src="http://al1020119.github.io/images/safari001.png" title="Caption" ></p>

<p>如果你的App需要显示网页，但是又不想自己去定制浏览器界面的话，可以考虑用SFSafariViewController来试试。从好的方面看，SFSafariViewController也去掉了从App中跳转到Safari的撕裂感，不同App之间切换总是让人感觉麻烦和不舒服。</p>

<p>代码例子:</p>

<pre><code>- (IBAction)onButtonClick:(id)sender

{

    NSString *urlString = @"http://www.kdanmobile.com";

    SFSafariViewController *sfViewControllr = [[SFSafariViewController alloc] initWithURL:[NSURL URLWithString:urlString]];

    sfViewControllr.delegate = self;

    [self presentViewController:sfViewControllr animated:YES completion:^{

       //...

    }];

}



// Done 按钮

- (void)safariViewControllerDidFinish:(nonnull SFSafariViewController *)controller

{

    [controller dismissViewControllerAnimated:YES completion:nil];

}
</code></pre>

<p>SFSafariViewController 的接口比较少，就不再继续一一列举了。另外一个定制功能在于SFSafariViewControllerDelegate里面的一个方法：</p>

<pre><code>-(NSArray&lt;UIActivity *&gt; *)safariViewController:(SFSafariViewController *)controller activityItemsForURL:(NSURL *)URL title:(nullable NSString *)title;
</code></pre>

<p>这个代理会在用户点击动作（Action）按钮（底部工具栏中间的按钮）的时候调用，可以传入UIActivity的数组，创建添加一些自定义的各类插件式的服务，比如分享到微信，微博什么的。</p>

<p><img src="http://al1020119.github.io/images/safari001.png" title="Caption" ></p>

<blockquote><p>小细节：
SFSafariViewController有保存Cookies的功能，但是貌似不能和Safari浏览器共享，也可能是Beta版的bug</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS9-Unit Test]]></title>
    <link href="http://al1020119.github.io/blog/2015/12/22/ios9-unit-test/"/>
    <updated>2015-12-22T00:59:07+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/12/22/ios9-unit-test</id>
    <content type="html"><![CDATA[<p> XCode7(iOS9)中新增了跟多特性，包括：</p>

<ul>
<li>WKWebView+SFSafariViewController</li>
<li>UI Test</li>
<li>Multitasking</li>
<li>watchOS 2</li>
<li>Swift 2</li>
<li>App Thinning</li>
<li>人工智能和搜索 API</li>
<li>HomeKit，CloudKit，HealthKit 等等杂七杂八的框架</li>
</ul>


<p> 前面的文章中我们已经将WKWebView+SFSafariViewController完整的介绍了一遍，现在我们就开始着手探究一下单元测试（后面的文章中我将会集中介绍一下常用功能新特性），敬请关注：<a href="http://al1020119.github.io/">iOS梦工厂</a></p>

<h3>UI Tests是什么？</h3>

<p>UI Tests是一个自动测试UI与交互的Testing组件</p>

<!--more-->


<h3>UI Tests有什么用？</h3>

<p>它可以通过编写代码、或者是记录开发者的操作过程并代码化，来实现自动点击某个按钮、视图，或者自动输入文字等功能。</p>

<h3>UI Tests的重要性</h3>

<p>在实际的开发过程中，随着项目越做越大，功能越来越多，仅仅靠人工操作的方式来覆盖所有测试用例是非常困难的，尤其是加入新功能以后，旧的功能也要重新测试一遍，这导致了测试需要花非常多的时间来进行回归测试，这里产生了大量重复的工作，而这些重复的工作有些是可以自动完成的，这时候UI Tests就可以帮助解决这个问题了</p>

<h2>使用方法</h2>

<h6>第一步：添加UI Tests</h6>

<p>如果是新项目，则创建工程的时候可以直接勾选选项，如下图</p>

<p><img src="http://al1020119.github.io/images/unittest001.png" title="Caption" ></p>

<p>如果是已有的项目，可以通过添加target的方式添加一个UI Tests，点击xcode的菜单，找到target栏</p>

<p><img src="http://al1020119.github.io/images/unittest002.png" title="Caption" ></p>

<p>在Test选项中选择Cocoa Touch UI Testing Bundle</p>

<p><img src="http://al1020119.github.io/images/unittest003.png" title="Caption" ></p>

<p>这时候test组件添加成功，它在项目中的位置如下图所示</p>

<p><img src="http://al1020119.github.io/images/unittest004.png" title="Caption" ></p>

<h6>第二步：创建测试代码</h6>

<p>手动创建测试代码
打开测试文件，在testExample()方法中添加测试代码</p>

<p><img src="http://al1020119.github.io/images/unittest005.png" title="Caption" ></p>

<p>如果不知道如何写测试代码，则可以参考自动生成的代码样式</p>

<h5>自动生成测试步骤</h5>

<p>选择测试文件后，点击录制按钮</p>

<p><img src="http://al1020119.github.io/images/unittest006.png" title="Caption" ></p>

<p>这时候开始进行操作，它会记录你的操作步骤，并生成测试代码
下图就是在一些操作后自动生成的测试代码</p>

<p><img src="http://al1020119.github.io/images/unittest007.png" title="Caption" ></p>

<p>这时候可以分析测试代码的语法，以便你自己手动修改或者手写测试代码</p>

<h6>第三步：开始测试</h6>

<p>点击testExample方法旁边的播放按钮，它就开始进行自动测试了，这时候你会看到app在自动操作</p>

<p><img src="http://al1020119.github.io/images/unittest008.png" title="Caption" ></p>

<h6>下面介绍一下测试元素的语法</h6>

<p>XCUIApplication：
继承XCUIElement，这个类掌管应用程序的生命周期，里面包含两个主要方法</p>

<pre><code>launch():
</code></pre>

<p>启动程序</p>

<pre><code>terminate():
</code></pre>

<p>终止程序</p>

<h6>XCUIElement:</h6>

<p>继承NSObject，实现协议XCUIElementAttributes, XCUIElementTypeQueryProvider
可以表示系统的各种UI元素</p>

<pre><code>exist:
</code></pre>

<p>可以让你判断当前的UI元素是否存在，如果对一个不存在的元素进行操作，会导致测试组件抛出异常并中断测试</p>

<pre><code>descendantsMatchingType(type:XCUIElementType)-&gt;XCUIElementQuery:
</code></pre>

<p>取某种类型的元素以及它的子类集合</p>

<pre><code>childrenMatchingType(type:XCUIElementType)-&gt;XCUIElementQuery:
</code></pre>

<p>取某种类型的元素集合，不包含它的子类</p>

<p>这两个方法的区别在于，你仅使用系统的UIButton时，用childrenMatchingType就可以了，如果你还希望查询自己定义的子Button，就要用descendantsMatchingType</p>

<p>另外UI元素还有一些交互方法</p>

<pre><code>tap():
</code></pre>

<p>点击</p>

<pre><code>doubleTap():
</code></pre>

<p>双击</p>

<pre><code>pressForDuration(duration: NSTimeInterval):
</code></pre>

<p>长按一段时间，在你需要进行延时操作时，这个就派上用场了</p>

<pre><code>swipeUp():
</code></pre>

<p>这个响应不了pan手势，暂时没发现能用在什么地方，也可能是beta版的bug，先不解释</p>

<pre><code>typeText(text: String):
</code></pre>

<p>用于textField和textView输入文本时使用，使用前要确保文本框获得输入焦点，可以使用tap()函数使其获得焦点</p>

<h6>XCUIElementAttributes协议</h6>

<p>里面包含了UIAccessibility中的部分属性
如下图</p>

<p><img src="http://al1020119.github.io/images/unittest009.png" title="Caption" ></p>

<p>可以方便你查看当前元素的特征，其中identifier属性可用于直接读取元素，不过该属性在UITextField中有bug，暂时不清楚原因</p>

<p>XCUIElementTypeQueryProvider协议
里面包含了系统中大部分UI控件的类型，可通过读属性的方式取得某种类型的UI集合
部分属性截图如下</p>

<p><img src="http://al1020119.github.io/images/unittest010.png" title="Caption" ></p>

<h3>创建Demo</h3>

<p>首先创建一个登录页面</p>

<p><img src="http://al1020119.github.io/images/unittest011.png" title="Caption" ></p>

<p>点击login按钮进行登录验证，点击clear按钮会清除文本
登录成功后可以去到个人信息页面</p>

<p>个人信息页面如下</p>

<p><img src="http://al1020119.github.io/images/unittest012.png" title="Caption" ></p>

<p>点击modify按钮可以修改个人信息，点击Message按钮可以查看个人消息</p>

<p>最后是消息界面</p>

<p><img src="http://al1020119.github.io/images/unittest013.png" title="Caption" ></p>

<h4>登录页面的测试</h4>

<ul>
<li>输入一个错误的账号</li>
<li>验证结果</li>
<li>关闭警告窗</li>
<li>清除输入记录</li>
<li>输入一个正确的账号</li>
<li>验证结果</li>
<li>进入个人信息页面</li>
</ul>


<p>测试代码如下:</p>

<pre><code>func testLoginView() {
    let app = XCUIApplication()

    // 由于UITextField的id有问题，所以只能通过label的方式遍历元素来读取
    let nameField = self.getFieldWithLbl("nameField")
    if self.canOperateElement(nameField) {
        nameField!.tap()
        nameField!.typeText("xiaoming")
    }

    let psdField = self.getFieldWithLbl("psdField")
    if self.canOperateElement(psdField) {
        psdField!.tap()
        psdField!.typeText("1234321")
    }

    // 通过UIButton的预设id来读取对应的按钮
    let loginBtn = app.buttons["Login"]
    if self.canOperateElement(loginBtn) {
        loginBtn.tap()
    }

    // 开始一段延时，由于真实的登录是联网请求，所以不能直接获得结果，demo通过延时的方式来模拟联网请求
    let window = app.windows.elementAtIndex(0)
    if self.canOperateElement(window) {
        // 延时3秒, 3秒后如果登录成功，则自动进入信息页面，如果登录失败，则弹出警告窗
        window.pressForDuration(3)
    }

    // alert的id和labe都用不了，估计还是bug，所以只能通过数量判断
    if app.alerts.count &gt; 0 {
        // 登录失败
        app.alerts.collectionViews.buttons["确定"].tap()

        let clear = app.buttons["Clear"]
        if self.canOperateElement(clear) {
            clear.tap()

            if self.canOperateElement(nameField) {
                nameField!.tap()
                nameField!.typeText("sun")
            }

            if self.canOperateElement(psdField) {
                psdField!.tap()
                psdField!.typeText("111111")
            }

            if self.canOperateElement(loginBtn) {
                loginBtn.tap()
            }
            if self.canOperateElement(window) {
                // 延时3秒, 3秒后如果登录成功，则自动进入信息页面，如果登录失败，则弹出警告窗
                window.pressForDuration(3)
            }
            self.loginSuccess()
        }
    } else {
        // 登录成功
        self.loginSuccess()
    }
}
</code></pre>

<blockquote><p>这里有几个需要特别注意的点：
当你的元素不存在时，它仍然可能返回一个元素对象，但这时候不能对其进行操作
当你要点击的元素被键盘或者UIAlertView遮挡时，执行tap方法会抛异常
详细实现可参照demo:
<a href="https://github.com/sunljz/demo/tree/master/iOS9/UITestDemo">https://github.com/sunljz/demo/tree/master/iOS9/UITestDemo</a></p></blockquote>

<h4>个人信息页测试</h4>

<ul>
<li>修改性别</li>
<li>修改年龄</li>
<li>修改心情</li>
<li>保存修改</li>
</ul>


<p>测试代码如下：</p>

<pre><code>    func testInfo() {
        let app = XCUIApplication()
        let window = app.windows.elementAtIndex(0)
        if self.canOperateElement(window) {
            // 延时2秒, 加载数据需要时间
            window.pressForDuration(2)
        }

        let modifyBtn = app.buttons["modify"];
        modifyBtn.tap()

        let sexSwitch = app.switches["sex"]
        sexSwitch.tap()

        let incrementButton = app.buttons["Increment"]
        incrementButton.tap()
        incrementButton.tap()
        incrementButton.tap()
        app.buttons["Decrement"].tap()

        let textView = app.textViews["feeling"]
        textView.tap()
        app.keys["Delete"].tap()
        app.keys["Delete"].tap()
        textView.typeText(" abc ")

        // 点击空白区域
        let clearBtn = app.buttons["clearBtn"]
        clearBtn.tap()

        // 保存数据
        modifyBtn.tap()
        window.pressForDuration(2)

        let messageBtn = app.buttons["message"]
        messageBtn.tap();

        // 延时1秒, push view需要时间
        window.pressForDuration(1)

        self.testMessage()
    }
</code></pre>

<blockquote><p>这里需要特别注意以下两点：
textview获取焦点时无法选择焦点的位置
tap事件的触发位置是view的中心，所以当view的中心被遮挡时，要考虑使用其他view来代替</p></blockquote>

<h4>个人消息界面测试</h4>

<p>单元格的点击
测试代码如下：</p>

<pre><code>    func testMessage() {
        let app = XCUIApplication()
        let window = app.windows.elementAtIndex(0)
        if self.canOperateElement(window) {
            // 延时2秒, 加载数据需要时间
            window.pressForDuration(2)
        }

        let table = app.tables
        table.childrenMatchingType(.Cell).elementAtIndex(8).tap()
        table.childrenMatchingType(.Cell).elementAtIndex(1).tap()

    }
</code></pre>

<blockquote><p>这里需要注意一点：
暂时无法获取到tableView的元素指针</p></blockquote>

<h3>总结</h3>

<p>总的来说，UI Tests只能用于一些基础功能的测试，验证app的功能是否可以正常使用，是否存在崩溃问题。但它也有很多不足之处，编写测试用例的过程非常繁琐，自动生成的代码几乎无法运行，功能单一，很多用例无法覆盖，而且bug很多，大大地限制了UI Tests在实际开发中的应用。希望正式版出来的时候能够修复这些问题，并开放更多的功能。</p>

<p>demo地址：</p>

<p><a href="https://github.com/sunljz/demo/tree/master/iOS9/UITestDemo">https://github.com/sunljz/demo/tree/master/iOS9/UITestDemo</a></p>

<p>最后介绍几个常见的第三方测试框架：</p>

<p>Frank， KIF， Subliminal， Apple 的 UIAutomation，我把他们都试了一遍。你要是希望了解更多可以访问我的故障特征测试框架。它不是开发者的失败，而是因为 Apple 对待测试只有有限的开放性。这使得这些框架有一系列的补丁，而在这些补丁之上，这些框架不外乎都成为了一堆破碎的工具。
没有涉及到的更多细节：</p>

<ul>
<li>Frank 一直被遗弃。</li>
<li>KIF 已经与主要的 iOS 修订版本决裂。</li>
<li>Subliminal 不能在命令行中可靠地运行。</li>
<li>UIAutomation 是用 JavaScript 和 clunky 写的。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS9+Xcode总结]]></title>
    <link href="http://al1020119.github.io/blog/2015/12/20/ios9-plus-xcodezong-jie/"/>
    <updated>2015-12-20T23:56:09+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/12/20/ios9-plus-xcodezong-jie</id>
    <content type="html"><![CDATA[<p>刚更新了Xcode 9 beat 2，运行了之前的工程，发现了一些问题，就针对性的做了一下iOS9的适配。</p>

<h4>1，默认使用HTTPS请求</h4>

<p>如果在Xcode 9之前使用的时http请求，那么在XCode 9上编译的App是不能联网的，会提示如下错误:</p>

<pre><code>App Transport Security has blocked a cleartext HTTP (http://) resource load since it is insecure. Temporary exceptions can be configured via your app's Info.plist file.
</code></pre>

<p>修改方法是要么使服务器支持https访问，要么关闭https的使用。第一种方法对于个人开发者来说代价还是比较大的，因此推荐使用后面一种方法，具体的做法是:在工程的Info.plist文件里添加NSAppTransportSecurity字典类型的，添加一个元素：key为NSAllowsArbitraryLoads，值为YES。</p>

<h4>2，iOS 9使用URL scheme必须将其加入白名单</h4>

<p>否则会提示类似如下错误:</p>

<!--more-->


<pre><code>    canOpenURL: failed for URL: "mqqopensdkapiV2://qqapp" - error: "This app is not allowed to query for scheme mqqopensdkapiV2”
</code></pre>

<p>修正方法是，Info.plist文件中添加一个key为LSApplicationQueriesSchemes的数组值，里面包含需要添加白名单的string类型的scheme。特酷吧在项目中使用了qq，微信等分享登录功能，需要添加的值为：</p>

<ul>
<li>mqqopensdkapiV2</li>
<li>mqqOpensdkSSoLogin</li>
<li>mqq</li>
<li>mqzoneopensdkapiV2</li>
<li>mqzoneopensdkapi19</li>
<li>mqzoneopensdkapi</li>
<li>mqzoneopensdk</li>
<li>mqzone</li>
<li>weixin</li>
<li>wechat
更多其他适配点后续不断跟进。</li>
</ul>


<h4>3，bitcode</h4>

<p>使用Xcode7编译提示：</p>

<pre><code>XXX does not contain bitcode. You must rebuild it with bitcode enabled (Xcode setting ENABLE_BITCODE), obtain an updated library from the vendor, or disable bitcode for this target. for architecture arm64
</code></pre>

<p>bitcode是被编译程序的一种中间形式的代码。包含bitcode配置的程序将会在App store上被编译和链接。bitcode允许苹果在后期重新优化我们程序的二进制文件，而不需要我们重新提交一个新的版本到App store上。
Xcode7 默认开启了bitcode，如果App使用的第三方类库不支持bitcode会提示错误，只需要在”Build Settings”->”Enable Bitcode”选项中看关闭bitcode即可。</p>

<blockquote><p>开启Bitcode编译后，编译产生的文件体积会变大 (因为是中间代码，不是用户下载的包)，且dSYM文件不能用来崩溃日志的符号化 (用户下载的包是Apple服务重新编译产生的，有产生新的符号文件)。通过Archive方式上传AppStore的包，可以在 Xcode的Organizer工具中下载对应安装包的新的符号文件。
转载请注明来自特酷吧,本文地址:www.tekuba.net/program/364/
 
 </p>

<h4>4，使用XCode7链接第三方库提示warning</h4>

<pre><code>Lots of warnings when building with Xcode 7 with 3rd party libraries
warning: Could not resolve external type c:objc(cs)NSString
warning: Could not resolve external type c:objc(cs)NSDictionary
warning: Could not resolve external type c:objc(cs)NSMutableString
warning: Could not resolve external type c:objc(cs)NSError
</code></pre>

<p><a href="https://forums.developer.apple.com/thread/17921">https://forums.developer.apple.com/thread/17921</a>
目前没发现好的解决办法，可以尝试如下:
I had this problem too.  Here&rsquo;s how I fixed it.</p></blockquote>

<ul>
<li>1)  Go to Build Settings -> Build Options -> Debug Information Format</li>
<li>2)  Change the Debug setting from &ldquo;DWARF with dSYM File&rdquo; to &ldquo;DWARF&rdquo;</li>
<li>3)  Leave the Release setting at &ldquo;DWARF with dSYM File&rdquo;</li>
</ul>


<p>The problem appears to be that Xcode was trying to create dSYM files for Debug builds.  You don&rsquo;t need dSYM files for Debug builds &ndash; it&rsquo;s release builds where you need them. </p>

<hr />

<h6>既然提到了Xcode7，那么Xcode7中也有几个需要注意的地方（Xcode7是随着ios9一起出来的，其实也就是ios9的新特性，只是不是sdk），</h6>

<p>升级到XCode7之后，编译和上传到itunes connect中遇到了一些问题（特酷吧XCode版本7.0.1），在这里总结下：</p>

<h4>1，was built for newer iOS version (9.0) than being linked (7.0)</h4>

<p>解决方法参考：<a href="http://qaseeker.com/32270491-xcode-7-warning-was-built-for-newer-ios-version-5-1-1-than-being-linked-5-1/">http://qaseeker.com/32270491-xcode-7-warning-was-built-for-newer-ios-version-5-1-1-than-being-linked-5-1/</a></p>

<pre><code>the -w flag can be added to Build Settings -&gt; Other Linker Flags
</code></pre>

<h4>2，Could not resolve external type c:objc(cs)</h4>

<p>解决方法参考：</p>

<pre><code>https://community.pushwoosh.com/questions/2774/lot-of-warnings-with-xcode-70-and-pushwoosh-304
</code></pre>

<p>It looks like a bug of XCode 7. See the discussion here:</p>

<pre><code>https://forums.developer.apple.com/thread/17921
</code></pre>

<hr />

<pre><code>To get rid of this warning you need to change debug information from "DWARF + dSYM" to DWARF.
DWARF seems to be the default setting for new projects created in Xcode 7, but existing projects that are migrating to Xcode 7 probably still have DWARF with dSYM File as the setting.
</code></pre>

<p>特酷吧亲测发现使用XCode7新建工程的时候，Debug模式默认选择了DWARF。</p>

<h4>3，"The resulting API analysis file is too large. We were unable to validate your API usage prior to delivery</h4>

<p><a href="https://forums.developer.apple.com/thread/18493">https://forums.developer.apple.com/thread/18493</a>
建议处理</p>

<ul>
<li>1，export IPA file (after you select Archive from within xCode)</li>
<li>2，Use Application Loader to upload</li>
<li>3，de-select Bitcode and Symbols</li>
</ul>


<p>似乎目前对bitcode的支持还不是很好，建议关闭。再上传。</p>

<h4>4.最后就是和swift相关的。</h4>

<p>如果使用了混编技术，也就是说里面涉及到了swift代码，实现了桥接，那么系统会偶尔出现崩溃的现象，这个时候需要修改一个属性</p>

<ul>
<li>1：选中项目</li>
<li>2：选中target，在build Setting中搜索swift</li>
<li><p>3：在出现的embedded content contains swift code选中对应的值</p>

<ul>
<li>使用了swift就是YES</li>
<li>没有swift就是NO</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iBeacon初探]]></title>
    <link href="http://al1020119.github.io/blog/2015/11/28/ibeaconchu-tan/"/>
    <updated>2015-11-28T17:42:15+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/11/28/ibeaconchu-tan</id>
    <content type="html"><![CDATA[<blockquote><p>iBeacon 是苹果公司在 iOS 7 中新推出的一种近场定位技术，可以感知一个附近的 iBeacon 信标的存在。
当一个 iBeacon 兼容设备进入/退出一个 iBeacon 信标标识的区域时，iOS 和支持 iBeacon 的 app 就能得知这一信息，从而对用户发出相应的通知。</p></blockquote>

<p>典型的应用场景例如博物馆实时推送附近展品的相关信息，商场内即时通知客户折扣信息
等。苹果在 Apple Store 中也部署了 iBeacon 来推送优惠、活动信息。</p>

<!--more-->


<h4>Apple Store 中的 iBeacon 支持</h4>

<h6>特点</h6>

<pre><code>iBeacon 基于低功耗蓝牙技术（Bluetooth Low Energy, BLE）这一开放标准，因此也继承了 BLE 的一些特点。
</code></pre>

<h6>范围广</h6>

<pre><code>相比于 NFC 的数厘米的识别范围，iBeacon 的识别范围可以达到数十米，并且能够估计距离的远近。
</code></pre>

<h6>兼容性</h6>

<pre><code>iBeacon 是基于 BLE 做的一个简单封装，因此大部分支持 BLE 的设备都可以兼容。
例如可以使用一个普通的蓝牙芯片作为信标，使用 Android 设备检测信标的存在。
</code></pre>

<h6>低能耗</h6>

<pre><code>不少 beacon 实现宣称可以不依赖外部能源独立运行两年。
</code></pre>

<h6>使用场景</h6>

<pre><code>我们以一个连锁商场的例子来讲解 iBeacon 的一个流程。在一个连锁商场中，店家需要在商场中的不同地方推送不同的优惠信息，比如服装和家居柜台推送的消息就很有可能不同。
</code></pre>

<p>当消费者走进某个商场时，会扫描到一个 beacon。这个 beacon 有三个标志符，proximityUUID 是一个整个公司（所有连锁商场）统一的值，可以用来标识这个公司，major 值用来标识特定的连锁商场，比如消费者正在走进的商场，minor 值标识了特定的一个位置的 beacon，例如定位到消费者正在门口。</p>

<p>这时商场的 app 会被系统唤醒，app 可以运行一个比较短的时间。在这段时间内，app 可以根据 beacon 的属性查询到用户的地理位置（通过查询服务器或者本地数据），例如在化妆品专柜，之后就可以通过一个 local notification 推送化妆品的促销信息。用户可以点击这次 local notification 来查看更详细的信息，这样一次促销行为就完成了。</p>

<h6>API</h6>

<pre><code>闲话少说，我们来看下 iBeacon 具体怎么使用：
</code></pre>

<h6>Beacon 的表示</h6>

<pre><code>iBeacon 本质上来说是一个位置（区域）信息，所以 Apple 把 iBeacon 功能集成在了 Core Location 里面。
</code></pre>

<p>iBeacon 信标在 Core Location 中表现为一个 CLBeacon，它圈定的范围则表现为 CLBeaconRegion，这是一个 CLRegion 的子类。</p>

<p>CLBeaconRegion 主要用三个属性来标识一个 iBeacon，proximityUUID、major 和 minor。
proximityUUID 是一个 NSUUID，用来标识公司，每个公司、组织使用的 iBeacon 应该拥有同样的 proximityUUID。
major 用来识别一组相关联的 beacon，例如在连锁超市的场景中，每个分店的 beacon 应该拥有同样的 major。
minor 则用来区分某个特定的 beacon。</p>

<pre><code>这些属性如果不指定（即 nil），匹配的时候就会忽略这个属性。例如只指定 proximityUUID 的 CLBeaconRegion 可以匹配某公司的所有 beacons。
</code></pre>

<h6>Monitoring</h6>

<pre><code>Apple 在 iOS 4 中增加了地理围栏 API，可以用来在设备进入/退出某个地理区域时获得通知，这些 API 包括 -startMonitoringForRegion:、-locationManager:didEnterRegion:、-locationManager:didExitRegion: 等。
</code></pre>

<p>CLBeaconRegion 作为 CLRegion 的子类也可以复用这些 API，这种检测 iBeacon 的方式叫做 monitoring。</p>

<p>使用这种方法可以在程序在后台运行时检测 iBeacon，但是只能同时检测 20 个 region，也不能推测设备与 beacon 的距离。</p>

<h6>Ranging</h6>

<pre><code>除了使用地理围栏 API 的方式，Apple 还在 iOS 7 中新增加了 iBeacon 专用的检测方式，也就是 ranging。
</code></pre>

<p>通过 CLLocationManager 的 -startRangingBeaconsInRegion: 方法可以开始检测特定的 iBeacon。</p>

<p>当检测到 beacon 的时候，CLLocationManager 的 delegate 方法 -locationManager:didRangeBeacons:inRegion: 会被调用，通知调用者现在被检测到的 beacons。
这个方法会返回一个 CLBeacon 的数组，根据 CLBeacon 的 proximity 属性就可以判断设备和 beacon 之间的距离。</p>

<blockquote><p>proximity 属性有四个可能的值，unknown、immediate、near 和 far。
另外 CLBeacon 还有 accuracy 和 rssi 两个属性能提供更详细的距离数据。</p></blockquote>

<h6>使用 iOS 设备作为 iBeacon</h6>

<p>我们可以使用 Core Bluetooth 框架来广播特定的 payload 来让 iOS 设备成为一个 iBeacon。
这个 payload 可以由 CLBeaconRegion 的 -peripheralDataWithMeasuredPower: 方法来获取。
之后交给 CBPeripheralManager 广播出去就可以了。</p>

<p>需要注意的是，广播 iBeacon 信息的时候 app 必须在前台运行。</p>

<h6>行为</h6>

<p>iBeacon 的 API 并不十分复杂，但他的行为比较难弄清楚，特别是当应用运行在后台时，检测到 beacon 的时间延迟会让开发者难以推测。在做了一些实验和合理的推测后，我们得出了一些</p>

<blockquote><p>结论：
检测到 beacon 的时间跟设备进行蓝牙扫描的时间间隔有关，每当设备进行扫描的时候，就能发现 iBeacon region 的变化。
在 ranging 打开的情况下，设备会每秒钟做一次扫描，也就是说状态更新最多延迟一秒。
程序在后台运行，并且 monitoring 打开的时候，设备可能每隔数分钟做一次扫描。iOS 7 的响应速度较慢，iOS 7.1 有比较大的改善。
如果存在设置 notifyEntryStateOnDisplay=YES 的 beacon，iOS 会在屏幕点亮的时候（锁屏状态下按下 home 键，或者因为收到推送点亮等）进行一次扫描。
设备重启并不影响 iBeacon 后台检测的执行。
iOS 7 中，在多任务界面中杀掉程序会终止 iBeacon 检测的执行，iOS 7.1 上改变了这一行为，被杀掉的 app 还可以继续进行 iBeacon 检测。</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Watch OS2 初探]]></title>
    <link href="http://al1020119.github.io/blog/2015/11/14/watch-os2-chu-tan/"/>
    <updated>2015-11-14T17:44:31+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/11/14/watch-os2-chu-tan</id>
    <content type="html"><![CDATA[<blockquote><p>这一年的WWDC大会上,苹果公司推出了watchOS 2,这标志着Apple Watch的开发产生了巨大的变化。现在,你可以开发能运行在你手表上原生的app了。 在这篇watchOS 2教程中,你会开发一个简单但是功能齐全的watchOS 2的app。
在这个过程中,你会学到:</p></blockquote>

<ul>
<li>如何为iOS app添加watchOS 2的target</li>
<li>如何在两个target之间共享数据</li>
<li>如何添加一个watchOS 2界面控制器到Storyboard,并放置界面对象</li>
<li>如何创建WKInterfaceController的子类并连线</li>
</ul>


<!--more-->


<p>正式开始吧</p>

<p>首先下载教程的起始项目吧。</p>

<p>在Xcode中打开它然后编译运行。你应该会看到一个空白界面:</p>

<p><img src="http://al1020119.github.io/images/watchOS001.png" title="Caption" ></p>

<p>这个项目没有太多的文件,只包含一些你需要的最基本的文件。</p>

<p>添加WatchKit App</p>

<p>选择File\New\Target…,在出现的对话框中选择watchOS\Application\WatchKit App然后点击Next:</p>

<p><img src="http://al1020119.github.io/images/watchOS002.png" title="Caption" ></p>

<p>在接下来的界面中,设置项目名字为Watch,确保语言设置为Swift,然后取消选中任何复选框。点击Finish:</p>

<p><img src="http://al1020119.github.io/images/watchOS003.png" title="Caption" ></p>

<p>之后会询问你是否想要激活watch scheme,你需要这么做,所以确保选择了激活:</p>

<p><img src="http://al1020119.github.io/images/watchOS004.png" title="Caption" ></p>

<p>祝贺,你刚刚创建了你的第一个手表app!这真的很容易。</p>

<p>你会注意到,这个操作实际上创建了两个target,而不是一个,在项目导航中看到两个对应的组。这是因为手表app的代码实际是作为一个扩展形式存在的,类似iOS上的Today extensions。</p>

<p>当你在项目导航中点开Watch和Watch Extensions组的时候,你会看到所有storyboard放在Watch组,当前target创建的所有的类文件放在Watch Extensions组中:</p>

<p><img src="http://al1020119.github.io/images/watchOS005.png" title="Caption" ></p>

<p>你需要遵循如下的原则:任何你添加的代码必须放在Watch Extension组中然后添加到Watch Extension target,而所有的assets或者storyboards需要放在Watch组里。</p>

<p><img src="http://al1020119.github.io/images/watchOS006.png" title="Caption" ></p>

<p>在继续前,你需要删掉一些target模板添加的你不需要的文件。</p>

<p>在项目导航里面右键点击InterfaceController.swift然后选择删除。 当弹出提示,选择Move to Trash来确保文件确实从项目中删掉了:</p>

<p><img src="http://al1020119.github.io/images/watchOS007.png" title="Caption" ></p>

<p>下一步,打开Interface.storyboard,选择其中仅有的界面控制器,按下backspace键来删除它。现在就剩下一个空storyboard,或者是我认为的,一个空白画布。</p>

<p>共享数据和代码</p>

<p>起始项目包含一个记录所有Aber航空公司航班信息的JSON文件,一个模型类表示飞行数据。这正是应该共享的数据,因为iOS app和手表app使用相同的模型类和数据-你记得DRY(不要写重复的代码)原则吗?</p>

<p>在项目导航中点开Shared组然后选择Flights.json。之后,在File Inspector中找到Target Membership区域,选中Watch Extension</p>

<p><img src="http://al1020119.github.io/images/watchOS008.png" title="Caption" ></p>

<p>文件现在应该被AirAber和Watch Extensions这两个target所包含。 为其他Shared组的文件重复这个步骤,比如说Flight.swift。 这些都做完后,你可以开始开发航班详情界面了!</p>

<p>构造界面</p>

<p>打开 Watch\Interface.storyboard,从对象库拖一个界面控制器到storyboard里面.选中这个界面控制器,打开属性检查器设置它的Identificer为Flight,然后勾选Is Initial Controller:</p>

<p><img src="http://al1020119.github.io/images/watchOS009.png" title="Caption" ></p>

<p>你设置的这个Identifier让你可以在代码中引用这个界面控制器。选中Is Initial Controller简单告诉WatchKit你希望当应用程序启动的时候首先显示这个界面。</p>

<p>下一步,从对象库中拖动一个组到界面控制器:</p>

<p><img src="http://al1020119.github.io/images/watchOS010.png" title="Caption" ></p>

<p>之后这个组会包含Aber公司的logo,航班号和路线。</p>

<p>选中这个组,在属性检查器的顶部改变它的Insets为Custom。这会显示四个额外的文本框让你可以手动的设置组的上下左右。设置Top为6:</p>

<p><img src="http://al1020119.github.io/images/watchOS011.png" title="Caption" ></p>

<p>这仅仅让你的组到顶部有个额外的空隙。</p>

<p>下一步,拖动Image到组中。组会相应的收缩来改变Top inset(感谢Xcode!),之后在文档大纲中检查来确保Image是组的子节点,而不是同级:</p>

<p><img src="http://al1020119.github.io/images/watchOS012.png" title="Caption" ></p>

<p>现在需要显示一张图片,下载logo图片然后把它拖动到Watch\Assets.xcassets中。这会创建一个新的logo图片,存放在2x的部分。</p>

<p><img src="http://al1020119.github.io/images/watchOS013.png" title="Caption" ></p>

<p>为了给图片染色,选中这张图片,在属性检查器中修改Render As为Template Image。</p>

<p>重新打开 Watch\Interface.storyboard 选中之前的image.使用属性检查器,做如下的改变:</p>

<ul>
<li>设置图片为Logo - 当下拉列表没有出现,你可以自己输入;</li>
<li>设置Tint为#FA114F(也可以在颜色面板中输入值);</li>
<li>设置Width为Fixed,值为40;</li>
<li>设置Height为Fixed,值为40。</li>
</ul>


<p>属性检查器现在应该像下面这样:</p>

<p><img src="http://al1020119.github.io/images/watchOS014.png" title="Caption" ></p>

<p>不要担心看不到logo,因为Xcode设计时无法给模板图片染色!</p>

<p>下一步,往已经存在的组中拖动另外一个组,确保它出现在image的右侧,使用属性检查器设置Layout属性为Vertical.同样修改Spacing为0、Width为Size to Fit Content。然后拖动两个label到新的组中,放置一个到另一个的下面。</p>

<p><img src="http://al1020119.github.io/images/watchOS015.png" title="Caption" ></p>

<p>选择上面的label,使用属性检查器,设置文本为Flight 123,文字颜色为#FA114F。</p>

<p>选择下面的label,设置文本为MAM to SFO。界面控制器最后看起来像下面这样:</p>

<p><img src="http://al1020119.github.io/images/watchOS016.png" title="Caption" ></p>

<p>这些文本仅仅充当占位符,之后会被控制器中设置的文本取代。</p>

<p>下一步,拖动另一个组到界面控制器中,但是这次确保与第一个组同级。当不能设置组级别关系请使用文档大纲(Document Outline)。</p>

<p><img src="http://al1020119.github.io/images/watchOS017.png" title="Caption" ></p>

<p>选中新的组,设置它的Layout为Vertical、Spacing为0。</p>

<p>现在,拖动三个label到新的组中:</p>

<p><img src="http://al1020119.github.io/images/watchOS018.png" title="Caption" ></p>

<p>确保label都在group中,而不是与group同级!</p>

<p>选择顶部的label使用属性检查器修改它的文本为AA123 Boards。</p>

<p>选中中间的label,修改文本颜色为#FA114F,字体选择System,Regulaer样式和54.0的size.最后,修改Height为Fixed,值是44。</p>

<p>选中底部的label修改文本为On time,文本颜色为#04DE71。 你的界面控制器应该现在像下面这样:</p>

<p><img src="http://al1020119.github.io/images/watchOS019.png" title="Caption" ></p>

<p>从对象库中拖动一个新的组到下面的组,这次确保它是在子节点而不是在同级,之后向其中添加两个label,你完全的界面对象关系应该像这样:</p>

<p><img src="http://al1020119.github.io/images/watchOS020.png" title="Caption" ></p>

<p>使用属性检查器,设置左边的label文本为Gate 1A。右边的label设置为Seat 64A,之后设置它的Horizontal alignment为Right 完全的界面应该像如下这样:</p>

<p><img src="http://al1020119.github.io/images/watchOS021.png" title="Caption" ></p>

<p>恭喜,你已经完成你的第一个watch app界面的布局了,现在是时候给它填充一些真实的数据然后在模拟器上运行。</p>

<p>创建控制器</p>

<p>在项目导航中右击Watch Extensions组,选择New File,在出现的对话框中选择watchOS\Source\WatchKit Class然后点击Next。命名新的类为FlightInterfaceController,确保它为WKInterfaceController的子类,语言设置为Swift:</p>

<p><img src="http://al1020119.github.io/images/watchOS022.png" title="Caption" ></p>

<p>点击Next,之后是Create</p>

<p>可以看到新的文件在代码编辑器中打开了,删除其中的三个空方法,只剩下import语句和类定义。</p>

<p>添加这些Outlets到FlightInterfaceController的顶部:</p>

<pre><code>@IBOutlet var flightLabel: WKInterfaceLabel!
@IBOutlet var routeLabel: WKInterfaceLabel!
@IBOutlet var boardingLabel: WKInterfaceLabel!
@IBOutlet var boardTimeLabel: WKInterfaceLabel!
@IBOutlet var statusLabel: WKInterfaceLabel!
@IBOutlet var gateLabel: WKInterfaceLabel!
@IBOutlet var seatLabel: WKInterfaceLabel!
</code></pre>

<p>这里仅仅为之前的每个label添加一个Outlet。稍后会把他们连接起来。</p>

<p>下一步,在outlets下面添加flight属性和对应的属性观察器:</p>

<pre><code>// 1
var flight: Flight? {
  // 2
  didSet {
    // 3
    if let flight = flight {
      // 4
      flightLabel.setText("Flight \(flight.shortNumber)")
      routeLabel.setText(flight.route)
      boardingLabel.setText("\(flight.number) Boards")
      boardTimeLabel.setText(flight.boardsAt)
      // 5
      if flight.onSchedule {
        statusLabel.setText("On Time")
      } else {
        statusLabel.setText("Delayed")
        statusLabel.setTextColor(UIColor.redColor())
      }
      gateLabel.setText("Gate \(flight.gate)")
      seatLabel.setText("Seat \(flight.seat)")
    }
  }
}
</code></pre>

<p>会一步步讲解发生的事情:</p>

<ul>
<li><p>1.你定义了一个可选的属性类型为Flight。这个类在Flight.swift中定义;</p></li>
<li><p>2.你添加了一个属性观察器,当属性设值时候会触发它;</p></li>
<li><p>3.在可选属性中确保有一个真的flight而不是nil,当flight存在才会去设置labels的值;</p></li>
<li><p>4.使用flight的相关属性去设置labels</p></li>
<li><p>5.如果航班被延误，那么你就将标签的文本颜色改为红色</p></li>
</ul>


<p>在控制器第一次显示时候设置航班。添加以下声明：</p>

<pre><code>override func awakeWithContext(context: AnyObject?) {
  super.awakeWithContext(context)
  flight = Flight.allFlights().first!
}
</code></pre>

<p>本后面的教程会修改为在上下文中传递值给它,但现在你只需要从共享的JSON文件中加载所有的航班,然后使用数组中的第一个。</p>

<p>在后面的教程你将学到更多关于awakeWithContext（_：)的知识,但是现在你仅仅需要知道它是界面控制器生命周期第一环节,一个设置flight值的地方。 现在仅剩最后一步你就可以编译运行了,就是去连接outlets</p>

<p>连接outlets</p>

<p>打开 Watch\Interface.storyboard 选择界面控制器,使用Identity Inspector,设置Class\Custom Class为FlightInterfaceController</p>

<p>下一步,右击界面控制器顶部的黄色图片弹出窗口:</p>

<p><img src="http://al1020119.github.io/images/watchOS023.png" title="Caption" ></p>

<p>现在,按下面的列表连接outlets:</p>

<pre><code>boardingLabel: AA123 Boards
boardTimeLabel: 15:06
flightLabel: Flight 123
gateLabel: Gate 1A
routeLabel: MAN to SFO
seatLabel: Seat 64A
statusLabel: On time
</code></pre>

<p>在运行之前,有一件事情要做。本教程的实例app专为42mm的Apple Watch开发的,所以你需要确保正确设置了模拟器,否则界面元素看起来会有点小。对于一个现实app,需要确保界面能很好运行在两种大小的手表上,但这在本教程的范围之外。</p>

<p>在Xcode中,选择Window\Devices打开设备管理器,点击右下角的 + 图标.在弹出的对话框中,命名模拟器为iPhone 6 - 42mm,设置设备类型为iPhone 6,修改配对的Apple watch为Apple Watch - 42mm (WatchOS 2.0)然后点击Create:</p>

<p><img src="http://al1020119.github.io/images/watchOS024.png" title="Caption" ></p>

<p>关闭设备管理器,选择Watch Scheme,然后选中新的模拟器:</p>

<p><img src="http://al1020119.github.io/images/watchOS025.png" title="Caption" ></p>

<p>编译运行。一段模拟器启动完成你会看到下面界面:</p>

<p><img src="http://al1020119.github.io/images/watchOS026.png" title="Caption" ></p>

<blockquote><p>注意:如果收到一条错误消息,说明安装失败,然后你可以再次尝试使用Xcode,或者在手表模拟器上手动安装app。为此,打开iOS模拟器中的手表app,点击AirAber,在Apple Watch弹出我们的app。一旦这么做了,返回手表模拟器,按Shift + Ctrl + H导航到主界面, 然后点击AirAber图片来启动手表app。</p></blockquote>

<p>恭喜!你已经完成WatchKit初始界面,并使用真实的数据使它很好运行在手表模拟器上。</p>

<p>稍后会做什么?</p>

<p>下面是这个系列教程完整示例项目。</p>

<p>在这个练习中你已经学会了如何往现有的iOS app中添加手表app，如何创建一个界面控制器和使用嵌套组构造一个非常复杂的界面，以及使用WKInterfaceController类来配合这项工作。那么，接下来呢？</p>

<p>本教程系列的第二部分，你将学习所有关于表和导航WatchKit的使用。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[全屏返回（Runtime）]]></title>
    <link href="http://al1020119.github.io/blog/2015/11/06/quan-ping-fan-hui-(runtime)/"/>
    <updated>2015-11-06T02:51:33+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/11/06/quan-ping-fan-hui-(runtime)</id>
    <content type="html"><![CDATA[<blockquote><p>前言</p>

<p>此次文章，讲述的是导航控制器全屏滑动返回效果，而且代码量非常少，10行内搞定。</p></blockquote>

<p>如果喜欢我的文章，可以关注我，也可以来小码哥，了解下我们的iOS培训课程。陆续还会有更新ing&hellip;.</p>

<!--more-->


<h5>一、自定义导航控制器</h5>

<p>目的：以后需要使用全屏滑动返回功能，就使用自己定义的导航控制器。</p>

<h5>二、分析导航控制器侧滑功能</h5>

<p>效果：导航控制器默认自带了侧滑功能，当用户在界面的左边滑动的时候，就会有侧滑功能。</p>

<p>系统自带的侧滑效果：</p>

<p>分析：</p>

<ul>
<li><p>1.导航控制器的view自带了滑动手势，只不过手势的触发范围只能在左边。</p></li>
<li><p>2.当用户在界面左边拖动，就会触发滑动手势方法，并且有滑动返回功能，说明系统手势触发的方法已经实现了滑动返回功能。</p></li>
<li><p>3.为什么说系统手势触发的方法已经实现了滑动返回功能？</p></li>
</ul>


<h3>原因：</h3>

<p>创建滑动手势对象的时候，需要绑定监听者，当触发手势的时候会调用target的action。</p>

<p>UIPanGestureRecognizer *pan = [[UIPanGestureRecognizer alloc] initWithTarget:target action:action];
当用户在界面左边滑动，有滑动返回功能，这是因为触发手势了，调用target的action方法，说明action方法内部实现滑动返回功能，否则就不会有滑动返回效果。</p>

<h5>三、实现全屏滑动功能分析</h5>

<p>打印导航控制器自带的滑动手势，看下它的真实面目。</p>

<p>系统自带的滑动手势interactivePopGestureRecognizer</p>

<pre><code>//  self指向的导航控制器，在导航控制器的viewDidLoad方法打印 
- (void)viewDidLoad { 
    [super viewDidLoad]; 
    NSLog(@"%@",self.interactivePopGestureRecognizer); 
} 
</code></pre>

<p>由图中可知：</p>

<ul>
<li><p>1.系统自带的手势是UIScreenEdgePanGestureRecognizer类型对象,屏幕边缘滑动手势</p></li>
<li><p>2.系统自带手势target是_UINavigationInteractiveTransition类型的对象</p></li>
<li><p>3.target调用的action方法名叫handleNavigationTransition:</p></li>
</ul>


<p>分析：</p>

<p>UIScreenEdgePanGestureRecognizer，看名称就知道，这个手势的范围只能在屏幕的周边，就是因为这个手势，系统自带的滑动效果，只能实现侧边滑动。</p>

<h5>四、如何实现全屏滑动功能</h5>

<p>给自己的导航控制器，添加一个全屏的滑动手势，调用系统自带滑动手势的target的action方法，利用系统实现的滑动返回功能，加上自己全屏滑动手势，就有全屏滑动功能了。</p>

<p>问题：如何拿到系统自带的target对象?，action方法名已经知道，而且系统肯定在target对象实现了，只要拿到target对象，调用这个方法就行。</p>

<p>通过打印系统自带的滑动手势的代理，发现正好是_UINavigationInteractiveTransition对象，因此我猜测这个代理对象就是target对象,只要拿到它，就拿到系统自带滑动手势的target对象。</p>

<pre><code>// 打印系统自带滑动手势的代理对象 
SLog(@"%@",self.interactivePopGestureRecognizer.delegate); 
</code></pre>

<p>导航控制器全屏滑动注意点:</p>

<ul>
<li><p>1.禁止系统自带滑动手势使用。</p></li>
<li><p>2.只有导航控制器的非根控制器才需要触发手势，使用手势代理，控制手势触发。</p></li>
</ul>


<p>全屏滑动代码实现</p>

<pre><code>- (void)viewDidLoad { 
    [super viewDidLoad]; 
    // 获取系统自带滑动手势的target对象 
    id target = self.interactivePopGestureRecognizer.delegate; 
    // 创建全屏滑动手势，调用系统自带滑动手势的target的action方法 
    UIPanGestureRecognizer *pan = [[UIPanGestureRecognizer alloc] initWithTarget:target action:@selector(handleNavigationTransition:)]; 
    // 设置手势代理，拦截手势触发 
    pan.delegate = self; 
    // 给导航控制器的view添加全屏滑动手势 
    [self.view addGestureRecognizer:pan]; 
    // 禁止使用系统自带的滑动手势 
    self.interactivePopGestureRecognizer.enabled = NO; 
} 
// 什么时候调用：每次触发手势之前都会询问下代理，是否触发。 
// 作用：拦截手势触发 
- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer 
{ 
    // 注意：只有非根控制器才有滑动返回功能，根控制器没有。 
    // 判断导航控制器是否只有一个子控制器，如果只有一个子控制器，肯定是根控制器 
    if (self.childViewControllers.count == 1) { 
        // 表示用户在根控制器界面，就不需要触发滑动手势， 
        return NO; 
    } 
    return YES; 
} 
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[爬虫必备-java抓包]]></title>
    <link href="http://al1020119.github.io/blog/2015/10/20/java/"/>
    <updated>2015-10-20T12:03:23+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/10/20/java</id>
    <content type="html"><![CDATA[<p>前面我们介绍了怎么使用青花瓷和正则表达式抓包，今天就来介绍一下最后一篇：使用java抓包</p>

<p>java是大家再熟悉不过了，所以不用太担心有多难，因为里面涉及的java技术几乎为0（有点夸张），所以想想看完这篇之后你就会知道怎么使用java快速抓包，还能根据自己的喜好选择对应的方式！</p>

<p>我们开始吧！</p>

<p>前提：熟悉java语法（能看懂就行）</p>

<ul>
<li>准备阶段：从网页中获取html代码</li>
<li>实战阶段：将对应的html代码使用java语言解析出来，最后保存到plist文件</li>
</ul>


<!--more-->


<h2>一:准备阶段－－》获取html代码</h2>

<h6>1:打开你对应想要获取数据的网页，使用firefox打开（因为他有一个自带的神器叫：firebug，关于firebug这里就多说了，反正对于网页开发来说她就是神器），这里我们使用的是dota首页英雄的介绍。</h6>

<p>首先来看看我们需要的数据</p>

<p><img src="http://al1020119.github.io/images/ava001.png" title="Caption" ></p>

<h6>2:由于在网页开发中也是分模块开发的，所以一定的区域在html中对应对应的html代码模块，所以我们选取界面中一个小的模块作为练习。</h6>

<p>找到对应的模块，点击右键在firebug中查看元素</p>

<p><img src="http://al1020119.github.io/images/ava002.png" title="Caption" ></p>

<p>（确保已安装firebug，没有安装的去火狐工具栏中工具标签里面的一个附加组件搜索并下载安装就可以）</p>

<p>这个时候网页的下面就会显示对应模块的html代码，我们需要找到我们想要获取的数据对应的html模块代码，点击右键拷贝我们需要的html。</p>

<p> <img src="http://al1020119.github.io/images/ava003.png" title="Caption" ></p>

<h6>3:在界面简一个html文件将拷贝好的html代码粘贴到文件中，然后就需要哪么一丢丢的html相关知识了，就是补充html中的数据，使他成为完整的html文件</h6>

<p><img src="http://al1020119.github.io/images/ava004.png" title="Caption" ></p>

<p>这里注意一下编码方式：开发中常用的都是utf－8的格式</p>

<h2>二:实战阶段－－》抓取html（网页数据）</h2>

<p>然后我们就要正式开工了，后面才是重点，前面那都是傻瓜是的操作（后面的才做中需要有那么一丢丢的java或者android开发的基础，当然不会耶没有关系，笔者会完整的介绍流程）</p>

<h6>1:代开Eclipse</h6>

<p><img src="http://al1020119.github.io/images/ava005.png" title="Caption" ></p>

<p>新建一个java项目，并且点击项目中的src新建一个class专门用来实现数据的解析</p>

<p><img src="http://al1020119.github.io/images/ava006.png" title="Caption" ></p>

<h6>2:新建好项目之后就要用到我们的一个java的jar包，专门用来抓取网络数据的包：关于包的下载后面笔者会给出下载链接</h6>

<p><img src="http://al1020119.github.io/images/ava007.png" title="Caption" ></p>

<p>将下载好的jar包导入到java工程项目中。</p>

<p>然后我们需要将他添加到build路径（这里是一个常识，java中的jar包没有添加到build路径是不能使用的，添加之后对应的咖啡图标会变成奶瓶）</p>

<p><img src="http://al1020119.github.io/images/ava008.png" title="Caption" ></p>

<p>成功之后的显示</p>

<p><img src="http://al1020119.github.io/images/ava009.png" title="Caption" ></p>

<p>下面开始使用java正式抓取并解析html（网页）数据</p>

<p>根据下面的图片在java工程项目中书写html数据解析的代码：（注意里面的步骤）</p>

<p><img src="http://al1020119.github.io/images/ava0010.png" title="Caption" ></p>

<p>java核心代码：</p>

<pre><code>try {

　　　　　　//文件路径

　　　　　　　　String path = " /Users/icocos/Desktop/iCocos.html";



　　　　　　　　//加载网页

　　　　　　　　Document doc = Jsoup.parse(new File(path), "UTF-8");



　　　　　　　　//解析网页

　　　　　　　　Elements lis = doc.select("li");



　　　　　　　 //遍历数组

　　　　　　　　for(int i = 0; i &lt; eles.size(); i++) {

　　　　　　　　//根据i获取对应的元素

　　　　　　　　Element li = lis.get(i);



　　　　　　　　//取图片

　　　　　　　　Element img = li.select("img").get(0);

　　　　　　　　// System.out.println(img.attr("src"));



　　　　　　　　//获取图片名

　　　　　　　　String imgName = img.attr("src");



　　　　　　　 Element p = li.select("p").get(0);

　　　　　　　　String personName = p.text();



　　　　　　　　//打印数据

　　　　　　　　System.out.println(imgName + "," + personName);



　　　　　　}

　　　　　} catch {

　　　　//错误（异常）处理

　　　　e.printStackTrace();

}
</code></pre>

<p>此时点击Run运行之后，Eclipse就会根据你的代码输出对应的信息</p>

<p><img src="http://al1020119.github.io/images/ava011.png" title="Caption" ></p>

<p>但是这个时候我并不能直接使用数据所以需要在java代码中做一些相应的修改，使得输出的数据可以直接拷贝并且读到plist中，其实就是数组或者字典数据</p>

<p>我们知道在ios开发中从plist文件中读取数据时最常见的，当然你也可以使用其他方式，但是没有比这更简单了。</p>

<p>下面我给java代码做一些调整</p>

<p>1:在for循环之前输入这一行代码，实现数据拼接并且数据</p>

<pre><code>System.out.println("NSArray *apps = @[");
</code></pre>

<p>2:接着就需要在for循环结束之后输入预知对应的拼接数组结尾标志</p>

<pre><code>System.out.println("]");
</code></pre>

<p>3:在for循环内部的最后面我们需要在每次循环的时候都要使用上面的代码进行拼接并且使用逗号做相应的分割</p>

<pre><code>System.out.println("@{@\"name\":@\"" + personName + "\", @\"icon\":@\""+ imgName + "\"},");
</code></pre>

<p>最后完整的java获取并且解析html数据如下；</p>

<pre><code>public class iCocos {

public static void main (String[] args) {

　　　 try {

　　　　　　//文件路径

　　　　　　String path = " /Users/icocos/Desktop/iCocos.html";

　　　　　　//加载网页
　　　　　　Document doc = Jsoup.parse(new File(path), "UTF-8");

　　　　　　//解析网页
　　　　　　Elements lis = doc.select("li");

　　　　　　System.out.println("NSArray *apps = @[");


　　　　　　//遍历数组

　　　　　　for(int i = 0; i &lt; eles.size(); i++) {

　　　　　　//根据i获取对应的元素

　　　　　　Element li = lis.get(i);


　　　　　　//取图片

　　　　　　Element img = li.select("img").get(0);

　　　　　　// System.out.println(img.attr("src"));

　　　　　　//获取图片名

　　　　　　String imgName = img.attr("src");

　　　　　　Element p = li.select("p").get(0);

　　　　　　String personName = p.text();

　　　　　　//打印数据
　　　　　　// System.out.println(imgName + "," + personName);

　　　　　　System.out.println("@{@\"name\":@\"" + personName + "\", @\"icon\":@\""+ imgName + "\"},");
　　　　　　}
　　　　　　System.out.println("]");

　　　　} catch {

　　　　　　//错误（异常）处理
　　　　　　e.printStackTrace();

　　　　}

　　}

}
</code></pre>

<p>这个时候回打印输出下面的代码，</p>

<p><img src="http://al1020119.github.io/images/ava012.png" title="Caption" ></p>

<p>下面我们就需要在xcode中做事情了，做什么事呢，就是将输出的以NSArray开头的所有数据在Xcode中转换为plist的数据，当然你也可以不转换，做少部分的修改之后直接使用JSON解析技术去解析，但是那样不是最好的办法。</p>

<p>在Xcode中新建一个项目工程，在ViewDidLoad中粘贴拷贝过来的代码，这个时候是不是看起来非常熟悉，对了，她就是我吗开发中常用到的数组数据。</p>

<p>下面我就使用循环遍历去讲NSArray数组数据写到plist文件中。</p>

<pre><code>- (void)viewDidLoad

{

    [super viewDidLoad];



    NSArray *apps = @[

  @{@"name":@"敌法师", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/dfss.jpg"},

  @{@"name":@"火枪", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/arjj.jpg"},

  @{@"name":@"德鲁伊", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/dlyy.jpg"},

  @{@"name":@"月骑", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/yzqs.jpg"},

  @{@"name":@"变体精灵", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/btjl.jpg"},

  @{@"name":@"娜迦海妖", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/njhy.gif"},

  @{@"name":@"猴子", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/hycm.jpg"},

  @{@"name":@"白虎", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/yzjs.jpg"},

  @{@"name":@"隐形刺客", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/yxck.jpg"},

  @{@"name":@"巨魔", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/jmzj.jpg"},

  @{@"name":@"直升机", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/arzs.jpg"},

  @{@"name":@"赏金猎人", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/Naka.gif"},

  @{@"name":@"骷髅射手", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/KLSS.gif"},

  @{@"name":@"育母蜘蛛", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/YMZZ.gif"},

  @{@"name":@"血魔", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/XM.gif"},

  @{@"name":@"黑暗游侠", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/Nbrn.gif"},

  @{@"name":@"虚空假面", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/EC45.gif"},

  @{@"name":@"蛇发女妖", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/H00V.gif"},

  @{@"name":@"地卜师", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/H00I.gif"},

  @{@"name":@"地穴刺客", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/DXCK.gif"},

  @{@"name":@"蚂蚁", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/DXBZ.gif"},

  @{@"name":@"幻影刺客", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/HYCK.gif"},

  @{@"name":@"闪电幽魂", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/E002.gif"},

  @{@"name":@"影魔", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/YM01.gif"},

  @{@"name":@"小鱼人", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/yryx.gif"},

  @{@"name":@"幽鬼", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/YG1.gif"},

  @{@"name":@"圣堂刺客", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/E01Y.gif"},

  @{@"name":@"灵魂守卫", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/LHSW.gif"},

  @{@"name":@"熊战士", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/Huth.gif"},

  @{@"name":@"剧毒术士", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/JDSS.gif"},

  @{@"name":@"冥界亚龙", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/MJYL.gif"},

  @{@"name":@"复仇之魂", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/Hvwd.jpg"},

  @{@"name":@"剑圣", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/jsjs.jpg"}

  ];



    [newApps writeToFile:@"/Users/icocos/Desktop/apps.plist" atomically:YES];
</code></pre>

<p>这个时候我吗的左面就有了这个plist文件，打开之后你会看到</p>

<p><img src="http://al1020119.github.io/images/ava013.png" title="Caption" ></p>

<p>最后的步骤就是图片的下载，</p>

<pre><code>//简单写入

//    for (NSDictionary *dict in apps) {

//        NSString *icon = dict[@"icon"];

//        

//        // 新建网络图片的URL路径

//        NSURL *url = [NSURL URLWithString:icon];

//        

//        // 下载图片的二进制数据

//        NSData *data = [NSData dataWithContentsOfURL:url];

//        

//        // 截取文件名

//        NSString *filename = [icon lastPathComponent];

//        

//        // 文件路径

//        NSString *iconPath = [NSString stringWithFormat:@"/Users/icocos/Desktop/Icons/%@", filename];

//        

//        [data writeToFile:iconPath atomically:YES];

//    }
</code></pre>

<p>由于plist中图片名使用的都是对应链接的最后一个名字，所以我们不能使用上面的方法，还需要做一些处理，才能真正使用</p>

<pre><code>NSMutableArray *newApps = [NSMutableArray array];

    for (NSDictionary *dict in apps) {

        NSMutableDictionary *newDict = [NSMutableDictionary dictionary];

        newDict[@"name"] = dict[@"name"];

        newDict[@"icon"] = [dict[@"icon"] lastPathComponent];

        [newApps addObject:newDict];

    }



    [newApps writeToFile:@"/Users/icocos/Desktop/apps.plist" atomically:YES];



}
</code></pre>

<p><img src="http://al1020119.github.io/images/ava014.png" title="Caption" ></p>

<p>图片下载完成之后你会回看到对应的文件夹中快速的出现了好多的图片</p>

<p><img src="http://al1020119.github.io/images/ava015.png" title="Caption" ></p>

<p>此时我们就得到了一份和网页想相对应比较完整的plist数据，后面我们要做的就是将我们的plist数据显示到界面，后面我就不介绍了，详细请看：plist文件读取</p>

<blockquote><p>最后总结一下，如果以后遇到了关于需要抓取网络数据实现网络爬虫的功能的时候，我们基本上想到的第一种方法就是使用java语言，当然公司一般不会有这样的要求，公司一般都是使用自己服务器的api来实现，特殊情况除外。</p></blockquote>

<p>当然你也可以使用正则表达式或者Python，关于正则表达式相对来说还是比较难的，主要是细节比较多。而Python本人还没有研究过，有机会尝试一下，如果您还有什么好的方法欢迎笔者联系，相互学习与讨论。</p>

<p>我们基本上可以按照上面的思路去实现，只需要做少部分的修改，这里大致说一下</p>

<ul>
<li>1:准备阶段根据你需要的数据会有不同的html产生</li>
<li>2:产生不同的html之后你html内部的结构就会做响应的变化，这个时候你就要去把java那段核心代码搞懂来就没问题了，最重要的还是这里。</li>
<li>3:根据对应的NSArray数据写入到plist文件中，这里是iOS开发中常用的技术我就不多说。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[爬虫必备-Phthon抓包]]></title>
    <link href="http://al1020119.github.io/blog/2015/10/15/pa-chong-bi-bei-phthonzhua-bao/"/>
    <updated>2015-10-15T11:03:23+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/10/15/pa-chong-bi-bei-phthonzhua-bao</id>
    <content type="html"><![CDATA[<p>由于最近都在研究网络爬虫技术，自己也总结了一些。接住一个朋友（boyXiong）的博文，了解到了python抓包技术，所以就整理到这里，希望你能喜欢！</p>

<h4>准备搭建环境</h4>

<p>因为是MAC电脑，所以自动安装了Python 2.7的版本</p>

<p>添加一个 库 Beautiful Soup ,方法这里说两种</p>

<ul>
<li>1.在终端输入 pip install BeautifulSoup</li>
<li>2.手动下载包后，终端切换到 解压的文件夹，输入 sudo python setup.py install 下载地址BeautifulSoup</li>
</ul>


<!--more-->


<h4>开始写代码吧</h4>

<p>先找一个想要抓取东西的网站，这里我就随便找一个吧 地址是：<a href="http://movie.douban.com/chart">http://movie.douban.com/chart</a>
好了在终端输入 vim 我知道这个东西，对于新手来说，就是一个挑战，这里我也建议使用轻量的Sublime
代码如下 (注意python是严格的缩进,以下代码要顶格写)</p>

<pre><code>#-*- coding:utf-8 -*-
import urllib2
import urllib
html=urllib2.urlopen("http://movie.douban.com/chart").read()
print html
</code></pre>

<p>输出的结果就是一个HTML的网页，这里我就看到自己想要抓取的图片和图片名的文字片段</p>

<pre><code>&lt;a class="nbg" href="http://movie.douban.com/subject/24879839/"  title="道士下山"&gt;
           &lt;img src="http://img3.douban.com/view/movie_poster_cover/ipst/public/p2251450614.jpg" alt="道士下山" class=""/&gt;
&lt;/a&gt;
</code></pre>

<p>分析我们想要的，一个是图片的名称，一个是图片的链接地址，直接上Python代码
    #-<em>- coding:utf-8 -</em>-
    import urllib2
    from bs4 import BeautifulSoup</p>

<pre><code>import sys  
reload(sys)  
sys.setdefaultencoding('utf8')

# 函数
def  printPlistCode():
    #1.得到这个网页的 html 代码 #
    html = urllib2.urlopen("http://movie.douban.com/chart").read()

    #2.转换 一种格式，方便查找
    soup = BeautifulSoup(html)
    #3.  得到 找到的所有 包含 a 属性是class = nbg 的代码块,数组
    liResutl = soup.findAll('a', attrs = {"class" : "nbg"})
    #4.用于拼接每个字典的字符串
    tmpDictM = ''

    #5. 遍历这个代码块  数组
    for li in liResutl:

        #5.1 找到 img 标签的代码块 数组
        imageEntityArray = li.findAll('img')

        #5.2 得到每个image 标签
        for image in imageEntityArray:
            #5.3 得到src 这个属性的 value  后面也一样 类似 key value
            link = image.get('src')
            imageName = image.get('alt')
            #拼接 由于 py中 {} 是一种数据处理格式，类似占位符
            tmpDict = '''@{0}@\"name\" : @\"{1}\", @\"imageUrl\" : @\"{2}\"{3},'''

            tmpDict =  tmpDict.format('{',imageName,link,'}')

            tmpDictM = tmpDictM + tmpDict

    #6.去掉最后一个 , 
    tmpDictM = tmpDictM[0:len(tmpDictM) - 1].decode('utf8')

    #7 拼接全部
    restultStr = '@[{0}];'.format(tmpDictM)

    print restultStr


if __name__ == '__main__':
    printPlistCode()
</code></pre>

<p>输出结果就是Objective-C的 数组</p>

<pre><code>@[@{@"name" : @"进击的巨人真人版：前篇", @"imageUrl" : @"http://img3.douban.com/view/movie_poster_cover/ipst/public/p2251690571.jpg"},@{@"name" : @"花与爱丽丝杀人事件", @"imageUrl" : @"http://img3.douban.com/view/movie_poster_cover/ipst/public/p2222398443.jpg"},@{@"name" : @"小黄人大眼萌", @"imageUrl" : @"http://img4.douban.com/view/movie_poster_cover/ipst/public/p2258235689.jpg"},@{@"name" : @"小森林 冬春篇", @"imageUrl" : @"http://img4.douban.com/view/movie_poster_cover/ipst/public/p2215147728.jpg"},@{@"name" : @"道士下山", @"imageUrl" : @"http://img3.douban.com/view/movie_poster_cover/ipst/public/p2251450614.jpg"},@{@"name" : @"深夜食堂 电影版", @"imageUrl" : @"http://img3.douban.com/view/movie_poster_cover/ipst/public/p2205014862.jpg"},@{@"name" : @"小男孩", @"imageUrl" : @"http://img4.douban.com/view/movie_poster_cover/ipst/public/p2230105606.jpg"},@{@"name" : @"头脑特工队", @"imageUrl" : @"http://img4.douban.com/view/movie_poster_cover/ipst/public/p2231021196.jpg"},@{@"name" : @"百元之恋", @"imageUrl" : @"http://img4.douban.com/view/movie_poster_cover/ipst/public/p2205471169.jpg"},@{@"name" : @"杀破狼2", @"imageUrl" : @"http://img4.douban.com/view/movie_poster_cover/ipst/public/p2246885606.jpg"}];
</code></pre>

<p>使用Xcode 写到Plist中去</p>

<pre><code>#import &lt;Foundation/Foundation.h&gt;

int main(int argc, const char * argv[]) {


NSArray *plistArray = @[@{@"name" : @"进击的巨人真人版：前篇", @"imageUrl" : @"http://img3.douban.com/view/movie_poster_cover/ipst/public/p2251690571.jpg"},@{@"name" : @"花与爱丽丝杀人事件", @"imageUrl" : @"http://img3.douban.com/view/movie_poster_cover/ipst/public/p2222398443.jpg"},@{@"name" : @"小黄人大眼萌", @"imageUrl" : @"http://img4.douban.com/view/movie_poster_cover/ipst/public/p2258235689.jpg"},@{@"name" : @"小森林 冬春篇", @"imageUrl" : @"http://img4.douban.com/view/movie_poster_cover/ipst/public/p2215147728.jpg"},@{@"name" : @"道士下山", @"imageUrl" : @"http://img3.douban.com/view/movie_poster_cover/ipst/public/p2251450614.jpg"},@{@"name" : @"深夜食堂 电影版", @"imageUrl" : @"http://img3.douban.com/view/movie_poster_cover/ipst/public/p2205014862.jpg"},@{@"name" : @"小男孩", @"imageUrl" : @"http://img4.douban.com/view/movie_poster_cover/ipst/public/p2230105606.jpg"},@{@"name" : @"头脑特工队", @"imageUrl" : @"http://img4.douban.com/view/movie_poster_cover/ipst/public/p2231021196.jpg"},@{@"name" : @"百元之恋", @"imageUrl" : @"http://img4.douban.com/view/movie_poster_cover/ipst/public/p2205471169.jpg"},@{@"name" : @"杀破狼2", @"imageUrl" : @"http://img4.douban.com/view/movie_poster_cover/ipst/public/p2246885606.jpg"}];
//路径可以自己选择
[plistArray writeToFile:@"/Users/xxx/Desktop/test/movie.plist" atomically:YES];

return 0;
</code></pre>

<p>到这里，就可以看到plist 文件可以用于测试了</p>

<p><img src="http://al1020119.github.io/images/python001.png" title="Caption" ></p>

<p>这里写图片描述
如果想要复制粘贴这里面的代码，那就选择Sublime编辑器</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[爬虫必备-正则表达式抓包]]></title>
    <link href="http://al1020119.github.io/blog/2015/10/13/zhengze/"/>
    <updated>2015-10-13T10:03:23+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/10/13/zhengze</id>
    <content type="html"><![CDATA[<p>第一篇我们有介绍到使用青花瓷抓包，也提到了后面会介绍java和python实现，本篇就介绍一下怎么使用python抓取网络数据。</p>

<p>先来看看网络爬虫的基本原理：</p>

<p>一个通用的网络爬虫的框架如图所示：</p>

<p><img src="http://al1020119.github.io/images/zhengze001.png" title="Caption" ></p>

<!--more-->


<h5>网络爬虫的基本工作流程如下：</h5>

<ol>
<li><p>首先选取一部分精心挑选的种子URL；</p></li>
<li><p>将这些URL放入待抓取URL队列；</p></li>
<li><p>从待抓取URL队列中取出待抓取在URL，解析DNS，并且得到主机的ip，并将URL对应的网页下载下来，存储进已下载网页库中。此外，将这些URL放进已抓取URL队列。</p></li>
<li><p>分析已抓取URL队列中的URL，分析其中的其他URL，并且将URL放入待抓取URL队列，从而进入下一个循环。</p></li>
</ol>


<p>以下内容均为本人个人理解。</p>

<p>网络数据抓取</p>

<ol>
<li>概念：网络数据抓取，也叫网络爬虫。是在我们iOS程序中，获取要抓取到的网页上的数据。</li>
<li>用处：如果要用到某网站的一些数据，这个时候我们就要用到抓取数据技术。</li>
<li>建议：建议抓取过程中，多利用分类，多写一些分类方法，有助于提高程序可读性，也可提高效率。</li>
</ol>


<p>今天先来介绍一下第一种：正则表达式</p>

<blockquote><p>注意点：其实网络抓取数据很简单，但是有用到正则表达式，这个有人说难，有人说很难，有人说非常难，其实我们抓取数据只会用到“.&ldquo; 、&rdquo;*&ldquo;、&rdquo;?&ldquo;这三个符号！</p></blockquote>

<p>正则表达式中：“.”是包括任何字符不包括换行符，“*”是任意多个的字符，“？”是指到最近的一个URL，如果没有就是到最远的一个！</p>

<pre><code> NSString *pantten = [NSString stringWithFormat:@"&lt;ul class=\"cs_list\"&gt;(.*?)&lt;/ul&gt;"];

 NSRegularExpression *regx = [NSRegularExpression regularExpressionWithPattern:pantten options:NSRegularExpressionCaseInsensitive |NSRegularExpressionDotMatchesLineSeparators error:NULL];
</code></pre>

<p>其中有两个参数需要大家了解一下，很重要</p>

<ul>
<li>NSRegularExpressionCaseinsensitive 不区分大小写</li>
<li>NSRegularExpressionDotMatcheLineSeparators 让“点”字符可以匹配换行符</li>
</ul>


<p>抓数据，其实主要会写匹配字符串就行</p>

<pre><code>(.*?)表示要抓到的内容
.*?表示要忽略的内容，爱是啥是啥
字符串转义双引号用\转义括号用\\
</code></pre>

<p>在开发项目的过程，很多情况下我们需要利用互联网上的一些数据，在这种情况下，我们可能要写一个爬虫来爬我们所需要的数据。一般情况下都是利用正则表达式来匹配Html,获取我们所需要的数据。一般情况下分以下三步。</p>

<ul>
<li>1、获取网页的html</li>
<li>2、利用正则表达式，获取我们所需要的数据</li>
<li>3、分析，使用获取到的数据，（例如，保存到数据库）</li>
</ul>


<p>接下来我们分析代码：</p>

<h3>1、获取网页的html</h3>

<p>　　对于一些网页，不需要提交Post提交数据时，我们可以简单的利用NSURL类来获取我们所需要的html，交将其转换中kCFStringEncodingGB_18030_2000格式，解决中文乱码问题。</p>

<p>　　</p>

<pre><code>+(NSString*) urlstring:(NSString*)strurl{
　　　　NSURL *url = [NSURL URLWithString:strurl];
　　　　NSData *data = [NSData dataWithContentsOfURL:url];

　　　　NSStringEncoding enc = CFStringConvertEncodingToNSStringEncoding(kCFStringEncodingGB_18030_2000); 
　　　　NSString *retStr = [[NSString alloc] initWithData:data encoding:enc];

　　　　//NSLog(@" html = %@",retStr);

　　　　return retStr;
　　}
</code></pre>

<p> 对于需要Post提交数据的网页，我们可以利用强大的ASIFormDataRequest类来实现，例如：</p>

<pre><code>+(void)getPostResult:(NSString*)startqi{
　　　　ASIFormDataRequest *request = [[ASIFormDataRequest alloc] initWithURL:[NSURL URLWithString:URLPost]];

　　　　[request setPostValue:startqi forKey:@"startqi"];
　　　　[request setPostValue:@"20990101001" forKey:@"endqi"];
　　　　[request setPostValue:@"qihao" forKey:@"searchType"];//网页的中的搜索方式
　　　　[request startSynchronous];

　　　　NSData* data = [request responseData];

　　if (data==nil) {
　　　　FCLOG(@"has not data");
　　}
　　else{
　　　　NSStringEncoding enc = CFStringConvertEncodingToNSStringEncoding(kCFStringEncodingGB_18030_2000); 
　　　　NSString *retStr = [[NSString alloc] initWithData:data encoding:enc];
　　　　FCLOG(@"html = %@",retStr); 
　　}
}
</code></pre>

<p>这样的话，我们就通过了两种方式获取了我们所需要的html</p>

<h3>2、分析html</h3>

<p>　　关于利用正则表达式匹配问题，我又对NSString类扩展了一个方法-(NSMutableArray <em>)substringByRegular:(NSString </em>)regular。根据传入的正则表达式，返回所有匹配的数组。</p>

<p>　　</p>

<pre><code>@implementation NSString(StringRegular)


-(NSMutableArray *)substringByRegular:(NSString *)regular{

  　　　　　NSString * reg=regular;

　　　　　　NSRange r= [self rangeOfString:reg options:NSRegularExpressionSearch];

　　　　　　NSMutableArray *arr=[NSMutableArray array];

　　　　　　if (r.length != NSNotFound &amp;&amp;r.length != 0) {

　　　　　　int i=0;

　　　　　　while (r.length != NSNotFound &amp;&amp;r.length != 0) {

　　　　　　FCLOG(@"index = %i regIndex = %d loc = %d",(++i),r.length,r.location);

　　　　　　NSString* substr = [self substringWithRange:r];

　　　　　　FCLOG(@"substr = %@",substr);

　　　　　　[arr addObject:substr];

　　　　　　NSRange startr=NSMakeRange(r.location+r.length, [self length]-r.location-r.length);

　　　　　　r=[self rangeOfString:reg options:NSRegularExpressionSearch range:startr];
　　　　}
　　}
　　return arr;
}
@end
</code></pre>

<p>在这种情况下，我们首先我得到我们要获取数据的正则表达式，关于正则表达式这种火星文我就不多说了，我也很纠结，我就不多说了，但是有一点就是，所写的正则表达式一定是我们所需要的数据，并且能够屏蔽无效信息的，有可能在一次匹配中无法获取，可以多次利用正则表达式来分段获取。下面是我的语句，在我的例子中，就是两次利用正则表达式。</p>

<pre><code>NSString *regstr = @"&lt;td class=\'z_bg_05\'&gt;\\w{11}&lt;/td&gt;&lt;td class=\'z_bg_13\'&gt;(\\w{2}\\s{0,1})*&lt;/td&gt;";
NSMutableArray *arr=[strhtml substringByRegular:regstr];
</code></pre>

<h3>3、分析或利用数据，在这里，我只是利用上一篇博客上所述方法简单的把这些数据保存到了数据库（sqlite3）中。</h3>

<p>其实在这个arr数组中一条就是对应我数据库表中的一条记录，但是像td class等这些信息我是不需要的，所以再次利用正则表达式来分析NSString</p>

<pre><code>if (arr!=nil&amp;&amp;[arr count]&gt;0) {

　　　　　　NSString *prereg=@"\\w{11}";
　　　　　　NSString *backreg=@"(\\w{2}\\s{0,1}){8}";

　　　　　　TicketResultService *service=[[TicketResultService alloc] init];
　　　　　　[[Sqlite3Helper Instance] openDB];
　　　　for (NSString *sub in arr) {

　　　　　　TicketResult* r=[[[TicketResult alloc] init] autorelease];

　　　　　　NSMutableArray* prearr=[sub substringByRegular:prereg];

　　　　　　if (prearr!=nil&amp;&amp;[prearr count]&gt;0) {
　　　　　　　　r.sectionID=(NSString*)[prearr objectAtIndex:0];
　　　　　　}
　　　　　　else{
　　　　　　　　continue;
　　　　　　}

　　　　　　NSMutableArray *backarr=[sub substringByRegular:backreg];
　　　　　　if (backarr!=nil&amp;&amp;[backarr count]&gt;0) {
　　　　　　r.result=[backarr objectAtIndex:0];
　　　　　　}
　　　　　　else{
　　　　　　　　continue;
　　　　　　}

　　　　　　if([service isExist:r.sectionID]){
　　　　　　　　continue;
　　　　　　}

　　　　r.type=[NSNumber numberWithInt:1];

　　　　[service addModel:r];

　　}
　　[[Sqlite3Helper Instance] closeDB];

　　[service release];
}
</code></pre>

<blockquote><p>以上爬虫才算正式完成，其实，在此之前还有一个第0步，即判断设备目前的网络状态，如果没有联网的就没有必要去爬虫了，因为你也爬不到任何的数据。判断网络状态我是利用Apple官方的一个例子Reachability，网上也有很多关于这个的例子，我就不再细说了，非常感谢网上的各位大牛们提供的很好的办法，让我能更快的写出这些。</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[爬虫必备-青花瓷抓包]]></title>
    <link href="http://al1020119.github.io/blog/2015/10/11/qinghuaci/"/>
    <updated>2015-10-11T09:03:23+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/10/11/qinghuaci</id>
    <content type="html"><![CDATA[<p>在之前个人学习ios开发的时候听过抓包相关的技术，但是自己没有实现，所以也只是当听听。</p>

<p>这段时间，由于公司新项目的原因，但是后台和UI都还没有，而又需要我先开始封装对应的工具或者一下大概的逻辑，我当时就蒙了，最后还是乖乖的来做。</p>

<p>网上找了一些接口，也找了不少类似的网站，但是发现再美我用不了有什么用呢？最后我想到了之前听别人说的网络爬虫，找了不少资料研究了一番。发现效果还不错，就在这里记录下来，希望对你有用！</p>

<p>关于网络数据抓取不仅仅在iOS开发中有，其他开发中也有，也叫网络爬虫，大致分为三种方式实现</p>

<ul>
<li>1: 青花瓷</li>
<li>2: 正则表达</li>
<li>3: 利用其他语言的工具包：java／Python</li>
</ul>


<p>写本文的契机主要是前段时间有次用青花瓷抓包有一步忘了，在网上查了半天也没找到写的完整的教程，于是待问题解决后抽时间截了图，自己写一遍封存在博客园中以便以后随时查阅。</p>

<!--more-->


<p>charles又名青花瓷，在iOS开发中的抓包中具有重要作用。最大的三点用处，一就是拦截别人软件的发送的请求和后端接口，练习开发。二是自己后端返回的response拦截修改后再接收以达到测试临界数据的作用。三写脚本重复拦截抓取别人的数据。(因为不太道德，本文不提第三点)</p>

<p>如果你不是在董铂然博客园看到本文，请点击查看原文。</p>

<h3>1.开始之前的准备工作</h3>

<p>首先安装一下这个软件</p>

<p>这个相信很多人电脑里应该都安装了，没安装的搜charles破解版也能很容易搜到。如果没安装java环境，首次进入charles会提示让你安装java包得，直接给你链接是苹果官网的，去下一个一键安装就行了。</p>

<p> <img src="http://al1020119.github.io/images/qinghuaci001.jpg" title="Caption" ></p>

<p>安装完成后先打开，在进行下面操作。</p>

<p>然后去自己电脑的系统偏好设置-》网络-》选中现在连着的网(大部分人应该都是WiFi吧)可以查到自己这个电脑在现在这个wifi里的IP地址，比如我现在这个就是192.168.0.105(建议最好用私人网络，用公司网络的话可能会有限制会出现没反应的问题)</p>

<p><img src="http://al1020119.github.io/images/qinghuaci002.jpg" title="Caption" ></p>

<p>然后找到自己手机也连着这个同名的wifi，然后选中右边的蓝色i。</p>

<p> <img src="http://al1020119.github.io/images/qinghuaci003.jpg" title="Caption" ></p>

<p><img src="http://al1020119.github.io/images/qinghuaci004.jpg" title="Caption" ></p>

<p>然后进入到了这个无线局域网的高级设置页面。进去之后拉到最下方，找到HTTP代理字样。然后选中手动代理，并在服务器中填自己电脑查到的ip地址，然后把端口调8888，最后点击左上角返回。返回值后系统会自动设置代理重新连接。</p>

<p>这时候你的手机上网的过程中就要经过你的电脑了。刚用手机打开一个联网的程序，你的电脑上应该会显示一个弹窗问你【allow】还是【deny】肯定不能拒绝啊就点allow吧。这个只有第一次才弹窗，图没截上，你到时候看见肯定能看懂的。点了同意之后你手机发出的每一个请求都会被拦截出痕迹。</p>

<h3>2.拦截某个软件的接口数据</h3>

<p>拿网易新闻举例，以前就练习这写过网易新闻的项目，其中网易的接口全是用charles拦截的。拦截到了网易发请求时发的是什么，然后在练习项目中需要获取数据的地方也把这一串链接直接拿过来用即可。</p>

<p><img src="http://al1020119.github.io/images/qinghuaci005.jpg" title="Caption" ></p>

<p>当然这上面拦到的比较多，如果有过开发经验的话应该能很快看出来右边哪个是真正返回json数据的接口。或者一个一个点看内容也行啊。</p>

<p>比如选中一个url然后右键点击copy。</p>

<p><img src="http://al1020119.github.io/images/qinghuaci006.jpg" title="Caption" ></p>

<p>放到浏览器地址栏里打一下。能看到</p>

<p><img src="http://al1020119.github.io/images/qinghuaci007.jpg" title="Caption" ></p>

<p>这就说明这个接口是对的了。可以获取到数据。然后可以给他转化一下看的更清楚。虽然很多人都是用bash看，但我还是推荐一个网址<a href="http://www.w3cschool.cc/jsontool">http://www.w3cschool.cc/jsontool</a>。转JSON之后看的非常清晰。大部分软件json整理后都是默认把大括号全都打开，而仅有这个网站是默认全给你把大括号关上。想点哪个再点开，而且能知道字典里有多少个键值对，所以看着非常清晰。</p>

<p><img src="http://al1020119.github.io/images/qinghuaci008.jpg" title="Caption" ></p>

<p>到此就已经完成了一次完整的，拉取接口，和获得数据。</p>

<p>这里有两点我想说下：</p>

<p>①就是如果这个App发的请求加密了或是RSA什么的，这个就算拦截了你也弄不到数据。网易是没有做任何加密，所以可以抓取到数据。以前试了拦截百度医生的就不行。他设置的是一分钟内能获取到数据，超过了1分钟这个复制过来的接口就取不到数据了。怀疑可能是用的HMAC方法加密，并且在里面加入了时间判断。32分和33分发出的请求经过编码后是不一样的，后台可能做了容错，会把32分和31分都和你判断下，只要有一个对上就让你过，但是超过了整整一分钟后是肯定获取不到数据了。</p>

<p>②就是很多比较大型的网站，一般会开放一个开发者平台，里面注册开发者账号后会向你公开一个接口文档，你不用再去费事的拦截了。像新浪微博和大众点评都有开发者平台。</p>

<h3>3.更改返回数据来测试临界情况</h3>

<p>这个是重点了。因为这种做法可以让一个iOS前端的开发人员独立完成测试而不用拉过来一个后端一起联调。并且各种特殊维度，或是临界的账号也不用再去辛苦找了，仅仅自己在青花瓷上改来改去就可以达到效果了。比如这个地方如果返回了nil程序会不会崩，直接改response就行了。下面是具体操作方案。</p>

<p>打开青花瓷切换成结构页面</p>

<p><img src="http://al1020119.github.io/images/qinghuaci009.jpg" title="Caption" ></p>

<p>这里可以看到断点和调试信息</p>

<p><img src="http://al1020119.github.io/images/qinghuaci010.jpg" title="Caption" ><br/>
<img src="http://al1020119.github.io/images/qinghuaci011.jpg" title="Caption" ></p>

<p>然后找一个我们公司的页面。这个页面本来应该返回是这样的：如上图右边</p>

<p>你先正常的打开这个页面把玩几下，这个青花瓷就会抓取很多接口和域名分类了。在这里找到你这个页面所属的域名分类应该不难。然后打上断点。这里要注意是在域名上打断点而不是在下面的单个请求上打断点。</p>

<p>再次用手机进入这个页面，就会通过你刚才打断点的那个域名来请求数据，就会被断点拦住，如下图所示。</p>

<p><img src="http://al1020119.github.io/images/qinghuaci012.jpg" title="Caption" ></p>

<p>右边的信息也很清晰，一开始可以编辑请求。如果点击单步执行，等一下相应回来了也可以编辑响应。</p>

<p><img src="http://al1020119.github.io/images/qinghuaci013.jpg" title="Caption" ></p>

<p><img src="http://al1020119.github.io/images/qinghuaci014.jpg" title="Caption" ></p>

<p>这里的有好几种查看的方式，但是推荐使用JSON Text看的比较清楚。 现在我们对拦截回来的数据进行修改，我把这些统计数据全改成999如下图</p>

<p> <img src="http://al1020119.github.io/images/qinghuaci015.jpg" title="Caption" ></p>

<p>然后再次点击下方的Execute单步执行，更改后的数据就会像正常返回回来的数据那样显示到，APP的页面上展示。</p>

<p><img src="http://al1020119.github.io/images/qinghuaci016.jpg" title="Caption" ></p>

<p>能来到这一步就说明已经完整的掌握了用青花瓷篡改返回数据测试App的技术。</p>

<p>如果你不是在董铂然博客园看到本文，请点击查看原文。</p>

<p>这么做的意义：</p>

<p>这里只是简单的更改了一些数字，在页面显示更加直观。实际的操作中，你可以经常用来把某些值改为临界情况以看到App在处理这些临界状况时的反应，这样比找那些临界数据的测试账号成本要低得多。也可以把一些可能不会反回数值的字段找到，直接将里面的值删成nil，看看会不会报异常等等。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Metal深究]]></title>
    <link href="http://al1020119.github.io/blog/2015/10/10/metal/"/>
    <updated>2015-10-10T13:53:19+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/10/10/metal</id>
    <content type="html"><![CDATA[<p>学习使用苹果GPU加速3D绘图的新API:Metal！</p>

<p>在iOS 8里，苹果发布了一个新的接口叫做Metal，它是一个支持GPU加速3D绘图的API。</p>

<p>Metal和OpenGL ES相似，它也是一个底层API，负责和3D绘图硬件交互。它们之间的不同在于，Metal不是跨平台的。与之相反的，它设计的在苹果硬件上运行得极其高效，与OpenGL ES相比，它提供了更快的速度和更低的开销。</p>

<!--more-->


<p>在这篇教程里，你将会获得亲身的经历，使用Metal和Swift来创建一个有基本脉络的应用：画一个简单的三角形。在这个过程中，你将会学习一些Metal里最重要的类，比如devices、command queues，等等。</p>

<p>这篇教程是设计为任何人可以阅读明白，无论你是否学习过3D绘图。但是，我们会过得很快。如果你之前有过3D编程或者是OpenGL编程的经历，你会发现它非常简单，因为里面的很多概念你已经很熟悉了。</p>

<p>这篇教程假设你已经熟悉Swift了。如果你还是个Swift新手，先学习这些教程吧，苹果Swift站点、一些Swift教程。</p>

<p>注意：Metal应用不能跑在iOS模拟器上，它们需要一个设备，设备上装载着苹果A7芯片或者更新的芯片。所以要学习这篇教程，你需要一台这样的设备(iPhone 5S,iPad Air,iPad mini2)来完成代码的测试。</p>

<pre><code>Metal vs. Sprite Kit, Scene Kit, or Unity
</code></pre>

<p>在我们开始之前，我想要讨论怎样比较Metal和一些没那么底层的框架，比如：Sprite Kit，Scene Kit或者Unity。</p>

<p>Metal是一个底层3D绘图API，和OpenGL类似，但是它的开销更低。它是一个GPU上一个简单的封装，所以能够完成几乎所有事情，像 在屏幕上渲染一个精灵（sprite）或者是一个3D模型。但你要编写完成这些事情的所有代码。这样麻烦的代价是，你拥有了GPU的力量和控制。</p>

<p>没那么底层的游戏框架，像Sprite Kit、Scene Kit或者Unity都是在底层3D绘图API（像是Metal或是OpenGL ES）的基础上构建的。它们提供大部分你需要在游戏中编写的底层封装代码，比如在屏幕上渲染一个精灵(sprite)或者一个3D模型。</p>

<p>如果你所想要做的就是制作一个游戏，大多数情况下我会推荐你使用一个没那么底层的库，像Sprite Kit、Scene Kit或者Unity，因为它会让你的工作更轻松。如果你喜欢这样，我们有很多教程来帮助你学习这些框架。</p>

<p>但是，还是有两个很好的原因来学习Metal：</p>

<ul>
<li>1.使硬件达到运行效率的峰值：因为Metal非常底层，它允许你使硬件达到运行效率的峰值，对你的游戏如何运行有着完全的控制。</li>
<li>2.这是一个很好的学习经历：学习Metal教导你很多关于3D绘图编程的概念，编写你自己的游戏引擎，以及高层(higher level)游戏框架如何运作。</li>
</ul>


<p>如果以上任何一点对你来说是个好的理由，继续读下去！</p>

<h4>Metal vs OpenGL ES</h4>

<p>下面让我们来对比一下Metal和OpenGL ES的不同之处。</p>

<p>OpenGL ES被设计成跨平台的。那意味着你可以用C++OpenGL ES的代码，在大部分情况下只要作少许改动就能让它在另一个平台上运行，比如Android。</p>

<p>苹果意识到尽管OpenGL ES对跨平台的支持很赞，但是它缺少了一些苹果设计产品的基本理念：苹果把操作系统、硬件、软件整合在了一起。</p>

<p>所以苹果认真考虑了如果他们设计一套特定基于他们硬件的绘图API，会是怎样呢？它的目标是极速运行、低开销以及支持最新最好的特性。</p>

<p>于是Metal诞生了。它对比OpenGL ES，能为你的应用单位时间内提高最高10倍的绘图调用次数。这能够产生超赞的特效，就像WWDC 2014 keynote上zen花园样例。</p>

<p>让我们开始看看一些Metal代码吧！</p>

<p>开头
Xcode的iOS游戏模板有一个Metal选项，但是你不要在这里选择。这是因为我想要向你一步步展示如何编写一个Metal应用，所以你能够理解这过程中的每一步骤。</p>

<p>打开Xcode 6通过iOS\Application\Single View Application template创建一个新的项目。使用HelloMetal作为项目名称，设置开发语言为Swift，设置设备为通用设备(Universal)。点击 Next，选择一个目录，点击Create。</p>

<p>有七个步骤来设置metal：</p>

<ul>
<li>1.创建一个MTLDevice</li>
<li>2.创建一个CAMetalLayer</li>
<li>3.创建一个Vertex Buffer</li>
<li>4.创建一个Vertex Shader</li>
<li>5.创建一个Fragment Shader</li>
<li>6.创建一个Render Pipeline</li>
<li>7.创建一个Command Queue</li>
</ul>


<p>让我们一个个看它们。</p>

<h5>1)创建一个MTLDevice</h5>

<p>使用Metal你要做的第一件事就是获取一个MTLDevice的引用。</p>

<p>你可以把一个MTLDevice想象成是你和CPU的直接连接。你将通过使用MTLDevice创建所有其他你需要的Metal对象（像是command queues，buffers，textures）。</p>

<p>为了完成这点，打开ViewController.swift 并添加下面的import语句到文件最上方：</p>

<pre><code>import Metal 
</code></pre>

<p>这导入了Metal框架，所以你能够使用Metal的类（像这文件中的MTLDevice）。接着，在ViewController类中添加以下属性：</p>

<pre><code>var device: MTLDevice! = nil 
</code></pre>

<p>你将要在viewDidLoad函数内初始化这个属性，而不是在一个init函数里，所以它不得不是一个optional。既然你知道你一定会 在使用它前初始化它，你为了方便，把它标记为一个隐式不包裹的optional。最后，添加这一行到viewDidLoad函数的最后。</p>

<pre><code>device = MTLCreateSystemDefaultDevice() 
</code></pre>

<p>这个函数返回一个默认MTLDevice引用，你的代码将会用到它。</p>

<h5>2）创建一个CAMetalLayer</h5>

<p>在iOS里，你在屏幕上看见的所有东西，被一个CALayer所承载。存在不同特效的CALayer的子类，比如：渐变层(gradient layers)、形状层（shape layers）、重复层(replicator layers) 等等。</p>

<p>好的，如果你想要用Metal在屏幕上画一些东西，你需要使用一个特别的CALayer子类，CAMetalLayer。所以在你的viewcontroller中添加一个。</p>

<p>首先在这个文件的上方添加import语句。</p>

<pre><code>import QuartzCore 
</code></pre>

<p>你需要它因为CAMetalLayer是QuartzCore框架的部分，而不是Metal框架里的。</p>

<p>然后把新属性添加到类中：</p>

<pre><code>var metalLayer: CAMetalLayer! = nil 
</code></pre>

<p>这将会存储你新layer的引用。</p>

<p>最后，把这行代码添加到viewDidLoad方法最后。</p>

<pre><code> 1 metalLayer = CAMetalLayer()          // 1 
 2 
 3 metalLayer.device = device           // 2 
 4 
 5 metalLayer.pixelFormat = .BGRA8Unorm // 3 
 6 
 7 metalLayer.framebufferOnly = true    // 4 
 8 
 9 metalLayer.frame = view.layer.frame  // 5 
10 
11 view.layer.addSublayer(metalLayer)   // 6 
</code></pre>

<p>让我们一行行来看：</p>

<ul>
<li>a.你创建了一个CAMetalLayer</li>
<li>b.你必须明确layer使用的MTLDevice，你简单地设置你早前获取的device。</li>
<li>c.你把像素格式（pixel format）设置为BGRA8Unorm，它代表”8字节代表蓝色、绿色、红色和透明度，通过在0到1之间单位化的值来表示”。这次两种用在CAMetalLayer的像素格式之一，一般情况下你这样写就可以了。</li>
<li>d.苹果鼓励你设置framebufferOnly为true，来增强表现效率。除非你需要对从layer生成的纹理（textures）取 样，或者你需要在layer绘图纹理(drawable textures)激活一些计算内核，否则你不需要设置。（大部分情况下你不用设置）</li>
<li>e.你把layer的frame设置为view的frame。</li>
<li>f.你把layer作为view.layer下的子layer添加。</li>
</ul>


<h5>3）创建一个Vertex Buffer</h5>

<p>在Metal里每一个东西都是三角形。在这个应用里，你只需要画一个三角形，不过即使是极其复杂的3D形状也能被解构为一系列的三角形。</p>

<p>在Metal里，默认的坐标系是向量坐标系，这意味着默认的时候，一个2x2x1的立方体，中心点是(0,0,0.5)。</p>

<p>如果你认为z=0是平面，那么(-1,-1,0)就是左下角，(0,0,0)就是中心，(1,1,0)是右上角。在这篇教程中，你想要在这些点上画三角形：</p>

<p>让我们创建一个缓冲区。在你的类中添加下列的常量属性：</p>

<pre><code>let vertexData:[Float] = [ 
  0.0, 1.0, 0.0, 
  -1.0, -1.0, 0.0, 
  1.0, -1.0, 0.0] 
</code></pre>

<p>这在CPU创建一个浮点数数组——你需要通过把它移动到一个叫MTLBuffer的东西，来发送这些数据到GPU。</p>

<p>添加另一个新的属性：</p>

<pre><code>var vertexBuffer: MTLBuffer! = nil 
然后在 viewDidLoad 方法的最后添加以下代码：
let dataSize = vertexData.count * sizeofValue(vertexData[0]) // 1 
vertexBuffer = device.newBufferWithBytes(vertexData, length: dataSize, options: nil) // 2 
</code></pre>

<p>让我们一行行来看：</p>

<ul>
<li>a.你需要获取vertex data的字节大小。你通过把第一个元素的大小和数组元素个数相乘来得到。</li>
<li>b.你在MTLDevice上调用newBufferWithBytes(length:options:) ，在GPU创建一个新的buffer，从CPU里输送data。你传递nil来接受默认的选项。</li>
</ul>


<h5>4）创建一个Vertex Shader</h5>

<p>你之前创建的顶点将成为你接下来写的一个叫vertext shader的小程序的输入。</p>

<p>一个vertex shader 是一个在GPU上运行的小程序，它由像c++的一门语言编写，那门语言叫做Metal Shading Language。</p>

<p>一个vertex shader被每个顶点调用，它的工作是接受顶点的信息（如：位置和颜色、纹理坐标），返回一个潜在的修正位置（可能还有别的相关信息）。</p>

<p>为了把事情保持简单，你的vertex shader将会返回一个和传递位置相同的位置。</p>

<p>最简单的了解 vertex shader 的方法是，自己体验。点击File\New\File，选择iOS\Source\Metal File，然后点击Next。输入Shader.metal作为文件名上按回车，然后点击Create。</p>

<p>注意：在Metal里，你能够在一个Metal文件里包含多个shaders。你也能把你的shader 分散在多个Metal文件中。Metal会从任意Metal文件中加载你项目包含的shaders。
在Shaders.metal底部添加下列代码：</p>

<pre><code>metalLayer = CAMetalLayer()          // 1 

metalLayer.device = device           // 2 

metalLayer.pixelFormat = .BGRA8Unorm // 3 

metalLayer.framebufferOnly = true    // 4 

metalLayer.frame = view.layer.frame  // 5 

view.layer.addSublayer(metalLayer)   // 6
</code></pre>

<p>让我们一行行来看：</p>

<ul>
<li>a.所有的vertex shaders必须以关键字vertex开头。函数必须至少返回顶点的最终位置——你通过指定float4（一个元素为4个浮点数的向量）。然后你给一个名字给vetex shader，以后你将用这个名字来访问这个vertex shader。</li>
<li>b.第一个参数是一个指向一个元素为packed_float3(一个向量包含3个浮点数)的数组的指针，如：每个顶点的位置。这个 [[ &hellip; ]] 语法被用在声明那些能被用作特定额外信息的属性，像是资源位置，shader输入，内建变量。这里你把这个参数用 [[ buffer(0) ]] 标记，来指明这个参数将会被在你代码中你发送到你的vertex shader的第一块buffer data所遍历。</li>
<li>c.vertex shader会接受一个名叫vertex_id的属性的特定参数，它意味着它会被vertex数组里特定的顶点所装入。</li>
<li>d.现在你基于vertex id来检索vertex数组中对应位置的vertex并把它返回。同时你把这个向量转换为一个float4类型，最后的value设置为1.0（简单的来说，这是3D数学要求的）。</li>
</ul>


<h5>5）创建一个Fragment Shader</h5>

<p>完成我们的vertex shader后，另一个shader，它被每个在屏幕上的fragment(think pixel)调用，它就是fragment shader。</p>

<p>fragment shader通过内插(interpolating)vertex shader的输出还获得自己的输入。比如：思考在三角形两个底顶点之间的fragment：</p>

<p>fragment的输入值将会由50%的左下角顶点和50%的右下角顶点组成。</p>

<p>fragment shader的工作是给每个fragment返回最后的颜色。为了简便，你将会把每个fragment返回白色。</p>

<p>在Shader.metal的底部添加下列代码：</p>

<pre><code>1 fragment half4 basic_fragment() { // 1 
2 
3 return half4(1.0);              // 2 
4 
5 } 
</code></pre>

<p>让我们一行行来看：</p>

<ul>
<li><ol type="a">
<li>所有fragment shaders必须以fragment关键字开始。这个函数必须至少返回fragment的最终颜色——你通过指定half4（一个颜色的RGBA值）来 完成这个任务。注意，half4比float4在内存上更有效率，因为，你写入了更少的GPU内存。</li>
</ol>
</li>
<li><ol type="a">
<li>这里你返回(1,1,1,1)的颜色，也就是白色。</li>
</ol>
</li>
</ul>


<h5>6）创建一个Render Pipeline</h5>

<p>现在你已经创建了一个vertex shader和一个fragment shader，你需要组合它们（加上一些配置数据）到一个特殊的对象，它名叫render pipeline。Metal一个很酷的地方是，渲染器（shaders）是预编译的，render pipeline 配置会在你第一次设置它的时候被编译，所以所有事情都极其高效。</p>

<ol>
<li><p>首先在ViewController.swift里添加一个属性：
var pipelineState: MTLRenderPipelineState! = nil
这会对你即将要创建的render pipeline ，在它被编译后进行跟踪。</p></li>
<li><p>接着，在 viewDidLoad 方法最后添加如下代码：</p></li>
</ol>


<p>// 1</p>

<pre><code>1 let defaultLibrary = device.newDefaultLibrary() 
2 
3 let fragmentProgram = defaultLibrary.newFunctionWithName("basic_fragment") 
4 
5 let vertexProgram = defaultLibrary.newFunctionWithName("basic_vertex") 
</code></pre>

<p>// 2</p>

<pre><code>let pipelineStateDescriptor = MTLRenderPipelineDescriptor() 

pipelineStateDescriptor.vertexFunction = vertexProgram 

pipelineStateDescriptor.fragmentFunction = fragmentProgram 

pipelineStateDescriptor.colorAttachments[0].pixelFormat = .BGRA8Unorm
</code></pre>

<p>//3</p>

<pre><code>pipelineState = device.newRenderPipelineStateWithDescriptor(pipelineStateDescriptor, error: &amp;pipelineError) 

if !pipelineState { 

  println("Failed to create pipeline state, error \(pipelineError)") 

}
</code></pre>

<p>让我们分部分看这些代码：</p>

<ul>
<li>a.你可以通过调用device.newDefaultLibrary方法获得的MTLibrary对象访问到你项目中的预编译shaders。然后你能够通过名字检索每个shader。</li>
<li>b.你在这里设置你的render pipeline。它包含你想要使用的shaders、颜色附件（color attachment）的像素格式(pixel format)。（例如：你渲染到的输入缓冲区，也就是CAMetalLayer）。</li>
<li>c.最后，你把这个pipeline 配置编译到一个pipeline 状态(state)中，让它使用起来有效率。</li>
</ul>


<h5>7）创建一个Command Queue</h5>

<p>你需要做的最终的一次性设置步骤，是创建一个MTLCommandQueue。</p>

<p>把这个想象成是一个列表装载着你告诉GPU一次要执行的命令。</p>

<p>要创建一个command queue，简单地添加一个属性：</p>

<pre><code>var commandQueue: MTLCommandQueue! = nil 
</code></pre>

<p>把下面这行添加到 viewDidLoad 的最后：</p>

<pre><code>commandQueue = device.newCommandQueue() 
</code></pre>

<p>恭喜，你的预设置的代码完成了。</p>

<p>渲染三角形
现在，是时候学习每帧执行的代码，来渲染这个三角形！</p>

<p>它将在五个步骤中被完成：</p>

<ul>
<li>1.创建一个Display link。</li>
<li>2.创建一个Render Pass Descriptor</li>
<li>3.创建一个Command Buffer</li>
<li>4.创建一个Render Command Encoder</li>
<li>5.提交你Command Buffer的内容。</li>
</ul>


<p>让我们深入来看！</p>

<blockquote><p>注意：理论上这个应用实际上不需要每帧渲染，因为三角形被绘制之后不会动。但是，大部分应用会有物体的移动，所以我们会那样做。同时也为将来的教程打下基础。</p></blockquote>

<h6>1）创建一个Display Link</h6>

<p>你想要一个函数，在每次设备屏幕刷新的时候被调用，这样你就可以重绘屏幕。</p>

<p>在iOS平台上，你通过CADisplayLink 类来实现。</p>

<p>为了使用它，在类里添加一个新的属性：</p>

<pre><code> 1 var timer: CADisplayLink! = nil  
</code></pre>

<p>然后在 viewDidLoad 方法的末尾像这样初始化它：</p>

<pre><code>timer = CADisplayLink(target: self, selector: Selector("gameloop")) 

timer.addToRunLoop(NSRunLoop.mainRunLoop(), forMode: NSDefaultRunLoopMode) 
</code></pre>

<p>这会设置你的代码，让它每次刷新屏幕的时候调用一个名叫gameloop的方法。</p>

<pre><code>func render() { 

// TODO 

} 

func gameloop() { 
  autoreleasepool { 

    self.render() 

  } 

} 
</code></pre>

<p>这里 gameloop 函数简单地调用 render 函数，这时 render 函数只有一个空实现。让我们来实现它！</p>

<h6>2）创建一个Render Pass Descriptor</h6>

<p>下一步是创建一个MTLRenderPassDescriptor，它能配置什么纹理会被渲染到、什么是clear color，以及其他的配置。</p>

<p>简单地在 render 函数里添加以下行：</p>

<pre><code>var drawable = metalLayer.nextDrawable() 

let renderPassDescriptor = MTLRenderPassDescriptor() 
renderPassDescriptor.colorAttachments[0].texture = drawable.texture 

renderPassDescriptor.colorAttachments[0].loadAction = .Clear 

renderPassDescriptor.colorAttachments[0].clearColor = MTLClearColor(red: 0.0, green: 104.0/255.0, blue: 5.0/255.0, alpha: 1.0)
</code></pre>

<p>首先你在之前的metal layer上调用nextDrawable() ，它会返回你需要绘制到屏幕上的纹理(texture)。接下来，你配置你的render pass descriptor 来使用它。你设置load action为clear，也就是说在绘制之前，把纹理清空。然后你把绘制的背景颜色设置为绿色。</p>

<h6>3）创建一个Command Buffer</h6>

<p>下一步是创建一个command buffer。你可以把它想象为一系列这一帧想要执行的渲染命令。酷的是在你提交command buffer之前，没有事情会真正发生，这样给你对事物在何时发生有一个很好的控制。创建一个command buffer很简单，只要在render函数末尾加上这行代码：</p>

<pre><code> 1 let commandBuffer = commandQueue.commandBuffer()  
</code></pre>

<p>一个command buffer包含一个或多个渲染指令（render commands）。让我们下面创建一个。</p>

<h6>4）创建一个渲染命令编码器(Render Command Encoder)</h6>

<p>为了创建一个渲染命令（render command），你使用一个名叫render command encoder的对象。在render函数的最后添加以下代码：</p>

<pre><code>let renderEncoder = commandBuffer.renderCommandEncoderWithDescriptor(renderPassDescriptor) 
renderEncoder.setRenderPipelineState(pipelineState) 

renderEncoder.setVertexBuffer(vertexBuffer, offset: 0, atIndex: 0) 

renderEncoder.drawPrimitives(.Triangle, vertexStart: 0, vertexCount: 3, instanceCount: 1) 

renderEncoder.endEncoding()
</code></pre>

<p>这里你创建一个command encoder，并指定你之前创建的pipeline和顶点。最重要的部分是，调用drawPrimitives(vertexStart:vertexCount:instanceCount:)。</p>

<p>这里你你告诉GPU，让它基于vertex buffer画一系列的三角形。每个三角形由三个顶点组成，从vertex buffer 下标为0的顶点开始，总共有一个三角形。</p>

<p>当你完成后，你只要调用 endEncoding()。</p>

<h6>5）提交你的Command Buffer</h6>

<p>最后一步是提交command buffer。在render函数最后添加这些代码：</p>

<pre><code>commandBuffer.presentDrawable(drawable)
commandBuffer.commit()
</code></pre>

<p>第一行需要保证新纹理会在绘制完成后立即出现。然后你把事务(transaction)提交，把任务交给GPU。过去我们敲了不少代码，不过现在终于结束了。编译并运行这个应用：</p>

<p>我见过最赞的三角形！</p>

<blockquote><p>注意：如果你的应用崩溃了，请确定你在一台拥有A7芯片真机（iPhone 5S,iPad Air,iPad mini2 ,非模拟器）运行。</p>

<p>最后:这是我们教程最终的项目。</p></blockquote>

<pre><code>恭喜你，你学到了很多关于Metal API的知识！你现在对Metal的一些重要的概念有了了解，比如：shaders、devices、command buffers，pipeline等等。
</code></pre>

<p>我可能会写更多这系列的教程，覆盖uniforms，3D，纹理，光照，以及导入模型。如果你感到有兴趣、并想看到更多教程的话，请留下你的评论。同时，确定查看苹果一些很好的资源：</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[切换控制器]]></title>
    <link href="http://al1020119.github.io/blog/2015/09/22/qie-huan-kong-zhi-qi/"/>
    <updated>2015-09-22T02:51:10+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/09/22/qie-huan-kong-zhi-qi</id>
    <content type="html"><![CDATA[<p>从一个视图控制器切换到另一个视图控制器的几种方式</p>

<!--more-->


<h4>1,模态(modal)画面的显示方法：</h4>

<p>例如iphone通讯录管理程序中，追加新的通讯纪录时，就是使用这种模态画面
例：点击一个按钮，进入另一个界面
    - (IBAction)pressAbout:(id)sender {</p>

<pre><code>iCocosViewController *iCocos=[[[iCocosViewController alloc] initWithNibName:@"iCocosViewController" bundle:nil] autorelease];

[self presentModalViewController:aboutanimated:YES];//显示模态画面

关闭模态画面的方法：

[self dissmissModalViewControllerAnimationed:YES];
</code></pre>

<h4>2,SwitchViewController中有2个控制器的属性：BviewController,CViewController</h4>

<ul>
<li>使用方法：insertSubview: atIndex:
这种画面跳转方法并非最佳的跳转方法：</li>
<li>实际上并非真的实现了两个画面间的跳转，而是同时启动了2个画面，控制其中哪一个画面显示在前台，哪一个画面显示在后台而已。</li>
<li>这种画面跳转方式有一个很大的缺点，即当画面数量增加时，画面跳转的实现代码将月来越复杂，而且各个画面间不可避免的有相互依赖关系。</li>
</ul>


<h4>3,UITabBarController实现并列画面跳转（这里其实就是window的切花）</h4>

<pre><code>//将5个viewController实例放入TabBar的viewcontrollers属性中    

self.tabBarController.viewControllers = @[navFrist, navSecond,navThird,navFourth,navFifth];   

self.window.rootViewController = self.tabBarController;

[self.window addSubview:self.tabBarController.view];//将根控制器的视图加到应用程序主窗口
</code></pre>

<h4>4,UINavigationController实现多层画面跳转，在导航控制器中，载入有层级关系的界面</h4>

<pre><code>- (IBAction)addRightAction:(id)sender
{
    iCocosViewController *iCocos=[[[iCocosViewController alloc]initWithNibName:@"iCocosViewController" bundle:nil] autorelease];

[self.navigationController pushViewController:aiCocos animated:YES];
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[序列化&amp;反序列化深究]]></title>
    <link href="http://al1020119.github.io/blog/2015/09/20/xu-lie-hua-and-fan-xu-lie-hua-shen-jiu/"/>
    <updated>2015-09-20T09:36:37+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/09/20/xu-lie-hua-and-fan-xu-lie-hua-shen-jiu</id>
    <content type="html"><![CDATA[<blockquote><p>摘要
序列化和反序列化几乎是工程师们每天都要面对的事情，但是要精确掌握这两个概念并不容易：一方面，它们往往作为框架的一部分出现而湮没在框架之中；另一方面，它们会以其他更容易理解的概念出现，例如加密、持久化。然而，序列化和反序列化的选型却是系统设计或重构一个重要的环节，在分布式、大数据量系统设计里面更为显著。恰当的序列化协议不仅可以提高系统的通用性、强健性、安全性、优化系统性能，而且会让系统更加易于调试、便于扩展。本文从多个角度去分析和讲解“序列化和反序列化”，并对比了当前流行的几种序列化协议，期望对读者做序列化选型有所帮助。</p></blockquote>

<!--more-->


<h2>简介</h2>

<p>文章作者服务于美团推荐与个性化组，该组致力于为美团用户提供每天billion级别的高质量个性化推荐以及排序服务。从Terabyte级别的用户行为数据，到Gigabyte级别的Deal/Poi数据；从对实时性要求毫秒以内的用户实时地理位置数据，到定期后台job数据，推荐与重排序系统需要多种类型的数据服务。推荐与重排序系统客户包括各种内部服务、美团客户端、美团网站。为了提供高质量的数据服务，为了实现与上下游各系统进行良好的对接，序列化和反序列化的选型往往是我们做系统设计的一个重要考虑因素。</p>

<p>本文内容按如下方式组织：</p>

<ul>
<li>第一部分给出了序列化和反序列化的定义，以及其在通讯协议中所处的位置。</li>
<li>第二部分从使用者的角度探讨了序列化协议的一些特性。</li>
<li>第三部分描述在具体的实施过程中典型的序列化组件，并与数据库组建进行了类比。</li>
<li>第四部分分别讲解了目前常见的几种序列化协议的特性，应用场景，并对相关组件进行举例。</li>
<li>最后一部分，基于各种协议的特性，以及相关benchmark数据，给出了作者的技术选型建议。</li>
</ul>


<h4>一、定义以及相关概念</h4>

<p>互联网的产生带来了机器间通讯的需求，而互联通讯的双方需要采用约定的协议，序列化和反序列化属于通讯协议的一部分。通讯协议往往采用分层模型，不同模型每层的功能定义以及颗粒度不同，例如：TCP/IP协议是一个四层协议，而OSI模型却是七层协议模型。在OSI七层协议模型中展现层（Presentation Layer）的主要功能是把应用层的对象转换成一段连续的二进制串，或者反过来，把二进制串转换成应用层的对象&ndash;这两个功能就是序列化和反序列化。一般而言，TCP/IP协议的应用层对应与OSI七层协议模型的应用层，展示层和会话层，所以序列化协议属于TCP/IP协议应用层的一部分。本文对序列化协议的讲解主要基于OSI七层协议模型。</p>

<ul>
<li>序列化： 将数据结构或对象转换成二进制串的过程</li>
<li>反序列化：将在序列化过程中所生成的二进制串转换成数据结构或者对象的过程</li>
</ul>


<p>数据结构、对象与二进制串
不同的计算机语言中，数据结构，对象以及二进制串的表示方式并不相同。</p>

<p>数据结构和对象：对于类似Java这种完全面向对象的语言，工程师所操作的一切都是对象（Object），来自于类的实例化。在Java语言中最接近数据结构的概念，就是POJO（Plain Old Java Object）或者Javabean－－那些只有setter/getter方法的类。而在C++这种半面向对象的语言中，数据结构和struct对应，对象和class对应。</p>

<p>二进制串：序列化所生成的二进制串指的是存储在内存中的一块数据。C++语言具有内存操作符，所以二进制串的概念容易理解，例如，C++语言的字符串可以直接被传输层使用，因为其本质上就是以'\0'结尾的存储在内存中的二进制串。在Java语言里面，二进制串的概念容易和String混淆。实际上String 是Java的一等公民，是一种特殊对象（Object）。对于跨语言间的通讯，序列化后的数据当然不能是某种语言的特殊数据类型。二进制串在Java里面所指的是byte[]，byte是Java的8中原生数据类型之一（Primitive data types）。</p>

<h4>二、序列化协议特性</h4>

<p>每种序列化协议都有优点和缺点，它们在设计之初有自己独特的应用场景。在系统设计的过程中，需要考虑序列化需求的方方面面，综合对比各种序列化协议的特性，最终给出一个折衷的方案。</p>

<h6>通用性有两个层面的意义：</h6>

<ul>
<li>第一、技术层面，序列化协议是否支持跨平台、跨语言。如果不支持，在技术层面上的通用性就大大降低了。</li>
<li>第二、流行程度，序列化和反序列化需要多方参与，很少人使用的协议往往意味着昂贵的学习成本；另一方面，流行度低的协议，往往缺乏稳定而成熟的跨语言、跨平台的公共包。</li>
</ul>


<p>强健性/鲁棒性
以下两个方面的原因会导致协议不够强健：</p>

<ul>
<li>第一、成熟度不够，一个协议从制定到实施，到最后成熟往往是一个漫长的阶段。协议的强健性依赖于大量而全面的测试，对于致力于提供高质量服务的系统，采用处于测试阶段的序列化协议会带来很高的风险。</li>
<li>第二、语言/平台的不公平性。为了支持跨语言、跨平台的功能，序列化协议的制定者需要做大量的工作；但是，当所支持的语言或者平台之间存在难以调和的特性的时候，协议制定者需要做一个艰难的决定&ndash;支持更多人使用的语言/平台，亦或支持更多的语言/平台而放弃某个特性。当协议的制定者决定为某种语言或平台提供更多支持的时候，对于使用者而言，协议的强健性就被牺牲了。</li>
</ul>


<p>可调试性/可读性
序列化和反序列化的数据正确性和业务正确性的调试往往需要很长的时间，良好的调试机制会大大提高开发效率。序列化后的二进制串往往不具备人眼可读性，为了验证序列化结果的正确性，写入方不得同时撰写反序列化程序，或提供一个查询平台&ndash;这比较费时；另一方面，如果读取方未能成功实现反序列化，这将给问题查找带来了很大的挑战&ndash;难以定位是由于自身的反序列化程序的bug所导致还是由于写入方序列化后的错误数据所导致。对于跨公司间的调试，由于以下原因，问题会显得更严重：</p>

<ul>
<li>第一、支持不到位，跨公司调试在问题出现后可能得不到及时的支持，这大大延长了调试周期。</li>
<li>第二、访问限制，调试阶段的查询平台未必对外公开，这增加了读取方的验证难度。</li>
</ul>


<p>如果序列化后的数据人眼可读，这将大大提高调试效率， XML和JSON就具有人眼可读的优点。</p>

<h6>性能包括两个方面，时间复杂度和空间复杂度：</h6>

<ul>
<li>第一、空间开销（Verbosity）， 序列化需要在原有的数据上加上描述字段，以为反序列化解析之用。如果序列化过程引入的额外开销过高，可能会导致过大的网络，磁盘等各方面的压力。对于海量分布式存储系统，数据量往往以TB为单位，巨大的的额外空间开销意味着高昂的成本。</li>
<li>第二、时间开销（Complexity），复杂的序列化协议会导致较长的解析时间，这可能会使得序列化和反序列化阶段成为整个系统的瓶颈。</li>
</ul>


<p>可扩展性/兼容性
移动互联时代，业务系统需求的更新周期变得更快，新的需求不断涌现，而老的系统还是需要继续维护。如果序列化协议具有良好的可扩展性，支持自动增加新的业务字段，而不影响老的服务，这将大大提供系统的灵活度。</p>

<p>安全性/访问限制
在序列化选型的过程中，安全性的考虑往往发生在跨局域网访问的场景。当通讯发生在公司之间或者跨机房的时候，出于安全的考虑，对于跨局域网的访问往往被限制为基于HTTP/HTTPS的80和443端口。如果使用的序列化协议没有兼容而成熟的HTTP传输层框架支持，可能会导致以下三种结果之一：</p>

<ul>
<li>第一、因为访问限制而降低服务可用性。</li>
<li>第二、被迫重新实现安全协议而导致实施成本大大提高。</li>
<li>第三、开放更多的防火墙端口和协议访问，而牺牲安全性。</li>
</ul>


<h4>三、序列化和反序列化的组件</h4>

<p>典型的序列化和反序列化过程往往需要如下组件：</p>

<ul>
<li>IDL（Interface description language）文件：参与通讯的各方需要对通讯的内容需要做相关的约定（Specifications）。为了建立一个与语言和平台无关的约定，这个约定需要采用与具体开发语言、平台无关的语言来进行描述。这种语言被称为接口描述语言（IDL），采用IDL撰写的协议约定称之为IDL文件。</li>
<li>IDL Compiler：IDL文件中约定的内容为了在各语言和平台可见，需要有一个编译器，将IDL文件转换成各语言对应的动态库。</li>
<li>Stub/Skeleton Lib：负责序列化和反序列化的工作代码。Stub是一段部署在分布式系统客户端的代码，一方面接收应用层的参数，并对其序列化后通过底层协议栈发送到服务端，另一方面接收服务端序列化后的结果数据，反序列化后交给客户端应用层；Skeleton部署在服务端，其功能与Stub相反，从传输层接收序列化参数，反序列化后交给服务端应用层，并将应用层的执行结果序列化后最终传送给客户端Stub。</li>
<li>Client/Server：指的是应用层程序代码，他们面对的是IDL所生存的特定语言的class或struct。
底层协议栈和互联网：序列化之后的数据通过底层的传输层、网络层、链路层以及物理层协议转换成数字信号在互联网中传递。
序列化组件</li>
</ul>


<p>序列化组件与数据库访问组件的对比
数据库访问对于很多工程师来说相对熟悉，所用到的组件也相对容易理解。下表类比了序列化过程中用到的部分组件和数据库访问组件的对应关系，以便于大家更好的把握序列化相关组件的概念。</p>

<table>
<thead>
<tr>
<th> 序列化组件         </th>
<th style="text-align:center;"> 数据库组件          </th>
<th style="text-align:right;"> 说明  </th>
</tr>
</thead>
<tbody>
<tr>
<td> IDL           </td>
<td style="text-align:center;">   DDL              </td>
<td style="text-align:right;"> 用于建表或者模型的语言</td>
</tr>
<tr>
<td> DL            </td>
<td style="text-align:center;"> file DB Schema    </td>
<td style="text-align:right;"> 表创建文件或模型文件</td>
</tr>
<tr>
<td> Stub/Skeleton </td>
<td style="text-align:center;">  lib  O/R mapping </td>
<td style="text-align:right;">   将class和Table或者数据模型进行映射</td>
</tr>
</tbody>
</table>


<h4>四、几种常见的序列化和反序列化协议</h4>

<p>互联网早期的序列化协议主要有COM和CORBA。</p>

<p>COM主要用于Windows平台，并没有真正实现跨平台，另外COM的序列化的原理利用了编译器中虚表，使得其学习成本巨大（想一下这个场景， 工程师需要是简单的序列化协议，但却要先掌握语言编译器）。由于序列化的数据与编译器紧耦合，扩展属性非常麻烦。</p>

<p>CORBA是早期比较好的实现了跨平台，跨语言的序列化协议。COBRA的主要问题是参与方过多带来的版本过多，版本之间兼容性较差，以及使用复杂晦涩。这些政治经济，技术实现以及早期设计不成熟的问题，最终导致COBRA的渐渐消亡。J2SE 1.3之后的版本提供了基于CORBA协议的RMI-IIOP技术，这使得Java开发者可以采用纯粹的Java语言进行CORBA的开发。</p>

<p>这里主要介绍和对比几种当下比较流行的序列化协议，包括XML、JSON、Protobuf、Thrift和Avro。</p>

<p>一个例子
如前所述，序列化和反序列化的出现往往晦涩而隐蔽，与其他概念之间往往相互包容。为了更好了让大家理解序列化和反序列化的相关概念在每种协议里面的具体实现，我们将一个例子穿插在各种序列化协议讲解中。在该例子中，我们希望将一个用户信息在多个系统里面进行传递；在应用层，如果采用Java语言，所面对的类对象如下所示：</p>

<pre><code>class Address
{
    private String city;
    private String postcode;
    private String street;
}
public class UserInfo
{
    private Integer userid;
    private String name;
    private List&lt;Address&gt; address;
}
</code></pre>

<h6>XML&amp;SOAP</h6>

<ul>
<li><p>XML是一种常用的序列化和反序列化协议，具有跨机器，跨语言等优点。 XML历史悠久，其1.0版本早在1998年就形成标准，并被广泛使用至今。XML的最初产生目标是对互联网文档（Document）进行标记，所以它的设计理念中就包含了对于人和机器都具备可读性。 但是，当这种标记文档的设计被用来序列化对象的时候，就显得冗长而复杂（Verbose and Complex）。 XML本质上是一种描述语言，并且具有自我描述（Self-describing）的属性，所以XML自身就被用于XML序列化的IDL。 标准的XML描述格式有两种：DTD（Document Type Definition）和XSD（XML Schema Definition）。作为一种人眼可读（Human-readable）的描述语言，XML被广泛使用在配置文件中，例如O/R mapping、 Spring Bean Configuration File 等。</p></li>
<li><p>SOAP（Simple Object Access protocol） 是一种被广泛应用的，基于XML为序列化和反序列化协议的结构化消息传递协议。SOAP在互联网影响如此大，以至于我们给基于SOAP的解决方案一个特定的名称&ndash;Web service。SOAP虽然可以支持多种传输层协议，不过SOAP最常见的使用方式还是XML+HTTP。SOAP协议的主要接口描述语言（IDL）是WSDL（Web Service Description Language）。SOAP具有安全、可扩展、跨语言、跨平台并支持多种传输层协议。如果不考虑跨平台和跨语言的需求，XML的在某些语言里面具有非常简单易用的序列化使用方法，无需IDL文件和第三方编译器， 例如Java＋XStream。</p></li>
</ul>


<p>自我描述与递归
SOAP是一种采用XML进行序列化和反序列化的协议，它的IDL是WSDL. 而WSDL的描述文件是XSD，而XSD自身是一种XML文件。 这里产生了一种有趣的在数学上称之为“递归”的问题，这种现象往往发生在一些具有自我属性（Self-description）的事物上。</p>

<p>IDL文件举例
采用WSDL描述上述用户基本信息的例子如下：</p>

<pre><code>&lt;xsd:complexType name='Address'&gt;
     &lt;xsd:attribute name='city' type='xsd:string' /&gt;
     &lt;xsd:attribute name='postcode' type='xsd:string' /&gt;
     &lt;xsd:attribute name='street' type='xsd:string' /&gt;
&lt;/xsd:complexType&gt;
&lt;xsd:complexType name='UserInfo'&gt;
     &lt;xsd:sequence&gt;
     &lt;xsd:element name='address' type='tns:Address'/&gt;
     &lt;xsd:element name='address1' type='tns:Address'/&gt; 
     &lt;/xsd:sequence&gt;
     &lt;xsd:attribute name='userid' type='xsd:int' /&gt;
     &lt;xsd:attribute name='name' type='xsd:string' /&gt; 
&lt;/xsd:complexType&gt;
</code></pre>

<p>典型应用场景和非应用场景
SOAP协议具有广泛的群众基础，基于HTTP的传输协议使得其在穿越防火墙时具有良好安全特性，XML所具有的人眼可读（Human-readable）特性使得其具有出众的可调试性，互联网带宽的日益剧增也大大弥补了其空间开销大（Verbose）的缺点。对于在公司之间传输数据量相对小或者实时性要求相对低（例如秒级别）的服务是一个好的选择。</p>

<p>由于XML的额外空间开销大，序列化之后的数据量剧增，对于数据量巨大序列持久化应用常景，这意味着巨大的内存和磁盘开销，不太适合XML。另外，XML的序列化和反序列化的空间和时间开销都比较大，对于对性能要求在ms级别的服务，不推荐使用。WSDL虽然具备了描述对象的能力，SOAP的S代表的也是simple，但是SOAP的使用绝对不简单。对于习惯于面向对象编程的用户，WSDL文件不直观。</p>

<p>JSON（Javascript Object Notation）
JSON起源于弱类型语言Javascript， 它的产生来自于一种称之为"Associative array"的概念，其本质是就是采用"Attribute－value"的方式来描述对象。实际上在Javascript和PHP等弱类型语言中，类的描述方式就是Associative array。JSON的如下优点，使得它快速成为最广泛使用的序列化协议之一：</p>

<ul>
<li>1、这种Associative array格式非常符合工程师对对象的理解。</li>
<li>2、它保持了XML的人眼可读（Human-readable）的优点。</li>
<li>3、相对于XML而言，序列化后的数据更加简洁。 来自于的以下链接的研究表明：XML所产生序列化之后文件的大小接近JSON的两倍。<a href="http://www.codeproject.com/Articles/604720/JSON-vs-XML-Some-hard-numbers-about-verbosity">http://www.codeproject.com/Articles/604720/JSON-vs-XML-Some-hard-numbers-about-verbosity</a></li>
<li>4、它具备Javascript的先天性支持，所以被广泛应用于Web browser的应用常景中，是Ajax的事实标准协议。</li>
<li>5、与XML相比，其协议比较简单，解析速度比较快。</li>
<li>6、松散的Associative array使得其具有良好的可扩展性和兼容性。</li>
</ul>


<p>IDL悖论
JSON实在是太简单了，或者说太像各种语言里面的类了，所以采用JSON进行序列化不需要IDL。这实在是太神奇了，存在一种天然的序列化协议，自身就实现了跨语言和跨平台。然而事实没有那么神奇，之所以产生这种假象，来自于两个原因：</p>

<h6>第一</h6>

<p>Associative array在弱类型语言里面就是类的概念，在PHP和Javascript里面Associative array就是其class的实际实现方式，所以在这些弱类型语言里面，JSON得到了非常良好的支持。</p>

<h6>第二</h6>

<p>IDL的目的是撰写IDL文件，而IDL文件被IDL Compiler编译后能够产生一些代码（Stub/Skeleton），而这些代码是真正负责相应的序列化和反序列化工作的组件。 但是由于Associative array和一般语言里面的class太像了，他们之间形成了一一对应关系，这就使得我们可以采用一套标准的代码进行相应的转化。对于自身支持Associative array的弱类型语言，语言自身就具备操作JSON序列化后的数据的能力；对于Java这强类型语言，可以采用反射的方式统一解决，例如Google提供的Gson。</p>

<p>典型应用场景和非应用场景
JSON在很多应用场景中可以替代XML，更简洁并且解析速度更快。典型应用场景包括：</p>

<ul>
<li>1、公司之间传输数据量相对小，实时性要求相对低（例如秒级别）的服务。</li>
<li>2、基于Web browser的Ajax请求。</li>
<li>3、由于JSON具有非常强的前后兼容性，对于接口经常发生变化，并对可调式性要求高的场景，例如Mobile app与服务端的通讯。</li>
<li>4、由于JSON的典型应用场景是JSON＋HTTP，适合跨防火墙访问。</li>
</ul>


<p>总的来说，采用JSON进行序列化的额外空间开销比较大，对于大数据量服务或持久化，这意味着巨大的内存和磁盘开销，这种场景不适合。没有统一可用的IDL降低了对参与方的约束，实际操作中往往只能采用文档方式来进行约定，这可能会给调试带来一些不便，延长开发周期。 由于JSON在一些语言中的序列化和反序列化需要采用反射机制，所以在性能要求为ms级别，不建议使用。</p>

<p>IDL文件举例
以下是UserInfo序列化之后的一个例子：</p>

<pre><code>{"userid":1,"name":"messi","address":[{"city":"北京","postcode":"1000000","street":"wangjingdonglu"}]}
</code></pre>

<p>Thrift
Thrift是Facebook开源提供的一个高性能，轻量级RPC服务框架，其产生正是为了满足当前大数据量、分布式、跨语言、跨平台数据通讯的需求。 但是，Thrift并不仅仅是序列化协议，而是一个RPC框架。相对于JSON和XML而言，Thrift在空间开销和解析性能上有了比较大的提升，对于对性能要求比较高的分布式系统，它是一个优秀的RPC解决方案；但是由于Thrift的序列化被嵌入到Thrift框架里面，Thrift框架本身并没有透出序列化和反序列化接口，这导致其很难和其他传输层协议共同使用（例如HTTP）。</p>

<p>典型应用场景和非应用场景
对于需求为高性能，分布式的RPC服务，Thrift是一个优秀的解决方案。它支持众多语言和丰富的数据类型，并对于数据字段的增删具有较强的兼容性。所以非常适用于作为公司内部的面向服务构建（SOA）的标准RPC框架。</p>

<p>不过Thrift的文档相对比较缺乏，目前使用的群众基础相对较少。另外由于其Server是基于自身的Socket服务，所以在跨防火墙访问时，安全是一个顾虑，所以在公司间进行通讯时需要谨慎。 另外Thrift序列化之后的数据是Binary数组，不具有可读性，调试代码时相对困难。最后，由于Thrift的序列化和框架紧耦合，无法支持向持久层直接读写数据，所以不适合做数据持久化序列化协议。</p>

<p>IDL文件举例</p>

<pre><code>struct Address
{ 
    1: required string city;
    2: optional string postcode;
    3: optional string street;
} 
struct UserInfo
{ 
    1: required string userid;
    2: required i32 name;
    3: optional list&lt;Address&gt; address;
}
</code></pre>

<p>Protobuf
Protobuf具备了优秀的序列化协议的所需的众多典型特征：</p>

<ul>
<li>1、标准的IDL和IDL编译器，这使得其对工程师非常友好。</li>
<li>2、序列化数据非常简洁，紧凑，与XML相比，其序列化之后的数据量约为1/3到1/10。</li>
<li>3、解析速度非常快，比对应的XML快约20-100倍。</li>
<li>4、提供了非常友好的动态库，使用非常简介，反序列化只需要一行代码。</li>
</ul>


<p>Protobuf是一个纯粹的展示层协议，可以和各种传输层协议一起使用；Protobuf的文档也非常完善。 但是由于Protobuf产生于Google，所以目前其仅仅支持Java、C++、Python三种语言。另外Protobuf支持的数据类型相对较少，不支持常量类型。由于其设计的理念是纯粹的展现层协议（Presentation Layer），目前并没有一个专门支持Protobuf的RPC框架。</p>

<p>典型应用场景和非应用场景
Protobuf具有广泛的用户基础，空间开销小以及高解析性能是其亮点，非常适合于公司内部的对性能要求高的RPC调用。由于Protobuf提供了标准的IDL以及对应的编译器，其IDL文件是参与各方的非常强的业务约束，另外，Protobuf与传输层无关，采用HTTP具有良好的跨防火墙的访问属性，所以Protobuf也适用于公司间对性能要求比较高的场景。由于其解析性能高，序列化后数据量相对少，非常适合应用层对象的持久化场景。</p>

<p>它的主要问题在于其所支持的语言相对较少，另外由于没有绑定的标准底层传输层协议，在公司间进行传输层协议的调试工作相对麻烦。</p>

<p>IDL文件举例</p>

<pre><code>message Address
{
    required string city=1;
        optional string postcode=2;
        optional string street=3;
}
message UserInfo
{
    required string userid=1;
    required string name=2;
    repeated Address address=3;
}
</code></pre>

<p>Avro</p>

<pre><code>Avro的产生解决了JSON的冗长和没有IDL的问题，Avro属于Apache Hadoop的一个子项目。 Avro提供两种序列化格式：JSON格式或者Binary格式。Binary格式在空间开销和解析性能方面可以和Protobuf媲美，JSON格式方便测试阶段的调试。 Avro支持的数据类型非常丰富，包括C++语言里面的union类型。Avro支持JSON格式的IDL和类似于Thrift和Protobuf的IDL（实验阶段），这两者之间可以互转。Schema可以在传输数据的同时发送，加上JSON的自我描述属性，这使得Avro非常适合动态类型语言。 Avro在做文件持久化的时候，一般会和Schema一起存储，所以Avro序列化文件自身具有自我描述属性，所以非常适合于做Hive、Pig和MapReduce的持久化数据格式。对于不同版本的Schema，在进行RPC调用的时候，服务端和客户端可以在握手阶段对Schema进行互相确认，大大提高了最终的数据解析速度。
</code></pre>

<p>典型应用场景和非应用场景
Avro解析性能高并且序列化之后的数据非常简洁，比较适合于高性能的序列化服务。</p>

<p>由于Avro目前非JSON格式的IDL处于实验阶段，而JSON格式的IDL对于习惯于静态类型语言的工程师来说不直观。</p>

<p>IDL文件举例</p>

<pre><code>protocol Userservice {
  record Address {
   string city;
   string postcode;
   string street;
  }  
  record UserInfo {
   string name;
   int userid;
   array&lt;Address&gt; address = [];
  }
}
</code></pre>

<p>所对应的JSON Schema格式如下：</p>

<pre><code>{
  "protocol" : "Userservice",
  "namespace" : "org.apache.avro.ipc.specific",
  "version" : "1.0.5",
  "types" : [ {
    "type" : "record",
    "name" : "Address",
    "fields" : [ {
      "name" : "city",
      "type" : "string"
    }, {
      "name" : "postcode",
      "type" : "string"
    }, {
      "name" : "street",
      "type" : "string"
    } ]
  }, {
    "type" : "record",
    "name" : "UserInfo",
    "fields" : [ {
      "name" : "name",
      "type" : "string"
    }, {
      "name" : "userid",
      "type" : "int"
    }, {
      "name" : "address",
      "type" : {
        "type" : "array",
        "items" : "Address"
      },
      "default" : [ ]
    } ]
  } ],
  "messages" : { }
}
</code></pre>

<h4>五、Benchmark以及选型建议</h4>

<p>Benchmark
以下数据来自<a href="https://code.google.com/p/thrift-protobuf-compare/wiki/Benchmarking">https://code.google.com/p/thrift-protobuf-compare/wiki/Benchmarking</a></p>

<ul>
<li>解析性能</li>
<li>序列化之空间开销</li>
<li>序列化大小</li>
</ul>


<p>从上图可得出如下结论：</p>

<ul>
<li>1、XML序列化（Xstream）无论在性能和简洁性上比较差。</li>
<li>2、Thrift与Protobuf相比在时空开销方面都有一定的劣势。</li>
<li>3、Protobuf和Avro在两方面表现都非常优越。</li>
</ul>


<p>选型建议</p>

<pre><code>以上描述的五种序列化和反序列化协议都各自具有相应的特点，适用于不同的场景：
1、对于公司间的系统调用，如果性能要求在100ms以上的服务，基于XML的SOAP协议是一个值得考虑的方案。
2、基于Web browser的Ajax，以及Mobile app与服务端之间的通讯，JSON协议是首选。对于性能要求不太高，或者以动态类型语言为主，或者传输数据载荷很小的的运用场景，JSON也是非常不错的选择。
3、对于调试环境比较恶劣的场景，采用JSON或XML能够极大的提高调试效率，降低系统开发成本。
4、当对性能和简洁性有极高要求的场景，Protobuf，Thrift，Avro之间具有一定的竞争关系。
5、对于T级别的数据的持久化应用场景，Protobuf和Avro是首要选择。如果持久化后的数据存储在Hadoop子项目里，Avro会是更好的选择。
6、由于Avro的设计理念偏向于动态类型语言，对于动态语言为主的应用场景，Avro是更好的选择。
7、对于持久层非Hadoop项目，以静态类型语言为主的应用场景，Protobuf会更符合静态类型语言工程师的开发习惯。
8、如果需要提供一个完整的RPC解决方案，Thrift是一个好的选择。
9、如果序列化之后需要支持不同的传输层协议，或者需要跨防火墙访问的高性能场景，Protobuf可以优先考虑。
</code></pre>

<!--more-->

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[够逼格的注释习惯]]></title>
    <link href="http://al1020119.github.io/blog/2015/09/13/you-xiu-cheng-xu-yuan-shi-zen-yao-xie-zhu-shi-de/"/>
    <updated>2015-09-13T02:59:30+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/09/13/you-xiu-cheng-xu-yuan-shi-zen-yao-xie-zhu-shi-de</id>
    <content type="html"><![CDATA[<p>够逼格的注释习惯总结</p>

<p>首先关于注意这里就不说什么VVDocument了，来点新鲜的！</p>

<h6>也许你使用过#warning 警告提示</h6>

<h6>也许你也使用过#pragma marks。</h6>

<p>但是你见过或者使用过下面这个吗？</p>

<pre><code>Comments containing:
MARK:
TODO:
FIXME:
!!!:
???:
</code></pre>

<p>没有，那么你就快速的看看下面的内容，非常好用，也非常简单，不过具体使用看个人</p>

<!--more-->


<p> 首先说一下三个最常用的：</p>

<ul>
<li>1、TODO</li>
</ul>


<p> 等待实现的功能</p>

<ul>
<li>2、FIXME</li>
</ul>


<p> 需要修正的功能</p>

<ul>
<li>3、！！！</li>
</ul>


<p> 需要改进的功能</p>

<p>具体使用</p>

<pre><code>// FIXME:sss
/* FIXME: sss */


// MARK:sss
/* MARK:sss */


// !!!:sss
/* !!!: sss */


// ???:sss
/* ???: sss */


// TODO:sss
/* TODO: sss */


// Comments containing: sss
/* Comments containing: sss */
</code></pre>

<p>注意空格.</p>

<p> 最后你会发现下面的效果，虽然和#pragma marks没有什么区别，但是这就是装逼原因</p>

<p>关于最后一个/<em> Comments containing: sss </em>/，笔者还没照发对应的使用方法，如果你知道可以联系我哦！</p>

<!--more-->

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Block深究]]></title>
    <link href="http://al1020119.github.io/blog/2015/09/06/blockshen-jiu/"/>
    <updated>2015-09-06T17:43:24+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/09/06/blockshen-jiu</id>
    <content type="html"><![CDATA[<h2>目录</h2>

<ul>
<li><h5>什么是block？</h5>

<ul>
<li>block编译转换结构</li>
<li>block实际结构</li>
</ul>
</li>
<li><h5>block的类型</h5>

<ul>
<li>NSConcreteGlobalBlock和NSConcreteStackBlock</li>
<li>NSConcreteMallocBlock</li>
</ul>
</li>
<li><h5>捕捉变量对block结构的影响</h5>

<ul>
<li>局部变量</li>
<li>全局变量</li>
<li>局部静态变量</li>
<li>__block修饰的变量</li>
<li>self隐式循环引用</li>
</ul>
</li>
<li><h5>不同类型block的复制</h5>

<ul>
<li>栈block</li>
<li>堆block</li>
<li>全局block</li>
</ul>
</li>
<li><h5>block辅助函数</h5>

<ul>
<li>__block修饰的基本类型的辅助函数</li>
<li>对象的辅助函数</li>
</ul>
</li>
<li><h5>ARC中block的工作</h5>

<ul>
<li>block试验</li>
<li>block作为参数传递</li>
<li>block作为返回值</li>
<li>block属性</li>
</ul>
</li>
</ul>


<!--more-->


<h3>参考博文</h3>

<p>最近看了一些block的资料，并动手做了一些实践，摘录并添加了一些结论。</p>

<h3>什么是block？</h3>

<p>首先，看一个极简的block：</p>

<pre><code>    int main(int argc, const char * argv[]) {
        @autoreleasepool {

            ^{ };
        }
        return 0;
    }
</code></pre>

<h5>block编译转换结构</h5>

<p>对其执行clang -rewrite-objc编译转换成C++实现，得到以下代码：</p>

<pre><code>    struct __block_impl {
        void *isa;
        int Flags;
        int Reserved;
        void *FuncPtr;
    };

    struct __main_block_impl_0 {
      struct __block_impl impl;
      struct __main_block_desc_0* Desc;
      __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) {
        impl.isa = &amp;_NSConcreteStackBlock;
        impl.Flags = flags;
        impl.FuncPtr = fp;
        Desc = desc;
      }
    };
    static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
    }

    static struct __main_block_desc_0 {
      size_t reserved;
      size_t Block_size;
    } __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};
    int main(int argc, const char * argv[]) {
        /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool;
            (void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA);
        }
        return 0;
    }
</code></pre>

<p>不难看出其中的<strong>main_block_impl_0就是block的一个C++的实现(最后面的_0代表是main中的第几个block)，也就是说也是一个结构体。
其中</strong>block_impl的定义如下：</p>

<pre><code>struct __block_impl {
  void *isa;
  int Flags;
  int Reserved;
  void *FuncPtr;
};
</code></pre>

<p>其结构体成员如下：</p>

<ul>
<li>isa，指向所属类的指针，也就是block的类型</li>
<li>flags，标志变量，在实现block的内部操作时会用到</li>
<li>Reserved，保留变量</li>
<li>FuncPtr，block执行时调用的函数指针</li>
<li>可以看出，它包含了isa指针（包含isa指针的皆为对象），也就是说block也是一个对象* (runtime里面，对象和类都是用结构体表示)。</li>
</ul>


<p>__main_block_desc_0的定义如下：</p>

<pre><code>    static struct __main_block_desc_0 {
      size_t reserved;
      size_t Block_size;
    } __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};
</code></pre>

<p>其结构成员含义如下：</p>

<ul>
<li>reserved：保留字段</li>
<li>Block_size：block大小(sizeof(struct __main_block_impl_0))</li>
<li>以上代码在定义<strong>main_block_desc_0结构体时，同时创建了</strong>main_block_desc_0_DATA，并给它赋值，以供在main函数中对__main_block_impl_0进行初始化。</li>
</ul>


<p>__main_block_impl_0定义了显式的构造函数，其函数体如下：</p>

<pre><code>  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) {
    impl.isa = &amp;_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
</code></pre>

<p>可以看出，</p>

<ul>
<li><em>_main_block_impl_0的isa指针指向了</em>NSConcreteStackBlock，</li>
<li>从main函数中看， <strong>main_block_impl_0的FuncPtr指向了函数</strong>main_block_func_0</li>
<li><strong>main_block_impl_0的Desc也指向了定义</strong>main_block_desc_0时就创建的__main_block_desc_0_DATA，其中纪录了block结构体大小等信息。</li>
<li>以上就是根据编译转换的结果，对一个简单block的解析，后面会将block操作不同类型的外部变量，对block结构的影响进行相应的说明。</li>
</ul>


<h5>block实际结构</h5>

<p>接下来观察下Block_private.h文件中对block的相关结构体的真实定义：</p>

<pre><code>/* Revised new layout. */
struct Block_descriptor {
    unsigned long int reserved;
    unsigned long int size;
    void (*copy)(void *dst, void *src);
    void (*dispose)(void *);
};


struct Block_layout {
    void *isa;
    int flags;
    int reserved;
    void (*invoke)(void *, ...);
    struct Block_descriptor *descriptor;
    /* Imported variables. */
};
</code></pre>

<p>有了上文对编译转换的分析，这里只针对略微不同的成员进行分析：</p>

<p>invoke，同上文的FuncPtr，block执行时调用的函数指针，block定义时内部的执行代码都在这个函数中
Block_descriptor，block的详细描述</p>

<ul>
<li>copy/dispose，辅助拷贝/销毁函数，处理block范围外的变量时使用</li>
<li>总体来说，block就是一个里面存储了指向函数体中包含定义block时的代码块的函数指针，以及block外部上下文变量等信息的结构体。</li>
</ul>


<h3>block的类型</h3>

<p>block的常见类型有3种：</p>

<ul>
<li>_NSConcreteGlobalBlock（全局）</li>
<li>_NSConcreteStackBlock（栈）</li>
<li>_NSConcreteMallocBlock（堆）</li>
</ul>


<p>附上APUE的进程虚拟内存段分布图：</p>

<p><img src="http://al1020119.github.io/images/block001.png" title="Caption" ></p>

<p>进程虚拟内存空间分布</p>

<ul>
<li>其中前2种在Block.h种声明，后1种在Block_private.h中声明，所以最后1种基本不会在源码中出现。</li>
<li>由于无法直接创建_NSConcreteMallocBlock类型的block，所以这里只对前面2种进行手动创建分析，最后1种通过源代码分析。</li>
</ul>


<h5>NSConcreteGlobalBlock和NSConcreteStackBlock</h5>

<p>首先，根据前面两种类型，编写以下代码：</p>

<pre><code>void (^globalBlock)() = ^{

};

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        void (^stackBlock1)() = ^{

        };
    }
    return 0;
}
</code></pre>

<p>对其进行编译转换后得到以下缩略代码：</p>

<pre><code>// globalBlock
struct __globalBlock_block_impl_0 {
  struct __block_impl impl;
  struct __globalBlock_block_desc_0* Desc;
  __globalBlock_block_impl_0(void *fp, struct __globalBlock_block_desc_0 *desc, int flags=0) {
    impl.isa = &amp;_NSConcreteGlobalBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};
...

// stackBlock
struct __main_block_impl_0 {
  struct __block_impl impl;
  struct __main_block_desc_0* Desc;
  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) {
    impl.isa = &amp;_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};
...
int main(int argc, const char * argv[]) {
    /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool;
        void (*stackBlock)() = (void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA);
    }
    return 0;
}
</code></pre>

<p>可以看出globalBlock的isa指向了<em>NSConcreteGlobalBlock，即在全局区域创建，编译时具体的代码就已经确定在上图中的代码段中了，block变量存储在全局数据存储区；stackBlock的isa指向了</em>NSConcreteStackBlock，即在栈区创建。</p>

<h5>NSConcreteMallocBlock</h5>

<ul>
<li><p>接下来是在堆中的block，堆中的block无法直接创建，其需要由<em>NSConcreteStackBlock类型的block拷贝而来(也就是说block需要执行copy之后才能存放到堆中)。由于block的拷贝最终都会调用</em>Block_copy_internal函数，所以观察这个函数就可以知道堆中block是如何被创建的了：</p>

<pre><code>  static void *_Block_copy_internal(const void *arg, const int flags) {
      struct Block_layout *aBlock;
      ...
      aBlock = (struct Block_layout *)arg;
      ...
      // Its a stack block.  Make a copy.
      if (!isGC) {
          // 申请block的堆内存
          struct Block_layout *result = malloc(aBlock-&gt;descriptor-&gt;size);
          if (!result) return (void *)0;
          // 拷贝栈中block到刚申请的堆内存中
          memmove(result, aBlock, aBlock-&gt;descriptor-&gt;size); // bitcopy first
          // reset refcount
          result-&gt;flags &amp;= ~(BLOCK_REFCOUNT_MASK);    // XXX not needed
          result-&gt;flags |= BLOCK_NEEDS_FREE | 1;
          // 改变isa指向_NSConcreteMallocBlock，即堆block类型
          result-&gt;isa = _NSConcreteMallocBlock;
          if (result-&gt;flags &amp; BLOCK_HAS_COPY_DISPOSE) {
              //printf("calling block copy helper %p(%p, %p)...\n", aBlock-&gt;descriptor-&gt;copy, result, aBlock);
              (*aBlock-&gt;descriptor-&gt;copy)(result, aBlock); // do fixup
          }
          return result;
      }
      else {
          ...
      }
  }
</code></pre>

<p>从以上代码以及注释可以很清楚的看出，函数通过memmove将栈中的block的内容拷贝到了堆中，并使isa指向了_NSConcreteMallocBlock。
block主要的一些学问就出在栈中block向堆中block的转移过程中了。</p></li>
</ul>


<p>捕捉变量对block结构的影响
接下来会编译转换捕捉不同变量类型的block，以对比它们的区别。</p>

<h5>局部变量</h5>

<p>前：</p>

<pre><code>- (void)test
{
    int a;
    ^{a;};
}
</code></pre>

<p>后：</p>

<pre><code>struct __Person__test_block_impl_0 {
  struct __block_impl impl;
  struct __Person__test_block_desc_0* Desc;
  int a;
  // a(_a)是构造函数的参数列表初始化形式，相当于a = _a。从_I_Person_test看，传入的就是a
  __Person__test_block_impl_0(void *fp, struct __Person__test_block_desc_0 *desc, int _a, int flags=0) : a(_a) {
    impl.isa = &amp;_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};
static void __Person__test_block_func_0(struct __Person__test_block_impl_0 *__cself) {
  int a = __cself-&gt;a; // bound by copy
a;}

static struct __Person__test_block_desc_0 {
  size_t reserved;
  size_t Block_size;
} __Person__test_block_desc_0_DATA = { 0, sizeof(struct __Person__test_block_impl_0)};

static void _I_Person_test(Person * self, SEL _cmd) {
    int a;
    (void (*)())&amp;__Person__test_block_impl_0((void *)__Person__test_block_func_0, &amp;__Person__test_block_desc_0_DATA, a);
}
</code></pre>

<p>可以看到，block相对于文章开头增加了一个int类型的成员变量，他就是用来存储外部变量a的。可以看出，这次拷贝只是一次值传递。并且当我们想在block中进行以下操作时，将会发生错误</p>

<pre><code>^{a = 10;};
</code></pre>

<p>编译器会提示</p>

<p><img src="http://al1020119.github.io/images/block002.png" title="Caption" ></p>

<p>错误提示
。因为_I_Person_test函数中的a和Persontest_block_func_0函数中的a并没有在同一个作用域，所以在block对a进行赋值是没有意义的，所以编译器给出了错误。我们可以通过地址传递来消除以上错误：</p>

<pre><code>- (void)test
{
    int a = 0;
    // 利用指针p存储a的地址
    int *p = &amp;a;

    ^{
        // 通过a的地址设置a的值
        *p = 10;
    };
}
</code></pre>

<p>但是变量a的生命周期是和方法test的栈相关联的，当test运行结束，栈随之销毁，那么变量a就会被销毁，p也就成为了野指针。如果block是作为参数或者返回值，这些类型都是跨栈的，也就是说再次调用会造成野指针错误。</p>

<h5>全局变量</h5>

<p>前：</p>

<pre><code>// 全局静态
static int a;
// 全局
int b;
- (void)test
{

    ^{
        a = 10;
        b = 10;
    };
}
</code></pre>

<p>后：</p>

<pre><code>static int a;
int b;

struct __Person__test_block_impl_0 {
  struct __block_impl impl;
  struct __Person__test_block_desc_0* Desc;
  __Person__test_block_impl_0(void *fp, struct __Person__test_block_desc_0 *desc, int flags=0) {
    impl.isa = &amp;_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};
static void __Person__test_block_func_0(struct __Person__test_block_impl_0 *__cself) {

        a = 10;
        b = 10;
    }

static struct __Person__test_block_desc_0 {
  size_t reserved;
  size_t Block_size;
} __Person__test_block_desc_0_DATA = { 0, sizeof(struct __Person__test_block_impl_0)};

static void _I_Person_test(Person * self, SEL _cmd) {

    (void (*)())&amp;__Person__test_block_impl_0((void *)__Person__test_block_func_0, &amp;__Person__test_block_desc_0_DATA);
}
</code></pre>

<p>可以看出，因为全局变量都是在静态数据存储区，在程序结束前不会被销毁，所以block直接访问了对应的变量，而没有在Persontest_block_impl_0结构体中给变量预留位置。</p>

<h5>局部静态变量</h5>

<p>前</p>

<pre><code>- (void)test
{
    static int a;
    ^{
        a = 10;
    };
}
</code></pre>

<p>后：</p>

<pre><code>struct __Person__test_block_impl_0 {
  struct __block_impl impl;
  struct __Person__test_block_desc_0* Desc;
  int *a;
  __Person__test_block_impl_0(void *fp, struct __Person__test_block_desc_0 *desc, int *_a, int flags=0) : a(_a) {
    impl.isa = &amp;_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};
static void __Person__test_block_func_0(struct __Person__test_block_impl_0 *__cself) {
  int *a = __cself-&gt;a; // bound by copy
        // 这里通过局部静态变量a的地址来对其进行修改
        (*a) = 10;
    }

static struct __Person__test_block_desc_0 {
  size_t reserved;
  size_t Block_size;
} __Person__test_block_desc_0_DATA = { 0, sizeof(struct __Person__test_block_impl_0)};

static void _I_Person_test(Person * self, SEL _cmd) {
    static int a;
    // 传入a的地址
    (void (*)())&amp;__Person__test_block_impl_0((void *)__Person__test_block_func_0, &amp;__Person__test_block_desc_0_DATA, &amp;a);
}
</code></pre>

<p>需要注意一点的是静态局部变量是存储在静态数据存储区域的，也就是和程序拥有一样的生命周期，也就是说在程序运行时，都能够保证block访问到一个有效的变量。但是其作用范围还是局限于定义它的函数中，所以只能在block通过静态局部变量的地址来进行访问。
关于变量的存储我原来的这篇博客有提及：c语言臆想&ndash;全局&mdash;局部变量</p>

<h5>__block修饰的变量</h5>

<p>前：</p>

<pre><code>- (void)test
{
   __block int a;
    ^{
        a = 10;
    };
}
</code></pre>

<p>后：</p>

<pre><code>struct __Block_byref_a_0 {
  void *__isa;
__Block_byref_a_0 *__forwarding;
 int __flags;
 int __size;
 int a;
};

struct __Person__test_block_impl_0 {
  struct __block_impl impl;
  struct __Person__test_block_desc_0* Desc;
  __Block_byref_a_0 *a; // by ref
  __Person__test_block_impl_0(void *fp, struct __Person__test_block_desc_0 *desc, __Block_byref_a_0 *_a, int flags=0) : a(_a-&gt;__forwarding) {
    impl.isa = &amp;_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};
static void __Person__test_block_func_0(struct __Person__test_block_impl_0 *__cself) {
  __Block_byref_a_0 *a = __cself-&gt;a; // bound by ref
        // 注意，这里的_forwarding用来保证操作的始终是堆中的拷贝a，而不是栈中的a
        (a-&gt;__forwarding-&gt;a) = 10;
    }
static void __Person__test_block_copy_0(struct __Person__test_block_impl_0*dst, struct __Person__test_block_impl_0*src) {_Block_object_assign((void*)&amp;dst-&gt;a, (void*)src-&gt;a, 8/*BLOCK_FIELD_IS_BYREF*/);}

static void __Person__test_block_dispose_0(struct __Person__test_block_impl_0*src) {_Block_object_dispose((void*)src-&gt;a, 8/*BLOCK_FIELD_IS_BYREF*/);}

static struct __Person__test_block_desc_0 {
  size_t reserved;
  size_t Block_size;
  void (*copy)(struct __Person__test_block_impl_0*, struct __Person__test_block_impl_0*);
  void (*dispose)(struct __Person__test_block_impl_0*);
} __Person__test_block_desc_0_DATA = { 0, sizeof(struct __Person__test_block_impl_0), __Person__test_block_copy_0, __Person__test_block_dispose_0};

static void _I_Person_test(Person * self, SEL _cmd) {
    // __block将a包装成了一个对象
   __attribute__((__blocks__(byref))) __Block_byref_a_0 a = {(void*)0,(__Block_byref_a_0 *)&amp;a, 0, sizeof(__Block_byref_a_0)};
;
    (void (*)())&amp;__Person__test_block_impl_0((void *)__Person__test_block_func_0, &amp;__Person__test_block_desc_0_DATA, (__Block_byref_a_0 *)&amp;a, 570425344);
}
</code></pre>

<p>可以看到，对比上面的结果，明显多了<strong>Block_byref_a_0结构体，这个结构体中含有isa指针，所以也是一个对象，它是用来包装局部变量a的。当block被copy到堆中时，</strong>Person<strong>test_block_impl_0的拷贝辅助函数</strong>Person<strong>test_block_copy_0会将</strong>Block_byref_a_0拷贝至堆中，所以即使局部变量所在堆被销毁，block依然能对堆中的局部变量进行操作。其中<strong>Block_byref_a_0成员指针</strong>forwarding用来指向它在堆中的拷贝，其依据源码如下：</p>

<pre><code>static void _Block_byref_assign_copy(void *dest, const void *arg, const int flags) {
    struct Block_byref **destp = (struct Block_byref **)dest;
    struct Block_byref *src = (struct Block_byref *)arg;

    ...
    // 堆中拷贝的forwarding指向它自己
    copy-&gt;forwarding = copy; // patch heap copy to point to itself (skip write-barrier)
    // 栈中的forwarding指向堆中的拷贝
    src-&gt;forwarding = copy;  // patch stack to point to heap copy
    ...
}
</code></pre>

<p>这样做是为了保证操作的值始终是堆中的拷贝，而不是栈中的值。（处理在局部变量所在栈还没销毁，就调用block来改变局部变量值的情况，如果没有__forwarding指针，则修改无效）
至于block如何实现对局部变量的拷贝，下面会详细说明。</p>

<h5>self隐式循环引用</h5>

<p>前：</p>

<pre><code>@implementation Person
{
    int _a;
    void (^_block)();
}
- (void)test
{
  void (^_block)() = ^{
        _a = 10;
    };
}

@end
</code></pre>

<p>后：</p>

<pre><code>struct __Person__test_block_impl_0 {
  struct __block_impl impl;
  struct __Person__test_block_desc_0* Desc;
  // 可以看到，block强引用了self
  Person *self;
  __Person__test_block_impl_0(void *fp, struct __Person__test_block_desc_0 *desc, Person *_self, int flags=0) : self(_self) {
    impl.isa = &amp;_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};
static void __Person__test_block_func_0(struct __Person__test_block_impl_0 *__cself) {
  Person *self = __cself-&gt;self; // bound by copy

        (*(int *)((char *)self + OBJC_IVAR_$_Person$_a)) = 10;
    }
static void __Person__test_block_copy_0(struct __Person__test_block_impl_0*dst, struct __Person__test_block_impl_0*src) {_Block_object_assign((void*)&amp;dst-&gt;self, (void*)src-&gt;self, 3/*BLOCK_FIELD_IS_OBJECT*/);}

static void __Person__test_block_dispose_0(struct __Person__test_block_impl_0*src) {_Block_object_dispose((void*)src-&gt;self, 3/*BLOCK_FIELD_IS_OBJECT*/);}

static struct __Person__test_block_desc_0 {
  size_t reserved;
  size_t Block_size;
  void (*copy)(struct __Person__test_block_impl_0*, struct __Person__test_block_impl_0*);
  void (*dispose)(struct __Person__test_block_impl_0*);
} __Person__test_block_desc_0_DATA = { 0, sizeof(struct __Person__test_block_impl_0), __Person__test_block_copy_0, __Person__test_block_dispose_0};

static void _I_Person_test(Person * self, SEL _cmd) {
  void (*_block)() = (void (*)())&amp;__Person__test_block_impl_0((void *)__Person__test_block_func_0, &amp;__Person__test_block_desc_0_DATA, self, 570425344);
}
</code></pre>

<p>如果在编译转换前，将<em>a改成self.a，能很明显地看出是产生了循环引用(self强引用block，block强引用self)。那么使用</em>a呢？经过编译转换后，依然可以在<strong>Person</strong>test_block_impl_0看见self的身影。且在函数<em>I_Person_test中，传入的参数也是self。通过以下语句，可以看出，不管是用什么形式访问实例变量，最终都会转换成self+变量内存偏移的形式。所以在上面例子中使用</em>a也会造成循环引用。</p>

<pre><code>static void __Person__test_block_func_0(struct __Person__test_block_impl_0 *__cself) {
  Person *self = __cself-&gt;self; // bound by copy
        // self＋实例变量a的偏移值
        (*(int *)((char *)self + OBJC_IVAR_$_Person$_a)) = 10;
    }
</code></pre>

<h3>不同类型block的复制</h3>

<p>block的复制代码在_Block_copy_internal函数中。</p>

<h5>栈block</h5>

<p>从以下代码可以看出，栈block的复制不仅仅复制了其内容，还添加了一些额外的东西</p>

<pre><code>* 1、往flags中并入了BLOCK_NEEDS_FREE（这个标志表明block需要释放，在release以及再次拷贝时会用到）

* 2、如果有辅助copy函数（BLOCK_HAS_COPY_DISPOSE），那么就调用（这个辅助copy函数是用来拷贝block捕获的变量的）

struct Block_layout *result = malloc(aBlock-&gt;descriptor-&gt;size);
if (!result) return (void *)0;
  memmove(result, aBlock, aBlock-&gt;descriptor-&gt;size); // bitcopy first
// reset refcount
result-&gt;flags &amp;= ~(BLOCK_REFCOUNT_MASK);    // XXX not needed
result-&gt;flags |= BLOCK_NEEDS_FREE | 1;
result-&gt;isa = _NSConcreteMallocBlock;
if (result-&gt;flags &amp; BLOCK_HAS_COPY_DISPOSE) {
      //printf("calling block copy helper %p(%p, %p)...\n", aBlock-&gt;descriptor-&gt;copy, result, aBlock);
      (*aBlock-&gt;descriptor-&gt;copy)(result, aBlock); // do fixup
  }
  return result;
</code></pre>

<h5>堆block</h5>

<p>从以下代码看出，如果block的flags中有BLOCK_NEEDS_FREE标志（block从栈中拷贝到堆时添加的标志），就执行latching_incr_int操作，其功能就是让block的引用计数加1。所以堆中block的拷贝只是单纯地改变了引用计数</p>

<pre><code>  ...
  if (aBlock-&gt;flags &amp; BLOCK_NEEDS_FREE) {
        // latches on high
        latching_incr_int(&amp;aBlock-&gt;flags);
        return aBlock;
    }
  ...
</code></pre>

<h5>全局block</h5>

<p>从以下代码看出，对于全局block，函数没有做任何操作，直接返回了传入的block</p>

<pre><code>else if (aBlock-&gt;flags &amp; BLOCK_IS_GLOBAL) {
      return aBlock;
}
</code></pre>

<h3>block辅助函数</h3>

<ul>
<li>上文提及到了block辅助copy与dispose处理函数，这里分析下这两个函数的内部实现。在捕* 获变量为__block修饰的基本类型，或者为对象时，block才会有这两个辅助函数。</li>
<li>block捕捉变量拷贝函数为<em>Block_object_assign。在调用复制block的函数</em>Block_copy_internal时，会根据block有无辅助函数来对捕捉变量拷贝函数<em>Block_object_assign进行调用。而在</em>Block_object_assign函数中，也会判断捕捉变量包装而成的对象(Block_byref结构体)是否有辅助函数，来进行调用。</li>
</ul>


<h5>__block修饰的基本类型的辅助函数</h5>

<p>编写以下代码：</p>

<pre><code>typedef void(^Block)();
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        __block int a;
        Block block = ^ {
            a;
        };
}
</code></pre>

<p>转换成C++代码后：</p>

<pre><code>typedef void(*Block)();
// __block int a
struct __Block_byref_a_0 {
  void *__isa;
__Block_byref_a_0 *__forwarding;
 int __flags;
 int __size;
 int a;
};

// block
struct __main_block_impl_0 {
  struct __block_impl impl;
  struct __main_block_desc_0* Desc;
  __Block_byref_a_0 *a; // by ref
  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_a_0 *_a, int flags=0) : a(_a-&gt;__forwarding) {
    impl.isa = &amp;_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};

// block函数体
static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
  __Block_byref_a_0 *a = __cself-&gt;a; // bound by ref

            (a-&gt;__forwarding-&gt;a);
        }
// 辅助copy函数
static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {_Block_object_assign((void*)&amp;dst-&gt;a, (void*)src-&gt;a, 8/*BLOCK_FIELD_IS_BYREF*/);}

// 辅助dispose函数
static void __main_block_dispose_0(struct __main_block_impl_0*src) {_Block_object_dispose((void*)src-&gt;a, 8/*BLOCK_FIELD_IS_BYREF*/);}

static struct __main_block_desc_0 {
  size_t reserved;
  size_t Block_size;
  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);
  void (*dispose)(struct __main_block_impl_0*);
} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0};
int main(int argc, const char * argv[]) {
    /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool;
        // 这里创建了，并将a的flags设置为0
        __attribute__((__blocks__(byref))) __Block_byref_a_0 a = {(void*)0,(__Block_byref_a_0 *)&amp;a, 0, sizeof(__Block_byref_a_0)};
;
        Block block = (void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_a_0 *)&amp;a, 570425344);
    }
    return 0;
}
</code></pre>

<p>从上面代码中，被<strong>block修饰的a变量变为了</strong>Block_byref_a_0类型，根据这个格式，从源码中查看得到相似的定义：</p>

<pre><code>struct Block_byref {
    void *isa;
    struct Block_byref *forwarding;
    int flags; /* refcount; */
    int size;
    void (*byref_keep)(struct Block_byref *dst, struct Block_byref *src);
    void (*byref_destroy)(struct Block_byref *);
    /* long shared[0]; */
};

// 做下对比
struct __Block_byref_a_0 {
  void *__isa;
__Block_byref_a_0 *__forwarding;
 int __flags;
 int __size;
 int a;
};

// flags/_flags类型
enum {
        /* See function implementation for a more complete description of these fields and combinations */
        // 是一个对象
        BLOCK_FIELD_IS_OBJECT   =  3,  /* id, NSObject, __attribute__((NSObject)), block, ... */
        // 是一个block
        BLOCK_FIELD_IS_BLOCK    =  7,  /* a block variable */
        // 被__block修饰的变量
        BLOCK_FIELD_IS_BYREF    =  8,  /* the on stack structure holding the __block variable */
        // 被__weak修饰的变量，只能被辅助copy函数使用
        BLOCK_FIELD_IS_WEAK     = 16,  /* declared __weak, only used in byref copy helpers */
        // block辅助函数调用（告诉内部实现不要进行retain或者copy）
        BLOCK_BYREF_CALLER      = 128  /* called from __block (byref) copy/dispose support routines. */
    };
</code></pre>

<p>可以看出，__block将原来的基本类型包装成了对象。因为以上两个结构体的前4个成员的类型都是一样的，内存空间排列一致，所以可以进行以下操作：</p>

<pre><code>// 转换成C++代码
static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {_Block_object_assign((void*)&amp;dst-&gt;a, (void*)src-&gt;a, 8/*BLOCK_FIELD_IS_BYREF*/);}

// _Block_object_assign源码
void _Block_object_assign(void *destAddr, const void *object, const int flags) {
...
    else if ((flags &amp; BLOCK_FIELD_IS_BYREF) == BLOCK_FIELD_IS_BYREF)  {
        // copying a __block reference from the stack Block to the heap
        // flags will indicate if it holds a __weak reference and needs a special isa
        _Block_byref_assign_copy(destAddr, object, flags);
    }
...
}

// _Block_byref_assign_copy源码
static void _Block_byref_assign_copy(void *dest, const void *arg, const int flags) {
    // 这里因为前面4个成员的内存分布一样，所以直接转换后，使用Block_byref的成员变量名，能访问到__Block_byref_a_0的前面4个成员
    struct Block_byref **destp = (struct Block_byref **)dest;
    struct Block_byref *src = (struct Block_byref *)arg;
...
    else if ((src-&gt;forwarding-&gt;flags &amp; BLOCK_REFCOUNT_MASK) == 0) {
        // 从main函数对__Block_byref_a_0的初始化，可以看到初始化时将flags赋值为0
        // 这里表示第一次拷贝，会进行复制操作，并修改原来flags的值
        // static int _Byref_flag_initial_value = BLOCK_NEEDS_FREE | 2;
        // 可以看出，复制后，会并入BLOCK_NEEDS_FREE，后面的2是block的初始引用计数
        ...
        copy-&gt;flags = src-&gt;flags | _Byref_flag_initial_value;
        ...
    }
    // 已经拷贝到堆了，只增加引用计数
    else if ((src-&gt;forwarding-&gt;flags &amp; BLOCK_NEEDS_FREE) == BLOCK_NEEDS_FREE) {
        latching_incr_int(&amp;src-&gt;forwarding-&gt;flags);
    }
    // 普通的赋值，里面最底层就*destptr = value;这句表达式
    _Block_assign(src-&gt;forwarding, (void **)destp);
}
</code></pre>

<p>主要操作都在代码注释中了，总体来说，__block修饰的基本类型会被包装为对象，并且只在最初block拷贝时复制一次，后面的拷贝只会增加这个捕获变量的引用计数。</p>

<h5>对象的辅助函数</h5>

<p>没有__block修饰</p>

<pre><code>typedef void(^Block)();
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        NSObject *a = [[NSObject alloc] init];
        Block block = ^ {
            a;
        };
    }
    return 0;
}
</code></pre>

<p>首先，在没有__block修饰时，对象编译转换的结果如下，删除了一些变化不大的代码：</p>

<pre><code>static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
  NSObject *a = __cself-&gt;a; // bound by copy
            a;
        }
static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {_Block_object_assign((void*)&amp;dst-&gt;a, (void*)src-&gt;a, 3/*BLOCK_FIELD_IS_OBJECT*/);}

static void __main_block_dispose_0(struct __main_block_impl_0*src) {_Block_object_dispose((void*)src-&gt;a, 3/*BLOCK_FIELD_IS_OBJECT*/);}

static struct __main_block_desc_0 {
  size_t reserved;
  size_t Block_size;
  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);
  void (*dispose)(struct __main_block_impl_0*);
} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0),
</code></pre>

<p>对象在没有<strong>block修饰时，并没有产生</strong>Block_byref_a_0结构体，只是将标志位修改为BLOCK_FIELD_IS_OBJECT。而在_Block_object_assign中对应的判断分支代码如下：</p>

<pre><code>else if ((flags &amp; BLOCK_FIELD_IS_OBJECT) == BLOCK_FIELD_IS_OBJECT) {
    _Block_retain_object(object);
    _Block_assign((void *)object, destAddr);
}
</code></pre>

<p>可以看到，block复制时，会retain捕捉对象，以增加其引用计数。</p>

<p>有__block修饰</p>

<pre><code>typedef void(^Block)();
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        __block NSObject *a = [[NSObject alloc] init];
        Block block = ^ {
            a;
        };
    }
    return 0;
}
</code></pre>

<p>在这种情况下，编译转换的部分结果如下：</p>

<pre><code>struct __Block_byref_a_0 {
  void *__isa;
__Block_byref_a_0 *__forwarding;
 int __flags;
 int __size;
 void (*__Block_byref_id_object_copy)(void*, void*);
 void (*__Block_byref_id_object_dispose)(void*);
 NSObject *a;
};
int main(int argc, const char * argv[]) {
    /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool;
attribute__((__blocks__(byref))) __Block_byref_a_0 a = {(void*)0,(__Block_byref_a_0 *)&amp;a, 33554432, sizeof(__Block_byref_a_0), __Block_byref_id_object_copy_131, __Block_byref_id_object_dispose_131,....};
Block block = (void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_a_0 *)&amp;a, 570425344);
}

// 以下的40表示__Block_byref_a_0对象a的位移（4个指针(32字节)＋2个int变量(8字节)＝40字节）
    static void __Block_byref_id_object_copy_131(void *dst, void *src) {
     _Block_object_assign((char*)dst + 40, *(void * *) ((char*)src + 40), 131);
    }
    static void __Block_byref_id_object_dispose_131(void *src) {
     _Block_object_dispose(*(void * *) ((char*)src + 40), 131);
    }
</code></pre>

<ol>
<li><p>可以看到，对于对象，<strong>Block_byref_a_0另外增加了两个辅助函数</strong>Block_byref_id_object_copy、__Block_byref_id_object_dispose,以实现对对象</p></li>
<li><p>内存的管理。其中两者的最后一个参数131表示BLOCK_BYREF_CALLER|BLOCK_FIELD_IS_OBJECT，BLOCK_BYREF_CALLER表示在内部实现中不对a对象进行retain或copy；以下为相关源码</p></li>
</ol>


<hr />

<pre><code>if ((flags &amp; BLOCK_BYREF_CALLER) == BLOCK_BYREF_CALLER) {
    ...
    else {
        // do *not* retain or *copy* __block variables whatever they are
        _Block_assign((void *)object, destAddr);
    }
}
</code></pre>

<p>_Block_byref_assign_copy函数的以下代码会对上面的辅助函数（__Block_byref_id_object_copy_131）进行调用；570425344表示BLOCK_HAS_COPY_DISPOSE|BLOCK_HAS_DESCRIPTOR，所以会执行以下相关源码：</p>

<pre><code>if (src-&gt;flags &amp; BLOCK_HAS_COPY_DISPOSE) {
    // Trust copy helper to copy everything of interest
    // If more than one field shows up in a byref block this is wrong XXX
    copy-&gt;byref_keep = src-&gt;byref_keep;
    copy-&gt;byref_destroy = src-&gt;byref_destroy;
    (*src-&gt;byref_keep)(copy, src);
}
</code></pre>

<h3>ARC中block的工作</h3>

<p><img src="http://al1020119.github.io/images/block003.png" title="Caption" ></p>

<p>苹果说明</p>

<p>苹果文档提及，在ARC模式下，在栈间传递block时，不需要手动copy栈中的block，即可让block正常工作。主要原因是ARC对栈中的block自动执行了copy，将<em>NSConcreteStackBlock类型的block转换成了</em>NSConcreteMallocBlock的block。</p>

<h5>block试验</h5>

<p>下面对block做点实验：</p>

<p>int main(int argc, const char * argv[]) {
    @autoreleasepool {
        int i = 10;
        void (^block)() = ^{i;};</p>

<pre><code>    __weak void (^weakBlock)() = ^{i;};

    void (^stackBlock)() = ^{};

    // ARC情况下

    // 创建时，都会在栈中
    // &lt;__NSStackBlock__: 0x7fff5fbff730&gt;
    NSLog(@"%@", ^{i;});

    // 因为stackBlock为strong类型，且捕获了外部变量，所以赋值时，自动进行了copy
    // &lt;__NSMallocBlock__: 0x100206920&gt;
    NSLog(@"%@", block);

    // 如果是weak类型的block，依然不会自动进行copy
    // &lt;__NSStackBlock__: 0x7fff5fbff728&gt;
    NSLog(@"%@", weakBlock);

    // 如果block是strong类型，并且没有捕获外部变量，那么就会转换成__NSGlobalBlock__
    // &lt;__NSGlobalBlock__: 0x100001110&gt;
    NSLog(@"%@", stackBlock);

    // 在非ARC情况下，产生以下输出
    // &lt;__NSStackBlock__: 0x7fff5fbff6d0&gt;
    // &lt;__NSStackBlock__: 0x7fff5fbff730&gt;
    // &lt;__NSStackBlock__: 0x7fff5fbff700&gt;
    // &lt;__NSGlobalBlock__: 0x1000010d0&gt;
}
return 0;
</code></pre>

<p>}</p>

<p>可以看出，ARC对类型为strong且捕获了外部变量的block进行了copy。并且当block类型为strong，但是创建时没有捕获外部变量，block最终会变成<strong>NSGlobalBlock</strong>类型（这里可能因为block中的代码没有捕获外部变量，所以不需要在栈中开辟变量，也就是说，在编译时，这个block的所有内容已经在代码段中生成了，所以就把block的类型转换为全局类型）</p>

<h5>block作为参数传递</h5>

<p>再来看下使用在栈中的block需要注意的情况：</p>

<pre><code>NSMutableArray *arrayM;
void myBlock()
{
    int a = 5;
    Block block = ^ {
        NSLog(@"%d", a);
    };

    [arrayM addObject:block];
    NSLog(@"%@", block);
}

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        arrayM = @[].mutableCopy;

        myBlock();

        Block block = [arrayM firstObject];
        // 非ARC这里崩溃
        block();
 }

// ARC情况下输出
// &lt;__NSMallocBlock__: 0x100214480&gt;

// 非ARC情况下输出
// &lt;__NSStackBlock__: 0x7fff5fbff738&gt;
// 崩溃，野指针错误
</code></pre>

<p>可以看到，ARC情况下因为自动执行了copy，所以返回类型为<strong>NSMallocBlock</strong>，在函数结束后依然可以访问；而非ARC情况下，需要我们手动调用[block copy]来将block拷贝到堆中，否则因为栈中的block生命周期和函数中的栈生命周期关联，当函数退出后，相应的堆被销毁，block也就不存在了。
如果把block的以下代码删除：</p>

<pre><code>NSLog(@"%d", a);
那么block就会变成全局类型，在main中访问也不会出崩溃。
</code></pre>

<h5>block作为返回值</h5>

<pre><code>在非ARC情况下，如果返回值是block，则一般这样操作：

return [[block copy] autorelease];
</code></pre>

<p>对于外部要使用的block，更趋向于把它拷贝到堆中，使其脱离栈生命周期的约束。</p>

<h5>block属性</h5>

<p>这里还有一点关于block类型的ARC属性。上文也说明了，ARC会自动帮strong类型且捕获外部变量的block进行copy，所以在定义block类型的属性时也可以使用strong，不一定使用copy。也就是以下代码：</p>

<pre><code>/** 假如有栈block赋给以下两个属性 **/

// 这里因为ARC，当栈block中会捕获外部变量时，这个block会被copy进堆中
// 如果没有捕获外部变量，这个block会变为全局类型
// 不管怎么样，它都脱离了栈生命周期的约束

@property (strong, nonatomic) Block *strongBlock;

// 这里都会被copy进堆中
@property (copy, nonatomic) Block *copyBlock;
</code></pre>

<p>参考博文
谈Objective-C Block的实现(<a href="http://blog.devtang.com/blog/2013/07/28/a-look-inside-blocks/">http://blog.devtang.com/blog/2013/07/28/a-look-inside-blocks/</a>)
iOS中block实现的探究(<a href="http://blog.csdn.net/jasonblog/article/details/7756763">http://blog.csdn.net/jasonblog/article/details/7756763</a>)
A look inside blocks: Episode 3
runtime.c
Block_private.h</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[网络请求疯（封）装]]></title>
    <link href="http://al1020119.github.io/blog/2015/08/25/wang-shang-qing-qiu-feng-(feng-)zhuang/"/>
    <updated>2015-08-25T09:37:30+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/08/25/wang-shang-qing-qiu-feng-(feng-)zhuang</id>
    <content type="html"><![CDATA[<p>一直想总结一下关于iOS的离线数据缓存的方面的问题，然后最近也简单的对AFN进行了再次封装，所有想把这两个结合起来写一下。数据展示型的页面做离线缓存可以有更好的用户体验，用户在离线环境下仍然可以获取一些数据，这里的数据缓存首选肯定是SQLite，轻量级，对数据的存储读取相对于其他几种方式有优势，这里对AFN的封装没有涉及太多业务逻辑层面的需求，主要还是对一些方法再次封装方便使用，解除项目对第三方的耦合性，能够简单的快速的更换底层使用的网络请求代码。这篇主要写离线缓存思路，对AFN的封装只做简单的介绍。</p>

<p>关于XLNetworkApi</p>

<!--more-->


<p>XLNetworkApi的一些功能和说明：</p>

<p>使用XLNetworkRequest做一些GET、POST、PUT、DELETE请求，与业务逻辑对接部分直接以数组或者字典的形式返回。
以及网络下载、上传文件，以block的形式返回实时的下载、上传进度，上传文件参数通过模型XLFileConfig去存取。
通过继承于XLDataService来将一些数据处理，模型转化封装起来，于业务逻辑对接返回的是对应的模型，减少Controllor处理数据处理逻辑的压力。
自定义一些回调的block</p>

<pre><code>/**
请求成功block
*/
typedef void (^requestSuccessBlock)(id responseObj);
/**
请求失败block
*/
typedef void (^requestFailureBlock) (NSError *error);
/**
请求响应block
*/
typedef void (^responseBlock)(id dataObj, NSError *error);
/**
监听进度响应block
*/
typedef void (^progressBlock)(int64_t bytesWritten, int64_t totalBytesWritten, int64_t totalBytesExpectedToWrite);
XLNetworkRequest.m部分实现
#import "XLNetworkRequest.h"
#import "AFNetworking.h"
@implementation XLNetworkRequest
+ (void)getRequest:(NSString *)url params:(NSDictionary *)params success:(requestSuccessBlock)successHandler failure:(requestFailureBlock)failureHandler {
//网络不可用
  if (![self checkNetworkStatus]) {
      successHandler(nil);
      failureHandler(nil);
      return;
  }
  AFHTTPRequestOperationManager *manager = [self getRequstManager];
  [manager GET:url parameters:params success:^(AFHTTPRequestOperation * _Nonnull operation, id  _Nonnull responseObject) {
      successHandler(responseObject);
  } failure:^(AFHTTPRequestOperation * _Nullable operation, NSError * _Nonnull error) {
      XLLog(@"------请求失败-------%@",error);
      failureHandler(error);
  }];
}
</code></pre>

<p>下载部分代码</p>

<pre><code>    //下载文件，监听下载进度
    + (void)downloadRequest:(NSString *)url successAndProgress:(progressBlock)progressHandler complete:(responseBlock)completionHandler {
      if (![self checkNetworkStatus]) {
          progressHandler(0, 0, 0);
          completionHandler(nil, nil);
          return;
      }
      NSURLSessionConfiguration *sessionConfiguration = [NSURLSessionConfiguration defaultSessionConfiguration];
      AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:sessionConfiguration];
      NSURLRequest *request = [NSURLRequest requestWithURL:[NSURL URLWithString:url]];
      NSProgress *kProgress = nil;
      NSURLSessionDownloadTask *downloadTask = [manager downloadTaskWithRequest:request progress:&amp;kProgress destination:^NSURL * _Nonnull(NSURL * _Nonnull targetPath, NSURLResponse * _Nonnull response) {
          NSURL *documentUrl = [[NSFileManager defaultManager] URLForDirectory :NSDocumentDirectory inDomain:NSUserDomainMask appropriateForURL:nil create:NO error:nil];
          return [documentUrl URLByAppendingPathComponent:[response suggestedFilename]];
      } completionHandler:^(NSURLResponse * _Nonnull response, NSURL * _Nonnull filePath, NSError * _Nonnull error){
          if (error) {
              XLLog(@"------下载失败-------%@",error);
          }
          completionHandler(response, error);
      }];
      [manager setDownloadTaskDidWriteDataBlock:^(NSURLSession * _Nonnull session, NSURLSessionDownloadTask * _Nonnull downloadTask, int64_t bytesWritten, int64_t totalBytesWritten, int64_t totalBytesExpectedToWrite) {
          progressHandler(bytesWritten, totalBytesWritten, totalBytesExpectedToWrite);
      }];
      [downloadTask resume];
    }
</code></pre>

<p>上传部分代码</p>

<pre><code>//上传文件，监听上传进度
+ (void)updateRequest:(NSString *)url params:(NSDictionary *)params fileConfig:(XLFileConfig *)fileConfig successAndProgress:(progressBlock)progressHandler complete:(responseBlock)completionHandler {
  if (![self checkNetworkStatus]) {
      progressHandler(0, 0, 0);
      completionHandler(nil, nil);
      return;
  }
  NSMutableURLRequest *request = [[AFHTTPRequestSerializer serializer] multipartFormRequestWithMethod:@"POST" URLString:url parameters:params constructingBodyWithBlock:^(id  _Nonnull formData) {
      [formData appendPartWithFileData:fileConfig.fileData name:fileConfig.name fileName:fileConfig.fileName mimeType:fileConfig.mimeType];
  } error:nil];
  //获取上传进度
  AFHTTPRequestOperation *operation = [[AFHTTPRequestOperation alloc] initWithRequest:request];
  [operation setUploadProgressBlock:^(NSUInteger bytesWritten, long long totalBytesWritten, long long totalBytesExpectedToWrite) {
      progressHandler(bytesWritten, totalBytesWritten, totalBytesExpectedToWrite);
  }];
  [operation setCompletionBlockWithSuccess:^(AFHTTPRequestOperation * _Nonnull operation, id  _Nonnull responseObject) {
      completionHandler(responseObject, nil);
  } failure:^(AFHTTPRequestOperation * _Nonnull operation, NSError * _Nonnull error) {
      completionHandler(nil, error);
      if (error) {
          XLLog(@"------上传失败-------%@",error);
      }
  }];
  [operation start];
}
</code></pre>

<p>XLDataService.m部分实现</p>

<pre><code>+ (void)getWithUrl:(NSString *)url param:(id)param modelClass:(Class)modelClass responseBlock:(responseBlock)responseDataBlock {
      [XLNetworkRequest getRequest:url params:param success:^(id responseObj) {
      //数组、字典转化为模型数组
      dataObj = [self modelTransformationWithResponseObj:responseObj modelClass:modelClass];
      responseDataBlock(dataObj, nil);
  } failure:^(NSError *error) {
      responseDataBlock(nil, error);
  }];
}
</code></pre>

<p>（关键）下面这个方法提供给继承XLDataService的子类重写，将转化为模型的代码写在这里，相似业务的网络数据请求都可以用这个子类去请求数据，直接返回对应的模型数组。
    /<em>*
    数组、字典转化为模型
    </em>/
    + (id)modelTransformationWithResponseObj:(id)responseObj modelClass:(Class)modelClass {
         return nil;
    }
关于离线数据缓存</p>

<p>当用户进入程序的展示页面，有三个情况下可能涉及到数据库存取操作，简单画了个图来理解，思路比较简单，主要是一些存取的细节处理。</p>

<p>进入展示页面</p>

<p><img src="http://al1020119.github.io/images/net001.png" title="Caption" ></p>

<p>下拉刷新最新数据</p>

<p><img src="http://al1020119.github.io/images/net002.png" title="Caption" ></p>

<p>上拉加载更多数据</p>

<p><img src="http://al1020119.github.io/images/net003.png" title="Caption" ></p>

<p>需要注意的是，上拉加载更多的时候，每次从数据库返回一定数量的数据，而不是一次性将数据全部加载，否则会有内存问题，直到数据库中没有更多数据时再发生网络请求，再次将新数据存入数据库。这里存储数据的方式是将服务器返回每组数据的字典归档成二进制作为数据库字段直接存储，这样存储在模型属性比较多的情况下更有好处，避免每一个属性作为一个字段，另外增加了一个idStr字段用来判断数据的唯一性，避免重复存储。
首先定义一个工具类XLDataBase来做数据库相关的操作，这里用的是第三方的FMDB。</p>

<pre><code>#import "XLDataBase.h"
#import "FMDatabase.h"
#import "Item.h"
#import "MJExtension.h"
@implementation XLDataBase
static FMDatabase *_db;
+ (void)initialize {
    NSString *path = [NSString stringWithFormat:@"%@/Library/Caches/Data.db",NSHomeDirectory()];
    _db = [FMDatabase databaseWithPath:path];
    [_db open];
    [_db executeUpdate:@"CREATE TABLE IF NOT EXISTS t_item (id integer PRIMARY KEY, itemDict blob NOT NULL, idStr text NOT NULL)"];
}
//存入数据库
+ (void)saveItemDict:(NSDictionary *)itemDict {
    //此处把字典归档成二进制数据直接存入数据库，避免添加过多的数据库字段
    NSData *dictData = [NSKeyedArchiver archivedDataWithRootObject:itemDict];
    [_db executeUpdateWithFormat:@"INSERT INTO t_item (itemDict, idStr) VALUES (%@, %@)",dictData, itemDict[@"id"]];
}
//返回全部数据
+ (NSArray *)list {
    FMResultSet *set = [_db executeQuery:@"SELECT * FROM t_item"];
    NSMutableArray *list = [NSMutableArray array];
    while (set.next) {
        // 获得当前所指向的数据
        NSData *dictData = [set objectForColumnName:@"itemDict"];
        NSDictionary *dict = [NSKeyedUnarchiver unarchiveObjectWithData:dictData];
        [list addObject:[Item mj_objectWithKeyValues:dict]];
    }
    return list;
}
//取出某个范围内的数据
+ (NSArray *)listWithRange:(NSRange)range {
    NSString *SQL = [NSString stringWithFormat:@"SELECT * FROM t_item LIMIT %lu, %lu",range.location, range.length];
    FMResultSet *set = [_db executeQuery:SQL];
    NSMutableArray *list = [NSMutableArray array];
    while (set.next) {
        NSData *dictData = [set objectForColumnName:@"itemDict"];
        NSDictionary *dict = [NSKeyedUnarchiver unarchiveObjectWithData:dictData];
        [list addObject:[Item mj_objectWithKeyValues:dict]];
    }
    return list;
}
//通过一组数据的唯一标识判断数据是否存在
+ (BOOL)isExistWithId:(NSString *)idStr
{
    BOOL isExist = NO;
    FMResultSet *resultSet= [_db executeQuery:@"SELECT * FROM t_item where idStr = ?",idStr];
    while ([resultSet next]) {
        if([resultSet stringForColumn:@"idStr"]) {
            isExist = YES;
        }else{
            isExist = NO;
        }
    }
    return isExist;
}
@end
</code></pre>

<p>一些继承于XLDataService的子类的数据库存储和模型转换的逻辑代码</p>

<pre><code>#import "GetTableViewData.h"
#import "XLDataBase.h"
@implementation GetTableViewData
//重写父类方法
+ (id)modelTransformationWithResponseObj:(id)responseObj modelClass:(Class)modelClass {
    NSArray *lists = responseObj[@"data"][@"list"];
    NSMutableArray *array = [NSMutableArray array];
    for (NSDictionary *dict in lists) {
        [modelClass mj_setupReplacedKeyFromPropertyName:^NSDictionary *{
            return @{ @"ID" : @"id" };
        }];
        [array addObject:[modelClass mj_objectWithKeyValues:dict]];
        //通过idStr先判断数据是否存储过，如果没有，网络请求新数据存入数据库
        if (![XLDataBase isExistWithId:dict[@"id"]]) {
            //存数据库
            NSLog(@"存入数据库");
            [XLDataBase saveItemDict:dict];
        }
    }
    return array;
}
</code></pre>

<p>下面是一些控制器的代码实现：</p>

<pre><code>#import "ViewController.h"
#import "GetTableViewData.h"
#import "Item.h"
#import "XLDataBase.h"
#import "ItemCell.h"
#import "MJRefresh.h"
#define URL_TABLEVIEW @"https://api.108tian.com/mobile/v3/EventList?cityId=1&amp;step=10&amp;theme=0&amp;page=%lu"
@interface ViewController () {
    NSMutableArray *_dataArray;
    UITableView *_tableView;
    NSInteger _currentPage;//当前数据对应的page
}
@end
@implementation ViewController
#pragma mark Life cycle
- (void)viewDidLoad {
    [super viewDidLoad];
    // Do any additional setup after loading the view, typically from a nib.
    [self createTableView];
    _dataArray = [NSMutableArray array];
}
- (void)viewWillAppear:(BOOL)animated {
    [super viewWillAppear:animated];
    NSRange range = NSMakeRange(0, 10);
    //如果数据库有数据则读取，不发送网络请求
    if ([[XLDataBase listWithRange:range] count]) {
        [_dataArray addObjectsFromArray:[XLDataBase listWithRange:range]];
        NSLog(@"从数据库加载");
    }else{
        [self getTableViewDataWithPage:0];
    }
}
#pragma mark UI
- (void)createTableView {
    _tableView = [[UITableView alloc] initWithFrame:self.view.bounds];
    _tableView.delegate = self;
    _tableView.dataSource = self;
    _tableView.rowHeight = 100.0;
    [self.view addSubview:_tableView];
    _tableView.mj_header = [MJRefreshNormalHeader headerWithRefreshingBlock:^{
        [self loadNewData];
    }];
    _tableView.mj_footer = [MJRefreshAutoNormalFooter footerWithRefreshingBlock:^{
        [self loadMoreData];
    }];
}
#pragma mark GetDataSoure
- (void)getTableViewDataWithPage:(NSInteger)page {
    NSLog(@"发送网络请求！");
    NSString *url = [NSString stringWithFormat:URL_TABLEVIEW, page];
    [GetTableViewData getWithUrl:url param:nil modelClass:[Item class] responseBlock:^(id dataObj, NSError *error) {
        [_dataArray addObjectsFromArray:dataObj];
        [_tableView reloadData];
        [_tableView.mj_header endRefreshing];
        [_tableView.mj_footer endRefreshing];
    }];
}
- (void)loadNewData {
    NSLog(@"下拉刷新");
    _currentPage = 0;
    [_dataArray removeAllObjects];
    [self getTableViewDataWithPage:_currentPage];
}
- (void)loadMoreData {
    NSLog(@"上拉加载");
    _currentPage ++;
    NSRange range = NSMakeRange(_currentPage * 10, 10);
    if ([[XLDataBase listWithRange:range] count]) {
        [_dataArray addObjectsFromArray:[XLDataBase listWithRange:range]];
        [_tableView reloadData];
        [_tableView.mj_footer endRefreshing];
        NSLog(@"数据库加载%lu条更多数据",[[XLDataBase listWithRange:range] count]);
    }else{
        //数据库没更多数据时再网络请求
        [self getTableViewDataWithPage:_currentPage];
    }
}
#pragma mark UITableViewDataSource
- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section {
    return _dataArray.count;
}
- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {
    ItemCell *cell = [ItemCell itemCellWithTableView:tableView];
    cell.item = _dataArray[indexPath.row];
    return cell;
}
@end
</code></pre>

<p>最后附上代码的下载地址，重要的部分代码中都有相应的注释和文字打印，运行程序可以很直观的表现。</p>

<p><a href="https://github.com/ShelinShelin/OffLineCache.git">Demo</a></p>

<p>希望大家能提出一些意见，很乐意与大家互相交流。</p>

<!--more-->

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ScrollView回到顶部复原]]></title>
    <link href="http://al1020119.github.io/blog/2015/08/21/scrollviewhui-dao-ding-bu-fu-yuan/"/>
    <updated>2015-08-21T02:33:00+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/08/21/scrollviewhui-dao-ding-bu-fu-yuan</id>
    <content type="html"><![CDATA[<p>相信细心的开发者都会发现scrollView自带一个功能,当用户点击顶部的状态栏时,scrollView的ContentOffset.y轴会自动滚动到初始位置,效果如图所示:</p>

<!--more-->


<blockquote><p>单个scrollView单击顶部状态栏系统自带功能展示</p></blockquote>

<p>这个功能对用户来说非常实用,尤其是在scrollView(TableView, WebView, CollectionView一切继承scrollView的控件)展示的内容很多,当用户翻看很久以后,想回到最顶部时,只需单击一下顶部的状态栏位置就可以轻松返回到顶部(这里吐槽下.貌似很多用户都不知道有这个功能),而不用使劲用手滑动到顶部.</p>

<ul>
<li>可是功能在当前控制器有多个scrollView(TableView, WebView, CollectionView一切继承scrollView的控件)的时候就会失效,效果如下图所示:</li>
</ul>


<p>当控制器内有多个scrollView时,系统自带的滚动到顶的功能就会失效</p>

<p>实际开发中,我们的产品在同一个控制器经常会有多个scrollView组合在一起的情况,这就意味着系统的方法已经失效了,需要开发人员自己来实现这个效果,下面我们就来搞定这个需求</p>

<blockquote><p>我们分析下原生的方法为什么会失效,当一个控制器内只有一个scrollView时,点击状态栏,系统会遍历当前keyWindow的子控件,发现子控件中只有一个scrollView会调用这个scrollView的setContentOffset: animated:的这个方法,将scrollView的contentOffset.y值修改为初始值,但是当子控件中又多个scrollView时,系统会不知道掉用哪一个scrollView而失效,知道这点我们就知道该如何搞定这个问题了</p></blockquote>

<p>这里就直接将解决思路一一写出来不将代码分段展示了,在代码中我加了详细的注释objective-c的套路和swift基本一样,在最后会将Swift和objective-c的代码一起放上,如果需要直接解决问题的童鞋可以直接将代码拷贝到工程里即可</p>

<ul>
<li>首先创建一个topWindow继承至NSObject,这里我们考虑将这个功能完全封装起来,所以所有的方法都用的类方法,所以用最基本的类就可以</li>
<li>在initialize方法中初始化topWIndow,将topWIndow的级别改成最高的UIWindowLevelAlert级别,设置topWindow位置,并且添加点击手势</li>
<li>在topWIndow被点击调用的方法中,我们拿出UIApplication的keyWindow,遍历keyWindow的所有子控件,如果满足是scrollView同时又显示在当前keyWindow条件时,将subView的contentOffset的y值回复到原始</li>
<li>然后采用递归的套路在遍历subView内时候有满足条件的子控件,直到没有满足条件时会停止</li>
</ul>


<h4>Swift的代码</h4>

<pre><code>import UIKit
class TopWindow: UIWindow {
    private static let window_: UIWindow = UIWindow()
    ///  类初始化方法,保证window_只被创建一次
    override class func initialize() {
        window_.frame = CGRectMake(0, 0, global.appWidth, 20)
        window_.windowLevel = UIWindowLevelAlert
        window_.addGestureRecognizer(UITapGestureRecognizer(target: self, action: "topWindowClick"))
    }
    class func topWindowClick() {
        // 遍历当前主窗口所有view,将满足条件的scrollView滚动回原位
        searchAllowScrollViewInView(UIApplication.sharedApplication().keyWindow!)
    }
    private class func searchAllowScrollViewInView(superView: UIView) {
        for subview: UIView in superView.subviews as! [UIView] {
            if subview.isKindOfClass(UIScrollView.self) &amp;&amp; superView.viewIsInKeyWindow() {
                // 拿到scrollView的contentOffset
                var offest = (subview as! UIScrollView).contentOffset
                // 将offest的y轴还原成最开始的值
                offest.y = -(subview as! UIScrollView).contentInset.top
                // 重新设置scrollView的内容
                (subview as! UIScrollView).setContentOffset(offest, animated: true)
            }
            // 递归,让子控件再次调用这个方法判断时候还有满足条件的view
            searchAllowScrollViewInView(subview)
        }
    }
    ///  添加topWindow,使手势生效
    class func showTopWindow() {
        window_.hidden = false
    }
    ///  隐藏topWindow,移除手势
    class func hiddenTopWindow() {
        window_.hidden = true
    }
}
///  对UIView的一个扩展
extension UIView {
    ///  判断调用方法的view是否在keyWindow中
    func viewIsInKeyWindow() -&gt; Bool {
        let keyWindow = UIApplication.sharedApplication().keyWindow!
        // 将当前view的坐标系转换到window.bounds
        let viewNewFrame = keyWindow.convertRect(self.frame, fromView: self.superview)
        let keyWindowBounds = keyWindow.bounds
        // 判断当前view是否在keyWindow的范围内
        let isIntersects = CGRectIntersectsRect(viewNewFrame, keyWindowBounds)
        // 判断是否满足所有条件
        return !self.hidden &amp;&amp; self.alpha &gt; 0.01 &amp;&amp; self.window == keyWindow &amp;&amp; isIntersects
    }   
}
</code></pre>

<p>在AppDelegate里,程序启动完成方法时添加就OK了</p>

<pre><code>  func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -&gt; Bool {
      // 添加顶部的window
      TopWindow.showTopWindow()
      return true
  }
</code></pre>

<p>需要注意添加了自定义的window后,控制器的改变状态栏状态方法会失效,可以在info.plist中将改变状态栏的管理权交给UIApplication解决,或者在需要改变状态栏的控制器中调用TopWindow.hiddenTopWindow()即可,或者直接改info.plist,用UIApplication.sharedApplication().setStatusBarStyle来管理</p>

<h4>Objective-C代码</h4>

<p>.h文件只暴露显示和隐藏方法</p>

<pre><code>#import @interface WNXTopWindow : NSObject
+ (void)show;
+ (void)hide;
@end
</code></pre>

<p>.m文件</p>

<pre><code>#import "WNXTopWindow.h"
@implementation WNXTopWindow
static UIWindow *window_;
//初始化window
+ (void)initialize {
  window_ = [[UIWindow alloc] init];
  window_.frame = CGRectMake(0, 0, [UIScreen mainScreen].bounds.size.width, 20);
  window_.windowLevel = UIWindowLevelAlert;
  [window_ addGestureRecognizer:[[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(windowClick)]];
}  
+ (void)show {
  window_.hidden = NO;
}
+ (void)hide {
  window_.hidden = YES;
}
// 监听窗口点击
+ (void)windowClick {
  UIWindow *window = [UIApplication sharedApplication].keyWindow;
  [self searchScrollViewInView:window];
}
+ (void)searchScrollViewInView:(UIView *)superview {
  for (UIScrollView *subview in superview.subviews) {
      // 如果是scrollview, 滚动最顶部
      if ([subview isKindOfClass:[UIScrollView class]] &amp;&amp; [subview isShowingOnKeyWindow]) {
          CGPoint offset = subview.contentOffset;
          offset.y = - subview.contentInset.top;
          [subview setContentOffset:offset animated:YES];
      }
      // 递归继续查找子控件
      [self searchScrollViewInView:subview];
  }
}
+ (BOOL)isShowingOnKeyWindow:(UIView *)view {
  // 主窗口
  UIWindow *keyWindow = [UIApplication sharedApplication].keyWindow;
  // 以主窗口左上角为坐标原点, 计算self的矩形框
  CGRect newFrame = [keyWindow convertRect:view.frame fromView:view.superview];
  CGRect winBounds = keyWindow.bounds;
  // 主窗口的bounds 和 self的矩形框 是否有重叠
  BOOL intersects = CGRectIntersectsRect(newFrame, winBounds);
  return !view.isHidden &amp;&amp; view.alpha &gt; 0.01 &amp;&amp; view.window == keyWindow &amp;&amp; intersects;
}
@end
</code></pre>

<p>同样,也是在程序初始化完成AppDelegate文件中显示topWindow,整个工程这个问题就统统解决了</p>

<pre><code>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
  // 添加一个window, 点击这个window, 可以让屏幕上的scrollView滚到最顶部
  [WNXTopWindow show];
  return YES;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[KeyChain初探]]></title>
    <link href="http://al1020119.github.io/blog/2015/07/20/keychainchu-tan/"/>
    <updated>2015-07-20T22:46:16+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/07/20/keychainchu-tan</id>
    <content type="html"><![CDATA[<p>iOS的keychain服务提供了一种安全的保存私密信息（密码，序列号，证书等）的方式，每个ios程序都有一个独立的keychain存储。相对于NSUserDefaults、文件保存等一般方式，keychain保存更为安全，而且keychain里保存的信息不会因App被删除而丢失，所以在重装App后，keychain里的数据还能使用。</p>

<blockquote><p>“yourAppID.com.yourCompany.whatever”就是你要起的公共区名称，除了whatever字段可以随便定之外，其他的都必须如实填写。这个文件的路径要配置在 Project->build setting->Code Signing Entitlements里，否则公共区无效，配置好后，须用你正式的证书签名编译才可通过，否则xcode会弹框告诉你code signing有问题。所以，苹果限制了你只能同公司的产品共享KeyChain数据，别的公司访问不了你公司产品的KeyChain。</p></blockquote>

<!--more-->


<h3>一.基本知识</h3>

<h6>1.方法</h6>

<ul>
<li>SecItemAdd 增</li>
<li>SecItemUpdate 改</li>
<li>SecItemDelete 删</li>
<li>SecItemCopyMatching 查</li>
</ul>


<h6>2.权限</h6>

<p>文档上说iOS的keyChain是一个相对独立的空间，当程序替换，删除时并不会删除keyChain的内容，这个要比Library/Cache好。刷机，恢复出厂应该就没有了。关于备份，只会备份数据，到那时不会备份设备的密钥，换句话说，即使拿到数据，也没有办法解密里面的内容。有人说似乎破解的手机就能破解keyChain,本人并不清楚，希望有大神能指教。但个人认为，keyChain只是沙盒的升级版，可以存放一些非私密的信息，即使破解也不影响其它用户，只影响那个破解了的设备。（比如针对该设备的一个密钥）。</p>

<p>可访问性一般来说，自己的程序只能访问自己的keychain,相同bundle的程序通过设置group可以互相共享同组的keychain，从而实现程序间可以共同访问一些数据。详细后面介绍一些我测试下来的经验。</p>

<h6>3.如何查询keyChain</h6>

<pre><code>[objc] view plaincopyprint?在CODE上查看代码片派生到我的代码片
genericPasswordQuery = [[NSMutableDictionary alloc] init];   
[genericPasswordQuery setObject:(id)kSecClassGenericPassword forKey:(id)kSecClass];//1  
[genericPasswordQuery setObject:identifier forKey:(id)kSecAttrGeneric];//2  
if (accessGroup != nil){  
    [genericPasswordQuery setObject:accessGroup forKey:(id)kSecAttrAccessGroup];//3  
}  
[genericPasswordQuery setObject:(id)kSecMatchLimitOne forKey:(id)kSecMatchLimit];//4  
[genericPasswordQuery setObject:(id)kCFBooleanTrue forKey:(id)kSecReturnAttributes];//5  
NSDictionary *tempQuery = [NSDictionary dictionaryWithDictionary:genericPasswordQuery];  
NSMutableDictionary *outDictionary = nil;      
if (SecItemCopyMatching((CFDictionaryRef)tempQuery, (CFTypeRef *)&amp;outDictionary) == noErr){//6  
//found and outDicitionary is not nil  
}else{  
//not found  
}  
</code></pre>

<ul>
<li>1.设置Class值，每个Class对应的都有不同的参数类型</li>
<li>2.用户确定的参数，一般是程序中使用的类别，比如说是"Password"或"Account Info"，作为search的主力条件</li>
<li>3.设置Group,如果不同程序都拥有这个组，那么不同程序间可以共享这个组的数据</li>
<li>4.只返回第一个匹配数据，查询方法使用，还有值kSecMatchLimitAll</li>
<li>5.返回数据为CFDicitionaryRef，查询方法使用</li>
<li>6.执行查询方法，判断返回值</li>
</ul>


<blockquote><p>eg:这个是none-ARC的代码哦！ARC情况下会有bridge提示。</p></blockquote>

<h6>4.类型转换</h6>

<p>介绍增删改方法调用前，先介绍转换方法，如何将NSDictionary转换成KeyChain方法可以设置的Dicitionary，一般在写程序过程中，应该尽量避免直接访问KeyChain，一般会创建一个NSDictionary来同步对应的数据，所以两者需要做转换。</p>

<pre><code>//data to secItem  
- (NSMutableDictionary *)dictionaryToSecItemFormat:(NSDictionary *)dictionaryToConvert  
{  
    // Create a dictionary to return populated with the attributes and data.  
    NSMutableDictionary *returnDictionary = [NSMutableDictionary dictionaryWithDictionary:dictionaryToConvert];  

    //设置kSecClass  
    [returnDictionary setObject:(id)kSecClassGenericPassword forKey:(id)kSecClass];  
    //将Dictionary里的kSecValueData(一般就是这个keyChain里主要内容，比如说是password),NSString转换成NSData  
    NSString *passwordString = [dictionaryToConvert objectForKey:(id)kSecValueData];  
    [returnDictionary setObject:[passwordString dataUsingEncoding:NSUTF8StringEncoding] forKey:(id)kSecValueData];  
    return returnDictionary;  
}  
//secItem to data  
- (NSMutableDictionary *)secItemFormatToDictionary:(NSDictionary *)dictionaryToConvert  
{  
    NSMutableDictionary *returnDictionary = [NSMutableDictionary dictionaryWithDictionary:dictionaryToConvert];  

    // Add the proper search key and class attribute.  
    [returnDictionary setObject:(id)kCFBooleanTrue forKey:(id)kSecReturnData];  
    [returnDictionary setObject:(id)kSecClassGenericPassword forKey:(id)kSecClass];  

    // Acquire the password data from the attributes.  
    NSData *passwordData = NULL;  
    if (SecItemCopyMatching((CFDictionaryRef)returnDictionary, (CFTypeRef *)&amp;passwordData) == noErr)  
    {  
        // 删除多余的kSecReturnData数据  
        [returnDictionary removeObjectForKey:(id)kSecReturnData];  

        // 对应前面的步骤，将数据从NSData转成NSString  
        NSString *password = [[[NSString alloc] initWithBytes:[passwordData bytes] length:[passwordData length]  
                                                     encoding:NSUTF8StringEncoding] autorelease];  
        [returnDictionary setObject:password forKey:(id)kSecValueData];  
    }  
    else  
    {  
        NSAssert(NO, @"Serious error, no matching item found in the keychain.\n");  
    }  
    [passwordData release];   
    return returnDictionary;  
}  
</code></pre>

<h6>5.增删改</h6>

<p>用代码来说明</p>

<pre><code>- (void)writeToKeychain  
{  
    NSDictionary *attributes = NULL;  
    NSMutableDictionary *updateItem = NULL;  
    OSStatus result;  
    //判断是增还是改  
    if (SecItemCopyMatching((CFDictionaryRef)genericPasswordQuery, (CFTypeRef *)&amp;attributes) == noErr)  
    {  
            // First we need the attributes from the Keychain.  
            updateItem = [NSMutableDictionary dictionaryWithDictionary:attributes];  
        // Second we need to add the appropriate search key/values.  
            [updateItem setObject:[genericPasswordQuery objectForKey:(id)kSecClass] forKey:(id)kSecClass];  
            // Lastly, we need to set up the updated attribute list being careful to remove the class.  
            NSMutableDictionary *tempCheck = [self dictionaryToSecItemFormat:keychainItemData];  
            //删除kSecClass update不能update该字段，否则会报错  
            [tempCheck removeObjectForKey:(id)kSecClass];  
        //参数1表示search的，参数2表示需要更新后的值  
            result = SecItemUpdate((CFDictionaryRef)updateItem, (CFDictionaryRef)tempCheck);  
    }else{  
            //增加  
            result = SecItemAdd((CFDictionaryRef)[self dictionaryToSecItemFormat:keychainItemData], NULL);  
    }  
}  
</code></pre>

<p>删除很简单，就不写注释了</p>

<pre><code>- (void)resetKeychainItem  
{  
    OSStatus junk = noErr;  
    if (!keychainItemData)  
    {  
        self.keychainItemData = [[NSMutableDictionary alloc] init];  
    }  
    else if (keychainItemData)  
    {  
        NSMutableDictionary *tempDictionary = [self dictionaryToSecItemFormat:keychainItemData];  
        junk = SecItemDelete((CFDictionaryRef)tempDictionary);  
        NSAssert( junk == noErr || junk == errSecItemNotFound, @"Problem deleting current dictionary." );  
    }  

    // Default attributes for keychain item.  
    [keychainItemData setObject:@"" forKey:(id)kSecAttrAccount];  
    [keychainItemData setObject:@"" forKey:(id)kSecAttrLabel];  
    [keychainItemData setObject:@"" forKey:(id)kSecAttrDescription];  

    // Default data for keychain item.  
    [keychainItemData setObject:@"" forKey:(id)kSecValueData];  
}  
</code></pre>

<p>二.Group的配置
配置Target的Code Signing Entitlements.</p>

<p><img src="http://al1020119.github.io/images/keyChain001.png" title="Caption" ></p>

<p>配置该文件</p>

<p><img src="http://al1020119.github.io/images/keyChain002.png" title="Caption" ></p>

<p><img src="http://al1020119.github.io/images/keyChain003.png" title="Caption" ></p>

<p>可以配置一个Array列表，表示该程序可以支持多个group
这样就可以在创建secItem时候添加kSecAttrAccessGroup了。
经过测试有以下经验同大家分享：</p>

<ul>
<li><p>1.相同bundle下生成的程序都可以共享相同group的keyChain.
相同bundle解释下就是：比如:2个程序分别使用的provision对应bundle是com.jv.key1和com.jv.key2，那你配置文件肯定是{Identifer}.com.jv.{name},其中identifer是苹果生成的随机串号，可以在申请证书时看到，复制过来即可，name可以自己取，程序中指定属于哪个Group即可。</p></li>
<li><p>2.如果你在 addkey时，没有指定group,则会默认添加你keychain-access-groups里第一个group，如果你没有设置Entitlements,则默认使用对应的程序的bundle name,比如com.jv.key1,表示只能给自己程序使用。</p></li>
<li><p>3.如果你程序添加的group并不存在你的配置文件中，程序会奔溃，表示无法添加。因此你只能添加你配置文件中支持的keychain。</p></li>
</ul>


<p>三、保存私密信息（工具）
在应用里使用使用keyChain，我们需要导入Security.framework ，keychain的操作接口声明在头文件SecItem.h里。直接使用SecItem.h里方法操作keychain，需要写的代码较为复杂，为减轻咱们程序员的开发，我们可以使用一些已经封装好了的工具类，下面我会简单介绍下我用过的两个工具类：KeychainItemWrapper和SFHFKeychainUtils。</p>

<p>（一）KeychainItemWrapper是apple官方例子“GenericKeychain”里一个访问keychain常用操作的封装类，在官网上下载了GenericKeychain项目后，只需要
把“KeychainItemWrapper.h”和“KeychainItemWrapper.m”拷贝到我们项目，并导入Security.framework 。KeychainItemWrapper的用法：</p>

<pre><code>/** 初始化一个保存用户帐号的KeychainItemWrapper */
KeychainItemWrapper *wrapper = [[KeychainItemWrapper alloc] initWithIdentifier:@"Account Number"
                                                                   accessGroup:@"YOUR_APP_ID_HERE.com.yourcompany.AppIdentifier"];  

//保存帐号
[
wrapper setObject:@"&lt;帐号&gt;" forKey:(id)kSecAttrAccount];    

//保存密码
[
wrapper setObject:@"&lt;帐号密码&gt;" forKey:(id)kSecValueData];    

//从keychain里取出帐号密码
NSString *password = [wrapper objectForKey:(id)kSecValueData];      

//清空设置
[
wrapper resetKeychainItem];
</code></pre>

<p>其中方法“- (void)setObject:(id)inObject forKey:(id)key;”里参数“forKey”的值应该是Security.framework 里头文件“SecItem.h”里定义好的key，用其他字符串做key程序会崩溃！</p>

<p>（二）SFHFKeychainUtils 提供了在 iOS keychain中安全的存储密码的工具</p>

<p>下载地址<a href="https://github.com/ldandersen/scifihifi-iphone/tree/master/security">https://github.com/ldandersen/scifihifi-iphone/tree/master/security</a></p>

<ul>
<li><p>1、引入Security.frameWork框架。</p></li>
<li><p>2、引入头文件：SFHKeychainUtils.h.</p></li>
<li><p>3、存密码：</p></li>
</ul>


<hr />

<pre><code>[SFHFKeychainUtils storeUsername:@"dd" andPassword:@"aa"forServiceName:SERVICE_NAME updateExisting:1 error:nil];

[SFHFKeychainUtils deleteItemForUsername:@"dd" andServiceName:SERVICE_NAME error:nil];
</code></pre>

<ul>
<li>4、取密码：</li>
</ul>


<hr />

<pre><code>NSString *passWord =  [SFHFKeychainUtils getPasswordForUsername:@"dd"andServiceName:SERVICE_NAME error:nil];
</code></pre>
]]></content>
  </entry>
  
</feed>
