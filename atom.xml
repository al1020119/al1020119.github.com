<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[iOS梦工厂]]></title>
  <link href="http://al1020119.github.io/atom.xml" rel="self"/>
  <link href="http://al1020119.github.io/"/>
  <updated>2016-10-14T11:47:02+08:00</updated>
  <id>http://al1020119.github.io/</id>
  <author>
    <name><![CDATA[iCocos]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS装逼篇——APO编程]]></title>
    <link href="http://al1020119.github.io/blog/2016/10/14/ioszhuang-bi-pian-apobian-cheng/"/>
    <updated>2016-10-14T11:45:17+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/10/14/ioszhuang-bi-pian-apobian-cheng</id>
    <content type="html"><![CDATA[<h4>实现原理</h4>

<ul>
<li>用Objective-C强大的runtime.</li>
</ul>


<p>我们知道当给一个对象发送一个方法的时候, 如果当前类和父类都没实现该方法的时候就会走转发流程</p>

<pre><code>动态方法解析 -&gt; 快速消息转发 -&gt; 标准消息转发
</code></pre>

<!--more-->


<h2>准备知识</h2>

<h3>准备知识一：Method,SEL,IMP概念</h3>

<h6>SEL</h6>

<pre><code> 先看一下SEL的概念，Objective-C在编译时，会依据每一个方法的名字、参数序列，生成一个唯一的整型标识(Int类型的地址)，这个标识就是SEL。

 SEL也是@selector的类型，用来表示OC运行时的方法的名字。来看一下OC中的定义
</code></pre>

<p><img src="http://al1020119.github.io/images/iosapo001.png" title="Caption" ></p>

<pre><code>  本质上，SEL只是一个指向方法的指针（准确的说，只是一个根据方法名hash化了的KEY值，能唯一代表一个方法），它的存在只是为了加快方法的查询速度。这个查找过程我们将在下面说明。
  我们可以在运行时添加新的selector，也可以在运行时获取已存在的selector。
</code></pre>

<h6>IMP</h6>

<pre><code>  实际上是一个函数指针，指向方法实现的首地址，定义如下：
</code></pre>

<p><img src="http://al1020119.github.io/images/iosapo002.png" title="Caption" ></p>

<h6>关于IMP的几点说明：</h6>

<p>使用当前CPU架构实现的标准的C调用约定</p>

<pre><code>第一个参数是指向self的指针（如果是实例方法，则是类实例的内存地址；如果是类方法，则是指向元类的指针）
第二个参数是方法选择器(selector)，
第三个参数开始是方法的实际参数列表。
</code></pre>

<p>通过取得IMP，我们可以跳过Runtime的消息传递机制，直接执行IMP指向的函数实现，这样省去了Runtime消息传递过程中所做的一系列查找操作，会比直接向对象发送消息高效一些，当然必须说明的是，这种方式只适用于极特殊的优化场景，如效率敏感的场景下大量循环的调用某方法。</p>

<h6>Method</h6>

<pre><code>  直接上定义：
</code></pre>

<p><img src="http://al1020119.github.io/images/iosapo003.png" title="Caption" ></p>

<pre><code>  Method = SEL + IMP + method_types，相当于在SEL和IMP之间建立了一个映射
</code></pre>

<p>相关方法：</p>

<pre><code>// 给 cls 添加一个新方法  
BOOL class_addMethod (  
   Class cls,  
   SEL name,  
   IMP imp,  
   const charchar *types  
);  

// 替换 cls 里的一个方法的实现  
IMP class_replaceMethod (  
   Class cls,  
   SEL name,  
   IMP imp,  
   const charchar *types  
);  

// 返回 cls 的指定方法  
Method class_getInstanceMethod (  
   Class cls,  
   SEL name  
);  

// 设置一个方法的实现  
IMP method_setImplementation (  
   Method m,  
   IMP imp  
);  

// 返回 cls 里的 name 方法的实现  
IMP class_getMethodImplementation (  
   Class cls,  
   SEL name  
);  
</code></pre>

<h3>准备知识二：iOS方法调用流程</h3>

<h6>方法调用的核心是objc_msgSend方法：</h6>

<pre><code>         objc_msgSend(receiver, selector, arg1,arg2,…)
</code></pre>

<p>具体的过程如下：</p>

<pre><code>        先找到selector 对应的方法实现(IMP)，因为同一个方法可能在不同的类中有不同的实现，所以需要receiver的类来找到确切的IMP

        IMP class_getMethodImplementation(Class class, SEL selector)
</code></pre>

<p>如同其文档所说：</p>

<pre><code>The function pointer returned may be a function internal to the runtime instead of an actual method implementation. For example, if instances of the class do not respond to the selector, the function pointer returned will be part of the runtime's message forwarding machinery.
</code></pre>

<p>具体来说，当找不到IMP的时候，方法返回一个 _objc_msgForward 对象，用来标记需要转入消息转发流程，我们现在用的AOP框架也是利用了这个机制来人为的制造找不到IMP的假象来触发消息转发的流程</p>

<p><img src="http://al1020119.github.io/images/iosapo004.png" title="Caption" ></p>

<pre><code>    如果实在对_objc_msgFroward的内部实现感兴趣，只能看看源码了，只不过都是汇编实现的....感兴趣的同学可以想想为什么是用汇编来实现
    这里有个源码的镜像https://github.com/opensource-apple ，如果翻墙费劲的话
</code></pre>

<p>根据查找结果</p>

<pre><code>    找到了IMP，调用找到的IMP，传入参数
    没找到IMP，转入消息转发流程
    将IMP的返回值作为自己的返回值
</code></pre>

<p>补充说明一下IMP的查找过程，消息传递的关键在于objc_class结构体中的以下几个东西：</p>

<pre><code>Class *isa
Class *super_class
objc_method_list **methodLists
objc_cache *cache
</code></pre>

<p>当消息发送给一个对象时，objc_msgSend通过对象的isa获取到类的结构体，然后在cache和methodLists中查找，如果没找到就找其父类，以此类推知道找到NSObject类，如果还没找到，就走消息转发流程。</p>

<h3>准备知识三：iOS方法转发流程</h3>

<pre><code>  从上文中我们看到当obj无法查找到 IMP时，会返回一个特定的IMP _objc_msgForward , 然后会进入消息转发流程，具体流程如下：
</code></pre>

<h6>动态方法解析</h6>

<pre><code>    resolveInstanceMethod:解析实例方法 
    resolveClassMethod:解析类方法
</code></pre>

<p>通过class_addMethod的方式将缺少的selector动态创建出来，前提是有提前实现好的IMP（method_types一致）</p>

<pre><code>    这种方案更多的是位@dynamic属性准备的
</code></pre>

<h6>备用接受者（AOP中有使用）</h6>

<p>如果上一步没有处理，runtime会调用以下方法</p>

<pre><code>        -(id)forwardingTargetForSelector:(SEL)aSelector
</code></pre>

<p>如果该方法返回非nil的对象，则使用该对象作为新的消息接收者，不能返回self，会出现无限循环</p>

<p>如果不知道该返回什么，应该使用[super forwardingTargetForSelector:aSelector]</p>

<p>这种方法属于单纯的转发，无法对消息的参数和返回值进行处理</p>

<h6>完整转发（AOP中有使用）</h6>

<pre><code>    - (void)forwardInvocation:(NSInvocation *)anInvocation
</code></pre>

<p>对象需要创建一个NSInvocation对象，把消息调用的全部细节封装进去，包括selector, target, arguments 等参数，还能够对返回结果进行处理
为了使用完整转发，需要重写以下方法</p>

<pre><code>        -(NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector，如果2中return nil,执行methodSignatureForSelector：
</code></pre>

<p>因为消息转发机制为了创建NSInvocation需要使用这个方法吗获取信息，重写它为了提供合适的方法签名</p>

<h2>AOP核心逻辑解析</h2>

<pre><code>    到了有意思的戏肉部分，打算用流程图的方式解析一下核心的两个流程：拦截器(intercepter)注册流程和拦截器(intercepter)执行流程。
</code></pre>

<h4>拦截器(intercepter)注册流程</h4>

<p><img src="http://al1020119.github.io/images/iosapo005.png" title="Caption" ></p>

<p>说明：（图中m:代表Method，ClassA是AOP的目标类，X是AOP的目标方法，AOPAspect是AOP处理类-单例）</p>

<pre><code>1. 将原始的X的IMP拿出来，以特定的命名规则动态加入AOPAspect
2. 将X的IMP替换为_objc_msgForward，用这种比较tricky的方式来触发消息转发流程
3. 将ClassA中原有的forwardingTargetForSelector:的IMP以特定的命名规则存入AOPAspect
4. 将ClassA的forwardingTargetForSelector：的IMP用AOPApect中的baseClassForwardingTargetForSelector替换，其中的具体逻辑见下面的代码

后边的就是将拦截器的信息和block存入到AOPAspect中，细节就不讲了，有兴趣的同学可以到github上看看原始版
</code></pre>

<p><img src="http://al1020119.github.io/images/iosapo006.png" title="Caption" ></p>

<h4>拦截器(intercepter)执行流程</h4>

<p><img src="http://al1020119.github.io/images/iosapo007.png" title="Caption" ></p>

<p>说明：（图中m:代表Method，ClassA是AOP的目标类，X是AOP的目标方法，AOPAspect是AOP处理类-单例,IMP是方法对应的实现）</p>

<p>开始调用，objc_msgSend开始查找SEL为X的IMP，查到结果为_objc_msgForward，触发ClassA的转发流程</p>

<pre><code>1. ClassA中转发流程调用forwardingTargetForSelector:，实际会调用替换上去的baseClassForwardingTargetForSelector:的IMP，这个IMP正常情况下会返回AOPAspect的单例作为target（代码见上文图）
2. 接下来开始在AOPAspect的单例中执行转发流程，经过一系列的3.1-3.5的跳转查找，最终会触发转发流程的forwardingInvocation方法

3. 在forwardingInvocation中触发一系列的interceptors的执行（包括原始的X的IMP），代码见下图
4. 后边的interceptor的执行细节也略过了，有兴趣的同学可以到github上看看原始版
</code></pre>

<p><img src="http://al1020119.github.io/images/iCocosPublic.jpg" title="Caption" ></p>

<h2>AOP案例</h2>

<p>这里举个例子,我们有个方法sumA:andB:, 用来返回ab之和的一个字串,我们在这个方法前和方法后都增加个一段代码</p>

<pre><code>在运行方法前我们把参数改成2和3, 当然这里是演示用,实际用的时候别改参数,不然其他同事真的要骂人了
在运行方法后我们输出传入的参数和返回值
</code></pre>

<p>在CODE上查看代码片派生到我的代码片</p>

<pre><code>- (void)clickTestAop:(id)sender  
{  
    AopTestM *test = [[AopTestM alloc] init];  
    NSLog(@"run1");  
    [test sumA:1 andB:2];  

    NSString *before = [XYAOP interceptClass:[AopTestM class] beforeExecutingSelector:@selector(sumA:andB:) usingBlock:^(NSInvocation *invocation) {  
        int a = 3;  
        int b = 4;  

        [invocation setArgument:&amp;a atIndex:2];  
        [invocation setArgument:&amp;b atIndex:3];  

        NSLog(@"berore fun. a = %d, b = %d", a , b);  
    }];  

    NSString *after =  [XYAOP interceptClass:[AopTestM class] afterExecutingSelector:@selector(sumA:andB:) usingBlock:^(NSInvocation *invocation) {  
        int a;  
        int b;  
        NSString *str;  

        [invocation getArgument:&amp;a atIndex:2];  
        [invocation getArgument:&amp;b atIndex:3];  
        [invocation getReturnValue:&amp;str];  

        NSLog(@"after fun. a = %d, b = %d, sum = %@", a , b, str);  
    }];  

    NSLog(@"run2");  
    [test sumA:1 andB:2];  

    [XYAOP removeInterceptorWithIdentifier:before];  
    [XYAOP removeInterceptorWithIdentifier:after];  

    NSLog(@"run3");  
    [test sumA:1 andB:2];  
}   

- (NSString *)sumA:(int)a andB:(int)b  
{  
    int value = a + b;  
    NSString *str = [NSString stringWithFormat:@"fun running. sum : %d", value];  
    NSLog(@"%@", str);  

    return str;  
}  
</code></pre>

<p>我们执行这段代码的时候,大伙猜猜结果是啥.结果如下</p>

<pre><code>2014-10-28 22:52:47.215 JoinShow[3751:79389] run1  
2014-10-28 22:52:52.744 JoinShow[3751:79389] fun running. sum : 3  
2014-10-28 22:52:52.745 JoinShow[3751:79389] run2  
2014-10-28 22:52:52.745 JoinShow[3751:79389] berore fun. a = 3, b = 4  
2014-10-28 22:52:52.745 JoinShow[3751:79389] fun running. sum : 7  
2014-10-28 22:52:52.745 JoinShow[3751:79389] after fun. a = 3, b = 4, sum = fun running. sum : 7  
2014-10-28 22:52:52.746 JoinShow[3751:79389] run3  
2014-10-28 22:52:52.746 JoinShow[3751:79389] fun running. sum : 3  
</code></pre>

<h2>AOP库</h2>

<p>一个简洁高效的用于使iOS支持AOP面向切面编程的库.它可以帮助你在不改变一个类或类实例的代码的前提下,有效更改类的行为.比iOS传统的 AOP方法,更加简单高效.支持在方法执行的前/后或替代原方法执行.曾经是 PSPDFKit 的一部分,PSPDFKit,在Dropbox和Evernote中都有应用,现在单独单独开源出来给大家使用.</p>

<h4>项目主页: Aspects</h4>

<p>最新实例:<a href="https://github.com/steipete/Aspects/archive/master.zip">点击下载</a></p>

<blockquote><p>注: AOP是一种完全不同于OOP的设计模式.更多信息,可以参考这里: AOP 百度百科</p></blockquote>

<h5>安装使用</h5>

<p>CocoaPods 安装</p>

<pre><code>pod "Aspects"
</code></pre>

<p>手动安装</p>

<pre><code>把文件 Aspects.h/m 拖到工程中即可.
</code></pre>

<h5>使用</h5>

<p>Aspects 用于支持AOP(面向切面编程)模式,用于部分解决OOP(面向对象)模式无法解决的特定问题.具体指的是那些在多个方法有交叉,无法或很难被有效归类的操作,比如:</p>

<pre><code>不论何时用户通过客户端获取服务器端数据,权限检查总是必须的.
不论何时用户和市场交互,总应该更具用户的操作提供相应地购买参考或相关商品.
所有需要日志记录的操作.
</code></pre>

<h5>接口概述</h5>

<p>Aspects 给 NSObject 扩展了下面的方法:</p>

<pre><code>/// 为一个指定的类的某个方法执行前/替换/后,添加一段代码块.对这个类的所有对象都会起作用.
///
/// @param block  方法被添加钩子时,Aspectes会拷贝方法的签名信息.
/// 第一个参数将会是 `id&lt;AspectInfo&gt;`,余下的参数是此被调用的方法的参数.
/// 这些参数是可选的,并将被用于传递给block代码块对应位置的参数.
/// 你甚至使用一个没有任何参数或只有一个`id&lt;AspectInfo&gt;`参数的block代码块.
///
/// @注意 不支持给静态方法添加钩子.
/// @return 返回一个唯一值,用于取消此钩子.
+ (id&lt;AspectToken&gt;)aspect_hookSelector:(SEL)selector
                      withOptions:(AspectOptions)options
                       usingBlock:(id)block
                            error:(NSError **)error;

/// 为一个指定的对象的某个方法执行前/替换/后,添加一段代码块.只作用于当前对象.
 - (id&lt;AspectToken&gt;)aspect_hookSelector:(SEL)selector withOptions:(AspectOptions)options usingBlock:(id)block error:(NSError **)error; - (id&lt;AspectToken&gt;)aspect_hookSelector:(SEL)selector withOptions:(AspectOptions)options usingBlock:(id)block error:(NSError **)error; 
/// 撤销一个Aspect 钩子.
/// @return YES 撤销成功, 否则返回 NO. 
id&lt;AspectToken&gt; aspect = ...; 
[aspect remove];
</code></pre>

<p>所有的调用,都会是线程安全的.Aspects 使用了Objective-C 的消息转发机会,会有一定的性能消耗.所有对于过于频繁的调用,不建议使用 Aspects.Aspects更适用于视图/控制器相关的等每秒调用不超过1000次的代码.</p>

<p>可以在调试应用时,使用Aspects动态添加日志记录功能.</p>

<pre><code>[UIViewController aspect_hookSelector:@selector(viewWillAppear:) withOptions:AspectPositionAfter usingBlock:^(id&lt;AspectInfo&gt; aspectInfo, BOOL animated) {
    NSLog(@"控制器 %@ 将要显示: %tu", aspectInfo.instance, animated);
} error:NULL];
</code></pre>

<p>使用它,分析功能的设置会很简单:</p>

<pre><code>https://github.com/orta/ARAnalytics
</code></pre>

<p>你可以在你的测试用例中用它来检查某个方法是否被真正调用(当涉及到继承或类目扩展时,很容易发生某个父类/子类方法未按预期调用的情况):</p>

<pre><code>- (void)testExample {
    TestClass *testClass = [TestClass new];
    TestClass *testClass2 = [TestClass new];

    __block BOOL testCallCalled = NO;
    [testClass aspect_hookSelector:@selector(testCall) withOptions:AspectPositionAfter usingBlock:^{
        testCallCalled = YES;
    } error:NULL];

    [testClass2 testCallAndExecuteBlock:^{
        [testClass testCall];
    } error:NULL];
    XCTAssertTrue(testCallCalled, @"调用testCallAndExecuteBlock 必须调用 testCall");
}
</code></pre>

<p>它对调试应用真的会提供很大的作用.这里我想要知道究竟何时轻击手势的状态发生变化(如果是某个你自定义的手势的子类,你可以重写setState:方法来达到类似的效果;但这里的真正目的是,捕捉所有的各类控件的轻击手势,以准确分析原因):</p>

<pre><code>[_singleTapGesture aspect_hookSelector:@selector(setState:) withOptions:AspectPositionAfter usingBlock:^(id&lt;AspectInfo&gt; aspectInfo) {
    NSLog(@"%@: %@", aspectInfo.instance, aspectInfo.arguments);
} error:NULL];
</code></pre>

<p>下面是一个你监测一个模态显示的控制器何时消失的示例.通常,你也可以写一个子类,来实现相似的效果,但使用 Aspects 可以有效减小你的代码量:</p>

<pre><code>@implementation UIViewController (DismissActionHook)

// Will add a dismiss action once the controller gets dismissed.
- (void)pspdf_addWillDismissAction:(void (^)(void))action {
    PSPDFAssert(action != NULL);

    [self aspect_hookSelector:@selector(viewWillDisappear:) withOptions:AspectPositionAfter usingBlock:^(id&lt;AspectInfo&gt; aspectInfo) {
        if ([aspectInfo.instance isBeingDismissed]) {
            action();
        }
    } error:NULL];
}

@end
</code></pre>

<h5>对调试的好处</h5>

<p>Aspectes 会自动标记自己,所有很容易在调用栈中查看某个方法是否已经调用:</p>

<p>在返回值不为void的方法上使用 Aspects</p>

<p>你可以使用 NSInvocation 对象类自定义返回值:</p>

<pre><code>[PSPDFDrawView aspect_hookSelector:@selector(shouldProcessTouches:withEvent:) withOptions:AspectPositionInstead usingBlock:^(id&lt;AspectInfo&gt; info, NSSet *touches, UIEvent *event) {
    // 调用方法原来的实现.
    BOOL processTouches;
    NSInvocation *invocation = info.originalInvocation;
    [invocation invoke];
    [invocation getReturnValue:&amp;processTouches];

    if (processTouches) {
        processTouches = pspdf_stylusShouldProcessTouches(touches, event);
        [invocation setReturnValue:&amp;processTouches];
    }
} error:NULL];
</code></pre>

<h5>兼容性与限制</h5>

<p>当应用于某个类时(使用类方法添加钩子),不能同时hook父类和子类的同一个方法;否则会引起循环调用问题.但是,当应用于某个类的示例时(使用实例方法添加钩子),不受此限制.
使用KVO时,最好在 aspect_hookSelector: 调用之后添加观察者;否则可能会引起崩溃.</p>

<hr />

<pre><code>Q Q：2211523682/790806573

微信：18370997821/13148454507

微博WB:http://weibo.com/u/3288975567?is_hot=1

git博文：http://al1020119.github.io/

github：https://github.com/al1020119
</code></pre>

<p><img src="http://al1020119.github.io/images/iCocosCoder.jpg" title="Caption" ></p>

<p><img src="http://al1020119.github.io/images/iCocosPublic.jpg" title="Caption" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS大神之路——应有尽有]]></title>
    <link href="http://al1020119.github.io/blog/2016/10/13/iosda-shen-zhi-lu-ying-you-jin-you/"/>
    <updated>2016-10-13T18:39:20+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/10/13/iosda-shen-zhi-lu-ying-you-jin-you</id>
    <content type="html"><![CDATA[<h3>目录</h3>

<ul>
<li><a href="#UI">UI</a>

<ul>
<li><a href="#%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0">下拉刷新</a></li>
<li><a href="#%E6%A8%A1%E7%B3%8A%E6%95%88%E6%9E%9C">模糊效果</a></li>
<li><a href="#AutoLayout">AutoLayout</a></li>
<li><a href="#%E5%AF%8C%E6%96%87%E6%9C%AC">富文本</a></li>
<li><a href="#%E5%9B%BE%E8%A1%A8">图表</a></li>
<li><a href="#%E8%A1%A8%E7%9B%B8%E5%85%B3%E4%B8%8ETabbar">表相关与Tabbar</a></li>
<li><a href="#%E9%9A%90%E8%97%8F%E4%B8%8E%E6%98%BE%E7%A4%BA">隐藏与显示</a></li>
<li><a href="#HUD%E4%B8%8EToast">HUD与Toast</a></li>
<li><a href="#%E5%AF%B9%E8%AF%9D%E6%A1%86">对话框</a></li>
<li><a href="#%E5%85%B6%E4%BB%96UI">其他UI</a></li>
</ul>
</li>
<li><a href="#%E5%8A%A8%E7%94%BB">动画</a>

<ul>
<li><a href="#%E4%BE%A7%E6%BB%91%E4%B8%8E%E5%8F%B3%E6%BB%91%E8%BF%94%E5%9B%9E%E6%89%8B%E5%8A%BF">侧滑与右滑返回手势</a></li>
<li><a href="#gif%E5%8A%A8%E7%94%BB">gif动画</a></li>
<li><a href="#%E5%85%B6%E4%BB%96%E5%8A%A8%E7%94%BB">其他动画</a></li>
</ul>
</li>
<li><a href="#%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3">网络相关</a>

<ul>
<li><a href="#%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5">网络连接</a></li>
<li><a href="#%E5%9B%BE%E5%83%8F%E8%8E%B7%E5%8F%96">图像获取</a></li>
<li><a href="#%E7%BD%91%E7%BB%9C%E8%81%8A%E5%A4%A9">网络聊天</a></li>
<li><a href="#%E7%BD%91%E7%BB%9C%E6%B5%8B%E8%AF%95">网络测试</a></li>
<li><a href="#WebView">WebView</a></li>
</ul>
</li>
<li><a href="#Model">Model</a></li>
<li><a href="#%E9%80%9A%E8%AE%AF%E5%BD%95">通讯录</a></li>
<li><a href="#%E5%85%B6%E4%BB%96">其他</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93">数据库</a></li>
<li><a href="#%E7%BC%93%E5%AD%98%E5%A4%84%E7%90%86">缓存处理</a></li>
<li><a href="#PDF">PDF</a></li>
<li><a href="#%E5%9B%BE%E5%83%8F%E6%B5%8F%E8%A7%88%E5%8F%8A%E5%A4%84%E7%90%86">图像浏览及处理</a></li>
<li><a href="#%E6%91%84%E5%83%8F%E7%85%A7%E7%9B%B8%E8%A7%86%E9%A2%91%E9%9F%B3%E9%A2%91%E5%A4%84%E7%90%86">摄像照相视频音频处理</a></li>
<li><a href="#%E5%93%8D%E5%BA%94%E5%BC%8F%E6%A1%86%E6%9E%B6">响应式框架</a></li>
<li><a href="#%E6%B6%88%E6%81%AF%E7%9B%B8%E5%85%B3">消息相关</a>

<ul>
<li><a href="#%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E5%AE%A2%E6%88%B7%E7%AB%AF">消息推送客户端</a></li>
<li><a href="#%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF">消息推送服务器端</a></li>
<li><a href="#%E9%80%9A%E7%9F%A5%E7%9B%B8%E5%85%B3">通知相关</a></li>
</ul>
</li>
<li><a href="#%E7%89%88%E6%9C%AC%E6%96%B0API%E7%9A%84Demo">版本新API的Demo</a></li>
<li><a href="#%E4%BB%A3%E7%A0%81%E5%AE%89%E5%85%A8%E4%B8%8E%E5%AF%86%E7%A0%81">代码安全与密码</a></li>
<li><a href="#%E6%B5%8B%E8%AF%95%E5%8F%8A%E8%B0%83%E8%AF%95">测试及调试</a></li>
<li><a href="#AppleWatch">AppleWatch</a></li>
<li><a href="#%E5%AE%8C%E6%95%B4%E9%A1%B9%E7%9B%AE">完整项目</a></li>
<li><a href="#%E5%A5%BD%E7%9A%84%E6%96%87%E7%AB%A0">好的文章</a></li>
<li><a href="#VPN">VPN</a></li>
<li><a href="#Xcode%E6%8F%92%E4%BB%B6">Xcode插件</a></li>
<li><a href="#%E7%BE%8E%E5%B7%A5%E8%B5%84%E6%BA%90">美工资源</a></li>
<li><a href="#%E5%BC%80%E5%8F%91%E8%B5%84%E6%BA%90">开发资源</a>

<ul>
<li><a href="#%E5%BC%80%E5%8F%91%E8%B5%84%E6%96%99">开发资料</a></li>
<li><a href="#swift">swift</a></li>
<li><a href="#%E4%BB%96%E4%BA%BA%E5%BC%80%E6%BA%90%E6%80%BB%E7%BB%93">他人开源总结</a></li>
<li><a href="#%E4%B8%AD%E6%96%87%E5%BC%80%E5%8F%91%E5%8D%9A%E5%AE%A2%E5%88%97%E8%A1%A8">中文开发博客列表</a></li>
</ul>
</li>
</ul>


<hr />

<h3>具体内容 =============================</h3>

<hr />

<h4>UI</h4>

<h5>下拉刷新</h5>

<ul>
<li><a href="https://github.com/enormego/EGOTableViewPullRefresh">EGOTableViewPullRefresh</a> - 最早的下拉刷新控件。</li>
<li><a href="https://github.com/samvermette/SVPullToRefresh">SVPullToRefresh</a> - 下拉刷新控件。</li>
<li><a href="https://github.com/CoderMJLee/MJRefresh">MJRefresh</a> - 仅需一行代码就可以为UITableView或者CollectionView加上下拉刷新或者上拉刷新功能。可以自定义上下拉刷新的文字说明。具体使用看“使用方法”。 （国人写）</li>
<li><a href="https://github.com/xhzengAIB/XHRefreshControl">XHRefreshControl</a> - XHRefreshControl 是一款高扩展性、低耦合度的下拉刷新、上提加载更多的组件。（国人写）</li>
<li><a href="https://github.com/coolbeet/CBStoreHouseRefreshControl">CBStoreHouseRefreshControl</a> - 一个效果很酷炫的下拉刷新控件。</li>
<li><a href="https://github.com/dasdom/BreakOutToRefresh">BreakOutToRefresh</a> - 一个下拉刷新打砖块的开源 Swift 库，能让用户在等待下拉刷新的时候边玩撞球游戏边等待。</li>
<li><a href="https://github.com/KittenYang/KYJellyPullToRefresh">KYJellyPullToRefresh</a> - 实现弹性物理效果的下拉刷新，神奇的贝塞尔曲线，配合UIDynamic写的一个拟物的下拉刷新动画。</li>
<li><a href="https://github.com/michaelhenry/MHYahooParallaxView">MHYahooParallaxView</a> - 类似于Yahoo Weather和News Digest首屏的视差滚动。</li>
<li><a href="https://github.com/gsdios/SDRefreshView">SDRefreshView</a> - 简单易用的上拉和下拉刷新（多版本细节适配）。</li>
<li><a href="https://github.com/MakeZL/ZLSwiftRefresh">ZLSwiftRefresh</a> - swift下拉刷新/上拉加载更多，支持自定义动画，集成简单，兼容UITableView/CollectionView/ScrollView/WebView。</li>
<li><a href="https://github.com/dasdom/BreakOutToRefresh">BreakOutToRefresh</a> - swift，上拉和下拉刷新。</li>
<li><a href="https://github.com/andreamazz/GearRefreshControl">GearRefreshControl</a> -  swift，上拉和下拉刷新。</li>
<li><a href="https://github.com/jcavar/refresher">refresher</a> -  swift，上拉和下拉刷新。</li>
<li><a href="http://d.cocoachina.com/code/detail/237753">可展开/收缩的下拉菜单&ndash;SvpplyTable</a> -  一个可展开可收缩的下拉菜单，类似Svpply app。</li>
<li><a href="https://github.com/Sephiroth87/ODRefreshControl">ODRefreshControl</a> - 原iOS6上的橡皮糖刷新样式，很有意思。现在也很多大的 App 在用，比如虾米音乐和 QQ 客户端。</li>
<li><a href="https://github.com/Yalantis/PullToMakeSoup">PullToMakeSoup</a> - PullToMakeSoup, 自定义下拉刷新的动画效果：煮饭, Yalantis新作！</li>
<li><a href="https://github.com/cyndibaby905/TwitterCover">TwitterCover</a> -  Twitter iOS客户端的下拉封面模糊效果。</li>
<li><a href="https://github.com/MartinRGB/Replace-iOS">Replace-iOS</a> - Replace-iOS 让人眼前一亮的下拉刷新（iOS）。</li>
<li><a href="https://github.com/KittenYang/Animations">Animations</a> - 封装了一下，使用的时候只要两行代码。一些动画的飞机稿，都是一些单独分离出来的用于测试的子动画，现在统一归类一下。</li>
<li><a href="https://github.com/entotsu/PullToBounce">PullToBounce</a> - 下拉刷新的动画 for UIScrollView。</li>
<li><a href="https://github.com/li6185377/WaterDropRefresh">WaterDropRefresh</a> - 仿Path 水滴的下拉刷新效果 还有视差滚动。</li>
<li><a href="https://github.com/EnjoySR/ESRefreshControl">ESRefreshControl</a> - 仿新浪微博、百度外卖、网易新闻下拉刷新样式Demo（仅供参考）。</li>
<li><a href="https://github.com/alienjun/WaveRefresh">WaveRefresh</a> - 下拉刷新水波纹动画。</li>
<li><a href="https://github.com/gontovnik/DGElasticPullToRefresh">DGElasticPullToRefresh</a> - 是一款带有弹性效果的 iOS 下拉刷新组件。</li>
<li><a href="https://github.com/wuwen1030/CALayerAnimationDemoh">CALayerAnimationDemoh</a> - 双向注水动画下拉刷新组件,使用CALayer的mask实现。</li>
</ul>


<h5>模糊效果</h5>

<ul>
<li><a href="https://github.com/nicklockwood/FXBlurView">FXBlurView</a> - 是一个UIView子类，支持iOS5.0以上版本，支持静态、动态模糊效果，继承与UIView的模糊特效。</li>
<li><a href="https://github.com/onevcat/VVBlurPresentation">VVBlurPresentation</a> -很简单易用的在原来viewconntroller基础上做模糊，然后present新的viewcontroller的。</li>
<li><a href="https://github.com/pchernovolenko/UICustomActionSheet">UICustomActionSheet</a> - 通过模糊背景来着重强调与菜单相关的元素&ndash;对话框 里面已经收藏。</li>
<li><a href="https://github.com/szk-atmosphere/SABlurImageView">SABlurImageView</a> - 支持渐变动画效果的图像模糊化类库。P.S. 与前几天推存类库 SAHistoryNavigationViewController 是同一位作者。</li>
<li><a href="https://github.com/FlexMonkey/Blurable">Blurable.swift</a> - swift模糊组件。</li>
</ul>


<h5>AutoLayout</h5>

<ul>
<li><a href="https://github.com/Masonry/Masonry">Masonry</a> - Masonry是一个轻量级的布局框架，拥有自己的描述语法，采用更优雅的链式语法封装自动布局，简洁明了并具有高可读性（ <a href="http://adad184.com/2014/09/28/use-masonry-to-quick-solve-autolayout/">使用介绍1</a>  <a href="http://ios.jobbole.com/81483/">使用介绍2</a>），<a href="http://www.cocoachina.com/ios/20150702/12217.html">iOS自适应前段库-Masonry的使用</a>），<a href="http://www.jianshu.com/p/2ed5f7444900">Masonry、Classy、ClassyLiveLayout介绍</a>。<a href="https://github.com/lcddhr/DDMasonryTest">使用DEMO</a> 视图居中显示、子视图含边距、视图等距离摆放、计算ScrollView的contentsize。</li>
<li><a href="https://github.com/cloudkite/Classy/">Classy</a> - Classy是一个能与UIKit无缝结合stylesheet(样式)系统。它借鉴CSS的思想，但引入新的语法和命名规则，<a href="http://classy.as/getting-started/">Classy官网</a>，<a href="http://www.jianshu.com/p/2ed5f7444900">Masonry、Classy、ClassyLiveLayout介绍</a>。</li>
<li><a href="https://github.com/olegam/ClassyLiveLayout">ClassyLiveLayout</a> - ClassyLiveLayout通过结合Classy stylesheets与Masonry一起使用，能够在运行的模拟器中微调Auto Layout约束实时显示效果的工具，<a href="http://www.jianshu.com/p/2ed5f7444900">Masonry、Classy、ClassyLiveLayout介绍</a>。</li>
<li><a href="https://github.com/Masonry/Snap">Snap</a> - Snap是Masonry Auto Layout DSL的Swift版本，是一款轻量级的布局框架，使用了更良好的语法封装了AutoLayout。Snap支持iOS和OS X。</li>
<li><a href="https://github.com/SnapKit/SnapKit">SnapKit</a> - 就是“snap”， &ndash;swift 喜欢自动布局吗？当然喜欢！至少在storyboard中创建时会喜欢。 在代码中纯手工创建约束灰常痛苦，但幸运的是我们有了SnapKit，在board中用上它，你可以简单直观地编写约束了。。</li>
<li><a href="https://github.com/smileyborg/PureLayout">PureLayout</a> - PureLayout 是 iOS &amp; OS X Auto Layout 的终极 API——非常简单，又非常强大。PureLayout 通过一个全面的Auto Layout API 扩展了 UIView/NSView, NSArray 和 NSLayoutConstraint，仿照苹果自身的框架。</li>
<li><a href="https://github.com/smileyborg/UIView-AutoLayout">UIView-AutoLayout</a> -
Deprecated in favor of PureLayout, which includes OS X support:<a href="https://github.com/smileyborg/PureLayout%E3%80%82">https://github.com/smileyborg/PureLayout%E3%80%82</a></li>
<li><a href="https://github.com/robb/Cartography">Cartography</a> - Cartography 是用来声明 Swift 中的 Auto Layout，无需输入任何 stringly 就可设置自己 Auto Layout 的约束声明。</li>
<li><a href="https://github.com/philcn/Auto-Layout-Showcase">Auto-Layout-Showcase</a> - swift,AutoLayout 进阶 Demo，宽高比约束、比例约束、不等约束、视差约束、低优先级约束等高级用法，无需写码即可进行复杂页面布局，Demo 还动态模拟了各屏幕下的效果。来自百度知道 iOS 小组的内部分享。</li>
<li><a href="https://github.com/forkingdog/UIView-FDCollapsibleConstraints">UIView-FDCollapsibleConstraints</a> - 一个AutoLayout辅助工具，最优雅的方式解决自动布局中子View的动态显示和隐藏的问题。第二个Demo模拟了一个经典的FlowLayout，任意一个元素隐藏时，底下的元素需要自动“顶”上来，配合这个扩展，你可以在IB里连一连，选一选，不用一行代码就能搞定。</li>
<li><a href="https://github.com/luodezhao/Autolayout_Demo">Autolayout_Demo</a> - 在项目中用自动布局实现的类似抽屉效果。</li>
<li><a href="http://code.cocoachina.com/detail/320405/">当view隐藏的时候也隐藏其autolayout的NSLayoutAttribute</a> - 当view隐藏的时候也隐藏其autolayout的NSLayoutAttribute，从而不用大量的代码工作。</li>
<li><a href="https://github.com/gsdios/SDAutoLayout">SDAutoLayout</a> - AutoLayout 一行代码搞定自动布局！支持Cell、Label和Tableview高度自适应，致力于做最简单易用的AutoLayout库。</li>
<li><a href="https://github.com/mamaral/Neon">Neon.swift</a> - 功能强大的 UI 布局神器。</li>
</ul>


<h5>富文本</h5>

<ul>
<li><a href="https://github.com/honcheng/RTLabel">RTLabel</a> - RTLabel 基于UILabel类的拓展,能够支持Html标记的富文本显示，它是基于Core Text,因此也支持Core Text上的一些东西。32位，很久没有更新了。</li>
<li><a href="https://github.com/bingxue314159/RTLabel">RTLabel</a> - 富文本，RTLabel支持64位。</li>
<li><a href="https://github.com/12207480/TYAttributedLabel">TYAttributedLabel</a> -  TYAttributedLabel。 简单易用的属性文本控件(无需了解CoreText)，支持富文本，图文混排显示，支持添加链接，image和UIView控件，支持自定义排版显示。</li>
<li><a href="https://github.com/TinyQ/TQRichTextView">TQRichTextView</a> - 用于做富文本视图控件显示，用于即时通讯的表情显示，以及资源评论的富文本显示。</li>
<li><a href="https://github.com/mattt/TTTAttributedLabel">TTTAttributedLabel</a> - 一个文字视图开源组件，是UILabel的替代元件，可以以简单的方式展现渲染的属性字符串。另外，还支持链接植入，不管是手动还是使用UIDataDetectorTypes自动把电话号码、事件、地址以及其他信息变成链接。<a href="http://blog.csdn.net/prevention/article/details/9998575">用TTTAttributedLabel创建变化丰富的UILabel</a> - 网易新闻iOS版使用。</li>
<li><a href="https://github.com/molon/MLEmojiLabel">MLEmojiLabel</a> - 自动识别网址、号码、邮箱、@、#话题#和表情的label。可以自定义自己的表情识别正则，和对应的表情图像。(默认是识别微信的表情符号)，继承自TTTAttributedLabel，所以可以像label一样使用。label的特性全都有，使用起来更友好更方便。</li>
<li><a href="https://github.com/nicklockwood/FXLabel">FXLabel</a> - FXLabel是一个功能强大使用简单的类库，通过提供一个子类改进了标准的UILabel组件，为字体增加了阴影、内阴影和渐变色等，可以被用在任何标准的UILabel中。FXLabel还提供了更多控件，可以对字体行距、字体间距等进行调整。</li>
<li><a href="https://github.com/TigerWf/WFReader">WFReader</a> - 一款简单的coretext阅读器，支持文本选择、高亮以及字体大小选择等。</li>
<li><a href="https://github.com/nigelgrange/WPAttributedMarkup">WPAttributedMarkup</a> - WPAttributedMarkup is a simple utility category that can be used to easily create an attributed string from text with markup tags and a style dictionary。</li>
<li><a href="https://github.com/MoZhouqi/KMPlaceholderTextView">KMPlaceholderTextView</a> - 可显示多行 placeholder 的 textView，可以在IB里面设置 &ndash; swift。</li>
<li><a href="https://github.com/mrchenhao/HHFlashSwitch">HHFlashSwitch</a> - 一个另类的UISwitch，选择后，背景水波扩散变色效果。</li>
<li><a href="https://github.com/zhangyu9050/UUColorSwitch">UUColorSwitch</a> - Switch 开关动画效果,当打开开关时，Switch可实现平滑渲染过渡到父视图的效果。</li>
<li><a href="https://github.com/zekunyan/UITextViewDIYEmojiExample">UITextViewDIYEmojiExample</a> - <a href="http://tutuge.me/2015/03/07/UITextView%E7%BC%96%E8%BE%91%E6%97%B6%E6%8F%92%E5%85%A5%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A1%A8%E6%83%85-%E7%AE%80%E5%8D%95%E7%9A%84%E5%9B%BE%E6%96%87%E6%B7%B7%E7%BC%96/">UITextView编辑时插入自定义表情-简单的图文混编</a>。</li>
<li><a href="https://github.com/facebook/Shimmer">Shimmer</a> - BlingBling闪光效果，酷炫的Label的效果，可以用于加载等待提示。</li>
<li><a href="https://github.com/nnhubbard/ZSSRichTextEditor">ZSSRichTextEditor</a> - 适用于iOS的富文本WYSIWYG编辑器，支持语法高亮和源码查看。ZSSRichTextEditor包含所有WYSIWYG标准的编辑器工具。</li>
<li><a href="https://github.com/cjwirth/RichEditorView">RichEditorView</a> - swift，一套可定制富文本编辑器组件及示例。功能完整、代码简练、实现逻辑巧妙（编辑器核心与 WebView 结合，采用 HTML5 contentEditable 编辑模式，执行JS 配套命令 execCommand 实现富文本编辑功能）。</li>
<li><a href="https://github.com/Cocoanetics/DTCoreText">DTCoreText</a> - 可以解析HTML与CSS最终用CoreText绘制出来，通常用于在一些需要显示富文本的场景下代替低性能的UIWebView。<a href="http://blog.cnbang.net/tech/2630/">DTCoreText源码解析</a>。</li>
<li><a href="https://github.com/cloverstudio/CSGrowingTextView">CSGrowingTextView</a> - 用作即时通讯文本框和评论文本框使用，可以显示多行输入。</li>
<li><a href="https://github.com/indragiek/MarkdownTextView">MarkdownTextView</a> - 显示Markdown的TextView。</li>
<li><a href="http://d.cocoachina.com/code/detail/300299">高仿微信限定行数文字内容</a> - 采用Autolayout高仿微信纯文字限定行数。</li>
<li><a href="https://github.com/lingochamp/FuriganaTextView">FuriganaTextView</a> - 实现复杂的日文韩文排版。</li>
<li><a href="https://github.com/gmertk/ParkedTextField">ParkedTextField</a> - 带固定文本的输入组件。</li>
<li><a href="https://github.com/lexrus/LTMorphingLabel">LTMorphingLabel</a> - swift 能够实现文字变形动画效果的Label，用Swift写的一个能够实现文字变形动画效果的Label，很炫。</li>
<li><a href="https://github.com/zyprosoft/GJCFCoreText">GJCFCoreText</a> - 图文混排。</li>
<li><a href="https://github.com/KyoheiG3/AttributedLabel">AttributedLabel</a> - 显示性能数量级 UILabel 的 AttributedLabel。无畏无惧、挑战权威。</li>
<li><a href="https://github.com/liufan321/FFLabel">FFLabel</a> - 自动检测 URLs, @username, #topic# 等关链词（提供响应扩展）。实用的标签文本小组件。</li>
<li><a href="https://github.com/raulriera/TextFieldEffects">TextFieldEffects</a> - 标准的UITextField有些枯燥么？来认识一下TextFieldEffects吧！废话不多说，只要看几个例子,是啊，都是些简单的dropin控制器。甚至可以在storyboard中使用IBDesignables。</li>
<li><a href="https://github.com/filipstefansson/AutocompleteField">AutocompleteField</a> - 可应用于 iOS 应用中文字输入框自动补全的场景, 兼容到 iOS 8。</li>
<li><a href="https://github.com/yannickl/Splitflap">Splitflap.swift</a> - 可用于快速给 iOS 应用创建文字翻转的动画效果。</li>
<li><a href="https://github.com/wordpress-mobile/WordPress-Editor-iOS">WordPress-Editor-iOS</a> - 一个文本编辑器 简书和新浪博客都在用。</li>
<li><a href="https://github.com/ibireme/YYText">YYText</a> - 功能强大的 iOS 富文本框架。</li>
</ul>


<h5>图表</h5>

<ul>
<li><a href="https://github.com/kevinzhow/PNChart">PNChart</a> - 国内开源作者，动态的图表。</li>
<li><a href="https://github.com/zemirco/swift-linechart">swift-linechart</a> - 功能完整、实用的折线图组件。使用方便，参数配置简单。是不可多得的优质组件&ndash;swift。</li>
<li><a href="https://github.com/danielgindi/ios-charts">ios-charts</a> - 一款优秀 Android 图表开源库 MPAndroidChart 的 Swift 语言实现版（支持 Objective-C 和 Swift 调用）。缺省提供的示例代码为 Objective-C。</li>
<li><a href="https://github.com/xhacker/TEAChart">TEAChart</a> - xhacker/TEAChart 一个简洁的 iOS 图表库，支持柱状图、饼图以及日历等。</li>
<li><a href="https://github.com/yasuoza/YOChartImageKit">YOChartImageKit</a> - 支持在watchOS上绘制图表，看它最近更新挺勤快的，可以关注一下。</li>
<li><a href="https://github.com/kevinzhow/RealtimeGradientText">RealtimeGradientText</a> - Fun With CALayer Mask 刚好今天开源了一个有趣的项目 RealtimeGradientText，所以也好聊一下 CALayer 的 Mask，<a href="http://blog.zhowkev.in/2015/07/06/fun-with-mask/">说明</a>。</li>
</ul>


<h5>表相关与Tabbar</h5>

<ul>
<li><a href="https://github.com/onevcat/SWTableViewCell">SWTableViewCell</a> - 国内开源作者，带很多手势的表单元格。</li>
<li><a href="https://github.com/alikaragoz/MCSwipeTableViewCell">MCSwipeTableViewCell</a> - 带很多手势的表单元格。</li>
<li><a href="https://github.com/1000Memories/TMQuiltView">TMQuiltView</a> - 瀑布流。</li>
<li><a href="https://github.com/lengmolehongyan/WaterfallFlowDemo">WaterfallFlowDemo</a> - 一个简单的UICollectionView瀑布流布局演示demo。</li>
<li><a href="https://github.com/xmartlabs/XLForm">XLForm</a> - 很多表格类的table,写法更高冷一点，推荐使用。</li>
<li><a href="https://github.com/xmartlabs/Eureka">Eureka.swift</a> - Eureka 是 XLForm 的 Swift 的移植版本, 一个可以帮助开发者们快速构建 iOS 各种复杂表单的库, 具有较高的可扩展性, 方便自定制样式。</li>
<li><a href="https://github.com/romaonthego/RETableViewManager">RETableViewManager</a> - 可以十分方便地生成各种样式、各种功能的TableView。只要开发者能想到的列表效果或者功能，都可以利用这份代码迅速编写出来。比如，之前要实现一个填写各种资料的列表，可能需要很多代码，现在只需要几行代码就可以实现。</li>
<li><a href="https://github.com/TomThorpe/UIScrollSlidingPages">UIScrollSlidingPages</a> - 允许添加多视图控件，并且可以横向滚动。有点类似于Groupon app。</li>
<li><a href="https://github.com/izyhuang/HBHorizontalTableView">HBHorizontalTableView</a> - swift，TableView 横向滚动小示例（仿照 AppStore 应用展示）。</li>
<li><a href="https://github.com/mcelayir/HorizontalScrollCell">HorizontalScrollCell</a> - HorizontalScrollCell是一款使用方便的水平方向可滚动的单元格，适用于UICollectionView中实现水片方向滚动视图。 。</li>
<li><a href="https://github.com/shiyuan17/SYJiugonggeTableView">SYJiugonggeTableView</a> - tableView封装的九宫格。</li>
<li><a href="https://github.com/ZhipingYang/UUChatTableView">UUChatTableView</a> - UUChatTableView 气泡聊天界面，支持文本、图片以及音频的气泡聊天界面。<a href="http://www.cocoachina.com/ios/20150205/11116.html">源码推荐说明</a>。</li>
<li><a href="https://github.com/acani/Chats">Chats</a> - 聊天 UI 示例程序。此项目应该只为演示或学习之用，没有服务器 &ndash; swift。</li>
<li><a href="https://github.com/layerhq/Atlas-iOS">Atlas-iOS</a> - 快速在iOS里集成聊天功能，类似开源版本的环信。Layer家开源了一套聊天app界面的解决方案.看起来很赞，很多蛮复杂的东西直接都帮封好了。不得不说现在做app开发真是很简单，大部分时间搭积木就可以了。<a href="https://atlas.layer.com/">官方网站</a>。</li>
<li><a href="https://github.com/badoo/Chatto">Chatto.swift</a> - Chatto.swift:轻量级聊天应用框架及示例。文字及图片可扩展输入栏，汽泡效果等聊天核心特性，分页及自动布局完善。</li>
<li><a href="https://github.com/agdsdl/DLSlideView">DLSlideView</a> - DLSlideView对常见的顶部Tab页点击、滑动分页做了封装。它使用基于ViewController的container特性（而不是scrollview）来管理各个子页面，以支持无限分页，<a href="http://www.cocoachina.com/ios/20150205/11116.html">源码推荐说明</a>。</li>
<li><a href="https://github.com/pozi119/VOVCManager">VOVCManager</a> - 页面管理器:1.跳转指定页面,只需要知道viewController的Class名,如果有storyboard,则需要指定storyboard名；2.无需添加基类；3.支持URLScheme跳转指定页面。</li>
<li><a href="https://github.com/Moblox/MBXPageViewController">MBXPageViewController</a> - 简洁快速的页面切换&ndash;MBXPageViewController，带有按钮控件的UIPageController，非常整洁、简单以及快速。该项目通过三种形式展示页面之间的切换，比如导航栏上的多个tab切换、页面左右两端箭头指示切换，以及使用分段控件。</li>
<li><a href="https://github.com/ming1016/PagerTab">PagerTab</a> - UIScrollView实现滑动转换页面，类似网易云音乐iOS版的页面滑动切换效果。</li>
<li><a href="https://github.com/guilhermearaujo/GUITabPagerViewController">GUITabPagerViewController</a> - 多个tab滑动切换。</li>
<li><a href="https://github.com/pozi119/VOMetroLayoutDemo">VOMetroLayoutDemo</a> - Metro风格的UICollectionView, 目前只支持横向布局,仅在iPad上应用。</li>
<li><a href="https://github.com/KittenYang/KYCellAnimation">KYCellAnimation</a> - 给UITableViewCell增加进入的动画。</li>
<li><a href="https://github.com/knutigro/COBezierTableView">COBezierTableView</a> - swift，通过编辑 Bezier 曲线四点位置设置 TableView 内 Cell 及对应按扭位置。实验效果很赞。</li>
<li><a href="https://github.com/robbdimitrov/RDVTabBarController">RDVTabBarController</a> - 一个TabBar组件，可以方便设置底部菜单的文字图片，点击效果，小红点提示等。</li>
<li><a href="https://github.com/DeveloperLx/LxTabBarController">LxTabBarController</a> - 改变了原生tabbar切换tab时的生硬效果，并加入滑动切换手势（有和界面上的其它手势发生冲突的风险，可根据具体项目予以关闭），<a href="https://github.com/DeveloperLx/LxTabBarController-swift">swift版本</a>。</li>
<li><a href="https://github.com/leichunfeng/WXTabBarController">WXTabBarController</a> - 在系统 UITabBarController 的基础上完美实现了安卓版微信 TabBar 的滑动切换功能，单手操作 iPhone 6 Plus 切换 TabBar 一直是一件很痛苦的事情，而滑动切换是一种不错的解决方案，支持屏幕旋转。</li>
<li><a href="https://github.com/KittenYang/GooeyTabbar">GooeyTabbar</a> - 皮筋式弹性缩放工具栏示例及演示。</li>
<li><a href="http://d.cocoachina.com/code/detail/298409">横向展示文本内容的自定义cell</a> - 可以横向展示文本内容的自定义cell，根据文本无限滚动。</li>
<li><a href="https://github.com/forkingdog/UITableView-FDTemplateLayoutCell">UITableView-FDTemplateLayoutCell</a> - UITableView-FDTemplateLayoutCell 是一个方便缓存 UITableViewCell 的高度的框架。</li>
<li><a href="https://github.com/jozsef-vesza/ExpandingStackCells">ExpandingStackCells</a> - 采用 UIStackView 实现表格单元格扩展内容显示示例及解决方案。</li>
<li><a href="https://github.com/forkingdog/FDStackView">FDStackView</a> - 可以将 UIStackView 的最低支持版本拉低到 iOS6，无需配置，没有代码侵染，扔到工程里后直接用系统 UIStackView 的 API 即可，同时兼容 Storyboard。</li>
<li><a href="https://github.com/nghialv/Sapporo">Sapporo</a> - swift 单元格模型驱动的集合视图管理器组件。又一个超实用的“轮子”。</li>
<li><a href="https://github.com/WeeTom/MDIHorizontalSectionTableViewController">MDIHorizontalSectionTableViewController</a> - 根据产品需求开源了一个交互项目，可以理解为横向Section的TableView，section和cell同时支持拖拽，后续安卓版本也会开源出来。</li>
<li><a href="https://github.com/JazysYu/JZNavigationExtension">JZNavigationExtension</a> - 多功能导航控制器，可以透明返回栏。</li>
<li><a href="https://github.com/okla/QuickRearrangeTableView">QuickRearrangeTableView</a> - 基于 UITableView 的快速重排功能扩展子类。通过长按选定单元格然后滚动移动到指定位置。</li>
<li><a href="https://github.com/nshintio/uicollectionview-reordering">uicollectionview-reordering</a> - UICollectionViews的拖拽(拖动、移动)效果,<a href="http://nshint.io/blog/2015/07/16/uicollectionviews-now-have-easy-reordering/">实例教程</a>.</li>
<li><a href="https://github.com/dzenbot/DZNEmptyDataSet">DZNEmptyDataSet</a> - DZNEmptyDataSet算是一个很标准的iOS内建方式，适合用来处理空的table view和collection view。会自动将collection view处理完善，并将用户消息以合适美观的方式显示出来。每个iOS项目都可以自动处理。</li>
<li><a href="https://github.com/MortimerGoro/MGSwipeTableCell">MGSwipeTableCell</a> - 另一个常见于很多应用中的UI组件，苹果应该考虑在标准的iOS SDK中加入一些类似的内容。Swipeable表格cell是这个pod的最佳描述，也是最好的。</li>
<li><a href="https://github.com/HebeTienCoder/XLPlainFlowLayout">XLPlainFlowLayout</a> - 可以让UICollectionView的header也支持悬停效果，类似于tableView的Plain风格。</li>
<li><a href="https://github.com/wangmchn/WMPageController">WMPageController</a> - 一个方便的 pageContrller 的控件，里面还包括滚动视图。</li>
<li><a href="https://github.com/steipete/PSTCollectionView">PSTCollectionView</a> - PSTCollectionView。</li>
<li><a href="https://github.com/lianleven/LLRiseTabBar-iOS">LLRiseTabBar-iOS</a> - 直接使用系统的特性实现的tabbar，比较简单。</li>
<li><a href="https://github.com/MartinRGB/MTMaterialDelete">MTMaterialDelete</a> - 非常有趣的Material Design动画，动画删除表里面的单元格。</li>
<li><a href="https://github.com/gmertk/BusyNavigationBar">BusyNavigationBar</a> - 进度条式NavigationBar导航条。</li>
<li><a href="https://github.com/cemolcay/ReorderableGridView-Swift">ReorderableGridView-Swift</a> - 拖拽排序卡片。</li>
</ul>


<h5>隐藏与显示</h5>

<ul>
<li><a href="http://d.cocoachina.com/code/detail/286102">SlideTapBar</a> - 滚动栏菜单，向上滚动时隐藏tabbar，向下滚动马上显示tabbar。</li>
<li><a href="https://github.com/Yalantis/FoldingTabBar.iOS">FoldingTabBar.iOS</a> - 可折叠Tab Bar和Tab Bar Controller。</li>
<li><a href="https://github.com/ltebean/LTNavigationBar">LTNavigationBar</a> - LTNavigationBar为app导航栏添加动态着色效果，可自定义其背景色。Demo包含：1.变换背景色；2.滚动视图，导航栏和状态栏重叠。</li>
<li><a href="https://github.com/bryankeller/BLKFlexibleHeightBar">BLKFlexibleHeightBar</a> - 固定Header的效果库，一个拥有非常灵活高度的标题栏，可以为使用软件的用户提供更多的阅读和滑动空间，现在已经被众多app所采用。</li>
</ul>


<h5>HUD与Toast</h5>

<ul>
<li><a href="https://github.com/jdg/MBProgressHUD">MBProgressHUD</a> - 最多人用的loading。</li>
<li><a href="https://github.com/LvJianfeng/EBuyCommon">EBuyCommon</a> - 1.基于MBProgressHUD实现得图形加载提示方式，及其它标题方式提醒。2.弹窗。</li>
<li><a href="https://github.com/TransitApp/SVProgressHUD">SVProgressHUD</a> - SVProgressHUD的loading，如果你需要定制化的等待提示器，这个就是了（也许是最好的）。</li>
<li><a href="https://github.com/relatedcode/ProgressHUD">ProgressHUD</a> - ProgressHUD的loading，使用最简单。</li>
<li><a href="https://github.com/mutualmobile/MMProgressHUD">MMProgressHUD</a> - 设置HUD出现和消失的方式（包括上下、左右、淡入淡出、放大缩小等等），设置HUD的内容（可以在HUD中加入帧动画、动态图片等等），设置HUD出现时的底部覆盖层颜色，等等。总而言之，这是一份集大成的HUD代码。慢慢看视频吧，囊括了所有效果。</li>
<li><a href="https://github.com/devSC/WSProgressHUD">WSProgressHUD</a> - 一个小巧精致的HUD,支持添加到自定义View上, 还有更多小细节.。</li>
</ul>


<h5>对话框</h5>

<ul>
<li><a href="https://github.com/m1entus/WCAlertView">WCAlertView</a> - 自定义的对话框。</li>
<li><a href="https://github.com/wimagguc/ios-custom-alertview">IOS7AlertView</a> - IOS7AlertView的对话框。</li>
<li><a href="https://github.com/mtonio91/AMSmoothAlert">AMSmoothAlert</a> - 动画效果不错，最多star，但不支持arm64。</li>
<li><a href="https://github.com/dinhquan/DQAlertView">DQAlertView</a> - 扁平化的样式不错。</li>
<li><a href="https://github.com/mrchenhao/HHAlertView">HHAlertView</a> - 一个简易的alertview  有三种样式，有成功，失败，和警告三种样式，支持Delegate和block两种回调。</li>
<li><a href="https://github.com/martinjuhasz/MJPopupViewController">MJPopupViewController</a> - 实现弹出视图的各种弹出和消失效果，包括淡入淡出（fade in，fade out），从屏幕上方飞进，下方飞出，从屏幕左方飞进，右方飞出等等效果，弹窗。</li>
<li><a href="https://github.com/adad184/MMPopupView">MMPopupView</a> - 弹出框的基类组件（弹窗）。</li>
<li><a href="https://github.com/fengchuanxiang/Menu">Menu</a> - 项目中可能会用到的常用菜单，以后有时间会继续补充，弹窗。</li>
<li><a href="https://github.com/teodorpatras/EasyTipView">EasyTipView</a> - 弹出提示框类及演示示例。同样地，API 简单、易用。好“轮子”，弹窗。</li>
<li><a href="https://github.com/kolyvan/kxmenu">kxmenu</a> - kxmenu弹出菜单，点击视图上任意位置的按钮，会弹出一个菜单，并且有个小箭头指向点击的按钮，类似气泡视图。弹出的菜单位置会根据按钮的位置来进行调整。</li>
<li><a href="https://github.com/questbeat/QBPopupMenu">QBPopupMenu</a> - QBPopupMenu弹出菜单，实现类似 UIMenuItem 的弹出菜单按钮。点击按钮，会弹出一个菜单，上面可以排列多个按钮。纯代码实现，不需要任何图片。</li>
<li><a href="https://github.com/zhenlintie/STModalDemo">STModalDemo</a> - 弹出视图（通知，提示，选择，窗口）。</li>
<li><a href="https://github.com/TaimurAyaz/TAOverlay">TAOverlay</a> - TAOverlay可通过叠加层展示有用的信息，可自定义文本和背景色，添加阴影和模糊效果，以及更改字体大小或者用自定义图片替换页面上的icon。</li>
<li><a href="https://github.com/pchernovolenko/UICustomActionSheet">UICustomActionSheet</a> - 通过模糊背景来着重强调与菜单相关的元素&ndash;模糊效果 里面已经收藏。</li>
<li><a href="http://code.cocoachina.com/detail/232178">ActionSheetPicker-3.0</a> - 该项目是此前热门项目ActionSheetPicker的新版本，快速复制了iOS 8上的下拉 UIPickerView/ActionSheet功能。</li>
<li><a href="https://github.com/mayuur/MJAlertView">MJAlertView</a> - 3D效果转场效果警示图&ndash;MJAlertView。</li>
<li><a href="https://github.com/morizotter/SwiftyDrop">SwiftyDrop</a> - 轻量、易用的小清新弹出列表及信息提示组件真心不错。</li>
<li><a href="https://github.com/steipete/PSTAlertController">PSTAlertController</a> - 兼容 iOS7的 XXAlertController，接口跟UIAlertController 一模一样，做到高低版本通用。</li>
<li><a href="https://github.com/hryk224/PCLBlurEffectAlert">PCLBlurEffectAlert.swfit</a> - 细节定制较丰富的弹出警报窗口组件。</li>
<li><a href="https://github.com/wxxsw/GSAlert">GSAlert.swfit</a> - 苹果在iOS8推出了全新的UIAlertController，旧的UIAlertView和UIActionSheet渐渐被废弃，但如果你仍然支持iOS7系统，你将不得不写两套代码。GSAlert解决了这个问题。</li>
</ul>


<h5>其他UI</h5>

<ul>
<li><a href="https://github.com/levey/AwesomeMenu">AwesomeMenu</a> - 最多人用的Path菜单。</li>
<li><a href="https://github.com/Tangdixi/DCPathButton">DCPathButton</a> - Path，4.0的弹出菜单，呼出或者关闭菜单时，多个小图标会分别按照逆时针和顺时针的方向进行滚动。</li>
<li><a href="https://github.com/itouch2/SphereMenu">SphereMenu</a> - 利用UIDynamicAnimator的有趣的菜单，path类似。</li>
<li><a href="https://github.com/KittenYang/KYGooeyMenu">KYGooeyMenu</a> - KYGooeyMenu 是一个具有 Gooey Effects 带粘性的扇形菜单控件(卫星菜单、path)。</li>
<li><a href="https://github.com/yoavlt/LiquidFloatingActionButton">LiquidFloatingActionButton</a> - 卫星弹出菜单。</li>
<li><a href="https://github.com/JustinFincher/JZMultiChoicesCircleButton">JZMultiChoicesCircleButton</a> - 三维多选按钮。</li>
<li><a href="https://github.com/xhzengAIB/TwitterPaggingViewer">TwitterPaggingViewer</a>  - 多个Tableview，左右滑动。</li>
<li><a href="https://github.com/carantes/CircularProgressControl">CircularProgressControl</a> - Circular Progress Control using CAShapeLayer ，环形进度控制条。</li>
<li><a href="https://github.com/kaandedeoglu/KDCircularProgress">KDCircularProgress</a> -  KDCircularProgress是使用swift制作的色彩炫丽的进度条，可以加入多种颜色来控制进度条的渐变效果。</li>
<li><a href="https://github.com/cgwangding/TextProgress">TextProgress</a> - 自定义实现数字进度条：1、可以自定义数字（0-100），填充的比例为当前设置的数字，2、可以实现自定义填充颜色，上下部分都可以，3、可以自定义边界的颜色4、实现了水波动画，可以设置打开或关闭。</li>
<li><a href="https://github.com/gsdios/SDProgressView">SDProgressView</a> - 简便美观的进度指示器，此系列共有六种样式的进度指示器。</li>
<li><a href="https://github.com/ninjaprox/NVActivityIndicatorView">NVActivityIndicatorView</a> -  loading 进度条动画，有20-30多种，是在此<a href="https://github.com/gontovnik/DGActivityIndicatorView">DGActivityIndicatorView</a> 基础上做得修改。</li>
<li><a href="https://github.com/saitjr/LoopProgressDemo">LoopProgressDemo</a> - 环形渐变进度条。</li>
<li><a href="http://www.superqq.com/blog/2015/08/12/realization-circular-gradient-progress/">环形渐变进度条实现</a>，</li>
<li><a href="https://github.com/xmartlabs/XLPagerTabStrip">XLPagerTabStrip</a> - 做的很棒的iOS下的PagerTabStrip。</li>
<li><a href="https://github.com/alskipp/ASProgressPopUpView">ASProgressPopUpView</a> - 弹出的进度条显示进度。</li>
<li><a href="https://github.com/onevcat/RandomColorSwift">RandomColorSwift</a> - 一个自动生成好看的颜色的 Swift 库，RandomColorSwift。</li>
<li><a href="https://github.com/ChangweiZhang/HexColorService">HexColorService</a> - 将16进制颜色字符串转成UIColor。</li>
<li><a href="https://github.com/NorthernRealities/Rainbow">Rainbow</a> - 旨在提高代码可读性及易用性的 UIColor 扩展，它使原先有限的预定义颜色（方法）选择，扩展至超过 1200 种。</li>
<li><a href="https://github.com/zhxnlai/UIColor-ChineseTraditionalColors">UIColor-ChineseTraditionalColors</a> - 中国传统颜色引用 UIColor 扩展。“UIColor.桃红()，UIColor.竹青() &hellip;”，共158种。</li>
<li><a href="http://code.cocoachina.com/detail/284158">类似美团的下拉菜单</a> - 类似美团的下拉菜单，<a href="http://www.cocoachina.com/ios/20150205/11116.html">源码推荐说明</a>。</li>
<li><a href="http://code4app.com/ios/%E7%B1%BB%E4%BC%BC%E7%BE%8E%E5%9B%A2%E7%9A%84%E4%B8%8B%E6%8B%89%E9%80%89%E9%A1%B9/538606d4933bf06e0a8b496e">类似美团的下拉选项</a> -  类似于美团、大众点评的下拉菜单选项，code4app代码，评论代码有瑕疵。</li>
<li><a href="http://code.cocoachina.com/detail/284267">CRMediaPickerController</a> - 一个简单易用的图片/视频选择器。1.可同时选择照片和视频。 2.挑选范围有Camera、Camera Roll、Photo Library以及最近拍摄的照片和视频。3.可自定义UIImagePickerController属性（Camera Overlay、Camera Device、Camera View Transform以及allowsEditing）。4.支持横屏和竖屏5.原生的iOS UI。，<a href="http://www.cocoachina.com/ios/20150205/11116.html">源码推荐说明</a>。</li>
<li><a href="https://github.com/modocache/MDCSwipeToChoose">MDCSwipeToChoose</a> - MDCSwipeToChoose可简单地添加滑动手势来调用UIView，并使用该行为提供了一个组件以创建类似Tinder app的like或者dislike界面的轻扫。基于轻扫的方向，你可以决定执行什么样的行为，并且你可以自定义文本颜色和图片。该项目适用于教学用的抽认卡、图片查看器以及其他等。</li>
<li><a href="http://d.cocoachina.com/code/detail/285611">iOS Material Design库</a> - 该项目借鉴于谷歌的Material Design guideline，用户可自定义背景色。</li>
<li><a href="https://github.com/fpt-software/Material-Controls-For-iOS">Material-Controls-For-iOS</a> - Material Design风格的各种控件，非常完整全面。</li>
<li><a href="https://github.com/richzertuche/ZMaterialDesignUIButton">ZMaterialDesignUIButton</a> - Swift Material Design UIButton。</li>
<li><a href="https://github.com/pixyzehn/MediumScrollFullScreen">MediumScrollFullScreen</a> - Medium的可扩展滚动页面，上下滚动时，全屏显示内容，并自然消隐上下菜单。由此项目感知，作者是一位很注重细节的开发者，他的另外<a href="https://github.com/pixyzehn">几个菜单类项目</a>也都不错，值得参考，比如：PathMenu, MediumMenu 等。</li>
<li><a href="https://github.com/SatanWoo/WZFlashButton">WZFlashButton</a> - WZFlashButton，点击后button里面出现水波扩散效果。</li>
<li><a href="https://github.com/piemonte/Twinkle">Twinkle</a> - 为字体加上钻石版闪耀的效果。使用Swift编写。</li>
<li><a href="https://github.com/palmin/ios-multi-back-button">ios-multi-back-button</a> - 可替换内置的UInavigationController返回按钮，长按左上角的返回按钮，实现多层级的快速返回。</li>
<li><a href="http://code.cocoachina.com/detail/226543">ASDayPicker</a> - 适用于iOS (iPhone)的日期选择器(时间选择器)，类似于Calendar app的周视图。</li>
<li><a href="http://adad184.com/2014/10/29/2014-10-29-how-to-setup-today-extension-programmatically/">today extension</a> - 用纯代码构建一个Widget(today extension) 。</li>
<li><a href="https://github.com/f33chobits/FSCalendar">FSCalendar</a> - 日历视图，带有微妙和平滑的滚动效果，可自定义外观&ndash;国人。</li>
<li><a href="https://github.com/Mozharovsky/CVCalendar">CVCalendar</a> - 是一个方便开发者集成自定义日历视图到自己 iOS 应用的项目, 支持 Storyboard 和手动配置, 使用 CocoaPods 进行安装, 提供了丰富的 API 供开发者使用。</li>
<li><a href="https://github.com/EmilYo/HSDatePickerViewController">HSDatePickerViewController</a> - 带有Dropbox Mailbox感觉的时间日期选择器(时间选择器)。启动是背景被模糊化。界面也是主流的扁平化风格。</li>
<li><a href="https://github.com/huzhiqin/HZQDatePickerView">HZQDatePickerView</a> - 自定义时间选择器(日期选择器)，包括开始日期和结束日期两种类型。</li>
<li><a href="https://github.com/nsdictionary/CFCityPickerVC">CFCityPickerVC</a> - 城市选取控制器。</li>
<li><a href="https://github.com/jonathantribouharet/JTCalendar">JTCalendar</a> - iOS下优美的 Calendar 组件，做 GTD 类 App 必备。</li>
<li><a href="https://github.com/Yalantis/Persei">Persei</a> - 动画隐藏或显示顶部菜单支持库及示例项目。&ndash;swift</li>
<li><a href="https://github.com/jivesoftware/PDTSimpleCalendar">PDTSimpleCalendar</a> - 是iOS最棒的日历组件了。你可以在各个方面对它进行定制，无论是运行逻辑还是外观方面。</li>
<li><a href="https://github.com/hyperoslo/Form">Form</a> - JSON 驱动的 Form表单系统，复杂的表单填写类 App 极其需要（比如淘宝呢！）。</li>
<li><a href="https://github.com/neoneye/SwiftyFORM">SwiftyFORM</a> - swift 表单输入框架（亮点是表单验证规则引擎），是我见过地最易用的 Swift 表单组件。</li>
<li><a href="https://github.com/icanzilb/SwiftSpinner">SwiftSpinner</a> - SwiftSpinner是使用swift制作的一款精致带感的指示器，并且连带有字体信息显示，模糊背景，半透明，扁平化等IOS8的效果。</li>
<li><a href="https://github.com/Akkyie/AKPickerView-Swift">AKPickerView-Swift</a> - 一款小而美的 3D 效果选择器。</li>
<li><a href="https://github.com/larcus94/ImagePickerSheet">ImagePickerSheet</a> - 图片或视频选择器（可多选）组件及其示例项目。</li>
<li><a href="https://github.com/saiwu-bigkoo/iOS-RatingBar">iOS-RatingBar</a> - iOS-RatingBar swift版的评分控件,跟Android的RatingBar一样有两种模式，评分模式和只读模式'支持视图编辑，自定义星星数量，评分等级,另外还能支持非整数星，0.5颗星，0.1颗星,可以开启动画效果。</li>
<li><a href="https://github.com/cwRichardKim/RKNotificationHub">RKNotificationHub</a> - 快速给 UIView 添加上炫酷的通知图标（Badge、红点、提示）。</li>
<li><a href="https://github.com/weng1250/WZLBadge">WZLBadge</a> - Badge，支持横竖屏支持iOS5~iOS8允许高度定制化，包括“红点”的背景颜色，文字(字体大小、颜色)，位置等。<a href="http://code.cocoachina.com/detail/316890/%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E5%A4%9A%E9%A3%8E%E6%A0%BC%E7%9A%84%E6%8E%A8%E9%80%81%E5%B0%8F%E7%BA%A2%E7%82%B9/">说明</a>.</li>
<li><a href="https://github.com/andreamazz/BubbleTransition">BubbleTransition</a> - 以气泡膨胀和缩小的动画效果来显示和移除 controller，Uber的就是这种取消操作的方式。</li>
<li><a href="https://github.com/KittenYang/KYFloatingBubble">KYFloatingBubble</a> - 类似iOS7中Game Center浮动气泡的效果。</li>
<li><a href="https://github.com/Draveness/DKNightVersion">DKNightVersion</a> - DKNightVersion 是一个支持夜间模式切换的框架。</li>
<li><a href="https://github.com/sx1989827/EasyUIControl">EasyUIControl</a> - 一个可以简化界面ui的控件框架。</li>
<li><a href="https://github.com/DeveloperLx/LxGridView">LxGridView-oc</a> <a href="https://github.com/DeveloperLx/LxGridView-swift">LxGridView-swift</a> - 利用UICollectionView模仿iOS系统桌面图标的交互，作用如动图。</li>
<li><a href="https://github.com/ZhongTaoTian/QQBtn">QQBtn</a> - 仿QQ未读消息弹性按钮动画，达到和手机QQ未读信息一样的动画效果，效果基本实现。</li>
<li><a href="https://github.com/gmertk/GMStepper">GMStepper</a> - swift 带动画效果、支持手势滑动操作的步进标签。</li>
<li><a href="https://github.com/tomvanzummeren/TZStackView">TZStackView</a> - OS 9 UIStackView 功能模拟实现于 iOS 7/ iOS 8 内。</li>
<li><a href="https://github.com/441088327/LayoutTrait">LayoutTrait</a> - swift 一个小类库。 做iPad 多任务分屏 适配的同学可以看一下。</li>
<li><a href="https://github.com/HAHAKea/HACursor">HACursor</a> - HACursor，是一个对横向ScrollView中的视图进行管理的UI控件。只要几行代码就可以集成类似于网易新闻对主题页面进行排序，删除操作的功能。</li>
<li><a href="https://github.com/IOStao/ZTPageController">ZTPageController</a> - 模仿网易新闻和其他新闻样式做的一个菜单栏，栏中有各自的控制器，其中有4中展示样式’网易style' ’搜狐style' ’腾讯style1' ’网易style2' 。</li>
<li><a href="https://github.com/nixzhu/Ruler">Ruler</a> - 尺子。</li>
<li><a href="https://github.com/justhum/HUMSlider">HUMSlider</a> - HUMSlider是一款能够自动显示刻度记号的滑竿，滑动到某处，该处的刻度会自动上升，两边还能配置图像。支持代码或storyboard中实现。</li>
<li><a href="https://github.com/zhangli4659507/JDSelectedDemo">JDSelectedDemo</a> - 仿京东筛选菜单实现。</li>
<li><a href="https://github.com/PhamBaTho/BTNavigationDropdownMenu">BTNavigationDropdownMenu</a> -  下拉列表暨导航标题组件。简单、直接、易用 -swift。</li>
<li><a href="https://github.com/luzefeng/3DTouchDemo">3DTouchDemo</a> - 详细介绍了每个参数的含义和3Dtouch的入口，保证包学包会。</li>
<li><a href="https://github.com/RichardLeung/3DTouchSample">3DTouchSample</a> - 3D-Touch的功能分为两个部分：Shortcut和Preview。</li>
<li><a href="https://github.com/DeskConnect/SBShortcutMenuSimulator">SBShortcutMenuSimulator</a> - 教你如何在模拟器上测试 3D Touch 功能!</li>
<li><a href="https://github.com/richzertuche/InceptionTouch">InceptionTouch.swift</a> - 让没有 3D Touch 设备也有类似交互体验的 InceptionTouch 类（基于 UITextView 实现，支持日期，链接，电话号码，地址触摸响应）。</li>
<li><a href="http://code.cocoachina.com/view/128287">仿LOL滚动视图</a> - 仿LOL滚动视图。</li>
<li><a href="http://code.cocoachina.com/view/128281">答题选择切换页</a> - 将scrollview和tableview封装在一起，在初始化的时候简单的将数据带上，就可以一页一页的左右来回滑动。</li>
<li><a href="https://github.com/alafighting/CharacterPickerView">CharacterPickerView</a> - 可实现三级联动的选择器，高仿iOS的滚轮控件,可实现单项选择，并支持一二三级联动效果。</li>
<li><a href="https://github.com/SergioChan/SCTrelloNavigation">SCTrelloNavigation</a> - 类似trello的导航动效控件实现。</li>
<li><a href="https://github.com/Akateason/XTPaster">XTPaster</a> - 贴纸功能出现在很多图片社交中, 就是图片上面贴图片, 对贴纸而言就是需要控制贴纸的位置,旋转,大小,<a href="http://www.jianshu.com/p/d873d348bbfb">如何使用</a>。</li>
<li><a href="https://github.com/refinemobi/RGCategoryView">RGCategoryView</a> - 仿了个苏宁易购的分类页面。</li>
<li><a href="https://github.com/txaidw/TWControls">TWControls.swift</a> - 简单的开关和按钮控制器,使用闭包来执行由控件触发的操作。</li>
<li><a href="https://github.com/ephread/Instructions">Instructions.swift</a> - 可定制嵌入式操作指引框架及演示。</li>
<li><a href="https://github.com/Lves/LLPieCharts">LLPieCharts</a> - LLPieCharts iOS 绘制饼图，<a href="http://www.lvesli.com/?p=339">教程</a>。</li>
<li><a href="https://github.com/Boris-Em/BEMCheckBox">BEMCheckBox</a> - BEMCheckBox 是一个用于 iOS 应用上构建漂亮, 高度可定制化动画效果的复选框类库, 最低支持到 iOS 7 系统, 有多种不同风格的动画效果可供选择。</li>
<li><a href="https://github.com/kevin0571/STPopup">STPopup</a> - 提供了一个可在 iPhone 和 iPad 上使用的具有 UINavigationController 弹出效果的 STPopupController 类, 并能在 Storyboard 上很好的工。</li>
<li><a href="https://github.com/victorBaro/VBFPopFlatButton">VBFPopFlatButton</a> - 通过几条线段实现的非常Q萌的动画按钮效果。</li>
<li><a href="https://github.com/richzertuche/ZSeatSelector">ZSeatSelector</a> - 电影院位置排座位。</li>
<li><a href="https://github.com/zangqilong198812/CustomSearchBar">CustomSearchBar</a> - 自定义searchbar,类似于instagram的搜索框效果。</li>
<li><a href="https://github.com/LeoNatan/LNPopupController">LNPopupController</a> - AppleMusic式pop up，弹出是页面，可以上下拉动。</li>
<li><a href="https://github.com/gontovnik/DGRunkeeperSwitch/">DGRunkeeperSwitch</a> - 动画segment，节选器。</li>
</ul>


<hr />

<h4>动画</h4>

<ul>
<li><a href="http://www.starming.com/index.php?v=index&amp;view=62">Core Animation笔记，基本的使用方法</a> - Core Animation笔记，基本的使用方法：1.基本动画，2.多步动画，3.沿路径的动画，4.时间函数，5.动画组。</li>
<li><a href="https://github.com/sxyx2008/awesome-ios-animation">awesome-ios-animation</a> - <a href="https://github.com/sxyx2008/DevArticles/issues/91">iOS Animation 主流炫酷动画框架(特效)收集整理</a> 收集整理了下iOS平台下比较主流炫酷的几款动画框架。</li>
<li><a href="https://github.com/Animatious/awesome-animation">awesome-animation</a> -  在内的十多位童鞋们一起发起的一起动画开源组正式成立啦~Github组织名称：Animatious，这是我们第一期成员先前开源的一些动效库，我们的第一个合作开源项目正在紧锣密鼓的准备~请大家期待设计和代码的碰撞吧。</li>
</ul>


<h5>侧滑与右滑返回手势</h5>

<ul>
<li><a href="https://github.com/fastred/SloppySwiper">SloppySwiper</a> - iOS系统自带的UINavigationController要7.0才支持，但不过该手势只能从屏幕左侧边缘识别，如果要扩大到整个屏幕范围怎么办？配合一个SloppySwiper无需代码就可以轻松实现。此库支持iOS5.0以上版本（另外：Nav的title滑动不明显，本人写了2个类似的控件），<a href="https://github.com/Tim9Liu9/SloppySwiper-Example">SloppySwiper-demo</a> ：代码方式与storyboard方式。</li>
<li><a href="https://github.com/singro/SCNavigation">SCNavigation</a> - UINavigation可以右滑返回，隐藏UINavigationBar。</li>
<li><a href="https://github.com/YueRuo/UINavigationController-YRBackGesture">UINavigationController-YRBackGesture</a> - 支持右滑返回手势，标题栏不动。</li>
<li><a href="https://github.com/gresrun/GHSidebarNav">GHSidebarNav</a> - 现在比较流行使用侧开(侧滑)菜单设计。试了不少控件，感觉GHSidebarNav最成熟，尤其对纯代码创建的界面兼容性最好。<a href="http://www.cnblogs.com/zyl910/archive/2013/06/14/ios_storyboard_sidemenu.html">在Storyboard中使用GHSidebarNav侧开菜单控件</a>。</li>
<li><a href="https://github.com/aryaxt/iOS-Slide-Menu">iOS-Slide-Menu</a> - 能够类似Facebook和Path那样弹出左右边栏侧滑菜单,还支持手势。多种可以自定义的属性 (非常不错)。</li>
<li><a href="https://github.com/ECSlidingViewController/ECSlidingViewController">ECSlidingViewController</a> - 侧滑菜单。</li>
<li><a href="https://github.com/gotosleep/JASidePanels">JASidePanels</a> - 侧滑菜单,有左右菜单，有pop功能，支持手势侧滑,本人使用中：简单。</li>
<li><a href="https://github.com/Ramotion/animated-tab-bar">animated-tab-bar</a> - 让 Tabbar items能显示萌萌的动画。</li>
<li><a href="http://code.cocoachina.com/detail/284346">tabbar图标动画</a> - tabbar上图标的动画实现，<a href="http://www.cocoachina.com/ios/20150205/11116.html">源码推荐说明</a>。</li>
<li><a href="https://github.com/Yalantis/Side-Menu.iOS/tree/master/SideMenu">SideMenu</a> - swift实现，一款带动画效果可定制 Slide Menu，可以学习其动画实现思路。P.S. 对于Hamburger式菜单，虽然很常用，不过，苹果并不鼓励使用，甚至有开发小组对其弊病用自家上线应用前后数据对比进行了抨击。</li>
<li><a href="https://github.com/romaonthego/RESideMenu">RESideMenu</a> - 侧开菜单，qq类似。</li>
<li><a href="https://github.com/Jiahai/JHMenuTableViewDemo">JHMenuTableViewDemo</a> - 仿网易邮箱列表侧滑菜单。</li>
<li><a href="https://github.com/xudafeng/SlideMenuView">SlideMenuView</a> - 炫酷侧滑菜单布局框架，<a href="Android%20%E7%89%88%E6%9C%AC%E7%9A%84%E4%B8%80%E8%87%B4%E5%AE%9E%E7%8E%B0%E8%AF%B7%E8%A7%81%EF%BC%9Ahttps://github.com/xudafeng/SlidingMenu">Android版本的一致实现</a>。</li>
<li><a href="https://github.com/shinept/QQConfiguration">QQConfiguration</a> - swift，QQ-iPhone端框架，左侧菜单栏拖动手势。</li>
<li><a href="https://github.com/KyleGoddard/KGFloatingDrawer">KGFloatingDrawer</a> - 侧滑菜单，qq类似，KyleGoddard/KGFloatingDrawer：一款适合于大屏手机或平板的浮动抽屉式导航界面组件。效果很赞- 侧开菜单，qq类似（与RESideMenu类似）。</li>
<li><a href="https://github.com/cocoatoucher/AIFlatSwitch">AIFlatSwitch</a> - 一款带平滑过渡动画的 Switch 组件类，类相同风格的 Menu/Back<a href="https://github.com/fastred/HamburgerButton">HamburgerButton</a>,类似相同风格的 Menu/Close<a href="https://github.com/robb/hamburger-button">hamburger-button</a>.</li>
<li><a href="https://github.com/jhurray/JHChainableAnimations">JHChainableAnimations</a> - 在应用中采用链式写出酷炫的动画效果, 使代码更加清晰易读，利用block实现的链式编程。</li>
<li><a href="https://github.com/WXGBridgeQ/WXGSlideMenuDemo">WXGSlideMenuDemo</a> - 个简单实现侧拉（侧滑）菜单的小demo，供初学者共同学习、练习使用。</li>
<li><a href="https://github.com/pkluz/PKRevealController">PKRevealController</a> - PKRevealController是一个可以滑动的侧边栏菜单（可向左、向右或者同时向两侧），只需手指轻轻一点（或者按一下按钮，但是这样滑动时不够炫酷），这类控制的其他库，而PKRevealController是最棒的。安装简便，高度定制且对手势识别良好。可以当做一个标准控件用在iOS SDK中。</li>
<li><a href="https://github.com/GabrielAlva/SwiftPages">SwiftPages</a> - 高可定制类似 Instagram 视图滑动切换功能类库。API 简单、易用。</li>
<li><a href="https://github.com/michaelhenry/FlipBoardNavigationController">FlipBoardNavigationController</a> - FlipBoardNavigationController。</li>
<li><a href="https://github.com/mutualmobile/MMDrawerController">MMDrawerController</a> - 最多人用的一个有关侧边“抽屉”导航框架，里面还有很多你意想不到的交互效果，侧滑。</li>
<li><a href="http://code.cocoachina.com/detail/316925/UIWebView%E7%BF%BB%E9%A1%B5%E8%BF%94%E5%9B%9E%E6%95%88%E6%9E%9C%EF%BC%88%E5%8F%98%E9%80%9A%E6%96%B9%E6%B3%95%EF%BC%89/">UIWebView翻页返回效果</a> - UIWebView翻页返回效果（变通方法）。</li>
<li><a href="https://github.com/lilei644/LLSlideMenu">LLSlideMenu</a> - 一个弹性侧滑菜单,弹性动画原理借鉴该项目中阻尼函数实现。</li>
</ul>


<h5>gif动画</h5>

<ul>
<li><a href="https://github.com/yfme/UIImageView-PlayGIF">UIImageView-PlayGIF</a> - UIImageView-PlayGIF。</li>
<li><a href="https://github.com/liyong03/YLGIFImage">YLGIFImage</a> - YLGIFImage。</li>
<li><a href="https://github.com/liyong03/YLGIFImage-Swift">YLGIFImage-Swift</a> - YLGIFImage-Swift。</li>
<li><a href="https://github.com/mortenjust/droptogif">droptogif</a> -  droptogif视频拖拽到应用窗口后自动转换为 GIF 动画（其转换进程动画效果也超赞）。</li>
</ul>


<h5>其他动画</h5>

<ul>
<li><a href="https://github.com/schneiderandre/popping">popping</a> - popping是一个POP 使用实例工程</li>
<li><a href="https://github.com/xhzengAIB/SinaMenuView">SinaMenuView</a> - 用POP动画引擎写的Sina微博的Menu菜单。</li>
<li><a href="https://github.com/adad184/MMTweenAnimation">MMTweenAnimation</a> - facebook POP的自定义动画扩展(基于POPCustomAnimation) 提供10种函数式动画。</li>
<li><a href="https://github.com/pingguo-zangqilong/ZQLRotateMenu">ZQLRotateMenu</a> - 这是一个旋转视图的选择器。</li>
<li><a href="https://github.com/pingguo-zangqilong/CoolLoadAniamtion">CoolLoadAniamtion</a> - 一个简单但是效果不错的loading动画。</li>
<li><a href="https://github.com/pingguo-zangqilong/SequenRotateAnimation">SequenRotateAnimation</a> - 一个简单的loading次序动画。</li>
<li><a href="https://github.com/441088327/SYAppStart">SYAppStart</a> - App启动插画的自定义过度。</li>
<li><a href="https://github.com/victorjiang/UIImage-VJDeviceSpecificMedia/">VJDeviceSpecificMedia</a> - <a href="http://www.imooc.com/wenda/detail/249271">如何根据设备选择不同尺寸的图片</a> 可以通过设置不同尺寸设备的LaunchImage，来使得App适配这些设备，要是在不同不同尺寸设备上使用不同大小的图片，则需要在代码中一一判断，然后加载。</li>
<li><a href="https://github.com/michaelbabiy/RMParallax">RMParallax</a> - RMParallax是一个app启动页引导开源项目，除了细微的翻页视差效果，描述文本的过渡也非常美观（版本新特性、导航页、引导页）。</li>
<li><a href="https://github.com/Nododo/ADo_GuideView">ADo_GuideView</a> - 转动的用户引导页(模仿网易bobo) 因为没有从app包里抓到@3x的图片,建议在iPhone5模拟器运行,保证效果~ （版本新特性、导航页、引导页）。</li>
<li><a href="https://github.com/nsdictionary/CoreNewFeatureVC">CoreNewFeatureVC</a> - 版本新特性（引导页），1.封装并简化了版本新特性启动视图！2.添加了版本的本地缓存功能，3.集成简单，使用方便，没有耦合度，4.支持block回调（版本新特性、导航页、引导页）。</li>
<li><a href="https://github.com/MachelleZhang/MZGuidePages">MZGuidePages</a> - 自己写的通用导航页，可以直接引入工程使用，请参考案例（版本新特性、导航页、引导页）。</li>
<li><a href="https://github.com/AdamBCo/ABCIntroView">ABCIntroView</a> - ABCIntroView是一个易于使用的入门类，让你到达主屏幕之前介绍你的应用程序（版本新特性、导航页、引导页）。</li>
<li><a href="https://github.com/MengTo/Spring">Spring</a> - Spring是一个Swift编写的开源库，可简化Swift编写的iOS动画。支持shake、pop、morph、squeeze、wobble、swing、flipX、flipY、fall、squeezeLeft、squeezeRight以及squeezeDown等多种动画形式，用 IBDesignable 让使用者可以在 Xcode 中快速设置动画效果。</li>
<li><a href="https://github.com/KittenYang/KYBezierBounceView">KYBezierBounceView</a> - 手势控制贝塞尔曲线，取消手势贝塞尔曲线会有反弹效果。</li>
<li><a href="http://kittenyang.com/cadisplaylinkanduibezierpath/">cadisplaylinkanduibezierpath</a> - CADisplayLink结合UIBezierPath的神奇妙用。</li>
<li><a href="https://github.com/KittenYang/KYCuteView">KYCuteView</a> - 实现类似QQ消息拖拽消失的交互+GameCenter的浮动小球效果，<a href="http://kittenyang.com/drawablebubble/">分析</a>。</li>
<li><a href="https://github.com/KittenYang/KYWaterWaveView">KYWaterWaveView</a> - 一个内置波浪动画的UIView，里面有鱼跳跃水溅起来的效果。</li>
<li><a href="https://github.com/KittenYang/KYPingTransition">KYPingTransition</a> - 实现圆圈放大放小的转场动画，可以根据自己的需要使用Paper中的弹性效果，有Material风格。</li>
<li><a href="https://github.com/KittenYang/KYNewtonCradleAnimiation">KYNewtonCradleAnimiation</a> - 牛顿摆动画。</li>
<li><a href="https://github.com/scotteg/LayerPlayer">LayerPlayer</a> - 一款全面展示核心动画 API 示例项目（上架应用）。包括 CALayer, CAScrollLayer, CATextLayer, AVPlayerLayer, CAGradientLayer, CAReplicatorLayer, CATiledLayer, CAShapeLayer, CAEAGLLayer, CATransformLayer, CAEmitterLayer 等使用的互动演示。</li>
<li><a href="https://github.com/JayGajjar/JGTransitionCollectionView">JGTransitionCollectionView</a> - swift，基于集合视图扩展实现完成自动布局及单元项 Flip式动画效果（效果很赞）。组件使用方便、自然（只需设置集合视图数据源的标准方式即可）。</li>
<li><a href="https://github.com/KittenYang/KYShareMenu">KYShareMenu</a> - 带弹性动画的分享菜单。</li>
<li><a href="https://github.com/Yalantis/Context-Menu.iOS">Context-Menu.iOS</a> - 可以为app的菜单添加漂亮的动画内容，可自定义icon，并可根据自己的喜好设计单元格和布局。</li>
<li><a href="https://github.com/LuciusLu/DeformationButton">DeformationButton</a> - 一个简单的变换形状动画按钮。</li>
<li><a href="https://github.com/heroims/UnReadBubbleView">UnReadBubbleView</a> - UnReadBubbleView是一个能够拖拽并拉长的气泡视图。拖拽到一定的长度会消失，可以通过系数设置来控制拖拽的长度。气泡也支持多种属性设置。</li>
<li><a href="https://github.com/smallmuou/PPDragDropBadgeView">PPDragDropBadgeView</a> - 实现了类似于QQ 5.0 水滴拖拽效果. 支持iOS 5.0+ ARC，气泡能够带有数字标识，同时支持消失block方法。消失时还带有消失效果动画。</li>
<li><a href="https://github.com/MartinRGB/GiftCard-Implementation">GiftCard-Implementation</a> - 购买的炫酷动画。</li>
<li><a href="https://github.com/gsdios/SDCycleScrollView">SDCycleScrollView</a> - 无限循环自动图片轮播器(一步设置即可使用)。</li>
<li><a href="https://github.com/johnlui/Swift-On-iOS/tree/master/BuildAnInfiniteCarousel">BuildAnInfiniteCarousel</a> - 自己动手造无限循环图片轮播，<a href="https://autolayout.club/2015/10/29/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E9%80%A0%E6%97%A0%E9%99%90%E5%BE%AA%E7%8E%AF%E5%9B%BE%E7%89%87%E8%BD%AE%E6%92%AD/">教程</a>。</li>
<li><a href="https://github.com/nicklockwood/iCarousel">iCarousel</a> - iCarousel是一个类，它继承于UIView。用于简化实现各种类型的旋转木马(分页滚动视图），无限轮播 ，<a href="http://www.cocoachina.com/ios/20150828/13198.html">iOS开发之多图片无缝滚动组件封装与使用</a>。</li>
<li><a href="https://github.com/smartwalle/KIPageView">KIPageView</a> - 无限循环PageView，横向TableView，无限轮播。</li>
<li><a href="http://code.cocoachina.com/view/128288">简单实用的无限循环轮播图</a> - 简单实用的无限循环轮播图 。</li>
<li><a href="https://github.com/Akateason/XTLoopScroll">XTLoopScroll</a> - 用两个 timer 三个重用的 view 实现无限循环 scrollView，1自动轮播 2点击监听回调当前图片 3手动滑动后重新计算轮播的开始时间, 良好的用户体验。</li>
<li><a href="https://github.com/zangqilong198812/HotGirls">HotGirls</a> - 卡片动画。</li>
<li><a href="https://github.com/tispr/tispr-card-stack">tispr-card-stack</a> - swift 卡片风格动画切换组件及完整交互示例。</li>
<li><a href="https://github.com/zhxnlai/ZLSwipeableViewSwift">ZLSwipeableViewSwift</a> - swift 卡片堆叠效果的实现（ZLSwipeableView)】可实现类似Tinder和Potluck应用程序的卡片堆叠效果，该项目基于<a href="https://github.com/zhxnlai/ZLSwipeableView/">ZLSwipeableView objective-c</a>实现。1.自定义动画。2.自定义滑动切换。3.自定义方向。4.撤销。</li>
<li><a href="https://github.com/Yalantis/Koloda">Koloda</a> - 基于卡片的 Tinder-style 动画效果示例。精细绝人。更赞的是额外附了详细开发教程 How We Built Tinder-Like Koloda Animation in Swift <a href="https://yalantis.com/blog/how-we-built-tinder-like-koloda-in-swift/">网页链接</a> 。Yalantis 出品动画程序款款精品。</li>
<li><a href="https://github.com/zangqilong198812/QQPersonalInfoTransition">QQPersonalInfoTransition</a> - 仿照QQ的转场。</li>
<li><a href="https://github.com/KittenYang/KYAnimatedPageControl">KYAnimatedPageControl</a> - 除了滚动视图时PageControl会以动画的形式一起移动，点击目标页还可快速定位。支持两种样式：粘性小球和旋转方块。</li>
<li><a href="https://github.com/likedan/KDIntroView">KDIntroView</a> - swift 动态介绍视图框架及演示。另外两个相似的类库是 RazzleDazzle和 Presentation，择需使用。</li>
<li><a href="https://github.com/IFTTT/RazzleDazzle">RazzleDazzle</a> - 【IFTTT开源Swift编写的帧动画框架&ndash;RazzleDazzle】RazzleDazzle 是IFTTT开源的一个iOS帧动画框架，非常适用于APP初次使用时的介绍和引导信息。JazzHands是UIKit一个简单的关键帧基础动画框架，可通过手势、scrollview、KVO等控制动画，被IFTTT应用在IFTTT for iPhone上。</li>
<li><a href="https://github.com/hyperoslo/Presentation">Presentation</a> - 一个类似RazzleDazzle的框架。</li>
<li><a href="https://github.com/poolqf/FillableLoaders">FillableLoaders</a> - 基于 CGPaths 可定制个性化填空式装载类库。附水波上涨式示例。</li>
<li><a href="https://github.com/dsxNiubility/SXWaveAnimate">SXWaveAnimate</a> - 实现非常美观的灌水动画。</li>
<li><a href="https://github.com/liusen001/LSPaomaView">LSPaomaView</a> - 可循环滚动的较长文字，跑马灯，效果很好，一句话集成。</li>
<li><a href="https://github.com/ProudOfZiggy/SIFloatingCollection_Swift">SIFloatingCollection_Swift</a> - 可定制的 Apple Music 风格浮动形状动画组件及演示。</li>
<li><a href="https://github.com/suguru/Cheetah">Cheetah</a> - 易用、高可读链式动画类库。另一个类似类库是 <a href="https://github.com/Draveness/DKChainableAnimationKit">DKChainableAnimationKit</a>。</li>
<li><a href="https://github.com/CezaryKopacz/CKWaveCollectionViewTransition">CKWaveCollectionViewTransition</a> - swift， UICollectionViewController之间切换的动画。</li>
<li><a href="https://github.com/entotsu/TKSubmitTransition">TKSubmitTransition</a> - 基于 UIButton 的登录加载、返回按钮转场动画组件及示例。</li>
<li><a href="https://github.com/AugustRush/ARAnimation">ARAnimation</a> - ARAnimation 对 Core Animation 进行了封装, 帮助 iOS 开发者能更加便捷的在项目中使用动画。</li>
<li>[CardsAnimationDemo]<a href="https://github.com/adow/CardsAnimationDemo">https://github.com/adow/CardsAnimationDemo</a>) - swift， <a href="http://swiftcn.io/topics/64?f=w">《使用 UICollectionView 实现的一个卡片动画》</a>不是直接操作所有 UIView 和 CALayer 的 transform3D 属性来实现整个效果的，而是使用 UICollectionView 来完成所有的视图管理和实现。。</li>
<li><a href="https://github.com/TBXark/TKRubberIndicator">TKRubberIndicator.swift</a> - 一个很不错的 page control。</li>
<li><a href="http://code.cocoachina.com/view/127174">渐变特效文字</a> - 做了一个仿iPhone的移动滑块来解锁的渐变特效文字,还有一个类似ktv歌词显示的文字特效。</li>
<li><a href="https://github.com/zekunyan/TTGEmojiRate">TTGEmojiRate.swift</a> - TTGEmojiRate.swift以Emoji表情为基础绘图，<a href="http://tutuge.me/2015/10/25/ttgemojirate-lib/">Swift开源项目: TTGEmojiRate的实现</a>。</li>
<li><a href="https://github.com/nathanwhy/HYAwesomeTransition">HYAwesomeTransition</a> - 模仿格瓦拉的转场效果。</li>
<li><a href="https://github.com/seedante/CardAnimation">CardAnimation.swift</a> - CardAnimation 是国人开发的一个用 Swift 实现卡片垂直翻转动画的 Demo, <a href="http://www.jianshu.com/p/286222d4edf8">实现思路</a>。</li>
<li><a href="https://github.com/Glow-Inc/TaskSwitcherDemon">TaskSwitcherDemon</a> -  是仿造iOS9的Task Switcher做出来的动画效果, 具体的实现思路可参照<a href="http://tech.glowing.com/cn/implement-ios9-task-switcher-animation/">这篇文章</a>。</li>
<li><a href="https://github.com/lzwjava/CoreAnimationCode">CoreAnimationCode.swift</a> - 提供了 &ldquo;iOS Core Animation Advanced Techniques&rdquo; 书籍中的代码实例, 方便开发者们进行参考学习。</li>
<li><a href="https://github.com/xxycode/UIViewXXYBoom">UIViewXXYBoom.swift</a> - 一个炫酷好玩的爆炸效果，<a href="http://xxycode.com/ru-he-zhi-zuo-ge-xuan-ku-hao-wan-de-bao-zha-xiao-guo-2/">如何实现这个效果</a>。</li>
<li><a href="https://github.com/zhxnlai/ZLSwipeableViewSwift">ZLSwipeableViewSwift</a> - <a href="https://github.com/zhxnlai/ZLSwipeableView">ZLSwipeableView</a> - ZLSwipeableViewSwift在Tinder and Potluck中的动画效果实现思路（连续卡片翻页效果），最贴心的是作者提供了OC和Swift两个版本来供开发者使用，非常丝滑顺畅的效果。</li>
</ul>


<hr />

<h4>网络相关</h4>

<h5>网络连接</h5>

<ul>
<li><a href="https://github.com/AFNetworking/AFNetworking">AFNetworking</a> - ASI不升级以后，最多人用的网络连接开源库，<a href="http://www.superqq.com/blog/2014/11/07/ioswang-luo-bian-cheng-zhi-afnetworkingshi-yong/">iOS网络编程之AFNetworking使用</a>,<a href="http://www.superqq.com/blog/2015/01/29/ioskai-fa-xia-zai-wen-jian-su-du-ji-suan/">iOS开发下载文件速度计算</a> , <a href="http://www.cocoachina.com/ios/20151022/13831.html">AFNetworking 3.0迁移指南</a> , <a href="http://www.cocoachina.com/ios/20140829/9480.html">AFNetworking2.0源码解析&lt;一></a> 、<a href="http://www.cocoachina.com/ios/20140904/9523.html">AFNetworking2.0源码解析&lt;二></a>、<a href="http://www.cocoachina.com/ios/20140916/9632.html">AFNetworking源码解析&lt;三></a>、<a href="http://www.cocoachina.com/ios/20141120/10265.html">AFNetworking源码解析&lt;四></a>。</li>
<li><a href="https://github.com/Alamofire/Alamofire">Alamofire</a> - Alamofire是AFNetworking的作者mattt新写的网络请求的swift库。</li>
<li><a href="https://github.com/yuantiku/YTKNetwork">YTKNetwork</a> - 是基于 AFNetworking 封装的 iOS网络库，提供了更高层次的网络访问抽象。相比AFNetworking，YTKNetwork提供了以下更高级的功能：按时间或版本号缓存网络请求内容、检查返回 JSON 内容的合法性、文件的断点续传、批量的网络请求发送、filter和插件机制等。</li>
<li><a href="https://github.com/DeveloperLx/LxFTPRequest">LxFTPRequest</a> - 支持获取FTP服务器资源列表，下载/上传文件，创建/销毁ftp服务器文件/目录，以及下载断点续传，下载/上传进度，自动判断地址格式合法性跟踪等功能！国人开发，QQ：349124555。</li>
<li><a href="https://github.com/HHuiHao/HSDownloadManager">HSDownloadManager</a> - HSDownloadManager，下载音乐、视频、图片各种资源，支持多任务、断点下载。</li>
<li><a href="https://github.com/HHuiHao/MutableUploadDemo">MutableUploadDemo</a> - 模拟需求：图文混编，要求用户选择图片后就上传，可选择多图，并行上传，用户确定提交后后台执行，必须全部图片上传完才能提交文字。</li>
<li><a href="https://github.com/swtlovewtt/WTRequestCenter">WTRequestCenter</a> - 方便缓存的请求库，提供了方便的HTTP请求方法，传入请求url和参数，返回成功和失败的回调。 UIKit扩展提供了许多不错的方法，快速缓存图片，图片查看，缩放功能， 颜色创建，设备UUID，网页缓存，数据缓存等功能。 无需任何import和配置，目前实现了基础需求。</li>
<li><a href="https://github.com/mutualmobile/MMWormhole">MMWormhole</a> - Message passing between iOS apps and extensions 2个iOS设备之间通信。</li>
<li><a href="https://github.com/socketio/socket.io-client-swift">socket.io-client-swift</a> - WebSockect 客户端类库。开放的通讯协议，有利于构建强大地跨平台应用。</li>
<li><a href="https://github.com/nghialv/Transporter">Transporter</a> - swift， 短小、精悍、易用的多文件（并发或顺序）上传和下载传输库。还支持后台运行、传输进程跟踪、暂停/续传/取消/重试控制等功能。</li>
<li><a href="https://github.com/kevin0571/STNetTaskQueue">STNetTaskQueue</a> - STNetTaskQueue Objective-C 可扩展网络请求管理库。</li>
<li><a href="https://github.com/robbiehanson/CocoaAsyncSocket">CocoaAsyncSocket</a> - 在iOS开发中使用socket，一般都是用第三方库AsyncSocket，不得不承认这个库确实很强大，<a href="http://www.superqq.com/blog/2015/04/03/ioskai-fa-zhi-asyncsocketshi-yong-jiao-cheng/">使用教程</a>。</li>
<li><a href="https://github.com/eugenehp/GCDAsyncSocket">GCDAsyncSocket</a> - GCDAsyncSocket ， <a href="https://github.com/smalltask/TestTcpConnection">不错的Demo</a>。</li>
<li><a href="https://github.com/JustHTTP/Just">Just</a> - 小而美的 HTTP 类。功能简单、直接、完整且健壮性高&ndash; swift。</li>
<li><a href="https://github.com/nghialv/Future">Future</a> - 基于微框架设计思想的异步执行及结果响应类，代码即简单又干净&ndash; swift。</li>
<li><a href="https://github.com/mzeeshanid/MZDownloadManager">MZDownloadManager</a> - 下载管理。</li>
<li><a href="https://github.com/venmo/DVR">DVR</a> - 针对网络请求的测试框架，超实用的工具。且支持 iOS, OSX, watchOS 全平台。</li>
<li><a href="https://github.com/hongfenglt/HFDownLoad">HFDownLoad</a> - iOS开发网络篇之文件下载、大文件下载、断点下载:NSData方式、NSURLConnection方式、NSURLSession下载方式 <a href="http://blog.csdn.net/hongfengkt/article/details/48290561">下载方式具体的思路、区别见Blog</a> 。</li>
<li><a href="https://github.com/johnlui/Pitaya">Pitaya.swift</a> - Pitaya 是纯 Swift 写的 iOS 网络库，支持 Basic Authorization、SSL 钢钉、HTTP raw body / JSON body、快速文件上传等特性，并通过内置 JSONNeverDie 实现了对 JSON 的完全支持，开箱即用。 <a href="https://github.com/johnlui/Pitaya/wiki/%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3">中文文档</a></li>
</ul>


<h5>图像获取</h5>

<ul>
<li><a href="https://github.com/rs/SDWebImage">SDWebImage</a> - SDWebImage 网络图片获取及缓存处理。</li>
<li><a href="https://github.com/onevcat/Kingfisher">Kingfisher</a> - 纯 Swift 实现的类 SDWebImage 库，实现了异步下载和缓存图片。</li>
<li><a href="https://github.com/kiavashfaisali/KFSwiftImageLoader">KFSwiftImageLoader</a> - Swift，一个图像缓存加载库。</li>
<li><a href="https://github.com/path/FastImageCache">FastImageCache</a> - FastImageCache 网络图片获取及缓存处理，<a href="http://www.imooc.com/wenda/detail/247239">iOS图片加载速度极限优化—FastImageCache解析</a>。</li>
<li><a href="https://github.com/enormego/EGOCache">EGOCache</a> - 十分知名的第三方缓存类库，可以缓存NSString、UIImage、NSImage以及NSData。除此，如果还可以缓存任何一个实现了<NSCoding>接口的对象。所有缓存的数据都可以自定义过期的时间，默认是1天。EGOCache 支持多线程（thread-safe），<a href="http://www.superqq.com/blog/2014/11/06/ioskai-fa-:uitableviewjia-zai-duo-zhang-zhao-pian-dao-zhi-nei-cun-shang-zhang-de-wen-ti/">UITableView加载多张照片导致内存上涨的问题</a>。</li>
<li><a href="https://github.com/ibireme/YYWebImage/">YYWebImage</a> - 一个图片加载库 YYWebImage，支持 APNG、WebP、GIF 播放，支持渐进式图片加载，更高性能的缓存，更多图像处理方法，可以替代 SDWebImage 等开源库，<a href="http://blog.ibireme.com/2015/11/02/mobile_image_benchmark/">相关文章</a>。</li>
</ul>


<h5>网络聊天</h5>

<ul>
<li><a href="https://github.com/robbiehanson/XMPPFramework">XMPPFramework</a> - XMPPFramework openfire聊天。</li>
<li><a href="https://github.com/dsxNiubility/SXTheQQ">SXTheQQ</a> - 用xmppFramework框架编写QQ程序，主要为了练习通讯的一些原理，界面比较渣 必须要先在本地配置好环境才可以运行。</li>
<li><a href="http://www.easemob.com/">环信</a> - 给开发者更稳定IM云功能。8200万用户考验，好用！（暂无及时语音、视频通话）</li>
<li><a href="http://www.rongcloud.cn/">融云</a> - 即时通讯云服务提供商。（暂无及时语音、视频通话）</li>
<li><a href="http://www.yuntongxun.com">容联云通讯</a> - 提供基于互联网通话,视频会议,呼叫中心/IVR,IM等通讯服务。</li>
<li><a href="https://github.com/ChatSecure/ChatSecure-iOS">chatsecure</a> - 基于XMPP的iphone、android加密式聊天软件， <a href="https://chatsecure.org/">chatsecure官网</a> 。 <a href="https://github.com/chrisballinger/Off-the-Record-iOS">iOS代码1</a>，<a href="https://github.com/chrisballinger/ChatSecure-iOS">iOS代码2</a>， <a href="http://www.cocoachina.com/bbs/read.php?tid=153156">iOS中文版</a>。</li>
<li><a href="https://github.com/xhzengAIB/MessageDisplayKit">MessageDisplayKit</a> - 仿微信聊天，参考JSQMessagesViewController。（国人写）</li>
<li><a href="https://github.com/jessesquires/JSQMessagesViewController">JSQMessagesViewController</a> - 聊天 。</li>
<li><a href="https://github.com/HanYaZhou1990/-SunFlower">SunFlower</a> - 环信聊天demo，比较多功能 。</li>
<li><a href="http://code4app.com/ios/BlueTalk%E8%93%9D%E7%89%99%E8%81%8A%E5%A4%A9-%E6%89%8B%E6%9C%BA%E4%B9%8B%E9%97%B4/552b8190933bf0291e8b4748">BlueTalk蓝牙聊天</a> - 以MultipeerConnectivity为基础， 实现了简单的蓝牙聊天。</li>
</ul>


<h5>网络测试</h5>

<ul>
<li><a href="https://github.com/tonymillion/Reachability">Reachability</a> - 苹果提供过一个Reachability类，用于检测网络状态。但是该类由于年代久远，并不支持ARC。该项目旨在提供一个苹果的Reachability类的替代品，支持ARC和block的使用方式。<a href="http://www.jianshu.com/p/efcfa3c87306">iOS网络监测如何区分2、3、4G</a></li>
<li><a href="https://github.com/ashleymills/Reachability.swift">Reachability.swift</a> - 用于替换苹果的 Reachability 类，可以方便地检测当前是否联网以及具体的联网状态。</li>
<li><a href="https://github.com/crazypoo/SimpleCarrie">SimpleCarrie</a> - 简单的运营商信息获取!。</li>
<li><a href="https://github.com/crazypoo/SimpleCarrie">NetReachability</a> - swift2.0 简单的方法检查网络连接的连通性，提供通知中心集成接口。</li>
<li><a href="https://github.com/coderyi/NetworkEye">NetworkEye</a> - 一个网络调试库，可以监控App内HTTP请求并显示请求相关的详细信息，方便App开发的网络调试。</li>
<li><a href="https://github.com/bin1991/SimpleBS">SimpleBS.swift</a> - 网络测试小工具。</li>
</ul>


<h5>WebView</h5>

<ul>
<li><a href="https://github.com/mattgemmell/MGTemplateEngine">MGTemplateEngine</a> - MGTemplateEngine比较象 PHP 中的 Smarty、FreeMarker 和 Django的模版引擎，是一个轻量级的引擎，简单好用。只要设置很多不同的HMTL模版，就能轻松的实现一个View多种内容格式的显示，对于不熟悉HTML或者减轻 工作量而言，把这些工作让设计分担一下还是很好的，也比较容易实现设计想要的效果。</li>
<li><a href="https://github.com/ninjinkun/NJKWebViewProgress">NJKWebViewProgress</a> - 一个 UIWebView 的进度条接口库,UIWebView 本身是不提供进度条的。</li>
<li><a href="https://github.com/siriusdely/GTMNSString-HTML">GTMNSString-HTML</a> - 谷歌开源的用于过滤HTML标签。</li>
</ul>


<hr />

<h4>Model</h4>

<ul>
<li><a href="https://github.com/johnezang/JSONKit">JSONKit</a> - JSONKit库是非常简单易用而且效率又比较高的，重要的JSONKit适用于ios 5.0以下的版本,使用JSONKit库来解析json文件，只需要下载JSONKit.h 和JSONKit.m添加到工程中；然后加入libz.dylib即可。</li>
<li><a href="https://github.com/icanzilb/JSONModel">JSONModel</a> - 解析服务器返回的Json数据的库,<a href="http://www.jianshu.com/p/3d795ea37835">JSONModel源码解析一</a>。</li>
<li><a href="https://github.com/Mantle/Mantle">Mantle</a> - Mantle主要用来将JSON数据模型化为OC对象, 大系统中使用。<a href="http://www.iwangke.me/2014/10/13/Why-Changba-iOS-choose-Mantle/">为什么选择Mantle</a>。</li>
<li><a href="https://github.com/refusebt/RFJModel">RFJModel</a> - RFJModel是一个IOS类库，可以将JSON字典自动装填到OBJC对象。相比JSONModel有一些非常好的特性，使用上也比较简单。</li>
<li><a href="https://github.com/nicklockwood/XMLDictionary">XMLDictionary</a> - ios与mac os平台下xml与NSDictionary相互转化开源类库。</li>
<li><a href="https://github.com/CoderMJLee/MJExtension">MJExtension</a> - 用于json转model进行使用，转换效率很高，使用也比较简单，只要前后台约定好，json直接就转成了model。</li>
<li><a href="https://github.com/CoderMJLee/MJExtension">CFRuntime</a> - “Swift 版的 MJExtension，运行时、反射与一键字典模型互转”。</li>
<li><a href="https://github.com/openboy2012/DDModel">DDModel</a> - 快速搭建项目Model层，支持ORM映射关系，能从JSON/XML直接实例一个Model对象。支持SQLite本地数据持久化，封装了HTTP， 减少HTTP代码与UIViewController的代码耦合，支持Cache；类似RESTKit、Mantle的功能；使用该类库以后简化了网络层的开发工作，把更多的精力放在UI上面；目前只支持GET/POST方法的请求。使用到的第三方库有：1.SQLitePersistentObject; 2.JTObjectMapping; 3.AFNetworking; 4.XMLDictionary;</li>
<li><a href="https://github.com/alexeyxo/protobuf-swift">protobuf-swift</a> - Protocol Buffers 的 Swift 语言实现库。P.S. Protocol Buffers 是 Google 开源项目，主要功能是实现直接序列化结构化的对象数据，方便跨平台快速传递，开发者也可以直接修改 protobuf 中的数据。相比 XML 和 JSON，protobuf 解析更快，存储更小。</li>
<li><a href="https://github.com/matthewcheok/JSONCodable">JSONCodable</a> - 基于 Swift 2.0 新特性（Protocol Extensions and Error Handling）的JSON 解析类。</li>
<li><a href="https://github.com/SwiftyJSON/SwiftyJSON">SwiftyJSON</a> - 使Swift的JSON解析变得简单。</li>
<li><a href="https://github.com/johnlui/JSONNeverDie">JSONNeverDie.swift</a> - JSON 到 Model 类的自动映射工具。</li>
<li><a href="https://github.com/cezheng/Fuzi">Fuzi.swift</a> - Swift实现的轻量快速的 XML/HTML 解析器。</li>
<li><a href="https://github.com/drmohundro/SWXMLHash">SWXMLHash.swift</a> - 易用的 XML 解析类库。非常实用的“轮子”。</li>
<li><a href="https://github.com/ibireme/YYModel">YYModel</a> - 高性能的 iOS JSON 模型框架。</li>
</ul>


<hr />

<h4>通讯录</h4>

<ul>
<li><a href="http://code.cocoachina.com/view/128245">快速查找联系人</a> - 类似微信联系人搜索的界面,快速查找联系人,并支持点击查询结果 。</li>
</ul>


<hr />

<h4>其他</h4>

<ul>
<li><a href="https://github.com/exsortis/DateTimeKit">DateTimeKit</a> - 一个超赞的时间处理的库，Joda-Time ！ 他能帮你轻松处理时区，处理时间加减，计算到期时间等等场景下的问题。</li>
<li><a href="https://github.com/malcommac/SwiftDate">SwiftDate</a> - 特别完整、强大的日期时间操作管理类库。它几乎涵盖了已知开源日期类库所有优秀特性。 他能帮你轻松处理时区，处理时间加减，计算到期时间等等场景下的问题。</li>
<li><a href="https://github.com/nst/iOS-Runtime-Headers">iOS私有API</a> - 私有API，绿色 == public，红色 == private，蓝色 == dylib。</li>
<li><a href="http://opensource.apple.com/source/CF/">iOS源代码</a> - iOS源代码。</li>
<li><a href="https://github.com/ShiqiYu/libfacedetection">libfacedetection</a> - C++ 人脸识别 包含正面和多视角人脸检测两个算法.优点:速度快(OpenCV haar+adaboost的2-3倍), 准确度高 (FDDB非公开类评测排名第二），能估计人脸角度。</li>
<li><a href="https://github.com/Brimizer/Slidden">Slidden</a> - 一个老外开源的开发自定义键盘的库，利用这个开源库，可以方便的配置键位、颜色以及键位对应的图片。</li>
<li><a href="https://github.com/michaeltyson/TPKeyboardAvoiding">TPKeyboardAvoiding</a> - 用户键盘弹出自动计算高度，进行屏幕滚动操作。</li>
<li><a href="http://d.cocoachina.com/code/detail/298267">CDPMonitorKeyboard</a> - CDPMonitorKeyboard封装,可以解决输入视图(例如textField,textView等)被键盘覆盖问题，并可设置高于键盘多少。</li>
<li><a href="http://code.cocoachina.com/detail/297973/%E8%87%AA%E5%8A%A8%E7%9B%91%E5%90%AC%E9%94%AE%E7%9B%98%E9%AB%98%E5%BA%A6/">自动监听键盘高度</a> - 自动监听键盘高度，初始界面，输入框在屏幕最下方，当键盘出现时，输入框随即移动到键盘上方。</li>
<li><a href="https://github.com/Jiar/KeyboardToolBar/">KeyboardToolBar</a> - 从此不再担心键盘遮住输入框，<a href="http://www.jianshu.com/p/48993ff982c1">文档</a>。</li>
<li><a href="https://github.com/441088327/SYKeyboardTextField">SYKeyboardTextField</a> - SYKeyboardTextField 是一个轻巧,简单,非侵入式的键盘附随输入框! 采用Swift编写。</li>
<li><a href="https://github.com/zwaldowski/BlocksKit">BlocksKit</a> - block框架，为 OC 常用类提供了强大的 Block 语法支持，使得编写 OC 代码变得舒适、快速、优雅。</li>
<li><a href="https://github.com/facebook/KVOController">KVOController</a> - 在项目中有使用 KVO ，那么 KVOController 绝对是个好选择。它是 facebook 开源的一个 KVO 增强框架。</li>
<li><a href="https://github.com/arashpayan/appirater">appirater</a> - 用于提醒用户给你的 APP 打分的工具。</li>
<li><a href="https://github.com/MHaroonBaig/MotionKitr">MotionKitr</a> - 为核心运动框架（The Core Motion framework）提供友好的类库封装，以更方便使用三轴陀螺仪和加速感应器特性。</li>
<li><a href="https://launchkit.io/reviews/">Review Monitor</a> -  第一时间自动推送 Apple Store 的用户评论到你的邮件箱或者 Slack，第一时间跟进用户反馈，打造优秀 App 必备工具！类似的有：App annie 的类似功能。</li>
<li><a href="https://github.com/Naituw/WBWebViewConsole">WBWebViewConsole</a> - 类似微博iPhone客户端的 “调试选项” 吗？把其中的 “内置浏览器网页调试” 开源在 Github 上了。</li>
<li><a href="https://github.com/futurice/ios-good-practices">ios-good-practices</a> - ios-good-practices iOS 开发最佳实践。</li>
<li><a href="http://ios.jobbole.com/81830/">iOS开发最佳实践</a> - iOS 开发最佳实践 &ndash; 中文。</li>
<li><a href="http://code.cocoachina.com/detail/232160">TodayExtensionSharingDefaults</a> - TodayExtensionSharingDefaults是一个iOS 8 Today扩展示例，可以使用NSUserDefaults与其containing app分享数据。</li>
<li><a href="https://github.com/yannickl/QRCodeReader.swift">QRCodeReader.swift</a> - QRCodeReader.swift一款简单的 QR 二维码阅读组件及示例，提供前后相机切换功能。</li>
<li><a href="https://github.com/MxABC/swiftScan">swiftScan</a> - 具有丰富功能的二维码扫描组件及类库。<a href="https://github.com/MxABC/LBXScan">对应OC版本LBXScan</a>。</li>
<li><a href="https://github.com/appcoda/QR-Code-Generator">QR-Code-Generator.swift</a> - 生成二维码。</li>
<li><a href="https://github.com/100mango/QRCatcher">QRCatcher</a> - 一个简洁美观的二维码扫描应用， <a href="https://github.com/100mango/zen/blob/master/iOS%E5%AD%A6%E4%B9%A0%EF%BC%9AAVFoundation%20%E8%A7%86%E9%A2%91%E6%B5%81%E5%A4%84%E7%90%86/iOS%E5%AD%A6%E4%B9%A0%EF%BC%9AAVFoundation%20%E8%A7%86%E9%A2%91%E6%B5%81%E5%A4%84%E7%90%86%20.md">iOS学习：AVFoundation 视频流处理&ndash;二维码扫描</a>。</li>
<li><a href="https://github.com/zhengjinghua/MQRCodeReaderViewController">MQRCodeReaderViewController</a> - 二维码扫描控件, UI 做了优化, 仿造微信, 直接拖进项目就可使用。</li>
<li><a href="https://github.com/ayanonagon/Parsimmon">Parsimmon</a> - swift，小而美的语言学类库封装工具包。提供分词、标记词性、词形归并、朴素贝页斯分类、决策树等自然语言分析小工具。P.S. 英语分词效果好于中文，感兴趣的同学可以针对中文做一些优化开发。参考译文 NSHipster - <a href="http://nshipster.cn/nslinguistictagger/">NSLinguistic​Tagger</a>。</li>
<li><a href="https://github.com/liuchunlao/Password-keyboard">Password-keyboard</a> - 随机变换数字位置的密码键盘。 模仿银行类应用在付款时输入的随机密码键盘。</li>
<li><a href="https://github.com/SemperIdem/MKMapView-Extension">MKMapView-Extension</a> - 这是关于 MKMapView 写的一个基于swift的扩展，可以扩展 MKMapView 的相关功能，减少复用代码量。</li>
<li><a href="https://github.com/nomothetis/SemverKit">SemverKit</a> - 针对符合『语义化版本规范 2.0.0』版本号的解析、比较运算类库。不仅支持 Major, Minor, Patch，还支持 Alpha 和 Beta 预发布版本，以及相应地递增运算扩展。</li>
<li><a href="https://github.com/jpotts18/SwiftValidator">SwiftValidator</a> - 基于规则的输入验证类库。项目良好的面向对象设计思想，使规则的扩展及自定义非常方便。更专业的规则引擎（甚至是基于自然语言的规则配置）解决方案，比如：开源的 Drools，商用的 ILOG 等。</li>
<li><a href="https://github.com/gali8/Tesseract-OCR-iOS">Tesseract-OCR-iOS</a> - 有关OCR文字识别项目。</li>
<li><a href="https://github.com/osnr/Screenotate">Screenotate</a> - 支持 OCR 文字识别的载屏笔记 Mac 完整应用。</li>
<li><a href="http://cocoacats.com/">cocoacats</a> - 【分类汇总】里面收集了 iOS 中常用的分类文件，一直在更新。。</li>
<li><a href="https://github.com/nonstriater/Olla4iOS">Olla4iOS</a> - 过去积累的一些方便复用的类和方法，还在整理中。</li>
<li><a href="https://github.com/Draveness/DKNightVersion">DKNightVersion</a> - 用最快的方式给你的应用加上夜间和白天的切换效果。</li>
<li><a href="https://github.com/morizotter/TouchVisualizer">TouchVisualizer</a> - 实用的多点触摸可视化组件。扩展并作用于 UIWindows，结构上提供了简单地针对触摸显示定制，比如触摸点的颜色。</li>
<li><a href="https://github.com/wezm/RegexKitLite">RegexKitLite</a> - 用来处理正则表达式。</li>
<li><a href="https://github.com/sharplet/Regex">Regex.swift</a> - 实用的正则表达式微框架类库。</li>
<li><a href="https://github.com/cezheng/PySwiftyRegex">PySwiftyRegex.swift</a> - 像Python一样简洁高效地作正则处理。</li>
<li><a href="https://github.com/marmelroy/PhoneNumberKit">PhoneNumberKit.swift</a> -  解析、格式化及验证国际电话号码工具库（相当于 Google 的 libphonenumber 库的 Swift 版本）。</li>
<li><a href="https://github.com/czechboy0/XcodeServerSDK">XcodeServerSDK</a> - 非官方 Xcode Server SDK 封装库。 P.S. 该 SDK 分离自之前推荐的由该作者开发的自动测试框架 <a href="https://github.com/czechboy0/Buildasaur">Buildasaur</a>。</li>
<li><a href="https://github.com/FabrizioBrancati/BFKit-Swift">BFKit-Swift</a> - BFKit-Swift 这套工具库可以提高应用开发效率。</li>
<li><a href="https://github.com/CloudKitSpace/CKSIncrementalStore">CKSIncrementalStore</a> - 基于 CloudKit 服务器实现多终端数据同步。</li>
<li><a href="https://github.com/oisdk/SwiftSequence">SwiftSequence</a> - 简洁、灵活、多变的操作 SequenceType 的类库（基于微框架（μframework）设计思想）。</li>
<li><a href="https://github.com/photondragon/IDNFeedParser">IDNFeedParser</a> - 一个简单易用的Rss解析库。</li>
<li><a href="https://github.com/nsdictionary/CoreUmeng">CoreUmeng</a> - 简单：友盟分享封装。</li>
<li><a href="https://github.com/100apps/openshare">openshare</a> - 不用官方SDK，利用社交软件移动客户端(微信/QQ/微博/人人/支付宝)分享/登录/支付。</li>
<li><a href="https://github.com/tomkowz/Swifternalization">Swifternalization</a> - 一套实用的本地化工具库。使用教程及 API 文档完整。值得收入项目的“轮子”。</li>
<li><a href="https://github.com/owensd/apous">apous</a> - 一款有趣的 Swift 应用 － 让 Swift 成为脚本语言。</li>
<li><a href="https://github.com/kostiakoval/Mirror">Mirror</a> - 通过反射（Refection）实现镜像对象封装库。从而可以更轻松获取（或输出）对象属性名、类型及值变量。</li>
<li><a href="https://github.com/nixzhu/Proposer">Proposer</a> - Proposer 用单个 API 处理 iOS 上的权限请求，以便使用前确认可访问“相册”、“相机”、“麦克风”、“通讯录”或“用户位置”。</li>
<li><a href="https://github.com/nickoneill/PermissionScope">PermissionScope</a> - 用这个库可以在询问用户前，就告知用户所需的系统权限，为用户带来更好的体验。接受度更高—>更多活跃用户->更高的留存率->数据更好->下载率更高。</li>
<li><a href="https://github.com/intuit/LocationManager">LocationManager</a> - CoreLocation使用起来还是比较麻烦的，需要授权，判断系统版本等等，所以推荐使用第三方框架LocationManager，使用Block，十分简单！<a href="http://www.cocoachina.com/ios/20150721/12611.html">iOS-CoreLocation：无论你在哪里，我都要找到你！</a> 。</li>
<li><a href="https://github.com/Cee/pangu.objective-c">pangu.objective-c</a> - 有多种语言实现版本～ Pangu.Objective-C：格式化中英文之间的空格（OC）。</li>
<li><a href="https://github.com/atomicobject/objection">objection</a> - 一个轻量级的依赖注入框架Objection。</li>
<li><a href="https://github.com/johnlui/Swift-On-iOS/tree/master/ControlOrientation/ControlOrientation">ControlOrientation</a> - 如何用代码控制以不同屏幕方向打开新页面【iOS】， <a href="http://lvwenhan.com/ios/458.html">使用说明</a>。</li>
<li><a href="https://github.com/nicklockwood/iRate">iRate</a> - 问卷调查。</li>
<li><a href="https://github.com/nihalahmed/GameCenterManager">GameCenterManager</a> - 在iOS上管理GameCenter vanilla并不算难，但是有了这个库会更简单也更快。好上加好不是更好么。</li>
<li><a href="https://github.com/slackhq/SlackTextViewController">SlackTextViewController</a> - 用作极佳、定制的文本输入控制时，自适应文本区域，手势识别、自动填充、多媒体合并，快速drop-in解决方案。</li>
<li><a href="https://github.com/saturngod/IAPHelper">IAPHelper</a> - 应用内付费给我们提供了很多样本代码，而这个库丢掉了那些代码，将金钱交易相关的大多通用任务做了简单的封装。</li>
<li><a href="https://github.com/JanC/TAPromotee">TAPromotee</a> - 交叉推广应用是你可以免费实现的最佳市场推广策略之一。使用这个库做起来非常简单，不用都不可能——将TAPromotee加入你的podfile中，免费配置与享受更多下载吧。</li>
<li><a href="https://github.com/cgwangding/DownloadFontOnline">DownloadFontOnline</a> - 实现了在线下载一些字体的功能，不用在工程中导入字体库，下载的字体也不会保存在你的应用中，所以可以放心使用。修复了一下崩溃的bug。</li>
<li><a href="https://github.com/zhenlintie/STClock">STClock</a> - 仿锤子时钟。</li>
<li><a href="https://github.com/git-up/GitUp">GitUp</a> - GitUp是一个可视化的Git客户端，能够实时的进行编辑、合并、回滚等多种操作，更多功能，请下载体验。</li>
<li><a href="http://code.cocoachina.com/detail/320392/">获取联系人信息，通讯录</a> - 获取联系人信息，通讯录。</li>
<li><a href="https://github.com/HHuiHao/Universal-Jump-ViewController">Universal-Jump-ViewController</a> - 根据规则跳转到指定的界面(runtime实用篇一)。</li>
<li><a href="https://github.com/Ekhoo/Device">Device-swift</a> - 可以非常方便的获取设备型号和屏幕尺寸，实现起来难度不大，大家可以学习一下源码。</li>
<li><a href="https://github.com/khoiln/RunKit">RunKit.swift</a> - 针对 GCD 框架的一个友好访问封装库（支持方法链式调用）。</li>
<li><a href="https://github.com/FlexMonkey/Plum-O-Meter">Plum-O-Meter</a> - swift 称重应用， (3D Touch之我见)[<a href="http://swift.gg/2015/10/23/3d-touch-impressions-and-thoughts/">http://swift.gg/2015/10/23/3d-touch-impressions-and-thoughts/</a>]。</li>
<li><a href="http://code.cocoachina.com/view/128249">打开自带地图、百度地图、腾讯地图</a> - 打开自带地图、百度地图、腾讯地图。</li>
<li><a href="https://github.com/colin1994/batteryLevelTest">batteryLevelTest</a> - runtime精准获取电池电量，<a href="http://www.jianshu.com/p/11c1afdf5415">文档</a>。</li>
<li><a href="https://github.com/100apps/openshare">openshare</a> - 不用官方SDK，利用社交软件移动客户端(微信/QQ/微博/人人/支付宝)分享/登录/支付。。</li>
<li><a href="https://github.com/MatthewYork/DateTools">DateTools</a> - 用于提高Objective-C中日期和时间相关操作的效率。灵感来源于 DateTime和Time Period Library。</li>
<li><a href="https://github.com/deepdevelop/DDSlackFeedback">DDSlackFeedback</a> - 用这个接口实现的摇一摇上传文字或者截屏反馈到你的 Slack channel，特别适合测试 app 的时候用，集成也很简单。</li>
<li><a href="https://github.com/coolnameismy/BabyBluetooth">BabyBluetooth</a> - 是一个非常容易使用的蓝牙库, 适用于 iOS 和 Mac OS, 基于原生 CoreBluetooth 框架封装, 可以帮开发者们更简单地使用 CoreBluetooth API, 使用链式方法体, 使得代码更简洁、优雅。</li>
<li><a href="https://github.com/rasmusth/BluetoothKit">BluetoothKit.swift</a> - 基于 CoreBluetooth API 实现iOS/OS X 设备间蓝牙通讯封装类库。功能强大、传输稳定，示例完整，很酷。</li>
<li><a href="https://github.com/bignerdranch/CoreDataStack">CoreDataStack.swift</a> - 存储栈。</li>
<li><a href="https://github.com/THREDOpenSource/SYNQueue">SYNQueue.swift</a> - 执行队列类库。</li>
<li><a href="https://github.com/davedelong/DDMathParser">DDMathParser.swift</a> - 相比 NSExpression 和 GCMathPaser，功能更强大的数学表达式解析器。</li>
<li><a href="https://github.com/soffes/RateLimit">RateLimit.swift</a> - 简单、实用定时执行任务工具类库。</li>
<li><a href="https://github.com/shaojiankui/IOS-Categories">iOS-Categories</a> - 收集了许多有助于开发的iOS扩展,各种category分类。</li>
<li><a href="https://github.com/ibireme/YYCategories">YYCategories</a> - 功能丰富的 Category 类型工具库。</li>
<li><a href="https://github.com/ibireme/YYAsyncLayers">YYAsyncLayers</a> -  iOS 异步绘制与显示的工具。</li>
<li><a href="https://github.com/ibireme/YYDispatchQueuePool">YYDispatchQueuePool</a> -  iOS 全局并发队列管理工具。</li>
<li><a href="https://github.com/ibireme/YYKeyboardManager">YYKeyboardManager</a> -   iOS 键盘监听管理工具。</li>
</ul>


<hr />

<h4>数据库</h4>

<ul>
<li><a href="https://github.com/ccgus/fmdb">FMDB</a> - sqlite的工具， <a href="https://github.com/tangqiaoboy/FmdbSample">多线程FMDatabaseQueue实例</a>，<a href="https://github.com/liuchunlao/LVDatabaseDemo">FMDB数据库的使用演示和封装工具类</a>，<a href="http://code.cocoachina.com/view/128312">基于fmdb 的基本操作</a> 通过 fmdb 进行的数据库的 基本操作(增删改查 )查找是使用 UISearchBar 和UISearchDisplayController 进行混合使用。</li>
<li><a href="https://github.com/Gerry1218/GXDatabaseUtils">GXDatabaseUtils</a> - 在FMDB基础上的工具。</li>
<li><a href="https://github.com/realm/realm-cocoa">realm-cocoa</a> - Realm是一个真正为移动设备打造的数据库，同时支持Objective-C和Swfit。Realm宣称其相比Sqlite，在移动设备上有着更好的性能表现,<a href="https://realm.io/cn/">官方中文</a>。</li>
<li><a href="https://github.com/andrelind/Breeze">Breeze</a> - 用Swift写的一个轻量级的CoreData管理工具，并且还支持iCloud 。</li>
<li><a href="https://github.com/Alecrim/AlecrimCoreData">AlecrimCoreData</a> - Swift，更容易地访问 CoreData 对象封装类库。除了 CRUD，还提供指针定位，强大的排序、筛选，异步数据获取，以及独立线程后台存取数据。</li>
<li><a href="https://github.com/JohnEstropia/CoreStore">CoreStore</a> -  Core Data 管理类库。 其中事务管理及查询是其比较大的亮点，整套 API 功能完整。</li>
<li><a href="https://github.com/magicalpanda/MagicalRecord">MagicalRecord</a> - MagicalRecord就像是给Core Data提供了一层外包装，隐藏掉所有不相关的东西。 其中事务管理及查询是其比较大的亮点，整套 API 功能完整。</li>
<li><a href="https://github.com/hyperoslo/Presentation">Presentation</a> - 重量级好项目 Presentation，它可以方便你制作定制的动画式教程、Release Notes、个性化演讲稿等。</li>
<li><a href="https://github.com/terhechte/CoreValue">CoreValue</a> - Swift 2 版 Core Data 封装库。相比另外两个 <a href="https://github.com/arkverse/SwiftRecord">SwiftRecord</a>和 <a href="https://github.com/JohnEstropia/CoreStore">CoreStore</a>更轻量。</li>
<li><a href="https://github.com/sqlcipher/sqlcipher">SQLCipher</a> - SQLCipher使用256-bit AES加密，SQLCipher分为收费版本和免费版本。<a href="https://www.zetetic.net/sqlcipher/ios-tutorial/">官方教程</a>， <a href="http://foggry.com/blog/2014/05/19/jia-mi-ni-de-sqlite/">加密你的SQLite</a> - 各种sqlite数据库加密介绍。 <a href="http://download.csdn.net/detail/wzzvictory_tjsd/7379055">SQLCipherDemo下载</a> 。</li>
<li><a href="https://github.com/stephencelis/SQLite.swift">SQLite.swift</a> - 纯swift实现的类型安全的SQLite3封装，数据存储和JSON解析是永恒的话题。</li>
</ul>


<hr />

<h4>缓存处理</h4>

<ul>
<li><a href="https://github.com/yuantiku/YTKKeyValueStore">YTKKeyValueStore</a> - Key-Value存储工具类，<a href="http://tangqiaoboy.gitcafe.io/blog/2014/10/03/opensouce-a-key-value-storage-tool/">说明</a>。</li>
<li><a href="https://github.com/tumblr/TMCache">TMCache</a> - TMCache 是 Tumblr 开源的一个基于 key/value 的数据缓存类库,可以用于缓存一些临时数据或者需要频繁加载的数据,比如某些下载的数据或者一些临时处理结果。</li>
<li><a href="https://github.com/jl322137/JLKeychain">JLKeychain</a> - 快捷使用keychain存储数据的类，使keychain像NSUserDefaults一样工作。</li>
<li><a href="https://github.com/soffes/sskeychain">sskeychain</a> - SSKeyChains对苹果安全框架API进行了简单封装,支持对存储在钥匙串中密码、账户进行访问,包括读取、删除和设置。</li>
<li><a href="https://github.com/kishikawakatsumi/KeychainAccess">KeychainAccess</a> - 管理Keychain接入的小助手。</li>
<li><a href="https://github.com/ibireme/YYCache">YYCache</a> - 高性能的 iOS 缓存框架。</li>
</ul>


<hr />

<h4>PDF</h4>

<ul>
<li><a href="https://github.com/vfr/Reader">Reader</a> - Reader可提供类似iBooks的文档导航，支持屏幕旋转和所有方向，并通过密码保护加密PDF文件，支持PDF链接和旋转页面。</li>
</ul>


<hr />

<h4>图像浏览及处理</h4>

<ul>
<li><a href="https://github.com/liric28/FLAnimatedImage">FLAnimatedImage</a> - gif播放处理的工具。</li>
<li><a href="https://github.com/yackle/CLImageEditor">CLImageEditor</a> - 超强的图片编辑库，快速帮你实现旋转，防缩，滤镜等等一系列麻烦的事情。</li>
<li><a href="https://github.com/esilverberg/ios-image-filters">ios-image-filters</a> - 图像滤镜，库比较旧了，很容易崩溃。</li>
<li><a href="https://github.com/xissburg/XBImageFilters">XBImageFilters</a> - 图像滤镜。</li>
<li><a href="https://github.com/mwaterfall/MWPhotoBrowser">MWPhotoBrowser</a> - 一个非常不错的照片浏览器，在github的star接近3000个，<a href="http://www.superqq.com/blog/2015/01/22/jie-jue-mwphotobrowserzhong-de-sdwebimagejia-zai-da-tu-dao-zhi-de-nei-cun-jing-gao-wen-ti/">解决MWPhotoBrowser中的SDWebImage加载大图导致的内存警告问题</a>。</li>
<li><a href="https://github.com/objcio/issue-21-core-image-explorer">core-image-explorer</a> -  Core Image 滤镜处理图片&ndash; swift ，<a href="http://objccn.io/issue-21-6/">Core Image 介绍</a>。</li>
<li><a href="https://github.com/rFlex/CoreImageShop">CoreImageShop</a> - CoreImageShop图片滤镜处理&ndash; Mac app that let you create a complete Core Image Filter usable on iOS using SCRecorder。</li>
<li><a href="https://github.com/BradLarson/GPUImage">GPUImage</a> - 处理图片效果。</li>
<li><a href="https://github.com/ruslanskorb/RSKImageCropper">RSKImageCropper</a> - 适用于iOS的图片裁剪器，类似Contacts app，可上下左右移动图片选取最合适的区域。</li>
<li><a href="http://code.cocoachina.com/detail/232156">WZRecyclePhotoStackView</a> - 删除照片交互&ndash;WZRecyclePhotoStackView，就是模拟生活中是删除或保留犹豫不决的情形而产生的。 在上滑，下滑的部分，借鉴了<a href="https://github.com/cwRichardKim/TinderSimpleSwipeCards">TinderSimpleSwipeCards</a>。</li>
<li><a href="https://github.com/schwa/TimingFunctionEditor">TimingFunctionEditor</a> - TimingFunctionEditor用swift编写， 贝塞尔曲线编辑器，编辑后可以预览或拷贝代码片段直接使用。P.S. 该项目采用更简单的依赖管理器 <a href="https://github.com/Carthage/Carthage">Carthage</a> ，而非常用的 CocoaPods。<a href="http://www.cocoachina.com/ios/20141204/10528.html">Carthage介绍中文</a>。</li>
<li><a href="https://github.com/aaronabentheuer/AAFaceDetection">AAFaceDetection</a> - AAFaceDetection&ndash;swift，简单、实用的面部识别封装库。虽然该技术从 iOS 5 发展，不过真正有趣的应用还不多。。</li>
<li><a href="https://github.com/itouch2/PhotoTweaks">PhotoTweaks</a> - 这个库挺赞的，正好是对图像操作的。</li>
<li><a href="https://github.com/contentful-labs/Concorde">Concorde</a> - swift, Concorde, 一个可用于下载和解码渐进式 JPEG 的库, 可用来改善应用的用户体验。</li>
<li><a href="https://github.com/tristanhimmelman/ZoomTransition">ZoomTransition</a> - swift, 通过手势操控图片的放大、缩小、旋转等自由变化效果的组件及示例。</li>
<li><a href="https://github.com/melvitax/AFImageHelper">AFImageHelper</a> - swift,一套针对 UIImage 和 UIImageView 的实用扩展库，功能包含填色和渐变、裁剪、缩放以及具有缓存机制的在线图片获取。</li>
<li><a href="https://github.com/demon1105/PinterestSwift">PinterestSwift</a> - swift,Pinterest 风格图片缩放、切换示例。</li>
<li><a href="https://github.com/KittenYang/KYElegantPhotoGallery">KYElegantPhotoGallery</a> - 一个优雅的图片浏览库。</li>
<li><a href="https://github.com/gsdios/SDPhotoBrowser">SDPhotoBrowser</a> - 仿新浪动感图片浏览器,非常简单易用的图片浏览器，模仿微博图片浏览器动感效果，综合了图片展示和存储等多项功能。</li>
<li><a href="https://github.com/chennyhuang/HZPhotoBrowser">HZPhotoBrowser</a> - 一个类似于新浪微博图片浏览器的框架（支持显示和隐藏动画；支持双击缩放，手势放大缩小；支持图片存储；支持网络加载gif图片，长图滚动浏览；支持横竖屏显示）。</li>
<li><a href="https://github.com/YiZhuoChen/PhotoStackView-Swift">PhotoStackView-Swift</a> - PhotoStackView——照片叠放视图，<a href="http://blog.csdn.net/u013604612/article/details/46336657">使用说明</a>。</li>
<li><a href="https://github.com/FlexMonkey/MarkingMenu">MarkingMenu</a> - 基于手势、类似 Autodesk Maya 风格标记菜单及图片渲染。</li>
<li><a href="https://github.com/dsxNiubility/SXPhotoShow">SXPhotoShow</a> - UICollectionViewFlowLayout流水布局 是当下collectionView中常用且普通的布局方式。本代码也写了三种好看的布局，其中LineLayout和流水布局有很大的相同点就直接继承UICollectionViewFlowLayout，然后StackLayout，CircleLayout这两种都是直接继承自最原始的UICollectionViewLayout 布局方案。</li>
<li><a href="https://github.com/cgwangding/PictureWatermark">PictureWatermark</a> - 主要实现了给图片加文字以及图片水印的功能，已封装成了UIImage的类别，方便使用。</li>
<li><a href="http://code.cocoachina.com/detail/320603/">自定义宽高比的相册框 拍照</a> - 取出照片时 弹出自定义view。在这个自定义view上创建一个需要的相框大小的view层 把取出的图片赋值给UIImageView按缩放添加到这个层上。对uiimageView添加捏合、移动 手势。添加按钮 选取，最后根据位移和缩放比例 裁剪image。</li>
<li><a href="https://github.com/gang544043963/LGPhotoBrowser">LGPhotoBrowser</a> - LGPhotoBrowser:相册选择/浏览器/照相机（仿微信）,包含三个模块：照片浏览器，相册选择器，照相机。</li>
<li><a href="https://github.com/oscarWyz/PhotoBrowser">PhotoBrowser</a> - 一个简单的好用的的图片浏览器。</li>
<li><a href="https://github.com/xujingzhou/BeautyHour">BeautyHour</a> - 完整应用，功能与“美图秀秀”雷同。</li>
<li><a href="https://github.com/DroidsOnRoids/MPParallaxView">MPParallaxView</a> - 是用 Swift 写的类似 Apple TV Parallax 效果的视图。</li>
<li><a href="https://github.com/zhengjinghua/StitchingImage">StitchingImage</a> - 仿微信群组封面拼接控件, 直接拖进项目就可使用，<a href="http://gold.xitu.io/entry/56395f5360b20b143a9178f6">教程</a>。</li>
<li><a href="https://github.com/seedante/SDECollectionViewAlbumTransition">SDECollectionViewAlbumTransition</a> - 用自定义的 push 和 pop 实现了有趣的 iOS 相册翻开动画效果。</li>
<li><a href="https://github.com/xujingzhou/BeautyHour">SKPhotoBrowser.swift</a> - swift中规中矩、实用的图片浏览类库。示例也很完整。</li>
<li><a href="https://github.com/kean/Nuke">Nuke.swift</a> - 完整、强大、实用的图片管理类库。主要功能包括可定制装载，缓存，滤镜及尺寸变换。</li>
<li><a href="https://github.com/AwesomeDennis/DNImagePicker">DNImagePicker</a> - 类似wechat的图片选择。</li>
<li><a href="https://github.com/lioonline/CocoaPicker">CocoaPicker</a> - 仿QQ图片选择器（OC）。</li>
<li><a href="https://github.com/johnil/JFImagePickerController">JFImagePickerController</a> - vvebo作者：多选照片、预览已选照片、针对超大图片优化。</li>
<li><a href="https://github.com/vitoziv/VIPhotoView">VIPhotoView</a> - 图片浏览，用于展示图片的工具类，因为是个 View，所以你可以放在任何地方显示。支持旋转，双击指定位置放大等。</li>
<li><a href="https://github.com/SpringOx/AGImagePickerController">AGImagePickerController</a> - 是一个图片选择器，支持图片多选，支持大图横滑预览，支持放大预览，支持横竖屏，支持所有的iOS设备。</li>
<li><a href="https://github.com/ibireme/YYImage">YYImage</a> - 功能强大的 iOS 图像框架，支持大部分动画图像、静态图像的播放/编码/解码。</li>
<li><a href="https://github.com/KyoheiG3/PagingView">PagingView.swift</a> - 注重细节的自动布局分页视图组件。</li>
</ul>


<hr />

<h4>摄像照相视频音频处理</h4>

<ul>
<li><a href="https://github.com/rFlex/SCRecorder">SCRecorder</a> - SCRecorder 短视频录制。</li>
<li><a href="https://github.com/pingguo-zangqilong/VideoPushDemo">VideoPushDemo</a> - 视频剪辑 <a href="http://www.jianshu.com/p/3006502912aa">视频特效制作1</a> <a href="http://www.jianshu.com/p/6313025349a9">视频特效制作2</a>。</li>
<li><a href="https://github.com/omergul123/LLSimpleCamera">LLSimpleCamera</a> - A simple, customizable camera control for iOS， 摄像头。</li>
<li><a href="https://github.com/syedhali/EZAudio">EZAudio</a> - EZAudio 是一个 iOS 和 OSX 上简单易用的音频框架，根据音量实时显示波形图，基于Core Audio，适合实时低延迟音频处理，非常直观。<a href="http://segmentfault.com/blog/news/1190000000370957">中文介绍</a>,<a href="http://www.syedharisali.com/about">官网</a>。</li>
<li><a href="http://ffmpeg.org/">ffmpeg</a> - ffmpeg官网，<a href="http://www.cocoachina.com/ios/20150514/11827.html">FFmpeg在iOS上完美编译</a>。</li>
<li><a href="http://www.videolan.org/">VCL</a> - VCL官网。</li>
<li><a href="https://github.com/kolyvan/kxmovie">kxmovie</a> - 使用ffmpeg的影片播放器，<a href="http://www.cocoachina.com/bbs/read.php?tid=145575">修改说明</a>， <a href="https://github.com/kinglonghuang">修改代码</a>。</li>
<li><a href="https://github.com/Bilibili/ijkplayer">ijkplayer</a> - B站开源的视频播放器，支持Android和iOS。</li>
<li><a href="https://github.com/tumtumtum/StreamingKit">StreamingKit</a> - StreamingKit流媒体音乐播放器。</li>
<li><a href="https://github.com/muhku/FreeStreamer">FreeStreamer</a> - FreeStreamer流媒体音乐播放器，cpu占用非常小。</li>
<li><a href="https://github.com/douban/DOUAudioStreamer">DOUAudioStreamer</a> - DOUAudioStreamer豆瓣的音乐流媒体播放器。</li>
<li><a href="https://github.com/fmpro/fmpro">fmpro</a> - 电台播放器，支持锁屏歌词，支持基本播放流程，歌词展示，后台锁屏播放和控制以及锁屏后封面+歌词，<a href="https://github.com/jovisayhehe/fmpro_R">fmpro_R</a> 。</li>
<li><a href="https://github.com/mmackh/IPDFCameraViewController">IPDFCameraViewController</a> - 支持相机定焦拍摄、滤镜、闪光、实时边框检测以及透视矫正功能，并有简单易用的API。</li>
<li><a href="https://github.com/rFlex/SCRecorder">SCRecorder</a> - 酷似 Instagram/Vine 的音频/视频摄像记录器，以 Objective-C 为基础的过滤器框架。 你可以做很多如下的操作：记录多个视频录像片段。删除任何你不想要的记录段。可以使用任何视频播放器播放片段。保存的记录可以在序列化的 NSDictionary 中使用。（在 NSUserDefaults 的中操作）添加使用 Core Image 的视频滤波器。可自由选择你需要的 parameters 合并和导出视频。</li>
<li><a href="https://github.com/GabrielAlva/Cool-iOS-Camera">Cool-iOS-Camera</a> - Cool-iOS-Camera。</li>
<li><a href="https://github.com/IFTTT/FastttCamera">FastttCamera</a> - FastttCamera 快速照相。</li>
<li><a href="https://github.com/itsmeichigo/ICGVideoTrimmer">ICGVideoTrimmer</a> - ICGVideoTrimmer提供提供视频剪切的视图（类似系统相册中浏览视频时顶部那个条状视图）。左右两个边界选择器还能够自定义。</li>
<li><a href="http://d.cocoachina.com/code/detail/285717">IOS录音和播放功能demo</a> - 比较完整的ios录音和播放功能的实现。</li>
<li><a href="https://github.com/imaginary-cloud/CameraManager">CameraManager</a> - 相机管理封装类库。看着极好用的样子&mdash;-swift。</li>
<li><a href="https://github.com/msching/MCAudioInputQueue">MCAudioInputQueue</a> - 简易录音类，基于AudioQueue的。</li>
<li><a href="https://github.com/vizllx/DraggableYoutubeFloatingVideo">DraggableYoutubeFloatingVideo</a> - 展示像类似Youtube移动应用的那种浏览视频的效果，当点击某视频时能够从右下方弹出一个界面，并且该界面能够通过手势，再次收缩在右下方并继续播放。这是通过AutoLayout设计实现。</li>
<li><a href="http://www.penguin.cz/~utx/amr">amr</a> - 做即时通讯的音频处理，录音文件是m4a，便于web端的音频播放。</li>
<li><a href="https://github.com/f33chobits/FSVoiceBubble">FSVoiceBubble</a> - 一个轻量级播放录音音频的气泡：1.支持短时间的音频播放（支持网络音频）；2.播放时的声波动画；3.自定义包括声波的颜色，气泡的背景等。</li>
<li><a href="https://github.com/36Kr-Mobile/KRVideoPlayer">KRVideoPlayer</a> - 类似Weico的播放器，支持竖屏模式下全屏播放。</li>
<li><a href="http://code.cocoachina.com/view/128253">自定义视频播放器AVPlayer</a> - 利用系统类AVPlayer实现完全自定义视频播放器，显示播放时间，缓存等功能。代码清晰，注释详细。</li>
<li><a href="https://github.com/xujingzhou/VideoBeautify">VideoBeautify</a> - 功能酷似美拍,秒拍等应用的源码：对视频进行各种美化处理，采用主题形式进行分类，内含各种滤镜，动画特效和音效等。</li>
<li><a href="https://github.com/hanton/HTY360Player">HTY360Player</a> - 是一款提供在 iOS 中使用 360 度无死角拖拽视频进行不同角度播放的视频播放器。</li>
<li><a href="https://github.com/AlexLittlejohn/ALCameraViewController">ALCameraViewController</a> - ALCameraViewController 摄像头视图控制器（含可定制照片选择器，图片简单裁切功能）及演示。</li>
<li><a href="https://github.com/lfb-cd/recordDemo">recordDemo.swift</a> - 一个Swift语言实现直接可以用的录音Demo，<a href="http://www.jianshu.com/p/f0b88355d7cb">实现说明</a>。</li>
<li><a href="https://github.com/swiftcodex/Swift-Radio-Pro">Swift-Radio-Pro</a> - 集成 LastFM 的专业电台应用（基于 Swift 2.0）。</li>
<li><a href="https://github.com/coderyi/Eleven">Eleven</a> - Eleven Player - 一个使用 FFmpeg 实现的简单强大的 iOS 开源播放器。</li>
<li><a href="https://github.com/mobileplayer/mobileplayer-ios">mobileplayer-ios.swift</a> - 很不错的高度可定制播放器项目。</li>
<li><a href="https://github.com/lajos/iFrameExtractor">iFrameExtractor</a> - 开源视频播放器， ffmpeg在iOS的使用-iFrameExtractor源码解析，<a href="http://ios.jobbole.com/82408/">文章</a>。</li>
</ul>


<hr />

<h4>响应式框架</h4>

<ul>
<li><a href="https://github.com/ReactiveCocoa/ReactiveCocoa">ReactiveCocoa</a> - ReactiveCocoa 受函数响应式编程激发。不同于使用可变的变量替换和就地修改，RAC提供Signals来捕获当前值和将来值（ <a href="http://yulingtianxia.com/blog/2014/07/29/reactivecocoa/">使用介绍</a> ），<a href="http://iiiyu.com/2014/12/26/learning-ios-notes-thirty-six/">不错的例子</a>,入门好教程：<a href="http://www.cocoachina.com/ios/20150123/10994.html">ReactiveCocoa入门教程：第一部分 </a>。<a href="http://ios.jobbole.com/82232/">Reactive Cocoa 3.0 在 MVVM 中的应用</a> ,<a href="http://www.jianshu.com/p/87ef6720a096">小码哥：快速让你上手ReactiveCocoa之基础篇</a>。</li>
<li><a href="https://github.com/ReactiveCocoa/ReactiveAnimation">ReactiveAnimation</a> - ReactiveCocoa 推出了一个叫 ReactiveAnimation 的子项目，直接用完全用 Swift 来实现了。</li>
<li><a href="https://github.com/gavinkwoe/BeeFramework">BeeFramework</a> -  与ReactiveCocoa类似，<a href="http://www.lanrenios.com/tutorials/all/2012/1220/641.html">BeeFramework用户指南 v1.0</a>。</li>
<li><a href="https://github.com/iMartinKiss/Objective-Chain">Objective-Chain</a> - Objective-Chain是一个面向对象的响应式框架，作者表示该框架吸收了 ReactiveCocoa 的思想，并且想做得更面向对象一些。</li>
<li><a href="https://github.com/ReactiveX/RxSwift">RxSwift</a> - RxSwift。</li>
</ul>


<hr />

<h4>消息相关</h4>

<h5>消息推送客户端</h5>

<ul>
<li><a href="https://github.com/sagiwei/SGPush/tree/master/SGPushDemo">SGPushDemo</a> - 消息推送客户端</li>
<li><a href="https://github.com/mattt/Orbiter">Orbiter</a> - 消息推送客户端:Push Notification Registration for iOS.</li>
<li><a href="https://github.com/ios44first/PushDemo">PushDemo</a> - 客户端消息接收消息代码，<a href="http://blog.sina.com.cn/s/blog_71715bf80102uy2k.html">IOS开发之 &mdash;- IOS8推送消息注册</a> ， <a href="http://my.oschina.net/u/2340880/blog/413584">分分钟搞定IOS远程消息推送</a>。</li>
</ul>


<h5>消息推送服务端</h5>

<ul>
<li><a href="https://code.google.com/p/javapns/downloads/list">javapns源代码</a> - 消息推送的java服务端代码，注意：DeviceToken中间不能有空格。</li>
<li><a href="https://github.com/stefanhafeneger/PushMeBaby">pushMeBaby</a> - Mac端消息推送端代码，注意：DeviceToken中间要有空格。</li>
</ul>


<h5>通知相关</h5>

<ul>
<li><a href="https://github.com/jessesquires/JSQNotificationObserverKit">JSQNotificationObserverKit</a> - 一款轻量、易用的通知发送及响应框架类库。作者是知名开源项目 JSQMessagesViewController（Objective-C 版即时聊天）的作者 Jesse Squires.</li>
<li><a href="https://github.com/Glow-Inc/GLPubSub">GLPubSub</a> - 一个简短实用的 NSNotificationCenter 的封装。</li>
<li><a href="https://github.com/lizyyy/Homeoff">Homeoff</a> - 用swift写了一个模仿Launcher通知中心快捷方式的应用。支持20个应用，并增加了一个返回到桌面来解放Home键的功能。</li>
<li><a href="https://github.com/jaydee3/JDStatusBarNotification">JDStatusBarNotification</a> - 在状态栏顶部显示通知。可以自定义颜色字体以及动画。支持进度显示以及显示状态指示器。</li>
</ul>


<hr />

<h4>版本新API的Demo</h4>

<ul>
<li><a href="https://github.com/WildDylan/appleSample">appleSample</a> - iOS 苹果官方Demo合集， <a href="https://developer.apple.com/library/ios/navigation/#section=Resource%20Types&amp;topic=Sample%20Code">官方demo</a>.</li>
<li><a href="https://github.com/shu223/iOS7-Sampler">iOS7-Sampler</a> - 整合了iOS7.0的一些十分有用的特性，比如：Dynamic Behaviors、碰撞检测、语音合成、视图切换、图像滤镜、三维地图、Sprite Kit（动画精灵）、Motion Effect（Parallax）、附近蓝牙或者wifi搜索连接、AirDrop、运动物体追踪（iPhone 5S以上，需要M7处理器）等等。对于日常的应用开发十分实用。</li>
<li><a href="https://github.com/shu223/iOS8-Sampler">iOS8-Sampler</a> - 日本的shuさん制作的 iOS8 参考代码集。01.Audio Effects ；02.New Image Filters；03.Custom Filters；04.Metal Basic；05.Metal Uniform Streaming；06.SceneKit；07.HealthKit；08.TouchID；09.Visual Effects；10.WebKit；11.UIAlertController；12.User Notification；13.Pedometer；14.AVKit；15.Histogram；16.Code Generator；17.New Fonts；18.Popover；19.Accordion Fold Transition</li>
<li><a href="https://github.com/shu223/iOS-9-Sampler">iOS-9-Sampler</a> - 通过实例介绍了iOS 9 SDK中重要新特性的使用。</li>
<li><a href="https://github.com/MartinRGB/MTSwift-Learning">MTSwift-Learning</a> - 通过一些简单项目实战演练开始学习 Swift 。</li>
<li><a href="https://github.com/shinobicontrols/iOS8-day-by-day">iOS8-day-by-day</a> - swift。</li>
<li><a href="https://github.com/shinobicontrols/iOS9-day-by-day">iOS9-day-by-day</a> - swfit <a href="http://www.jianshu.com/p/039f8de6ee4d">iOS9 Day-by-Day :: Day 2 :: UI Testing</a>。</li>
<li><a href="http://www.cocoachina.com/ios/20150714/12557.html">iOS 9 分屏多任务</a> - iOS 9 分屏多任务：Slide Over &amp; Split View快速入门（中文版）。</li>
<li><a href="https://github.com/uraimo/uistackview-sample">uistackview-sample.swift</a> - iOS 9 引进了 UIStackViews，提供 auto-layout 特性。如果你开发过 Android 应用，会发现它和 LinearLayouts 概念上很类似，它是增强版。你可以手动创建，也可以使用 IB 自动创建，本文用的是代码实现。。</li>
</ul>


<hr />

<h4>代码安全与密码</h4>

<ul>
<li><a href="https://github.com/Polidea/ios-class-guard">ios-class-guard</a> - 一个用于混淆iOS的类名、方法名以及变量名的开源库&ndash;有人反映编译出来的app运行不了。</li>
<li><a href="https://www.polidea.com/#!heartbeat/blog/Protecting_iOS_Applications">《Protecting iOS Applications》</a>：文章系统地介绍了如何保护iOS程序的代码安全，防止反汇编分析。</li>
<li><a href="https://github.com/facebook/fishhook">fishhook</a> - fishhook是Facebook开源的一个可以hook系统方法的工具。</li>
<li><a href="https://github.com/smilingxinyi/GesturePassword">GesturePassword</a> - 一个iOS手势密码功能实现，iPad/iPhone 都可以用，没有使用图片，里面可以通过view自己添加。keychain做的数据持久化，利用苹果官方KeychainItemWrapper类。操作部分都在controller了。删除直接用一下clear。</li>
<li><a href="https://github.com/Juuman/JMPasswordView">JMPasswordView</a> - 简单实用的手势密码，效果可自行调控。</li>
<li><a href="http://code.cocoachina.com/detail/298556/%E4%BB%BF%E5%AF%86%E7%A0%81%E9%94%81-%E4%B9%9D%E5%AE%AB%E6%A0%BC/">仿密码锁-九宫格</a> - 仿密码锁-九宫格，主要是使用UIButton 手势事件  UIBezierPath画图，解锁失败弹出“密码错误”。</li>
<li><a href="https://github.com/nsdictionary/CoreLock">CoreLock</a> - 本框架是高仿支付宝，并集成了所有功能，并非一个简单的解锁界面展示。个人制作用时1周多，打造解锁终结者框架。</li>
<li><a href="https://github.com/crazypoo/LikeAlipayLockCodeView">LikeAlipayLockCodeView</a> - 高仿支付宝手势解锁（超级版）。</li>
<li><a href="https://github.com/iosdeveloperpanc/PCGestureUnlock">PCGestureUnlock</a> - 目前最全面最高仿支付宝的手势解锁，而且提供方法进行参数修改，能解决项目开发中所有手势解锁的开发。</li>
<li><a href="https://github.com/icoder20150719/ICPayPassWordDemo">ICPayPassWordDemo</a> - CPayPassWordDemo，一个模仿支付宝支付密码输入对话框小demo。</li>
<li><a href="https://github.com/bigsan/RSAESCryptor">RSAESCryptor</a> - 加密 RSA+AES Encryption/Decryption library for iOS. This library uses 2048-bit RSA and 256-bit key with 128-bit block size AES for encryption/decryption。</li>
</ul>


<hr />

<h4>测试及调试</h4>

<ul>
<li><a href="https://github.com/tapwork/HeapInspector-for-iOS">HeapInspector</a> - HeapInspector是一个用于检测应用中的内存泄漏的开源调试工具。</li>
<li><a href="http://try.crashlytics.com/">Crashlytics</a> - Crashlytics 崩溃报告 崩溃日志   <a href="http://www.infoq.com/cn/articles/crashlytics-crash-statistics-tools">使用说明</a> 。</li>
<li><a href="https://github.com/RuiAAPeres/UIViewController-Swizzled">UIViewController-Swizzled</a> - 把你进入的每一个controller的类名打出来,如果看一些特别复杂的项目的时候直接运行demo就可以知道执行次序了。</li>
<li><a href="https://code.google.com/p/snoop-it/">snoop-it</a> - snoop-it比UIViewController-Swizzled好用，代码托管在google上。</li>
<li><a href="https://github.com/zenangst/Versions">Versions</a> - 版本比较小工具。</li>
<li><a href="http://code4app.com/ios/MobileWebPerformanceTest/5465d3e9933bf00c658b4f43">MobileWebPageTest</a> - MobileWebPageTest是用来测试移动网页性能的软件，它可以对页面的加载和渲染过程进行截屏，协助开发者分析出页面性能瓶颈。</li>
<li><a href="https://github.com/Coneboy-k/KKLog">KKLog</a> - 一个日志管理系统。</li>
<li><a href="https://github.com/emaloney/CleanroomLogger">CleanroomLogger</a> - 相当于 CocoaLumberjack 或 Log4j 的 Swift 版本，功能上甚至更强大。另外，源代码中已经内含了完整的 API 文档，使用非常方便。</li>
<li><a href="https://github.com/czechboy0/Buildasaur">Buildasaur</a> - 自动测试框架 Buildasaur。</li>
<li><a href="http://www.devtf.cn/?p=739">使用Quick框架和Nimble来测试ViewControler</a> - Quick是一个用于创建BDD测试的框架。配合Nimbl，可以为你创建更符合预期目标的测试。</li>
<li><a href="https://github.com/KrauseFx/fastlane">fastlane</a> - 一套iOS开发和持续集成的命令行工具fastlane，可以用来快速搭建CI甚至自动提交的开发环境。这套工具中包括了上传ipa文件，自动截取多语言截屏，生成推送证书，管理产品证书等一系列实用工具。</li>
<li><a href="https://github.com/kif-framework/KIF">KIF</a> - 是一个开源的用户界面UI测试框架. 使用 KIF, 并利用 iOS中的辅助功能 API, 你将能够编写模拟用户输入，诸如点击，触摸和文本输入，自动化的UI测试.</li>
<li><a href="https://github.com/Quick/Quick">Quick</a> - 用于Swift中的单元测试（也可用于Objective-C），与Xcode整合在一起。如果你是Objective-C的粉丝，我建议用Specta代替这个，但是对Swift使用者来说，Quick是最佳选择。</li>
<li><a href="https://github.com/railsware/Sleipnir">Sleipnir</a> - Swift的测试框架。</li>
<li><a href="https://github.com/kiwi-bdd/Kiwi/wiki">kiwi-bdd</a> - TDD或BDD，objective-c语言的测试框架，最流行的BDD测试框架了，Kiwi最受欢迎（根据github上的star数来推断，行为描述和期望写起来也比较易懂，至少我是这么认为的） <a href="http://www.jianshu.com/p/7e3f197504c1#">iOS开发中的测试框架</a>。</li>
<li><a href="https://github.com/specta/specta">specta</a> -  TDD或BDD，objective-c语言的测试框架，用的人多。</li>
<li><a href="https://github.com/pivotal/cedar">cedar</a> -  TDD或BDD，objective-c语言的测试框架，用的人少。</li>
<li><a href="https://github.com/daisuke0131/ViewMonitor">ViewMonitor</a> - 能够帮助 iOS 开发者们精确的测量视图, 可直接在调试应用中查看具体某个视图的坐标, 宽高等参数。</li>
<li><a href="https://github.com/adad184/MMPlaceHolder">MMPlaceHolder</a> - 一行代码显示UIView的位置及相关参数。</li>
<li><a href="https://github.com/adad184/XXPlaceHolder">XXPlaceHolder.swift</a> - MMPlaceHolder的swift版本。

<ul>
<li><a href="https://github.com/kconner/KMCGeigerCounter">KMCGeigerCounter</a> - KMCGeigerCounter通过复杂和简单的视图演示了类似盖革计数器的帧速计算功能。掉帧通常是可见的，但是很难区分55fps和60fps之间的不同，而KMCGeigerCounter可以让你观测到掉落5帧的情况。</li>
</ul>
</li>
</ul>


<hr />

<h4>AppleWatch</h4>

<ul>
<li><a href="https://github.com/eleks/rnd-apple-watch-tesla">Tesla汽车AppleWatch app demo演示</a> - 通过AppleWatch控制特斯拉汽车，同时可以看到汽车的相关信息，比如剩余电量、可续行里程等，以及解锁/上锁车门、调节司机和乘客的四区域空调温度、开启车辆大灯、定位汽车等。<a href="http://www.cocoachina.com/ios/20150205/11116.html">源码推荐说明</a>。</li>
<li><a href="https://github.com/kostiakoval/WatchKit-Apps">WatchKit-Apps</a> - WatchKit 开源小项目示例集锦。是不可多得地学习 WatchKit 的示例式教程（1.如何创建一个简单的交互式计数器；2.如何从手表上控制iOS app；3.如何在WatchKit app和iOS app之间共享数据；4.如何创建一个拥有不同背景色的数字时钟；5.展示不同的UI层；6.如何创建支持滑动手势的应用程序。）。</li>
<li><a href="https://github.com/KittenYang/KYVoiceCurve">KYVoiceCurve</a> - 类似Apple Watch中语音的声音曲线动画。</li>
<li><a href="https://github.com/Instagram/IGInterfaceDataTable">IGInterfaceDataTable</a> - IGInterfaceDataTable是WKInterfaceTable对象的一个类别，可以让开发者更简单地配置多维数据。该项目使用类似UITableViewDataSource的数据源模式配置Apple Watch表格，而不是将数据结构扁平化成为数组。</li>
<li><a href="http://www.swiftkiller.com/?p=613">Apple Watch开发教程资料汇总</a> - Apple Watch开发教程资料汇总。</li>
<li><a href="https://github.com/contentful-labs/Stargate">Stargate</a> - 通过 iPhone 桥接实现 Mac 与 Watch 的即时通讯。Stargate 通过封装两个优秀的基础类库 MMWormhole 和 PeerKit 实现高效的通讯应用。&ndash;swift</li>
<li><a href="https://github.com/sandofsky/soon">soon</a> - 一款倒计时 WatchKit 示例应用。作者从架构的角度，思考如何设计一款完整、通讯高效且性能又好的 WatchKit 扩展应用。该示例学习性非常强。&ndash;swift</li>
<li><a href="https://github.com/shu223/watchOS-2-Sampler">watchOS-2-Sampler</a> - 基于 watchOS 2 若干新特性，写了相应的示例代码供大家学习、参考。</li>
<li><a href="https://github.com/KhaosT/HMWatch">HMWatch</a> - HMWatch是个有待完善的watchOS 2.0 HomeKit 应用示例。</li>
<li><a href="https://github.com/manavgabhawala/CocoaMultipeer">CocoaMultipeer</a> - CocoaMultipeer这个开源框架支持OS X, iOS和watchOS设备间的点对点通信，解决watchOS和Mac之间通信的方案还是很有用的。</li>
<li><a href="https://github.com/GetHighstreet/HighstreetWatchApp">HighstreetWatchApp</a> - 是电商平台Highstreet针对App Watch的一款应用，该demo中加载的是虚拟数据。</li>
<li><a href="https://github.com/NilStack/NKWatchChart">NKWatchChart</a> - NKWatchChart是一个基于PNChart专门为Apple Watch 开发的图表库,目前支持 line, bar, pie, circle 和 radar 等 图表形式。</li>
<li><a href="https://github.com/diwu/BeijingAirWatch">BeijingAirWatch</a> - 国人的开源项目代码 ！WatchOS 2.0 Complication of Real-time Air Quality for Major Chinese Cities 苹果表盘实时刷新北上广沈蓉空气质量。</li>
</ul>


<hr />

<h4>VPN</h4>

<ul>
<li><a href="https://github.com/lexrus/vpnon/">vpnon</a> - swift的VPN On 的源码和本地化内容都是开放的: <a href="https://crowdin.com/project/vpnon">官方网站</a>。</li>
<li><a href="https://github.com/CatchChat/Hydro.network">Hydro.network</a> - <a href="http://zhowkev.in/2015/03/09/hydro-network-de-kai-fa-lu-cheng/">Hydro.network 的开发旅程</a>, <a href="https://gitcafe.com/Catch/Hydro.network">gitcafe</a>。</li>
</ul>


<hr />

<h4>完整项目</h4>

<ul>
<li><a href="https://github.com/singro/v2ex">v2ex</a> - v2ex 的客户端，新闻、论坛。</li>
<li><a href="https://github.com/iAugux/iBBS-Swift">iBBS-Swift</a> - “新手开源一个用Swift（2.0）写的论坛客户端”。<a href="http://obbs.sinaapp.com/">BBS 服务端</a>。</li>
<li><a href="https://github.com/wikimedia/apps-ios-wikipedia">apps-ios-wikipedia</a> - apps-ios-wikipedia 客户端。</li>
<li><a href="https://github.com/uber/jetstream-ios">jetstream-ios</a> - 一款 Uber 的 MVC 框架。它同时提供了多用户实时通讯支持，一旦启动 JetStream 后端服务，通过 WebSocket 协议可以分分钟建立多用户实时通讯应用。</li>
<li><a href="https://github.com/jpsim/DeckRocket">DeckRocket</a> - 在相同 WiFi 网络环境内，通过iPhone 控制并播放 Mac 中的 PDF 文档。</li>
<li><a href="https://github.com/JayFang1993/ScanBook">ScanBook</a> - 扫扫图书:可以扫描条形码查询图书，也可以关键字搜索，遇到合乎你口味的书，还可以看看别人的读书笔记，不同角度去体会。</li>
<li><a href="https://github.com/MengTo/DesignerNewsApp">DesignerNewsApp</a> - Swift 开发的 DesignerNews 客户端，看着美美的！</li>
<li><a href="https://github.com/KittenYang/KYWeibo">KYWeibo</a> - 调用新浪API自己写的第三方微博客户端。</li>
<li><a href="https://github.com/li6185377/DouQu_IOS">DouQu_IOS</a> - 逗趣IOS手机端（一款笑话软件）,拥有完整的功能的手机应用app 。</li>
<li><a href="https://github.com/itjhDev/itjh">IT江湖iOS客户端</a> - IT江湖iOS客户端。</li>
<li><a href="https://github.com/artsy/eidolon">Eidolon</a> - 艺术品拍卖的投标亭平台，用swift与反应式编程框架 ReactiveCocoa。</li>
<li><a href="https://github.com/nonstriater/CrazyPuzzle">CrazyPuzzle</a> - 模仿“看图猜成语”App，功能齐全，配有音效，效果很不错。游戏使用cocoa框架完成，没有使用cocos2d的框架。</li>
<li><a href="https://github.com/Tim9Liu9/WhoCall">WhoCall</a> - 谁CALL我，iOS来电信息语音提醒，无需越狱。（需要iOS 7.0及以上版本。)骚扰电话预警、来电归属地提醒、联系人姓名播报，这些有中国特色人性化的电话功能，iOS上也应该有。电话提醒、私有API。</li>
<li><a href="http://www.devtf.cn/?p=562">仿iOS猎豹垃圾清理(实现原理+源码)</a> -  仿iOS猎豹垃圾清理(实现原理+源码),用到私有API。</li>
<li><a href="https://github.com/sam408130/DSLolita">DSLolita</a> - 模仿新浪微博做的一款app，有发送博文，评论，点赞，私聊功能。</li>
<li><a href="https://github.com/gsdios/GSD_ZHIFUBAO">GSD_ZHIFUBAO</a> - 支付宝高仿版。</li>
<li><a href="https://github.com/thoughtbot/Tropos">Tropos</a> - Tropos, 由 thoughtbot 推出的一款用 Objective-C 写的开源天气类应用, 截至今天, thoughtbot 已在 GitHub 上贡献了 174 个开源项目, 实在令人敬佩。</li>
<li><a href="https://github.com/liu044100/SmileWeather">SmileWeather</a> -开源天气类应用,天气图标很完整。</li>
<li><a href="https://github.com/leichunfeng/MVVMReactiveCocoa">MVVMReactiveCocoa</a> - GitBucket 2.0 通过审核啦，她是我在公司实践了一年多 MVVM 和 RAC 的基础上，利用业余时间开发的第三方 GitHub 客户端，旨在能够对想实践 MVVM 和 RAC 的 iOS 开发者有所帮助。<a href="https://itunes.apple.com/cn/app/id961330940?mt=8">AppStore地址</a>，欢迎下载使用GitBucket和收藏MVVMReactiveCocoa。</li>
<li><a href="https://github.com/dasdom/Tomate">Tomate</a> - 这个圆盘式计时器让你更专注于工作或学习。P.S. App Store 上架收费应用（0.99 欧）。</li>
<li><a href="https://github.com/joeshang/StoveFireiOSMenu">StoveFireiOSMenu</a> - 炉火餐饮系统iPad点餐端。</li>
<li><a href="https://github.com/belm/BaiduFM-Swift">BaiduFM-Swift</a> - 百度FM, swift语言实现，基于最新xcode6.3+swift1.2,初步只是为了实现功能，代码比较粗燥，后面有时间会整理，支持Apple Watch。</li>
<li><a href="https://github.com/ZhongTaoTian/WNXHuntForCity">WNXHuntForCity</a> - iOS高仿城觅项目（开发思路和代码）。</li>
<li><a href="https://github.com/zyprosoft/ZYChat">ZYChat</a> - 关于聊天界面的可消息类型扩展，响应绑定设计。</li>
<li><a href="https://github.com/minxiaoming/NiceAppDemo">NiceAppDemo</a> - 仿最美应用-每日最美的钢琴律动效果。</li>
<li><a href="https://github.com/lookingstars/meituan">meituan</a> - 美团5.7iOS版（高仿），功能包括，团购首页，高德地图搜索附近美食并显示在地图上，上门服务，商家，友盟分享。</li>
<li><a href="https://github.com/zangqilong198812/MeituanDemo">MeituanDemo</a> - 造美团应用界面构建的 iOS 应用, 第一个是 @叶孤城___ 的 MeituanDemo。</li>
<li><a href="https://github.com/tubie/JFMeiTuan">JFMeiTuan</a> - 造美团应用界面构建的 iOS 应用, 第二个是 @tubiebutu 的 JFMeiTuan。</li>
<li><a href="https://github.com/lookingstars/chuanke">chuanke</a> - 高仿百度传课iOS版。</li>
<li><a href="https://github.com/aiqiuqiu/Tuan">Tuan</a> - 模仿MJ老师iPad版美团（swift版），偶有bug 见谅。</li>
<li><a href="https://github.com/dsxNiubility/SXNews">SXNews</a> - 模仿网易新闻做的新闻软件，完成了主导航页，新闻详情页，图片浏览页，评论页。效果不错，比网上流传的各种和网易新闻UI架构有关的代码都要完整，都要好。</li>
<li><a href="https://github.com/coderyi/Monkey">Monkey</a> - Monkey for GitHub是一个GitHub开发者和仓库排名的开源App。这次主要增加了登录GitHub的功能，随手follow和star，并且增加发现模块，包括GitHub的trending，动态，showcases等。</li>
<li><a href="https://github.com/callmewhy/Uther">Uther</a> -  跟蠢萌的外星人聊天，还能帮你记事”。<a href="https://itunes.apple.com/cn/app/uther/id1024104920">itunes下载</a> 。</li>
<li><a href="https://github.com/zixun/CocoaChinaPlus">CocoaChinaPlus</a> - CocoaChina+是一款开源的第三方CocoaChina移动端。整个App都用Swift2.0编写(除部分第三方OC代码外，比如JPush和友盟)。</li>
<li><a href="http://code.cocoachina.com/view/128246">高仿斗鱼TV</a> - 高仿斗鱼TV，点击头部滚动视图可以播放视频。</li>
<li><a href="https://github.com/LonelyTown/LXZEALER">LXZEALER</a> - 模仿着做了zealer客户端,App里几乎所有请求都是Post,所以内容都是固定的URL加载的,登录功能只做了微博的第三方登录。</li>
<li><a href="https://github.com/pengleelove/ShiXiSeng_ios">ShiXiSeng_ios</a> - 完整app的UI框架。</li>
<li><a href="https://github.com/Coding/Coding-iPad">Coding-iPad</a> - Coding-iPad 是@Coding的官方 iPad 客户端, 又是一个完整的开源应用。</li>
<li><a href="https://github.com/likumb/SimpleMemo">SimpleMemo</a> - 易便签已经转到Swift2.0，全面适配iOS9和Watch OS2，并支持iPhone6s和iPhone6sPlus的3D Touch功能，包括图标快捷键和内容预览。</li>
<li><a href="https://github.com/xxycode/XXYAudioEngine">XXYAudioEngine.swift</a> - 基于NSURLSession 和 AVAudoPlayer的在线音乐的工具，可以把音乐保存在本地，也可以支持后台播放，后台下载，最低支持iOS7，swift版本1.2。</li>
</ul>


<hr />

<h4>好的文章</h4>

<ul>
<li><a href="http://www.jianshu.com/p/38cd35968864">自定义转场动画</a> - 3 种方法～ 关于自定义转场动画。</li>
<li><a href="https://github.com/icepy/_posts/blob/master/iOS%E6%8F%90%E9%AB%98%E6%95%88%E7%8E%87%E7%9A%84%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7.md">iOS提高效率的方法和工具</a> - iOS提高效率的方法和工具。</li>
<li><a href="http://jsonapi.org.cn/">用 JSON 构建 API 的标准指南</a> - 用 JSON 构建 API 的标准指南。</li>
<li><a href="http://blog.callmewhy.com/2015/09/21/rxswift-getting-started-0/">RxSwift入坑手册</a> - RxSwift入坑手册。</li>
</ul>


<hr />

<h4>Xcode插件</h4>

<ul>
<li><a href="http://www.cocoachina.com/special/xcode/">iOS开发进阶，从Xcode开始</a> - 学习使用Xcode构建出色的应用程序！</li>
<li><p>在Xcode启动的时候，Xcode将会寻找位于~/Library/Application Support/Developer/Shared/Xcode/Plug-ins文件夹中的后缀名为.xcplugin的bundle作为插件进行加载（运行其中的可执行文件）。<a href="http://studentdeng.github.io/blog/2014/02/21/xcode-plugin-fun/">Xcode5 Plugins 开发简介</a>  <a href="http://joeyio.com/ios/2013/07/25/write_xcode4_plugin_of_your_own/">写个自己的Xcode4插件</a></p></li>
<li><p><a href="http://www.onevcat.com/2013/02/xcode-plugin/">Xcode 4 插件制作入门</a> - Xcode 4 插件制作入门:Xcode所使用的所有库都包含在Xcode.app/Contents/的Frameworks，SharedFrameworks和OtherFrameworks三个文件夹下。其中和Xcode关系最为直接以及最为重要的是Frameworks中的IDEKit和IDEFoundation，以及SharedFrameworks中的DVTKit和DVTFoundation四个。</p></li>
<li><p><a href="https://github.com/rickytan/RTImageAssets">RTImageAssets</a> - 一个 Xcode 插件，用来生成 @3x 的图片资源对应的 @2x 和 @1x 版本。<a href="https://itunes.apple.com/app/asset-catalog-creator-free/id866571115?mt=12">Asset Catalog Creator</a> 功能强大，能自动生成全部尺寸：包括App Icons、Image Sets、Launch Screens Generator。</p></li>
<li><p><a href="https://github.com/onevcat/VVDocumenter-Xcode">VVDocumenter-Xcode</a> - 一个Xcode插件，build后，随手打开一个你之前的项目，然后在任意一个方法上面连按三下"/&ldquo;键盘，就ok了。</p></li>
<li><p><a href="https://github.com/shjborage/Reveal-Plugin-for-XCode">Reveal-Plugin-for-XCode</a> - 一个Reveal插件，可以使工程不作任何修改的情况下使用Reveal，该插件已在Alcatraz上架。<a href="http://security.ios-wiki.com/issue-3-4/">Reveal：分析iOS UI的利器</a> 。</p></li>
<li><p><a href="https://github.com/google/j2objc">java2Objective-c</a> - Google公司出得java转Obje-C转换工具，转换逻辑，不转换UI。</p></li>
<li><p><a href="https://github.com/kzaher/RegX">RegX</a> - 专治代码强迫症的 Xcode 插件，使用 Swift 和 Objective-C 编写。其用竖向对齐特定源代码的元素，使得代码更易读和易理解。<a href="http://www.cocoachina.com/ios/20141224/10743.html">说明</a> ； 菜单：xcode——》Edit-》Regx 。</p></li>
<li><p><a href="https://github.com/ksuther/KSImageNamed-Xcode">KSImageNamed</a> - 自动完成，特别是如果你正在写Objective-C，如果Xcode能自动完成文件名难道不会很伟大吗？比如图像文件的名称。</p></li>
<li><p><a href="https://github.com/FuzzyAutocomplete/FuzzyAutocompletePlugin">FuzzyAutocomplete</a> - Xcode的实现自动完成还不完美，此插件能给出你所期望或想要的建议，设置：xcode-》Editor-》FuzzyAutocomplete-》plugin settings。</p></li>
<li><p><a href="https://github.com/johnno1962/GitDiff">GitDiff</a> - Xcode的代码编辑器的一个微妙的补强，加上了足够的可见信息以了解上次git提交以来发生了什么变化，设置：xcode-》Edit-》GitDiff。</p></li>
<li><p><a href="https://github.com/trawor/XToDo">XToDo</a> - 这个插件不仅凸显TODO，FIXME，???，以及！！！注释，也在便利列表呈现他们。 菜单：xcode-》view-》snippets;   调出列表显示: xcode-》view-》ToDo List ： ctrl + T 。</p></li>
<li><p><a href="https://github.com/limejelly/Backlight-for-XCode">Backlight</a> - 突出显示当前正在编辑的行。菜单：xcode-》view-》Backlight 。</p></li>
<li><p><a href="https://github.com/kattrali/cocoapods-xcode-plugin">CocoaPods</a> - 该CocoaPods的插件增加了一个CocoaPods菜单到Xcode的产品菜单。如果你不喜欢命令行，那么你一定会喜欢这个插件。 <a href="http://tangqiaoboy.gitcafe.io/blog/2014/05/25/use-cocoapod-to-manage-ios-lib-dependency/">用CocoaPods做iOS程序的依赖管理 </a>。</p></li>
<li><p><a href="https://github.com/markohlebar/Peckham">Peckham</a> - 添加import语句比较麻烦，此插件 按Command-Control-P，给出的选项列表中选择要的头文件。先要安装<a href="http://alcatraz.io/">Alcatraz</a> ,在终端输入： <strong>curl -fsSL <a href="https://raw.github.com/supermarin/Alcatraz/master/Scripts/install.sh">https://raw.github.com/supermarin/Alcatraz/master/Scripts/install.sh</a> | sh</strong> ； 重启xcode-》window-》Package Manager：搜索 <strong>Peckham</strong> 安装，打开Peckham.xcodeproj，编译 Peckham target，重启Xcode 。</p></li>
<li><p><a href="https://github.com/lucholaf/Auto-Importer-for-Xcode">Auto-Importer</a> - Auto-Importer是一个自动导入类对应的头文件的Xcode插件。</p></li>
<li><p><a href="http://alcatraz.io/">Alcatraz</a> -使用Alcatraz来管理Xcode插件 <a href="http://tangqiaoboy.gitcafe.io/blog/2014/03/05/use-alcatraz-to-manage-xcode-plugins/">使用说明</a> 。</p></li>
<li><p><a href="https://github.com/kimsungwhee/KSHObjcUML">KSHObjcUML</a> -KSHObjcUML 是一个 Objective-C 类引用关系图的 Xcode 插件。</p></li>
<li><p><a href="https://github.com/omz/ColorSense-for-Xcode">ColorSense-for-Xcode</a> - 颜色插件，安装之后，就不用根据RGB选择颜色，直接从取色板中取颜色，会自动补齐RGB代码。。</p></li>
<li><p><a href="http://www.imooc.com/wenda/detail/237132">10款提高iOS开发效率的XCode插件</a> - 10款提高iOS开发效率的XCode插件：1. XcodeColors；5. ACCodeSnippetRepository；10. Dash for Xcode。</p></li>
<li><p><a href="https://github.com/MakeZL/ZLGotoSandboxPlugin">ZLGotoSandboxPlugin</a> - 支持Xcode快捷键了跳转当前应用沙盒了！快捷键是 Shift+Common+w。</p></li>
<li><p><a href="https://github.com/burczyk/XcodeSwiftSnippets">XcodeSwiftSnippets</a> - XcodeSwiftSnippets, 提供了很多可在 Xcode 上使用的 Swift 代码片段, 通过自动补全的方式极大的提高了开发效率， <a href="https://github.com/Xcode-Snippets/Objective-C">另外还有 Objective-C 版的</a>。</p></li>
<li><p><a href="https://vimeo.com/128713880">CoPilot</a> - 通过此插件， Xcode 可以协同编程了（采用 WebSocket 通讯）。如此强大的“黑工具”，不爱它能行吗。</p></li>
<li><a href="https://github.com/EnjoySR/ESJsonFormat-Xcode">ESJsonFormat-Xcode</a> - 将Json格式化输出为模型的属性。</li>
<li><a href="https://github.com/stefanceriu/SCXcodeMiniMap">SCXcodeMiniMap</a> - Xcode迷你小地图-SCXcodeMiniMap。</li>
<li><a href="http://code.cocoachina.com/detail/316095/xTransCodelation/">xTransCodelation</a> - XCODE中英文翻译插件，提供API查询模式和网页模式，都是利用的百度翻译。另外集成了一个可以一键关闭其他所有APP的实用功能，方便开发者！</li>
<li><a href="https://github.com/jwaitzel/SuggestedColors/">SuggestedColors</a> - Xcode 插件SuggestedColors，用于 IB颜色设置 辅助插件，非常好用。</li>
</ul>


<hr />

<h4>美工资源</h4>

<ul>
<li><a href="https://github.com/markohlebar/Peckham">TWG_Retina_Icons</a> - 一套支持 Retina 高清屏的 iPhone 免费图标集。</li>
<li><a href="https://github.com/cparnot/ASCIImage">ASCIImage</a> - 使用 NSString 创建 image，<a href="http://cocoamine.net/blog/2015/03/20/replacing-photoshop-with-nsstring/">说明</a>。</li>
<li><a href="https://github.com/RayPS/my-sketch-colors">my-sketch-colors</a> - 配色。</li>
<li><a href="http://www.imooc.com/wenda/detail/250367">Font Awesome</a> - Font Awesome：一套绝佳的图标字体库和CSS框架，详细的安装方法请参考<a href="http://fortawesome.github.io/Font-Awesome/icons/">官方网站</a><a href="http://fontawesome.dashgame.com/">中文网站</a>,<a href="https://github.com/FortAwesome/Font-Awesome">GitHub地址</a> 。</li>
<li><a href="https://github.com/yannickl/DynamicColor">DynamicColor</a> - 强大的颜色操作扩展类。通过该类，你可以通过扩展方法基于某个颜色得到不同深浅、饱和度、灰度、色相，以及反转后的新颜色。是不可多得的好类库。</li>
<li><a href="https://github.com/ViccAlexander/Chameleon">Chameleon</a> - Chameleon是一个iOS的色彩框架。它运用现代化flat color将UIColor扩展地非常美观。我们还可以通过它运用自定义颜色创建调色板。它还有很多功用，请浏览readme。</li>
<li><a href="https://github.com/ArtSabintsev/FontBlaster">FontBlaster</a> - 载入定制字体时更简单。</li>
</ul>


<h4>其他资源</h4>

<ul>
<li><a href="http://githuber.info/#/index">githuber</a> - 最好用的GitHub人才搜索工具。</li>
<li><a href="https://www.codatlas.com">codatlas</a> - 源代码搜索利器。</li>
<li><a href="https://searchcode.com/">searchcode</a> - 源代码搜索利器：来自悉尼的代码搜索引擎汇聚了 Github, Bitbucket, Sourceforge&hellip;等多家开源站点超20万个项目、180亿行源代码，能以特殊字符、语言、仓库和源方式从90多种语言找到函数、API的真实代码。</li>
<li><a href="https://github.com/kitematic/kitematic">kitematic</a> - Mac 上使用 Docker 最简单的方案。</li>
</ul>


<hr />

<h4>开发资源</h4>

<h5>开发资料</h5>

<ul>
<li><a href="http://www.douban.com/note/276160185/?type=like">豆瓣iOS开源库列表</a> - 豆瓣iOS开源库列表，很多开源项目。</li>
<li><a href="https://github.com/AttackOnDobby/iOS-Core-Animation-Advanced-Techniques">iOS-Core-Animation-Advanced-Techniques</a> - 中文版iOS 高级动画技术。</li>
<li><a href="http://www.jianshu.com/p/50b63a221f09">iOS开发的一些奇巧淫技1</a> - TableView不显示没内容的Cell怎么办; 键盘事件：<a href="https://github.com/hackiftekhar/IQKeyboardManager">IQKeyboardManager</a>;  app不流畅:<a href="https://github.com/kconner/KMCGeigerCounter">KMCGeigerCounter</a>;  CoreData用起来好烦:<a href="https://github.com/magicalpanda/MagicalRecord">MagicalRecord</a>;  CollectionView实现悬停的header:<a href="https://github.com/jamztang/CSStickyHeaderFlowLayout">CSStickyHeaderFlowLayout</a>。</li>
<li><a href="http://www.jianshu.com/p/08f194e9904c">iOS开发的一些奇巧淫技2</a> -  用一个pan手势来代替UISwipegesture的各个方向、拉伸图片、播放GIF、上拉刷新、把tableview里cell的小对勾的颜色改变、navigationbar弄成透明的而不是带模糊的效果、改变uitextfield placeholder的颜色和位置。</li>
<li><a href="http://code4app.com/article/cocoapods-install-usage">cocoapods安装指南</a> - cocoapods安装指南。</li>
<li><a href="https://github.com/johnno1962/Remote">RemoteControl</a> - Control your iPhone from inside Xcode for end-to-end testing 。</li>
<li><a href="http://objccn.io/issue-13-1/">MVVM 介绍</a> - 替换MVC的开发模式。</li>
<li><p><a href="http://apistore.baidu.com/astore/index">第三方接口</a> - 基本所有第三方接口都在这，再也不用那么麻烦去找了。</p></li>
<li><p><a href="http://yyny.me/ios/%E6%8F%90%E9%AB%98iOS%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7/">提高iOS开发效率的方法和工具</a> - 提高iOS开发效率的方法和工具。</p></li>
<li><a href="https://github.com/oa414/objc-zen-book-cn">禅与 Objective-C 编程艺术</a> - 禅与 Objective-C 编程艺术 （Zen and the Art of the Objective-C Craftsmanship 中文翻译）。</li>
<li><a href="http://www.imooc.com/article/1216">Objective-C编码规范：26个方面解决iOS开发问题</a> - 【Objective-C编码规范：26个方面解决iOS开发问题：“我们制定Objective-C编码规范的原因是我们能够在我们的书，教程和初学者工具包的代码保持优雅和一致。”今天分享的规范来自raywenderlich.com团队成员共同完成的，希望对学习OC的朋友们有所指导和帮助。</li>
</ul>


<h6>swift</h6>

<ul>
<li><a href="https://github.com/numbbbbb/the-swift-programming-language-in-chinese">Swift中文指南</a> - 中文版Apple官方Swift教程《The Swift Programming Language》，<a href="http://numbbbbb.gitbooks.io/-the-swift-programming-language-/content/">老码版本</a>  <a href="http://numbbbbb.gitbooks.io/-the-swift-programming-language-/content/chapter1/03_revision_history.html">历史版本更新说明</a>。</li>
<li><a href="http://wiki.jikexueyuan.com/project/swift/">The Swift Programming Language 中文版</a> - The Swift Programming Language 中文版。</li>
<li><a href="http://www.swifttoolbox.io/">swifttoolbox</a> -  swifttoolbox swift开发的开源库汇总。</li>
<li><a href="https://github.com/ipader/SwiftGuide">SwiftGuide</a> -  这份指南汇集了Swift语言主流学习资源，并以开发者的视角整理编排&ndash; 非常不错，值得推荐。</li>
<li><a href="https://github.com/ipader/SwiftGuide/blob/master/Featured.md">Swift开源项目精选</a> - Swift开源项目精选&ndash;推荐，每周都有更新。</li>
<li><a href="https://swift.zeef.com/robin.eggenkamp">Awesome Swift</a> - 一个收集了很多 Swift 开发资源的网站。</li>
<li><a href="https://github.com/x140yu/Developing_iOS_8_Apps_With_Swift">Developing_iOS_8_Apps_With_Swift</a> - Developing iOS 8 Apps with Swift 字幕简体中文翻译项目（斯坦福白胡子老头swift教学视频）。</li>
<li><a href="https://github.com/johnlui/Swift-On-iOS">Swift-On-iOS</a> - JohnLui 的 Swift On iOS 代码仓库。</li>
<li><a href="https://github.com/PerfectlySoft/Perfect">Perfect</a> - Perfect 致力于 Swift 服务端应用，从打造专业应用服务器开始。。</li>
</ul>


<h5>他人开源总结</h5>

<ul>
<li><a href="http://www.code4app.com/">code4app</a> - 最多国人用的代码库。</li>
<li><a href="http://code.cocoachina.com/">cocoachina</a> - 国内最热门的iOS社区的代码库。</li>
<li><a href="https://github.com/vsouza/awesome-ios">awesome-ios</a> - 一个老外整理的，<a href="http://app.memect.com/doc/ios.html">中文版</a>。</li>
<li><a href="https://github.com/cjwirth/awesome-ios-ui">awesome-ios-ui</a> - 收集了不少 iOS UI/UX 库, 包含了很多酷炫的动画效果。</li>
<li><a href="http://ios-cosmos.com/">ios-cosmos</a> - The iOS Cosmos：收录了IOS绝大部分的开源框架和工具。</li>
<li><a href="https://haskell.zeef.com/konstantin.skipor#block_28362_basics">Awesome Haskell资料大全</a> -    Awesome Haskell 资料大全：框架，库和软件。</li>
<li><a href="http://ios-cosmos.com">Cosmos</a> - The iOS Cosmos：收录了IOS绝大部分的开源框架和工具。</li>
<li><a href="http://cocoacontrols.com">cocoacontrols</a> -  收集了很多UI控件效果代码，缺点是需要翻墙，而且代码分类不够好。</li>
<li><a href="https://github.com/lexrus">lexrus</a> -  lexrus国内出名的iOS开源coder，非常酷的label动画、textfield动画。</li>
<li><p><a href="https://github.com/dkhamsing/open-source-ios-apps">open-source-ios-apps</a> - iOS App集合，分：swift与Objective-C&ndash;国外人整理。</p></li>
<li><p><a href="http://www.csdn.net/article/2015-03-04/2824108-ios-developers-sites">适合iOS开发者的15大网站推荐</a> -  适合 iOS 开发者的 15 大网站推荐 &mdash; 英文网站。</p></li>
<li><p><a href="https://github.com/Aufree/trip-to-iOS/blob/master/Top-100.md">Objective-C GitHub 排名前 100 项目简介</a> -  主要对当前 GitHub 排名前 100 的项目做一个简单的简介, 方便初学者快速了解到当前 Objective-C 在 GitHub 的情况。</p></li>
<li><p><a href="http://github.ibireme.com/github/list/ios/">Github-iOS备忘</a> -整理了比较常用的iOS第三方组件，以及github上的统计。</p></li>
<li><a href="https://github.com/JanzTam/MyGithubMark">MyGithubMark</a> - Github上的iOS资料-个人记录（持续更新）。</li>
</ul>


<h5>中文开发博客列表</h5>

<ul>
<li><a href="https://github.com/tangqiaoboy/iOSBlogCN">唐巧整理</a> - 猿题库唐巧整理。</li>
</ul>


<table>
<thead>
<tr>
<th>博客地址 </th>
<th> RSS地址</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://southpeak.github.io/">南峰子的技术博客</a> </td>
<td> 南峰子的技术博客。</td>
</tr>
<tr>
<td><a href="http://blog.devtang.com">唐巧的技术博客</a> </td>
<td> <a href="http://blog.devtang.com/atom.xml">http://blog.devtang.com/atom.xml</a></td>
</tr>
<tr>
<td><a href="http://onevcat.com">OneV&rsquo;s Den</a> </td>
<td> <a href="http://onevcat.com/atom.xml">http://onevcat.com/atom.xml</a></td>
</tr>
<tr>
<td><a href="http://beyondvincent.com">破船之家</a> </td>
<td> <a href="http://beyondvincent.com/atom.xml">http://beyondvincent.com/atom.xml</a></td>
</tr>
<tr>
<td><a href="http://nshipster.cn">NSHipster</a> </td>
<td> <a href="http://nshipster.cn/feed.xml">http://nshipster.cn/feed.xml</a></td>
</tr>
<tr>
<td><a href="http://blog.leezhong.com/">Limboy 无网不剩</a> </td>
<td> <a href="http://feeds.feedburner.com/lzyy">http://feeds.feedburner.com/lzyy</a></td>
</tr>
<tr>
<td><a href="http://ios.lextang.com">Lex iOS notes</a> </td>
<td> <a href="http://ios.lextang.com/rss">http://ios.lextang.com/rss</a></td>
</tr>
<tr>
<td><a href="http://nianxi.net">念茜的博客</a> </td>
<td> <a href="http://nianxi.net/feed.xml">http://nianxi.net/feed.xml</a></td>
</tr>
<tr>
<td><a href="http://blog.xcodev.com">Xcode Dev</a> </td>
<td> <a href="http://blog.xcodev.com/atom.xml">http://blog.xcodev.com/atom.xml</a></td>
</tr>
<tr>
<td><a href="http://wufawei.com/">Ted&rsquo;s Homepage</a></td>
<td> <a href="http://wufawei.com/feed">http://wufawei.com/feed</a></td>
</tr>
<tr>
<td><a href="http://blog.t-xx.me">txx&rsquo;s blog</a> </td>
<td> <a href="http://blog.t-xx.me/atom.xml">http://blog.t-xx.me/atom.xml</a></td>
</tr>
<tr>
<td><a href="http://imkevin.me">KEVIN BLOG</a> </td>
<td> <a href="http://imkevin.me/rss">http://imkevin.me/rss</a></td>
</tr>
<tr>
<td><a href="http://www.xiangwangfeng.com">阿毛的蛋疼地</a> </td>
<td> <a href="http://www.xiangwangfeng.com/atom.xml">http://www.xiangwangfeng.com/atom.xml</a></td>
</tr>
<tr>
<td><a href="http://billwang1990.github.io">亚庆的 Blog</a> </td>
<td> <a href="http://billwang1990.github.io/atom.xml">http://billwang1990.github.io/atom.xml</a></td>
</tr>
<tr>
<td><a href="http://nonomori.farbox.com">Nonomori</a> </td>
<td> <a href="http://nonomori.farbox.com/feed">http://nonomori.farbox.com/feed</a></td>
</tr>
<tr>
<td><a href="http://tang3w.com">言无不尽</a> </td>
<td> <a href="http://tang3w.com/atom.xml">http://tang3w.com/atom.xml</a></td>
</tr>
<tr>
<td><a href="http://wonderffee.github.io">Wonderffee&rsquo;s Blog</a> </td>
<td> <a href="http://wonderffee.github.io/atom.xml">http://wonderffee.github.io/atom.xml</a></td>
</tr>
<tr>
<td><a href="http://imtx.me">I&rsquo;m TualatriX</a> </td>
<td> <a href="http://imtx.me/feed/latest/">http://imtx.me/feed/latest/</a></td>
</tr>
<tr>
<td><a href="http://vclwei.com">vclwei</a> </td>
<td> <a href="http://vclwei.com/posts.rss">http://vclwei.com/posts.rss</a></td>
</tr>
<tr>
<td><a href="http://blog.cocoabit.com">Cocoabit</a> </td>
<td> <a href="http://blog.cocoabit.com/atom.xml">http://blog.cocoabit.com/atom.xml</a></td>
</tr>
<tr>
<td><a href="http://nixzhu.me">nixzhu on scriptogr.am</a> </td>
<td> <a href="http://nixzhu.me/feed">http://nixzhu.me/feed</a></td>
</tr>
<tr>
<td><a href="http://studentdeng.github.io">不会开机的男孩</a> </td>
<td> <a href="http://studentdeng.github.io/atom.xml">http://studentdeng.github.io/atom.xml</a></td>
</tr>
<tr>
<td><a href="http://www.taofengping.com">Nico</a> </td>
<td> <a href="http://www.taofengping.com/rss.xml">http://www.taofengping.com/rss.xml</a></td>
</tr>
<tr>
<td><a href="http://hufeng825.github.io">阿峰的技术窝窝</a> </td>
<td> <a href="http://hufeng825.github.io/atom.xml">http://hufeng825.github.io/atom.xml</a></td>
</tr>
<tr>
<td><a href="http://answerhuang.duapp.com">answer_huang</a> </td>
<td> <a href="http://answerhuang.duapp.com/index.php/feed/">http://answerhuang.duapp.com/index.php/feed/</a></td>
</tr>
<tr>
<td><a href="http://webfrogs.me">webfrogs</a> </td>
<td> <a href="http://webfrogs.me/feed/">http://webfrogs.me/feed/</a></td>
</tr>
<tr>
<td><a href="http://joeyio.com">代码手工艺人</a> </td>
<td> <a href="http://joeyio.com/atom.xml">http://joeyio.com/atom.xml</a></td>
</tr>
<tr>
<td><a href="http://gracelancy.com">Lancy&rsquo;s Blog</a> </td>
<td> <a href="http://gracelancy.com/atom.xml">http://gracelancy.com/atom.xml</a></td>
</tr>
<tr>
<td><a href="http://www.imallen.com">I&rsquo;m Allen</a> </td>
<td> <a href="http://www.imallen.com/atom.xml">http://www.imallen.com/atom.xml</a></td>
</tr>
<tr>
<td><a href="http://imi.im/">Travis' Blog</a></td>
<td> <a href="http://imi.im/feed">http://imi.im/feed</a></td>
</tr>
<tr>
<td><a href="http://wangzz.github.io/">王中周的技术博客</a> </td>
<td><a href="http://wangzz.github.io/atom.xml">http://wangzz.github.io/atom.xml</a></td>
</tr>
<tr>
<td><a href="http://jiajun.org/">会写代码的猪</a></td>
<td><a href="http://gaosboy.com/feed/atom/">http://gaosboy.com/feed/atom/</a></td>
</tr>
<tr>
<td><a href="http://wangkewei.cnblogs.com/">克伟的博客</a></td>
<td><a href="http://feed.cnblogs.com/blog/u/23857/rss">http://feed.cnblogs.com/blog/u/23857/rss</a></td>
</tr>
<tr>
<td><a href="http://cnblogs.com/biosli">摇滚诗人</a></td>
<td><a href="http://feed.cnblogs.com/blog/u/35410/rss">http://feed.cnblogs.com/blog/u/35410/rss</a></td>
</tr>
<tr>
<td><a href="http://geeklu.com/">Luke&rsquo;s Homepage</a> </td>
<td> <a href="http://geeklu.com/feed/">http://geeklu.com/feed/</a></td>
</tr>
<tr>
<td><a href="http://iiiyu.com/">萧宸宇</a> </td>
<td> <a href="http://iiiyu.com/atom.xml">http://iiiyu.com/atom.xml</a></td>
</tr>
<tr>
<td><a href="http://www.heyuan110.com/">Yuan博客</a> </td>
<td> <a href="http://www.heyuan110.com/?feed=rss2">http://www.heyuan110.com/?feed=rss2</a></td>
</tr>
<tr>
<td><a href="http://shiningio.com/">Shining IO</a> </td>
<td> <a href="http://shiningio.com/atom.xml">http://shiningio.com/atom.xml</a></td>
</tr>
<tr>
<td><a href="http://www.yifeiyang.net/">YIFEIYANG&ndash;易飞扬的博客</a> </td>
<td> <a href="http://www.yifeiyang.net/feed">http://www.yifeiyang.net/feed</a></td>
</tr>
<tr>
<td><a href="http://koofrank.com/">KooFrank&rsquo;s Blog</a> </td>
<td> <a href="http://koofrank.com/rss">http://koofrank.com/rss</a></td>
</tr>
<tr>
<td><a href="http://helloitworks.com">hello it works</a> </td>
<td> <a href="http://helloitworks.com/feed">http://helloitworks.com/feed</a></td>
</tr>
<tr>
<td><a href="http://msching.github.io/">码农人生</a> </td>
<td> <a href="http://msching.github.io/atom.xml">http://msching.github.io/atom.xml</a></td>
</tr>
<tr>
<td><a href="http://yulingtianxia.com">玉令天下的Blog</a> </td>
<td> <a href="http://yulingtianxia.com/atom.xml">http://yulingtianxia.com/atom.xml</a></td>
</tr>
<tr>
<td><a href="http://www.hotobear.com/">不掏蜂窝的熊</a> </td>
<td> <a href="http://www.hotobear.com/?feed=rss2">http://www.hotobear.com/?feed=rss2</a></td>
</tr>
<tr>
<td><a href="https://andelf.github.io/">猫·仁波切</a> </td>
<td> <a href="https://andelf.github.io/atom.xml">https://andelf.github.io/atom.xml</a></td>
</tr>
<tr>
<td><a href="http://ivoryxiong.org/">煲仔饭</a> </td>
<td> <a href="http://ivoryxiong.org/feed.xml">http://ivoryxiong.org/feed.xml</a></td>
</tr>
<tr>
<td><a href="http://adad184.com">里脊串的开发随笔</a> </td>
<td> <a href="http://adad184.com/atom.xml">http://adad184.com/atom.xml</a></td>
</tr>
<tr>
<td><a href="http://al1020119.github.io/">iCocos：曹理鹏</a> </td>
<td> <a href="http://al1020119.github.io/">http://al1020119.github.io/</a></td>
</tr>
</tbody>
</table>


<h4>物联网</h4>

<ul>
<li><a href="https://github.com/phodal/awesome-iot">awesome-iot</a> - 这份物联网学习参考大全太给力。从物联网协议、嵌入式系统、相关开源库、相关书籍、博客、学习笔记、标准应有尽有。</li>
</ul>


<hr />

<p>更新中，敬请关注。。。。。。</p>

<pre><code>Q Q：2211523682/790806573

微信：18370997821/13148454507

微博WB:http://weibo.com/u/3288975567?is_hot=1

git博文：http://al1020119.github.io/

github：https://github.com/al1020119
</code></pre>

<p><img src="http://al1020119.github.io/images/iCocosCoder.jpg" title="Caption" ></p>

<p><img src="http://al1020119.github.io/images/iCocosPublic.jpg" title="Caption" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS大神之路——精华篇]]></title>
    <link href="http://al1020119.github.io/blog/2016/10/13/iosda-shen-zhi-lu-jing-hua-pian/"/>
    <updated>2016-10-13T18:38:38+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/10/13/iosda-shen-zhi-lu-jing-hua-pian</id>
    <content type="html"><![CDATA[<h1>iCocos</h1>

<p>iOS初学者面对网上浩瀚的资料往往不知所措，为了让iOS初学者们少走弯路，少花时间在搜索资料上，个人为iOS初学者整理了一份学习资料。希望能帮助到大家。</p>

<h2>一：培训班视频教程</h2>

<table>
<thead>
<tr>
<th>地址  </th>
<th>  简介</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://open.itcast.cn/ios/">传智播客iOS公开课</a></td>
<td> 传智播客iOS公开课</td>
</tr>
<tr>
<td><a href="http://yun.baidu.com/s/1pKYiLwJ">传智播客2016年基础班</a></td>
<td> 传智播客2016基础班</td>
</tr>
<tr>
<td><a href="http://pan.baidu.com/s/1pKLqjnt">传智播客2013年基础班</a></td>
<td> 李明杰授课</td>
</tr>
<tr>
<td><a href="http://pan.baidu.com/s/1eSnvZVk">传智2013年就业班</a></td>
<td> 李明杰授课 解压密码u1ku.taobao.com</td>
</tr>
<tr>
<td><a href="http://yun.baidu.com/s/1mhdu1z6">传智2015广州一期</a></td>
<td> 传智播客2015广州就业班</td>
</tr>
<tr>
<td><a href="http://yun.baidu.com/s/1i4qrLAl#path=%252F">黑马2014年8-12月</a></td>
<td> 黑马程序员就业班</td>
</tr>
<tr>
<td><a href="http://pan.baidu.com/s/1boJCKDD">黑马2014年5-8月</a></td>
<td> 黑马程序员就业班</td>
</tr>
<tr>
<td><a href="https://pan.baidu.com/s/1o8GpGy2">小码哥大神班1期</a></td>
<td> 李明杰，swift版微博项目，ReactiveCocoa，百思不得姐，环信，HTML5</td>
</tr>
<tr>
<td><a href="https://yun.baidu.com/s/1slDzMWX">小码哥大神班5期</a></td>
<td> 新增MVVM，Apple Pay</td>
</tr>
<tr>
<td>小码哥大神班11期</td>
<td> <a href="https://pan.baidu.com/s/1jIlVZBg">第一部分</a>密码:diyq<a href="https://pan.baidu.com/s/1dE2eTSt">第二部分</a>密码: a7fx 新增React Native项目</td>
</tr>
</tbody>
</table>


<!--more-->


<h2>二：进阶教程</h2>

<table>
<thead>
<tr>
<th>地址  </th>
<th>  简介</th>
</tr>
</thead>
<tbody>
<tr>
<td>斗鱼直播视频1.<a href="http://pan.baidu.com/s/1eSyifOe">下载地址</a>2.<a href="http://reviewcode.cn/video.html">在线播放地址</a></td>
<td> QQ群(叶孤城的iOS开发天地)直播视频（群号：107888255），有仿写下厨房，Masonry，RAC，RunLoop，插件开发等高级内容</td>
</tr>
<tr>
<td><a href="https://developer.apple.com/videos/">WWDC官方视频</a></td>
<td> 历年WWDC官方视频</td>
</tr>
<tr>
<td><a href="https://github.com/SwiftGGTeam/Developing-iOS-9-Apps-with-Swift">Developing-iOS-9-Apps-with-Swift</a></td>
<td> 斯坦福大学公开课，Swift版iOS9教程，字幕翻译</td>
</tr>
<tr>
<td><a href="https://github.com/SwiftGGTeam/Developing_iOS_8_Apps_With_Swift">Developing-iOS-8-Apps-with-Swift</a></td>
<td> 斯坦福大学公开课，Swift版iOS8教程，字幕翻译</td>
</tr>
<tr>
<td><a href="http://open.163.com/special/opencourse/iphonekaifa.html">iPhone开发教程2010年冬</a></td>
<td> 斯坦福大学公开课，Objective-C</td>
</tr>
<tr>
<td><a href="http://open.163.com/special/opencourse/ios7.html">iOS 7应用开发</a></td>
<td> 斯坦福大学公开课，iOS7，Objective-C</td>
</tr>
</tbody>
</table>


<h2>三：推荐博客、微博或Github</h2>

<table>
<thead>
<tr>
<th>地址  </th>
<th>  简介</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://wereadteam.github.io">WeRead团队博客</a></td>
<td> 微信读书团队博客</td>
</tr>
<tr>
<td><a href="http://baiduhidevios.github.io/">百度Hi iOS团队技术周报</a></td>
<td> 百度Hi iOS团队技术周报</td>
</tr>
<tr>
<td><a href="http://tech.meituan.com/">美团点评技术团队博客</a></td>
<td> 美团点评技术团队</td>
</tr>
<tr>
<td><a href="http://pingguohe.net">苹果核</a></td>
<td> 现由天猫无线-基础业务团队主力维护</td>
</tr>
<tr>
<td><a href="http://swift.gg">SwiftGG翻译组</a></td>
<td> 翻译的文章来源于国外的优秀 Swift 网站和博客</td>
</tr>
<tr>
<td><a href="http://mobilefrontier.github.io/">移动开发前线博客</a></td>
<td> 第一时间传递移动开发最新干货内容，与时代保持同步，消除信息焦虑。<a href="http://weibo.com/bornmobile?from=myfollow_group&amp;is_all=1">微博@移动开发前线</a></td>
</tr>
<tr>
<td><a href="http://blog.sunnyxx.com">sunnyxx的技术博客</a></td>
<td> 孙源，前百度研发工程师<a href="http://weibo.com/u/1364395395?topnav=1&amp;wvr=6&amp;topsug=1&amp;is_all=1">微博@我就叫Sunny怎么了</a></td>
</tr>
<tr>
<td><a href="http://blog.ibireme.com">Garan no Dou </a></td>
<td> ibireme，YYKit作者</td>
</tr>
<tr>
<td><a href="http://www.jianshu.com/users/b82d2721ba07/latest_articles">叶孤城</a></td>
<td> 大神，现在创业。<a href="http://weibo.com/u/1438670852?from=myfollow_group&amp;is_all=1">微博@叶孤城___</a></td>
</tr>
<tr>
<td><a href="http://adad184.com">里脊串的开发随笔</a></td>
<td> 著名iOS工程师<a href="http://weibo.com/ljc1986?from=myfollow_group&amp;is_all=1">微博@里脊串</a></td>
</tr>
<tr>
<td><a href="http://www.henishuo.com">标哥的技术博客</a></td>
<td> 著名iOS工程师，博客更新非常频繁，活跃在各个社区，reviewcode.cn成员</td>
</tr>
<tr>
<td><a href="http://www.cnblogs.com/kenshincui">Kenshin Cui&rsquo;s Blog</a></td>
<td> 崔江涛，文章写的非常详细</td>
</tr>
<tr>
<td><a href="https://github.com/ChenYilong">ChenYilong</a></td>
<td> <a href="http://weibo.com/luohanchenyilong?refer_flag=1005055013_&amp;is_all=1">微博@iOS程序犭袁</a>有iOS9AdaptationTips,iOSInterviewQuestions等多个上千star的项目</td>
</tr>
<tr>
<td><a href="http://southpeak.github.io">南峰子的技术博客</a></td>
<td> 就职于京东金融。<a href="http://weibo.com/touristdiary?refer_flag=1005055013_&amp;is_all=1">微博@南峰子_老驴</a></td>
</tr>
<tr>
<td><a href="http://fengjian0106.github.io">FengJian&rsquo;s Blog</a></td>
<td> FengJian&rsquo;s Blog</td>
</tr>
<tr>
<td><a href="http://xiangwangfeng.com">阿毛的蛋疼地</a></td>
<td> 博客从2011年就开始更新了</td>
</tr>
<tr>
<td><a href="http://foggry.com">王中周的技术博客</a></td>
<td> 曾就职于高阳科技、北京拉手网</td>
</tr>
<tr>
<td><a href="http://tutuge.me">土土哥的技术博客</a></td>
<td> 就职于阿里巴巴B2B国际事业部</td>
</tr>
<tr>
<td><a href="http://yulingtianxia.com">玉令天下的博客</a></td>
<td> 腾讯移动开发实习</td>
</tr>
<tr>
<td><a href="http://casatwy.com">Casa Taloyum</a></td>
<td> iOS应用架构谈系列作者</td>
</tr>
<tr>
<td><a href="http://blog.wtlucky.com">GeekerProbe</a></td>
<td> 曾就职于美丽说，负责美丽说主站APP的开发工作，在时尚圈也有一番打拼，现就职于百度，负责百度知道项目的开发，也因此加入forkingdog开源小组，为iOS的开源社区做出一点贡献。</td>
</tr>
<tr>
<td><a href="http://geeklu.com">Luke&rsquo;s Homepage</a></td>
<td> 2008年开始更新，经验丰富的工程师</td>
</tr>
<tr>
<td><a href="https://github.com/liuzhiyi1992/MyshareBlogs">Zhiyi</a></td>
<td> 他的github上拥有多个超过200star的项目</td>
</tr>
<tr>
<td><a href="http://limboy.me">Limboy</a></td>
<td> 蘑菇街iOS工程师</td>
</tr>
<tr>
<td><a href="https://blog.cnbluebox.com">刘坤的技术博客</a></td>
<td> 现就职于杭州阿里</td>
</tr>
<tr>
<td><a href="http://www.jianshu.com/users/40e4dced948f/latest_articles">kuailejim</a></td>
<td> kuailejim</td>
</tr>
<tr>
<td><a href="https://github.com/gsdios">高少东</a></td>
<td> SDAutoLayout作者 <a href="http://weibo.com/gsdios?is_all=1">微博@GSD_iOS </a></td>
</tr>
<tr>
<td><a href="https://github.com/lzwjava">lzwjava</a></td>
<td> 前 LeanCloud 工程师。<a href="http://weibo.com/zhiweilee">微博@lzwjava</a></td>
</tr>
<tr>
<td><a href="http://blog.devtang.com">唐巧</a></td>
<td> 猿题库iOS高级研发工程师。<a href="http://weibo.com/tangqiaoboy?refer_flag=1005055013_&amp;is_all=1">微博@唐巧_boy</a></td>
</tr>
<tr>
<td><a href="http://www.jianshu.com/users/3e55748920d2/latest_articles">bestswifter</a></td>
<td> 简书推荐作者。<a href="http://weibo.com/bestswifter?refer_flag=1005055013_&amp;is_all=1">微博@bestswifter</a></td>
</tr>
<tr>
<td>李明杰</td>
<td> 小码哥CEO。<a href="http://weibo.com/exceptions?from=myfollow_group&amp;is_all=1">微博@M了个J</a></td>
</tr>
<tr>
<td><a href="https://onevcat.com/#blog">OneV&rsquo;s Den</a></td>
<td> 王巍，喵神，知名iOS/Unity 开发者，现居日本，就职于LINE<a href="http://weibo.com/onevcat?from=myfollow_group">微博@onevcat</a></td>
</tr>
<tr>
<td><a href="https://github.com/12207480">tany</a></td>
<td> Github上有很多干货 <a href="http://weibo.com/u/5515296583?refer_flag=1001030101_&amp;is_all=1">微博@yeBlueColor</a></td>
</tr>
<tr>
<td><a href="http://weibo.com/GitHubDaily?from=feed&amp;loc=at&amp;nick=GitHubDaily&amp;is_all=1">微博@GitHubDaily</a></td>
<td> 专注于分享 GitHub 最新的优质开源项目</td>
</tr>
<tr>
<td><a href="http://al1020119.github.io/">iCocos</a></td>
<td> 个人（iCocos：曹理鹏）博文</td>
</tr>
</tbody>
</table>


<h2>四：学习网站</h2>

<table>
<thead>
<tr>
<th>地址  </th>
<th>  简介</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://objccn.io/">objc中国</a></td>
<td> 为中国 Objective-C 社区带来最佳实践和先进技术</td>
</tr>
<tr>
<td><a href="http://nshipster.cn">NSHipster中文版</a></td>
<td> NSHipster 关注被忽略的 Objective-C、Swift 和 Cocoa 特性。每周更新。</td>
</tr>
<tr>
<td><a href="http://iosdevweekly.com">iOS Dev Weekly</a></td>
<td> 如果你是老手精通英文，那么这个周刊是非常值得推荐订阅的，该周刊提供行业新闻、最新开发动态、开发工具、代码分享、UI设计、设计师招聘等丰富的资源。</td>
</tr>
<tr>
<td><a href="https://www.shinobicontrols.com/blog">Shinobicontrols</a></td>
<td> The latest technical blog posts</td>
</tr>
<tr>
<td><a href="http://iosdevelopertips.com">iOS Developer Tips</a></td>
<td> Code, tips and tricks for iOS developers</td>
</tr>
<tr>
<td><a href="https://www.raywenderlich.com">Raywenderlich</a></td>
<td> 国外iOS视频教程网站</td>
</tr>
</tbody>
</table>


<h2>五：开源项目</h2>

<table>
<thead>
<tr>
<th>地址  </th>
<th>  简介</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/Draveness/iOS-Source-Code-Analyze">iOS-Source-Code-Analyze</a></td>
<td> <strong>收集了优秀的iOS开源框架源代码解析文章，强烈推荐</strong></td>
</tr>
<tr>
<td><a href="https://github.com/CatchChat/Yep">Yep</a></td>
<td> 社交IM软件YEP，star4000+</td>
</tr>
<tr>
<td><a href="https://github.com/mogujie/TeamTalk">TeamTalk</a></td>
<td> 蘑菇街开源IM，star3000+</td>
</tr>
<tr>
<td><a href="https://github.com/xhzengAIB/MessageDisplayKit">MessageDisplayKit</a></td>
<td> 类似微信的IMapp，可发送图片，音频，视频，文字，位置信息等，star3000+</td>
</tr>
<tr>
<td><a href="https://github.com/dsxNiubility/SXNews">仿网易新闻</a></td>
<td> star2000+</td>
</tr>
<tr>
<td><a href="https://github.com/ZhongTaoTian/WNXHuntForCity">高仿城觅</a></td>
<td> star1700+</td>
</tr>
<tr>
<td><a href="https://github.com/YouXianMing/YoCelsius">YoCelsius</a></td>
<td> 天气预报的应用，动画和交互非常丰富，star1800+</td>
</tr>
<tr>
<td><a href="https://github.com/Coding/Coding-iOS">Coding-iOS</a></td>
<td> Coding iOS 客户端源代码, star1700+</td>
</tr>
<tr>
<td><a href="https://github.com/singro/v2ex">v2ex</a></td>
<td> v2ex.com客户端，star1600+</td>
</tr>
<tr>
<td><a href="https://github.com/gsdios/GSD_WeiXin">高仿微信</a></td>
<td> star1500+</td>
</tr>
<tr>
<td><a href="https://github.com/lookingstars/meituan">高仿美团</a></td>
<td>  star1300+</td>
</tr>
<tr>
<td><a href="https://github.com/SunLiner/MiaowShow">高仿喵播APP</a></td>
<td>  视频直播项目，star1300+</td>
</tr>
<tr>
<td><a href="https://github.com/ZhongTaoTian/LoveFreshBeen">爱鲜蜂</a></td>
<td> Swift2.0，star1000+</td>
</tr>
<tr>
<td><a href="https://github.com/MichaelHuyp/Bilibili_Wuxianda">高仿Bilibili客户端</a></td>
<td> star1000+</td>
</tr>
<tr>
<td><a href="https://github.com/gsdios/GSD_ZHIFUBAO">高仿支付宝</a></td>
<td>  star700+</td>
</tr>
<tr>
<td><a href="https://github.com/lyimin/beautifulApp">高仿最美应用</a></td>
<td>  star700+</td>
</tr>
<tr>
<td><a href="https://github.com/ZhongTaoTian/SmallDay">高仿小日子</a></td>
<td>  Swift2.0, star700+</td>
</tr>
<tr>
<td><a href="https://github.com/meilbn/MyOne-iOS">一个</a></td>
<td>  《一个》 iOS 客户端, star600+</td>
</tr>
<tr>
<td><a href="https://github.com/jxd001/Swift-ZhihuDaily">知乎日报</a></td>
<td>  swift 知乎日报, star500+</td>
</tr>
<tr>
<td><a href="https://github.com/zixun/CocoaChinaPlus">CocoaChina+</a></td>
<td>  开源的第三方CocoaChina移动端,swift2.0， star500+</td>
</tr>
<tr>
<td><a href="https://github.com/jiachenmu/Swift-BanTang">半塘</a></td>
<td>  Swift2.0 高仿半糖App，star400+</td>
</tr>
<tr>
<td><a href="https://github.com/lookingstars/nuomi">高仿百度糯米</a></td>
<td>  star400+</td>
</tr>
<tr>
<td><a href="https://github.com/shenAlexy/MVVM">MVVM</a></td>
<td>  MVVM架构的一次实践，重写iOS头条客户端，star300+</td>
</tr>
<tr>
<td><a href="https://github.com/SketchK/FOUR">Four</a></td>
<td>  一个上线的任务记录app，star200+</td>
</tr>
</tbody>
</table>


<h2>六：微信公众号</h2>

<p><img src="http://upload-images.jianshu.io/upload_images/1070332-6b6f25ce0b552191.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" /></p>

<h2>七：更多资料</h2>

<table>
<thead>
<tr>
<th>地址  </th>
<th>  简介</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/Aufree/trip-to-iOS">trip-to-iOS</a></td>
<td> 6000多个star的iOS学习资料整理</td>
</tr>
<tr>
<td><a href="https://github.com/ipader/SwiftGuide">SwiftGuide</a></td>
<td> 这份指南汇集了Swift语言主流学习资源，接近1W的star</td>
</tr>
<tr>
<td><a href="https://github.com/Tim9Liu9/TimLiu-iOS">TimLiu-iOS</a></td>
<td> 4000多个star，iOS、mac开源项目及库</td>
</tr>
<tr>
<td><a href="https://github.com/TeamStuQ/skill-map">skill-map</a></td>
<td>  IT技术领域（云计算，大数据，运维，安全，开发语言，智能硬件等）及互联网产品、运营等领域学习技能图谱</td>
</tr>
<tr>
<td><a href="http://ppt.geekbang.org/gmtc?amp;isappinstalled=0&amp;amp;amp;amp;amp;amp;from=groupmessage&amp;amp;amp;amp;amp;from=groupmessage&amp;amp;amp;amp;from=timeline&amp;amp;amp;amp;isappinstalled=0&amp;amp;amp;from=timeline&amp;amp;amp;isappinstalled=0&amp;amp;from=timeline&amp;amp;isappinstalled=0&amp;from=timeline&amp;from=timeline&amp;isappinstalled=0">全球移动技术大会2016</a></td>
<td> 全球移动技术大会2016PPT下载合集</td>
</tr>
<tr>
<td><a href="https://github.com/atConf/atswift-2016-resources">atswift-2016-resources</a></td>
<td> 2016中国Swift开发者大会源文件，包括keynote, pdf 和源工程文件</td>
</tr>
</tbody>
</table>


<hr />

<p>更新中，敬请关注。。。。。。</p>

<pre><code>Q Q：2211523682/790806573

微信：18370997821/13148454507

微博WB:http://weibo.com/u/3288975567?is_hot=1

git博文：http://al1020119.github.io/

github：https://github.com/al1020119
</code></pre>

<p><img src="http://al1020119.github.io/images/iCocosCoder.jpg" title="Caption" ></p>

<p><img src="http://al1020119.github.io/images/iCocosPublic.jpg" title="Caption" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[玩转iOS10+Xcode8适配]]></title>
    <link href="http://al1020119.github.io/blog/2016/10/12/wan-zhuan-ios10-plus-xcode8gua-pei/"/>
    <updated>2016-10-12T11:34:34+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/10/12/wan-zhuan-ios10-plus-xcode8gua-pei</id>
    <content type="html"><![CDATA[<p>最近因为公司App在iOS10上出现很多问题，结果花了一天时间适配了一下，其中也遇到了不少坑，有些网上直接有方法，但是有些却需要细心琢磨。这里整理了一下。</p>

<p>其中有两个比较麻烦的</p>

<ul>
<li><p>1：关于导航栏的适配</p>

<ul>
<li>当导航栏是透明或者半透明的实现，显示不正常，全白。</li>
</ul>
</li>
<li><p>2：关于tabBar的适配</p>

<ul>
<li>tabbar中第一个子控制器的Item重复出现</li>
</ul>
</li>
</ul>


<p>下面一个个整理了一下！</p>

<!--more-->


<h2>1.Xcode8运行项目之后，控制台打印了一堆东西;</h2>

<p>去除方法：选择Xcode ->Product ->Scheme -> Edit Scheme 或者按command + shift + &lt; 快捷键，</p>

<p>在弹出的窗口中Environment Variables 下添加 0S_ACTIVITY_MODE=disable</p>

<p><img src="http://al1020119.github.io/images/ios10shipei001.png" title="Caption" ></p>

<blockquote><p>注：真机调试不输出NSlog了，所以我真机调试的时候，把此处对号去除，就好了</p></blockquote>

<h5>最新Log方式：（会定位某各类，某个方法，某一行）</h5>

<pre><code>#ifdef DEBUG
#define iCocosLog(format, ...) printf("\n[%s] %s [第%d行] %s\n", __TIME__, __FUNCTION__, __LINE__, [[NSString stringWithFormat:format, ## __VA_ARGS__] UTF8String]);
#else
#define iCocosLog(format, ...)
#endif
</code></pre>

<h2>2.Xcode8 打开工程后，出现下图，苹果新特性</h2>

<p><img src="http://al1020119.github.io/images/ios10shipei002.png" title="Caption" ></p>

<p>我勾选了Automatically manage signing(需要在Xcode的偏好设置中，添加苹果账号)，并且选择配置了Team，就好了。</p>

<blockquote><p>注：或者另外一种方式  点击打开链接</p></blockquote>

<h2>3.用Xcode8 运行项目在真机上，打开相机相册功能，程序崩溃；</h2>

<p>解决办法：项目中访问了隐私数据，需要在info.plist中添加这些权限：</p>

<p>相机权限</p>

<pre><code>&lt;key&gt;NSCameraUsageDescription&lt;/key&gt;

&lt;string&gt;cameraDesciption&lt;/string&gt;
</code></pre>

<p>相册权限</p>

<pre><code>&lt;key&gt;NSPhotoLibraryUsageDescription&lt;/key&gt;

&lt;string&gt;photoLibraryDesciption&lt;/string&gt;
</code></pre>

<p>注：
在CODE上查看代码片派生到我的代码片</p>

<pre><code>&lt;!-- 相册 --&gt;   
&lt;key&gt;NSPhotoLibraryUsageDescription&lt;/key&gt;   
&lt;string&gt;App需要您的同意,才能访问相册&lt;/string&gt;   
&lt;!-- 相机 --&gt;   
&lt;key&gt;NSCameraUsageDescription&lt;/key&gt;   
&lt;string&gt;App需要您的同意,才能访问相机&lt;/string&gt;   
&lt;!-- 麦克风 --&gt;   
&lt;key&gt;NSMicrophoneUsageDescription&lt;/key&gt;   
&lt;string&gt;App需要您的同意,才能访问麦克风&lt;/string&gt;   
&lt;!-- 位置 --&gt;   
&lt;key&gt;NSLocationUsageDescription&lt;/key&gt;   
&lt;string&gt;App需要您的同意,才能访问位置&lt;/string&gt;   
&lt;!-- 在使用期间访问位置 --&gt;   
&lt;key&gt;NSLocationWhenInUseUsageDescription&lt;/key&gt;   
&lt;string&gt;App需要您的同意,才能在使用期间访问位置&lt;/string&gt;   
&lt;!-- 始终访问位置 --&gt;   
&lt;key&gt;NSLocationAlwaysUsageDescription&lt;/key&gt;   
&lt;string&gt;App需要您的同意,才能始终访问位置&lt;/string&gt;   
&lt;!-- 日历 --&gt;   
&lt;key&gt;NSCalendarsUsageDescription&lt;/key&gt;   
&lt;string&gt;App需要您的同意,才能访问日历&lt;/string&gt;   
&lt;!-- 提醒事项 --&gt;   
&lt;key&gt;NSRemindersUsageDescription&lt;/key&gt;   
&lt;string&gt;App需要您的同意,才能访问提醒事项&lt;/string&gt;   
&lt;!-- 运动与健身 --&gt;   
&lt;key&gt;NSMotionUsageDescription&lt;/key&gt; &lt;string&gt;App需要您的同意,才能访问运动与健身&lt;/string&gt;   
&lt;!-- 健康更新 --&gt;   
&lt;key&gt;NSHealthUpdateUsageDescription&lt;/key&gt;   
&lt;string&gt;App需要您的同意,才能访问健康更新 &lt;/string&gt;   
&lt;!-- 健康分享 --&gt;   
&lt;key&gt;NSHealthShareUsageDescription&lt;/key&gt;   
&lt;string&gt;App需要您的同意,才能访问健康分享&lt;/string&gt;   
&lt;!-- 蓝牙 --&gt;   
&lt;key&gt;NSBluetoothPeripheralUsageDescription&lt;/key&gt;   
&lt;string&gt;App需要您的同意,才能访问蓝牙&lt;/string&gt;   
&lt;!-- 媒体资料库 --&gt;   
&lt;key&gt;NSAppleMusicUsageDescription&lt;/key&gt;   
&lt;string&gt;App需要您的同意,才能访问媒体资料库&lt;/string&gt;  
</code></pre>

<p>如果没有用，需配置一下</p>

<p><img src="http://al1020119.github.io/images/ios10shipei003.png" title="Caption" ></p>

<blockquote><p>注意，添加的时候，末尾不要有空格，值得说明必须要要写不写也会崩溃</p></blockquote>

<p>我们需要打开info.plist文件添加相应权限的说明，否则程序在iOS10上会出现崩溃。</p>

<h2>4.字体变大，原有的fream需要适配</h2>

<p>经有的朋友提醒，发现程序内原来2个字的宽度是24，现在2个字需要27的宽度来显示了。。我只能试着一个个智能逐一排查!</p>

<ul>
<li>希望有解决办法的朋友，评论告我一下耶，谢谢啦</li>
</ul>


<h2>5.Nib问题：警告</h2>

<p>在CODE上查看代码片派生到我的代码片</p>

<pre><code>- (void)awakeFromNib {  
    // Initialization code  
}  
</code></pre>

<p>需要添加：
在CODE上查看代码片派生到我的代码片</p>

<pre><code>[super awakeFromNib];  
</code></pre>

<h2>6.UIApplication对象中openUrl被废弃</h2>

<p>在iOS 10以前，我们要想使用应用程序去打开一个网页或者进行跳转，直接使用[[UIApplication sharedApplication] openURL 方法就可以了，但是在iOS 10 已经被废弃了，因为使用这种方式，处理的结果我们不能拦截到也不能获取到，对于开发是非常不利的，在iOS 10全新的退出了</p>

<pre><code>[[UIApplication sharedApplication] openURL:nil options:nil completionHandler:nil];
</code></pre>

<p>有一个成功的回调block 可以进行监视。</p>

<blockquote><p>注：仍然可以用，只不过会出现警告</p></blockquote>

<h2>7.系统判断失效</h2>

<p>现在改用：
在CODE上查看代码片派生到我的代码片</p>

<pre><code>#define LIOS10_OR_LATER  ([[[UIDevice currentDevice]systemVersion]compare:@"10.0" options:NSNumericSearch] !=NSOrderedAscending)  
</code></pre>

<h2>8.代码注释不能用</h2>

<p>解决方法：</p>

<pre><code>打开终端，命令运行： sudo /usr/libexec/xpccachectl
</code></pre>

<p>然后必须重启电脑后生效</p>

<blockquote><p>Xcode8已经不能再使用第三方插件了，但是Xcode8已经完善了一部分第三方插件才能实现的功能（抹杀了第三方插件作者，掠夺别人的劳动成果），比如语法提示、代码注释。</p>

<p>Xcode8代码注释快捷键为 Command + Option + / 。</p></blockquote>

<h2>9.导航栏适配</h2>

<p>因为使用了"UINavigationBar+Awesome.h"这个框架，所以，最后找来找去，找到了这个框架的底层，修改代码发现既然可以。</p>

<pre><code>if (!self.overlay) {
    [self setBackgroundImage:[UIImage new] forBarMetrics:UIBarMetricsDefault];
    self.overlay = [[UIView alloc] initWithFrame:CGRectMake(0, 0, CGRectGetWidth(self.bounds), CGRectGetHeight(self.bounds) + 20)];
    self.overlay.userInteractionEnabled = NO;
    self.overlay.autoresizingMask = UIViewAutoresizingFlexibleWidth;    // Should not set `UIViewAutoresizingFlexibleHeight`
    [[self.subviews firstObject] insertSubview:self.overlay atIndex:0];
}
self.overlay.backgroundColor = backgroundColor;
</code></pre>

<h2>10.导航的图片不显示了,使用的是系统导航,怎么调整都不显示.</h2>

<p>解决问题
找到原因了,修改代码就比较容易了,你可以在添加视图时,将bgView指定到UIVisualEffectView,将新的视图添加到UIVisualEffectView上:</p>

<pre><code>for (UIView  * v in subs)
    {
        NSString * classname = NSStringFromClass([v class]);
        if ([classname isEqualToString:@"_UINavigationBarBackground"] || [classname isEqualToString:@"UINavigationBarBackground"])
        {

            bgview=v;
            break;
        }  else if ([classname isEqualToString:@"_UIBarBackground"]) {
            //适配iOS10导航
            for (UIView *vi in v.subviews) {

                NSString *viName = NSStringFromClass([vi class]);
                if ([viName isEqualToString:@"UIVisualEffectView"]) {

                    bgview = vi;
                    break;
                }
            }
        }
    }
</code></pre>

<p>也可以还添加到_UIBarBackground上,但是找到UIVisualEffectView,将其隐藏掉:</p>

<pre><code>if ([classname isEqualToString:@"_UINavigationBarBackground"] || [classname isEqualToString:@"UINavigationBarBackground"])
        {

            bgview=v;
            break;
        } else if ([classname isEqualToString:@"_UIBarBackground"]) {

            bgview = v;

            for (UIView *vi in v.subviews) {
                // 适配iOS10
                NSString *viName = NSStringFromClass([vi class]);
                if ([viName isEqualToString:@"UIVisualEffectView"]) {

                    vi.hidden = YES;
                    break;
                }
            }
        }
</code></pre>

<h2>11.Xcode7 8SB兼容问题</h2>

<p>控制器报如下错误：</p>

<pre><code>This version does not support documents saved in the Xcode 8 format. Open this document with Xcode 8.0 or later.
</code></pre>

<p>右键SB，选择Open As -> Source Code，并删除下面代码即可：</p>

<pre><code>&lt;capability name="documents saved in the Xcode 8 format" minToolsVersion="8.0"/&gt;
</code></pre>

<p><img src="http://al1020119.github.io/images/ios10shipei004.png" title="Caption" ></p>

<h2>12.推送</h2>

<p>如下图的部分，不要忘记打开。所有的推送平台，不管是极光还是什么的，要想收到推送，这个是必须打开的哟✌️</p>

<p><img src="http://al1020119.github.io/images/ios10shipei005.png" title="Caption" ></p>

<p>之后就应该可以收到推送了。另外，极光推送也推出新版本了，大家也可以更新下。</p>

<p>PS.苹果这次对推送做了很大的变化，希望大家多查阅查阅，处理推送的代理方法也变化了。</p>

<p>// 推送的代理</p>

<pre><code>[&lt;UNUserNotificationCenterDelegate&gt;]
</code></pre>

<p>iOS10收到通知不再是在</p>

<pre><code>[application: didReceiveRemoteNotification:]
</code></pre>

<p>方法去处理， iOS10推出新的代理方法，接收和处理</p>

<p>各类通知（本地或者远程）</p>

<pre><code>- (void)userNotificationCenter:(UNUserNotificationCenter *)center willPresentNotification:(UNNotification *)notification withCompletionHandler:(void (^)(UNNotificationPresentationOptions))completionHandler 
{ 
//应用在前台收到通知 NSLog(@"========%@", notification);
}


- (void)userNotificationCenter:(UNUserNotificationCenter *)center didReceiveNotificationResponse:(UNNotificationResponse *)response withCompletionHandler:(void (^)())completionHandler { 
//点击通知进入应用 NSLog(@"response:%@", response);
}
</code></pre>

<h2>13.代码及Api注意</h2>

<p>使用Xcode8之后，有些代码可能就编译不过去了，具体我就说说我碰到的问题。</p>

<p>1.UIWebView的代理方法：</p>

<blockquote><p>**注意要删除NSError前面的 nullable，否则报错。</p></blockquote>

<pre><code>- (void)webView:(UIWebView *)webView didFailLoadWithError:(nullable NSError *)error
{
    [self hideHud];
}
</code></pre>

<h2>14.Xib文件的注意事项</h2>

<p>使用Xcode8打开xib文件后，会出现下图的提示。</p>

<p><img src="http://al1020119.github.io/images/ios10shipei006.png" title="Caption" ></p>

<p>大家选择Choose Device即可。
之后大家会发现布局啊，frame乱了，只需要更新一下frame即可。如下图</p>

<p><img src="http://al1020119.github.io/images/ios10shipei007.png" title="Caption" ></p>

<pre><code>注意：如果按上面的步骤操作后，在用Xcode7打开Xib会报一下错误，
</code></pre>

<p><img src="http://al1020119.github.io/images/ios10shipei008.png" title="Caption" ></p>

<h5>解决办法：需要删除Xib里面</h5>

<pre><code>&lt;capability name="documents saved in the Xcode 8 format" minToolsVersion="8.0"/&gt;

这句话，以及把&lt; document &gt;中的toolsVersion和&lt; plugIn &gt;中的version改成你正常的xib文件中的值
，不过不建议这么做，在Xcode8出来后，希望大家都快速上手，全员更新。这就跟Xcode5到Xcode6一样，有变动，但是还是要尽早学习，尽快适应哟！
</code></pre>

<h2>15.tabBarItem第一个重复出现</h2>

<p>这个问题实在没有找到好的方法解决。不过庆幸的是，公司决定将TabBar中的Item四个变成，既然好了，我就想不通。</p>

<p>如果你也遇到了这样的问题，或者已经解决了此问题，欢迎联系我，在此致谢！</p>

<hr />

<pre><code>Q Q：2211523682/790806573

微信：18370997821/13148454507

微博WB:http://weibo.com/u/3288975567?is_hot=1

git博文：http://al1020119.github.io/

github：https://github.com/al1020119
</code></pre>

<p><img src="http://al1020119.github.io/images/iCocosCoder.jpg" title="Caption" ></p>

<p><img src="http://al1020119.github.io/images/iCocosPublic.jpg" title="Caption" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[最新书单]]></title>
    <link href="http://al1020119.github.io/blog/2016/09/26/zui-xin-shu-dan/"/>
    <updated>2016-09-26T13:30:57+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/09/26/zui-xin-shu-dan</id>
    <content type="html"><![CDATA[<h2>2016年-2017年书单</h2>

<p>总结了一下，2016年，这一年来所看的书和2017年计划所要看的书，后面的文章中会给出相关介绍并且说明我为什么会选择这些，同时以后也会时常回顾这些东西。</p>

<p>如果遗漏或者增加的后面会继续补充。</p>

<!--more-->


<hr />

<h4>2016</h4>

<hr />

<h4>全力推荐：</h4>

<ul>
<li>内外兼修</li>
</ul>


<h4>程序员篇</h4>

<ul>
<li>程序员必备之路
 

<ul>
<li>剑指offer
 </li>
<li>大话设计模式
 </li>
<li>数据结构教程
 </li>
<li>算法设计与分析
 </li>
<li>算法导论
 <br/>
 </li>
</ul>
</li>
</ul>


<h4>iOS篇 </h4>

<ul>
<li> iOS底层与高级篇
 

<ul>
<li>Effective Objective-C 2.0
 </li>
<li>Objective-C高级编程
 </li>
<li>iOS开发网络高级编程
 </li>
<li>iOS开发数据库应用高级编程
 </li>
<li>精通iOS开发读
 </li>
<li>iOS逆向工程
 
 </li>
</ul>
</li>
</ul>


<p>总结：</p>

<ol>
<li><p>ios底层与高级相关</p></li>
<li><p>算法与数据结构相关</p></li>
</ol>


<hr />

<h4>2017</h4>

<hr />

<h4>后台篇</h4>

<p> </p>

<ul>
<li> PHP
 

<ul>
<li>PHP入门到精通
 </li>
<li>PHP和MYSQL WEB开发
 </li>
</ul>
</li>
</ul>


<h4>全栈篇</h4>

<ul>
<li>JavaScript
 

<ul>
<li><p>JavaScript权威指南</p></li>
<li><p>JavaScript高级程序设计</p></li>
</ul>
</li>
</ul>


<p>总结：</p>

<ol>
<li><p>PHP后台与网站相关</p></li>
<li><p>JS->H5,微信小程序相关</p></li>
</ol>


<blockquote><p>我相信 : 我们每天不是在学习，就是在学习路上！</p></blockquote>

<hr />

<pre><code>Q Q：2211523682/790806573

微信：18370997821/13148454507

微博WB:http://weibo.com/u/3288975567?is_hot=1

git博文：http://al1020119.github.io/

github：https://github.com/al1020119
</code></pre>

<p><img src="http://al1020119.github.io/images/iCocosCoder.jpg" title="Caption" ></p>

<p><img src="http://al1020119.github.io/images/iCocosPublic.jpg" title="Caption" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[直播-美颜篇]]></title>
    <link href="http://al1020119.github.io/blog/2016/09/26/zhi-bo-mei-yan-pian/"/>
    <updated>2016-09-26T10:56:04+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/09/26/zhi-bo-mei-yan-pian</id>
    <content type="html"><![CDATA[<p>在看这篇之前，如果您还不了解直播原理，请查看这篇文章如何快速的开发一个完整的iOS直播app(原理篇)</p>

<p>开发一款直播app，美颜功能是很重要的，如果没有美颜功能，可能分分钟钟掉粉千万，本篇主要讲解直播中美颜功能的实现原理，并且实现美颜功能。</p>

<p>利用GPUImage处理直播过程中美颜的流程</p>

<pre><code>采集视频 =&gt; 获取每一帧图片 =&gt; 滤镜处理 =&gt; GPUImageView展示
</code></pre>

<p><img src="http://al1020119.github.io/images/zhibomeiyuanpian001.png" title="Caption" ></p>

<!--more-->


<p></p>

<h4>美颜基本概念</h4>

<pre><code>GPU：（Graphic Processor Unit图形处理单元）手机或者电脑用于图像处理和渲染的硬件

GPU工作原理：CPU指定显示控制器工作，显示控制器根据CPU的控制到指定的地方去取数据和指令， 目前的数据一般是从显存里取，如果显存里存不下，则从内存里取， 内存也放不下，则从硬盘里取，当然也不是内存放不下，而是为了节省内存的话，可以放在硬盘里，然后通过指令控制显示控制器去取。

OpenGL ES：（Open Graphics Library For Embedded(嵌入的) Systems 开源嵌入式系统图形处理框架），一套图形与硬件接口，用于把处理好的图片显示到屏幕上。

GPUImage:是一个基于OpenGL ES 2.0图像和视频处理的开源iOS框架，提供各种各样的图像处理滤镜，并且支持照相机和摄像机的实时滤镜，内置120多种滤镜效果，并且能够自定义图像滤镜。

滤镜处理的原理:就是把静态图片或者视频的每一帧进行图形变换再显示出来。它的本质就是像素点的坐标和颜色变化
</code></pre>

<h4>GPUImage处理画面原理</h4>

<pre><code>GPUImage采用链式方式来处理画面,通过addTarget:方法为链条添加每个环节的对象，处理完一个target,就会把上一个环节处理好的图像数据传递下一个target去处理，称为GPUImage处理链。
    比如：墨镜原理，从外界传来光线，会经过墨镜过滤，在传给我们的眼睛，就能感受到大白天也是乌黑一片，哈哈。
    一般的target可分为两类
        中间环节的target, 一般是各种filter, 是GPUImageFilter或者是子类.
        最终环节的target, GPUImageView：用于显示到屏幕上, 或者GPUImageMovieWriter：写成视频文件。
GPUImage处理主要分为3个环节
    source(视频、图片源) -&gt; filter（滤镜） -&gt; final target (处理后视频、图片)
    GPUImaged的Source:都继承GPUImageOutput的子类，作为GPUImage的数据源,就好比外界的光线，作为眼睛的输出源
        GPUImageVideoCamera：用于实时拍摄视频
        GPUImageStillCamera：用于实时拍摄照片
        GPUImagePicture：用于处理已经拍摄好的图片，比如png,jpg图片
        GPUImageMovie：用于处理已经拍摄好的视频,比如mp4文件
    GPUImage的filter:GPUimageFilter类或者子类，这个类继承自GPUImageOutput,并且遵守GPUImageInput协议，这样既能流进，又能流出，就好比我们的墨镜，光线通过墨镜的处理，最终进入我们眼睛
    GPUImage的final target:GPUImageView,GPUImageMovieWriter就好比我们眼睛，最终输入目标。
</code></pre>

<p><img src="http://al1020119.github.io/images/zhibomeiyuanpian002.png" title="Caption" ></p>

<h4>美颜原理</h4>

<pre><code>磨皮(GPUImageBilateralFilter)：本质就是让像素点模糊，可以使用高斯模糊，但是可能导致边缘会不清晰，用双边滤波(Bilateral Filter) ，有针对性的模糊像素点，能保证边缘不被模糊。
美白(GPUImageBrightnessFilter)：本质就是提高亮度。
</code></pre>

<h2>GPUImage实战</h2>

<h4>GPUImage原生美颜</h4>

<pre><code>步骤一：使用Cocoapods导入GPUImage
步骤二：创建视频源GPUImageVideoCamera
步骤三：创建最终目的源：GPUImageView
步骤四：创建滤镜组(GPUImageFilterGroup)，需要组合亮度(GPUImageBrightnessFilter)和双边滤波(GPUImageBilateralFilter)这两个滤镜达到美颜效果.
步骤五：设置滤镜组链
步骤六：设置GPUImage处理链，从数据源 =&gt; 滤镜 =&gt; 最终界面效果
步骤七：开始采集视频
</code></pre>

<blockquote><p>注意点：</p>

<p>SessionPreset最好使用AVCaptureSessionPresetHigh，会自动识别，如果用太高分辨率，当前设备不支持会直接报错</p>

<p>GPUImageVideoCamera必须要强引用，否则会被销毁，不能持续采集视频.</p>

<p>必须调用startCameraCapture，底层才会把采集到的视频源，渲染到GPUImageView中，就能显示了。</p>

<p>GPUImageBilateralFilter的distanceNormalizationFactor值越小，磨皮效果越好,distanceNormalizationFactor取值范围: 大于1。</p></blockquote>

<pre><code>- (void)viewDidLoad {
    [super viewDidLoad];

    // 创建视频源
    // SessionPreset:屏幕分辨率，AVCaptureSessionPresetHigh会自适应高分辨率
    // cameraPosition:摄像头方向
    GPUImageVideoCamera *videoCamera = [[GPUImageVideoCamera alloc] initWithSessionPreset:AVCaptureSessionPresetHigh cameraPosition:AVCaptureDevicePositionFront];
     videoCamera.outputImageOrientation = UIInterfaceOrientationPortrait;
    _videoCamera = videoCamera;

    // 创建最终预览View
    GPUImageView *captureVideoPreview = [[GPUImageView alloc] initWithFrame:self.view.bounds];
    [self.view insertSubview:captureVideoPreview atIndex:0];

    // 创建滤镜：磨皮，美白，组合滤镜
    GPUImageFilterGroup *groupFilter = [[GPUImageFilterGroup alloc] init];

    // 磨皮滤镜
    GPUImageBilateralFilter *bilateralFilter = [[GPUImageBilateralFilter alloc] init];
    [groupFilter addTarget:bilateralFilter];
    _bilateralFilter = bilateralFilter;

    // 美白滤镜
    GPUImageBrightnessFilter *brightnessFilter = [[GPUImageBrightnessFilter alloc] init];
    [groupFilter addTarget:brightnessFilter];
    _brightnessFilter = brightnessFilter;

    // 设置滤镜组链
    [bilateralFilter addTarget:brightnessFilter];
    [groupFilter setInitialFilters:@[bilateralFilter]];
    groupFilter.terminalFilter = brightnessFilter;

    // 设置GPUImage响应链，从数据源 =&gt; 滤镜 =&gt; 最终界面效果
    [videoCamera addTarget:groupFilter];
    [groupFilter addTarget:captureVideoPreview];

    // 必须调用startCameraCapture，底层才会把采集到的视频源，渲染到GPUImageView中，就能显示了。
    // 开始采集视频
    [videoCamera startCameraCapture];
}

- (IBAction)brightnessFilter:(UISlider *)sender {
    _brightnessFilter.brightness = sender.value;
}

- (IBAction)bilateralFilter:(UISlider *)sender {
    // 值越小，磨皮效果越好
    CGFloat maxValue = 10;
    [_bilateralFilter setDistanceNormalizationFactor:(maxValue - sender.value)];
}
</code></pre>

<h4>利用美颜滤镜实现</h4>

<pre><code>步骤一：使用Cocoapods导入GPUImage
步骤二：导入GPUImageBeautifyFilter文件夹
步骤三：创建视频源GPUImageVideoCamera
步骤四：创建最终目的源：GPUImageView
步骤五：创建最终美颜滤镜：GPUImageBeautifyFilter
步骤六：设置GPUImage处理链，从数据源 =&gt; 滤镜 =&gt; 最终界面效果
</code></pre>

<blockquote><p>注意：</p>

<p>切换美颜效果原理：移除之前所有处理链，重新设置处理链</p></blockquote>

<pre><code>- (void)viewDidLoad {
    [super viewDidLoad];
    // Do any additional setup after loading the view.
    // 创建视频源
    // SessionPreset:屏幕分辨率，AVCaptureSessionPresetHigh会自适应高分辨率
    // cameraPosition:摄像头方向
    GPUImageVideoCamera *videoCamera = [[GPUImageVideoCamera alloc] initWithSessionPreset:AVCaptureSessionPresetHigh cameraPosition:AVCaptureDevicePositionFront];
    videoCamera.outputImageOrientation = UIInterfaceOrientationPortrait;
    _videoCamera = videoCamera;

    // 创建最终预览View
    GPUImageView *captureVideoPreview = [[GPUImageView alloc] initWithFrame:self.view.bounds];
    [self.view insertSubview:captureVideoPreview atIndex:0];
    _captureVideoPreview = captureVideoPreview;

    // 设置处理链
    [_videoCamera addTarget:_captureVideoPreview];

    // 必须调用startCameraCapture，底层才会把采集到的视频源，渲染到GPUImageView中，就能显示了。
    // 开始采集视频
    [videoCamera startCameraCapture];

}

- (IBAction)openBeautifyFilter:(UISwitch *)sender {

    // 切换美颜效果原理：移除之前所有处理链，重新设置处理链
    if (sender.on) {

        // 移除之前所有处理链
        [_videoCamera removeAllTargets];

        // 创建美颜滤镜
        GPUImageBeautifyFilter *beautifyFilter = [[GPUImageBeautifyFilter alloc] init];

        // 设置GPUImage处理链，从数据源 =&gt; 滤镜 =&gt; 最终界面效果
        [_videoCamera addTarget:beautifyFilter];
        [beautifyFilter addTarget:_captureVideoPreview];

    } else {

        // 移除之前所有处理链
        [_videoCamera removeAllTargets];
        [_videoCamera addTarget:_captureVideoPreview];
    }


}
</code></pre>

<h4>GPUImage扩展</h4>

<p>  <a href="http://www.tuicool.com/articles/6bIbQbQ">GPUImage所有滤镜介绍</a></p>

<p>  <a href="http://www.jianshu.com/p/945fc806a9b4">美颜滤镜</a></p>

<p>  <a href="http://www.360doc.com/content/15/0907/10/19175681_497418716.shtml">美图秀秀滤镜大汇总</a></p>

<h2>源码下载</h2>

<p><a href="https://github.com/iThinkerYZ/GPUImgeDemo">源码</a></p>

<h2>结束语</h2>

<p>后续还会讲解GPUImage原理openGL ES，视频编码，推流，聊天室，礼物系统等更多功能，敬请关注！！！</p>

<hr />

<pre><code>Q Q：2211523682/790806573

微信：18370997821/13148454507

微博WB:http://weibo.com/u/3288975567?is_hot=1

git博文：http://al1020119.github.io/

github：https://github.com/al1020119
</code></pre>

<p><img src="http://al1020119.github.io/images/iCocosCoder.jpg" title="Caption" ></p>

<p><img src="http://al1020119.github.io/images/iCocosPublic.jpg" title="Caption" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[直播-采集篇]]></title>
    <link href="http://al1020119.github.io/blog/2016/09/25/zhi-bo-cai-ji-pian/"/>
    <updated>2016-09-25T16:46:26+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/09/25/zhi-bo-cai-ji-pian</id>
    <content type="html"><![CDATA[<p>前言</p>

<p>在看这篇之前，如果您还不了解直播原理，请查看这篇文章如何快速的开发一个完整的iOS直播app(原理篇)</p>

<p>开发一款直播app，首先需要采集主播的视频和音频，然后传入流媒体服务器，本篇主要讲解如何采集主播的视频和音频，当前可以切换前置后置摄像头和焦点光标,但是美颜功能还没做，可以看见素颜的你，后续还会有直播的其他功能文章陆续发布。</p>

<!--more-->


<p></p>

<p>基本知识介绍</p>

<pre><code>AVFoundation: 音视频数据采集需要用AVFoundation框架.

AVCaptureDevice：硬件设备，包括麦克风、摄像头，通过该对象可以设置物理设备的一些属性（例如相机聚焦、白平衡等）
AVCaptureDeviceInput：硬件输入对象，可以根据AVCaptureDevice创建对应的AVCaptureDeviceInput对象，用于管理硬件输入数据。
AVCaptureOutput：硬件输出对象，用于接收各类输出数据，通常使用对应的子类AVCaptureAudioDataOutput（声音数据输出对象）、AVCaptureVideoDataOutput（视频数据输出对象）
AVCaptionConnection:当把一个输入和输出添加到AVCaptureSession之后，AVCaptureSession就会在输入、输出设备之间建立连接,而且通过AVCaptureOutput可以获取这个连接对象。
AVCaptureVideoPreviewLayer:相机拍摄预览图层，能实时查看拍照或视频录制效果，创建该对象需要指定对应的AVCaptureSession对象，因为AVCaptureSession包含视频输入数据，有视频数据才能展示。
AVCaptureSession: 协调输入与输出之间传输数据
    系统作用：可以操作硬件设备
    工作原理：让App与系统之间产生一个捕获会话，相当于App与硬件设备有联系了， 我们只需要把硬件输入对象和输出对象添加到会话中，会话就会自动把硬件输入对象和输出产生连接，这样硬件输入与输出设备就能传输音视频数据。
    现实生活场景：租客（输入钱），中介（会话），房东（输出房），租客和房东都在中介登记，中介就会让租客与房东之间产生联系，以后租客就能直接和房东联系了。
</code></pre>

<p>捕获音视频步骤:官方文档</p>

<pre><code>1.创建AVCaptureSession对象
2.获取AVCaptureDevicel录像设备（摄像头），录音设备（麦克风），注意不具备输入数据功能,只是用来调节硬件设备的配置。
3.根据音频/视频硬件设备(AVCaptureDevice)创建音频/视频硬件输入数据对象(AVCaptureDeviceInput)，专门管理数据输入。
4.创建视频输出数据管理对象（AVCaptureVideoDataOutput），并且设置样品缓存代理(setSampleBufferDelegate)就可以通过它拿到采集到的视频数据
5.创建音频输出数据管理对象（AVCaptureAudioDataOutput），并且设置样品缓存代理(setSampleBufferDelegate)就可以通过它拿到采集到的音频数据
6.将数据输入对象AVCaptureDeviceInput、数据输出对象AVCaptureOutput添加到媒体会话管理对象AVCaptureSession中,就会自动让音频输入与输出和视频输入与输出产生连接.
7.创建视频预览图层AVCaptureVideoPreviewLayer并指定媒体会话，添加图层到显示容器layer中
8.启动AVCaptureSession，只有开启，才会开始输入到输出数据流传输。
</code></pre>

<p>// 捕获音视频</p>

<pre><code>- (void)setupCaputureVideo
{
    // 1.创建捕获会话,必须要强引用，否则会被释放
    AVCaptureSession *captureSession = [[AVCaptureSession alloc] init];
    _captureSession = captureSession;

    // 2.获取摄像头设备，默认是后置摄像头
    AVCaptureDevice *videoDevice = [self getVideoDevice:AVCaptureDevicePositionFront];

    // 3.获取声音设备
    AVCaptureDevice *audioDevice = [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeAudio];

    // 4.创建对应视频设备输入对象
    AVCaptureDeviceInput *videoDeviceInput = [AVCaptureDeviceInput deviceInputWithDevice:videoDevice error:nil];
    _currentVideoDeviceInput = videoDeviceInput;

    // 5.创建对应音频设备输入对象
    AVCaptureDeviceInput *audioDeviceInput = [AVCaptureDeviceInput deviceInputWithDevice:audioDevice error:nil];

    // 6.添加到会话中
    // 注意“最好要判断是否能添加输入，会话不能添加空的
    // 6.1 添加视频
    if ([captureSession canAddInput:videoDeviceInput]) {
        [captureSession addInput:videoDeviceInput];
    }
    // 6.2 添加音频
    if ([captureSession canAddInput:audioDeviceInput]) {
        [captureSession addInput:audioDeviceInput];
    }

    // 7.获取视频数据输出设备
    AVCaptureVideoDataOutput *videoOutput = [[AVCaptureVideoDataOutput alloc] init];
    // 7.1 设置代理，捕获视频样品数据
    // 注意：队列必须是串行队列，才能获取到数据，而且不能为空
    dispatch_queue_t videoQueue = dispatch_queue_create("Video Capture Queue", DISPATCH_QUEUE_SERIAL);
    [videoOutput setSampleBufferDelegate:self queue:videoQueue];
    if ([captureSession canAddOutput:videoOutput]) {
        [captureSession addOutput:videoOutput];
    }

    // 8.获取音频数据输出设备
    AVCaptureAudioDataOutput *audioOutput = [[AVCaptureAudioDataOutput alloc] init];
    // 8.2 设置代理，捕获视频样品数据
    // 注意：队列必须是串行队列，才能获取到数据，而且不能为空
    dispatch_queue_t audioQueue = dispatch_queue_create("Audio Capture Queue", DISPATCH_QUEUE_SERIAL);
    [audioOutput setSampleBufferDelegate:self queue:audioQueue];
    if ([captureSession canAddOutput:audioOutput]) {
        [captureSession addOutput:audioOutput];
    }

    // 9.获取视频输入与输出连接，用于分辨音视频数据
    _videoConnection = [videoOutput connectionWithMediaType:AVMediaTypeVideo];

    // 10.添加视频预览图层
    AVCaptureVideoPreviewLayer *previedLayer = [AVCaptureVideoPreviewLayer layerWithSession:captureSession];
    previedLayer.frame = [UIScreen mainScreen].bounds;
    [self.view.layer insertSublayer:previedLayer atIndex:0];
    _previedLayer = previedLayer;

    // 11.启动会话
    [captureSession startRunning];
}
</code></pre>

<p>// 指定摄像头方向获取摄像头</p>

<pre><code>- (AVCaptureDevice *)getVideoDevice:(AVCaptureDevicePosition)position
{
    NSArray *devices = [AVCaptureDevice devicesWithMediaType:AVMediaTypeVideo];
    for (AVCaptureDevice *device in devices) {
        if (device.position == position) {
            return device;
        }
    }
    return nil;
}

#pragma mark - AVCaptureVideoDataOutputSampleBufferDelegate

// 获取输入设备数据，有可能是音频有可能是视频

- (void)captureOutput:(AVCaptureOutput *)captureOutput didOutputSampleBuffer:   (CMSampleBufferRef)sampleBuffer fromConnection:(AVCaptureConnection *)connection
{
    if (_videoConnection == connection) {
        NSLog(@"采集到视频数据");
    } else {
        NSLog(@"采集到音频数据");
    }
}
</code></pre>

<p>视频采集额外功能一（切换摄像头）</p>

<pre><code>切换摄像头步骤
    1.获取当前视频设备输入对象
    2.判断当前视频设备是前置还是后置
    3.确定切换摄像头的方向
    4.根据摄像头方向获取对应的摄像头设备
    5.创建对应的摄像头输入对象
    6.从会话中移除之前的视频输入对象
    7.添加新的视频输入对象到会话中
</code></pre>

<p>// 切换摄像头</p>

<pre><code>- (IBAction)toggleCapture:(id)sender {

    // 获取当前设备方向
    AVCaptureDevicePosition curPosition = _currentVideoDeviceInput.device.position;

    // 获取需要改变的方向
    AVCaptureDevicePosition togglePosition = curPosition == AVCaptureDevicePositionFront?AVCaptureDevicePositionBack:AVCaptureDevicePositionFront;

    // 获取改变的摄像头设备
    AVCaptureDevice *toggleDevice = [self getVideoDevice:togglePosition];

    // 获取改变的摄像头输入设备
    AVCaptureDeviceInput *toggleDeviceInput = [AVCaptureDeviceInput deviceInputWithDevice:toggleDevice error:nil];

    // 移除之前摄像头输入设备
    [_captureSession removeInput:_currentVideoDeviceInput];

    // 添加新的摄像头输入设备
    [_captureSession addInput:toggleDeviceInput];

    // 记录当前摄像头输入设备
    _currentVideoDeviceInput = toggleDeviceInput;

}
</code></pre>

<p>视频采集额外功能二（聚焦光标）</p>

<pre><code>聚焦光标步骤
    1.监听屏幕的点击
    2.获取点击的点位置，转换为摄像头上的点，必须通过视频预览图层（AVCaptureVideoPreviewLayer）转
    3.设置聚焦光标图片的位置，并做动画
    4.设置摄像头设备聚焦模式和曝光模式(注意：这里设置一定要锁定配置lockForConfiguration,否则报错)
</code></pre>

<p>// 点击屏幕，出现聚焦视图</p>

<pre><code>- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event
{
   // 获取点击位置
   UITouch *touch = [touches anyObject];
   CGPoint point = [touch locationInView:self.view];

   // 把当前位置转换为摄像头点上的位置
   CGPoint cameraPoint = [_previedLayer captureDevicePointOfInterestForPoint:point];

   // 设置聚焦点光标位置
   [self setFocusCursorWithPoint:point];

   // 设置聚焦
   [self focusWithMode:AVCaptureFocusModeAutoFocus exposureMode:AVCaptureExposureModeAutoExpose atPoint:cameraPoint];
}
</code></pre>

<p>/<em>*
 *  设置聚焦光标位置
 *
 *  @param point 光标位置
 </em>/</p>

<pre><code>-(void)setFocusCursorWithPoint:(CGPoint)point{
    self.focusCursorImageView.center=point;
    self.focusCursorImageView.transform=CGAffineTransformMakeScale(1.5, 1.5);
    self.focusCursorImageView.alpha=1.0;
    [UIView animateWithDuration:1.0 animations:^{
        self.focusCursorImageView.transform=CGAffineTransformIdentity;
    } completion:^(BOOL finished) {
        self.focusCursorImageView.alpha=0;

    }];
}
</code></pre>

<p>/<em>*
 *  设置聚焦
 </em>/</p>

<pre><code>-(void)focusWithMode:(AVCaptureFocusMode)focusMode exposureMode:(AVCaptureExposureMode)exposureMode atPoint:(CGPoint)point{

    AVCaptureDevice *captureDevice = _currentVideoDeviceInput.device;
    // 锁定配置
    [captureDevice lockForConfiguration:nil];

    // 设置聚焦
    if ([captureDevice isFocusModeSupported:AVCaptureFocusModeAutoFocus]) {
        [captureDevice setFocusMode:AVCaptureFocusModeAutoFocus];
    }
    if ([captureDevice isFocusPointOfInterestSupported]) {
        [captureDevice setFocusPointOfInterest:point];
    }

    // 设置曝光
    if ([captureDevice isExposureModeSupported:AVCaptureExposureModeAutoExpose]) {
        [captureDevice setExposureMode:AVCaptureExposureModeAutoExpose];
    }
    if ([captureDevice isExposurePointOfInterestSupported]) {
        [captureDevice setExposurePointOfInterest:point];
    }

    // 解锁配置
    [captureDevice unlockForConfiguration];
}
</code></pre>

<h4>结束语</h4>

<p>后续还会更新更多有关直播的资料，希望做到教会每一个朋友从零开始做一款直播app，并且Demo也会慢慢完善.
Demo点击下载</p>

<pre><code>由于FFMPEG库比较大，大概100M。
本来想自己上传所有代码了，上传了1个小时，还没成功，就放弃了。
提供另外一种方案，需要你们自己导入IJKPlayer库
具体步骤：
下载Demo后，打开YZLiveApp.xcworkspace问题
</code></pre>

<p><img src="http://al1020119.github.io/images/zhibocaiji001.png" title="Caption" ></p>

<p>打开YZLiveApp.xcworkspace问题</p>

<pre><code>pod install就能解决
</code></pre>

<p><img src="http://al1020119.github.io/images/zhibocaiji002.png" title="Caption" ></p>

<pre><code>下载jkplayer库，点击下载
把jkplayer直接拖入到与Classes同一级目录下，直接运行程序，就能成功了
</code></pre>

<p><img src="http://al1020119.github.io/images/zhibocaiji003.png" title="Caption" ></p>

<pre><code>注意不需要打开工程，把jkplayer拖入到工程中，而是直接把jkplayer库拷贝到与Classes同一级目录下就可以了。
错误示范:不要向下面这样操作
</code></pre>

<p><img src="http://al1020119.github.io/images/zhibocaiji004.png" title="Caption" ></p>

<hr />

<pre><code>Q Q：2211523682/790806573

微信：18370997821/13148454507

微博WB:http://weibo.com/u/3288975567?is_hot=1

git博文：http://al1020119.github.io/

github：https://github.com/al1020119
</code></pre>

<p><img src="http://al1020119.github.io/images/iCocosCoder.jpg" title="Caption" ></p>

<p><img src="http://al1020119.github.io/images/iCocosPublic.jpg" title="Caption" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[直播-实战篇]]></title>
    <link href="http://al1020119.github.io/blog/2016/09/20/zhi-bo-shi-zhan-pian/"/>
    <updated>2016-09-20T14:42:57+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/09/20/zhi-bo-shi-zhan-pian</id>
    <content type="html"><![CDATA[<p>前言</p>

<p>在看这篇之前，如果您还不了解直播原理，请查看上篇文章如何快速的开发一个完整的iOS直播app(原理篇)</p>

<p>开发一款直播app，集成ijkplayer成功后，就算完成直播功能一半的工程了，只要有拉流url，就能播放直播啦</p>

<p>本篇主要讲解的是直播app中，需要用到的一个很重要的开源框架ijkplayer，然后集成这个框架可能对大多数初学者还是比较有难度的，所以本篇主要教你解决集成【ijkplayer】遇见的各种坑。</p>

<!--more-->


<p></p>

<p>很多文章，可能讲解的是如何做，我比较注重讲解为什么这样做,大家有什么不明白，还可以多多提出来。</p>

<p>效果</p>

<p><img src="http://al1020119.github.io/images/zhiboshizhan001.gif" title="Caption" ></p>

<h3>一、基本知识</h3>

<p>README.md文件：框架的描述文件，描述这个框架怎么使用</p>

<p>编译语言:程序在被执行之前，需要一个专门的编译过程，把程序编译成为机器语言的文件，运行时不需要翻译，所以编译型语言的程序执行效率高，比如OC,C,C++</p>

<p>解释性语言:解释性语言的程序不需要编译，在运行程序的时候才翻译，每个语句都是执行的时候才翻译。这样解释性语言每执行一次就需要逐行翻译一次，效率比较低</p>

<p>解释性语言执行和编译语言执行的区别：</p>

<pre><code>解释性语言一行一行的解析，如果有错误，就不会执行，直接执行下一行。
编译语言，只要有错，就不能编译，一行都不能执行。
</code></pre>

<p>脚本语言:属于解析语言，必须通过解释器解析，将其一条条的翻译成机器可识别的指令，并按程序顺序执行。</p>

<pre><code>python：脚本语言，适合网络应用程序的开发，有利于开发效率，现在显得越来越强大
PHP：服务器端脚本语言，适合做动态网站
JS：作为客户端的脚本语言，在浏览中解释执行，
shell：操作系统脚本语言，一般指Unix/Linux中使用的命令行
编译语言，执行文件是二进制。脚本语言是解释执行的，执行文件是文本
</code></pre>

<p>shell解释器:shell是一个命令行解释器，相当于windows的cmd,处于内核和用户之间，负责把用户的指令传递给内核并且把执行结果回显给用户.</p>

<pre><code>默认Unix都有shell,OS基于Unix,因此OS自带shell。
</code></pre>

<p>bash: bash是一种shell解释器版本，shell有很多种版本，就像人，也分不同国家的人。</p>

<pre><code>牛程序员看到不爽的Shell解释器，就会自己重新写一套，慢慢形成了一些标准，常用的Shell解释器有这么几种，sh、bash、csh等
</code></pre>

<p>shell:通常我们说的shell,指的是shell脚本语言，而不是shell解释器。</p>

<pre><code>在编写shell时，第一行一定要指明系统需要哪种shell解释器解释你的shell脚本，如：#! /bin/bash，使用bash解析脚本语言
什么时候使用shell命令，比如有些系统命令经常需要用到，可以把命令封装到一个脚本文件，以后就不用再敲一遍了，直接执行脚本语言。
比如ijkplayer,就用脚本文件下载ffmpeg,因为下载ffmpeg需要执行很多命令，全部封装到脚本文件中。
在导入一些第三方框架的时候，经常需要用到一些命令，所以一般都会封装到一个脚本文件中，以后只要执行脚本，就会自动执行集成第三方框架的命令。
</code></pre>

<p>sh:sheel脚本文件后缀名</p>

<h3>二、下载ijkPlayer</h3>

<pre><code>去到B站得github主页，找到ijkplayer项目，下载源码 ijkplayer下载地址
打开Demo，查看用法，一般学习第三方库，都是先查看Demo
</code></pre>

<p><img src="http://al1020119.github.io/images/zhiboshizhan002.png" title="Caption" ></p>

<h3>三、编译ijkPlayer的步骤</h3>

<p>1、找到ijkPlayerMediaDemo并运行</p>

<pre><code>提示'libavformat/avformat.h' file not found
</code></pre>

<p><img src="http://al1020119.github.io/images/zhiboshizhan003.png" title="Caption" ></p>

<p>原因：因为libavformat是ffmpeg中的库，而ijkplayer是基于ffmpeg这个库的，因此需要导入ffmpeg</p>

<p>解决：查看ijkplayer的README.md，一般都会有说明。</p>

<p><img src="http://al1020119.github.io/images/zhiboshizhan004.png" title="Caption" ></p>

<p>init-ios.sh脚本的作用：下载ffmpeg源码</p>

<pre><code>想了解脚本具体怎么做的，可以查看之前写的文章带你走进脚本世界，ijkplayer之【init-ios.sh】脚本分析，全面剖析了init-ios.sh这个脚本做了哪些事情。
</code></pre>

<p>如何执行init-ios.sh脚本文件</p>

<pre><code>步骤一：找到init-ios.sh脚本文件
</code></pre>

<p><img src="http://al1020119.github.io/images/zhiboshizhan005.png" title="Caption" ></p>

<pre><code>步骤二：打开终端，cd进入到ijkplayer-master的目录中
</code></pre>

<p><img src="http://al1020119.github.io/images/zhiboshizhan006.png" title="Caption" ></p>

<pre><code>注意是 cd 这个文件夹
</code></pre>

<p><img src="http://al1020119.github.io/images/zhiboshizhan007.png" title="Caption" ></p>

<pre><code>步骤三：输入./init-ios.sh，就会执行当前脚本了。
</code></pre>

<p><img src="http://al1020119.github.io/images/zhiboshizhan008.png" title="Caption" ></p>

<pre><code>执行完脚本后，就会发现ijkplayer中有ffmpeg了
</code></pre>

<p><img src="http://al1020119.github.io/images/zhiboshizhan009.png" title="Caption" >
2、下载好ffmpeg源码后，再次运行Demo</p>

<pre><code>发现还是报'libavformat/avformat.h' file not found错误
原因:执行init-ios.sh，仅仅是下载源码，但是源码并没有参与编译，需要把源码编译成.a文件
    Demo依赖于IJKMediaPlayer库
</code></pre>

<p><img src="http://al1020119.github.io/images/zhiboshizhan010.png" title="Caption" ></p>

<pre><code>打开 IJKMediaPlayer库，查看下源码
</code></pre>

<p><img src="http://al1020119.github.io/images/zhiboshizhan011.png" title="Caption" ></p>

<pre><code>打开 IJKMediaPlayer库
</code></pre>

<p><img src="http://al1020119.github.io/images/zhiboshizhan012.png" title="Caption" ></p>

<pre><code>右击，发现FFMPEG中的库都是红的，表示不存在
</code></pre>

<p><img src="http://al1020119.github.io/images/zhiboshizhan013.png" title="Caption" ></p>

<pre><code>解决:查看ijkplayer的README.md
</code></pre>

<p><img src="http://al1020119.github.io/images/zhiboshizhan014.png" title="Caption" >
编译ffmpeg库</p>

<pre><code>步骤一：进入到脚本文件的目录下
</code></pre>

<p><img src="http://al1020119.github.io/images/zhiboshizhan015.png" title="Caption" ></p>

<pre><code>步骤二：执行./compile-ffmpeg.sh clean
    步骤二功能：删除一些文件和文件夹，为编译ffmpeg.sh做准备，在编译ffmpeg.sh的时候，会自动创建刚刚删除的那些文件，为避免文件名冲突，因此在编译ffmpeg.sh之前先删除等会会自动创建的文件夹或者文件
</code></pre>

<p><img src="http://al1020119.github.io/images/zhiboshizhan016.png" title="Caption" ></p>

<pre><code>步骤三：执行./compile-ffmpeg.sh all,真正的编译各个平台的ffmpeg库，并生成所以平台的通用库.
</code></pre>

<p><img src="http://al1020119.github.io/images/zhiboshizhan017.png" title="Caption" ></p>

<p>执行./compile-ffmpeg.sh all
执行compile-ffmpeg.sh all前</p>

<p><img src="http://al1020119.github.io/images/zhiboshizhan018.png" title="Caption" >
执行compile-ffmpeg.sh all后</p>

<p><img src="http://al1020119.github.io/images/zhiboshizhan019.png" title="Caption" >
3.再次运行Demo,就能成功了,因为IJKMediaPlayer库获取到ffmpeg库了</p>

<pre><code>编译完ffmpeg后，IJKMediaPlayer库中显示
</code></pre>

<p><img src="http://al1020119.github.io/images/zhiboshizhan020.png" title="Caption" ></p>

<pre><code>cmd+r,Demo运行成功
</code></pre>

<p><img src="http://al1020119.github.io/images/zhiboshizhan021.png" title="Caption" ></p>

<h3>四、如何集成到ijkplayer到自己的项目中</h3>

<pre><code>注意：ijkplayer的README中的方法比较麻烦，不方便携带，不推荐。
</code></pre>

<p><img src="http://al1020119.github.io/images/zhiboshizhan022.png" title="Caption" >
1.推荐自己把IJKMediaPlayer打包成静态库,在导入到自己的项目中。</p>

<pre><code>如何打包，请参考，iOS中集成ijkplayer视频直播框架，写的非常不错，就不一一详细介绍了,但是只有发布版本的库。
我自己打包了ijkplayer两个版本库，分别用于调试和发布(DEBUG和Release),点击下载
由于文件太大上传不了GitHUb,就上传到百度云了
</code></pre>

<p>2.直接把ijkplayer库拖入到自己的工程中，</p>

<pre><code>调试的话，拖入调试版本的ijkplayer库，发布的话，拖入发布版本的ijkplayer库
</code></pre>

<p><img src="http://al1020119.github.io/images/zhiboshizhan023.png" title="Caption" >
3.导入ijkplayer依赖的库，具体可以查看ijkplayer的README</p>

<p><img src="http://al1020119.github.io/images/zhiboshizhan024.png" title="Caption" >
<img src="http://al1020119.github.io/images/zhiboshizhan025.png" title="Caption" ></p>

<h3>五、使用ijkplayer直播</h3>

<p>1.ijkplayer用法简介</p>

<pre><code>ijkplayer用法比较简单，其实只要有直播地址，就能直播了
注意：最好真机测试，模拟器测试比较卡,不流畅，真机就没有问题了
</code></pre>

<p>2.抓取数据</p>

<pre><code>抓了很多直播app的数据，发现映客主播的质量是最高的。
映客主播url:http://116.211.167.106/api/live/aggregation?uid=133825214&amp;interest=1
    uid=账号ID，这里是我的账号ID
    interest=兴趣 ，1表示只查看女生，哈哈
    上下拉刷新的接口没抓到，就一下加载200条数据，哈哈

- (void)loadData
{
    // 映客数据url
    NSString *urlStr = @"http://116.211.167.106/api/live/aggregation?uid=133825214&amp;interest=1";

    // 请求数据
    AFHTTPSessionManager *mgr = [AFHTTPSessionManager manager];
    mgr.responseSerializer = [AFJSONResponseSerializer serializer];
    mgr.responseSerializer.acceptableContentTypes = [NSSet setWithObjects:@"text/plain", nil];
    [mgr GET:urlStr parameters:nil progress:nil success:^(NSURLSessionDataTask * _Nonnull task, NSDictionary * _Nullable responseObject) {

        _lives = [YZLiveItem mj_objectArrayWithKeyValuesArray:responseObject[@"lives"]];

        [_tableView reloadData];

    } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {

        NSLog(@"%@",error);

    }];
}
</code></pre>

<p>3.获取拉流url,直播</p>

<p>IJKFFMoviePlayerController：用来做直播的类</p>

<pre><code>- (void)viewDidLoad {
    [super viewDidLoad];

    self.view.backgroundColor = [UIColor whiteColor];

    // 设置直播占位图片
    NSURL *imageUrl = [NSURL URLWithString:[NSString stringWithFormat:@"http://img.meelive.cn/%@",_live.creator.portrait]];
    [self.imageView sd_setImageWithURL:imageUrl placeholderImage:nil];

    // 拉流地址
    NSURL *url = [NSURL URLWithString:_live.stream_addr];

    // 创建IJKFFMoviePlayerController：专门用来直播，传入拉流地址就好了
    IJKFFMoviePlayerController *playerVc = [[IJKFFMoviePlayerController alloc] initWithContentURL:url withOptions:nil];

    // 准备播放
    [playerVc prepareToPlay];

    // 强引用，反正被销毁
    _player = playerVc;

    playerVc.view.frame = [UIScreen mainScreen].bounds;

    [self.view insertSubview:playerVc.view atIndex:1];

}
</code></pre>

<p>4.结束播放</p>

<pre><code>界面不播放，一定要记得结束播放，否则会报内存溢出
</code></pre>

<p><img src="http://al1020119.github.io/images/zhiboshizhan026.png" title="Caption" ></p>

<pre><code>- (void)viewWillDisappear:(BOOL)animated
{
    [super viewWillDisappear:animated];

    // 界面消失，一定要记得停止播放
    [_player pause];
    [_player stop];
}
</code></pre>

<p>结束语</p>

<p>后续还会更新更多有关直播的资料，希望做到教会每一个朋友从零开始做一款直播app，并且Demo也会慢慢完善.
Demo点击下载</p>

<pre><code>由于FFMPEG库比较大，大概100M。
本来想自己上传所有代码了，上传了1个小时，还没成功，就放弃了。
提供另外一种方案，需要你们自己导入IJKPlayer库
具体步骤：
下载Demo后，打开YZLiveApp.xcworkspace问题
</code></pre>

<p>打开YZLiveApp.xcworkspace问题</p>

<p><img src="http://al1020119.github.io/images/zhiboshizhan027.png" title="Caption" ></p>

<pre><code>pod install就能解决
</code></pre>

<p><img src="http://al1020119.github.io/images/zhiboshizhan028.png" title="Caption" ></p>

<pre><code>下载jkplayer库，点击下载
把jkplayer直接拖入到与Classes同一级目录下，直接运行程序，就能成功了
</code></pre>

<p><img src="http://al1020119.github.io/images/zhiboshizhan029.png" title="Caption" ></p>

<pre><code>注意不需要打开工程，把jkplayer拖入到工程中，而是直接把jkplayer库拷贝到与Classes同一级目录下就可以了。
错误示范:不要向下面这样操作
</code></pre>

<p><img src="http://al1020119.github.io/images/zhiboshizhan030.png" title="Caption" ></p>

<hr />

<pre><code>Q Q：2211523682/790806573

微信：18370997821/13148454507

微博WB:http://weibo.com/u/3288975567?is_hot=1

git博文：http://al1020119.github.io/

github：https://github.com/al1020119
</code></pre>

<p><img src="http://al1020119.github.io/images/iCocosCoder.jpg" title="Caption" ></p>

<p><img src="http://al1020119.github.io/images/iCocosPublic.jpg" title="Caption" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[直播-原理篇]]></title>
    <link href="http://al1020119.github.io/blog/2016/09/15/zhi-bo-yuan-li-pian/"/>
    <updated>2016-09-15T14:42:49+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/09/15/zhi-bo-yuan-li-pian</id>
    <content type="html"><![CDATA[<p>前言</p>

<p>本系列文章引自一个朋友（讲师）的精华：<a href="http://www.jianshu.com/users/b09c3959ab3b/latest_articles">袁峥Seemygo</a></p>

<h2>一、个人见解（直播难与易）</h2>

<p>直播难：个人认为要想把直播从零开始做出来，绝对是牛逼中的牛逼，大牛中的大牛，因为直播中运用到的技术难点非常之多，视频/音频处理，图形处理，视频/音频压缩，CDN分发，即时通讯等技术，每一个技术都够你学几年的。</p>

<!--more-->


<p></p>

<p>直播易：已经有各个领域的大牛，封装好了许多牛逼的框架，我们只需要用别人写好的框架，就能快速的搭建一个直播app，也就是传说中的站在大牛肩膀上编程。</p>

<h2>二、了解直播</h2>

<p>热门直播产品</p>

<p>映客，斗鱼，熊猫，虎牙，花椒等等
直播效果图</p>

<p><img src="http://al1020119.github.io/images/zhiboyuanli001.png" title="Caption" >
1.一个完整直播app功能(来自落影loyinglin分享)</p>

<pre><code>1、聊天
    私聊、聊天室、点亮、推送、黑名单等;

2、礼物
    普通礼物、豪华礼物、红包、排行榜、第三方充值、内购、礼物动态更新、提现等；

3、直播列表
    关注、热门、最新、分类直播用户列表等；

4、自己直播
    录制、推流、解码、播放、美颜、心跳、后台切换、主播对管理员操作、管理员对用户等；

5、房间逻辑
    创建房间、进入房间、退出房间、关闭房间、切换房间、房间管理员设置、房间用户列表等；

6、用户逻辑
    普通登陆、第三方登陆、注册、搜索、修改个人信息、关注列表、粉丝列表、忘记密码、查看个人信息、收入榜、关注和取关、检索等；

7、观看直播
    聊天信息、滚屏弹幕、礼物显示、加载界面等；

8、统计
    APP业务统计、第三方统计等；

9、超管
    禁播、隐藏、审核等；
</code></pre>

<p>2.一个完整直播app原理</p>

<p>直播原理：把主播录制的视频，推送到服务器，在由服务器分发给观众观看。</p>

<p>直播环节：推流端（采集、美颜处理、编码、推流）、服务端处理（转码、录制、截图、鉴黄）、播放器（拉流、解码、渲染）、互动系统（聊天室、礼物系统、赞）
3.一个完整直播app实现流程</p>

<p>1.采集、2.滤镜处理、3.编码、4.推流、5.CDN分发、6.拉流、7.解码、8.播放、9.聊天互动</p>

<p><img src="http://al1020119.github.io/images/zhiboyuanli002.png" title="Caption" >
4.一个完整直播app架构</p>

<p><img src="http://al1020119.github.io/images/zhiboyuanli003.png" title="Caption" >
5.一个完整直播app技术点</p>

<p><img src="http://al1020119.github.io/images/zhiboyuanli004.png" title="Caption" ></p>

<h2>三、了解流媒体（直播需要用到流媒体）</h2>

<pre><code>流媒体开发:网络层(socket或st)负责传输，协议层(rtmp或hls)负责网络打包，封装层(flv、ts)负责编解码数据的封装，编码层(h.264和aac)负责图像，音频压缩。
帧:每帧代表一幅静止的图像
GOP:（Group of Pictures）画面组，一个GOP就是一组连续的画面，每个画面都是一帧，一个GOP就是很多帧的集合
    直播的数据，其实是一组图片，包括I帧、P帧、B帧，当用户第一次观看的时候，会寻找I帧，而播放器会到服务器寻找到最近的I帧反馈给用户。因此，GOP Cache增加了端到端延迟，因为它必须要拿到最近的I帧
    GOP Cache的长度越长，画面质量越好
码率：图片进行压缩后每秒显示的数据量。
帧率：每秒显示的图片数。影响画面流畅度，与画面流畅度成正比：帧率越大，画面越流畅；帧率越小，画面越有跳动感。
    由于人类眼睛的特殊生理结构，如果所看画面之帧率高于16的时候，就会认为是连贯的，此现象称之为视觉暂留。并且当帧速达到一定数值后，再增长的话，人眼也不容易察觉到有明显的流畅度提升了。
分辨率：(矩形)图片的长度和宽度，即图片的尺寸
压缩前的每秒数据量:帧率X分辨率(单位应该是若干个字节)
压缩比:压缩前的每秒数据量/码率 （对于同一个视频源并采用同一种视频编码算法，则：压缩比越高，画面质量越差。）　

视频文件格式：文件的后缀，比如.wmv,.mov,.mp4,.mp3,.avi,
    主要用处，根据文件格式，系统会自动判断用什么软件打开,
    注意: 随意修改文件格式，对文件的本身不会造成太大的影响，比如把avi改成mp4,文件还是avi.

视频封装格式：一种储存视频信息的容器，流式封装可以有TS、FLV等，索引式的封装有MP4,MOV,AVI等，
    主要作用：一个视频文件往往会包含图像和音频，还有一些配置信息(如图像和音频的关联，如何解码它们等)：这些内容需要按照一定的规则组织、封装起来.
    注意：会发现封装格式跟文件格式一样，因为一般视频文件格式的后缀名即采用相应的视频封装格式的名称,所以视频文件格式就是视频封装格式。
视频封装格式和视频压缩编码标准：就好像项目工程和编程语言，封装格式就是一个项目的工程，视频编码方式就是编程语言，一个项目工程可以用不同语言开发。
</code></pre>

<h2>四、直播基础知识介绍：</h2>

<h4>1.采集视频、音频</h4>

<ul>
<li><p>1.1 采集视频、音频编码框架 *</p>

<p>  AVFoundation:AVFoundation是用来播放和创建实时的视听媒体数据的框架，同时提供Objective-C接口来操作这些视听数据，比如编辑，旋转，重编码</p></li>
<li><p>1.2 视频、音频硬件设备 *</p>

<p>  CCD:图像传感器： 用于图像采集和处理的过程，把图像转换成电信号。
  拾音器:声音传感器： 用于声音采集和处理的过程，把声音转换成电信号。
  音频采样数据:一般都是PCM格式
  视频采样数据: 一般都是YUV,或RGB格式，采集到的原始音视频的体积是非常大的，需要经过压缩技术处理来提高传输效率</p></li>
</ul>


<h4>2.视频处理（美颜，水印）</h4>

<pre><code>视频处理原理:因为视频最终也是通过GPU，一帧一帧渲染到屏幕上的，所以我们可以利用OpenGL ES，对视频帧进行各种加工，从而视频各种不同的效果，就好像一个水龙头流出的水，经过若干节管道，然后流向不同的目标
    现在的各种美颜和视频添加特效的app都是利用GPUImage这个框架实现的,.
</code></pre>

<ul>
<li><p>视频处理框架 *</p>

<p>  GPUImage : GPUImage是一个基于OpenGL ES的一个强大的图像/视频处理框架,封装好了各种滤镜同时也可以编写自定义的滤镜,其本身内置了多达120多种常见的滤镜效果。
  OpenGL:OpenGL（全写Open Graphics Library）是个定义了一个跨编程语言、跨平台的编程接口的规格，它用于三维图象（二维的亦可）。OpenGL是个专业的图形程序接口，是一个功能强大，调用方便的底层图形库。
  OpenGL ES:OpenGL ES (OpenGL for Embedded Systems) 是 OpenGL三维图形 API 的子集，针对手机、PDA和游戏主机等嵌入式设备而设计。</p></li>
</ul>


<h4>3.视频编码解码</h4>

<ul>
<li><p>3.1 视频编码框架 *</p>

<p>  FFmpeg:是一个跨平台的开源视频框架,能实现如视频编码,解码,转码,串流,播放等丰富的功能。其支持的视频格式以及播放协议非常丰富,几乎包含了所有音视频编解码、封装格式以及播放协议。
      -Libswresample:可以对音频进行重采样,rematrixing 以及转换采样格式等操 作。
      -Libavcodec:提供了一个通用的编解码框架,包含了许多视频,音频,字幕流 等编码/解码器。
      -Libavformat:用于对视频进行封装/解封装。
      -Libavutil:包含一些共用的函数,如随机数生成,数据结构,数学运算等。
      -Libpostproc:用于进行视频的一些后期处理。
      -Libswscale:用于视频图像缩放,颜色空间转换等。
      -Libavfilter:提供滤镜功能。
  X264:把视频原数据YUV编码压缩成H.264格式
  VideoToolbox:苹果自带的视频硬解码和硬编码API，但是在iOS8之后才开放。
  AudioToolbox:苹果自带的音频硬解码和硬编码API</p></li>
<li><p>3.2 视频编码技术 *</p>

<p>  视频压缩编码标准：对视频进行压缩(视频编码)或者解压缩（视频解码）的编码技术,比如MPEG，H.264,这些视频编码技术是压缩编码视频的</p>

<pre><code>  主要作用:是将视频像素数据压缩成为视频码流，从而降低视频的数据量。如果视频不经过压缩编码的话，体积通常是非常大的，一部电影可能就要上百G的空间。
  注意:最影响视频质量的是其视频编码数据和音频编码数据，跟封装格式没有多大关系
</code></pre>

<p>  MPEG:一种视频压缩方式，它采用了帧间压缩，仅存储连续帧之间有差别的地方 ，从而达到较大的压缩比</p></li>
</ul>


<p> H.264/AVC:一种视频压缩方式,采用事先预测和与MPEG中的P-B帧一样的帧预测方法压缩，它可以根据需要产生适合网络情况传输的视频流,还有更高的压缩比，有更好的图象质量</p>

<pre><code>    注意1:如果是从单个画面清晰度比较，MPEG4有优势；从动作连贯性上的清晰度，H.264有优势
    注意2:由于264的算法更加复杂，程序实现烦琐，运行它需要更多的处理器和内存资源。因此，运行264对系统要求是比较高的。
    注意3:由于264的实现更加灵活，它把一些实现留给了厂商自己去实现，虽然这样给实现带来了很多好处，但是不同产品之间互通成了很大的问题，造成了通过A公司的编码器编出的数据，必须通过A公司的解码器去解这样尴尬的事情
</code></pre>

<p>H.265/HEVC:一种视频压缩方式,基于H.264，保留原来的某些技术，同时对一些相关的技术加以改进，以改善码流、编码质量、延时和算法复杂度之间的关系，达到最优化设置。</p>

<pre><code>    H.265 是一种更为高效的编码标准，能够在同等画质效果下将内容的体积压缩得更小，传输时更快更省带宽
    I帧:(关键帧)保留一副完整的画面，解码时只需要本帧数据就可以完成（因为包含完整画面）
P帧:(差别帧)保留这一帧跟之前帧的差别，解码时需要用之前缓存的画面叠加上本帧定义的差别，生成最终画面。（P帧没有完整画面数据，只有与前一帧的画面差别的数据）
B帧:(双向差别帧)保留的是本帧与前后帧的差别，解码B帧，不仅要取得之前的缓存画面，还要解码之后的画面，通过前后画面的与本帧数据的叠加取得最终的画面。B帧压缩率高，但是解码时CPU会比较累
帧内（Intraframe）压缩:当压缩一帧图像时，仅考虑本帧的数据而不考虑相邻帧之间的冗余信息,帧内一般采用有损压缩算法
帧间（Interframe）压缩:时间压缩（Temporal compression），它通过比较时间轴上不同帧之间的数据进行压缩。帧间压缩一般是无损的
muxing（合成）：将视频流、音频流甚至是字幕流封装到一个文件中(容器格式（FLV，TS）)，作为一个信号进行传输。
</code></pre>

<ul>
<li><p>3.3 音频编码技术 *</p>

<p>  AAC，mp3：这些属于音频编码技术,压缩音频用</p></li>
<li><p>3.4码率控制 *</p>

<p>  多码率:观众所处的网络情况是非常复杂的，有可能是WiFi，有可能4G、3G、甚至2G，那么怎么满足多方需求呢？多搞几条线路，根据当前网络环境自定义码率。
      列如：常常看见视频播放软件中的1024，720，高清，标清，流畅等，指的就是各种码率。</p></li>
<li><p>3.5 视频封装格式 *</p>

<p>  TS : 一种流媒体封装格式，流媒体封装有一个好处，就是不需要加载索引再播放，大大减少了首次载入的延迟，如果片子比较长，mp4文件的索引相当大，影响用户体验
      为什么要用TS:这是因为两个TS片段可以无缝拼接，播放器能连续播放</p>

<p>  FLV: 一种流媒体封装格式,由于它形成的文件极小、加载速度极快，使得网络观看视频文件成为可能,因此FLV格式成为了当今主流视频格式</p></li>
</ul>


<h4>4.推流</h4>

<ul>
<li>4.1 数据传输框架 *</li>
</ul>


<p>librtmp:用来传输RTMP协议格式的数据</p>

<ul>
<li><p>4.2 流媒体数据传输协议 *</p>

<p>  RTMP:实时消息传输协议,Adobe Systems公司为Flash播放器和服务器之间音频、视频和数据传输开发的开放协议，因为是开放协议所以都可以使用了。
      RTMP协议用于对象、视频、音频的传输。
      这个协议建立在TCP协议或者轮询HTTP协议之上。
      RTMP协议就像一个用来装数据包的容器，这些数据可以是FLV中的视音频数据。一个单一的连接可以通过不同的通道传输多路网络流，这些通道中的包都是按照固定大小的包传输的</p>

<p>  chunk:消息包</p></li>
</ul>


<h4>5.流媒体服务器</h4>

<ul>
<li><p>5.1常用服务器 *</p>

<p>  SRS：一款国人开发的优秀开源流媒体服务器系统
  BMS:也是一款流媒体服务器系统，但不开源，是SRS的商业版，比SRS功能更多
  nginx:免费开源web服务器，常用来配置流媒体服务器。</p></li>
<li><p>5.2数据分发 *</p>

<p>  CDN：(Content Delivery Network)，即内容分发网络,将网站的内容发布到最接近用户的网络”边缘”，使用户可以就近取得所需的内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度.
      CDN：代理服务器，相当于一个中介。
      CDN工作原理：比如请求流媒体数据
          1.上传流媒体数据到服务器（源站）
          2.源站存储流媒体数据
          3.客户端播放流媒体，向CDN请求编码后的流媒体数据
          4.CDN的服务器响应请求，若节点上没有该流媒体数据存在，则向源站继续请求流媒体数据；若节点上已经缓存了该视频文件，则跳到第6步。
          5.源站响应CDN的请求，将流媒体分发到相应的CDN节点上
          6.CDN将流媒体数据发送到客户端
  回源：当有用户访问某一个URL的时候，如果被解析到的那个CDN节点没有缓存响应的内容，或者是缓存已经到期，就会回源站去获取搜索。如果没有人访问，那么CDN节点不会主动去源站拿.
  带宽:在固定的时间可传输的数据总量，
      比如64位、800MHz的前端总线，它的数据传输率就等于64bit×800MHz÷8(Byte)=6.4GB/s
  负载均衡: 由多台服务器以对称的方式组成一个服务器集合，每台服务器都具有等价的地位，都可以单独对外提供服务而无须其他服务器的辅助.
      通过某种负载分担技术，将外部发送来的请求均匀分配到对称结构中的某一台服务器上，而接收到请求的服务器独立地回应客户的请求。
      均衡负载能够平均分配客户请求到服务器列阵，籍此提供快速获取重要数据，解决大量并发访问服务问题。
      这种群集技术可以用最少的投资获得接近于大型主机的性能。
  QoS（带宽管理）:限制每一个组群的带宽，让有限的带宽发挥最大的效用</p></li>
</ul>


<h4>6.拉流</h4>

<pre><code>直播协议选择：
    即时性要求较高或有互动需求的可以采用RTMP,RTSP
    对于有回放或跨平台需求的，推荐使用HLS
直播协议对比 :
</code></pre>

<p><img src="http://al1020119.github.io/images/zhiboyuanli005.png" title="Caption" ></p>

<pre><code>HLS:由Apple公司定义的用于实时流传输的协议,HLS基于HTTP协议实现，传输内容包括两部分，一是M3U8描述文件，二是TS媒体文件。可实现流媒体的直播和点播，主要应用在iOS系统
    HLS是以点播的技术方式来实现直播
    HLS是自适应码率流播，客户端会根据网络状况自动选择不同码率的视频流，条件允许的情况下使用高码率，网络繁忙的时候使用低码率，并且自动在二者间随意切
    换。这对移动设备网络状况不稳定的情况下保障流畅播放非常有帮助。
    实现方法是服务器端提供多码率视频流，并且在列表文件中注明，播放器根据播放进度和下载速度自动调整。
HLS与RTMP对比:HLS主要是延时比较大，RTMP主要优势在于延时低
    HLS协议的小切片方式会生成大量的文件，存储或处理这些文件会造成大量资源浪费
    相比使用RTSP协议的好处在于，一旦切分完成，之后的分发过程完全不需要额外使用任何专门软件，普通的网络服务器即可，大大降低了CDN边缘服务器的配置要求，可以使用任何现成的CDN,而一般服务器很少支持RTSP。
HTTP-FLV:基于HTTP协议流式的传输媒体内容。
    相对于RTMP，HTTP更简单和广为人知，内容延迟同样可以做到1~3秒，打开速度更快，因为HTTP本身没有复杂的状态交互。所以从延迟角度来看，HTTP-FLV要优于RTMP。
RTSP:实时流传输协议,定义了一对多应用程序如何有效地通过IP网络传送多媒体数据.
RTP:实时传输协议,RTP是建立在UDP协议上的，常与RTCP一起使用，其本身并没有提供按时发送机制或其它服务质量（QoS）保证，它依赖于低层服务去实现这一过程。
RTCP:RTP的配套协议,主要功能是为RTP所提供的服务质量（QoS）提供反馈，收集相关媒体连接的统计信息，例如传输字节数，传输分组数，丢失分组数，单向和双向网络延迟等等。
</code></pre>

<h4>7.解码</h4>

<ul>
<li><p>7.1 解封装 *</p>

<p>  demuxing（分离）：从视频流、音频流，字幕流合成的文件(容器格式（FLV，TS）)中， 分解出视频、音频或字幕，各自进行解码。</p></li>
<li><p>7.2 音频编码框架 *</p>

<p>  fdk_aac:音频编码解码框架，PCM音频数据和AAC音频数据互转</p></li>
<li><p>7.3 解码介绍 *</p>

<p>  硬解码：用GPU来解码，减少CPU运算
      　优点：播放流畅、低功耗，解码速度快，
      　　 * 缺点：兼容不好
  软解码：用CPU来解码
      优点：兼容好
      　　 * 缺点：加大CPU负担，耗电增加、没有硬解码流畅，解码速度相对慢</p></li>
</ul>


<h4>8.播放</h4>

<pre><code>ijkplayer:一个基于FFmpeg的开源Android/iOS视频播放器
    API易于集成；
    编译配置可裁剪，方便控制安装包大小；
    支持硬件加速解码，更加省电
    简单易用，指定拉流URL，自动解码播放.
</code></pre>

<h4>9.聊天互动</h4>

<pre><code>IM:(InstantMessaging)即时通讯:是一个实时通信系统，允许两人或多人使用网络实时的传递文字消息、文件、语音与视频交流.
    IM在直播系统中的主要作用是实现观众与主播、观众与观众之间的文字互动.
    * 第三方SDK *
腾讯云：腾讯提供的即时通讯SDK，可作为直播的聊天室
融云：一个比较常用的即时通讯SDK，可作为直播的聊天室
</code></pre>

<h2>五、如何快速的开发一个完整的iOS直播app</h2>

<h4>1、利用第三方直播SDK快速的开发</h4>

<p>七牛云:七牛直播云是专为直播平台打造的全球化直播流服务和一站式实现SDK端到端直播场景的企业级直播云服务平台.</p>

<ul>
<li> 熊猫TV,龙珠TV等直播平台都是用的七牛云</li>
</ul>


<p>网易视频云：基于专业的跨平台视频编解码技术和大规模视频内容分发网络，提供稳定流畅、低延时、高并发的实时音视频服务，可将视频直播无缝对接到自身App.</p>

<h4>2、第三方SDK公司为什么要提供SDK给我们？</h4>

<pre><code>希望把我们的产品和它绑在一条船上，更加的依赖它。
技术生钱，帮养一大批牛B的程序员
</code></pre>

<h4>3、直播功能：自研还是使用第三方直播SDK开发？</h4>

<p>第三方SDK开发: 对于一个初创团队来讲，自研直播不管在技术门槛、CDN、带宽上都是有很大的门槛的，而且需要耗费大量的时间才能做出成品，不利于拉投资。</p>

<p>自研：公司直播平台大，从长远看，自研可以节省成本，技术成面比直接用SDK可控多了。</p>

<h6>4.第三方SDK好处</h6>

<pre><code>降低成本
    使用好的第三方企业服务，将不用再花高价请猎头去挖昂贵的大牛，也不用去安抚大牛们个性化的脾气
提升效率
    第三方服务的专注与代码集成所带来的方便，所花费的时间可能仅仅是1-2个小时，节约近99%的时间，足够换取更多的时间去和竞争对手斗智斗勇，增加更大的成功可能性
降低风险
    借助专业的第三方服务，由于它的快速、专业、稳定等特点，能够极大地加强产品的竞争能力（优质服务、研发速度等），缩短试错时间，必将是创业中保命的手段之一
专业的事，找专业的人来做
    第三方服务最少是10-20人的团队专注地解决同一个问题，做同一件事情。第三方服务所带来的支持效果，绝不是通过1-2个人处理所能对比的，难道不是吗
</code></pre>

<p>结束语</p>

<p>后续还会有讲解视频采集，美颜，聊天室，礼物系统等更多功能，敬请关注！！！</p>

<hr />

<pre><code>Q Q：2211523682/790806573

微信：18370997821/13148454507

微博WB:http://weibo.com/u/3288975567?is_hot=1

git博文：http://al1020119.github.io/

github：https://github.com/al1020119
</code></pre>

<p><img src="http://al1020119.github.io/images/iCocosCoder.jpg" title="Caption" ></p>

<p><img src="http://al1020119.github.io/images/iCocosPublic.jpg" title="Caption" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[直播-iJKPlayer]]></title>
    <link href="http://al1020119.github.io/blog/2016/09/10/zhi-bo-ijkplayer/"/>
    <updated>2016-09-10T14:42:37+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/09/10/zhi-bo-ijkplayer</id>
    <content type="html"><![CDATA[<p>demo:<a href="https://github.com/al1020119/iCocosIJKPlayer">iCocosIJKPlayer</a></p>

<p>网上讨论比较多并且支持Android/iOS的项目</p>

<pre><code>Vitamio
IJKPlayer
</code></pre>

<p>首先说下Vitamio目前可以拿到的版本是4.20，商业使用需要付费。</p>

<p>这里只介绍IJKPlayer，为什么？用了你就知道了！</p>

<!--more-->


<p>ijkplayer 是一款做视频直播的框架, 基于ffmpeg, 支持 Android 和 iOS, 网上也有很多集成说明, 但是个人觉得还是不够详细, 在这里详细的讲一下在 iOS 中如何集成ijkplayer, 即便以前从没有接触过, 按着下面做也可以集成成功!</p>

<p><a href="https://github.com/Bilibili/ijkplayer">ijkPlayer下载地址</a></p>

<p><a href="http://blog.csdn.net/zc639143029/article/details/51191886">ijkPlayer详解</a></p>

<p>必备条件:</p>

<pre><code># install homebrew, git, yasm
ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"
brew install git
brew install yasm
</code></pre>

<h3>一. 下载ijkplayer</h3>

<p><a href="https://github.com/Bilibili/ijkplayer">ijkplayer下载地址</a></p>

<p>下载完成后解压, 解压后文件夹内部目录如下图:</p>

<p><img src="http://al1020119.github.io/images/ijkplayer001.png" title="Caption" ></p>

<h3>二. 编译 ijkplayer</h3>

<p>说是编译 ijkplayer, 其实是编译 ffmpeg, 在这里我们已经下载好了ijkplayer, 所以 github 上README.md中的Build iOS那一步中有一些步骤是不需要的.</p>

<p>下面开始一步一步编译:</p>

<ol>
<li>打开终端, cd 到jkplayer-master文件夹中, 也就是下载完解压后的文件夹, 如下图:</li>
</ol>


<p><img src="http://al1020119.github.io/images/ijkplayer002.png" title="Caption" >
2. 执行命令行./init-ios.sh, 这一步是去下载 ffmpeg 的, 时间会久一点, 耐心等一下.如下图:</p>

<p><img src="http://al1020119.github.io/images/ijkplayer003.png" title="Caption" >
3. 在第2步中下载完成后, 执行cd ios, 也就是进入到 ios目录中, 如下图:</p>

<p><img src="http://al1020119.github.io/images/ijkplayer004.png" title="Caption" >
4. 进入 ios 文件夹后, 在终端依次执行./compile-ffmpeg.sh clean和./compile-ffmpeg.sh all命令, 编译 ffmpeg, 也就是README.md中这两步, 如下图:</p>

<p><img src="http://al1020119.github.io/images/ijkplayer005.png" title="Caption" >
编译时间较久, 耐心等待一下.</p>

<pre><code>./init-ios.sh
cd ios
./compile-ffmpeg.sh clean
./compile-ffmpeg.sh all
</code></pre>

<h3>三. 打包IJKMediaFramework.framework框架</h3>

<p>集成 ijkplayer 有两种方法: 一种方法是按照IJKMediaDemo工程中那样, 直接导入工程IJKMediaPlayer.xcodeproj, 在这里不做介绍, 如下图:</p>

<p><img src="http://al1020119.github.io/images/ijkplayer006.png" title="Caption" >
第二种集成方法是把 ijkplayer 打包成framework导入工程中使用. 下面开始介绍如何打包IJKMediaFramework.framework, 按下面步骤开始一步一步做:</p>

<ol>
<li>首先打开工程IJKMediaPlayer.xcodeproj, 位置如下图:</li>
</ol>


<p><img src="http://al1020119.github.io/images/ijkplayer007.png" title="Caption" >
打开后是这样的, 如下图:</p>

<p><img src="http://al1020119.github.io/images/ijkplayer008.png" title="Caption" >
2. 工程打开后设置工程的 scheme, 具体步骤如下图:</p>

<p><img src="http://al1020119.github.io/images/ijkplayer009.png" title="Caption" >
<img src="http://al1020119.github.io/images/ijkplayer010.png" title="Caption" >
3. 设置好 scheme 后, 分别选择真机和模拟器进行编译, 编译完成后, 进入 Finder, 如下图:</p>

<p><img src="http://al1020119.github.io/images/ijkplayer011.png" title="Caption" >
进入 Finder 后, 可以看到有真机和模拟器两个版本的编译结果, 如下图:</p>

<p><img src="http://al1020119.github.io/images/ijkplayer012.png" title="Caption" >
下面开始合并真机和模拟器版本的 framework, 注意不要合并错了, 合并的是这个文件, 如下图:</p>

<p><img src="http://al1020119.github.io/images/ijkplayer013.png" title="Caption" >
打开终端, 进行合并, 命令行具体格式为:</p>

<p>lipo -create &ldquo;真机版本路径&rdquo; &ldquo;模拟器版本路径&rdquo; -output &ldquo;合并后的文件路径&rdquo;</p>

<p>合并后如下图:</p>

<p><img src="http://al1020119.github.io/images/ijkplayer014.png" title="Caption" >
下面很重要, 需要用合并后的IJKMediaFramework把原来的IJKMediaFramework替换掉, 如下图, 希望你能看懂:</p>

<p><img src="http://al1020119.github.io/images/ijkplayer015.png" title="Caption" >
上图中的1、2两步完成后, 绿色框住的那个IJKMediaFramework.framework文件就是我们需要的框架了, 可以复制出来, 稍后我们需要导入工程使用.</p>

<h3>四. iOS工程中集成ijkplayer</h3>

<p>新建工程, 导入合并后的IJKMediaFramework.framework以及相关依赖框架以及相关依赖框架,如下图:</p>

<p><img src="http://al1020119.github.io/images/ijkplayer016.png" title="Caption" >
导入框架后, 在ViewController.m进行测试, 首先导入IJKMediaFramework.h头文件, 编译看有没有错, 如果没有错说明集成成功.</p>

<p>接着开始在ViewController.m文件中使用IJKMediaFramework框架进行测试使用, 写一个简单的直播视频进行测试, 在这里看一下运行后的结果, 后面会放上 Demo 供下载.</p>

<p><img src="http://al1020119.github.io/images/ijkplayer0017.png" title="Caption" ></p>

<p><img src="http://al1020119.github.io/images/ijkplayer018.png" title="Caption" ></p>

<pre><code>为苦于各种奇怪原因而无法玩耍的小伙伴们提供了包装了ijkplayer的pod，仅供测试体验。
1.基于ijkplayer 5737ccc提交制作成的framework，需要注意的是需要iOS8+。
2.如果使用ijkplayer过程中遇到BUG什么的，可以移步去ijkplayer作者的GitHub上提issue或者PR。
哦对了，地址在这里https://coding.net/u/shirokuma/p/IJKMediaLibrary/git，因framework超过100MB无法传到GitHub上，就放到Coding上了。祝各位玩的愉快！
</code></pre>

<p>项目源码：（在集成或者使用之前请细细品读，也许你会发现不一样的乐趣）</p>

<pre><code>//
//  ViewController.m
//  iCocosIjkPlayer
//
//  Created by tqy on 16/8/8.
//  Copyright © 2016年 iCocos. All rights reserved.
//

#import "ViewController.h"

#import &lt;IJKMediaFramework/IJKMediaFramework.h&gt;

@interface ViewController ()

@property (nonatomic, strong) NSURL *url;

@property (nonatomic, retain) id&lt;IJKMediaPlayback&gt; player;

@property (nonatomic, weak) UIView *PlayerView;

@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];



    //网络视频
    //    self.url = [NSURL URLWithString:@"https://clips.vorwaerts-gmbh.de/big_buck_bunny.mp4"];
    //    _player = [[IJKAVMoviePlayerController alloc] initWithContentURL:self.url];

    //直播视频
    self.url = [NSURL URLWithString:@"http://live.hkstv.hk.lxdns.com/live/hks/playlist.m3u8"];
    _player = [[IJKFFMoviePlayerController alloc] initWithContentURL:self.url withOptions:nil];

    UIView *playerView = [self.player view];

    UIView *displayView = [[UIView alloc] initWithFrame:CGRectMake(0, 50, self.view.bounds.size.width, 180)];
    self.PlayerView = displayView;
    self.PlayerView.backgroundColor = [UIColor blackColor];
    [self.view addSubview:self.PlayerView];

    playerView.frame = self.PlayerView.bounds;
    playerView.autoresizingMask = UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight;

    [self.PlayerView insertSubview:playerView atIndex:1];
    [_player setScalingMode:IJKMPMovieScalingModeAspectFill];
    [self installMovieNotificationObservers];

}

-(void)viewWillAppear:(BOOL)animated{
    if (![self.player isPlaying]) {
        [self.player prepareToPlay];
    }
}

#pragma Selector func

- (void)loadStateDidChange:(NSNotification*)notification {
    IJKMPMovieLoadState loadState = _player.loadState;

    if ((loadState &amp; IJKMPMovieLoadStatePlaythroughOK) != 0) {
        NSLog(@"LoadStateDidChange: IJKMovieLoadStatePlayThroughOK: %d\n",(int)loadState);
    }else if ((loadState &amp; IJKMPMovieLoadStateStalled) != 0) {
        NSLog(@"loadStateDidChange: IJKMPMovieLoadStateStalled: %d\n", (int)loadState);
    } else {
        NSLog(@"loadStateDidChange: ???: %d\n", (int)loadState);
    }
}

- (void)moviePlayBackFinish:(NSNotification*)notification {
    int reason =[[[notification userInfo] valueForKey:IJKMPMoviePlayerPlaybackDidFinishReasonUserInfoKey] intValue];
    switch (reason) {
        case IJKMPMovieFinishReasonPlaybackEnded:
            NSLog(@"playbackStateDidChange: IJKMPMovieFinishReasonPlaybackEnded: %d\n", reason);
            break;

        case IJKMPMovieFinishReasonUserExited:
            NSLog(@"playbackStateDidChange: IJKMPMovieFinishReasonUserExited: %d\n", reason);
            break;

        case IJKMPMovieFinishReasonPlaybackError:
            NSLog(@"playbackStateDidChange: IJKMPMovieFinishReasonPlaybackError: %d\n", reason);
            break;

        default:
            NSLog(@"playbackPlayBackDidFinish: ???: %d\n", reason);
            break;
    }
}

- (void)mediaIsPreparedToPlayDidChange:(NSNotification*)notification {
    NSLog(@"mediaIsPrepareToPlayDidChange\n");
}

- (void)moviePlayBackStateDidChange:(NSNotification*)notification {
    switch (_player.playbackState) {
        case IJKMPMoviePlaybackStateStopped:
            NSLog(@"IJKMPMoviePlayBackStateDidChange %d: stoped", (int)_player.playbackState);
            break;

        case IJKMPMoviePlaybackStatePlaying:
            NSLog(@"IJKMPMoviePlayBackStateDidChange %d: playing", (int)_player.playbackState);
            break;

        case IJKMPMoviePlaybackStatePaused:
            NSLog(@"IJKMPMoviePlayBackStateDidChange %d: paused", (int)_player.playbackState);
            break;

        case IJKMPMoviePlaybackStateInterrupted:
            NSLog(@"IJKMPMoviePlayBackStateDidChange %d: interrupted", (int)_player.playbackState);
            break;

        case IJKMPMoviePlaybackStateSeekingForward:
        case IJKMPMoviePlaybackStateSeekingBackward: {
            NSLog(@"IJKMPMoviePlayBackStateDidChange %d: seeking", (int)_player.playbackState);
            break;
        }

        default: {
            NSLog(@"IJKMPMoviePlayBackStateDidChange %d: unknown", (int)_player.playbackState);
            break;
        }
    }
}

#pragma Install Notifiacation

- (void)installMovieNotificationObservers {
    [[NSNotificationCenter defaultCenter] addObserver:self
                                             selector:@selector(loadStateDidChange:)
                                                 name:IJKMPMoviePlayerLoadStateDidChangeNotification
                                               object:_player];
    [[NSNotificationCenter defaultCenter] addObserver:self
                                             selector:@selector(moviePlayBackFinish:)
                                                 name:IJKMPMoviePlayerPlaybackDidFinishNotification
                                               object:_player];

    [[NSNotificationCenter defaultCenter] addObserver:self
                                             selector:@selector(mediaIsPreparedToPlayDidChange:)
                                                 name:IJKMPMediaPlaybackIsPreparedToPlayDidChangeNotification
                                               object:_player];

    [[NSNotificationCenter defaultCenter] addObserver:self
                                             selector:@selector(moviePlayBackStateDidChange:)
                                                 name:IJKMPMoviePlayerPlaybackStateDidChangeNotification
                                               object:_player];

}

- (void)removeMovieNotificationObservers {
    [[NSNotificationCenter defaultCenter] removeObserver:self
                                                    name:IJKMPMoviePlayerLoadStateDidChangeNotification
                                                  object:_player];
    [[NSNotificationCenter defaultCenter] removeObserver:self
                                                    name:IJKMPMoviePlayerPlaybackDidFinishNotification
                                                  object:_player];
    [[NSNotificationCenter defaultCenter] removeObserver:self
                                                    name:IJKMPMediaPlaybackIsPreparedToPlayDidChangeNotification
                                                  object:_player];
    [[NSNotificationCenter defaultCenter] removeObserver:self
                                                    name:IJKMPMoviePlayerPlaybackStateDidChangeNotification
                                                  object:_player];

}


- (IBAction)play_btn:(id)sender {

    if (![self.player isPlaying]) {
        [self.player play];
    }else{
        [self.player pause];
    }
}

@end
</code></pre>

<hr />

<pre><code>Q Q：2211523682/790806573

微信：18370997821/13148454507

微博WB:http://weibo.com/u/3288975567?is_hot=1

git博文：http://al1020119.github.io/

github：https://github.com/al1020119
</code></pre>

<p><img src="http://al1020119.github.io/images/iCocosCoder.jpg" title="Caption" ></p>

<p><img src="http://al1020119.github.io/images/iCocosPublic.jpg" title="Caption" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[直播-H264-ACC-FLV😂总结]]></title>
    <link href="http://al1020119.github.io/blog/2016/09/08/yuan-li-zong-jie-h264-acc-flv/"/>
    <updated>2016-09-08T14:42:11+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/09/08/yuan-li-zong-jie-h264-acc-flv</id>
    <content type="html"><![CDATA[<p>H.264原理</p>

<pre><code>H.264原始码流（又称为“裸流”）是由一个一个的NALU组成的。他们的结构如下图所示。

其中每个NALU之间通过startcode（起始码）进行分隔，起始码分成两种：0x000001（3Byte）或者0x00000001（4Byte）。如果NALU对应的Slice为一帧的开始就用0x00000001，否则就用0x000001。

H.264码流解析的步骤就是首先从码流中搜索0x000001和0x00000001，分离出NALU；然后再分析NALU的各个字段。本文的程序即实现了上述的两个步骤。
</code></pre>

<!--more-->


<p>ACC原理</p>

<pre><code>AAC原始码流（又称为“裸流”）是由一个一个的ADTS frame组成的。他们的结构如下图所示。

其中每个ADTS frame之间通过syncword（同步字）进行分隔。同步字为0xFFF（二进制“111111111111”）。AAC码流解析的步骤就是首先从码流中搜索0x0FFF，分离出ADTS frame；然后再分析ADTS frame的首部各个字段。本文的程序即实现了上述的两个步骤。
</code></pre>

<p>FLV原理</p>

<pre><code>FLV封装格式是由一个FLV Header文件头和一个一个的Tag组成的。Tag中包含了音频数据以及视频数据。FLV的结构如下图所示。


有关FLV的格式本文不再做记录。可以参考文章《视音频编解码学习工程：FLV封装格式分析器》。本文的程序实现了FLV中的FLV Header和Tag的解析，并可以分离出其中的音频流。
</code></pre>

<hr />

<pre><code>Q Q：2211523682/790806573

微信：18370997821/13148454507

微博WB:http://weibo.com/u/3288975567?is_hot=1

git博文：http://al1020119.github.io/

github：https://github.com/al1020119
</code></pre>

<p><img src="http://al1020119.github.io/images/iCocosCoder.jpg" title="Caption" ></p>

<p><img src="http://al1020119.github.io/images/iCocosPublic.jpg" title="Caption" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[直播-M3U8]]></title>
    <link href="http://al1020119.github.io/blog/2016/09/06/m3u8/"/>
    <updated>2016-09-06T14:41:56+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/09/06/m3u8</id>
    <content type="html"><![CDATA[<p>引用：<a href="http://log.fyscu.com/index.php/archives/28/">http://log.fyscu.com/index.php/archives/28/</a></p>

<pre><code>文件格式
m3u文件是用来描述一个或多个媒体文件地址的纯文本文件，通常以 M3U 或 m3u 作为扩展名。

m3u文件里描述的最小单位（元素/行/记录），可以是一下三者之一：

1.一个文件的绝对路径
2.相对于m3u文件的相对路径
3.一个网络url
</code></pre>

<!--more-->


<p></p>

<pre><code>以#好开头的，是m3u的注释，而一些m3u扩展指令也是由#号开头

m3u的一个常见用途是作为一个指向网络中一个流媒体的播放列表，比如在线视频、广播等等。

你可以直接用文本编辑器编写一个m3u文件，但需要保存为 window-1252格式（ASCII的一个扩展集）。

M3U指令的扩展

#EXTM3U    文件头，必须出现在第一行            如：略
#EXTINF    引导信息，包含播放时间（时长）和标题     如：#EXTINF:191,Artist Name - Track Title

M3U8
所谓的M3U8就是用unicode编写的M3U文件，这最初是用在IOS设备上播放http实时流的基础格式。
</code></pre>

<h6>1. HLS</h6>

<p>HLS是为移动设备开发的基于HTTP的流媒体解决方案。</p>

<pre><code>HLS，Http Live Streaming 是由Apple公司定义的用于实时流传输的协议，HLS基于HTTP协议实现，传输内容包括两部分，一是M3U8描述文件，二是TS媒体文件。

1、M3U8文件

   用文本方式对媒体文件进行描述，由一系列标签组成。

2、ts文件

    ts文件为传输流文件，视频编码主要格式h264/mpeg4，音频为acc/MP3。

   ts文件分为三层：ts层Transport Stream、pes层 Packet Elemental Stream、es层 Elementary Stream. es层就是音视频数据，pes层是在音视频数据上加了时间戳等对数据帧的说明信息，ts层就是在pes层加入数据流的识别和传输必须的信息
（1）ts层     ts包大小固定为188字节，ts层分为三个部分：ts header、adaptation field、payload。ts header固定4个字节；adaptation field可能存在也可能不存在，主要作用是给不足188字节的数据做填充；payload是pes数据。
</code></pre>

<h6>2. 原理：</h6>

<p>将视频或流切分成小片（TS）， 并建立索引（M3U8）.</p>

<p>支持视频流：H.264； 音频流：AAC</p>

<h6>3. M3U8文件解析</h6>

<p>M3U8文件在很多地方也叫做Playlist file。</p>

<pre><code>m3u8，是HTTP Live Streaming直播的索引文件。

m3u8基本上可以认为就是.m3u格式文件，区别在于，m3u8文件使用UTF-8字符编码。
</code></pre>

<h6>4.  Playlist file</h6>

<pre><code>一个M3U的 Playlist 就是一个由多个独立行组成的文本文件，每行由回车/换行区分。每一行可以是一个URI  空白行或
</code></pre>

<p>是以”#“号开头的字符串，并且空格只能存在于一行中不同元素间的分隔。
   一个URI 表示一个媒体段或是”variant Playlist file“（最多支持一层嵌套，即一个mm3u8文件中嵌套另一个m3u8），
以”#EXT“开头的表示一个”tag“，否则表示注释，直接忽略</p>

<blockquote><p>多码率的适配，根据网络带宽，客户端会选择一个适合自己码率的文件进行播放，保证视频流的流畅。</p></blockquote>

<p>在IOS device和mac上可以用http的方式进行分发，其中playlist标准为由m3u扩展而来的m3u8文件，媒体文件为MPEG2-TS或者AAC文件(audio only)</p>

<h6>5. m3u8文件有两种应用场景：</h6>

<pre><code>- 多码率适配流，

- 单码率适配流
</code></pre>

<p>客户端默认会首先选择码率最高的请求，如果发现码率达不到，会请求郊低码率的流</p>

<h6>6. m3u8分类</h6>

<p>M3U8分顶级M3U8和二级M3U8， 顶级M3U8主要是做多码率适配的， 二级M3U8才是真正的切片文件，</p>

<hr />

<pre><code>Q Q：2211523682/790806573

微信：18370997821/13148454507

微博WB:http://weibo.com/u/3288975567?is_hot=1

git博文：http://al1020119.github.io/

github：https://github.com/al1020119
</code></pre>

<p><img src="http://al1020119.github.io/images/iCocosCoder.jpg" title="Caption" ></p>

<p><img src="http://al1020119.github.io/images/iCocosPublic.jpg" title="Caption" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[直播-视频编解码H.264]]></title>
    <link href="http://al1020119.github.io/blog/2016/09/05/zhi-bo-shi-pin-bian-jie-ma-h-dot-264/"/>
    <updated>2016-09-05T14:41:34+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/09/05/zhi-bo-shi-pin-bian-jie-ma-h-dot-264</id>
    <content type="html"><![CDATA[<pre><code>1995年，ITU-T针对低比特率视频应用制定了H.263标准，当时H.263被公认为是以像素为基础的采用第一代编码技术混合编码方案所能 达到的最佳结果。在随后几年中，ITU-T又对其进行了多次完善，以提高编码效率，增强编码功能。1998年发布了H.263+；2000年发布了 H.263++。尽管采用H263编码技术较H261编码在压缩率和图像质量上都有大幅度的提升，但H.263信源编码算法的核心仍然是H.261标准中 采用的 DPCM/DCT混和编码算法，原理框图也和H.261十分相似。
</code></pre>

<!--more-->


<p></p>

<pre><code>2001年12月，ITU-T和ISO两个国际标准化组织的有关视频编码的专家联合组成视频联合工作组（JVT，Joint Video Team），负责制定一个新的视频编码标准，以实现视频的高压缩比、高图像质量、良好的网络适应性等目标。随后JVT制定出的视频编码标准被ITU-T 定义为H.264；该标准也被ISO定义为14496-10（MPEG-4 第10部分）高级视频编码（AVC，Advanced Video Coding）标准。
</code></pre>

<ul>
<li>1、H.264/MPEG-4 AVC是一个块导向（block-oriented）、以移动补偿为基础（motion-compensation-based）codec标准</li>
<li>2、H264使用范围：蓝光discs，YouTube，iTunes，Adobe FlashPlayer，MS Silverlight，广播服务（DVB，SBTVD），卫星电视直播服务，有线电视服务，实时视频会议。</li>
<li><p>3、设计目标：高视频质量、低比特率，不增加设计及实现的复杂性。</p></li>
<li><p>4、从视频标准的发展来看，H.264作为国际两大标准组织确定的共同标准，全面覆盖了视频通信、广播、存储等各方面的应用，采用H264的视频标准协议的会议电视系统是合理的选择。</p></li>
<li><p>5、采用H264编码协议的优势：</p>

<ul>
<li><p>不同大小和形状的宏块分割：H.264支持7种模式。最小可达4×4的小块模式的运动补偿为运动详细信息的处理提高了性能，减少了方块效应，提高了图像的质量。</p></li>
<li><p>高精度的亚像素运动补偿：在H.263中采用的是半像素精度的运动估计，而在H.264中可以采用1/4或者1/8像素精度的运动估值。运动估计后的残差小。</p></li>
<li><p>多帧预测：H.264提供可选的多帧预测功能，在帧间编码时，可选5个不同的参考帧，提供了更好的纠错性能，这样更可以改善视频图像质量。</p></li>
<li><p>去块滤波器：H.264定义了自适应去除块效应的滤波器，这可以处理预测环路中的水平和垂直块边缘，大大减少了方块效应。</p></li>
<li><p>4×4块的整数变换：由于用二变换块的尺寸缩小,运动物体的划分更精确,这样,不但变换计算量比较小,而且在运动物体边缘处的衔接误疾差也大为减小；</p></li>
<li><p>先进的量化方法：与H.263等的固定常数量化步长不同，H.264步长是以12.5%的复合率递进的，并对色度系数采用了较小量化步长。这些措施提高了码率控制的能力，并加强了彩色的逼真性。</p></li>
</ul>
</li>
</ul>


<blockquote><p>在图像编解码效率上，H.264算法最为领先，MPEG-4和H.263算法基本相同，MPEG-2算法效率最低，但是当图像质量要求达到了一定的程度时，对带宽的要求趋向归一化，即在高带宽（6M和以上）时，各种编码算法提供的图像质量趋同。</p></blockquote>

<p>同时由于H.264编解码对CPU处理能力的需求大幅度增加（相同带宽下，H.264编解码对CPU的占用率是H.263编解码的6倍以上），当前CPU处理能力难以支撑。</p>

<pre><code>1、H264并没有明确规定一个编解码器如何实现，只是规定了一个编码后的视频比特流的句法，和该比特流的解码方法，这个与MPEG 相似。

2、H264和以前的标准（如H261、H263、MPEG-1、MPEG-4）的编解码器实现流程没有太大区别，主要的不同在于各功能块的细节。

3、H264就是利用实现的复杂性获得压缩性能的明显改善。（至于复杂度的评估，以后会介绍）
</code></pre>

<h2>一、H.264的发展历史</h2>

<p>　　H.264在1997年ITU的视频编码专家组（Video Coding Experts Group）提出时被称为H.26L，在ITU与ISO合作研究后被称为MPEG4 Part10（MPEG4 AVC）或H.264（JVT）。</p>

<p>H.264的高级技术背景</p>

<p>　　H.264标准的主要目标是：与其它现有的视频编码标准相比，在相同的带宽下提供更加优秀的图象质量。</p>

<p>　　而，H.264与以前的国际标准如H.263和MPEG-4相比，最大的优势体现在以下四个方面：</p>

<pre><code>1．将每个视频帧分离成由像素组成的块，因此视频帧的编码处理的过程可以达到块的级别。

2．采用空间冗余的方法，对视频帧的一些原始块进行空间预测、转换、优化和熵编码（可变长编码）。

3．对连续帧的不同块采用临时存放的方法，这样，只需对连续帧中有改变的部分进行编码。该算法采用运动预测和运动补偿来完成。对某些特定的块，在一个或多个已经进行了编码的帧执行搜索来决定块的运动向量，并由此在后面的编码和解码中预测主块。

4．采用剩余空间冗余技术，对视频帧里的残留块进行编码。例如：对于源块和相应预测块的不同，再次采用转换、优化和熵编码。
</code></pre>

<p>H.264的特征和高级优势</p>

<p>　　H.264是国际标准化组织（ISO）和国际电信联盟（ITU）共同提出的继MPEG4之后的新一代数字视频压缩格式，它即保留了以往压缩技术的优点和精华又具有其他压缩技术无法比拟的许多优点。</p>

<pre><code>1．低码流（Low Bit Rate）：和MPEG2和MPEG4 ASP等压缩技术相比，在同等图像质量下，采用H.264技术压缩后的数据量只有MPEG2的1/8，MPEG4的1/3。显然，H.264压缩技术的采用将大大节省用户的下载时间和数据流量收费。

2．高质量的图象：H.264能提供连续、流畅的高质量图象（DVD质量）。

3．容错能力强：H.264提供了解决在不稳定网络环境下容易发生的丢包等错误的必要工具。

4．网络适应性强：H.264提供了网络适应层（Network Adaptation Layer）, 使得H.264的文件能容易地在不同网络上传输（例如互联网，CDMA，GPRS，WCDMA，CDMA2000等）。 
</code></pre>

<h2>二、H.264标准概述</h2>

<p>　　H.264和以前的标准一样，也是DPCM加变换编码的混合编码模式。但它采用“回归基本”的简洁设计，不用众多的选项，获得比H.263++好得多的压缩性能；加强了对各种信道的适应能力，采用“网络友好”的结构和语法，有利于对误码和丢包的处理；应用目标范围较宽，以满足不同速率、不同解析度以及不同传输（存储）场合的需求。</p>

<p>　　技术上，它集中了以往标准的优点，并吸收了标准制定中积累的经验。与H.263 v2(H.263+)或MPEG-4简单类(Simple Profile)相比，H.264在使用与上述编码方法类似的最佳编码器时，在大多数码率下最多可节省50%的码率。H.264在所有码率下都能持续提供较高的视频质量。H.264能工作在低延时模式以适应实时通信的应用(如视频会议)，同时又能很好地工作在没有延时限制的应用，如视频存储和以服务器为基础的视频流式应用。H.264提供包传输网中处理包丢失所需的工具，以及在易误码的无线网中处理比特误码的工具。</p>

<p>　　在系统层面上，H.264提出了一个新的概念，在视频编码层(Video Coding Layer, VCL)和网络提取层(Network Abstraction Layer, NAL)之间进行概念性分割，前者是视频内容的核心压缩内容之表述，后者是通过特定类型网络进行递送的表述，这样的结构便于信息的封装和对信息进行更好的优先级控制。H.264的系统编码框图如图1所示。</p>

<p>图1 H.264系统框图</p>

<h2>三、H.264标准的关键技术</h2>

<pre><code>  1．帧内预测编码
</code></pre>

<p>　　帧内编码用来缩减图像的空间冗余。为了提高H.264帧内编码的效率，在给定帧中充分利用相邻宏块的空间相关性，相邻的宏块通常含有相似的属性。因此，在对一给定宏块编码时，首先可以根据周围的宏块预测（典型的是根据左上角的宏块，因为此宏块已经被编码处理），然后对预测值与实际值的差值进行编码，这样，相对于直接对该帧编码而言，可以大大减小码率。</p>

<p>　　H.264提供6种模式进行4×4像素宏块预测，包括1种直流预测和5种方向预测，如图2所示。在图中，相邻块的A到I共9个像素均已经被编码，可以被用以预测，如果我们选择模式4，那么，a、b、c、d4个像素被预测为与E相等的值，e、f、g、h4个像素被预测为与F相等的值，对于图像中含有很少空间信息的平坦区，H.264也支持16×16的帧内编码。</p>

<p>图2 帧内编码模式</p>

<h6>2．帧间预测编码</h6>

<p>　　帧间预测编码利用连续帧中的时间冗余来进行运动估计和补偿。H.264的运动补偿支持以往的视频编码标准中的大部分关键特性，而且灵活地添加了更多的功能，除了支持P帧、B帧外，H.264还支持一种新的流间传送帧——SP帧。码流中包含SP帧后，能在有类似内容但有不同码率的码流之间快速切换，同时支持随机接入和快速回放模式。</p>

<p>　　H.264的运动估计有以下4个特性。</p>

<p>　　(1) 不同大小和形状的宏块分割</p>

<pre><code>对每一个16×16像素宏块的运动补偿可以采用不同的大小和形状，H.264支持7种模式，如图4所示。小块模式的运动补偿为运动详细信息的处理提高了性能，减少了方块效应，提高了图像的质量。
</code></pre>

<p>　　(2) 高精度的亚像素运动补偿</p>

<pre><code>　　在H.263中采用的是半像素精度的运动估计，而在H.264中可以采用1/4或者1/8像素精度的运动估值。在要求相同精度的情况下，H.264使用1/4或者1/8像素精度的运动估计后的残差要比H.263采用半像素精度运动估计后的残差来得小。这样在相同精度下，H.264在帧间编码中所需的码率更小。
</code></pre>

<p>　　(3) 多帧预测</p>

<pre><code>　　H.264提供可选的多帧预测功能，在帧间编码时，可选5个不同的参考帧，提供了更好的纠错性能，这样更可以改善视频图像质量。这一特性主要应用于以下场合：周期性的运动、平移运动、在两个不同的场景之间来回变换摄像机的镜头。
</code></pre>

<p>　　(4) 去块滤波器</p>

<pre><code>　　H.264定义了自适应去除块效应的滤波器，这可以处理预测环路中的水平和垂直块边缘，大大减少了方块效应。
</code></pre>

<h6>3．整数变换</h6>

<p>　　在变换方面，H.264使用了基于4×4像素块的类似于DCT的变换，但使用的是以整数为基础的空间变换，不存在反变换，因为取舍而存在误差的问题，变换矩阵如图5所示。与浮点运算相比，整数DCT变换会引起一些额外的误差，但因为DCT变换后的量化也存在量化误差，与之相比，整数DCT变换引起的量化误差影响并不大。此外，整数DCT变换还具有减少运算量和复杂度，有利于向定点DSP移植的优点。</p>

<h6>4．量化</h6>

<p>　　H.264中可选32种不同的量化步长，这与H.263中有31个量化步长很相似，但是在H.264中，步长是以12.5%的复合率递进的，而不是一个固定常数。
在H.264中，变换系数的读出方式也有两种：之字形(Zigzag)扫描和双扫描。大多数情况下使用简单的之字形扫描；双扫描仅用于使用较小量化级的块内，有助于提高编码效率。</p>

<h6>5．熵编码</h6>

<p>　　视频编码处理的最后一步就是熵编码，在H.264中采用了两种不同的熵编码方法：通用可变长编码（UVLC）和基于文本的自适应二进制算术编码（CABAC）。
在H.263等标准中，根据要编码的数据类型如变换系数、运动矢量等，采用不同的VLC码表。H.264中的UVLC码表提供了一个简单的方法，不管符号表述什么类型的数据，都使用统一变字长编码表。其优点是简单；缺点是单一的码表是从概率统计分布模型得出的，没有考虑编码符号间的相关性，在中高码率时效果不是很好。
因此，H.264中还提供了可选的CABAC方法。算术编码使编码和解码两边都能使用所有句法元素(变换系数、运动矢量)的概率模型。为了提高算术编码的效率，通过内容建模的过程，使基本概率模型能适应随视频帧而改变的统计特性。内容建模提供了编码符号的条件概率估计，利用合适的内容模型，存在于符号间的相关性可以通过选择目前要编码符号邻近的已编码符号的相应概率模型来去除，不同的句法元素通常保持不同的模型。</p>

<h2>四、H.264在视频会议中的应用</h2>

<p>　　目前，大多数的视频会议系统均采用H.261或H.263视频编码标准，而H.264的出现，使得在同等速率下，H.264能够比H.263减小50%的码率。也就是说，用户即使是只利用 384kbit/s的带宽，就可以享受H.263下高达 768kbit/s的高质量视频服务。H.264 不但有助于节省庞大开支，还可以提高资源的使用效率，同时令达到商业质量的视频会议服务拥有更多的潜在客户。</p>

<p>　　目前，已经有少数几家厂商的视频会议产品支持H.264协议，厂商们致力于普及H.264这个全新的业界标准。随着其它视频会议方案厂商陆续效仿他们的做法，我们必将能全面体验H.264视频服务的优势。
　　
　　
　　
　　</p>

<hr />

<pre><code>Q Q：2211523682/790806573

微信：18370997821/13148454507

微博WB:http://weibo.com/u/3288975567?is_hot=1

git博文：http://al1020119.github.io/

github：https://github.com/al1020119
</code></pre>

<p><img src="http://al1020119.github.io/images/iCocosCoder.jpg" title="Caption" ></p>

<p><img src="http://al1020119.github.io/images/iCocosPublic.jpg" title="Caption" ><br/>
　　</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[直播-音频编解码ACC]]></title>
    <link href="http://al1020119.github.io/blog/2016/09/03/zhi-bo-yin-pin-bian-jie-ma-acc/"/>
    <updated>2016-09-03T14:41:15+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/09/03/zhi-bo-yin-pin-bian-jie-ma-acc</id>
    <content type="html"><![CDATA[<ul>
<li><p>AAC是高级音频编码（Advanced Audio Coding）的缩写，出现于1997年，最初是基于MPEG-2的音频编码技术。由Fraunhofer IIS、Dolby Laboratories、AT&amp;T、Sony等公司共同开发，目的是取代MP3格式。2000年，MPEG-4标准出台，AAC重新集成了其它技术（PS,SBR），为区别于传统的MPEG-2 AAC，故含有SBR或PS特性的AAC又称为MPEG-4 AAC。</p></li>
<li><p>AAC是新一代的音频有损压缩技术，它通过一些附加的编码技术（比如PS,SBR等），衍生出了LC-AAC,HE-AAC,HE-AACv2三种主要的编码，LC-AAC就是比较传统的AAC，相对而言，主要用于中高码率(>=80Kbps)，HE-AAC(相当于AAC+SBR)主要用于中低码(&lt;=80Kbps)，而新近推出的HE-AACv2(相当于AAC+SBR+PS)主要用于低码率(&lt;=48Kbps）,事实上大部分编码器设成&lt;=48Kbps自动启用PS技术，而>48Kbps就不加PS,就相当于普通的HE-AAC。</p></li>
</ul>


<!--more-->


<p></p>

<p>ACC是更优于MP3的音频格式。</p>

<pre><code>AAC可以在对比MP3文件缩小30%的前题下提供更好的音质。
</code></pre>

<blockquote><p>AAC（Advanced Audio Coding），中文称为“高级音频编码”，出现于1997年，最初是基于MPEG-2的音频编码技术，目的是取代MP3格式。2000年，MPEG-4标准出台，AAC重新集成了其特性，加入了SBR技术和PS技术，为区别于传统的MPEG-2 AAC，故含有SBR或PS特性的AAC又称为MPEG-4 AAC。
作为一种高压缩比的音频压缩算法，远胜MP3；在音质方面，由于采用多声道，和使用低复杂性的描述方式，使其比几乎所有的传统编码方式在同规格的情况下更胜一筹。一般来说，AAC可以在对比MP3文件缩小30%的前题下提供更好的音质。AAC是目前唯一一个，能够在所有的EBU试听测试项目的获得“优秀”的网络广播格式。</p></blockquote>

<p>AAC与MP3规格对比</p>

<pre><code>比特率：AAC - 最高超过400kbps / MP3 - 32~320kbps
采样率：AAC - 最高96kHz / MP3 - 最高48kHz
声道数：AAC - （5.1）六声道 / MP3 - 两声道
采样精度：AAC - 最高32bit / MP3 - 最高16bit
</code></pre>

<p>iTunes Plus优势简单总结</p>

<pre><code>1、更高的音质，更小的容量。（256Kbps的iTunes Plus AAC优于320Kbps的MP3，接近无损。）
2、正确完整无杂质的曲目ID3信息，内嵌官方唱片封面。
3、正版身份，值得收藏。
</code></pre>

<hr />

<pre><code>Q Q：2211523682/790806573

微信：18370997821/13148454507

微博WB:http://weibo.com/u/3288975567?is_hot=1

git博文：http://al1020119.github.io/

github：https://github.com/al1020119
</code></pre>

<p><img src="http://al1020119.github.io/images/iCocosCoder.jpg" title="Caption" ></p>

<p><img src="http://al1020119.github.io/images/iCocosPublic.jpg" title="Caption" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于直播]]></title>
    <link href="http://al1020119.github.io/blog/2016/09/01/guan-yu-zhi-bo/"/>
    <updated>2016-09-01T14:39:39+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/09/01/guan-yu-zhi-bo</id>
    <content type="html"><![CDATA[<p><img src="http://al1020119.github.io/images/zhibo001.png" title="Caption" ></p>

<p>关于直播，这里先推荐几篇相关的文字，都是非常经典的，虽然有些难，直播本来就很难，不难还叫直播吗？是吧！</p>

<p><a href="http://www.zhihu.com/question/42162310">知乎经典问答直播：如何搭建一个完整的视频直播系统？</a></p>

<!--more-->


<h4>关于直播,所有的技术细节都在这里了</h4>

<p><a href="http://mini.eastday.com/a/160511190456604-2.html">http://mini.eastday.com/a/160511190456604-2.html</a></p>

<p><a href="http://toutiao.com/i6283358665676161538/">http://toutiao.com/i6283358665676161538/</a></p>

<p><a href="http://www.csdn.net/article/a/2016-05-20/15821126">http://www.csdn.net/article/a/2016-05-20/15821126</a></p>

<p><a href="http://mini.eastday.com/a/160523102622452-4.html">http://mini.eastday.com/a/160523102622452-4.html</a></p>

<p>直播其实之前好早就存在，只是真正火起来是在今年上半年，一下子各大公司都打算开始着手直播，当然直播虽然赚钱，但是重点是得先烧钱 ，而且不是一般的App那么烧钱。</p>

<p>后面的文章系列就以直播为主题开始摘取和总结一系列的相关技术与知识。</p>

<p><img src="http://al1020119.github.io/images/zhibo002.png" title="Caption" ></p>

<hr />

<pre><code>Q Q：2211523682/790806573

微信：18370997821/13148454507

微博WB:http://weibo.com/u/3288975567?is_hot=1

git博文：http://al1020119.github.io/

github：https://github.com/al1020119
</code></pre>

<p><img src="http://al1020119.github.io/images/iCocosCoder.jpg" title="Caption" ></p>

<p><img src="http://al1020119.github.io/images/iCocosPublic.jpg" title="Caption" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[多线程安全？各种锁的实现原理😂]]></title>
    <link href="http://al1020119.github.io/blog/2016/08/31/duo-xian-cheng-an-quan-%3Fge-chong-suo-de-shi-xian-yuan-li/"/>
    <updated>2016-08-31T15:06:21+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/08/31/duo-xian-cheng-an-quan-?ge-chong-suo-de-shi-xian-yuan-li</id>
    <content type="html"><![CDATA[<p>本文要做的就是简单的分析 iOS 开发中常见的几种锁如何实现，以及优缺点是什么，为什么会有性能上的差距，最终会简单的介绍锁的底层实现原理。水平有限，如果不慎有误，欢迎交流指正。同时建议读者在阅读本文以前，对 OC 中各种锁的使用方法先有大概的认识。</p>

<p>在 ibireme 的 不再安全的 OSSpinLock 一文中，有一张图片简单的比较了各种锁的加解锁性能:</p>

<p><img src="http://al1020119.github.io/images/duoxianchengsuoshixianyuanli001.png" title="Caption" ></p>

<p>本文会按照从上至下(速度由快至慢)的顺序分析每个锁的实现原理。需要说明的是，加解锁速度不表示锁的效率，只表示加解锁操作在执行时的复杂程度，下文会通过具体的例子来解释。</p>

<h2>OSSpinLock</h2>

<p>上述文章中已经介绍了 OSSpinLock 不再安全，主要原因发生在低优先级线程拿到锁时，高优先级线程进入忙等(busy-wait)状态，消耗大量 CPU 时间，从而导致低优先级线程拿不到 CPU 时间，也就无法完成任务并释放锁。这种问题被称为优先级反转。</p>

<p>为什么忙等会导致低优先级线程拿不到时间片？这还得从操作系统的线程调度说起。</p>

<pre><code>现代操作系统在管理普通线程时，通常采用时间片轮转算法(Round Robin，简称 RR)。每个线程会被分配一段时间片(quantum)，通常在 10-100 毫秒左右。当线程用完属于自己的时间片以后，就会被操作系统挂起，放入等待队列中，直到下一次被分配时间片。
</code></pre>

<h4>自旋锁的实现原理</h4>

<p>自旋锁的目的是为了确保临界区只有一个线程可以访问，它的使用可以用下面这段伪代码来描述:</p>

<pre><code>do {

    Acquire Lock

        Critical section  // 临界区

    Release Lock

        Reminder section // 不需要锁保护的代码

}
</code></pre>

<p>在 Acquire Lock 这一步，我们申请加锁，目的是为了保护临界区(Critical Section) 中的代码不会被多个线程执行。</p>

<p>自旋锁的实现思路很简单，理论上来说只要定义一个全局变量，用来表示锁的可用情况即可，伪代码如下:</p>

<pre><code>bool lock = false; // 一开始没有锁上，任何线程都可以申请锁

do {

    while(lock); // 如果 lock 为 true 就一直死循环，相当于申请锁

    lock = true; // 挂上锁，这样别的线程就无法获得锁

        Critical section  // 临界区

    lock = false; // 相当于释放锁，这样别的线程可以进入临界区

        Reminder section // 不需要锁保护的代码        

}
</code></pre>

<p>注释写得很清楚，就不再逐行分析了。可惜这段代码存在一个问题: 如果一开始有多个线程同时执行 while 循环，他们都不会在这里卡住，而是继续执行，这样就无法保证锁的可靠性了。解决思路也很简单，只要确保申请锁的过程是原子操作即可。</p>

<h4>原子操作</h4>

<p>狭义上的原子操作表示一条不可打断的操作，也就是说线程在执行操作过程中，不会被操作系统挂起，而是一定会执行完。在单处理器环境下，一条汇编指令显然是原子操作，因为中断也要通过指令来实现。</p>

<blockquote><p>然而在多处理器的情况下，能够被多个处理器同时执行的操作任然算不上原子操作。因此，真正的原子操作必须由硬件提供支持，比如 x86 平台上如果在指令前面加上 “LOCK” 前缀，对应的机器码在执行时会把总线锁住，使得其他 CPU不能再执行相同操作，从而从硬件层面确保了操作的原子性。</p></blockquote>

<p>这些非常底层的概念无需完全掌握，我们只要知道上述申请锁的过程，可以用一个原子性操作 test_and_set 来完成，它用伪代码可以这样表示:</p>

<pre><code>bool test_and_set (bool *target) {

    bool rv = *target; 

    *target = TRUE; 

    return rv;

}
</code></pre>

<p>这段代码的作用是把 target 的值设置为 1，并返回原来的值。当然，在具体实现时，它通过一个原子性的指令来完成。</p>

<h4>自旋锁的总结</h4>

<p>至此，自旋锁的实现原理就很清楚了:</p>

<pre><code>bool lock = false; // 一开始没有锁上，任何线程都可以申请锁

do {

    while(test_and_set(&amp;lock); // test_and_set 是一个原子操作

        Critical section  // 临界区

    lock = false; // 相当于释放锁，这样别的线程可以进入临界区

        Reminder section // 不需要锁保护的代码        

}
</code></pre>

<p>如果临界区的执行时间过长，使用自旋锁不是个好主意。之前我们介绍过时间片轮转算法，线程在多种情况下会退出自己的时间片。其中一种是用完了时间片的时间，被操作系统强制抢占。除此以外，当线程进行 I/O 操作，或进入睡眠状态时，都会主动让出时间片。显然在 while 循环中，线程处于忙等状态，白白浪费 CPU 时间，最终因为超时被操作系统抢占时间片。如果临界区执行时间较长，比如是文件读写，这种忙等是毫无必要的。</p>

<h2>信号量</h2>

<p>之前我在 介绍 GCD 底层实现的文章 中简单描述了信号量 dispatch_semaphore_t 的实现原理，它最终会调用到 sem_wait 方法，这个方法在 glibc 中被实现如下:</p>

<pre><code>int sem_wait (sem_t *sem) {

  int *futex = (int *) sem;

  if (atomic_decrement_if_positive (futex) &gt; 0)

    return 0;

  int err = lll_futex_wait (futex, 0);

    return -1;

)
</code></pre>

<p>首先会把信号量的值减一，并判断是否大于零。如果大于零，说明不用等待，所以立刻返回。具体的等待操作在 lll_futex_wait 函数中实现，lll 是 low level lock 的简称。这个函数通过汇编代码实现，调用到 SYS_futex 这个系统调用，使线程进入睡眠状态，主动让出时间片，这个函数在互斥锁的实现中，也有可能被用到。</p>

<ul>
<li>主动让出时间片并不总是代表效率高。让出时间片会导致操作系统切换到另一个线程，这种上下文切换通常需要 10 微秒左右，而且至少需要两次切换。如果等待时间很短，比如只有几个微秒，忙等就比线程睡眠更高效。</li>
</ul>


<p>可以看到，自旋锁和信号量的实现都非常简单，这也是两者的加解锁耗时分别排在第一和第二的原因。再次强调，加解锁耗时不能准确反应出锁的效率(比如时间片切换就无法发生)，它只能从一定程度上衡量锁的实现复杂程度。</p>

<h2>pthread_mutex</h2>

<p>pthread 表示 POSIX thread，定义了一组跨平台的线程相关的 API，pthread_mutex 表示互斥锁。互斥锁的实现原理与信号量非常相似，不是使用忙等，而是阻塞线程并睡眠，需要进行上下文切换。</p>

<p>互斥锁的常见用法如下:</p>

<pre><code>pthread_mutexattr_t attr;

pthread_mutexattr_init(&amp;attr);

pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_NORMAL);  // 定义锁的属性



pthread_mutex_t mutex;

pthread_mutex_init(&amp;mutex, &amp;attr) // 创建锁



pthread_mutex_lock(&amp;mutex); // 申请锁

    // 临界区

pthread_mutex_unlock(&amp;mutex); // 释放锁
</code></pre>

<p>对于 pthread_mutex 来说，它的用法和之前没有太大的改变，比较重要的是锁的类型，可以有 PTHREAD_MUTEX_NORMAL、PTHREAD_MUTEX_ERRORCHECK、PTHREAD_MUTEX_RECURSIVE 等等，具体的特性就不做解释了，网上有很多相关资料。</p>

<blockquote><p>一般情况下，一个线程只能申请一次锁，也只能在获得锁的情况下才能释放锁，多次申请锁或释放未获得的锁都会导致崩溃。假设在已经获得锁的情况下再次申请锁，线程会因为等待锁的释放而进入睡眠状态，因此就不可能再释放锁，从而导致死锁。</p></blockquote>

<p>然而这种情况经常会发生，比如某个函数申请了锁，在临界区内又递归调用了自己。辛运的是 pthread_mutex 支持递归锁，也就是允许一个线程递归的申请锁，只要把 attr 的类型改成 PTHREAD_MUTEX_RECURSIVE 即可。</p>

<h2>互斥锁的实现</h2>

<p>互斥锁在申请锁时，调用了 pthread_mutex_lock 方法，它在不同的系统上实现各有不同，有时候它的内部是使用信号量来实现，即使不用信号量，也会调用到 lll_futex_wait 函数，从而导致线程休眠。</p>

<blockquote><p>上文说到如果临界区很短，忙等的效率也许更高，所以在有些版本的实现中，会首先尝试一定次数(比如 1000 次)的 test_and_test，这样可以在错误使用互斥锁时提高性能。</p></blockquote>

<p>另外，由于 pthread_mutex 有多种类型，可以支持递归锁等，因此在申请加锁时，需要对锁的类型加以判断，这也就是为什么它和信号量的实现类似，但效率略低的原因。</p>

<h2>NSLock</h2>

<p>NSLock 是 Objective-C 以对象的形式暴露给开发者的一种锁，它的实现非常简单，通过宏，定义了 lock 方法:</p>

<pre><code>#define    MLOCK \

- (void) lock\

{\

  int err = pthread_mutex_lock(&amp;_mutex);\

  // 错误处理 ……

}
</code></pre>

<p>NSLock 只是在内部封装了一个 pthread_mutex，属性为 PTHREAD_MUTEX_ERRORCHECK，它会损失一定性能换来错误提示。</p>

<p>这里使用宏定义的原因是，OC 内部还有其他几种锁，他们的 lock 方法都是一模一样，仅仅是内部 pthread_mutex 互斥锁的类型不同。通过宏定义，可以简化方法的定义。</p>

<blockquote><p>NSLock 比 pthread_mutex 略慢的原因在于它需要经过方法调用，同时由于缓存的存在，多次方法调用不会对性能产生太大的影响。</p></blockquote>

<h2>NSCondition</h2>

<p>NSCondition 的底层是通过条件变量(condition variable) pthread_cond_t 来实现的。条件变量有点像信号量，提供了线程阻塞与信号机制，因此可以用来阻塞某个线程，并等待某个数据就绪，随后唤醒线程，比如常见的生产者-消费者模式。</p>

<h4>如何使用条件变量</h4>

<p>很多介绍 pthread_cond_t 的文章都会提到，它需要与互斥锁配合使用:</p>

<pre><code>void consumer () { // 消费者

    pthread_mutex_lock(&amp;mutex);

    while (data == NULL) {

        pthread_cond_wait(&amp;condition_variable_signal, &amp;mutex); // 等待数据

    }

    // --- 有新的数据，以下代码负责处理 ↓↓↓↓↓↓

    // temp = data;

    // --- 有新的数据，以上代码负责处理 ↑↑↑↑↑↑

    pthread_mutex_unlock(&amp;mutex);

}



void producer () {

    pthread_mutex_lock(&amp;mutex);

    // 生产数据

    pthread_cond_signal(&amp;condition_variable_signal); // 发出信号给消费者，告诉他们有了新的数据

    pthread_mutex_unlock(&amp;mutex);

}
</code></pre>

<p>自然我们会有疑问:“如果不用互斥锁，只用条件变量会有什么问题呢？”。问题在于，temp = data; 这段代码不是线程安全的，也许在你把 data 读出来以前，已经有别的线程修改了数据。因此我们需要保证消费者拿到的数据是线程安全的。</p>

<p>wait 方法除了会被 signal 方法唤醒，有时还会被虚假唤醒，所以需要这里 while 循环中的判断来做二次确认。</p>

<h4>为什么要使用条件变量</h4>

<p>介绍条件变量的文章非常多，但大多都对一个一个基本问题避而不谈:“为什么要用条件变量？它仅仅是控制了线程的执行顺序，用信号量或者互斥锁能不能模拟出类似效果？”</p>

<p>网上的相关资料比较少，我简单说一下个人看法。信号量可以一定程度上替代 condition，但是互斥锁不行。在以上给出的生产者-消费者模式的代码中， pthread_cond_wait 方法的本质是锁的转移，消费者放弃锁，然后生产者获得锁，同理，pthread_cond_signal 则是一个锁从生产者到消费者转移的过程。</p>

<p>如果使用互斥锁，我们需要把代码改成这样:</p>

<pre><code>void consumer () { // 消费者

    pthread_mutex_lock(&amp;mutex);

    while (data == NULL) {

        pthread_mutex_unlock(&amp;mutex);

        pthread_mutex_lock(&amp;another_lock)  // 相当于 wait 另一个互斥锁

        pthread_mutex_lock(&amp;mutex);

    }

    pthread_mutex_unlock(&amp;mutex);

}
</code></pre>

<p>这样做存在的问题在于，在等待 another_lock 之前， 生产者有可能先执行代码， 从而释放了 another_lock。也就是说，我们无法保证释放锁和等待另一个锁这两个操作是原子性的，也就无法保证“先等待、后释放 another_lock” 这个顺序。</p>

<blockquote><p>用信号量则不存在这个问题，因为信号量的等待和唤醒并不需要满足先后顺序，信号量只表示有多少个资源可用，因此不存在上述问题。然而与 pthread_cond_wait 保证的原子性锁转移相比，使用信号量似乎存在一定风险(暂时没有查到非原子性操作有何不妥)。</p></blockquote>

<p>不过，使用 condition 有一个好处，我们可以调用 pthread_cond_broadcast 方法通知所有等待中的消费者，这是使用信号量无法实现的。</p>

<h2>NSCondition 的做法</h2>

<p>NSCondition 其实是封装了一个互斥锁和条件变量， 它把前者的 lock 方法和后者的 wait/signal 统一在 NSCondition 对象中，暴露给使用者:</p>

<pre><code>- (void) signal {

  pthread_cond_signal(&amp;_condition);

}



// 其实这个函数是通过宏来定义的，展开后就是这样

- (void) lock {

  int err = pthread_mutex_lock(&amp;_mutex);

}
</code></pre>

<p>它的加解锁过程与 NSLock 几乎一致，理论上来说耗时也应该一样(实际测试也是如此)。在图中显示它耗时略长，我猜测有可能是测试者在每次加解锁的前后还附带了变量的初始化和销毁操作。</p>

<h2>NSRecursiveLock</h2>

<p>上文已经说过，递归锁也是通过 pthread_mutex_lock 函数来实现，在函数内部会判断锁的类型，如果显示是递归锁，就允许递归调用，仅仅将一个计数器加一，锁的释放过程也是同理。</p>

<blockquote><p>NSRecursiveLock 与 NSLock 的区别在于内部封装的 pthread_mutex_t 对象的类型不同，前者的类型为 PTHREAD_MUTEX_RECURSIVE。</p></blockquote>

<h2>NSConditionLock</h2>

<p>NSConditionLock 借助 NSCondition 来实现，它的本质就是一个生产者-消费者模型。“条件被满足”可以理解为生产者提供了新的内容。NSConditionLock 的内部持有一个 NSCondition 对象，以及 _condition_value 属性，在初始化时就会对这个属性进行赋值:</p>

<pre><code>// 简化版代码

- (id) initWithCondition: (NSInteger)value {

    if (nil != (self = [super init])) {

        _condition = [NSCondition new]

        _condition_value = value;

    }

    return self;

}
</code></pre>

<p>它的 lockWhenCondition 方法其实就是消费者方法:</p>

<pre><code>- (void) lockWhenCondition: (NSInteger)value {

    [_condition lock];

    while (value != _condition_value) {

        [_condition wait];

    }

}
</code></pre>

<p>对应的 unlockWhenCondition 方法则是生产者，使用了 broadcast 方法通知了所有的消费者:</p>

<pre><code>- (void) unlockWithCondition: (NSInteger)value {

    _condition_value = value;

    [_condition broadcast];

    [_condition unlock];

}
</code></pre>

<h2>@synchronized</h2>

<p>这其实是一个 OC 层面的锁， 主要是通过牺牲性能换来语法上的简洁与可读。</p>

<blockquote><p>我们知道 @synchronized 后面需要紧跟一个 OC 对象，它实际上是把这个对象当做锁来使用。这是通过一个哈希表来实现的，OC 在底层使用了一个互斥锁的数组(你可以理解为锁池)，通过对对象去哈希值来得到对应的互斥锁。</p></blockquote>

<p>具体的实现原理可以参考这篇文章: 关于 @synchronized，这儿比你想知道的还要多</p>

<blockquote><p>参考资料</p></blockquote>

<pre><code>pthread_mutex_lock

ThreadSafety

Difference between binary semaphore and mutex

关于 @synchronized，这儿比你想知道的还要多

pthread_mutex_lock.c 源码

[Pthread] Linux中的线程同步机制(二)–In Glibc

pthread的各种同步机制

pthread_cond_wait

Conditional Variable vs Semaphore
</code></pre>

<hr />

<pre><code>Q Q：2211523682/790806573

微信：18370997821/13148454507

微博WB:http://weibo.com/u/3288975567?is_hot=1

git博文：http://al1020119.github.io/

github：https://github.com/al1020119
</code></pre>

<p><img src="http://al1020119.github.io/images/iCocosCoder.jpg" title="Caption" ></p>

<p><img src="http://al1020119.github.io/images/iCocosPublic.jpg" title="Caption" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[多线程安全？应该不止这些😂！]]></title>
    <link href="http://al1020119.github.io/blog/2016/08/31/duo-xian-cheng-an-quan-%3Fying-gai-bu-zhi-zhe-xie-%3F!/"/>
    <updated>2016-08-31T12:33:27+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/08/31/duo-xian-cheng-an-quan-?ying-gai-bu-zhi-zhe-xie-?!</id>
    <content type="html"><![CDATA[<ul>
<li>前言</li>
<li>介绍与使用</li>
<li>总结</li>
<li>其他实战使用</li>
</ul>


<h2>一、前言</h2>

<p>前段时间看了几个开源项目，发现他们保持线程同步的方式各不相同，有@synchronized、NSLock、dispatch_semaphore、NSCondition、pthread_mutex、OSSpinLock。后来网上查了一下，发现他们的实现机制各不相同，性能也各不一样。不好意思，我们平常使用最多的@synchronized是性能最差的。下面我们先分别介绍每个加锁方式的使用，在使用一个案例来对他们进行性能对比。</p>

<h2>二、介绍与使用</h2>

<!--more-->


<h4>2.1、@synchronized</h4>

<pre><code>    NSObject *obj = [[NSObject alloc] init];



    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{

        @synchronized(obj) {

            NSLog(@"需要线程同步的操作1 开始");

            sleep(3);

            NSLog(@"需要线程同步的操作1 结束");

        }

    });



    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{

        sleep(1);

        @synchronized(obj) {

            NSLog(@"需要线程同步的操作2");

        }

    });
</code></pre>

<p>@synchronized(obj)指令使用的obj为该锁的唯一标识，只有当标识相同时，才为满足互斥，如果线程2中的@synchronized(obj)改为@synchronized(self),刚线程2就不会被阻塞，@synchronized指令实现锁的优点就是我们不需要在代码中显式的创建锁对象，便可以实现锁的机制，但作为一种预防措施，@synchronized块会隐式的添加一个异常处理例程来保护代码，该处理例程会在异常抛出的时候自动的释放互斥锁。所以如果不想让隐式的异常处理例程带来额外的开销，你可以考虑使用锁对象。</p>

<p>上面结果的执行结果为：</p>

<pre><code>2016-06-29 20:48:35.747 SafeMultiThread[35945:580107] 需要线程同步的操作1 开始

2016-06-29 20:48:38.748 SafeMultiThread[35945:580107] 需要线程同步的操作1 结束

2016-06-29 20:48:38.749 SafeMultiThread[35945:580118] 需要线程同步的操作2
</code></pre>

<h4>2.2、dispatch_semaphore</h4>

<pre><code>dispatch_semaphore_t signal = dispatch_semaphore_create(1);

    dispatch_time_t overTime = dispatch_time(DISPATCH_TIME_NOW, 3 * NSEC_PER_SEC);



    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{

        dispatch_semaphore_wait(signal, overTime);

            NSLog(@"需要线程同步的操作1 开始");

            sleep(2);

            NSLog(@"需要线程同步的操作1 结束");

        dispatch_semaphore_signal(signal);

    });



    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{

        sleep(1);

        dispatch_semaphore_wait(signal, overTime);

            NSLog(@"需要线程同步的操作2");

        dispatch_semaphore_signal(signal);

    });
</code></pre>

<p>dispatch_semaphore是GCD用来同步的一种方式，与他相关的共有三个函数，分别是dispatch_semaphore_create，dispatch_semaphore_signal，dispatch_semaphore_wait。</p>

<h6>（1）dispatch_semaphore_create的声明为：</h6>

<pre><code>dispatch_semaphore_t dispatch_semaphore_create(long value);
</code></pre>

<p>传入的参数为long，输出一个dispatch_semaphore_t类型且值为value的信号量。</p>

<p>值得注意的是，这里的传入的参数value必须大于或等于0，否则dispatch_semaphore_create会返回NULL。</p>

<h6>（2）dispatch_semaphore_signal的声明为：</h6>

<pre><code>long dispatch_semaphore_signal(dispatch_semaphore_t dsema)
</code></pre>

<p>这个函数会使传入的信号量dsema的值加1；</p>

<h6>(3) dispatch_semaphore_wait的声明为：</h6>

<pre><code>long dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)；
</code></pre>

<p>这个函数会使传入的信号量dsema的值减1；这个函数的作用是这样的，如果dsema信号量的值大于0，该函数所处线程就继续执行下面的语句，并且将信号量的值减1；如果desema的值为0，那么这个函数就阻塞当前线程等待timeout（注意timeout的类型为dispatch_time_t，不能直接传入整形或float型数），如果等待的期间desema的值被dispatch_semaphore_signal函数加1了，且该函数（即dispatch_semaphore_wait）所处线程获得了信号量，那么就继续向下执行并将信号量减1。如果等待期间没有获取到信号量或者信号量的值一直为0，那么等到timeout时，其所处线程自动执行其后语句。</p>

<p>dispatch_semaphore 是信号量，但当信号总量设为 1 时也可以当作锁来。在没有等待情况出现时，它的性能比 pthread_mutex 还要高，但一旦有等待情况出现时，性能就会下降许多。相对于 OSSpinLock 来说，它的优势在于等待时不会消耗 CPU 资源。</p>

<p>如上的代码，如果超时时间overTime设置成>2，可完成同步操作。如果overTime</p>

<p>上面代码的执行结果为：</p>

<pre><code>2016-06-29 20:47:52.324 SafeMultiThread[35945:579032] 需要线程同步的操作1 开始

2016-06-29 20:47:55.325 SafeMultiThread[35945:579032] 需要线程同步的操作1 结束

2016-06-29 20:47:55.326 SafeMultiThread[35945:579033] 需要线程同步的操作2
</code></pre>

<p>如果把超时时间设置为</p>

<pre><code>2016-06-30 18:53:24.049 SafeMultiThread[30834:434334] 需要线程同步的操作1 开始

2016-06-30 18:53:25.554 SafeMultiThread[30834:434332] 需要线程同步的操作2

2016-06-30 18:53:26.054 SafeMultiThread[30834:434334] 需要线程同步的操作1 结束
</code></pre>

<h4>2.3、NSLock</h4>

<pre><code>   NSLock *lock = [[NSLock alloc] init];

    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{

        //[lock lock];

        [lock lockBeforeDate:[NSDate date]];

            NSLog(@"需要线程同步的操作1 开始");

            sleep(2);

            NSLog(@"需要线程同步的操作1 结束");

        [lock unlock];



    });



    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{

        sleep(1);

        if ([lock tryLock]) {//尝试获取锁，如果获取不到返回NO，不会阻塞该线程

            NSLog(@"锁可用的操作");

            [lock unlock];

        }else{

            NSLog(@"锁不可用的操作");

        }



        NSDate *date = [[NSDate alloc] initWithTimeIntervalSinceNow:3];

        if ([lock lockBeforeDate:date]) {//尝试在未来的3s内获取锁，并阻塞该线程，如果3s内获取不到恢复线程, 返回NO,不会阻塞该线程

            NSLog(@"没有超时，获得锁");

            [lock unlock];

        }else{

            NSLog(@"超时，没有获得锁");

        }



    });
</code></pre>

<p>NSLock是Cocoa提供给我们最基本的锁对象，这也是我们经常所使用的，除lock和unlock方法外，NSLock还提供了tryLock和lockBeforeDate:两个方法，前一个方法会尝试加锁，如果锁不可用(已经被锁住)，刚并不会阻塞线程，并返回NO。lockBeforeDate:方法会在所指定Date之前尝试加锁，如果在指定时间之前都不能加锁，则返回NO。</p>

<p>上面代码的执行结果为：</p>

<pre><code>2016-06-29 20:45:08.864 SafeMultiThread[35911:575795] 需要线程同步的操作1 开始

2016-06-29 20:45:09.869 SafeMultiThread[35911:575781] 锁不可用的操作

2016-06-29 20:45:10.869 SafeMultiThread[35911:575795] 需要线程同步的操作1 结束

2016-06-29 20:45:10.870 SafeMultiThread[35911:575781] 没有超时，获得锁
</code></pre>

<p>源码定义如下：</p>

<pre><code>@protocol NSLocking



- (void)lock;

- (void)unlock;



@end



@interface NSLock : NSObject  {

&lt;a href="http://www.jobbole.com/members/kaishu6296"&gt;@private&lt;/a&gt;

    void *_priv;

}



- (BOOL)tryLock;

- (BOOL)lockBeforeDate:(NSDate *)limit;



@property (nullable, copy) NSString *name NS_AVAILABLE(10_5, 2_0);



@end
</code></pre>

<h4>2.4、NSRecursiveLock递归锁</h4>

<pre><code>    //NSLock *lock = [[NSLock alloc] init];

    NSRecursiveLock *lock = [[NSRecursiveLock alloc] init];



    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{



        static void (^RecursiveMethod)(int);



        RecursiveMethod = ^(int value) {



            [lock lock];

            if (value &gt; 0) {



                NSLog(@"value = %d", value);

                sleep(1);

                RecursiveMethod(value - 1);

            }

            [lock unlock];

        };



        RecursiveMethod(5);

    });
</code></pre>

<p>NSRecursiveLock实际上定义的是一个递归锁，这个锁可以被同一线程多次请求，而不会引起死锁。这主要是用在循环或递归操作中。</p>

<p>这段代码是一个典型的死锁情况。在我们的线程中，RecursiveMethod是递归调用的。所以每次进入这个block时，都会去加一次锁，而从第二次开始，由于锁已经被使用了且没有解锁，所以它需要等待锁被解除，这样就导致了死锁，线程被阻塞住了。调试器中会输出如下信息：</p>

<pre><code>2016-06-30 19:08:06.393 SafeMultiThread[30928:449008] value = 5

2016-06-30 19:08:07.399 SafeMultiThread[30928:449008] -[NSLock lock]: deadlock ( ‘(null)’)

2016-06-30 19:08:07.399 SafeMultiThread[30928:449008] Break on _NSLockError() to debug.
</code></pre>

<p>在这种情况下，我们就可以使用NSRecursiveLock。它可以允许同一线程多次加锁，而不会造成死锁。递归锁会跟踪它被lock的次数。每次成功的lock都必须平衡调用unlock操作。只有所有达到这种平衡，锁最后才能被释放，以供其它线程使用。</p>

<p>如果我们将NSLock代替为NSRecursiveLock，上面代码则会正确执行。</p>

<pre><code>2016-06-30 19:09:41.414 SafeMultiThread[30949:450684] value = 5

2016-06-30 19:09:42.418 SafeMultiThread[30949:450684] value = 4

2016-06-30 19:09:43.419 SafeMultiThread[30949:450684] value = 3

2016-06-30 19:09:44.424 SafeMultiThread[30949:450684] value = 2

2016-06-30 19:09:45.426 SafeMultiThread[30949:450684] value = 1
</code></pre>

<p>如果需要其他功能，源码定义如下：</p>

<pre><code>@interface NSRecursiveLock : NSObject  {

&lt;a href="http://www.jobbole.com/members/kaishu6296"&gt;@private&lt;/a&gt;

    void *_priv;

}



- (BOOL)tryLock;

- (BOOL)lockBeforeDate:(NSDate *)limit;



@property (nullable, copy) NSString *name NS_AVAILABLE(10_5, 2_0);



@end
</code></pre>

<h2>2.5、NSConditionLock条件锁</h2>

<pre><code>    NSMutableArray *products = [NSMutableArray array];



    NSInteger HAS_DATA = 1;

    NSInteger NO_DATA = 0;



    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{

        while (1) {

            [lock lockWhenCondition:NO_DATA];

            [products addObject:[[NSObject alloc] init]];

            NSLog(@"produce a product,总量:%zi",products.count);

            [lock unlockWithCondition:HAS_DATA];

            sleep(1);

        }



    });



    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{

        while (1) {

            NSLog(@"wait for product");

            [lock lockWhenCondition:HAS_DATA];

            [products removeObjectAtIndex:0];

            NSLog(@"custome a product");

            [lock unlockWithCondition:NO_DATA];

        }



    });
</code></pre>

<p>当我们在使用多线程的时候，有时一把只会lock和unlock的锁未必就能完全满足我们的使用。因为普通的锁只能关心锁与不锁，而不在乎用什么钥匙才能开锁，而我们在处理资源共享的时候，多数情况是只有满足一定条件的情况下才能打开这把锁：</p>

<p>在线程1中的加锁使用了lock，所以是不需要条件的，所以顺利的就锁住了，但在unlock的使用了一个整型的条件，它可以开启其它线程中正在等待这把钥匙的临界地，而线程2则需要一把被标识为2的钥匙，所以当线程1循环到最后一次的时候，才最终打开了线程2中的阻塞。但即便如此，NSConditionLock也跟其它的锁一样，是需要lock与unlock对应的，只是lock,lockWhenCondition:与unlock，unlockWithCondition:是可以随意组合的，当然这是与你的需求相关的。</p>

<p>上面代码执行结果如下：</p>

<pre><code>2016-06-30 20:31:58.699 SafeMultiThread[31282:521698] wait for product

2016-06-30 20:31:58.699 SafeMultiThread[31282:521708] produce a product,总量:1

2016-06-30 20:31:58.700 SafeMultiThread[31282:521698] custome a product

2016-06-30 20:31:58.700 SafeMultiThread[31282:521698] wait for product

2016-06-30 20:31:59.705 SafeMultiThread[31282:521708] produce a product,总量:1

2016-06-30 20:31:59.706 SafeMultiThread[31282:521698] custome a product

2016-06-30 20:31:59.706 SafeMultiThread[31282:521698] wait for product

2016-06-30 20:32:00.707 SafeMultiThread[31282:521708] produce a product,总量:1

2016-06-30 20:32:00.708 SafeMultiThread[31282:521698] custome a product
</code></pre>

<p>如果你需要其他功能，源码定义如下：</p>

<pre><code>@interface NSConditionLock : NSObject  {

&lt;a href="http://www.jobbole.com/members/kaishu6296"&gt;@private&lt;/a&gt;

    void *_priv;

}



- (instancetype)initWithCondition:(NSInteger)condition NS_DESIGNATED_INITIALIZER;



@property (readonly) NSInteger condition;

- (void)lockWhenCondition:(NSInteger)condition;

- (BOOL)tryLock;

- (BOOL)tryLockWhenCondition:(NSInteger)condition;

- (void)unlockWithCondition:(NSInteger)condition;

- (BOOL)lockBeforeDate:(NSDate *)limit;

- (BOOL)lockWhenCondition:(NSInteger)condition beforeDate:(NSDate *)limit;



@property (nullable, copy) NSString *name NS_AVAILABLE(10_5, 2_0);



@end
</code></pre>

<h4>2.6、NSCondition</h4>

<pre><code>   NSCondition *condition = [[NSCondition alloc] init];



    NSMutableArray *products = [NSMutableArray array];



    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{

        while (1) {

            [condition lock];

            if ([products count] == 0) {

                NSLog(@"wait for product");

                [condition wait];

            }

            [products removeObjectAtIndex:0];

            NSLog(@"custome a product");

            [condition unlock];

        }



    });



    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{

        while (1) {

            [condition lock];

            [products addObject:[[NSObject alloc] init]];

            NSLog(@"produce a product,总量:%zi",products.count);

            [condition signal];

            [condition unlock];

            sleep(1);

        }



    });
</code></pre>

<h6>一种最基本的条件锁。手动控制线程wait和signal。</h6>

<p>[condition lock];一般用于多线程同时访问、修改同一个数据源，保证在同一时间内数据源只被访问、修改一次，其他线程的命令需要在lock 外等待，只到unlock ，才可访问</p>

<pre><code>[condition unlock];与lock 同时使用



[condition wait];让当前线程处于等待状态



[condition signal];CPU发信号告诉线程不用在等待，可以继续执行
</code></pre>

<p>上面代码执行结果如下：</p>

<pre><code>2016-06-30 20:21:25.295 SafeMultiThread[31256:513991] wait for product

2016-06-30 20:21:25.296 SafeMultiThread[31256:513994] produce a product,总量:1

2016-06-30 20:21:25.296 SafeMultiThread[31256:513991] custome a product

2016-06-30 20:21:25.297 SafeMultiThread[31256:513991] wait for product

2016-06-30 20:21:26.302 SafeMultiThread[31256:513994] produce a product,总量:1

2016-06-30 20:21:26.302 SafeMultiThread[31256:513991] custome a product

2016-06-30 20:21:26.302 SafeMultiThread[31256:513991] wait for product

2016-06-30 20:21:27.307 SafeMultiThread[31256:513994] produce a product,总量:1

2016-06-30 20:21:27.308 SafeMultiThread[31256:513991] custome a product
</code></pre>

<h4>2.7、pthread_mutex</h4>

<pre><code>    __block pthread_mutex_t theLock;

    pthread_mutex_init(&amp;theLock, NULL);



    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{

            pthread_mutex_lock(&amp;theLock);

            NSLog(@"需要线程同步的操作1 开始");

            sleep(3);

            NSLog(@"需要线程同步的操作1 结束");

            pthread_mutex_unlock(&amp;theLock);



    });



    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{

            sleep(1);

            pthread_mutex_lock(&amp;theLock);

            NSLog(@"需要线程同步的操作2");

            pthread_mutex_unlock(&amp;theLock);



    });
</code></pre>

<p>c语言定义下多线程加锁方式。</p>

<pre><code>1：pthread_mutex_init(pthread_mutex_t mutex,const pthread_mutexattr_t attr);

初始化锁变量mutex。attr为锁属性，NULL值为默认属性。

2：pthread_mutex_lock(pthread_mutex_t mutex);加锁

3：pthread_mutex_tylock(*pthread_mutex_t *mutex);加锁，但是与2不一样的是当锁已经在使用的时候，返回为EBUSY，而不是挂起等待。

4：pthread_mutex_unlock(pthread_mutex_t *mutex);释放锁

5：pthread_mutex_destroy(pthread_mutex_t* mutex);使用完后释放
</code></pre>

<p>代码执行操作结果如下：</p>

<pre><code>2016-06-30 21:13:32.440 SafeMultiThread[31429:548869] 需要线程同步的操作1 开始

2016-06-30 21:13:35.445 SafeMultiThread[31429:548869] 需要线程同步的操作1 结束

2016-06-30 21:13:35.446 SafeMultiThread[31429:548866] 需要线程同步的操作2
</code></pre>

<h4>2.8、pthread_mutex(recursive)</h4>

<p>这是pthread_mutex为了防止在递归的情况下出现死锁而出现的递归锁。作用和NSRecursiveLock递归锁类似。</p>

<p>如果使用pthread_mutex_init(&amp;theLock, NULL);初始化锁的话，上面的代码会出现死锁现象。如果使用递归锁的形式，则没有问题。</p>

<h4>2.9、OSSpinLock</h4>

<p>OSSpinLock 自旋锁，性能最高的锁。原理很简单，就是一直 do while 忙等。它的缺点是当等待时会消耗大量 CPU 资源，所以它不适用于较长时间的任务。 不过最近YY大神在自己的博客不再安全的 OSSpinLock中说明了OSSpinLock已经不再安全，请大家谨慎使用。</p>

<p>三、性能对比</p>

<p>对以上各个锁进行1000000此的加锁解锁的空操作时间如下：</p>

<pre><code>OSSpinLock: 46.15 ms

dispatch_semaphore: 56.50 ms

pthread_mutex: 178.28 ms

NSCondition: 193.38 ms

NSLock: 175.02 ms

pthread_mutex(recursive): 172.56 ms

NSRecursiveLock: 157.44 ms

NSConditionLock: 490.04 ms

@synchronized: 371.17 ms
</code></pre>

<h2>三.总的来说：</h2>

<ul>
<li><p>OSSpinLock和dispatch_semaphore的效率远远高于其他。</p></li>
<li><p>@synchronized和NSConditionLock效率较差。</p></li>
<li><p>鉴于OSSpinLock的不安全，所以我们在开发中如果考虑性能的话，建议使用dispatch_semaphore。</p></li>
<li><p>如果不考虑性能，只是图个方便的话，那就使用@synchronized。</p>

<blockquote><p> 总感觉这个标题怪怪的,但是我自身词汇有限,也不知道怎么描述好了.用一个简单的需求来解释一下吧.我之前开发的一个项目,需要向服务器上传图片,多图片上传,然后每次上传之后会返回一个图片的AID, 然后需要所有图片上传完成之后, 拿着一个全是AID的数组作为参数进行另一个异步请求&hellip;好吧,我感觉又绕了&hellip;</p></blockquote>

<p>  前几天,我在一个技术交流圈,看到一个朋友去JINGDONG的面试题, 其中一个题目的描述是:有a、b、c、d 4个异步请求，如何判断a、b、c、d都完成执行？, 跟我上面的需求大同小异.</p>

<p>  所以在这儿,我把我工作中曾经用到过的一些方法做一个小的总结,有遗漏的或者错误的地方,请大家留意指正,非常感谢哈!!!</p>

<p>  特别注意:所有的代码都基于JINGDONG这道面试题, 不过我只打印了A和B而已..</p></li>
</ul>


<h2>四.实战应用</h2>

<p>我们公司App前段时间刚好有一个功能需求，就是关于发动态的时候图片上传的需求。以前一般来说的话，我们是讲所有图片打包一起发给服务器，但是这依稀不一样的是，必须每一张每一张的传，具体为什么老大说了一各位自己体会。</p>

<p>需求是：</p>

<ul>
<li>1：每次上传图片的时候必须一张一张的传。</li>
<li>2：上传完一张之后服务器返回给我们一个url，把他存起来</li>
<li>3：全部传完之后再把所有存起来的url一起通过json格式发送给服务器</li>
</ul>


<p>这里试了各种方法，问了各种大牛都没找到好的方法，只能说有些能解决，但是达不到非常满意的效果。这里总结一下常见的使用。</p>

<ol>
<li><p>RunLoop</p>

<p> 需要注意一点: 这儿用的是NSURLSession, 不是AFN, 所以block里面的线程是子线程,不是主线程, 不能直接使用CFRunLoopGetCurrent</p>

<pre><code> CFRunLoopGetCurrent : Returns the CFRunLoop object for the current thread.
 CFRunLoopGetMain: Returns the main CFRunLoop object.

 NSURLSessionDataTask *task = [[NSURLSession sharedSession] dataTaskWithRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:@"http://www.baidu.com"]] completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {
         NSLog(@"A");
         CFRunLoopStop(CFRunLoopGetMain());
     }] ;
     [task resume];
  CFRunLoopRun();
  NSLog(@"B");
</code></pre></li>
<li><p>GCD的group</p>

<p> dispatch_group_notify就是需要等queue里面的子线程都执行完毕之后才会执行
 这种方法比较常见, 不多说</p>

<pre><code> dispatch_group_t group = dispatch_group_create();
     dispatch_queue_t queue = dispatch_get_global_queue(0, 0);
     dispatch_group_async(group, queue, ^{
         NSLog(@"A");
     });
     dispatch_group_notify(group, dispatch_get_main_queue(), ^{
         NSLog(@"B");
     });
</code></pre></li>
<li><p>dispatch_barrier_async</p>

<p> barrier的中文意思就是障碍, 屏障
 一般使用dispatch_barrier_async, 会让barrier之前的线程执行完成之后才会执行barrier后面的操作</p>

<pre><code>  dispatch_queue_t queue =  dispatch_queue_create(0, DISPATCH_QUEUE_CONCURRENT);
     dispatch_async(queue, ^{
         NSLog(@"A");
     });
     dispatch_async(queue, ^{
         NSLog(@"C");
     });
     dispatch_barrier_async(queue, ^{
         NSLog(@"拿到了A的值");
     });

     dispatch_async(queue, ^{
         NSLog(@"D");
     });
     dispatch_async(queue, ^{
         NSLog(@"E");
     });dispatch_async(queue, ^{
         NSLog(@"F");
     });
</code></pre></li>
</ol>


<p>4.NSOperationQueue</p>

<p>   主要就是用到NSOperationQueue的一个对象方法-addDependency
   需要注意一点: waitUntilFinished如果是YES,必须等到queue中所有Operation执行完毕之后, 才会打印HAHA, 反之的话, HAHA的打印顺序是随机的了,就看哪个线程跑得快了&hellip;</p>

<pre><code>NSOperationQueue *queue = [[NSOperationQueue alloc] init];
    NSBlockOperation *p1 = [NSBlockOperation blockOperationWithBlock:^{
        NSLog(@"A");
    }];
    NSBlockOperation *p2 = [NSBlockOperation blockOperationWithBlock:^{
        NSLog(@"B");
    }];
    NSBlockOperation *p3 = [NSBlockOperation blockOperationWithBlock:^{
        NSLog(@"C");
    }];
    [p3 addDependency:p1];
    [p3 addDependency:p2];
    // waitUntilFinished是否阻塞当前线程
    [queue addOperations:@[p1,p2,p3] waitUntilFinished:NO];

    // 如果是NO,那么这行打印就是随机的, 反之就是等A,B,C都打印完之后才执行
    NSLog(@"HAHA");
</code></pre>

<ol>
<li><p>使用AFN中的batchOfRequestOperations</p>

<p> 这个和GCD一样, 我工作中比较常用的一种方法
 batchOfRequestOperations方法其实是AFHTTPRequestOperation的父类AFURLConnectionOperation的一个方法.
 这儿的waitUntilFinished同4. NSOperationQueue
 progressBlock一般用在进度计算中, 比如执行了多少百分比, 可以自定义一些炫酷动画</p>

<pre><code> AFHTTPRequestOperation *queue = [[AFHTTPRequestOperation alloc] initWithRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:@"http://www.baidu.com"]]];
     [queue setCompletionBlockWithSuccess:^(AFHTTPRequestOperation *operation, id responseObject) {
         NSLog(@"A");
     } failure:^(AFHTTPRequestOperation *operation, NSError *error) {
         NSLog(@"A");
     }];
     [queue resume];

 AFHTTPRequestOperation *queue2 = [[AFHTTPRequestOperation alloc] initWithRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:@"http://www.baidu.com"]]];
 [queue2 setCompletionBlockWithSuccess:^(AFHTTPRequestOperation *operation, id responseObject) {
     NSLog(@"B");
 } failure:^(AFHTTPRequestOperation *operation, NSError *error) {
     NSLog(@"B");
 }];
 [queue2 resume];

 NSArray *operations = [AFHTTPRequestOperation batchOfRequestOperations:@[queue, queue2] progressBlock:^(NSUInteger numberOfFinishedOperations, NSUInteger totalNumberOfOperations) {
     NSLog(@"%ld/%ld", numberOfFinishedOperations, totalNumberOfOperations);
 } completionBlock:^(NSArray *operations) {
     NSLog(@"C");
 }];

 [[NSOperationQueue mainQueue] addOperations:operations waitUntilFinished:NO];
</code></pre></li>
</ol>


<p>6.其他</p>

<pre><code>老早以前, 我一般是在一个异步请求中的completionBlock或者successBlock中拿到需要的值, 为空判断后,直接在block里面再写一个异步线程...其实这样的写法可能很多人都用过,但是代码的阅读性太弱了,花括号太多,看的眼花缭乱的...
其实还可以设置flag进行判断等等方法...
暂时就想到这么多, 还有别的方案的话, 欢迎留言哈,大家共同学习!!!
</code></pre>

<hr />

<pre><code>Q Q：2211523682/790806573

微信：18370997821/13148454507

微博WB:http://weibo.com/u/3288975567?is_hot=1

git博文：http://al1020119.github.io/

github：https://github.com/al1020119
</code></pre>

<p><img src="http://al1020119.github.io/images/iCocosCoder.jpg" title="Caption" ></p>

<p><img src="http://al1020119.github.io/images/iCocosPublic.jpg" title="Caption" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[修行篇-ios开发中常见设计模式]]></title>
    <link href="http://al1020119.github.io/blog/2016/08/30/xiu-xing-pian-ioskai-fa-zhong-chang-jian-she-ji-mo-shi/"/>
    <updated>2016-08-30T13:10:04+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/08/30/xiu-xing-pian-ioskai-fa-zhong-chang-jian-she-ji-mo-shi</id>
    <content type="html"><![CDATA[<p>本文摘自：<a href="http://ios.jobbole.com/85360/">伯乐在线</a>,因为自己研究并学习ios设计模式的时候寻找了好多相关文章，最后发现这篇才是最适合ios开发的，当然你也可以自己通过C或者java设计模式的规范进行演变。</p>

<p>源码下载地址：<a href="https://github.com/al1020119/iCocosDesignPattern">https://github.com/al1020119/iCocosDesignPattern</a></p>

<h1>对象创建</h1>

<h4>原型（Prototype）</h4>

<p>使用原型实例指定创建对象的种类，并通过复制这个原型创建新的对象。</p>

<pre><code>NSArray *array = [[NSArray alloc] initWithObjects:@1, nil];
NSArray *array2 = array.copy;
</code></pre>

<p>array 就是原型了，array2 以 array 为原型，通过 copy 操作创建了 array2。</p>

<p>当创建的实例非常复杂且耗时，或者新实例和已存在的实例值相同，使用原型模式去复制已经存在的实例效率更高。</p>

<h4>工厂方法（Factory Method）</h4>

<pre><code>定义创建对象的接口，让子类决定实例化哪一个类。工厂方法使得类的实例化延迟到其子类。
</code></pre>

<p>工厂方法是针对每一种产品提供一个工厂类。通过不同的工厂类来创建不同的产品实例。</p>

<p><img src="http://al1020119.github.io/images/iosshejimoshi001.png" title="Caption" ></p>

<ul>
<li>如上图，+ create():Product 就是工厂方法，ConcreatFactoryA 与 ConcreateFactoryB 就是两个工厂类，ConcreateProductA 与 ConcreateProductB 就是两个工厂类对应的产品类，通过不同的工厂生产不同类型的产品，且两个产品类最终返回的是他们的父类 Product，隐藏了对象的具体类型。工厂方法模式让创建的对象拥有一组共同的接口，使我们无需关心做了不同类型接口的具体实现，只需要调用 Product 的接口就行。</li>
</ul>


<blockquote><p>工厂方法模式的扩展性也很好，新增的产品类并不需要修改客户端代码。但每新加一个产品类都需要新建一个工厂类，会造成项目中的类过多。</p></blockquote>

<p>而在 Cocoa Touch 框架中，以 NSNumber 举例，将原有的 alloc+init 拆开写：</p>

<pre><code> id obj1 = [NSNumber alloc];
    id obj2 = [NSNumber alloc];
    id obj3 = [obj1 initWithBool:YES];
</code></pre>

<p>发现 + alloc 后并非生成了我们期望的类实例，而是一个NSPlacehodlerNumber 的中间对象，后面的 – initWithXXXXX 消息都是发送给这个中间对象，再由它做工厂，生成真的对象。如 obj3 的实际类型为 NSCFBoolean，而 obj4 的实际类型为 NSCFNumber 。</p>

<h4>抽象工厂（Abstract Factory）</h4>

<pre><code>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。
</code></pre>

<p><img src="http://al1020119.github.io/images/iosshejimoshi002.png" title="Caption" ></p>

<ul>
<li>如上图，抽象工厂有一个产品族的概念，Factory1 与 Factory2 是继承 AbstractFactory 的两个产品族工厂类， 继承了父类创建 A，B 两个产品的方法，不同产品族工厂类会创建不同类型的产品，最终返回了不同的产品族对象，既 ProductA 和 ProductB。</li>
</ul>


<p>在 Cocoa Touch 框架中，类簇是抽象工厂模式在 iOS 下的一种实现，以 NSArray 举例，将原有的 alloc+init 拆开写：</p>

<pre><code>id obj1 = [NSArray alloc]; // __NSPlacehodlerArray *
id obj2 = [NSMutableArray alloc];  // __NSPlacehodlerArray *
id obj3 = [obj1 init];  // __NSArrayI *
id obj4 = [obj2 init];  // __NSArrayM *
</code></pre>

<p>发现 + alloc 后并非生成了我们期望的类实例，而是一个NSPlacehodlerArray 的中间对象，后面的 – init 或 – initWithXXXXX 消息都是发送给这个中间对象，再由它做工厂，生成真的对象。这里的 NSArrayI 和 __NSArrayM 分别对应 Immutable 和 Mutable（后面的 I 和 M 的意思）</p>

<blockquote><p>于是顺着思路猜实现，__NSPlacehodlerArray 必定用某种方式存储了它是由谁 alloc 出来的这个信息，才能在 init 的时候知道要创建的是可变数组还是不可变数组。</p></blockquote>

<p>抽象工厂将一系列的产品族统一到一起创建，增加产品族很方便，但增加产品很麻烦，需要改动太多的类的接口。</p>

<h4>生成器（Builder）</h4>

<p>将一个复杂对象的构建与它的表现分离，使得同样的构建过程可以创建不同的表现。
生成器可以将构建对象的过程分为，客户 – 指导者 – 生成器 的关系，</p>

<pre><code>CharacterBuilder *characterBuilder = [[StandarCharacterBuilder alloc] init];
ChasingGame *game = [[ChasingGame alloc] init];

Character *player = [chasingGame createPlayer:characterBuilder];
Character *enemy = [chasingGame createEnemy:characterBuilder];
</code></pre>

<p>characterBuilder 就是生成器了，而 game 就是指导者。指导者里声明了创建不同表现的对象的方法。而方法里由生成器 characterBuilder 来构建不同的 Character 类型的对象。</p>

<ul>
<li>生成器模式将复杂的生成对象的过程交给了生成器去完成，作为客户的我们只需要根据简单的接口去生成不同表现的对象。如上述代码中的 player 以及 enemy。玩家和敌人具体的属性数值我们不需要去设置，而是交给生成器去设置。</li>
</ul>


<h4>单例（Singleton）</h4>

<pre><code>保证一个类仅有一个实例，并提供一个访问它的全局访问点。
</code></pre>

<p>在 Cocoa Touch 框架中，最常见的使用了单例模式的就是 UIApplication 类了。每个应用程序有且仅有一个 UIApplication 的实例，它由 UIApplicationMain 函数在程序启动时创建为单例对象，之后，对同一 UIApplication 实例可以通过其 sharedApplication 类方法进行访问。</p>

<p>单例用来集中管理对类的对象所提供的资源，例如应用程序中需要用集中式的类来协调其服务，这个类就应该生成单一的实例。</p>

<ul>
<li>单例模式在多线程的应用场合下必须小心使用。如果当唯一实例尚未创建时，有两个线程同时调用创建方法，那么它们同时没有检测到唯一实例的存在，从而同时各自创建了一个实例，这样就有两个实例被构造出来，从而违反了单例模式中实例唯一的原则。 解决这个问题的办法是为指示类是否已经实例化的变量提供一个互斥锁。</li>
</ul>


<h1>接口适配</h1>

<h4>适配器（Adapter）</h4>

<pre><code>将一个类的接口转换成客户希望的另一个接口，适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
</code></pre>

<p>适配器模式分为类适配器模式和对象适配器模式。
<img src="http://al1020119.github.io/images/iosshejimoshi003.png" title="Caption" ></p>

<ul>
<li>上图是对象适配器模式，Adapter（适配器）遵守了 Target（目标接口）协议，拥有一个 Adaptee（被适配者）的对象 adaptee 的引用，当调用 Adapter 的 request 方法，request 方法里会去调用 adapteee 的 specificRequest 方法。</li>
</ul>


<h4>类适配模式</h4>

<p><img src="http://al1020119.github.io/images/iosshejimoshi004.png" title="Caption" ></p>

<p>类适配器模式中适配器和被适配者是继承关系。request 方法里会去调用 super 的 specificRequest 方法，达到将类的接口转换成客户希望的另一个接口。</p>

<p>适配器模式主要应用于“希望复用一些现存的类，但是接口又与复用环境要求不一致的情况”，在遗留代码复用、类库迁移等方面非常有用。</p>

<h4>桥接（Bridge）</h4>

<pre><code>将抽象部分与它的实现部分分离，使它们都可以独立地变化。
</code></pre>

<p>桥接模式是软件设计模式中最复杂的模式之一，在软件系统中，某些类型由于自身的逻辑，它具有两个或多个维度的变化。</p>

<p><img src="http://al1020119.github.io/images/iosshejimoshi005.png" title="Caption" ></p>

<ul>
<li>如上图，毛笔和颜色是两个维度的变化，可以选择新建 9 个类去实现不同颜色的不同毛笔，也可以如图所示，去组合两个维度。对于客户端而言，可以针对两个维度的抽象层编程，在程序运行的时候再动态确认两个维度的子类，动态组合对象，将两个独立变化的维度完全解耦，以便能够灵活地扩充任一维度而对另一维度不造成任何影响。比如增加一种毛笔并不需要去改动图中的实现部分，增加一种颜色也不需要去改变抽象部分。（抽象部分是面向我们编程的接口部分，我们绘图的时候是调用毛笔类的绘图方法）。</li>
</ul>


<p>桥接模式可以让抽象与实现之间不形成绑定关系，在运行时可以切换实现，也将抽象和实现完全解耦，可以独立扩展。</p>

<h4>外观（Facade）</h4>

<pre><code>为系统中的一组接口提供一个统一的接口。外观顶一个高层接口，让子系统更易于使用。
</code></pre>

<p>外观模式主要是使用一个外观类，为复杂的子系统提供一个简单的接口，而子系统的复杂调用交给外观类去做。</p>

<p><img src="http://al1020119.github.io/images/iosshejimoshi006.png" title="Caption" ></p>

<ul>
<li>如上图，数据的来源可能是不同数据库，获取数据可能非常的复杂，所以使用一个外观类提供简单的获取数据的接口，复杂的操作让外观类去做。做到让子系统更加的易用。</li>
</ul>


<h1>对象去耦</h1>

<h4>中介者（Mediator）</h4>

<pre><code>用一个对象来封装一系列对象的交互方式，中介者使各对象不需要显示地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。
</code></pre>

<p>我们开发的程序是由大量的类来组成的，随着程序功能的不断增加，类和类之间的依赖关系也跟着趋于复杂，而中介者模式便能解决这个问题，</p>

<p><img src="http://al1020119.github.io/images/iosshejimoshi007.png" title="Caption" ></p>

<ul>
<li>如图所示，6 个 VC 类之间的交互可能特别多，如果让他们相互依赖，然后管理这些 VC 之间的关系是一件非常繁琐的事情，我们要处理各个 VC 之间的关系，每当一个 VC 要跳转到另外个 VC，我们需要包含新的 VC 的头文件。而使用中介者模式，让 VC 之间的交互变成 VC 和中介者的交互，用中介者来管理多对多的复杂的对象群，降低了各个对象之间的耦合，减少了对象之间逻辑的复杂度，但也可能导致中介者类中的实现过于复杂。</li>
</ul>


<p>UINavigationController 就是一个中介者，如下图所示</p>

<p><img src="http://al1020119.github.io/images/iosshejimoshi008.png" title="Caption" ></p>

<p>视图控制器的切换都是与 UINavigationController 做交互。由 UINavigationController 去做集中管理。</p>

<h4>观察者（Observer）</h4>

<pre><code>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。
</code></pre>

<p>在 Cocoa Touch 框架中通知和 KVO 都实现了观察者模式。通知是由一个中心对象为所有观察者提供变更通知，KVO 是被观察的对象直接向观察者发送通知。</p>

<p><img src="http://al1020119.github.io/images/iosshejimoshi009.png" title="Caption" ></p>

<ul>
<li>如上图，Subject 的值改变时，通知观察者 ObserverA，ObserverB，ObserverC，我的数据改变了，依赖我的你们需要更新状态了。</li>
</ul>


<p>被观察者不需要知道有多少个观察者和观察者的更新细节，降低被观察者和观察者之间的耦合。</p>

<h1>抽象集合</h1>

<h4>组合（Composite）</h4>

<pre><code>将对象组合成树形结构以表示“部分-整体”的层次结构。组合使得用户对单个对象和组合对象的使用具有一致性。
</code></pre>

<p>在 Cocoa Touch 框架中，UIView 被组织成一个组合结构。每个 UIView 都可以将其它 UIView 设置为自己的子视图，形成一个树形结构，让客户端可以对单个 UIView 或者对 UIView 组合统一对待。</p>

<p>既平移一个 UIView，可以做到平移这一个 UIView 组合，且操作方法与平移单个 UIView 一致。</p>

<h4>迭代器（Iterator）</h4>

<pre><code>提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示，
</code></pre>

<p>在 Cocoa Touch 中的 NSEnumerator 就实现了迭代器模式，如以下代码</p>

<pre><code> NSArray *anArray = @[@"this", @"is", @"a", @"test"];
    NSEnumerator *itemEnumerator = [anArray objectEnumerator];

    NSString *item;
    while (item = [itemEnumerator nextObject]) {
        NSLog(@"%@", item);
    }
</code></pre>

<p>迭代器分为两种，上面使用了一个外部迭代器，外部迭代器让客户端直接操作迭代过程，如上面代码就是使用一个 while 循环去迭代。</p>

<p>下面是使用了内部迭代器，客户端不需要知道实现迭代的方式。</p>

<pre><code> NSArray *anArray = @[@"this", @"is", @"a", @"test"];
    NSString *string = @"a";
    [anArray enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
        NSLog(@"%@", obj);
        if ([obj isEqualToString:string]) {
            *stop = YES;
        }
    }];
</code></pre>

<p>客户端不需要手动实现迭代器，只要对每个元素进行处理就行。</p>

<h1>行为扩展</h1>

<h4>访问者（Visitor）</h4>

<pre><code>表示一个作用于某对象结构中的各元素的操作，它让我们可以在不改变各元素的类的前提下定义作用于这些元素的新操作。
</code></pre>

<p>当一个复杂的对象结构包含很多其他的对象，每个对象都有不同的接口，这个时候如果想添加新的接口进行新的操作，就得修改该对象的类，如果每个对象都需要添加新操作，就需要修改更多的类。而访问者模式就是用来不修改原有类添加新的操作。</p>

<p>访问者模式涉及两个关键元素，访问者和被访问对象。访问者遵从访问协议，访问协议里声明了访问方法。访问方法类似下面</p>

<pre><code>- (void)visitEngine:(NimoEngine *)engine;
- (void)visitWheel:(NimoWheel *)wheel;
</code></pre>

<p>访问者模式流程，直接调用访问者里的访问方法，访问方法里实现了新添加的操作，engine 与 wheel 既被访问对象，达到了将新操作集中在访问者里处理的效果。如果再需要新添加一系列对各个元素的操作，只需要再添加一个访问者类就行。</p>

<blockquote><p>访问者能访问复杂元素里的每一个元素，然后由访问者对这些元素进行行为扩展。</p>

<h4>装饰（Decorator）</h4></blockquote>

<pre><code>动态地给一个对象添加一些额外的职责。就扩展功能来说，装饰模式相比生成子类更为灵活。
</code></pre>

<p>Category 就是实现了装饰的设计模式。Category 是 Objective-C 的语言功能，通过它可以给类添加方法的接口与实现，而不必子类化。 从这个设计模式的描述联想到 Category，就没什么难理解了。
责任链（Chain of Responsibility）</p>

<pre><code>使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间发生耦合。此模式将这些对象连成一条链，并沿着这条链传递请求，直到有一个对象处理它为止。
</code></pre>

<p>Cocoa Touch 中的事件处理流程–响应者链就实现了责任链模式。以点击为例，首先通过 hit-test view 的流程找到被点击的视图，被点击的视图如果不处理点击事件，则沿着响应者链向上回溯，比如给父视图发消息，让父视图去处理，父视图不处理则继续沿着响应者链向上回溯，直到有对象处理它为止，如果都不处理，则该事件丢弃。</p>

<h1>算法封装</h1>

<h4>模板方法（Template Method）</h4>

<pre><code>定义一个操作中算法的骨架，而将一些步骤延迟到子类中。模板方法使子类可以重定义算法的某些特定步骤而不改变该算法的结构。
</code></pre>

<p>模板方法可以提高可扩展性与可复用性，比如 UIView 类中的定制绘图,UIView 的结构不改变，只是继承 UIView,再重载 – (void)drawRect:(CGRect)rect
方法。所以 – (void)drawRect:(CGRect)rect 就是模板方法，默认什么都不做或者只是做了部分操作，缺少特性操作，用来给子类选择重载与实现的方法。</p>

<h4>策略（Strategy）</h4>

<pre><code>定义一系列算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。
</code></pre>

<p>举一个常见的例子，验证 UITextField 输入是否有效。有两个算法分别是验证邮箱的和验证电话号码的。可以通过 if else 这样的判断代码来决定执行哪个算法。也可以通过策略模式，将算法封装起来，如下图
￼</p>

<p><img src="http://al1020119.github.io/images/iosshejimoshi010.png" title="Caption" ></p>

<p>Strategy 是这一系列算法的父类，ConcreteStrategyA, B, C。是三种算法，给 Context 对象添加一个 Strategy 类型的属性，里面存放着 ConcreteStrategyA 或者 B，C。然后 Context 对象就知道去执行哪个算法。也就知道自己需要执行什么策略。</p>

<blockquote><p>策略模式首先将算法都封装起来了，易于理解，且易于切换和扩展。</p>

<h4>命令（Command）</h4></blockquote>

<pre><code>将请求封装为一个对象，从而可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。
</code></pre>

<p>Cocoa Touch 框架中的 NSInvocation 就是实现了命令模式。</p>

<pre><code>NSMethodSignature*signature = [ViewController instanceMethodSignatureForSelector:@selector(sendMessageWithNumber:WithContent:)];
  //1、创建NSInvocation对象
  NSInvocation*invocation = [NSInvocation invocationWithMethodSignature:signature];
  invocation.target = self;
  //invocation中的方法必须和签名中的方法一致。
  invocation.selector = @selector(sendMessageWithNumber:WithContent:);
  /*第一个参数：需要给指定方法传递的值
         第一个参数需要接收一个指针，也就是传递值的时候需要传递地址*/
  //第二个参数：需要给指定方法的第几个参数传值
  NSString*number = @"1111";
  //注意：设置参数的索引时不能从0开始，因为0已经被self占用，1已经被_cmd占用
  [invocation setArgument:&amp;number atIndex:2];
  NSString*number2 = @"啊啊啊";
  [invocation setArgument:&amp;number2 atIndex:3];
  //2、调用NSInvocation对象的invoke方法
  //只要调用invocation的invoke方法，就代表需要执行NSInvocation对象中制定对象的指定方法，并且传递指定的参数
  [invocation invoke];
</code></pre>

<p>将行为封装成对象，而不是直接触发行为，因为是对象，所以可以很容易的设计一个命令队列，也可以方便的记录进日志里，以及实现行为的撤销。（因为行为对象可以记录进日志里，所以可以根据日志得知上一个操作做了什么，从而进行撤销）。</p>

<h1>性能与对象访问</h1>

<h2>享元（Flyweight）</h2>

<pre><code>利用共享技术有效地支持大量细粒度的对象。
</code></pre>

<p>tableViewCell 的重用机制就是实现了享元模式。在要使用一个 Cell 的时候，会先去重用池里看看 tableView 有没有可以重用的 cell，如果有重用该 cell，没有创建一个，这就是享元模式。</p>

<p>享元模式主要有两个关键组件，可共享的享元对象和保存它们的享元池。</p>

<blockquote><p>举另一个实现例子，画面上需要显示 100 个相同的图案，可以只生成一个包含该图案 image 的 imageView。其它 99 个只需要去享元池里去拿这个 imageView 实例的信息，然后在页面里直接绘制图案，这样就不需要生成 100 个图案实例。</p></blockquote>

<p>享元模式通过共享一部分必须的对象，减少对象的创建，节省大量的内存。</p>

<h4>代理（Proxy）</h4>

<pre><code>为其它对象提供一种代理以控制对这个对象的访问。
</code></pre>

<p>代理设计模式的英文名是 Proxy pattern，和我们常见的 delegate（委托） 没关系。</p>

<p>iOS 中常见的代理模式例子为引用计数，当一个复杂对象的多份副本须存在时，代理模式可以结合享元模式以减少内存用量。典型做法是创建一个复杂对象及多个代理者，每个代理者会引用到原本的复杂对象。而作用在代理者的运算会转送到原本对象。一旦所有的代理者都不存在时，复杂对象会被移除。</p>

<blockquote><p>当然，上面的代理模式中的代理者什么都没做，代理对象作为 A 和 C 中间的协调者，可以多做点操作，可以理解为 VPN 中的代理者可以对传输数据加密，而 A 和 C 中的代理者，也可以隐藏 C 的信息，做到对 C 的保护。</p></blockquote>

<h1>对象状态</h1>

<h4>备忘录（Memento）</h4>

<pre><code>在不破坏封装的情况下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可将该对象恢复到原先保存的状态。
</code></pre>

<p>Cocoa Touch 框架中归档可以实现备忘录模式，Cocoa 的归档是对对象及其属性还有同其他对象间的关系进行编码，形成一个文档，该文档可以保存于文件系统，也可在进程或网络间传输，最后又可以通过解档将文档解码成与该对象归档时状态一致的对象。</p>

<blockquote><p>既将对象保存一个备份放置到其它地方，可以随时使用备份将该对象恢复到原先保存的状态，用来储存关键对象的关键状态。</p></blockquote>

<h5>总结：（如果看了这么久您依然不知道上面在扯上面鬼，那么请结合ios开发中遇到的技术点简单粗略的体会一下下面的东西，再返回看看或许你就会明白很多）</h5>

<ul>
<li>备忘录-归档</li>
<li>代理-引用计数（非delegate）</li>
<li>享元-TableView重用机制</li>
<li>命令-NSInvocation</li>
<li>策略-文本有效</li>
<li>模板-drawRect</li>
<li>装饰-分类</li>
<li>责任链-响应者</li>
<li>迭代器-NSEnumerator</li>
<li>组合-UIView</li>
<li>观察者-通知、KVO</li>
<li>中介-导航</li>
<li>原型-.copy</li>
<li>工厂方法-initWithBool</li>
<li>抽象工厂-alloc]initWithXXX</li>
<li>单利-无处不在哈哈</li>
<li>适配器-网络请求接口</li>
</ul>


<hr />

<pre><code>Q Q：2211523682/790806573

微信：18370997821/13148454507

微博WB:http://weibo.com/u/3288975567?is_hot=1

git博文：http://al1020119.github.io/

github：https://github.com/al1020119
</code></pre>

<p><img src="http://al1020119.github.io/images/iCocosCoder.jpg" title="Caption" ></p>

<p><img src="http://al1020119.github.io/images/iCocosPublic.jpg" title="Caption" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[修行篇-数据结构常见操作与总结]]></title>
    <link href="http://al1020119.github.io/blog/2016/08/28/xiu-xing-pian-shu-ju-jie-gou-chang-jian-cao-zuo-yu-zong-jie/"/>
    <updated>2016-08-28T12:33:11+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/08/28/xiu-xing-pian-shu-ju-jie-gou-chang-jian-cao-zuo-yu-zong-jie</id>
    <content type="html"><![CDATA[<h1>一、栈</h1>

<p>栈是只能在一端进行插入和删除的线性表。
（别看只是个定义，非常重要，已经道出了运算方法：只能在一端插入和删除。)</p>

<blockquote><p>栈的特征：后进先出，先进后出。</p></blockquote>

<p>插入和删除元素的一端称为栈顶。（说明了我们在栈顶操作）
另一端称为栈底。
插入元素和删除元素的操作称为入栈和出栈。</p>

<!--more-->


<h3>1.顺序栈</h3>

<p>结构：(top总是指向数组最后的元素，比如data[n]，而不是前面)</p>

<pre><code>#define MAXSIZE 100
typedef struct
{
    elementtype data[MAXSIZE];
    int top;
} seqstack;
</code></pre>

<p>初始化栈：</p>

<pre><code>void init_stack(seqstack *S)
{
    S-&gt;top = -1;    //一个元素也没有，注意因为TOP是下标而不是元素个数，用-1
}
</code></pre>

<p>判断栈是否为空：</p>

<pre><code>int stack_empty(seqstack *S)
{
    if (S-&gt;top == -1)
        return 1;
    else
        return 0;
}
</code></pre>

<p>取栈顶元素：</p>

<pre><code>elementtype stack_top(seqstack *S)
{
    if (stack_empty(S))
        error("栈为空！");
    else
        return S-&gt;data[S-&gt;top];
}
</code></pre>

<p>入栈：</p>

<pre><code>void push_stack(seqstack *S, elementtype x)
{
    if (S-&gt;top == MAXSIZE -1)
        error("溢出！");
    else
        S-&gt;data[++S-&gt;top] = x;    //注意-&gt;运算符的优先级是最高的
}
</code></pre>

<p>出栈：</p>

<pre><code>elementtype pop_stack(seqstack *S)
{
    if (stack_empty(S))
        error("栈为空！");
    else
        return S-&gt;data[S-&gt;top--];
}
</code></pre>

<p>判断栈是否为满：</p>

<pre><code>int stack_full(seqstack *S)
{
    if (S-&gt;top == MAXSIZE -1)
        return 1;
    else
        return 0;
}
</code></pre>

<p>总体来说，顺序栈很简单，出的时候取最后的元素，进的时候一样进在尾部。</p>

<h3>2.链栈</h3>

<p>栈的链式存储结构称为链栈。
其插入和删除操作仅限制在表头位置上进行。
由于只能在链表头部进行操作，故链栈没有必要象单链表那样添加头结点。栈顶指针就是链表的头指针。
结构：</p>

<pre><code>typedef struct node    //和一般链表的结构一样。
{
    elementtype data;
    struct node *next;
} linkstack; 
linkstack *top;
当top=NULL时，链栈为空栈。
</code></pre>

<p>入栈：</p>

<pre><code>void push_stack(linkstack *top, elementtype x)
{
    linkstack *P = (linkstack *)malloc(sizeof(linkstack));
    P-&gt;data = x;
    P-&gt;next = top-&gt;next;
    top = P;
}
</code></pre>

<p>出栈：</p>

<pre><code>elementype pop_stack(linkstack *top)
{
    elementtype x;
    linkstack *P;
    if (top == NULL)
        error("栈为空！");
    else
    {
        x = top-&gt;data;
        P = top;
        top = top-&gt;next;
        free(P);
        return x;
    }
}
</code></pre>

<h1>二、队列</h1>

<p>队列是只能在一端插入，另一端删除的线性表。
特征是：先进先出，后进后出。</p>

<h1>1.顺序队列</h1>

<p>注意顺序队列多是循环队列，这里要注意几点：</p>

<ul>
<li>(1)front是队头的前一个位置。</li>
<li>(2)尾部入队，头部出队。</li>
<li><p>(3)由于循环，任何的位置移动计算之后要取余：P = (P + 1) % MAXSIZE 。
结构：</p>

<p>  #define MAXSIZE 100
  typedef struct
  {
      elementtype data[MAXSIZE];
      int front;    //头序号（注意是队头的前一个位置）
      int rear;    //尾序号（直接指向尾元素）
  } seqqueue;</p></li>
</ul>


<p>初始化队列：</p>

<pre><code>void init_queue(seqqueue *Q)
{
    Q-&gt;front = 0;
    Q-&gt;rear = 0;
}
</code></pre>

<p>还有一种写法：</p>

<pre><code>void init_queue(seqqueue *Q)
{
    Q-&gt;front = MAXSIZE - 1;
    Q-&gt;rear = MAXSIZE - 1;
}
</code></pre>

<p>两种方法的区别是第一种插入第一个元素是data[1]，而第二种是data[0]。
判断队列是否为空：</p>

<pre><code>int queue_empty(seqqueue *Q)
{
    if (Q-&gt;front == Q-&gt;rear)
        return 1;
    else
        return -1;
}
</code></pre>

<p>判断队列是否为满：</p>

<pre><code>int queue_full(seqqueue *Q)
{
    if ((Q-&gt;rear + 1) % MAXSIZE == Q-&gt;front)
        return 1;
    else
        return 0;
}
</code></pre>

<p>取队头元素：</p>

<pre><code>elementtype queue_front(seqqueue *Q)
{
    if (queue_empty(Q))
        error("队列为空！");
    else
        return Q-&gt;data[(Q-&gt;front + 1) % MAXSIZE];
}
</code></pre>

<p>入队：</p>

<pre><code>void Enqueue(seqqueue *Q, elementtype x)
{
    if (queue_full(Q))
        error("队列满！");
    else
    {
        Q-&gt;rear = (Q-&gt;rear + 1) % MAXSIZE;    //千万不能直接用Q-&gt;rear++，在循环队列要特别注意
        Q-&gt;data[Q-&gt;rear] = x;
    }
}
</code></pre>

<p>出队：</p>

<pre><code>elementtype Outqueue(seqqueue *Q)
{
    if (queue_empty(Q))
        error("队列为空！");
    else
    {
        Q-&gt;front = (Q-&gt;front + 1) % MAXSIZE;
        return Q-&gt;data[Q-&gt;front];
    }
}
</code></pre>

<h3>2.链队列</h3>

<p>出队时，删除表头操作，入队时，在表尾添加结点。（也就是头部出，尾部进）
使用带头结点的单链表形式。（注意链栈是不带头结点的）
结构：</p>

<pre><code>typedef struct mynode
{
    elementtype data;
    mynode *next;
} node;    //就是单链表
typedef struct
{
    node *front;
    node *rear;
} linkqueue;
</code></pre>

<p>初始化队列：</p>

<pre><code>void init_queue(linkqueue *Q)
{
    Q-&gt;front = (node *)malloc(sizeof(node));    //生成头结点（注意是NODE类型，Q结构是已有的一个结构，这里有点特殊，仔细体会）
    Q-&gt;rear = Q-&gt;front;
    Q-&gt;front = NULL;
}
</code></pre>

<p>判断队列是否为空：</p>

<pre><code>int queue_empty(linkqueue *Q)
{
    if (Q-&gt;front == Q-&gt;rear)
        return 1;
    else
        return 0;
}
</code></pre>

<p>取队头元素：</p>

<pre><code>elementtype queue_front(linkqueue *Q)
{
    if (queue_empty(Q))
        error("队列为空！");
    else
        return Q-&gt;front-&gt;next-&gt;data;
}
</code></pre>

<p>入队：</p>

<pre><code>void Enqueue(linkqueue *Q, elementtype x)
{
    node *P = (node *)malloc(sizeof(node));
    P-&gt;data = x;
    P-&gt;next = NULL;
    Q-&gt;rear-&gt;next = P;
    Q-&gt;rear = P;
}
</code></pre>

<p>出队：</p>

<pre><code>elementtype Outqueue(linkqueue *Q)
{
    node *P;
    elmenttype x;
    if (queue_empty(Q))
        error("队列为空！");
    else
    {
        P = Q-&gt;front-&gt;next;
        Q-&gt;front-&gt;next = P-&gt;next;
        x = P-&gt;data;
        free(P);
    }
    if (Q-&gt;front-&gt;next == NULL)    //只剩一个结点删除后队列为空时的特殊情况，一定要注意处理
        Q-&gt;rear = Q-&gt;front;
    return x;
}
</code></pre>

<h1>数组</h1>

<p>主要是稀疏矩阵的压缩存储：
当数组中非零元素非常少时，称之为稀疏矩阵。
存储特别如下：</p>

<ul>
<li>(1)对稀疏矩阵压缩存储时，除了存储非零元素的值v以外，还要存储其行列号i和j，故每个元素对应一个三元组(i, j, v)。将这些元素的三元组组织起来构成三元组表。</li>
<li>(2)需要在三元组表中增设元素个数、行列数，以唯一确定一个稀疏矩阵。</li>
</ul>


<p>结构如下：</p>

<pre><code>#define MAXSIZE 100
typedef struct    //三元组结构
{
    int i, j;
    elementtype v;
} tuple;
typedef struct
{
    int mu, nu, tu;    //行数、列数、非0元素个数
    tuple data[MAXSIZE];
} spmatrix;
</code></pre>

<h1>树</h1>

<h3>一、树</h3>

<p>树中的每个结点最多只有一个前驱（父辈），但可能有多个后继（后代）。
一个结点的度是指该结点的孩子数目。
若一个结点的度为0，称为叶子结点或终结点，否则称为分支结点或非终结点。
一棵树的度是树中最大的结点的度。
某个结点的子树的根称为其孩子结点，而该结点为其孩子结点的双亲结点或父结点。
同一个结点的孩子互相称为兄弟结点。
根的层次为1，其余结点的层次为父结点的层次数加1，而最大的层次数称为树的高度或深度。
如果树中各兄弟结点之间的排列次序是无关的，则称之为有序树，否则称为无序树。
称多棵树为森林。</p>

<h3>二叉树</h3>

<p>二叉树和树一样，都可以为空树。
注意二叉树每个结点的孩子都有左右之分，每个结点都有左右两个子树，这与树结构明显不同。
二叉树和树本质上是完全不同的两种结构。
 定义：满二叉树是指每层都有最大数目结点的二叉树，即高度为k的满二叉树中有2k-1个结点。而完全二叉树则是指在满二叉树的最下层从右到左连续地删除若干个结点所得到的二叉树。</p>

<p>二叉树的性质：</p>

<ul>
<li>1.在二叉树的第i层上的结点个数&lt;=2i-1(i>0)</li>
<li>2.深度（高度）为k的二叉树的结点个数&lt;=2k-1</li>
<li>3.对任一棵非空的二叉树，如果其叶子数为n0, 度为2的结点数为n2, 则有下面的关系式成立：n0=n2+1
(这个性质很重要。主要是有个概念：除去根结点，每个结点都与一个它上面的分支一一对应，也就是说，结点数＝分支数＋1，所以有：n-1=n1+2*n2)</li>
<li>4.有n个结点的完全二叉树(n>0)的深度为[log2n]+1([]为取整)</li>
<li>5.在编号的完全二叉树中，各结点的编号之间的关系为：
编号为i的结点如果存在左孩子，则其编号为2i，如果存在右孩子，则其编号为2i+1，如果存在父结点，则其编号为[i/2]。</li>
</ul>


<p>二叉树的存储结构：
1.顺序存储结构：
按完全二叉树的编号次序进行，即编号为i的结点存储在数组中下标为i的元素中。
缺点：若二叉树不是完全二叉树，则为了保持结点之间的关系，不得不空出许多元素来，这就造成了空间的浪费。</p>

<p>2.二叉链表存储结构：</p>

<pre><code>typedef struct node
{
    datatype data;
    struct node *lchild, *rchild;
} bitree;
</code></pre>

<h3>二叉树的遍历：</h3>

<p>所谓遍历二叉树是指按某种次序访问二叉树中每个结点一次且仅一次。
根据访问根结点的次序，可以分为先序遍历，中序遍历，后序遍历。
先序遍历可描述为：
若二叉树T不为空：</p>

<ul>
<li>(1)访问T的根结点；</li>
<li>(2)先序遍历T的左子树；</li>
<li><p>(3)先序遍历T的右子树。
遍历的算法非常简单，只写出先序遍历算法：</p>

<p>  void preorder(bitree *T)
  {
      if (T != NULL)
      {
          visit(T);    //一般用的最多的就是输出
          preorder(T->lchild);
          preorder(T->rchild);
      }
  }</p></li>
</ul>


<h3>线索二叉树</h3>

<p>线索二叉树主要是为了求解在某种次序下的前驱或后继结点。
将二叉树各结点中的空的左孩子指针域改为指向其前驱，空的右孩子指针域改为指向其后继。称这种新的指针（前驱或后继）为线索，所得到的二叉树被称为线索二叉树，将二叉树转变成线索二叉树的过程称为线索化。
同时，为了区分到底指针是指向前驱（后继）还是孩子，要加入两个标志来判断。
结构：</p>

<pre><code>typedef struct node
{
    int ltag, rtag;    //0为孩子，1为前驱或后继
    datatype data;
    struct node *lchild, *rchild;
} ordertree;
</code></pre>

<p>先序后继的求解：</p>

<pre><code>ordertree *presuc(ordertree *P)
{
    if (P-&gt;ltag == 0)
        return P-&gt;lchild;
    else
        return P-&gt;rchild;
}
</code></pre>

<p>中序后继：</p>

<pre><code>ordertree *insuc(ordertree *P)
{
    ordertree *q = P-&gt;rchild;
    if (P-&gt;rtag == 1)
        return q;
    else
    {
        while (q-&gt;ltag == 0)
            q = q-&gt;lchild;
        return q;
    }
}
</code></pre>

<p>中序先驱：</p>

<pre><code>ordertree *infore(ordertree *P)
{
    ordertree *q = P-&gt;lchild;
    if (P-&gt;ltag == 1)
        return q;
    else
    {
        while (q-&gt;rtag == 0)
            q = q-&gt;rchild;
        return q;
    }
}
</code></pre>

<p>后序先驱：</p>

<pre><code>ordertree *postfore(ordertree *P)
{
    if (P-&gt;rtag == 0)
        return P-&gt;rchild;
    else
        return P-&gt;lchild;
}
</code></pre>

<h3>树和森林</h3>

<h5>1.树的存储结构：</h5>

<p>(1)双亲表示法</p>

<pre><code>struct tnode
{
    datatype data;
    int parent;
}
struct tnode treelist[MAXSIZE];    //整个树的存储数组说明
</code></pre>

<p>其中parent指示该结点父结点的下标，data存放结点的值。
优点：便于搜索相应结点的父结点和祖先结点。
缺点：若要搜索孩子结点或后代结点需要搜索整个表，浪费时间。</p>

<p>(2)孩子链表表示法
分别将每个结点的孩子结点连成一个链表，然后将各表头指针放在一个表中构成一个整体结构。</p>

<pre><code>typedef struct node    //链表中每个孩子结点的定义
{
    int data;
    struct node *next;
} listnode;
typedef struct    //数组元素的定义，每个数组元素都是一个单链表，单头元素不同
{
    datatype info;
    listnode *firstchild;
} arrnode;
arrnode tree[MAXSIZE];    //MAXSIZE为所有结点的个数
</code></pre>

<p>优缺点：与双亲表示法恰好相反。</p>

<p>(3)孩子－兄弟链表表示法（二叉链表表示法，二叉树表示法）
树中每个结点用一个链表结点来存储，每个链表结点中除了存放结点的值外，还有两个指针，一个用来指示该结点的第一个孩子，另一个用于指示该结点的下一个兄弟结点。</p>

<pre><code>typedef struct node
{
    datatype data;
    struct node *firstchild, *nextbrother;
} tnode;
</code></pre>

<h5>2.树（森林）与二叉树的转换</h5>

<p>树或森林的子树转换为二叉树的左子树，兄弟转化为右子树。</p>

<h5>3.树（森林）的遍历</h5>

<p>树的遍历可分为先序遍历和后序遍历。（注意没有中序，因为树有不只两个孩子）即结点是在其子树之前还是之后访问。
遍历树（森林）要转换为遍历其对应的二叉树：
先序遍历：（同二叉树的先序遍历）</p>

<pre><code>void preorder(tnode *T)
{
    if (T != NULL)
    {
        visit(T);
        preorder(T-&gt;firstchild);
        preorder(T-&gt;nextbrother);
    }
}
</code></pre>

<p>后序遍历：（同二叉树的中序遍历）</p>

<pre><code>void postorder(tnode *T)
{
    if (T != NULL)
    {
        postorder(T-&gt;firstchild);
        visit(T);
        postorder(T-&gt;nextbrother);
    }
}
</code></pre>

<h3>哈夫曼树</h3>

<p>哈夫曼树主要用来处理压缩算法。
一般的判断问题的流程就象是一棵二叉树，其中分支（判断）结点对应于二叉树的分支结点；而最后得出的结论对应于叶子结点；一个结论所需要的判断次数是从根结点到该叶子结点的分支线数（层次数-1）；每个结论成立的次数作为叶子结点的权值。
(这个权值可能比较少接触,但是其实它非常重要,因为我们平时设计的系统,判断的结果常常都是通过长年的实践会有一个出现机率分配,而不可能是平分的,比如考试,如果常常80-90分的比较多,也许就要换一种算法,当然这是后话,和考试无关了.)</p>

<p>哈夫曼算法步骤如下:</p>

<ul>
<li>(1)根据给定的n个权值,构成一排结点T,每个的值都是相应的权值.</li>
<li>(2)从T中选两棵权值最小的二叉树,作为左右子树构成一棵新的二叉树T',并且新二叉树的权值为左右子树权值之和.</li>
<li>(3)将新二叉树T'并入到T中,删除原来的两棵二叉树.</li>
<li>(4)重复2,3直到只剩一棵二叉树.这棵树就是哈夫曼树.</li>
</ul>


<p>哈夫曼树的带权路径长度WPL=∑wL
即所有叶子结点的 权值*比较次数(层次数-1) 之和.
而WPL也正好等于所有分支结点(不包括叶子结点)的值之和.</p>

<h1>图</h1>

<p>图中将每个对象用一个顶点表示，并常用一个序号来标识一个顶点。
其中弧表示单向关系，边表示双向关系，用离散数学中的术语来说，则分别表示为非对称关系和对称关系。
弧用&lt;A, B>表示（A为尾，B为头），边用(A, B)表示。</p>

<pre><code>一个图G由两部分内容构成，即顶点(vertex)集合(V)和边(或弧edge)的集合(E)，并用二元组(V, E)来表示，记做G = (V, E) 
</code></pre>

<ul>
<li>根据顶点间的关系是否有向而引入有向图和无向图。</li>
<li>给每条边或弧加上权值，这样的带权图称为网络。</li>
<li>若无向图中任意两点间都有一条边，则称此图G为无向完全图。(共有边数 n*(n-1)/2 )</li>
<li><p>若有向图中任意一个顶点到其余各点间均有一条弧，则称为有向完全图。(共有弧数 n*(n-1) )
若一个图G1是从G中选取部分顶点和部分边（或弧）组成，则称G1是G的子图。（注意，顶点和边必须都为子关系）</p></li>
<li><p>若无向图中两个顶点i, j之间存在一条边，则称i, j相邻接，并互为邻接点。
在有向图中，若存在弧&lt;Vi, Vj>，也做Vi, Vj相邻接，但为区别弧的头、尾顶点，可进一步称做Vi邻接到Vj，Vj邻接于Vi。</p></li>
</ul>


<p>与一个顶点相邻接的顶点数称为该顶点的度。
在有向图中，进入一个顶点的弧数称为该顶点的入度，从一个顶点发出的弧数为该顶点的出度，并将入度和出度之和作为该顶点的度。</p>

<p>一个顶点经过一定的可经路程到达另一个顶点，就为顶点之间的路径。</p>

<ul>
<li>若某路径所经过的顶点不重复，则称此路径为简单路径。</li>
<li>若某路径的首尾相同，则称此路径为回路（或称为环）。</li>
<li><p>若某回路的中间不重复，则称之为简单回路。</p></li>
<li><p>若无向图中任意两点之间均存在路径，则称G为连通图，否则不连通，就存在若干个连通分量。</p></li>
<li>若有向图中任意两点间可以互相到达，则称为强连通图。</li>
</ul>


<p>一个无向图，连通并且无回路，称这样的图为树。
若有向图中仅有一个顶点的入度为0，其余顶点的入度都为1，称此图为有向树，入度为0的顶点为根。</p>

<h3>图的存储结构：</h3>

<h5>1。邻接矩阵表示</h5>

<p>对n个顶点的图来说，其邻接矩阵为n*n阶的。
邻接矩阵的元素存放边（弧）的权值，对不存在的边（弧），则用0或∞表示。
定义格式如下：</p>

<pre><code>#define n 6    /* 图顶点数 */ 
#define e 8    /* 图的边（弧）数 */
typedef struct
{
    vextype vexs[n];    /* 顶点类型 */
    datatype arcs[n][n];    /* 权值类型 */
} graph; 
</code></pre>

<p>建立一个无向网络的算法：</p>

<pre><code>CreateGraph(graph *G) 
{ 
    int i, j, k; 
    float w; 
    for (i=0; i&lt;n; i++) 
        G-&gt;vexs[i] = getchar();    /* 读入顶点信息，创建表，这里用字符型 */ 
    for (i=0; i&lt;n; i++) 
        for (j=0; j&lt;n; j++) 
            G-&gt;arcs[i][j] = 0;    /* 邻接矩阵初始化 */ 
    for (k=0; k&lt;e; k++) 
    { 
        scanf("%d%d%f", &amp;i, &amp;j, &amp;w);    /* 读入边(vi, vj)上的权w(暂用float类型) */ 
        G-&gt;arcs[i][j] = w; 
        G-&gt;arcs[j][i] = w; 
    } 
}
</code></pre>

<h5>2.邻接表表示法</h5>

<p>将每个顶点的邻接点连成链表，并将各链表的表头指针合在一起（用数组或链表表示均可），其中每个头指针与该结点的信息合为一个整体结点。
如果将邻接表中各顶点的邻接表变为其前驱顶点即可，从而得到逆邻接表。
用邻接表存储网络时，需要将各条边（弧）的权值作为相应邻接结点中的一个字段。
结构：</p>

<pre><code>typedef struct node
{
    int adjvex;    /* 邻接点域 */
    struct node *next;    /* 链域 */
    datatype arc;    /* 权值 */
} edgenode;    /* 边表指针 */
typedef struct
{
    vextype vertex;    /* 顶点信息 */
    edgenode *link;    /* 边表头指针 */
} vexnode;    /* 顶点表结点 */
vexnode gnode[n];    /* 整个图的构成 */
 建立无向图的邻接表：
CreateAdjlist(gnode)
{
    int i, j, k;
    edgenode *s;
    for (i=0; i&lt;n; i++)    /* 读入顶点信息 */
    {
        gnode[i].vertex = getchar();
        gnode[i].link = NULL;    /* 边表指针初始化 */
    }
    for (k=0; k&lt;e; k++)    /* 建立边表 */
    {
        scanf("%d%d", &amp;i, &amp;j);    /* 读入边(vi,vj)的顶点序号 */
        s = malloc(sizeof(edgenode));    /* 生成邻接点序号为j的表结点 */
        s-&gt;adjvex = j;
        s-&gt;next = gnode[i].link;
        gnode[i].link = s;    /* 将*s插入顶点vi的边表头部(插到头部比尾部简单) */
        s = malloc(sizeof(edgenode));    /* 生成邻接点序号为i的边表结点*s */
        s-&gt;adjvex = i;
        s-&gt;next = gnode[j].link;
        gnode[j].link = s;    /* 将*s插入顶点vj的边表头部(最后四行由于是无向图，所以相互，两次) */
    }
}
</code></pre>

<h3>图的遍历算法及其应用</h3>

<h5>1.深度遍历</h5>

<ul>
<li>(1)访问V0</li>
<li>(2)依次从V0 的各个未被访问的邻接点出发深度遍历
（两句话说的非常清楚。是一种以深度为绝对优先的访问。）</li>
</ul>


<h5>2。深度优先搜索遍历算法</h5>

<p>由于实际算法比较复杂，这里算法依赖两个函数来求解（对于不同的存储结构有不同的写法）
firstadj(G, v)：返回图G中顶点v的第一个邻接点。若不存在，返回0。
nextadj(G, v, w)：返回图G中顶点v的邻接点中处于w之后的那个邻接点。若不存在，返回0。
depth first search:</p>

<pre><code>void dfs(graph G, int v)
{
    int w;
    visit(v);
    visited[v] = 1;
    w = firstadj(G, v)
    while (w != 0)
    {
        if (visited[w] == 0)
            dfs(w);
        w = nextadj(G, v, w);
    }
}
</code></pre>

<p>如果不是连通图，或者是有向图，那么访问一个v不可能遍历所有顶点。所以，需要再选择未被访问的顶点作为起点再调用dfs.</p>

<p>所以，深度遍历图的算法如下：</p>

<pre><code>void dfs_travel(graph G)
{
    int i;
    for (i=1; i&lt;=n; i++)
        visited[i] = 0;        //初始化各顶点的访问标志
    for (i=1; i&lt;=n; i++)
        if (visited[i] == 0)
            dfs(G, i);
}
</code></pre>

<h5>3.广度优先搜索遍历算法</h5>

<p>广度优先搜索遍历算法(bfs)是一种由近而远的层次遍历算法，从顶点V0出发的广度遍历bfs描述为：</p>

<ul>
<li>(1)访问V0（可作为访问的第一层）；</li>
<li>(2)假设最近一层的访问顶点依次为V1, V2, &hellip;, Vk，则依次访问他们的未被访问的邻接点。</li>
<li>(3)重复2，直到找不到未被访问的邻接点为止。</li>
</ul>


<p>算法</p>

<pre><code>void bfs(graph G, int V0)
{
    int w;
    int v;
    queue Q;
    init_queue(Q);
    visit(V0);
    visited[V0] = 1;
    Enqueue(Q, V0);
    while (!empty(Q))
    {
        v = Outqueue(Q);
        w = firstadj(G, v);
        while (w != 0)
        {
            if (visited[w] == 0)
            {
                visit(w);
                visited[w] = 1;
                Enqueue(Q, w);
            }
            w = nextadj(G, v, w);
        }
    }
}
</code></pre>

<p>广度遍历图的算法和深度一样：</p>

<pre><code>void bfs_travel(graph G)
{
    int i;
    for (i=1; i&lt;=n; i++)
        visited[i] = 0;
    for (i=1; i&lt;=n; i++)
        if (visited[i] = 0)
            bfs(G, i);
}
</code></pre>

<p>最小生成树：</p>

<pre><code>从图中选取若干条边，将所有顶点连接起来，并且所选取的这些边的权值之和最小。
</code></pre>

<p>这样所选取的边构成了一棵树，称这样的树为生成树，由于权值最小，称为最小生成树。</p>

<h3>构造最小生成树有两种方法：</h3>

<h6>1.Prim算法：</h6>

<pre><code>首先将所指定的起点作为已选顶点，然后反复在满足如下条件的边中选择一条最小边，直到所有顶点成为已选顶点为止（选择n-1条边）：一端已选，另一端未选。
</code></pre>

<p>(简单的说，就是先任选一点，然后每次选择一条最小权值的边，而且只连接到一个已选顶点)</p>

<h6>2.Kruskal算法：</h6>

<pre><code>反复在满足如下条件的边中选出一条最小的，和已选边不够成回路。
(条件就是不够成回路就OK，反复选最小边，知道所有顶点都有连接）
</code></pre>

<p>最短路径：
一般即是要一个顶点到其余各个顶点的最短路径。（比如隔很远的顶点，要绕哪几条边走）
求解方法：</p>

<pre><code>首先，我们要画一个表，每个顶点有path和dist两个值，分别用来存储到各点的最短路径（比如(1,5,6)，就是1-5-6这个路径）和相应的长度（到该点的权值之和）。
</code></pre>

<ul>
<li>(1)对V以外的各顶点，若两点间的邻接路径存在，则将其作为最短路径和最短长度存到path[v]和dist[v]中。(实际上也就是最开始对顶点的直接后继进行处理）</li>
<li>(2)从未解顶点中选择一个dist值最小的顶点v，则当前的path[v]和dist[v]就是顶点v的最终解（从而使v成为已解顶点）。</li>
<li>(3)如果v的直接后继经过v会更近一些，则修改v的直接后继的path和dist值。</li>
</ul>


<p>(上面的确是很难懂，只能通过例子自己慢慢熟悉。）</p>

<h1>查找</h1>

<blockquote><p>在软件设计中，通常是将待查找的数据元素集以某种表的形式给出，从而构成一种新的数据结构－－查找表。
表包括一些“元素”，“字段”等等概念。</p></blockquote>

<p>在一个数据表中，若某字段的值可以标识一个数据元素，则称之为关键字（或键）。
若此关键字的每个值均可以唯一标识一个元素，则称之为主关键字，否则，若该关键字可以标识若干个元素，则称之为次关键字。</p>

<p>查找算法的时间性能一般以查找次数来衡量。所谓查找长度是指查找一个元素所进行的关键字的比较次数。常以平均查找次数、最大查找次数来衡量查找算法的性能。</p>

<h5>一、简单顺序查找</h5>

<pre><code>int seq_seach(elementtype A[], int n, keytype x)
{
    int i;
    A[0].key = x;        //设定监视哨
    for (i=n; A[i].key!=x; i--);
    return i;
}
</code></pre>

<p>监视哨是一个小技巧，查找失败时，这里设定的数据是A[1]-A[n]，肯定可以在A[0]中找到该元素，并返回0表示查找失败。如果不设定监视哨，则在每次循环中要判断下标是否越界：for (i=1; i!=n&amp;&amp;A[i].key!=x;i&ndash;); 可以节省一半的时间。</p>

<h5>二、有序表的二分查找</h5>

<pre><code>int bin_search(elementtype A[], int n, keytype x)
{
    int mid, low, high;
    low = 0;
    high = n - 1;
    while (low &lt;= high)
    {
        mid = (low + high) / 2;
        if (x == A[mid].key)
            return mid;
        else if (x &lt; A[mid].key)
            high = mid - 1;
        else
            low = mid + 1;
    }
    return -1;
}
</code></pre>

<p>也可以使用递归算法：</p>

<pre><code>int bin_search(elementtype A[], int low, int high, keytype x)
{
    int mid;
    if (low &lt; high)
        return -1;
    else
    {
        mid = (low + high) / 2;
        if (x == A[mid].key)
            return mid;
        else if (x &lt; A[mid],key)
            return bin_search(A, low, mid - 1, x);
        else
            return bin_search(A, mid - 1, high, x);
    }
}
</code></pre>

<h1>排序</h1>

<ul>
<li>增排序和减排序：如果排序的结果是按关键字从小到大的次序排列的，就是增排序，否则就是减排序。</li>
<li>内部排序和外部排序：如果在排序过程中，数据表中所有数据均在内存中进行，则这类排序为内部排序，否则就是外部排序。</li>
<li>稳定排序和不稳定排序：在排序过程中，如果关键字相同的两个元素的相对次序不变，则称为稳定排序，否则是不稳定排序。</li>
</ul>


<p>在分析算法的时间性能时，主要以算法中用的最多的基本操作的执行次数（或者其数量级）来衡量，这些操作主要是比较、移动和交换元素。有时，可能要用这些次数的平均数来表示。</p>

<h3>一、插入排序</h3>

<p>基本思想：</p>

<blockquote><p>把整个待排序子表看作是左右两部分，其中左边为有序区，右边为无序区，整个排序过程就是把右边无序区中的元素逐个插入到左边的有序区中，以构成新的有序区。
实际中，开始排序时把第一个元素A[0]（或A[1]）看作左边的有序区，然后把剩下的2～N个元素依次插入到有序表中。</p></blockquote>

<pre><code>void insert_sort(elementtype A[n+1])
{
    int i;
    for (i=2; i&lt;=n; i++)
    {
        A[0] = A[i];        //设置监视哨，这个数组同样是从1开始，A[0]就设为监视哨
        j = i - 1;
        while (A[j].key &gt; A[0].key)
        {
            A[j + 1] = A[j];
            j--;
        }
        A[j + 1] = A[0];
    }
}
</code></pre>

<p>明白这种方法的简单原理：
a1 a2 a3 &hellip; a(i-1) ai &hellip;
先将ai临时保存起来，然后把a(i-1)向前只要是比ai大的向后移，再把ai填进去即可。</p>

<h3>二、快速排序</h3>

<p>速度最快的办法！一定要掌握，考试重点。</p>

<p>基本思想：</p>

<blockquote><p>首先，选定一个元素作为中间元素，然后将表中所有元素与该中间元素相比较，将表中比中间元素小的元素调到表的前面，将比中间元素大的元素调到后面，再将中间数放在这两部分之间作为分界点，这样便得到一个划分；然后再对左右两部分分别进行快速排序，如此反复，直到每个子表仅有一个元素或空表为止。
中间数一般选择部分的第一个元素。</p></blockquote>

<pre><code>int partition(elementtype A[n], int s, int t)    //s,t是要排序元素的起点和终点,并返回最后中间元素位置
{
    elementtype x = A[s];    //保存中间元素到临时变量x,以腾出空位
    int i = s;                        //置两端搜索位置的初值
    int j = t;
    while (i != j)        //两端位置重和再停止
    {
        while (i &lt; j &amp;&amp; A[j].key &gt; x.key) j--;    //从后面搜索“小”的元素
        if (i &lt; j)        //如果找到，就调到前面的空位中
        {
            A[i] = A[j];
            i++;
        }
        while (i &lt; j &amp;&amp; A[i].key &lt; x.key) i++;    //从前面搜索“大”的元素
        if (i &lt; j)        //如果找到，调到后面的空位中
        {
            A[j] = A[i];
            j--;
        }
    }
    A[i] = x;        //将中间数移到最终位置上
    return i;
}
</code></pre>

<p>整个算法：</p>

<pre><code>void quick_sort(elementtype A[n], int s, int t)    //对数组中下标从s到t的部分进行快速排序，如果是整个表就是0, n-1
{
    int i;
    if (s &lt; t)    //表中至少有两个元素时
    {
        i = partition(A, s, t);    //划分排序一次
        quick_sort(A, i + 1, t);    //对后面部分快速排序
        quick_sort(A, s, i - 1);    //对前面部分快速排序
    }
}
</code></pre>

<h3>三、选择排序：</h3>

<p>在待排序子表中完整地比较一遍以确定最大（小）元素，并将该元素放在子表的最前（后）面。
【注：可能发觉和冒泡法比较类似，但注意选择法是全部比较一遍，找到最小元素的下标，再进行一次交换，而冒泡则是进行多次交换】</p>

<pre><code>void select_sort(elementtype A[n])
{
   int min, i, j;
   elementtype temp;
   for (i=0; i&lt;n-1; i++)
   {
      min = i;
      for (j=i+1; j&lt;n; j++)
         if (A[min].key &gt; A[j].key) min = j;
      if (min != i)
      {
         temp = A[i];
         A[i] = A[min];
         A[min] = temp;
      }
   }
}
</code></pre>

<h3>四、归并排序</h3>

<p>所谓归并是指将两个或两个以上的有序表合并成一个新的有序表。
归并算法：</p>

<p>假设两个序列A[m]和B[n]为非降序列（即存在相同元素的升序列），现要把他们合并为一个非降序列C[m+n]。</p>

<pre><code>void merge(elementtype A[], elementtype B[], elementtype C[], int m, int n)
{
    int ia = 0, ib = 0, ic = 0;
    while (ia &lt; m &amp;&amp; ib &lt; n)
        if (A[ia] &lt;= B[ib])
            C[ic++] = A[ia++];
        else
            C[ic++] = B[ib++];
    while (ia &lt; m)
        C[ic++] = A[ia++];
    while (ib &lt; n)
        C[ic++] = B[ib++];
}
</code></pre>

<hr />

<pre><code>Q Q：2211523682/790806573

微信：18370997821/13148454507

微博WB:http://weibo.com/u/3288975567?is_hot=1

git博文：http://al1020119.github.io/

github：https://github.com/al1020119
</code></pre>

<p><img src="http://al1020119.github.io/images/iCocosCoder.jpg" title="Caption" ></p>

<p><img src="http://al1020119.github.io/images/iCocosPublic.jpg" title="Caption" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[修行篇-算法之精华-算法&amp;冒泡]]></title>
    <link href="http://al1020119.github.io/blog/2016/08/25/xiu-xing-pian-suan-fa-zhi-jing-hua-suan-fa-and-mou-pao/"/>
    <updated>2016-08-25T12:32:56+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/08/25/xiu-xing-pian-suan-fa-zhi-jing-hua-suan-fa-and-mou-pao</id>
    <content type="html"><![CDATA[<ul>
<li><p>冒泡排序（交换）</p>

<ul>
<li>改进</li>
</ul>
</li>
<li><p>快速排序（交换）</p>

<ul>
<li>改进</li>
</ul>
</li>
</ul>


<h2>交换排序—冒泡排序（Bubble Sort）</h2>

<p>基本思想：</p>

<blockquote><p>在要排序的一组数中，对当前还未排好序的范围内的全部数，自上而下对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。即：每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。
算法的实现：</p></blockquote>

<pre><code>void bubbleSort(int a[], int n){  
    for(int i =0 ; i&lt; n-1; ++i) {  
        for(int j = 0; j &lt; n-i-1; ++j) {  
            if(a[j] &gt; a[j+1])  
            {  
                int tmp = a[j] ; a[j] = a[j+1] ;  a[j+1] = tmp;  
            }  
        }  
    }  
}  
</code></pre>

<h4>改进</h4>

<!--more-->


<blockquote><p>对冒泡排序常见的改进方法是加入一标志性变量exchange，用于标志某一趟排序过程中是否有数据交换，如果进行某一趟排序时并没有进行数据交换，则说明数据已经按要求排列好，可立即结束排序，避免不必要的比较过程。本文再提供以下两种改进算法：</p></blockquote>

<p>1．设置一标志性变量pos,用于记录每趟排序中最后一次进行交换的位置。由于pos位置之后的记录均已交换到位,故在进行下一趟排序时只要扫描到pos位置即可。
改进后算法如下:</p>

<pre><code>void Bubble_1 ( int r[], int n) {  
    int i= n -1;  //初始时,最后位置保持不变  
    while ( i&gt; 0) {   
        int pos= 0; //每趟开始时,无记录交换  
        for (int j= 0; j&lt; i; j++)  
            if (r[j]&gt; r[j+1]) {  
                pos= j; //记录交换的位置   
                int tmp = r[j]; r[j]=r[j+1];r[j+1]=tmp;  
            }   
        i= pos; //为下一趟排序作准备  
     }   
}    
</code></pre>

<p>2．传统冒泡排序中每一趟排序操作只能找到一个最大值或最小值,我们考虑利用在每趟排序中进行正向和反向两遍冒泡的方法一次可以得到两个最终值(最大者和最小者) , 从而使排序趟数几乎减少了一半。
改进后的算法实现为:</p>

<pre><code>void Bubble_2 ( int r[], int n){  
    int low = 0;   
    int high= n -1; //设置变量的初始值  
    int tmp,j;  
    while (low &lt; high) {  
        for (j= low; j&lt; high; ++j) //正向冒泡,找到最大者  
            if (r[j]&gt; r[j+1]) {  
                tmp = r[j]; r[j]=r[j+1];r[j+1]=tmp;  
            }   
        --high;                 //修改high值, 前移一位  
        for ( j=high; j&gt;low; --j) //反向冒泡,找到最小者  
            if (r[j]&lt;r[j-1]) {  
                tmp = r[j]; r[j]=r[j-1];r[j-1]=tmp;  
            }  
        ++low;                  //修改low值,后移一位  
    }   
}   
</code></pre>

<h2>交换排序—快速排序（Quick Sort）</h2>

<p>基本思想：</p>

<ul>
<li><p>1）选择一个基准元素,通常选择第一个元素或者最后一个元素,</p></li>
<li><p>2）通过一趟排序讲待排序的记录分割成独立的两部分，其中一部分记录的元素值均比基准元素值小。另一部分记录的 元素值比基准值大。</p></li>
<li><p>3）此时基准元素在其排好序后的正确位置</p></li>
<li><p>4）然后分别对这两部分记录用同样的方法继续进行排序，直到整个序列有序。</p></li>
</ul>


<p>算法的实现：
 递归实现：</p>

<pre><code>void print(int a[], int n){  
    for(int j= 0; j&lt;n; j++){  
        cout&lt;&lt;a[j] &lt;&lt;"  ";  
    }  
    cout&lt;&lt;endl;  
}  

void swap(int *a, int *b)  
{  
    int tmp = *a;  
    *a = *b;  
    *b = tmp;  
}  
int partition(int a[], int low, int high)  
{  
    int privotKey = a[low];                             //基准元素  
    while(low &lt; high){                                   //从表的两端交替地向中间扫描  
        while(low &lt; high  &amp;&amp; a[high] &gt;= privotKey) --high;  //从high 所指位置向前搜索，至多到low+1 位置。将比基准元素小的交换到低端  
        swap(&amp;a[low], &amp;a[high]);  
        while(low &lt; high  &amp;&amp; a[low] &lt;= privotKey ) ++low;  
        swap(&amp;a[low], &amp;a[high]);  
    }  
    print(a,10);  
    return low;  
}  
void quickSort(int a[], int low, int high){  
    if(low &lt; high){  
        int privotLoc = partition(a,  low,  high);  //将表一分为二  
        quickSort(a,  low,  privotLoc -1);          //递归对低子表递归排序  
        quickSort(a,   privotLoc + 1, high);        //递归对高子表递归排序  
    }  
}  
int main(){  
    int a[10] = {3,1,5,7,2,4,9,6,10,8};  
    cout&lt;&lt;"初始值：";  
    print(a,10);  
    quickSort(a,0,9);  
    cout&lt;&lt;"结果：";  
    print(a,10);  

}  
</code></pre>

<p>分析：</p>

<blockquote><p>快速排序是通常被认为在同数量级（O(nlog2n)）的排序方法中平均性能最好的。但若初始序列按关键码有序或基本有序时，快排序反而蜕化为冒泡排序。为改进之，通常以“三者取中法”来选取基准记录，即将排序区间的两个端点与中点三个记录关键码居中的调整为支点记录。快速排序是一个不稳定的排序方法。
快速排序的改进</p></blockquote>

<h4>改进</h4>

<p>在本改进算法中,只对长度大于k的子序列递归调用快速排序,让原序列基本有序，然后再对整个基本有序序列用插入排序算法排序。实践证明，改进后的算法时间复杂度有所降低，且当k取值为 8 左右时,改进算法的性能最佳。算法思想如下：</p>

<pre><code>void print(int a[], int n){  
    for(int j= 0; j&lt;n; j++){  
        cout&lt;&lt;a[j] &lt;&lt;"  ";  
    }  
    cout&lt;&lt;endl;  
}  
void swap(int *a, int *b)  
{  
    int tmp = *a;  
    *a = *b;  
    *b = tmp;  
}  
int partition(int a[], int low, int high)  
{  
    int privotKey = a[low];                 //基准元素  
    while(low &lt; high){                   //从表的两端交替地向中间扫描  
        while(low &lt; high  &amp;&amp; a[high] &gt;= privotKey) --high; //从high 所指位置向前搜索，至多到low+1 位置。将比基准元素小的交换到低端  
        swap(&amp;a[low], &amp;a[high]);  
        while(low &lt; high  &amp;&amp; a[low] &lt;= privotKey ) ++low;  
        swap(&amp;a[low], &amp;a[high]);  
    }  
    print(a,10);  
    return low;  
}  
void qsort_improve(int r[ ],int low,int high, int k){  
    if( high -low &gt; k ) { //长度大于k时递归, k为指定的数  
        int pivot = partition(r, low, high); // 调用的Partition算法保持不变  
        qsort_improve(r, low, pivot - 1,k);  
        qsort_improve(r, pivot + 1, high,k);  
    }   
}   
void quickSort(int r[], int n, int k){  
    qsort_improve(r,0,n,k);//先调用改进算法Qsort使之基本有序  
    //再用插入排序对基本有序序列排序  
    for(int i=1; i&lt;=n;i ++){  
        int tmp = r[i];   
        int j=i-1;  
        while(tmp &lt; r[j]){  
            r[j+1]=r[j]; j=j-1;   
        }  
        r[j+1] = tmp;  
    }   

}   
int main(){  
    int a[10] = {3,1,5,7,2,4,9,6,10,8};  
    cout&lt;&lt;"初始值：";  
    print(a,10);  
    quickSort(a,9,4);  
    cout&lt;&lt;"结果：";  
    print(a,10);  

}  
</code></pre>

<hr />

<pre><code>Q Q：2211523682/790806573

微信：18370997821/13148454507

微博WB:http://weibo.com/u/3288975567?is_hot=1

git博文：http://al1020119.github.io/

github：https://github.com/al1020119
</code></pre>

<p><img src="http://al1020119.github.io/images/iCocosCoder.jpg" title="Caption" ></p>

<p><img src="http://al1020119.github.io/images/iCocosPublic.jpg" title="Caption" ></p>
]]></content>
  </entry>
  
</feed>
