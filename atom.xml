<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[iOS梦工厂]]></title>
  <link href="http://al1020119.github.io/atom.xml" rel="self"/>
  <link href="http://al1020119.github.io/"/>
  <updated>2016-03-19T00:28:46+08:00</updated>
  <id>http://al1020119.github.io/</id>
  <author>
    <name><![CDATA[iCocos]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[逆向工程总结]]></title>
    <link href="http://al1020119.github.io/blog/2016/04/25/nixiangzongjie/"/>
    <updated>2016-04-25T13:32:08+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/04/25/nixiangzongjie</id>
    <content type="html"><![CDATA[<p>不忍心作结，虽然才刚刚开始，很多东西都没有细细总结，只可惜很多东西并非自己想的那么顺利。</p>

<p>才干了一年多的活，就见证了两个项目的死亡，这个世界远远超过自己想象中的残酷。第一个项目只历经一两个版本，无啥感情可言；第二个项目就完完全全经历了诞生到死亡的全过程，若说无感情的话，那我就是彻头彻尾的混蛋了。虽然终结是必然的，但是比预料中的更快更突然。悲剧往往就是在这种感情的强烈碰撞下诞生的。</p>

<!--more-->


<p>祸不单行，我丢了我的iPhone。那一刻我真真实实感觉到，失去自己熟悉的亲密的东西的那种无助。若是人，不敢想象。</p>

<p>好在人有着天生的自愈能力。换了新环境已快两月，感觉以前的那些已经过去很久似的，早已渐渐淡忘。新项目的生活紧张而细致，繁密且高精度的工作会让人无暇关注其它。而且，偶尔偶尔的小波澜，比如说某人被离职了，会在你神经绷得更紧更紧。</p>

<p>不过今天，发现那个当时也凝聚了不少心血的app终于上了AppStore，推迟了足足半年有余，惊讶中夹杂着深深的悲凉。当然这不是最让人伤心的。回想起自己后来去搞了越狱版，于是乎就听到了“我的AppStore版”和“你们的越狱版”之类的言语，似乎这个东西当时几个人搞出来，就算被重构至少还有不少头文件还标记着我的名字的东西，已经被彻头彻尾和我无关了。所以，这个东西上了AppStore，似乎我也没资格感到高兴。不，应该是连感到悲哀的权利都没有。</p>

<p>最后，我没有在Appstore下载它，更别说刷一个五星评论了。这个可能还保留着我那些刚学iOS开发而写出来的无比稚嫩的代码的东西，经历了一次次的延期、需求变更，甚至一度被挂起、拆分，最终上了架，可惜连我都觉得，这东西上不上架，已经无啥意义了。</p>

<p>只是偶尔，即使已经不做越狱版了，我还会到BigBoss的统计页面，看看那个只发了四个版本的越狱版，到底被下载了多少次（BigBoss上的统计是对所有人公开的，其它渠道的下载统计等等数据，对我来说基本不可能拿得到）。看到那个数字居然还在缓慢增长，停止更新后居然还能慢慢多了两万多的下载量，嘴角还是轻轻上扬一下。当然，我知道下载量和日活量是两个完全不同的概念，卸载是个很方便的操作，况且那个支持越狱版通过桌面长按卸载deb的功能还是我做的哩。很二逼的需求，我想，这么一个没啥用户基础的软件，居然还提供快捷卸载方法，二到家了。</p>

<p>说说新项目吧。至少这个长期占据AppStore前100名中一席的app，肯定有其牛逼的原因。果不其然，要融入到这个团队之中，我至少需要先脱层皮，不然拉低整个团队的技术水平和智商水准可是不被容忍的。中途有一段时间没活干，还在内疚着没帮上什么忙，最近接连三个版本两两并行，于是就累得跟狗一样了。效率，以及对工作量的估算，对我来说还是个硬伤。</p>

<p>吐槽了半天，没总结半点和越狱开发相关的东西。可能之后会很少接触这些东西了。以此作结，纪念那段偶尔挺二逼但也挺随意的时光。</p>

<p>改bundleid，启动后改掉取bundleid的方法，让它返回的bundle固定为原来那个，然后重签名就可以了</p>

<p>如果不hook那个取bundleid的方法，登录几次就会提示你用的不是正版，然后让你退出登录</p>

<p>不过要我做盗版或多开监测的话，会加上签名验证</p>

<p>不越狱其实也可以做，二进制文件里有个dylb的map，可以差一条记录上去，挂载你自己的动态库。然后把你自己写的用来hook代码的动态库一起签名放到ipa包里安装就行了。不过略麻烦。</p>

<p>使用load command,在mach o的头里,不过也是需求重新签名</p>

<p>bundleid在二进制中也编译的有吧，仅仅改plots</p>

<p>直接改plist就行</p>

<p>bundleid在二进制中也编译的有吧，仅仅改Plist,好像不行</p>

<p>行的，已验证</p>

<p>这么说ipa重签名是可以的，难道苹果只验证plist文件？</p>

<p>不过为了原有代码里面的判断逻辑啥的正常，最好再didfinishlaunch后hook掉NSBundle 的bundleIdentifier，让其返回原来的。</p>

<p>你改为新的bundleid，然后用你自己的证书签名，苹果就当这个app是你写的了</p>

<p>可以用theos写个tweak，然后用runtime想这么玩就随意你了·</p>

<p>主要还是看能不能分析出原有的逻辑。</p>

<p>用theos就得越狱了吧</p>

<p>噗。。。都在问iOS逆向问题，有没有谁了解Android的防逆向的所谓的『加固』处理，原理是什么呢？各加的加固处理效果如何？</p>

<p>逆向的关键只有一句 找到入口</p>

<p>做过别人 app 的分析,主要 reveal 分析 view 解构，猜测对方怎么做的效果。。。</p>

<p>reveal神器，用越狱的手机+插件来拖界面</p>

<p>然后 dump 二进制文件，可以看别人在一些地方用到了什么库</p>

<p>应该只能逆向出oc的头文件，不能逆向出m文件吧？</p>

<p>另外用 cocoapod 的可以从 dump 的头文件看得出来，因为，每个 pod 都有一个 dummy class[偷笑]一下就知道对方用了什么库了</p>

<p>嗯嗯，是的，不过可以反汇编，其实 hopper 给出来的反汇编代码已经有很大帮助了</p>

<p>reveal只能看到界面相关的东西,分析界面用的,要是想把别人的逻辑都搞清楚还是挺费劲的。了解个大体还行。</p>

<p>全部逻辑搞清楚的话，其实很费劲的。。。</p>

<p>不过找关键逻辑，或者想要的东西的话，还可以了</p>

<p>现在好多https请求是单向验证，一个charles就搞定接口了</p>

<p>之前搞雅虎天气找他们地图图片怎么做的</p>

<p>最无语的是搞金融的都不加双向验证</p>

<p>我们在接口上现在HTTPS+参数加密</p>

<p>不过对于普通抓包还是够了，一开始还用zlib压缩了一层，然后发现安卓会有问题，就放弃zlib只用gzip简单压了一下</p>

<p>大家开发的时候后天接口地址是不是都放在头文件里面？地址都放在.m里面了.不过抓包跟踪一下也差不多能抓出来</p>

<p>我们通信用的ice</p>

<p>reveal感觉用得比较舒服就是调试辅助，例如找别人写的view的名字</p>

<p>用过找别人是用啥控件,唯一设备ID没啥好研究的吧,或者取出指针</p>

<p>哈哈哈，找别人用的控件我也干过。。。Reveal抓出来一看，原来也是用的第三方的View，在github上就找到了。。。</p>

<p>例如一个feed流里一个用户的头像不相似了，想看下用户头像的地址是不是有问题，就直接选中对应imageview，然后看地址，进到xcode里暂停，直接打po [0xxxxxxxxx url] 就好了</p>

<p>url还是sd_url了···忘记了···啊哈哈哈哈哈··反正这个原理···</p>

<p>@飞宇。 有啊，我是做广告相关的。大家拿出去钱砸广告新增用户就是按照这个排重的。idfa可以更改，很多刷榜公司就是靠假良骗钱的。</p>

<p>不是，是反设备清洗,防止一台设备伪造出成千上万设备</p>

<p>这不还有IP可查么</p>

<p>你可能花100w做了100w新增用户，其实是用一台设备搞出来的</p>

<p>ip也可以用vpn自动刷新，没听过刷榜公司么！之前积分墙火的时候，淘宝上一搜一大把。</p>

<p>开发相关的安全问题，除了代码安全，资源文件安全，接口安全，还有什么没？</p>

<p>人员安全？比如别把代码上传到Github里</p>

<p>最主要是别把各种 key 传 github 了，以及自建的 git 的访问权限控制好</p>

<p>别人家的app怎么在xcode里暂停调试呢？之家的···调试别人家的bug干啥···别人家的用lldbserver挂上去，也能断点</p>

<p>因为看到你前面说reveal配合调试imageview了</p>

<p>那个是调试自家的APP时用</p>

<p>ssh+debugserver是能调试 但是不太方便 有没有更好用的工具？iPhoneTunnel</p>

<p>还有一个办法，不过我试了下新版，好像经常卡死，不晓得现在还没好，你可以试试
给你截图</p>

<p>竟然截不了图了············直接说把，直接用xcode的attach proce</p>

<p>想问一下，从iOS8.4后，还有什么方法可以访问到非越狱机子的Document目录吗？</p>

<p>刚才那个方法想成功attch上，得给个啥东西来着··竟然一时想不起来了···</p>

<p>是不是要给debugserver重签名</p>

<p>给大家再说个大家可能不知道的tips，iOS5后用rvictl可以把iPhone的网卡虚拟到mac上，然后···你懂的···</p>

<p>估计现在在非越狱机子上非常难做到了。 毕竟iOS8.4后对沙盒的权限限制较大</p>

<p>iExplorer可以部分备份指定app，间接访问到document目录</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[微信机器人]]></title>
    <link href="http://al1020119.github.io/blog/2016/04/20/weixinjiqiren/"/>
    <updated>2016-04-20T13:32:08+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/04/20/weixinjiqiren</id>
    <content type="html"><![CDATA[<p> 基于iOS逆向工程的微信机器人</p>

<p>本文转自猫头鹰团队</p>

<p>推荐序</p>

<blockquote><p>本文的作者沙梓社和吴航共同编写了《 iOS 应用逆向工程》，文章中介绍的是一些基本的 iOS 领域的安全知识，但是由于普及不够，基本上没有被人们重视，希望本文能让大家重视到 iOS 的源代码安全问题。</p></blockquote>

<p>另外预告一下，我认识的一个做移动安全的白帽子即将公开一个在非越狱手机上通过 App 绕过 sandbox 的 iOS 漏洞视频，并且计划发布一系列 iOS 系统安全方面的文章。我争取到了授权，并在我的公众号上同步发表这些文章，敬请期待：）</p>

<p>以下是文章正文，略有调整。</p>

<!--more-->


<p>讲师介绍-沙梓社</p>

<ul>
<li>湖北武汉人，《iOS 应用逆向工程》系列图书的作者，在 Cydia（最大的越狱 iOS 商店）上有 11 款独立作品，接受过 CSDN 的专访，书的英文版在 GitHub 上开源后收获了 2600+ stars，是首位在 WWJC 上发表演讲的中国人，以「提升中国 iOS 开发者在国际上的地位」为己任。</li>
</ul>


<p>在很多朋友的眼里，iOS 逆向工程是一个小众、神秘的方向，为什么我会选择这个小众的方向呢？这要从我最喜欢的一首诗说起。第一次，我是在李开复的自传《世界因你不同》里看到这首诗，当时就感觉身心得到了非常强烈的震撼：</p>

<p><img src="http://al1020119.github.io/images/nixiangjiqiren001.jpg" title="Caption" ></p>

<p>因为我感觉到自己就是这类人：如果有两条路给我选，我确实会选更少人走的那一条。我发现自己是一个刻意保持自己跟别人不同的人。</p>

<p>在初次读到这首诗时，我还没有开始学习 iOS。在从事 iOS 方面的研究后，又从乔帮主亲自配音的广告中寻找到了灵感，发现苹果跟我的价值观非常一致，就是要追求不同。因此，我更加认定 iOS 就是我的主攻方向。</p>

<p><img src="http://al1020119.github.io/images/nixiangjiqiren002.jpg" title="Caption" ></p>

<p>我的成长之路，就是一条与众不同的未选之路：别人都在学「大众情人」Windows 时，我开始学「小众路人」iOS；别人都在学 iOS 正向开发时，我开始学 iOS 逆向工程。正是因为追求不同，我写的《iOS 应用逆向工程》成为了全球唯一一本 iOS 逆向相关书籍，而且有美国和韩国的出版社想要引进本书，打破了中国 iOS 知识产权零输出的尴尬纪录。我用自己的努力代表中国 iOS 开发者在国际上发声，而且为 iOS 主流社区所认可，作为中国人我感到非常自豪。</p>

<p>简单来说，我所研究的，主要是 iOS 应用层的逆向工程，对内核层的逆向工程只是稍有涉猎，没有入门。应用层的逆向工程，我感觉自己玩得差不多了，应用层的所有逆向工程相关问题，都可以用我那本书上介绍过的知识和技术得到解决，我觉得没有太大挑战性了，主要是劳动量问题。到了这个地步，我的规划主要分为 2 个方向：</p>

<p>继续从事内核研究，这个方向的终点是「越狱」（越狱即通过漏洞利用拿到iOS的root权限，代表了iOS技术研究的最高境界）；</p>

<p>换个脑子，用一些非技术能力武装自己，让自己成为一专多能的人才。这个方向的终点就是创业。</p>

<p>当然，很多朋友会问，IT 人员创业的普遍做法，都是去 BAT 这样的互联网公司干 2 年，观察一下他们的玩法，然后拉一个团队出来干。你问啥不这么干呢？主要是碰到了一个很好的项目。大公司一直都在那里，想什么时候去都可以；而好项目却不常有，机会过去就过去了，不等人，所以我在准备并不算充分的情况下选择了创业这条路。</p>

<p>交代完了我的背景，咱们可以进入正题了😁</p>

<p><img src="http://al1020119.github.io/images/nixiangjiqiren003.jpg" title="Caption" ></p>

<p>大意是「通过研究现有功能的实现原理，理解并融会贯通，在此基础上实现（甚至增强）这个功能。」也就是说，不是照猫画虎，而是师夷长技，「借刀杀人」。</p>

<p>在我的理解里，逆向工程是一种工程师式的高级思维方式。给你水、面粉、糖、芝麻，让你做烧饼，这是正向工程；给你一个烧饼，让你分析出它是由多少水、多少面粉、多少糖、多少芝麻组成的，这是逆向工程。也就是说，根据图纸制作实物的这个过程是正向工程，而根据实物倒推图纸的这个过程则是逆向工程。乔布斯曾说「Good artists copy; Great artists steal.」逆向工程有异曲同工之妙。</p>

<p>举几个通过逆向工程师夷长技的例子：</p>

<p><img src="http://al1020119.github.io/images/nixiangjiqiren004.jpg" title="Caption" ></p>

<p>通过逆向工程分析instagram滤镜算法。一个人可以“steal”一个滤镜算法团队的工作成果；</p>

<p>研究微信的网络传输协议，就像@58沈剑 在博客里说到的那样。就我目前对微信九牛一毛的研究来说，就已经发现了一处可以进一步节省流量的地方，但是估计是因为历史遗留问题，这块代码不好动；</p>

<p>看看1Password做了哪些防护。1Password是专门用于保存密码的，类似于保险柜，安全系数必须很高，它把我们的密码存在了哪里，通过什么方式加密？这些都是值得我们学习借鉴的地方。</p>

<p>除了去学习别人的长处，逆向工程还可以发现自己和别人的短处：</p>

<p><img src="http://al1020119.github.io/images/nixiangjiqiren005.jpg" title="Caption" ></p>

<p>这种低级错误，星巴克可以犯，但1Password不能犯；这取决于你的产品定位。这个错误当然是通过逆向工程发现的。</p>

<p>这是某世界500强企业犯的，通过HTTP协议明文传输用户手机和密码的低级错误：</p>

<p><img src="http://al1020119.github.io/images/nixiangjiqiren006.jpg" title="Caption" ></p>

<p>这是某突破3亿用户的移动App：</p>

<p><img src="http://al1020119.github.io/images/nixiangjiqiren007.jpg" title="Caption" ></p>

<p>把传输协议的密钥硬编码在代码里，有逆向工程基础的朋友可以轻松还原整套网络传输协议。淘宝上一堆堆的这个刷榜那个刷赞，就是这个原理。</p>

<p>阿凹(猫友会吉祥物，一个微信机器人)，是「借刀杀人」最典型的运用之一：</p>

<p><img src="http://al1020119.github.io/images/nixiangjiqiren008.jpg" title="Caption" ></p>

<p>阿凹的实现原理，简单说，就是通过逆向工程的方式找出微信iOS客户端的收发信息等私有接口，然后基于自己的逻辑调用这些接口，实现针对特殊事件的自动化应答功能。</p>

<p>我个人最常用的iOS逆向工程工具主要有这些：</p>

<p><img src="http://al1020119.github.io/images/nixiangjiqiren009.jpg" title="Caption" ></p>

<ol>
<li><p>dumpdecrypted：将苹果加过密的App砸壳。通过AppStore处理的App，都是加过密的，不能直接进行二进制分析，需要先解秘，业界称为「砸壳」。它的原理是等App完全加载进内存，得到解密后，再把解密过的内存给dump出来，形成解密后的二进制文件，可以直接分析。</p></li>
<li><p>class-dump：导出MachO文件里的ObjC类及方法定义。因为ObjC是一门强烈依赖于运行时的语言，它的文件类型是MachO（类比于Windows里的PE文件类型），MachO里存放了大量运行时需要用到的信息，从中可以收集整理，还原出一个App源代码里的ObjC头文件。</p></li>
<li><p>CydiaSubstrate：将第三方动态库注入进程。它是越狱插件的存在前提。在iOS开机时，会把特定目录下的所有库，给加载到指定的进程里，俗称「hook」或「钩子」。</p></li>
<li><p>Cycript：用JS语法写ObjC方法。这是Cydia之父Saurik发明的一门语言，我个人主要用它来测试私有函数。</p></li>
<li><p>Theos：越狱插件开发工具。是我的书序作者DHowett开发的。iOS正向开发用Xcode，逆向开发用Theos。</p></li>
<li><p>IDA：全平台反汇编、反编译工具。搞技术的一般都听说过这个软件，就不多介绍了。</p></li>
<li><p>Hopper：OSX反汇编、反编译工具。比IDA便宜了1000倍，但功能跟IDA差不多；主攻苹果系操作系统。</p></li>
<li><p>debugserver + LLDB：动态调试器。是大名鼎鼎的「苹果版」GDB。</p></li>
</ol>


<p>class-dump的效果，图中显示的是新浪微博App的所有头文件：</p>

<p><img src="http://al1020119.github.io/images/nixiangjiqiren010.jpg" title="Caption" ></p>

<p>Cycript的效果，可以看到微信星号密码的明文：</p>

<p><img src="http://al1020119.github.io/images/nixiangjiqiren011.jpg" title="Caption" ></p>

<p>Theos开发插件的运行效果：</p>

<p><img src="http://al1020119.github.io/images/nixiangjiqiren012.jpg" title="Caption" ></p>

<p>所有进程的[NSDictionary dictionaryWithContentsOfFile:]方法均被「hook」，可以随意篡改。</p>

<p>IDA的效果：</p>

<p><img src="http://al1020119.github.io/images/nixiangjiqiren013.jpg" title="Caption" ></p>

<p>对于熟悉汇编语言（图里是ARM汇编）的朋友来说，所有未加密的二进制文件，均等同于开源。这是什么概念，做技术的都懂。</p>

<h6>接下来我简单介绍下阿凹的制作流程：</h6>

<p>核心在于找到收发微信消息的函数，然后加以修改利用：</p>

<p><img src="http://al1020119.github.io/images/nixiangjiqiren014.jpg" title="Caption" ></p>

<p>用dumpdecrypted给微信砸壳，解密出的文件近50M：</p>

<p><img src="http://al1020119.github.io/images/nixiangjiqiren015.jpg" title="Caption" ></p>

<p>class-dump出微信的所有头文件，近7000个：</p>

<p><img src="http://al1020119.github.io/images/nixiangjiqiren016.jpg" title="Caption" ></p>

<ul>
<li><p>定位到收消息的View，进而定位到V对应的C，找出逻辑层的收消息函数。</p></li>
<li><p>定位到发消息的按钮（也是一个View），进而定位到对应的C，找出逻辑层的发消息函数（这个过程没法用截图表现出来，所以我只简单描述下）。</p></li>
</ul>


<p>组合收发函数，完成阿凹的逻辑，最后写代码：</p>

<p><img src="http://al1020119.github.io/images/nixiangjiqiren017.jpg" title="Caption" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[驱动开发]]></title>
    <link href="http://al1020119.github.io/blog/2016/04/15/qudongkaifa/"/>
    <updated>2016-04-15T13:32:08+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/04/15/qudongkaifa</id>
    <content type="html"><![CDATA[<h4>一、系统架构</h4>

<p><img src="http://al1020119.github.io/images/nixiangqudong001.png" title="Caption" ></p>

<p>我们编写的驱动一般运行在i/o Kit框架下。</p>

<h4>二、一些记录</h4>

<ul>
<li>开发工具 xcode</li>
<li>开发语言：c++, c</li>
</ul>


<p>c++用的是嵌入式c++，是标准c++的子集。</p>

<!--more-->


<p>所以，stl、异常、多重继承、模板和runtime类型信息  都无法使用。</p>

<p>因为这些东西会导致编译出来的文件很大，且容易导致问题。</p>

<p>c++只能编写基于i/o Kit框架的驱动，而c语言则可以编写任意的驱动。</p>

<p>并且c++的驱动反汇编后很难看。</p>

<blockquote><p>所以写驱动还是用c吧。这一点和微软默认的一样。</p></blockquote>

<h4>三、编写一个驱动例子</h4>

<ol>
<li>创建工程</li>
</ol>


<p><img src="http://al1020119.github.io/images/nixiangqudong002.png" title="Caption" ></p>

<p>因为不是设备驱动，只能选择extension；如果是设备驱动，则选择IOKit Driver。</p>

<ol>
<li>写代码</li>
</ol>


<p><img src="http://al1020119.github.io/images/nixiangqudong003.png" title="Caption" ></p>

<p>苹果将studio.h这样的c++库换成了自己的libkern.h。</p>

<ol>
<li>添加引用库
因为代码中使用了libkern.h，所以要修改工程。</li>
</ol>


<p><img src="http://al1020119.github.io/images/nixiangqudong004.png" title="Caption" ></p>

<ol>
<li>驱动入口</li>
</ol>


<p><img src="http://al1020119.github.io/images/nixiangqudong005.png" title="Caption" ></p>

<ol>
<li><p>编译驱动</p></li>
<li><p>在xcode的product菜单里点击build就可以编译驱动了。</p></li>
<li>xcode只是能编辑和编译驱动，无法调试驱动的。</li>
<li>编译驱动时，你需要有一个开发者账号，否则编译不过。</li>
<li>我没有账号，所以后面的操作无法进行，只能把书上的翻译过来。</li>
</ol>


<p>6、运行驱动有2种方式：</p>

<ul>
<li>1、拷贝驱动文件到目录 /system/library/extensions下，重启后自动运行；</li>
<li><p>2、在terminal中运行命令启动驱动：</p>

<ul>
<li>sudo chown -R root:wheel 驱动名.kext   // 设置驱动文件的权限，如果有权限，这步可省略。
sudo kextload 驱动名.kext  // 运行驱动</li>
</ul>
</li>
<li><p>卸载驱动：sudo kextunload 驱动名.kext</p></li>
<li><p>显示当前系统中的驱动：kextstat</p></li>
</ul>


<p><img src="http://al1020119.github.io/images/nixiangqudong006.png" title="Caption" ></p>

<ol>
<li>查看调试信息
printf输出的信息是保存在磁盘上的log文件中。通过tail和cat命令就可以查看。log文件在/var/log/kernel.log或者/Applications/Utilities目录下。</li>
</ol>


<p><img src="http://al1020119.github.io/images/nixiangqudong007.png" title="Caption" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[逆向支付宝]]></title>
    <link href="http://al1020119.github.io/blog/2016/04/10/nixiangzhifubao/"/>
    <updated>2016-04-10T13:32:08+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/04/10/nixiangzhifubao</id>
    <content type="html"><![CDATA[<p>为了了解支付宝app的源码结构，我们可以使用class-dump-z工具来分析支付宝二进制。
1.下载配置class_dump_z</p>

<p>前往 <a href="https://code.google.com/p/networkpx/wiki/class_dump_z">https://code.google.com/p/networkpx/wiki/class_dump_z</a> ，下载tar包，然后解压配置到本地环境</p>

<p>$ tar -zxvf class-dump-z_0.2a.tar.gz<br/>
$ sudo cp mac_x86/class-dump-z /usr/bin/
2.class_dump支付宝app
$ class-dump-z Portal > Portal-dump.txt</p>

<!--more-->


<p>@protocol XXEncryptedProtocol_10764b0<br/>
-(?)XXEncryptedMethod_d109df;<br/>
-(?)XXEncryptedMethod_d109d3;<br/>
-(?)XXEncryptedMethod_d109c7;<br/>
-(?)XXEncryptedMethod_d109bf;<br/>
-(?)XXEncryptedMethod_d109b8;<br/>
-(?)XXEncryptedMethod_d109a4;<br/>
-(?)XXEncryptedMethod_d10990;<br/>
-(?)XXEncryptedMethod_d1097f;<br/>
-(?)XXEncryptedMethod_d10970;<br/>
-(?)XXEncryptedMethod_d10968;<br/>
-(?)XXEncryptedMethod_d10941;<br/>
-(?)XXEncryptedMethod_d10925;<br/>
-(?)XXEncryptedMethod_d10914;<br/>
-(?)XXEncryptedMethod_d1090f;<br/>
-(?)XXEncryptedMethod_d1090a;<br/>
-(?)XXEncryptedMethod_d10904;<br/>
-(?)XXEncryptedMethod_d108f9;<br/>
-(?)XXEncryptedMethod_d108f4;<br/>
-(?)XXEncryptedMethod_d108eb;<br/>
@optional<br/>
-(?)XXEncryptedMethod_d109eb;<br/>
@end</p>

<p>查看得到的信息是加过密的，这个加密操作是苹果在部署到app store时做的，所以我们还需要做一步解密操作。
3.使用Clutch解密支付宝app</p>

<p>1）下载Clutch
iOS7越狱后的Cydia源里已经下载不到Clutch了，但是我们可以从网上下载好推进iPhone
地址：Clutch传送门</p>

<p>2）查看可解密的应用列表</p>

<p>root</p>

<h1>./Clutch</h1>

<p>Clutch-1.3.2<br/>
usage: ./Clutch [flags] [application name] [&hellip;]<br/>
Applications available: 9P_RetinaWallpapers breadtrip Chiizu CodecademyiPhone FisheyeFree food GirlsCamera IMDb InstaDaily InstaTextFree iOne ItsMe3 linecamera Moldiv MPCamera MYXJ NewsBoard Photo Blur Photo Editor PhotoWonder POCO相机 Portal QQPicShow smashbandits Spark tripcamera Tuding_vITC_01 wantu WaterMarkCamera WeiBo Weibo</p>

<p>3）解密支付宝app</p>

<p>root# ./Clutch Portal</p>

<p>Clutch-1.3.2<br/>
Cracking Portal&hellip;<br/>
Creating working directory&hellip;<br/>
Performing initial analysis&hellip;<br/>
Performing cracking preflight&hellip;<br/>
dumping binary: analyzing load commands<br/>
dumping binary: obtaining ptrace handle<br/>
dumping binary: forking to begin tracing<br/>
dumping binary: successfully forked<br/>
dumping binary: obtaining mach port<br/>
dumping binary: preparing code resign<br/>
dumping binary: preparing to dump<br/>
dumping binary: ASLR enabled, identifying dump location dynamically<br/>
dumping binary: performing dump<br/>
dumping binary: patched cryptid<br/>
dumping binary: writing new checksum<br/>
Censoring iTunesMetadata.plist&hellip;<br/>
Packaging IPA file&hellip;</p>

<p>compression level: 0<br/>
    /var/root/Documents/Cracked/支付宝钱包-v8.0.0-(Clutch-1.3.2).ipa</p>

<p>elapsed time: 7473ms</p>

<p>Applications Cracked: <br/>
Portal</p>

<p>Applications that Failed:</p>

<p>Total Success: 1 Total Failed: 0</p>

<p>4）导出已解密的支付宝app</p>

<p>从上一步骤得知，已解密的ipa位置为：/var/root/Documents/Cracked/支付宝钱包-v8.0.0-(Clutch-1.3.2).ipa
将其拷贝到本地去分析</p>

<p>4.class_dump已解密的支付宝app</p>

<p>解压.ipa后，到 支付宝钱包-v8.0.0-(Clutch-1.3.2)/Payload/Portal.app 目录下，class_dump已解密的二进制文件
1</p>

<p>$ class-dump-z Portal > ~/Portal-classdump.txt</p>

<p>这回就可以得到对应的信息了：</p>

<p>@protocol ALPNumPwdInputViewDelegate <NSObject><br/>
-(void)onPasswordDidChange:(id)onPassword;<br/>
@end</p>

<p>@protocol ALPContactBaseTableViewCellDelegate <NSObject><br/>
-(void)shareClicked:(id)clicked sender:(id)sender;<br/>
@end</p>

<p>@interface MMPPayWayViewController : XXUnknownSuperclass &lt;SubChannelSelectDelegate, UITableViewDataSource, UITableViewDelegate, CellDelegate, UIAlertViewDelegate> {<br/>
@private<br/>
    Item<em> channelSelected;<br/>
    BOOL <em>bCheck;<br/>
    BOOL </em>bOpenMiniPay;<br/>
    BOOL <em>bNeedPwd;<br/>
    BOOL </em>bSimplePwd;<br/>
    BOOL <em>bAutopayon;<br/>
    BOOL </em>bHasSub;<br/>
    BOOL <em>bFirstChannel;<br/>
    BOOL </em>bChangeSub;<br/>
    BOOL _bClickBack;<br/>
    UITableView</em> <em>channelListTableView;<br/>
    NSMutableArray* </em>channelListArray;<br/>
    NSMutableArray<em> _subChanneSelectedlList;<br/>
    NSMutableArray</em> <em>unCheckArray;<br/>
    UIButton* </em>saveButton;<br/>
    UILabel<em> _tipLabel;<br/>
    MMPPasswordSwichView</em> <em>payWaySwitch;<br/>
    MMPPopupAlertView* </em>alertView;<br/>
    UIView<em> <em>setView;<br/>
    int </em>originalSelectedRow;<br/>
    int _currentSelectedRow;<br/>
    NSString</em> <em>statusCode;<br/>
    ChannelListModel* </em>defaultChannelList;<br/>
}<br/>
@property(assign, nonatomic) BOOL bClickBack;<br/>
@property(retain, nonatomic) ChannelListModel<em> defaultChannelList;<br/>
@property(retain, nonatomic) NSString</em> statusCode;<br/>
@property(assign, nonatomic) int currentSelectedRow;<br/>
@property(assign, nonatomic) int originalSelectedRow;<br/>
@property(retain, nonatomic) UIView<em> setView;<br/>
@property(retain, nonatomic) MMPPopupAlertView</em> alertView;<br/>
@property(retain, nonatomic) MMPPasswordSwichView<em> payWaySwitch;<br/>
@property(assign, nonatomic, getter=isSubChannelChanged) BOOL bChangeSub;<br/>
@property(assign, nonatomic) BOOL bFirstChannel;<br/>
@property(assign, nonatomic) BOOL bHasSub;<br/>
@property(assign, nonatomic) BOOL bAutopayon;<br/>
@property(assign, nonatomic) BOOL bSimplePwd;<br/>
@property(assign, nonatomic) BOOL bNeedPwd;<br/>
@property(assign, nonatomic) BOOL bOpenMiniPay;<br/>
@property(assign, nonatomic) BOOL bCheck;<br/>
@property(retain, nonatomic) UILabel</em> tipLabel;<br/>
@property(retain, nonatomic) UIButton<em> saveButton;<br/>
@property(retain, nonatomic) NSMutableArray</em> unCheckArray;<br/>
@property(retain, nonatomic) NSMutableArray<em> subChanneSelectedlList;<br/>
@property(retain, nonatomic) NSMutableArray</em> channelListArray;<br/>
@property(retain, nonatomic) UITableView* channelListTableView;<br/>
-(void).cxx_destruct;<br/>
-(void)subChannelDidSelected:(id)subChannel;<br/>
-(void)switchCheckButtonClicked:(id)clicked;<br/>
-(void)checkboxButtonClicked:(id)clicked;<br/>
-(void)onCellClick:(id)click;<br/>
-(void)showSubChannels;<br/>
-(void)tableView:(id)view didSelectRowAtIndexPath:(id)indexPath;<br/>
-(id)tableView:(id)view cellForRowAtIndexPath:(id)indexPath;<br/>
-(int)tableView:(id)view numberOfRowsInSection:(int)section;<br/>
-(float)tableView:(id)view heightForRowAtIndexPath:(id)indexPath;<br/>
-(int)numberOfSectionsInTableView:(id)tableView;<br/>
-(void)setTableViewFootView:(id)view;<br/>
-(void)setTableViewHeaderView:(id)view;<br/>
-(id)tableView:(id)view viewForHeaderInSection:(int)section;<br/>
-(id)tableView:(id)view viewForFooterInSection:(int)section;<br/>
-(float)tableView:(id)view heightForHeaderInSection:(int)section;<br/>
-(float)tableView:(id)view heightForFooterInSection:(int)section;<br/>
-(void)alertView:(id)view clickedButtonAtIndex:(int)index;<br/>
-(void)clickSave;<br/>
-(void)netWorkRequestWithPwd:(id)pwd;<br/>
-(void)setPayWaySwitchStates:(id)states;<br/>
-(void)changePayWaySwitch:(id)aSwitch;<br/>
-(void)scrollToSelectedRow;<br/>
-(void)didReceiveMemoryWarning;<br/>
-(void)viewDidLoad;<br/>
-(void)applicationEnterBackground:(id)background;<br/>
-(void)dealloc;<br/>
-(void)goBack;<br/>
-(BOOL)isChannelsSetChanged;<br/>
-(id)subChannelCode:(int)code;<br/>
-(id)subChannelDesc:(int)desc;<br/>
-(id)initWithDefaultData:(id)defaultData;<br/>
-(id)initWithNibName:(id)nibName bundle:(id)bundle;<br/>
-(void)commonInit:(id)init;<br/>
@end
5.分析支付宝源码片段</p>

<p>1）使用了@private关键字限制成员访问权限
但是实际上，在Objective-C编程中，使用@private连Keypath访问都拦不住的</p>

<p>2）抛出了冗长的成员对象
这非常有利分析程序结构
6.进一步思考</p>

<p>1）如何利用 class-dump 结果，结合 cycript 进行攻击呢？
2）class-dump-z 如此强大，有什么方法可以减少暴露的信息吗？</p>

<p>接下来的博文将针对上面的思考，继续总结～</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[非6S-实现3D Touch]]></title>
    <link href="http://al1020119.github.io/blog/2016/04/05/fei6sshixian3dtouch/"/>
    <updated>2016-04-05T13:32:08+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/04/05/fei6sshixian3dtouch</id>
    <content type="html"><![CDATA[<p>首先先给我这困难的语言表达能力道个歉哈，真的尽力了。
本章排版是参照<a href="http://bbs.pediy.com/showthread.php?t=205133%E5%A4%A7%E7%A5%9E%E7%9A%84%E6%9D%A5%E6%8E%92%E7%9A%84%EF%BC%8C%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%86%99%E5%BF%83%E5%BE%97%E6%96%87%EF%BC%8C%E4%B9%9F%E6%8A%8A%E6%89%80%E5%AD%A6%E5%88%B0%E7%9A%84%E5%88%86%E4%BA%AB%E7%BB%99%E5%A4%A7%E5%AE%B6">http://bbs.pediy.com/showthread.php?t=205133%E5%A4%A7%E7%A5%9E%E7%9A%84%E6%9D%A5%E6%8E%92%E7%9A%84%EF%BC%8C%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%86%99%E5%BF%83%E5%BE%97%E6%96%87%EF%BC%8C%E4%B9%9F%E6%8A%8A%E6%89%80%E5%AD%A6%E5%88%B0%E7%9A%84%E5%88%86%E4%BA%AB%E7%BB%99%E5%A4%A7%E5%AE%B6</a></p>

<p>最近才接触不久的逆向工程,刷夜,爆肝,把《iOS应用逆向工程》这本书的工具，全部看了一遍，并且尝试了一遍，感觉需要点什么。 那就是实践！  最近6s手机出了3DTouch，无奈手中没有这款机型，恰好最近对逆向小有心得，又听说过已经有插件能实现同样的需求，证明确实有可行性，于是开动。根据点击的判断和出现，初步感觉，这应该不需要多少行代码就能搞定，应该只要添加一个手势，或者是更改一个手势的点击事件，让系统认为发生了3DTouch点击事件，就可以了。</p>

<ul>
<li>所需工具: cycript，openSSH，class-dump</li>
<li>测试环境：iOS9.0.2，iPhone5s</li>
<li>备注：因为自身没有3DTouch，所以需要下载一个插件，让机器拥有3DTouch功能，我使用的是forcy，通过覆盖长按手势，实现</li>
</ul>


<p>通过查阅官方文档，得到关键词  Shortcut Menu peek pop
这个词将来就是要在找关键方法时刻所要用到的</p>

<!--more-->


<h4>现在开始！</h4>

<p>通过ssh连接到手机，然后将cycript注入到SpringBoard</p>

<pre><code>huangjipingde-iPhone:~ root# cycript -p SpringBoard
</code></pre>

<p>首先 先隆重介绍1个方法，2个函数</p>

<ul>
<li>1方法 [view recursiveDescription]  该方法可以当做是Reveal的文字版，用来查看当前页面的布局</li>
<li><p>2函数，原理均是runtime，但是第二个没有怎么看懂。。。</p></li>
<li><p>printMethods 打印出该类所有的方法，后边接的是实现的地址,在这儿补充一下，如果想对某个方法打断点，但是又不想使用ida查看方法偏移，可以直接在这实现的地址处，添加断点，虽然不知道断在什么地方，但是可以肯定一定是在执行该方法的时候。效果如下图：</p></li>
</ul>


<p>代码:</p>

<pre><code>function printMethods(className){
var count = new new Type("I");
var methods = class_copyMethodList(objc_getClass(className),count);
var methodsArray = [];
for (var i = 0; i &lt; *count; i++){
var method = methods[i];
methodsArray.push({selector:method_getName(method), implentation:method_getImplementation(method)});
}
free(methods);
free(count);
return methodsArray;
}
</code></pre>

<p><img src="http://al1020119.github.io/images/nixiangqudong001.png" title="Caption" ></p>

<ol>
<li><p>tryPrintIvars打印出对象所有的属性，效果如下图：
代码:</p>

<p>  function tryPrintIvars(a){
  var x={};
  for(i in <em>a){
  try{
  x[i] = (</em>a)[i];
  } catch(e){}
  }
   return x;}</p></li>
</ol>


<p><img src="http://al1020119.github.io/images/nixiangqudong002.png" title="Caption" ></p>

<p>准备工作都做好了，将两个函数都先输入进去</p>

<p><img src="http://al1020119.github.io/images/nixiangqudong003.png" title="Caption" ></p>

<p>因为最后的目标是应用图标，所以，现在我们从主界面开始着手打印它的UI布局
代码:</p>

<pre><code>[[UIApplication sharedApplication].keyWindow.rootViewController.view recursiveDescription]
</code></pre>

<p><img src="http://al1020119.github.io/images/nixiangqudong004.png" title="Caption" ></p>

<p>然后出来了一大片，红呦呦的代码，看着都眼睛疼，4点钟时看得眼睛都瞎了啊。此时应想，主界面可以滚动，是一个scrollView，是scrollView就得有contentSize，然后一看手机的页面，总共有5页，由于5s机型的宽度是320，所以这时候可以大胆猜测它的contentSize的最大宽度是1600，然后commond+F大法</p>

<p><img src="http://al1020119.github.io/images/nixiangqudong005.png" title="Caption" ></p>

<p>准确命中，同时，还注意到，它的contentOffset是960又此时我的页面正是第4页，基本锁定目标，查找frame的坐标是960，0的view，此时可以得到大量信息了，SBRootIconListView，这个就是用来装一页所有图标的View，SBIconListModel这个里边，我猜是装了该view里边的模型信息，注意，11 icons，正好是我们页面所有的图标数，此时再看后边SBIconView的size 62，62  这和图标尺寸的差距只有2个点，基本锁定，它就是我们要找的目标</p>

<p><img src="http://al1020119.github.io/images/nixiangqudong006.png" title="Caption" ></p>

<ul>
<li><p>此时，让我们找到是什么在处理SBIconView的事件，我们所知道的，view一般是用来展示的，事件的发生一般都会交给代理来负责。让我们使用nextResponder，或者寻找他们的代理，来定位到一个controller文件，很幸运，直接一步就找到了，就是它：SBIconController！</p></li>
<li><p>此时，我们可以class-dump出SpringBoard的头文件了，去查看一下它的里边都有些什么方法和属性，如果想偷懒，去github直接搜索也行。。。
根据关键词和方法名译的意思大致锁定出来以下几个方法</p></li>
</ul>


<p>ps：  这儿的char 是BOOL类型
代码:</p>

<pre><code>-(void)_handleShortcutMenuPeek:(id)arg1 ;
-(SBApplicationShortcutMenu *)presentedShortcutMenu;
-(char)_canRevealShortcutMenu;
-(id)_aggregateLoggingAppKeyForShortcutMenu:(id)arg1 ;
-(void)applicationShortcutMenu:(id)arg1 activateShortcutItem:(id)arg2 index:(int)arg3 ;
-(void)applicationShortcutMenu:(id)arg1 startEditingForIconView:(id)arg2 ;
-(void)applicationShortcutMenu:(id)arg1 launchApplicationWithIconView:(id)arg2 ;
-(void)applicationShortcutMenuDidPresent:(id)arg1 ;
-(void)_revealMenuForIconView:(id)arg1 presentImmediately:(char)arg2 ;
</code></pre>

<p>自己写一个tweak，hook所有的这些函数，给他们所有的实现之前加上一个NSLog（），查看调用的顺序，和传进来的值的类型。 以及一次Peek事件所关联到了哪些方法。
代码:</p>

<pre><code>%hook SBIconController

- (void)_revealMenuForIconView:(id)arg1 presentImmediately:(BOOL)arg2 {
NSLog(@"ZZT3D _revealMenuForIconView:arg1:%s,%@--arg2:%c",object_getClassName(arg1), arg1, arg2);
    %orig;
}

- (void)_handleShortcutMenuPeek:(id)arg1
{
NSLog(@"ZZT3D _handleShortcutMenuPeek:%s,%@",object_getClassName(arg1),arg1);
%orig;
}

-(char)_canRevealShortcutMenu
{
NSLog(@"ZZT3D _canRevealShortcutMenu");
  return %orig;
}
-(id)_aggregateLoggingAppKeyForShortcutMenu:(id)arg1{

 NSLog(@"ZZT3D ggregateLoggingAppKeyForShortcutMenu:%s,%@",object_getClassName(arg1),arg1);
    return %orig;
}

-(void)applicationShortcutMenu:(id)arg1 activateShortcutItem:(id)arg2 index:(int)arg3
{
NSLog(@"ZZT3D activateShortcutItem:arg1%s,%@—arg2%s,%@--arg3:%d",object_getClassName(arg1),arg1,object_getClassName(arg2),arg2,arg3);
%orig;
}


-(void)applicationShortcutMenu:(id)arg1 startEditingForIconView:(id)arg2 {
NSLog(@"ZZT3D startEditingForIconView:arg1%s,%@—arg2%s,%@",object_getClassName(arg1),arg1,object_getClassName(arg2),arg2);
%orig;

}
-(void)applicationShortcutMenu:(id)arg1 launchApplicationWithIconView:(id)arg2{
NSLog(@"ZZT3D launchApplicationWithIconView:arg1%s,%@—arg2%s,%@",object_getClassName(arg1),arg1,object_getClassName(arg2),arg2);
%orig;
}

-(void)applicationShortcutMenuDidPresent:(id)arg1{
NSLog(@"ZZT3D applicationShortcutMenuDidPresent:%s,%@",object_getClassName(arg1),arg1);
%orig;
}

%end
</code></pre>

<p>此时我们拿手机进行一次长按操作，使其弹出ShotcutMenu菜单，然后在openSSH中查看系统日志grep ZZT3D /var/log/syslog查看一下，该事件处理分别使用了那几个方法。</p>

<p><img src="http://al1020119.github.io/images/nixiangqudong007.png" title="Caption" ></p>

<p>因为是要欺骗系统，所以方法应该是在前方，初步定位到这3个方法，第一个顾名思义返回值就是能不能显示shotcutMenu，第二个，我们可以看到，这里传进来了一个手势，通过这手势的信息，基本可以推断，这个就是插件作者用来欺骗系统的手势，而该方法，就是手势的target方法，第三个，根据意思可以得知，从XXiconView，是否立即显示。核心就在于这儿了。最后，我们再打印一遍SBIconView的所有属性，用来确认一下</p>

<p><img src="http://al1020119.github.io/images/nixiangqudong008.png" title="Caption" ></p>

<p>继续搜索关键词，果然又有大收获_shortcutMenuPeekGesture有一个如此手势，里边的东西的手势。</p>

<p><img src="http://al1020119.github.io/images/nixiangqudong009.png" title="Caption" ></p>

<p>猜测得到了极大的肯定，下面就开始编写tweak了
由于是要给每一个iconView都添加手势，并且只添加一次，所以翻看了iconView头文件，查看他的init方法，选择了在initWithContentType中初始化。
贴上Tweak.xm的源码
关于代码的编写，中间也踩过不少坑，比如_revealMenuForIconView中的yes，no的设置，还好一开始猜的时候就全部手动赋值。
至于手势为什么传值需要如此怪异，因为检测发现原方法只识别长按手势，并不识别轻扫手势，但是因为个人习惯，不想覆盖系统的手势，只想单纯的增加一个功能。耿直的楼主尝试将一个轻扫手势，强行变成长按手势。很多属性都是readonly，但是这个使用kvc轻松搞定，现在轻扫一下手机！出现了意想之中的弹窗！
代码:</p>

<pre><code>#import "ZZ3DTouch.h"

%hook SBIconView 

- (id)initWithContentType:(id)arg1{
// 设置3Dtouch手势
  // 手势传过去的就是手势自己本身,本身拥有所在的view
  self.shortcutMenuPeekGesture = [[%c(UISwipeGestureRecognizer) alloc] initWithTarget:[%c(SBIconController) sharedInstance] action:@selector(_handleShortcutMenuPeek:)];
  self.shortcutMenuPeekGesture.direction = UISwipeGestureRecognizerDirectionUp;

  return %orig;
}

%end

%hook SBIconController

- (void)_revealMenuForIconView:(id)arg1 presentImmediately:(BOOL)arg2 {

  // yes 改为no之后没有显示，或者没有设置也会不显示

  %orig(iconView, YES);

}

- (void)_handleShortcutMenuPeek:(id)arg1

{
  UISwipeGestureRecognizer *swipe = arg1;
  UILongPressGestureRecognizer *press = [[UILongPressGestureRecognizer alloc] init];
  [press setValue:@(UIGestureRecognizerStateBegan) forKey:@"state"];
  [press setValue:swipe.view forKey:@"view"];

%orig(press);

}
%end
</code></pre>

<p><img src="http://al1020119.github.io/images/nixiangqudong010.png" title="Caption" ></p>

<p><img src="http://al1020119.github.io/images/nixiangqudong011.png" title="Caption" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[游戏反编译]]></title>
    <link href="http://al1020119.github.io/blog/2016/03/30/youxifanbianyi/"/>
    <updated>2016-03-30T13:32:08+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/03/30/youxifanbianyi</id>
    <content type="html"><![CDATA[<p> ipa游戏反编译
看不懂的请飘过，不要继续。
这不是给新手看的，也代表你不需要解决程序的修改问题。
这些技巧不只用于游戏的修改。</p>

<p>下載 Windows 工具</p>

<p>Windows :
winscp <a href="http://winscp.net/eng/download.php">http://winscp.net/eng/download.php</a>
PuTTY <a href="http://putty.very.rulez.org/latest/x86/putty.exe">http://putty.very.rulez.org/latest/x86/putty.exe</a></p>

<p>Mac / Linux :
用內置的 Terminal 便可</p>

<!--more-->


<p>没 wifi 用 iPhone Tunnel Suite 3.0
<a href="http://bbs.weiphone.com/read-htm-tid-597149.html">http://bbs.weiphone.com/read-htm-tid-597149.html</a></p>

<p>苹果电脑用 iPhoneSSH
<a href="http://bbs.weiphone.com/read-htm-tid-720564.html">http://bbs.weiphone.com/read-htm-tid-720564.html</a></p>

<p>iPhone/iPod Touch 在 cydia 內安裝 deb 包
安装这些 deb 包最方便的方法是在 Cydia 内搜索及直接安装，这里提供的下载包及依赖包的链接下载点是方便手工安装时用</p>

<p>OpenSSH (openssh) 及 OpenSSL(openssl) （与iPhone/iPod Touch 终端操作）
<a href="http://apt.saurik.com/debs/openssh_5.2p1-8_iphoneos-arm.deb">http://apt.saurik.com/debs/openssh_5.2p1-8_iphoneos-arm.deb</a>
<a href="http://apt.saurik.com/debs/openssl_0.9.8k-9_iphoneos-arm.deb">http://apt.saurik.com/debs/openssl_0.9.8k-9_iphoneos-arm.deb</a></p>

<p>unzip 及 zip （解压缩及压缩打包工具）
<a href="http://apt.saurik.com/debs/unzip_5.52-5_iphoneos-arm.deb">http://apt.saurik.com/debs/unzip_5.52-5_iphoneos-arm.deb</a>
<a href="http://apt.saurik.com/debs/zip_2.32-5_iphoneos-arm.deb">http://apt.saurik.com/debs/zip_2.32-5_iphoneos-arm.deb</a></p>

<p>vbindiff (iPhone 上的十六进制查看差异及修改器)
<a href="http://apt.saurik.com/debs/vbindiff_3.0b1-3_iphoneos-arm.deb">http://apt.saurik.com/debs/vbindiff_3.0b1-3_iphoneos-arm.deb</a></p>

<p>Link Identity Editor (ldid) 及 Darwin CC Tools (odcctools)（修改后用 ldid 签名, odcctools 包括 otool, linker , assembler汇编)
<a href="http://apt.saurik.com/debs/ldid_610-5_iphoneos-arm.deb">http://apt.saurik.com/debs/ldid_610-5_iphoneos-arm.deb</a>
<a href="http://apt.saurik.com/debs/odcctools_286-8_iphoneos-arm.deb">http://apt.saurik.com/debs/odcctools_286-8_iphoneos-arm.deb</a>
<a href="http://apt.saurik.com/debs/uuid_1.6.0-2_iphoneos-arm.deb">http://apt.saurik.com/debs/uuid_1.6.0-2_iphoneos-arm.deb</a></p>

<p>Diff Utilities (diffutils) (文本差异工具 diff)
<a href="http://apt.saurik.com/debs/diffutils_2.8.1-6_iphoneos-arm.deb">http://apt.saurik.com/debs/diffutils_2.8.1-6_iphoneos-arm.deb</a></p>

<p>less (文本查看工具)
<a href="http://apt.saurik.com/debs/less_418-3_iphoneos-arm.deb">http://apt.saurik.com/debs/less_418-3_iphoneos-arm.deb</a></p>

<p>Vi IMproved (vim) 或 nano (文本编辑工具)
<a href="http://apt.saurik.com/debs/vim_7.1-3_iphoneos-arm.deb">http://apt.saurik.com/debs/vim_7.1-3_iphoneos-arm.deb</a>
<a href="http://apt.saurik.com/debs/ncurses_5.7-9_iphoneos-arm.deb">http://apt.saurik.com/debs/ncurses_5.7-9_iphoneos-arm.deb</a>
或
<a href="http://apt.saurik.com/debs/nano_2.0.7-5_iphoneos-arm.deb">http://apt.saurik.com/debs/nano_2.0.7-5_iphoneos-arm.deb</a>
<a href="http://apt.saurik.com/debs/ncurses_5.7-9_iphoneos-arm.deb">http://apt.saurik.com/debs/ncurses_5.7-9_iphoneos-arm.deb</a></p>

<p>GNU Debugger (gdb) (程序调试工具) iOS 4.3.x 更新
<a href="http://apt.saurik.com/debs/gdb_1518-11_iphoneos-arm.deb">http://apt.saurik.com/debs/gdb_1518-11_iphoneos-arm.deb</a>
<a href="http://apt.saurik.com/debs/ncurses_5.7-9_iphoneos-arm.deb">http://apt.saurik.com/debs/ncurses_5.7-9_iphoneos-arm.deb</a>
<a href="http://apt.saurik.com/debs/readline_6.0-7_iphoneos-arm.deb">http://apt.saurik.com/debs/readline_6.0-7_iphoneos-arm.deb</a>
<a href="http://apt.saurik.com/debs/sqlite3_3.5.9-12_iphoneos-arm.deb">http://apt.saurik.com/debs/sqlite3_3.5.9-12_iphoneos-arm.deb</a>
<a href="http://apt.saurik.com/debs/sqlite3-lib_3.5.9-2_iphoneos-arm.deb">http://apt.saurik.com/debs/sqlite3-lib_3.5.9-2_iphoneos-arm.deb</a>
<a href="http://apt.saurik.com/debs/sqlite3-dylib_3.5.9-1_iphoneos-arm.deb">http://apt.saurik.com/debs/sqlite3-dylib_3.5.9-1_iphoneos-arm.deb</a></p>

<p>GNU Debugger (gdb) (程序调试工具)
<a href="http://apt.saurik.com/debs/gdb_962-5_iphoneos-arm.deb">http://apt.saurik.com/debs/gdb_962-5_iphoneos-arm.deb</a>
<a href="http://apt.saurik.com/debs/ncurses_5.7-9_iphoneos-arm.deb">http://apt.saurik.com/debs/ncurses_5.7-9_iphoneos-arm.deb</a>
<a href="http://apt.saurik.com/debs/readline_6.0-7_iphoneos-arm.deb">http://apt.saurik.com/debs/readline_6.0-7_iphoneos-arm.deb</a>
<a href="http://apt.saurik.com/debs/sqlite3_3.5.9-12_iphoneos-arm.deb">http://apt.saurik.com/debs/sqlite3_3.5.9-12_iphoneos-arm.deb</a>
<a href="http://apt.saurik.com/debs/sqlite3-lib_3.5.9-1_iphoneos-arm.deb">http://apt.saurik.com/debs/sqlite3-lib_3.5.9-1_iphoneos-arm.deb</a>
<a href="http://apt.saurik.com/debs/sqlite3-dylib_3.5.9-1_iphoneos-arm.deb">http://apt.saurik.com/debs/sqlite3-dylib_3.5.9-1_iphoneos-arm.deb</a></p>

<p>adv-cmds (ps 工具)
<a href="http://apt.saurik.com/debs/adv-cmds_119-5_iphoneos-arm.deb">http://apt.saurik.com/debs/adv-cmds_119-5_iphoneos-arm.deb</a></p>

<p>grep (grep 文本搜索工具)
<a href="http://apt.saurik.com/debs/grep_2.5.4-3_iphoneos-arm.deb">http://apt.saurik.com/debs/grep_2.5.4-3_iphoneos-arm.deb</a></p>

<p>ARM 参考书籍</p>

<p><a href="http://bbs.weiphone.com/read-htm-tid-363306.html">http://bbs.weiphone.com/read-htm-tid-363306.html</a></p>

<p>ARM指令集及使用方法</p>

<p>ARM System Developer&rsquo;s Guide (主要是看第三章 Chapter 3)</p>

<p>ARM Assembly Language Programming</p>

<p>修改及用 gdb 调试游戏流程</p>

<p>(1) 安装及试玩游戏，每个游戏的修改方法都不同，没有玩过这游戏，怎样知道要修改什么呢？
这教程用了 Final Fantasy 2 作例子</p>

<p>(2) 用 iTunes 安装 Final Fantasy 2 破解版本 (未破解的不能反汇编)</p>

<p>(3) 用putty / ssh 连接iPhone / iPod Touch，假设你的iPhone / iPod Touch 的IP地址是192.168.1.104</p>

<p>Connection type: 选 SSH
Port 选 22
按 Open</p>

<p>PuTTY 连接 192.168.1.104 后</p>

<p>Login 打 root
Password(假设你没有更改密码) 打 alpine</p>

<p>Mac / Linux Terminal 内打
ssh <a href="&#109;&#x61;&#x69;&#108;&#116;&#x6f;&#x3a;&#x72;&#x6f;&#111;&#x74;&#x40;&#49;&#57;&#x32;&#x2e;&#x31;&#54;&#x38;&#46;&#x31;&#x2e;&#49;&#x30;&#52;">&#114;&#111;&#x6f;&#116;&#64;&#x31;&#57;&#x32;&#46;&#x31;&#x36;&#56;&#46;&#x31;&#x2e;&#x31;&#48;&#x34;</a></p>

<p>(4) 进入游戏路径目录内(先决条件是已用 PuTTy / Terminal 连接iPhone / iPod Touch)
打
复制代码</p>

<pre><code>cd /var/mobile/Applications/*/FinalFantasy2.app
</code></pre>

<p>(5) 到上一层路径目录建立 cheat 临时工作路径目录及游戏程式临时修改档
打
复制代码</p>

<pre><code>cd ..
mkdir -p cheat
cd cheat
cp -p ../FinalFantasy2.app/FinalFantasy2 FinalFantasy2.original
</code></pre>

<p>(6) 反汇编原游戏程式
复制代码</p>

<pre><code>otool -tv FinalFantasy2.original &gt; FinalFantasy2.original.txt
</code></pre>

<p>(7) 查看反汇编代码分析并找出要修改的地方(每个游戏的修改地方都不同, 这点最难)
要修改游戏，你会有以下的困难或问题：</p>

<p>(i) 没有高阶源代码，只有反汇编代码
反汇编代码分析是困难的但绝对不是不可能作分析，你可以找到些不错的ARM Assembly的参考书
在上面亦已提供了一些很好的 ARM 指令参考
常见的是以下这些基本的指令及其执行条件码：</p>

<p>MOV 或 MVN 寄存器数值的传送操作
ADD 或 SUB 加减的算术操作
CMP 或 CMN 比较操作
AND、ORR、EOR 逻辑操作
B、BL、BNE、BGE 分支/跳转指令
MUL 乘法操作 或 LSL 是 二进制左移，左移一位，即十进制乘2倍
LDR 或 STR 加载及存储数据</p>

<p>每个指令都可加上执行条件码根据上一个运算、逻辑或比较指令的结果决定是否执行指令</p>

<p>执行条件码 (Condition Codes)：
① CS 及 CC（Carry）进位条件码，CS＝进位，否则＝CC(不进位).
② EQ 及 NE （Equal 或 Zero）相等或零条件码，EQ＝运算结果为相等或零时，否则＝NE(不相等).
③ VS 及 VC（Overflow）溢出条件码。 VS=溢出，否则＝VC(不溢出)。
④ PL 及 MI 条件码。 PL（Plus/Positive）＝结果为正，MI（Minus/Negative）＝结果为负。</p>

<p>⑤ GT 及 LT 条件码。 GT（Greater Than）＝大于(PL+VC+NE / MI+VS+NE)，LT（Less Than）＝小于(MI+VC / PL+VS)。
⑥ GE 及 LE 条件码。 GE（Greater Than or Equal）＝大或等于(PL+VC / MI+VS)，LE（Less Than or Equal）＝小或等于(MI+VC / PL+VS / EQ)。
⑦ HI 及 LO 条件码。 HI（Higher Than）＝无符号数(unsigned)高于(CS+NE)，LO（Lower Than）＝无符号数(unsigned)低于(CC)。
⑧ HS 及 LS 条件码。 HS（Higher or Same）＝无符号数(unsigned)高于或相等(CS/EQ)，LS（Lower or Same）＝无符号数(unsigned)低于或相等(CC/EQ)。
⑨ AL 及 NV 条件码。 条件码默认为AL（Always）＝无条件执行，NV（Never）是AL的相反＝不执行。</p>

<p>例子及其注解意思
复制代码</p>

<p>CMP R0, R1       @寄存器数值 R0 及 R1 的比较
MOVGT R2, R0     @如果结果 R0 >(大于) R1，则执行MOV R2, R0即 R2＝R0
MOVLE R2, R1     @如果结果 R0 &lt;=(小或等于) R1，则执行MOV R2, R1即 R2＝R1</p>

<p>复制代码</p>

<p>LDR R1, [R0]     @意思是 R1 = <em>R0，从R0指向的地址处的数据载入到寄存器 R1
STR R1, [R0]     @意思是 </em>R0 = R1，把寄存器 R1内的数据写到 R0 内指向的地址处</p>

<p>ARM 指令集及使用方法</p>

<p>(ii) 看不懂游戏程式流程，没法分析
有很多人都喜欢用 IDA Pro Advanced 去做分析， 无疑这软件是个非常好的静态分析工具，它有图形视图显示代码流程作搜索及深层分析。除了可分析反汇编代码外，亦可反汇编一些 otool 不能处理的工作。 但 IDA Pro Advanced 在iPhone 的程式只适合做静态的分析。</p>

<p>你可以在这里下载 IDA Pro Advanced 5.2 及其参考书，建议你使用功能及视图比较强大的 Windows 版本。
<a href="http://bbs.weiphone.com/read-htm-tid-363306.html">http://bbs.weiphone.com/read-htm-tid-363306.html</a></p>

<p>只看代码是不能作分析，要配合动态调试去了解程式的细节在实际运行时发生的数据及变化。在第15步就有用 gdb 作动态调试的例子去设置断点、继续、跟踪及分析代码。gdb 的参考书可在上面的链接下载。</p>

<p>(iii) 找不到游戏的数据例如金钱，经验值，装备，等级暂存在那？</p>

<p>引用</p>

<p>方法一：在 gdb 设置断点分析
ARM CPU 有个特性便是一些加减计算要传送到CPU寄存器(register) 进行，因此你会经常看到这些要找的数据会先从内存用LDR 指令载入到寄存器, 经过一些计算(加或减)后及防溢位判断后便用STR 指令存储这寄存器回内存地址。</p>

<p>另外由于这些程式大多是用 Objective C 或 C++ 语言写成，这些程序员会用一些描述性的函数名，例如带有 Money, Price, Gold, Exp, Item, Life, Level 字段等。</p>

<p>利用这两点便可以将程序锁定在某些函数上，再利用 gdb 调试工具暂停在某些点一步一步地单步执行及查看一些寄存器，印证是否与你要找的数据是否有关。</p>

<pre><code>在FinalFantasy2 的这实例中, 是用这方法找到修改点
用 less 工具去找寻 Money
putty / Terminal 打
</code></pre>

<p>复制代码</p>

<pre><code>less FinalFantasy2.original.txt



在 less 工具內打
</code></pre>

<p>复制代码</p>

<pre><code>/Money


去开始找寻(按 N 键去继续找寻)，便会找到这段代码像是要存储金钱数据(SetMoney)，0007b218是进入这段代码的开始地址
</code></pre>

<p>复制代码</p>

<pre><code>__ZN14cFF2GlobalWork19sysGAMEPrm_SetMoneyEj:
0007b218 e59f300c ldr r3, [pc, #12] ; 0x7b22c
0007b21c e580120c str r1, [r0, #524]
0007b220 e1510003 cmp r1, r3
0007b224 8580320c strhi r3, [r0, #524]
0007b228 e12fff1e bx lr



首先在iPhone或iPod Touch 开始Final Fantasy 2 直至游戏已 Resume及进入游戏。


① 在PuTTY / Terminal 找FinalFantasy2 的运行中的进程编号(process id)

PuTTY / Terminal 打
</code></pre>

<p>复制代码</p>

<pre><code>ps ax



得到
</code></pre>

<p>复制代码</p>

<pre><code>1115   ??  Ss     1:30.86 /var/mobile/Applications/XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX/FinalFantasy2.app/FinalFantasy2



找到FinalFantasy2 游戏现时运行中的进程编号是 1115

② 用gdb 进入调试运行中的进程编号1115
PuTTY / Terminal 打
</code></pre>

<p>复制代码</p>

<pre><code>gdb -p 1115



此时游戏会暂停，音乐也暂停

③ 用gdb 设定断点breakpoint在十六进制地址0x7b218

PuTTY / Terminal 打
</code></pre>

<p>复制代码</p>

<pre><code>break *0x7b218



④ 继续 continue 游戏
PuTTY / Terminal 打
</code></pre>

<p>复制代码</p>

<pre><code>c



⑤ 将Final Fantasy 2 游戏进入战斗，战胜后游戏会在十六进制地址0x7b218处停止

⑥ 暂停后，离开这分支__ZN14cFF2GlobalWork19sysGAMEPrm_SetMoneyEj
PuTTY / Terminal 打
</code></pre>

<p>复制代码</p>

<pre><code>finish



⑦ 反汇编现时地址上面的代码
</code></pre>

<p>复制代码</p>

<pre><code>disassem $pc-28 $pc


得到
</code></pre>

<p>复制代码</p>

<pre><code>0x0003baac &lt;_ZN10FF2cBattle12SENRIHIN_CHKEP12thBATMonsterP6X86REG 180&gt;: bl 0x78e30 &lt;_ZN14cFF2GlobalWork8InstanceEv&gt;
0x0003bab0 &lt;_ZN10FF2cBattle12SENRIHIN_CHKEP12thBATMonsterP6X86REG 184&gt;: mov r4, r0
0x0003bab4 &lt;_ZN10FF2cBattle12SENRIHIN_CHKEP12thBATMonsterP6X86REG 188&gt;: bl 0x78e30 &lt;_ZN14cFF2GlobalWork8InstanceEv&gt;
0x0003bab8 &lt;_ZN10FF2cBattle12SENRIHIN_CHKEP12thBATMonsterP6X86REG 192&gt;: bl 0x7b230 &lt;_ZN14cFF2GlobalWork19sysGAMEPrm_GetMoneyEv&gt;
0x0003babc &lt;_ZN10FF2cBattle12SENRIHIN_CHKEP12thBATMonsterP6X86REG 196&gt;: add r1, r0, r5
0x0003bac0 &lt;_ZN10FF2cBattle12SENRIHIN_CHKEP12thBATMonsterP6X86REG 200&gt;: mov r0, r4
0x0003bac4 &lt;_ZN10FF2cBattle12SENRIHIN_CHKEP12thBATMonsterP6X86REG 204&gt;: bl 0x7b218 &lt;_ZN14cFF2GlobalWork19sysGAMEPrm_SetMoneyEj&gt;



这时会发现在_ZN14cFF2GlobalWork19sysGAMEPrm_GetMoneyEv
</code></pre>

<p>及_ZN14cFF2GlobalWork19sysGAMEPrm_SetMoneyEj
中间0x0003babc 地址的代码add r1, r0, r5 是最可疑的</p>

<pre><code>⑧ 取消断点1及设定新断点breakpoint在十六进制地址0x0003babc 及重新继续continue 游戏
PuTTY / Terminal 打
</code></pre>

<p>复制代码</p>

<pre><code>disable 1
break *0x3babc
c



在iPhone或iPod Touch查看现时游戏的金钱例如是4888，将Final Fantasy 2 游戏进入战斗，战胜后游戏会新断点2地址0x3babc处停止

⑨ 当游戏在新断点2暂停时查看寄存器就发现 r0 是当时的金钱余额及 r5 是战胜后得到的金钱
PuTTY / Terminal 打
</code></pre>

<p>复制代码</p>

<pre><code>i r $r0 $r1 $r5 $pc



⑩ 假设已找到应修改的地址是 0003babc，便可继续下面第(8)步
</code></pre>

<p>引用</p>

<p>方法二：在 gdb 搜索内存数据值及设置观察点(watchpoint)</p>

<pre><code>游戏的数据都会暂存在堆(heap)内存, 于游戏退出前储存在 iPhone 或 iPod Touch的闪存记忆体内, 一些经验值或金钱的数字是比较独特，在内存重复出现的机会不多，这些唯一的数字便可用这方法去进行搜索。

这里用了 Zenonia 2 v1.0 作例子，下面的游戏截图便看到用一个独特的经验值数字 672 去开始这方法



① 在 PuTTY / Terminal 用  ps ax  的指令找到 ZENONIA2 游戏现时运行中的进程编号是 1123

② 使用 gdb 进入运行中的进程编号 1123
PuTTY / Terminal 打
</code></pre>

<p>复制代码</p>

<pre><code>gdb -p 1123



此时游戏会暂停，音乐也暂停

③ 用 gdb 输入这些指令包括，内存开始地址(0x800000)、结束地址(0x880000)及要搜索的数字672如下:

PuTTY / Terminal 打
</code></pre>

<p>复制代码</p>

<pre><code>set $x=0x800000
while(*++$x!=672 &amp;&amp; $x&lt;0x880000)
end



④ 输入 end 之后等候数十秒 ....，待gdb去搜索这段内存地址

⑤ gdb 搜索完毕后
PuTTY / Terminal 打
</code></pre>

<p>复制代码</p>

<pre><code>p/x $x


得到
</code></pre>

<p>复制代码</p>

<pre><code>$1 = 0x85e28c
</code></pre>

<p>这代表 gdb 已找到在 0x85e28c 的内存地址的存储数字是 672</p>

<pre><code>PuTTY / Terminal 打
</code></pre>

<p>复制代码</p>

<pre><code>x/dw 0x85e28c


得到确认 0x85e28c 的内存地址的存储数字是 672
</code></pre>

<p>复制代码</p>

<pre><code>0x85e28c:    672



 ⑥ 用 gdb 继续搜索
PuTTY / Terminal 打 (或按方向键 ↑ 4次，然后回车，免重复输入)
</code></pre>

<p>复制代码</p>

<pre><code>while(*++$x!=672 &amp;&amp; $x&lt;0x880000)
end


再等十多秒，gdb 搜索完毕后
PuTTY / Terminal 打
</code></pre>

<p>复制代码</p>

<pre><code>p/x $x


得到
</code></pre>

<p>复制代码</p>

<pre><code>$2 = 0x880000
</code></pre>

<p>这代表 gdb 已到结束的地址 0x880000，都没有找到。这也表示数字 672 是唯一出现在 0x85e28c 要找的内存范围内。</p>

<pre><code>⑦ 用 gdb 更改内存地址 0x85e28c 的存储数字为 1000
PuTTY / Terminal 打
</code></pre>

<p>复制代码</p>

<pre><code>set {int}0x85e28c=1000



PuTTY / Terminal 打
</code></pre>

<p>复制代码</p>

<pre><code>x/dw 0x85e28c



得到确认已成功更改数字
</code></pre>

<p>复制代码</p>

<pre><code>0x85e28c:    1000



⑧ 继续 continue 游戏
PuTTY / Terminal 打
</code></pre>

<p>复制代码</p>

<pre><code>c



⑨ 在回到游戏里退出 STATUS 画面再进入 STATUS，画面内数据重刷后，确认已成功更改经验值数字为1000


留意:由于游戏数据在堆(heap)内存的地址不是固定的，所以每次运行的进程都要再搜索新的内存地址。另外，搜索的内存地址范围也会改变，如果在 0x800000 至 0x880000 范围内找不到的话，就要往后试 0x880000 至 0x900000 新的范围。

     另外：用相同搜索方法也可以找到金钱数字在这次运行进程是在内存地址 0x874c04

⑩ 找到经验值地址后便可设置观察点(watchpoint)于内存地址 0x85e28c

设置观察点的目的是当内存地址值被读或被写时，会显示数据及暂停程序

PuTTY / Terminal 打
</code></pre>

<p>复制代码</p>

<pre><code>watch *0x85e28c


及继续游戏
PuTTY / Terminal 打
</code></pre>

<p>复制代码</p>

<pre><code>c
</code></pre>

<p>留意:游戏在观察点(watchpoint) 生效下运行是非常的慢，有些游戏是不能正常运作，有时候手机也要重启，所以下面的步骤是不一定可以进行的</p>

<pre><code>⑪ 将游戏进入战斗打怪后程序便会暂停在 0x9f508 地址，gdb 会显示
</code></pre>

<p>复制代码</p>

<pre><code>Hardware watchpoint 1: *8774284
Old value = 1000
New value = 1086
0x0009f508 in CMvPlayer::CheckLevelUp ()



PuTTY / Terminal 打
</code></pre>

<p>复制代码</p>

<pre><code>x/14i $pc-16


得到
</code></pre>

<p>复制代码</p>

<pre><code>0x9f4f8 &lt;_ZN9CMvPlayer12CheckLevelUpEj+60&gt;:    b.n    0x9f508 &lt;_ZN9CMvPlayer12CheckLevelUpEj+76&gt;
0x9f4fa &lt;_ZN9CMvPlayer12CheckLevelUpEj+62&gt;:    adds    r0, r4, #0
0x9f4fc &lt;_ZN9CMvPlayer12CheckLevelUpEj+64&gt;:    movs    r1, #1
0x9f4fe &lt;_ZN9CMvPlayer12CheckLevelUpEj+66&gt;:    movs    r2, #0
0x9f500 &lt;_ZN9CMvPlayer12CheckLevelUpEj+68&gt;:    subs    r5, r5, r3
0x9f502 &lt;_ZN9CMvPlayer12CheckLevelUpEj+70&gt;:    bl    0x9f338 &lt;_ZN9CMvPlayer9OnLevelUpEii&gt;
0x9f506 &lt;_ZN9CMvPlayer12CheckLevelUpEj+74&gt;:    movs    r3, #1
0x9f508 &lt;_ZN9CMvPlayer12CheckLevelUpEj+76&gt;:    str    r5, [r4, r6]
0x9f50a &lt;_ZN9CMvPlayer12CheckLevelUpEj+78&gt;:    cmp    r3, #0
0x9f50c &lt;_ZN9CMvPlayer12CheckLevelUpEj+80&gt;:    beq.n    0x9f516 &lt;_ZN9CMvPlayer12CheckLevelUpEj+90&gt;
0x9f50e &lt;_ZN9CMvPlayer12CheckLevelUpEj+82&gt;:    cmp    r5, #0
0x9f510 &lt;_ZN9CMvPlayer12CheckLevelUpEj+84&gt;:    beq.n    0x9f516 &lt;_ZN9CMvPlayer12CheckLevelUpEj+90&gt;
0x9f512 &lt;_ZN9CMvPlayer12CheckLevelUpEj+86&gt;:    movs    r5, #0
0x9f514 &lt;_ZN9CMvPlayer12CheckLevelUpEj+88&gt;:    b.n    0x9f4c6 &lt;_ZN9CMvPlayer12CheckLevelUpEj+10&gt;



PuTTY / Terminal 打
</code></pre>

<p>复制代码</p>

<pre><code>i r $r5 $r4 $r6 $pc
p/x $r4+$r6


得到
</code></pre>

<p>复制代码</p>

<pre><code>r5             0x43E    1086
r4             0x85DC00    8772608
r6             0x68c    1676
pc             0x9f508    652552
$5 = 0x85e28c



这时确认了 0x9f508 地址这句代码
str    r5, [r4, r6]
的意思是，r4 + r6 = 0x85e28c ，把寄存器 r5 内的数字(1086) 写到 0x85e28c 的地址
</code></pre>

<p>　
    程序因要写进这0x85e28c 的地址，所以暂停了，这就是观察点(watchpoint) 的强大功能。</p>

<pre><code>PuTTY / Terminal 打
</code></pre>

<p>复制代码</p>

<pre><code>bt


得到
</code></pre>

<p>复制代码</p>

<pre><code>#0  0x0009f508 in CMvPlayer::CheckLevelUp ()
#1  0x0009ff2e in CMvPlayer::DoUpdate ()
#2  0x00094744 in CMvObject::Update ()
#3  0x000969cc in CMvObjectMgr::Update ()
#4  0x000662e6 in CMvGameState::UpdateGame ()



这时就可根据上面得到的信息在这段代码的前后范围进行跟踪、设置断点及进一步的分析
</code></pre>

<p>有新的方法时，再继续更新 &hellip;&hellip;&hellip;&hellip;</p>

<p>(iv) 不知道修改点在那及改为什么？</p>

<p>修改程序是不能插入程序代码，主要原因是移位后的程序是不能运行的。一般的做法是找到要修改的位置在原档案位置修改代码改为你需要的指令。 修改点一定要经过分析代码后再不断地用动态分析确定后，在适当的地方重覆试验及调试验证修改后的结果 。</p>

<ul>
<li>一些RPG游戏的特性，例如是金钱或经验值是会在战斗后重算及更新，一般都是要找到及修改更新数据前的指令。金钱的修改点也可以修改在买卖装备时的指令。连续升级的修改主要是看该游戏是怎样升级，例如 Inotia 2是根据经验值去升级，只要找到判断经验值的指令代码地址，修改其判断的指令便可。</li>
</ul>


<p>对于游戏来说，一般的指令修改例子如下：</p>

<p>① 修改寄存器的增加数字例如
    Final Fantasy II 增加战胜后所得金钱
    地址 0003babc
    add r1, r0, r5
    改为
    add r1, r0, r5, lsl #5</p>

<p>② 修改寄存器减少的数字为零例如
    Inotia 2 v 1.1.0 不扣技能点
    地址 00021b9c
    sub r3, #1
    改为
    sub r3, #0</p>

<pre><code>地址 00037b46 
sub r1, #1 
改为 
sub r1, #0 
</code></pre>

<p>③ 修改比较的寄存器例如
    花儿朵朵开-v1.0 不死作弊版 (这里 r2 寄存器是花朵已绽放的数量)
    地址 00004ee8
    cmp r2, r3
    改为
    cmp r2, #1 ; 0x1</p>

<p>④ 修改arm 32 位为两个arm thumb 16 位代码例如
    Inotia 2 v 1.1.0 roll点全18
    地址 0005c404
    bl 0x9914
    改为
    mov r0, #9
    mov r0, #9</p>

<pre><code>地址 0005c404, 0005c40e, 0005c41c, 0005c426 
bl 0x9914 
改为 
mov r0, #9 
mov r0, #9 
</code></pre>

<p>⑤ 要删除代码便要用 nop (no operation) 取代
    thumb 16 bits nop 是 46c0<br/>
    arm 32 bits nop 是 e1a00000</p>

<p>(8) 在FinalFantasy2 的这实例中，假设已找到应修改的地址是 0003babc，代码是 e0801005
复制代码</p>

<pre><code>0003bab8        eb00fddc        bl 0x7b230
0003babc        e0801005        add r1, r0, r5   @意思是 r1 = r0 +r5 ; r0 是当时的金钱余额; r5 是战胜后得到的金钱
0003bac0        e1a00004        mov r0, r4
0003bac4        eb00fdd3        bl 0x7b218     @分支到函数名 __ZN14cFF2GlobalWork19sysGAMEPrm_SetMoneyEj 去更新金錢余额
</code></pre>

<p>(9) 修改目标 : 将所得金钱乘大32倍
0003babc的应修改目标代码是
复制代码</p>

<pre><code>add r1, r0, r5, lsl#5 @意思是 r1 = r0 +( r5 二进制左移五位,即十进制乘大32倍)
</code></pre>

<p>(10) 找新ARM指令代码
add r1, r0, r5 的ARM指令代码是 e0801005
修改目标是要找到 add r1, r0, r5, lsl#5 的ARM指令代码 ?</p>

<p>用 vim 或 nano 建立 armtest.s 如下
复制代码</p>

<pre><code>    .file "armtest.s"
    .globl _main
    .code 32
_main:
    add r1, r0, r5
    add r1, r0, r5, lsl #5
</code></pre>

<p>留意: 一些程式反汇编后是ARM Thumb, ARM Thumb 是16 bits 而ARM 是32 bits. ARM 32 bits 及 ARM Thumb 的分别请找上面 ARM Assembler 的参考(ARM Thumb 的可用指令是比 ARM 32 bits 少)。 如果要找 ARM Thumb 代码要将上面的.code 32改为.code 16 及加上 .thumb_func _main 如下
复制代码</p>

<pre><code>    .code 16
    .thumb_func _main
</code></pre>

<p>汇编 arm 打
复制代码</p>

<pre><code>as armtest.s -o armtest.o ; otool -tv armtest.o
</code></pre>

<p>便看到</p>

<p>复制代码</p>

<pre><code>(__TEXT,__text) section
_main:
00000000    e0801005    add r1, r0, r5
00000004    e0801285    add r1, r0, r5, lsl #5
</code></pre>

<p>及得到add r1, r0, r5, lsl #5 目标ARM指令代码为 e0801285</p>

<p>(11) 建立修改程式第一版FinalFantasy2.v1及用十六进制修改器修改代码</p>

<p>打
复制代码</p>

<pre><code>cp -p FinalFantasy2.original FinalFantasy2.v1      
vbindiff FinalFantasy2.v1
</code></pre>

<p>进入vibindiff 后按G及输入地址3AABC跳到要修改的位置如下</p>

<p>留意: 在第8步时找到的位置是0003Babc，但修改程式的位置要减去十六进制0x1000得到3Aabc
(0x3babc 减 0x1000 等于 0x3aabc)</p>

<p>按E键开始修改，将
05 10 80 E0
改为
85 12 80 E0</p>

<p>然后按Esc键及Y键确认修改</p>

<p>最后按Q键离开 vbindiff 修改器</p>

<p>如下</p>

<p>留意: 修改器显示的05 10 80 E0与反汇编的代码e0801005的位置顺序是倒的</p>

<p>(12) 反汇编修改程式第一版 v1 及比较原版本 original
打
复制代码</p>

<pre><code>otool -tv FinalFantasy2.v1 &gt; FinalFantasy2.v1.txt
diff FinalFantasy2.original.txt FinalFantasy2.v1.txt
</code></pre>

<p>也可以用 otool -otV</p>

<p>得到</p>

<p>复制代码</p>

<pre><code>&lt; FinalFantasy2.original:
---
&gt; FinalFantasy2.v1:
59597c59597
&lt; 0003babc    e0801005    add    r1, r0, r5
---
&gt; 0003babc    e0801285    add    r1, r0, r5, lsl #5
</code></pre>

<p>(13) 对修改程式第一版重新签名
打
复制代码</p>

<pre><code>ldid -s FinalFantasy2.v1
</code></pre>

<p>(14) 将签名后的程式放回程式路径进行测试
首先备份原程式(留意:要用mv移动不要用cp)
打
复制代码</p>

<pre><code>mv ../FinalFantasy2.app/FinalFantasy2 ../FinalFantasy2.app/FinalFantasy2.bak
</code></pre>

<p>安装修改后的程式及更新权限
打
复制代码</p>

<pre><code>cp -p FinalFantasy2.v1 ../FinalFantasy2.app/FinalFantasy2
chown mobile:mobile ../FinalFantasy2.app/FinalFantasy2
chmod 0755 ../FinalFantasy2.app/FinalFantasy2
</code></pre>

<p>(15) 用 gdb 调试游戏</p>

<p>调试是用 gdb，在这里的目的是设置断点使游戏暂停，查看CPU的寄存器，印证修改是否成功。由于游戏占用很多内存，在游戏运行时调试再加ssh 连接很多时候都会崩溃。所以用 iPod Touch 3代 或 iPhone 3GS 做这项工作会有优势。</p>

<p>首先在iPhone或iPod Touch 开始Final Fantasy 2 直至游戏已Resume及进入游戏。</p>

<p>在iPhone或iPod Touch查看现时游戏的金钱例如是 7223</p>

<p>① 在putty / Terminal 找 FinalFantasy2 的运行中的进程编号 (process id)</p>

<p>PuTTY / Terminal 打
复制代码</p>

<pre><code>ps ax
</code></pre>

<p>得到</p>

<p>复制代码</p>

<pre><code>1115   ??  Ss     1:30.86 /var/mobile/Applications/XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX/FinalFantasy2.app/FinalFantasy2
</code></pre>

<p>找到 FinalFantasy2 游戏现时运行中的进程编号是 1115</p>

<p>② 用 gdb 进入调试运行中的进程编号 1115
PuTTY / Terminal 打
复制代码</p>

<pre><code>gdb -p 1115
</code></pre>

<p>此时游戏会暂停，音乐也暂停</p>

<p>③ 用 gdb 设定断点breakpoint在十六进制地址 0x3babc (即在第8步时找到的位置0003babc)
PuTTY / Terminal 打
复制代码</p>

<pre><code>break *0x3babc
</code></pre>

<p>④ 继续 continue 游戏
PuTTY / Terminal 打
复制代码</p>

<pre><code>c
</code></pre>

<p>⑤ 将Final Fantasy 2 游戏进入战斗，战胜后游戏会在十六进制地址 0x3babc处停止</p>

<p>⑥ 暂停后，查看 CPU 寄存器 register (info register 指令)
PuTTY / Terminal 打
复制代码</p>

<pre><code>i r $r0 $r1 $r5 $pc
</code></pre>

<p>得到</p>

<p>复制代码</p>

<pre><code>r0             0x1c37    7223
r1             0x25    37
r5             0x25    37
pc             0x3babc    244412
</code></pre>

<p>印证了 r0=7223 是现时的金钱
游戏暂停在 pc=0x3babc</p>

<p>⑦ 查看下一步将要运行的反汇编指令
PuTTY / Terminal 打
复制代码</p>

<pre><code>x/i $pc
</code></pre>

<p>得到 add r1, r0, r5, lsl #5，印证成功修改指令</p>

<p>复制代码</p>

<pre><code>0x3babc &lt;_ZN10FF2cBattle12SENRIHIN_CHKEP12thBATMonsterP6X86REG+196&gt;:    add    r1, r0, r5, lsl #5
</code></pre>

<p>⑧ 运行下一步 stepi 指令
PuTTY / Terminal 打
复制代码</p>

<pre><code>si
</code></pre>

<p>查看 CPU 寄存器 register (info register 指令)
PuTTY / Terminal 打
复制代码</p>

<pre><code>i r $r0 $r1 $r5 $pc
</code></pre>

<p>得到
复制代码</p>

<pre><code>r0             0x1c37    7223
r1             0x20d7    8407
r5             0x25    37
pc             0x3bac0    244416
</code></pre>

<p>此时印证了 r1 = r0 +( r5 x 32)
            = 7223 + (27 x 32)
            = 8407</p>

<p>查看下一步将要运行的反汇编指令
putty / Terminal 打
复制代码</p>

<pre><code>x/i $pc
</code></pre>

<p>得到</p>

<p>复制代码</p>

<pre><code>0x3bac0 &lt;_ZN10FF2cBattle12SENRIHIN_CHKEP12thBATMonsterP6X86REG+200&gt;:    mov    r0, r4
</code></pre>

<p>⑨ 继续 continue 游戏
PuTTY / Terminal 打
复制代码</p>

<pre><code>c
</code></pre>

<p>⑩ Final Fantasy 2 游戏显示战胜后得到37的金钱，但实际金钱余额是 8407，印证修改游戏已成功。</p>

<p>⑪ 离开 gdb</p>

<p>按下Ctrl+C 组合键停止执行进程</p>

<p>PuTTY / Terminal 打
复制代码</p>

<pre><code>quit
</code></pre>

<p>及按 y 键确认离开 gdb</p>

<p>留意:在上面第⑥步暂停时，你可以输入指令去更改CPU 寄存器 register
例如打
set $r5=1000
去试试增加金钱数目</p>

<p>(16) 假设已调试完成，便可将修改后的程式打包发布</p>

<p>进入游戏路径目录内，打
复制代码</p>

<pre><code>cd /var/mobile/Applications/*/FinalFantasy2.app
</code></pre>

<p>到上一层路径目录
复制代码</p>

<pre><code>cd ..
</code></pre>

<p>建立 IPA 所要的路径及档案及删除不需要的备份档案</p>

<p>复制代码</p>

<pre><code>rm -fr Payload
mkdir -p Payload
cp -pr FinalFantasy2.app Payload/
rm -fr Payload/FinalFantasy2.app/FinalFantasy2*.bak
</code></pre>

<p>打包 ipa 为 FinalFantasy2_v1.ipod4g.ipa
复制代码</p>

<pre><code>zip -r FinalFantasy2_v1.ipod4g.ipa Payload iTunesArtwork
</code></pre>

<p>找现时的路径
复制代码</p>

<pre><code>pwd
</code></pre>

<p>得到</p>

<p>复制代码</p>

<pre><code>/var/mobile/Applications/XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
</code></pre>

<p>用 winscp 或Terminal 的 scp 指令传送这档作发布</p>

<p>复制代码</p>

<pre><code>/var/mobile/Applications/XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX/FinalFantasy2_v1.ipod4g.ipa
</code></pre>

<p>XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX 是随机路径</p>

<p>(17) 其他有用的技巧</p>

<p>① 由于修改游戏的程式代码是很少量, 相对重覆调试及动态分析工作比较多，此教程便介绍了用iPhone 的工具直接做修改及反汇编。这样对于少量修改程式代码及重覆在iPhone调试是比较要传回PC做修改是更有效率的。</p>

<p>② 调试的工具 gdb 是比较难用，但有些方法是可提高使用 gdb 的效率。</p>

<p>例如：在 gdb 建立宏 macro define
在 iphone 建立这档案(~/.gdbinit) 内容为
复制代码</p>

<pre><code>define ascii_char
set $_c=*(unsigned char *)($arg0)
if ( $_c &lt; 0x20 || $_c &gt; 0x7E )
printf "."
else
printf "%c", $_c
end
end
document ascii_char
Print the ASCII value of arg0 or '.' if value is unprintable
end
define hex_quad
printf "%02X %02X %02X %02X  %02X %02X %02X %02X",  \
*(unsigned char*)($arg0), *(unsigned char*)($arg0 + 1),  \
*(unsigned char*)($arg0 + 2), *(unsigned char*)($arg0 + 3), \
*(unsigned char*)($arg0 + 4), *(unsigned char*)($arg0 + 5), \
*(unsigned char*)($arg0 + 6), *(unsigned char*)($arg0 + 7)
end
document hex_quad
Print eight hexadecimal bytes starting at arg0
end
define hexdump
printf "%08X : ", $arg0
hex_quad $arg0
printf " - "
hex_quad ($arg0+8)
printf " "
ascii_char ($arg0)
ascii_char ($arg0+1)
ascii_char ($arg0+2)
ascii_char ($arg0+3)
ascii_char ($arg0+4)
ascii_char ($arg0+5)
ascii_char ($arg0+6)
ascii_char ($arg0+7)
ascii_char ($arg0+8)
ascii_char ($arg0+9)
ascii_char ($arg0+0xA)
ascii_char ($arg0+0xB)
ascii_char ($arg0+0xC)
ascii_char ($arg0+0xD)
ascii_char ($arg0+0xE)
ascii_char ($arg0+0xF)
printf "\n"
end
document hexdump
Display a 16-byte hex/ASCII dump of arg0
end
define hexdump1
hexdump $arg0
x/8h $arg0
printf "\n"
disassem $arg0 $arg0+16
printf "\n"
end
document hexdump1
Display a 16-byte hex/ASCII dump and disassembly of arg0
end
</code></pre>

<p>在用 gdb 调试时打
复制代码</p>

<pre><code>hexdump1 $pc
</code></pre>

<p>便可列出$pc位置后十六位的内容及反汇编的代码</p>

<p>③ 在断点设定一些要自动运行的指令</p>

<p>下面的意思是建立断点１
及在断点１停止时运行查看一些暂存器(i r $r0 $r1 $r5 $pc)及反汇编下四个指令代码(x/4i $pc)</p>

<p>复制代码</p>

<pre><code>break *0x3babc
commands 1
i r $r0 $r1 $r5 $pc
x/4i $pc
end
</code></pre>

<p>④ 在 gdb 断点暂停时，是可改变内存及指令
FinalFantasy2 的例子，0x0003babc地址的指令是
打
复制代码</p>

<pre><code>x/i 0x0003babc
</code></pre>

<p>得到代码是
复制代码</p>

<pre><code>add r1, r0, r5
</code></pre>

<p>打
复制代码</p>

<pre><code>x/xw 0x0003babc
</code></pre>

<p>得到代码数值是
复制代码</p>

<pre><code>0xe0801005
</code></pre>

<p>改变指令代码数值打
复制代码</p>

<pre><code>set {int}0x0003babc = 0xe0801285
</code></pre>

<p>检查改变后的指令打
复制代码</p>

<pre><code>x/i 0x0003babc
</code></pre>

<p>得到改变后的指令代码是
复制代码</p>

<pre><code>add r1, r0, r5, lsl #5
</code></pre>

<p>这样就不用离开 gdb 即时看到修改代码后的效果</p>

<p>⑤ gdb 执行到程序中其他地址的命令</p>

<pre><code>例子：
stepi                           单步执行一个机器指令(命令步入函数)
nexti                           单步执行一个机器指令(命令步过函数)
nexti 2                        继续执行机器指令的数目为 2 个指令
finish                          继续执行至当前函数结束后，停止于其调用点
until *0x7b224            继续执行至特定地址*0x7b224
jump *0x3baac           跳转至特定地址*0x3baac 执行
</code></pre>

<p>⑥ gdb 调试记录的命令</p>

<pre><code>例子：
set logging file ./log1.txt      设定记录档
set logging on                     开始记录
set logging off                     停止记录
</code></pre>

<p>⑦ 学习别人修改程序的方法
看别人修改程序是最好的学习方法，只要你有原版本及修改后的版本，就可以知道修改的地址及方法
例如：
下载花儿朵朵开-v1.0.rar 原版本</p>

<p>下载花儿朵朵开-v1.0.rar 不死作弊修改版</p>

<p>解压后将两个 ipa 文件，用 winscp 传到iPhone 路径 /var/root/flower 内</p>

<p>在 PuTTY / Terminal 连接iPhone / iPod Touch后</p>

<p>打
复制代码</p>

<pre><code>cd /var/root/flower
</code></pre>

<p>解压原游戏版本程序
在 PuTTY / Terminal 打
复制代码</p>

<pre><code>unzip *-v1.0.ipa
mv Payload/FlowerChainCN.app/FlowerChainCN FlowerChainCN.original
</code></pre>

<p>删除不需要的的路径及档案
在 PuTTY / Terminal 打
复制代码</p>

<pre><code>rm -fr Payload/ iTunesArtwork *.ipa
</code></pre>

<p>解压不死作弊修改版程序
在 PuTTY / Terminal 打
复制代码</p>

<pre><code>unzip *-v1.0.ipod4g.ipa
mv Payload/FlowerChainCN.app/FlowerChainCN FlowerChainCN.patched
</code></pre>

<p>删除不需要的的路径及档案
在 PuTTY / Terminal 打
复制代码</p>

<pre><code>rm -fr Payload/ iTunesArtwork *.ipa
</code></pre>

<p>反汇编原游戏程式及保存反汇编文本文件为 FlowerChainCN.original.txt
在 PuTTY / Terminal 打
复制代码</p>

<pre><code>otool -tv FlowerChainCN.original &gt; FlowerChainCN.original.txt
</code></pre>

<p>反汇编不死作弊修改版程式及保存反汇编文本文件为 FlowerChainCN.patched.txt
在 PuTTY / Terminal 打
复制代码</p>

<pre><code>otool -tv FlowerChainCN.patched &gt; FlowerChainCN.patched.txt
</code></pre>

<p>比较两个版本及找出差异
在 PuTTY / Terminal 打
复制代码</p>

<pre><code>diff FlowerChainCN.original.txt FlowerChainCN.patched.txt
</code></pre>

<p>得到
复制代码</p>

<pre><code>&lt; FlowerChainCN.original:
---
&gt; FlowerChainCN.patched:
3060c3060
&lt; 00004ee8 e1520003 cmp r2, r3
---
&gt; 00004ee8 e3520001 cmp r2, #1 ; 0x1
</code></pre>

<p>原版本列在左边及把差异列在右边并输出差异文本保存为 FlowerChainCN.diff.txt
在 PuTTY / Terminal 打
复制代码</p>

<pre><code>diff -y --left-column FlowerChainCN.original.txt FlowerChainCN.patched.txt &gt; FlowerChainCN.diff.txt
</code></pre>

<p>用 less 工具打开差异文本 FlowerChainCN.diff.txt
在 PuTTY / Terminal 打
复制代码</p>

<pre><code>less FlowerChainCN.diff.txt
</code></pre>

<p>在 less 工具内搜寻差异分隔字符 |
在 less 工具内打
复制代码</p>

<pre><code>/\|
</code></pre>

<p>得到下面差异的显示去做进一步分析
复制代码</p>

<pre><code>00004ee8 e1520003 cmp r2, r3 | 00004ee8 e3520001 cmp r2, #1 ; 0x1
</code></pre>

<p>在 PuTTY / Terminal 打这句也可看到原版本上下的代码
复制代码</p>

<pre><code>grep -C5 '|' FlowerChainCN.diff.txt
</code></pre>

<p>或
复制代码</p>

<pre><code>grep -C5 00004ee8  FlowerChainCN.original.txt
</code></pre>

<p>⑧ 最后送上我自购破解的一个很实用的iPhone小工具 - 64位计算器
这小工具除了可以做64位的计算外，还可以输入文字及显示Unicode的代码</p>

<pre><code>64 Bit Calculator

 64_Bit_Calc-v1.2.ipod4g.ipa (788 K) 下载次数:233 




64 Bit Calculator (iPad)   64_Bit_Calc_iPad-v1.2.ipa (1521 K) 下载次数:116 
</code></pre>

<p>关于 FinalFantasy2 1.0.4 版本 ldid 签名时出现错误信息 Segmentation fault</p>

<p>初代 iPhone 使用ARMv6 指令集, 直到3GS, iPad, IPhone 4设备苹果开始采用了 ARMv7 指令集</p>

<p>如果你打指令</p>

<p>复制代码</p>

<pre><code>otool -f FinalFantasy2
</code></pre>

<p>就会看到</p>

<p>复制代码</p>

<pre><code>architecture 0
    cputype 12
    cpusubtype 6
architecture 1
    cputype 12
    cpusubtype 9
</code></pre>

<p>你可以把 FinalFantasy2 切开为 FinalFantasy2V6</p>

<p>复制代码</p>

<pre><code>lipo -thin armv6  FinalFantasy2 -output FinalFantasy2V6
chmod +x FinalFantasy2V6
chown mobile:mobile FinalFantasy2V6
</code></pre>

<p>及切开为 FinalFantasy2V7</p>

<p>复制代码</p>

<pre><code>cp -p FinalFantasy2 FinalFantasy2tmp
echo -ne "\x09" | dd bs=1 seek=15 conv=notrunc status=noxfer of=FinalFantasy2tmp
echo -ne "\x06" | dd bs=1 seek=35 conv=notrunc status=noxfer of=FinalFantasy2tmp
lipo -thin armv6 FinalFantasy2tmp -output FinalFantasy2V7
rm FinalFantasy2tmp
chmod +x FinalFantasy2V7
chown mobile:mobile FinalFantasy2V7
</code></pre>

<p>但 iPhone 的 otool 不支持反汇编 ARMv7 指令集, 你要用新版本的 IDA Pro 反汇编</p>

<p>在 iPhone 你只可以反汇编 FinalFantasy2V6, 修改及用 ldid 去签名</p>

<p>FinalFantasy2V6 签名后便可替代原版本使用, 游戏来说ARMv6 指令集也可以, 只不过在新的设备上使用时不是最优化.</p>

<p>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[获取短信-联系人]]></title>
    <link href="http://al1020119.github.io/blog/2016/03/28/huoqushoujiduanxintongxunlulianxiren/"/>
    <updated>2016-03-28T13:32:08+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/03/28/huoqushoujiduanxintongxunlulianxiren</id>
    <content type="html"><![CDATA[<p>越狱的 ios 如何 获取 读取 提取 手机上的 短信 通话记录 联系人 等信息</p>

<p><a href="http://willson.sinaapp.com/2011/12/iphone">http://willson.sinaapp.com/2011/12/iphone</a> 获取短信脚本.html  Iphone获取短信脚本
<a href="http://bbs.9ria.com/thread-209349-1-1.html">http://bbs.9ria.com/thread-209349-1-1.html</a>          IPhone短信相关部分研究（转载）
<a href="http://blog.csdn.net/slinloss/article/details/8722806">http://blog.csdn.net/slinloss/article/details/8722806</a>       整理：iOS 短信与电话事件的获取
<a href="http://308812025-qq-com.iteye.com/blog/1549756">http://308812025-qq-com.iteye.com/blog/1549756</a>              IOS 5 拦截手机短信(需越狱)</p>

<p><a href="http://www.iteye.com/problems/84131">http://www.iteye.com/problems/84131</a>                                IOS 短信截取 监听到了事件缺不能往下执行。。。</p>

<!--more-->


<p><a href="http://blog.csdn.net/ceko_wu/article/details/8021133">http://blog.csdn.net/ceko_wu/article/details/8021133</a>     短信数据库分析（一）</p>

<p>一般地，ios只要越狱，整体的文件系统就全部暴漏出来，使用ifunbox 工具连接iphone，即可查看。</p>

<p>短信数据库的存放位置在ios的：    /private/var/mobile/Library/SMS/sms.db</p>

<p>联系人数据库存放的位置在ios的：//private/var/mobile/Library/AddressBook/AddressBook.sqlitedb</p>

<pre><code> 联系人的头像估计存放在这里：//private/var/mobile/Library/AddressBook/AddressBookImages.sqlitedb
</code></pre>

<p>通话记录数据库的存放路径是：//private/var/wireless/Library/CallHistory/call_history.db</p>

<p>备忘录数据库的存放路径是：//private/var/mobile/Library/Notes/notes.sqlite</p>

<p>safira 浏览器的收藏夹数据库存放路径是：//private/var/mobile/Library/Safari/Bookmarks.db</p>

<p>日历数据库的存放路径是：//private/var/mobile/Library/Calendar/Calendar.sqlitedb</p>

<p>上面的数据库，无论其后缀名是.db也好，.sqlitedb、.sqlite也好，它们的真实面目是，全部都是sqlite数据库。在实际查看这些数据库时，可以将其后缀名统一改成.sqlite，当然也可以不改。查看这些数据库最好的工具是 火狐浏览器上的插件：Sqlite Manager</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SpringBoard界面结构分析]]></title>
    <link href="http://al1020119.github.io/blog/2016/03/25/springboardjiemianjiegoufenxi/"/>
    <updated>2016-03-25T13:32:08+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/03/25/springboardjiemianjiegoufenxi</id>
    <content type="html"><![CDATA[<p>SpringBoard界面层级结构分析</p>

<p>cycript -p 进程ID</p>

<p>通过cycript注入到SpringBoard进程中
首先SpringBoard有点类似于一般app的结构，只不过它是由好几个window构成的，总共如下：
  锁屏状态下是SBAlertWindow
  正常状态下是SBAppWindow
  通知栏滑下来时显示SBBulletinWindow
主要分析下正常状态的window</p>

<!--more-->


<p>SpringBoard界面层级结构分析</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[分析QQ-微信界面结构]]></title>
    <link href="http://al1020119.github.io/blog/2016/03/22/fenxiQQweixinjiemianjiegou/"/>
    <updated>2016-03-22T13:32:08+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/03/22/fenxiQQweixinjiemianjiegou</id>
    <content type="html"><![CDATA[<p>使用Reveal分析其他APP（如微信、qq等）的界面结构</p>

<p>特别提醒，现已无需按下面的方式注入libReveal.dlib了，只需把libReveal.dylib上传到设备的/Library/MobileSubstrate/DynamicLibraries，然后同时编辑并上传一个libReveal.plist，格式如下：</p>

<p>nixiang0001</p>

<p> 设定BundleID
注意，此时是可以指定多个BundleID的，也就是说，你可以同时监控任意多的app；再扩大一步说，如果你愿意，不上传这个libReveal.plist，你可以监控所有app，只要你不觉得机器很慢。。。
一定确保手机和电脑端处在同一局域网中，不然看不到界面的
Reveal.app 目前能搞到2.0.3的版本且能用注册机破解，但貌似对ios7.0以上的应用无效，需要Reveal2.0.4版，但又无法破解目前，2.0.3版本百度云下载
<a href="http://c.blog.sina.com.cn/profile.php?blogid=cb8a22ea89000gtw&amp;qq-pf-to=pcqq.c2c">http://c.blog.sina.com.cn/profile.php?blogid=cb8a22ea89000gtw&amp;qq-pf-to=pcqq.c2c</a></p>

<!--more-->


<p>打开XCode创建iOSOpenDev&ndash;》Logos Tweak的工程</p>

<p>创建动态加载Reveal的类RevealUtil：</p>

<pre><code>//
//  RevealUtil.h
//  pyu
//
//  Created by whe on 6/23/13.
//
//

#import

@interface RevealUtil : NSObject {
    void *_revealLib;
}

- (void)startReveal;
- (void)stopReveal;

@end

//
//  RevealUtil.m
//  pyu
//
//  Created by whe on 6/23/13.
//
//
#import
#import
#import "RevealUtil.h"

@implementation RevealUtil

- (void)startReveal {
    NSString *revealLibName = @"libReveal.dylib";
    //NSString *revealLibExtension = @"dylib";
    NSString *bundlePath = [[NSBundle mainBundle] bundlePath];
   //此处要先将libReveal.dylib通过iTools上传到需要分析的App的Buldle主目录下（即xxx.app目录）
    NSString *dyLibPath = [NSString stringWithFormat:@"%@/%@",bundlePath,revealLibName];
    UIAlertView *alert = [[UIAlertView alloc]
                          initWithTitle:@"Welcome"  message:[NSString stringWithFormat:@"Loading dynamic library: %@", dyLibPath]
                          delegate:nil cancelButtonTitle:@"Thanks"
                          otherButtonTitles:nil];
    [alert show];
    [alert release];

    void *revealLib = NULL;
    revealLib = dlopen([dyLibPath cStringUsingEncoding:NSUTF8StringEncoding], RTLD_NOW);

    if (revealLib == NULL)
    {
        char *error = dlerror();
        NSLog(@"dlopen error: %s", error);
    }else {
        [[NSNotificationCenter defaultCenter] postNotificationName:@"IBARevealRequestStart" object:self];
    }
}

- (void)stopReveal {
    if (_revealLib)
    {
        [[NSNotificationCenter defaultCenter] postNotificationName:@"IBARevealRequestStop" object:self];
        if (dlclose(_revealLib) == 0)
        {
            NSLog(@"Reveal library unloaded");
            _revealLib = NULL;
        }
        else
        {
            char *error = dlerror();
            NSLog(@"Reveal library could not be unloaded: %s", error);
        }
    }
}

@end
</code></pre>

<p>修改工程的xm文件内容如下：</p>

<pre><code>#import "RevealUtil.h"
</code></pre>

<p>%hook MobileAssistAppDelegate //对应分析APP的AppDelegate文件类名，不同的App这个类名可能不同，这可以先通过class-dump  xxx.app这个二进制文件，得出该APP所有的头文件，然后搜索关键字didFinishLaunchingWithOptions，找到对应文件并查看该文件内的类名即是</p>

<pre><code>- (BOOL)application:(id)arg1 didFinishLaunchingWithOptions:(id)arg2 {
    %orig;

    RevealUtil *ru = [[RevealUtil alloc] init];
    [ru startReveal];

    return YES;
}

%end
</code></pre>

<p>最终项目结构如下：</p>

<p>nixiang0002</p>

<p>注意那个Filter，其实可以不填，但要填一定要是该app的bundle identifier</p>

<p>附：OpenSSH的使用：
       ssh <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#111;&#58;&#114;&#111;&#111;&#116;&#64;&#x31;&#57;&#x32;&#x2e;&#49;&#x36;&#56;&#46;&#x32;&#x2e;&#53;">&#x72;&#x6f;&#x6f;&#116;&#64;&#x31;&#x39;&#50;&#46;&#x31;&#54;&#56;&#x2e;&#50;&#46;&#x35;</a> 默认密码alpine
     先通过ssh登录到手机，然后可以通过cycript -p 进程ID   依附在需要分析的应用程序上  ps ax | grep PP</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[私有API]]></title>
    <link href="http://al1020119.github.io/blog/2016/03/20/siyouapi/"/>
    <updated>2016-03-20T13:32:08+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/03/20/siyouapi</id>
    <content type="html"><![CDATA[<p>一．基本知识</p>

<p>iPhone中的API除了公开的 API：Published API外（或者叫文档中记录的API：Documented API），还有两类API：私有API：Private API和未公开的API：UnPublished API(或者叫文档中未记录的API：Undocumented API)。其中私有API是指放在PrivateFrameworks框架中的API，未公开的API是指虽然放在Frameworks框架中，但是却没有在苹果的官方文档中有使用说明、代码介绍等记录的API。后两种API是有区别的，按苹果的说法，未公开的API是还不够成熟，可能还会变动的API，等完全成型了后会变成公开的API，但是目前不对其提供承诺，就是系统版本升级后可能会失效。而私有API是苹果明确不能使用的API。虽然两者有所区别，但是在具体使用方法上是类似的。</p>

<!--more-->


<p>二．具体介绍
1.导出生成私有API的头文件声明
使用私有或未公开的API，首先需要导出其对应的头文件，在头文件里有相关函数的声明。
工具：
class-dump
class-dump可以从编译后的Objective-C的二进制文件中提取对应的数据结构及函数等声明。
使用方法：
为了能在任意目录下使用class-dump命令，首先建议把class-dump文件拷贝到/user/local/bin/目录下，然后就可以在任意目录下执行以下命令：</p>

<p>class-dump /Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator3.0.sdk/System/Library/Frameworks/UIKit.framework/ >UIKit.h</p>

<p>以上命令就可以把 iPhoneSimulator3.0.Sdk中Frameworks框架里的UIKit.Framework框架的数据结构及函数声明等给提取出来，并且放在UIKit.h这个文件中，之后你就可以在这个头文件中找你需要API的声明及其使用方式。以同样的方法，就可以挨个导出你需要那个框架中的API 声明。</p>

<p>也可以用ericasadun写的DumpFrameworks.pl（文件中有部分注释说明）这个文件把私有框架下的API头文件全部提取出来。使用方法也是首先把class-dump文件拷贝到/user/local/bin/目录下，然后在任意一个目录下执行./DumpFrameworks.pl,然后就会在你的家目录下产生一个Headers文件夹，里面罗列了私有框架下的API头文件。</p>

<p>2.使用私有API</p>

<p>导出了私有API的头文件声明后，使用方法就比较简单了，首先在你的工程中包含进头文件，然后导入对应的框架，之后就可以类似提供了静态库的方式在我们的代码中使用这些私有API函数。</p>

<p>三．附加说明</p>

<p>iPhone编程中一些非常精致好玩的API都包含在私有API或未公开的API中，虽然我们可以以这种方式使用这些非常好的API，但是这样做是存在一定风险的，首先为公开的API有变更的可能，这样在每个固件版本中，你的代码都有可能中断。同时，最大的问题是使用了私有API的程序是不能放在App Store上销售的。因此如果我们只是为了好玩体验iPhone中这些精彩的API，那没关系。如果是为了做出程序放在App Store上销售的，那就不要动私有API的主意了。</p>

<hr />

<p>class-dump-x 提取私有库里面的隐藏文件
class-dump</p>

<p>This is a command-line utility for examining the Objective-C runtime information stored in Mach-O files. It generates declarations for the classes, categories and protocols. This is the same information provided by using &lsquo;otool -ov&rsquo;, but presented as normal Objective-C declarations, so it is much more compact and readable.
Why use class-dump?</p>

<p>It&rsquo;s a great tool for the curious. You can look at the design of closed source applications, frameworks, and bundles. Watch the interfaces evolve between releases. Experiment with private frameworks, or see what private goodies are hiding in the AppKit. Learn about the plugin API lurking in Mail.app.</p>

<p>If you find class-dump useful, you can donate to help support its development. Thanks!
Download</p>

<p>Current version: 3.3.3 (Universal, 64 and 32 bit)
Requires Mac OS X 10.5 or later.</p>

<pre><code>class-dump-3.3.3.dmg
class-dump-3.3.3.tar.gz
class-dump-3.3.3.tar.bz2
</code></pre>

<p>Changes - News
Contact</p>

<p>You can email questions and bug reports to me at class-dump@codethecode.com, or nygard at gmail.com.
Usage</p>

<p>class-dump 3.3.3 (64 bit)
Usage: class-dump [options] <mach-o-file></p>

<p>  where options are:
        -a             show instance variable offsets
        -A             show implementation addresses
        &ndash;arch <arch>  choose a specific architecture from a universal binary (ppc, ppc7400, ppc64, i386, x86_64, etc.)
        -C <regex>     only display classes matching regular expression
        -f <str>       find string in method name
        -H             generate header files in current directory, or directory specified with -o
        -I             sort classes, categories, and protocols by inheritance (overrides -s)
        -o <dir>       output directory used for -H
        -r             recursively expand frameworks and fixed VM shared libraries
        -s             sort classes and categories by name
        -S             sort methods by name
        -t             suppress header in output, for testing
        &ndash;list-arches  list the arches in the file, then exit
        &ndash;sdk-root     specify the SDK root path (full path, or 4.1, 4.0, 3.2, 10.6, 10.5, 3.1.3, 3.1.2, 3.1)</p>

<p>License</p>

<p>This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.</p>

<p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.</p>

<p>You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</p>

<p> class-dump -H  /Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator2.1.sdk/System/Library/CoreServices/SpringBoard.app/SpringBoard</p>

<pre><code> -o 
</code></pre>

<p>~/Desktop/SpringBoard</p>

<p>下载：<a href="http://ericasadun.com/HeaderDumpKit/">http://ericasadun.com/HeaderDumpKit/</a></p>

<p>使用：
1 将下载好的 class-dump 放入usr/local/bin 下.
   如果 ‘/usr/local/bin’ 不知道在哪里，可以在terminal 下输入 ‘open -a Finder /usr/local/bin’ 以便打开目录.
   记着 class-dump 要 使用 chmod 修改下执行权限.   例如：在usr/local/bin 对 class-dump 修改，可以这    样在terminal 切换到 usr/local/bin 目录下: chmod 777 class-dump .
2 将DumpFrameworks.pl 放入任意目录下.同样需要修改执行权限.</p>

<ol>
<li>OK..现在所有的准备工作作好了. 我们在 terminal 的任意目录下 输入 ： ./DumpFrameworks.pl
等待&hellip;
会有一个Heards 文件夹在你的主目录下. 里面包含了 Frmeworks 和 privateFrameworks 下所有的私有        API,尽情享用吧.!</li>
</ol>


<hr />

<p> 作为 Objective-C / Cocoa Touch 开发者，在经历了呕心沥血十月怀胎终于孕育出了一个代码包，然后踌躇满志准备提交给天杀的 Apple App Review Team  审核之时，别急，我们仍然需要诚惶诚恐的考虑一个问题，我们的代码里是否用到了 Private API ？</p>

<pre><code>什么是 Private API ？简而言之，就是这个 API 真实存在于 Cocoa Touch 中，但它又不是 Public API （有点绕吧…）。那什么是 Public API 呢？Public API 就是苹果通过 Cocoa Touch 向全世界第三方开发者公开的所有 API 。在哪可以查到 Public API ？在你的 Xcode 工程中就能查到。如这幅截图所示， Xcode 中所有 framework 的头文件都是我们可用肉眼查询的 Public API 列表。



同此同时，民间也流传着一个非官方的 Private API 列表。(iphone-private-frameworks)

于是你说，那问题不就解决了呗，只要我们洁身自好，保证自己的代码里只使用 Cocoa Touch 公布的 API ，我们就肯定不会惹上 Private API 啦。

然而实际情况往往不是这样，当今世界，嗯嗯当今世界，App Store 的竞争越发激烈，每位开发者都希望自己的代码能站在前辈优秀开源代码的基础上高屋建瓴，而不是每新建一个工程就得自己花十天半个月一遍遍 reinvent the wheel 重造车轮。 随手举几个例子， ASIHTTPRequest 、JSON 、Facebook / Three20 、 SFHFKeychainUtils ，这几套知名开源代码包存在于许许多多优秀的 iOS 应用之中。其他名气稍小但是同样流传广泛的开源或者闭源代码包就更数不胜数了。作为开发者，我们不得不频繁面对这样一个问题，我们如何确保这些第三方的代 码报里，不存在 private API ？

苹果提供了几种机器识别方法，比如 string 命令，比如 otool -ov 命令，但都不太好用。江湖上有人做了一套解决方案，名叫 AppScanner ，我老人家决定强烈推荐一下。( 貌似现在用xcode提交项目时会检测一遍是否有私有函数 )

怎么用？很简单，你把AppScanner工程编译好，然后直接将 .app 文件夹整个拖进 AppScanner 窗口里。
免费的么？几乎是免费的，虽然收费（也才 $2.99 ），但是头 14 天免费。
是否有人维护？有，而且只要你愿意出 $2.99 支持他们维护。他们还会继续开发下去。

这是一个实例的截屏，头两项 API 可疑度 100% ，说明它们就是来搞破坏的 Private API。



最后插一则八卦， Facebook / Three20 如雷贯耳，想必很多开发者都使用过。然而要命的事，在 Three20 的第一个版本中，就悄悄的藏着一条因为重名导致的假阳性 Private API 。虽然是假阳性，但那次事故仍然导致了所有使用那个版本 Three20 的 app 被惨拒。当然了，后来他们很快就修正了这个问题。
</code></pre>

<p>使用私有api开启了iphone的蓝牙。现在把方法分享出来，希望能给大家提供一些思路。</p>

<p>1.首先在/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS4.3.sdk/System/Library/PrivateFrameworks路径下找到BluetoothManager.framework（如果我没估计错的话，里面只有一个库文件，没有头文件）
2. 所需的头文件，手动添加到BluetoothManager.framework中，并建立一个Headers文件夹。
3.建立一个工程将以上路径下的BluetoothManager.framework添加到工程中
4.将以下代码添加到工程中。（注意：不需要引入BluetoothManager的头文件，否则会出现编译错误）</p>

<p>-(void)startBluetooth{</p>

<h1>if TARGET_IPHONE_SIMULATOR</h1>

<pre><code>exit( EXIT_SUCCESS ) ;
</code></pre>

<h1>else</h1>

<pre><code>/* this works in iOS 4.2.3 */
Class BluetoothManager = objc_getClass( "BluetoothManager" ) ;
id btCont = [BluetoothManager sharedInstance] ;
[self performSelector:@selector(toggle:) withObject:btCont afterDelay:1.0f] ;
</code></pre>

<h1>endif</h1>

<p>}</p>

<h1>if TARGET_IPHONE_SIMULATOR</h1>

<h1>else</h1>

<ul>
<li>(void)toggle:(id)btCont
{
  BOOL currentState = [btCont enabled] ;
  [btCont setEnabled:!currentState] ;
  [btCont setPowered:!currentState] ;</li>
</ul>


<p>}</p>

<h1>endif</h1>

<p>5.在真机上编译运行，会发现iphone的蓝牙成功开启。</p>

<p>但是，遗憾的是，目前我研究出来的只有开启蓝牙，关于设备匹配，数据传输方面没什么进展。
希望有人能再接再厉，在我的基础上研究出设备匹配和数据传输的方法</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Tweak工程]]></title>
    <link href="http://al1020119.github.io/blog/2016/03/19/shiyongtweakgongcheng/"/>
    <updated>2016-03-19T13:32:08+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/03/19/shiyongtweakgongcheng</id>
    <content type="html"><![CDATA[<p>iOS逆向 - 使用Tweak工程</p>

<p>创建第一个Tweak工程
1、创建工程</p>

<p>在目录下面启动NIC /opt/theos/bin/nic.pl ,可以看到有好多个模板可以选择。 1、4、6、8、9 是Theos自带的模板,其他的是 <a href="https://github.com/DHowett/theos-nic-templates">https://github.com/DHowett/theos-nic-templates</a> 下载的。 这里主要学习tweak的用法，选择9</p>

<pre><code>  NIC 2.0 - New Instance Creator
------------------------------
  [1.] iphone/application
  [2.] iphone/cydget
  [3.] iphone/framework
  [4.] iphone/library
  [5.] iphone/notification_center_widget
  [6.] iphone/preference_bundle
  [7.] iphone/sbsettingstoggle
  [8.] iphone/tool
  [9.] iphone/tweak
  [10.] iphone/xpc_service
Choose a Template (required):
</code></pre>

<!--more-->


<p>输入工程的名字</p>

<pre><code>Project Name (required): reverseDemo
</code></pre>

<p>输入deb包的名字，相当于App的bundle id</p>

<pre><code>Package Name [com.yourcompany.reversedemo]: com.liuchendi.iOSReverse
</code></pre>

<p>输入tweak作者的名字</p>

<pre><code>Author/Maintainer Name [lovelydd]: liuchendi
</code></pre>

<p>输入MobileSubstrate Bundle filter，就是设置tweak作用对象的bundle identifier。就像上一节用Reveal查看别人的App一样，需要知道作用的对象是谁</p>

<pre><code>[iphone/tweak] MobileSubstrate Bundle filter [com.apple.springboard]: com.apple.springboard
</code></pre>

<p>安装完成后需要重启的应用，已进程名表示</p>

<pre><code>[iphone/tweak] List of applications to terminate upon installation (space-separated, '-' for none) [SpringBoard]: SpringBoard
</code></pre>

<p>一个Tweak工程就创建完成了
2、定制工程文件</p>

<p>查看工程里面的文件目录</p>

<pre><code>liuchendi@lovelyddtekiMBP reversedemo$ ls -l
total 40
-rw-r--r--  1 liuchendi  staff   182 12 17 17:30 Makefile
-rw-r--r--  1 liuchendi  staff  1045 12 17 17:30 Tweak.xm
-rw-r--r--  1 liuchendi  staff   222 12 17 17:30 control
-rw-r--r--  1 liuchendi  staff    57 12 17 17:30 reverseDemo.plist
lrwxr-xr-x  1 liuchendi  staff    10 12 17 17:30 theos -&gt; /opt/theos
</code></pre>

<p>Makefile：指定工程用到的文件、框架、库等信息，整个过程自动化。</p>

<p>// 固定写法
    include theos/makefiles/common.mk</p>

<pre><code>// tweak名字,就是工程的名字
TWEAK_NAME = reverseDemo

//tweak包含的源文件(不包括头文件),多个文件以空格分隔
reverseDemo_FILES = Tweak.xm

// 根据Theos工程的不同类型，指定不同的.mk文件。
// 逆向初级阶段一般是Application、 Tweak 、Tool三种类型的程序
// 分别对应的.mk文件是 application.mk 、tweak.mk 、tool.mk
include $(THEOS_MAKE_PATH)/tweak.mk

// 安装完成后,杀掉SpringBoard进程,好让CydiaSubstrate在进程启动时加载对应的dylib
after-install::
  install.exec "killall -9 SpringBoard"
</code></pre>

<p>其他功能：</p>

<pre><code>// 指定处理器架构，arm64架构不兼容armv7/armv7s架构,必须适配arm64的dylib
ARCHS = armv7 arm64

//指定SDK版本
TARGET = iphone:8.1:8.0     // 8.1是指定采用的SDK版本，8.0是可以部署安装的版本
TARGET = iphone:latest:8.0 // Xcode附带的最新版本SDK

//导入framework
reverseDemo_FRAMEWORKS = UIKit CoreTelephony

//导入私有framework
reverseDemo_PRIVATE_FRAMEWORK = AppSupport ChatKit

//链接Mach-O对象(Mach-O object)
// -lx 代表链接libx.a 或者libx.dylib
reverseDemo_LDFLAGS = -lx
</code></pre>

<p>Tweak.xm</p>

<p>默认生成的源文件，x表示支持Logos语法。</p>

<pre><code>/* How to Hook with Logos
Hooks are written with syntax similar to that of an Objective-C @implementation.
You don't need to #include &lt;substrate.h&gt;, it will be done automatically, as will
the generation of a class list and an automatic constructor.

%hook ClassName

// Hooking a class method
+ (id)sharedInstance {
  return %orig;
}

// Hooking an instance method with an argument.
- (void)messageName:(int)argument {
  %log; // Write a message about this call, including its class, name and arguments, to the system log.

  %orig; // Call through to the original function with its original arguments.
  %orig(nil); // Call through to the original function with a custom argument.

  // If you use %orig(), you MUST supply all arguments (except for self and _cmd, the automatically generated ones.)
}

// Hooking an instance method with no arguments.
- (id)noArguments {
  %log;
  id awesome = %orig;
  [awesome doSomethingElse];

  return awesome;
}

// Always make sure you clean up after yourself; Not doing so could have grave consequences!
%end
*/
</code></pre>

<p>主要包括几个命令:</p>

<pre><code>%hook : 指定需要hook的class，必须以%end结尾

%log : 在 %hook 函数内部使用，将函数的类名、参数等信息输出，还能够在结尾输出自定义格式信息

%orig : 执行被hook住的源代码，更改原始函数的参数

%group :将 %hook 分组，以%end结尾。便于代码管理及按条件初始化，不属于自定义的group都会隐式归类到%group_ungrouped中。 必须配合下面的 %init 命令才能生效

%init : 初始化某个group，必须在 hook 或 %ctor 内调用。如果带参数，则初始化指定的group。不带参数则初始化_ungrouped。 只有调用了 %init ，group才能生效

%ctor : 一个构造器，完成初始化工作。如果不显示定义，Theos自动生成一个 %ctor 。并在其中调用%init(_ungrouped), %ctor 不需要%end结尾

%new : 给一个现有的class添加新函数,功能与class_addMethod相同

%c : 等同于 objc_getClass 或者 NSClassFromString , 动态获取一个类的定义,在 %hook 或 %ctor 内使用

control
</code></pre>

<p>control记录了deb包管理系统所需的基本信息, 会被打包进deb里。其内容如下:</p>

<pre><code>Package: com.liuchendi.iOSReverse
Name: reverseDemo
Depends: mobilesubstrate    //依赖条件
Version: 0.0.1
Architecture: iphoneos-arm
Description: An awesome MobileSubstrate tweak!
Maintainer: liuchendi   //deb包的维护人
Author: liuchendi       //tweak作者
Section: Tweaks         //所属程序类别
</code></pre>

<p>更全面的介绍在 这里</p>

<pre><code>reverseDemo.plist
</code></pre>

<p>记录一些配置信息，描述tweak的作用范围。其实就是一个字典， Filter 为外键，里面包含有 :</p>

<pre><code>Bundles : tweak作用对象, 也是app的bundle id
Class : tweak作用的若干类
Executables : 指定若干可执行文件
</code></pre>

<p>注意: 当Filter下有不同的类array时候，需要添加Mode: Any键值对
3、编译 + 打包 + 安装
编译:make</p>

<p>执行make,可能出现的错误</p>

<pre><code>Please run `/Users/liuchendi/Desktop/逆向/Demo/reversedemo/theos/bin/bootstrap.sh substrate` manually, with privileges.
make: *** [before-all] Error 1
</code></pre>

<p>将iOS上的 /Library/Frameworks/CydiaSubstrate.framework/ CydiaSubstrate 拷贝到OSX中，将其重命名为libsubstrate.dylib后放到“/opt/theos/lib/libsubstrate. dylib”中</p>

<pre><code>/bin/sh: ldid: command not found
</code></pre>

<p>重新去 <a href="http://joedj.net/ldid">http://joedj.net/ldid</a> 下载ldid，放在/opt/theos/bin/下面,然后赋予可执行权限 sudo chmod 777</p>

<p>成功后的显示,完成了预处理，编译，签名等一系列工作</p>

<pre><code>Making all for tweak reverseDemo...
Preprocessing Tweak.xm...
Compiling Tweak.xm...
Linking tweak reverseDemo...
Stripping reverseDemo...
Signing reverseDemo...
</code></pre>

<p>发现多了一个obj文件夹</p>

<pre><code>liuchendi@lovelyddtekiMBP reversedemo$ ls -al
total 40
drwxr-xr-x  9 liuchendi  staff   306 12 17 23:20 .
drwxr-xr-x  4 liuchendi  staff   136 12 17 17:31 ..
drwxr-xr-x  4 liuchendi  staff   136 12 17 23:15 .theos
-rw-r--r--  1 liuchendi  staff   182 12 17 17:30 Makefile
-rw-r--r--  1 liuchendi  staff  1045 12 17 17:30 Tweak.xm
-rw-r--r--  1 liuchendi  staff   222 12 17 17:30 control
drwxr-xr-x  5 liuchendi  staff   170 12 17 23:20 obj
-rw-r--r--  1 liuchendi  staff    57 12 17 17:30 reverseDemo.plist
lrwxr-xr-x  1 liuchendi  staff    10 12 17 17:30 theos -&gt; /opt/theos
</code></pre>

<p>打包 make package</p>

<p>出现的错误</p>

<pre><code>make[2]: Nothing to be done for `internal-library-compile'.
Making stage for tweak reverseDemo...
make: *** [internal-package] Error 255
</code></pre>

<p>下载dm.pl文件 <a href="https://raw.githubusercontent.com/DHowett/dm.pl/master/dm.pl">https://raw.githubusercontent.com/DHowett/dm.pl/master/dm.pl</a> ,然后重命名为dpkg-deb.pl,放到/opt/theos/bin/目录下面。 我把pl后缀名字隐藏了</p>

<p>成功执行后的显示,生成一个*.deb的包</p>

<pre><code>liuchendi@lovelyddtekiMBP reversedemo$ make package
Making all for tweak reverseDemo...
Preprocessing Tweak.xm...
Compiling Tweak.xm...
Linking tweak reverseDemo...
Stripping reverseDemo...
Signing reverseDemo...
Making stage for tweak reverseDemo...
dpkg-deb：正在新建软件包“com.liuchendi.iosreverse”，包文件为“./com.liuchendi.iOSReverse_0.0.1-5_iphoneos-arm.deb”。
</code></pre>

<p>多了一个， _ 目录,里面有 DEBIAN 和 Library 文件夹</p>

<pre><code>liuchendi@lovelyddtekiMBP reversedemo$ ls
Makefile
Tweak.xm
_
com.liuchendi.iOSReverse_0.0.1-5_iphoneos-arm.deb
control
obj
reverseDemo.plist
theos
liuchendi@lovelyddtekiMBP reversedemo$ ls _
DEBIAN  Library
</code></pre>

<p><img src="http://al1020119.github.io/images/nixiangtweak001.png" title="Caption" ></p>

<p>用 dpkg -c 查看生成的内容</p>

<pre><code>liuchendi@lovelyddtekiMBP reversedemo$ dpkg -c com.liuchendi.iOSReverse_0.0.1-5_iphoneos-arm.deb
drwxr-xr-x liuchendi/staff   0 2015-12-17 23:48 ./
drwxr-xr-x liuchendi/staff   0 2015-12-17 23:48 ./Library/
drwxr-xr-x liuchendi/staff   0 2015-12-17 23:48 ./Library/MobileSubstrate/
drwxr-xr-x liuchendi/staff   0 2015-12-17 23:48 ./Library/MobileSubstrate/DynamicLibraries/
-rwxr-xr-x liuchendi/staff 49952 2015-12-17 23:48 ./Library/MobileSubstrate/DynamicLibraries/reverseDemo.dylib
-rw-r--r-- liuchendi/staff    57 2015-12-17 23:48 ./Library/MobileSubstrate/DynamicLibraries/reverseDemo.plist
</code></pre>

<p>可以看到内容都是一样的
安装</p>

<pre><code>make package install
</code></pre>

<p>首先在Makefile添加下面的内容,主要是指定安装的手机ip</p>

<pre><code>ARCHS = armv7 arm64
TARGET = iphone:latest:7.0
THEOS_DEVICE_IP = 192.168.1.100
</code></pre>

<p>安装成功后的显示,期间要输入两次密码</p>

<pre><code>liuchendi@lovelyddtekiMBP reversedemo$ make package install
Making all for tweak reverseDemo...
make[2]: Nothing to be done for `internal-library-compile'.
Making stage for tweak reverseDemo...
dpkg-deb：正在新建软件包“com.liuchendi.iosreverse”，包文件为“./com.liuchendi.iOSReverse_0.0.1-7_iphoneos-arm.deb”。
install.exec "cat &gt; /tmp/_theos_install.deb; dpkg -i /tmp/_theos_install.deb &amp;&amp; rm /tmp/_theos_install.deb" &lt; "./com.liuchendi.iOSReverse_0.0.1-7_iphoneos-arm.deb"
root@192.168.1.100's password: 
Selecting previously deselected package com.liuchendi.iosreverse.
(Reading database ... 2389 files and directories currently installed.)
Unpacking com.liuchendi.iosreverse (from /tmp/_theos_install.deb) ...
Setting up com.liuchendi.iosreverse (0.0.1-7) ...
install.exec "killall -9 SpringBoard"
root@192.168.1.100's password:
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[修改图标数字]]></title>
    <link href="http://al1020119.github.io/blog/2016/03/18/xiugaitubiaozhishishuzi/"/>
    <updated>2016-03-18T13:32:08+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/03/18/xiugaitubiaozhishishuzi</id>
    <content type="html"><![CDATA[<p>修改程序图标标示数字</p>

<p>1.修改自身应用图标标示数字：
   [UIApplication sharedApplication].applicationIconBadgeNumber = 10;
2. 修改其他应用图标标示数字：
   ios7.0下的sdk
   Use class-dump to dump the headers for /Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS3.0.sdk/System/Library/PrivateFrameworks/iTunesStore.framework/iTunesStore</p>

<p>涉及的头文件</p>

<pre><code>ISOperation-ISAuthentication.h
ISOperation-ISLoadSoftwareMapAdditions.h
ISOperation-ISLoadURLBagAdditions.h
ISOperation.h
ISOperationDelegate-Protocol.h
ISOperationQueue.h
ISSetApplicationBadgeOperation.h

You may have to edit ISOperation.h:
</code></pre>

<!--more-->


<ol>
<li>Change the #import &ldquo;NSOperation.h&rdquo; to #import</li>
<li>Remove the &ldquo;&rdquo; in the first part of the interface.</li>
<li>So you&rsquo;re just left with &ldquo;id _delegate;&rdquo;</li>
</ol>


<p>Then copy these 3 files into a &ldquo;Headers&rdquo; dir inside of the /Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS3.0.sdk/System/Library/PrivateFrameworks/iTunesStore.framework dir.</p>

<p>You can now add the iTunesStore framework to your xcode project. Just point to the dir above.</p>

<p>Now add &ldquo;#import &rdquo; to your code and, for your convenience, here&rsquo;s an example-function ready for use:</p>

<p>CODE：</p>

<pre><code>ISSetApplicationBadgeOperation *sbadge = [[ISSetApplicationBadgeOperation alloc] init];


[sbadge setBundleIdentifier:bundleIdentifier];
[sbadge setBadgeValue:[NSString stringWithFormat:@"%d",number]];
[sbadge run];
[sbadge release];
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Jiandanappshizhan]]></title>
    <link href="http://al1020119.github.io/blog/2016/03/14/jiandanappshizhan/"/>
    <updated>2016-03-14T00:00:00+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/03/14/jiandanappshizhan</id>
    <content type="html"><![CDATA[<hr />

<p>layout: post
title: &ldquo;简单App实战&rdquo;
date: 2016-03-14 13:32:08 +0800
comments: true</p>

<h2>categories: Summary</h2>

<p>底层开发之越狱开发第一篇</p>

<p>做越狱开发也有一些时间了，有很多东西想总结一下，希望给他人一些借鉴，也是自己对过去开发经历的一些总结。个人不推荐使用盗版，这里主要以技术介绍为主。</p>

<p>这个系列里面主要介绍怎样进行越狱开发，涉及到以下几个方面:</p>

<ul>
<li>(1)主要涉及到越狱市场的建立，在App内部实现ipa的安装和卸载以及更新。参照的对象就是91助手，25pp，同步推那样的应用。建立一个盗版的App Store.当然了，如果通过299刀的企业证书的话，是不需要通过Cydia的，直接通过网页链接就可以实现app的推广，有一定的风险。这里面涉及到一些协议，后面会进行介绍。</li>
<li>(2)在App内部实现壁纸和铃声的替换。这个过程涉及到的东西很多，特别是铃声的替换，iPhone里面非常麻烦；</li>
<li>(3)一些越狱插件的开发，通过里面有些插件非常好用，合理，而且非常美观漂亮。
这里先从App内部安装ipa包开始讲，后面逐步把上面提到的3点全部讲完。</li>
</ul>


<!--more-->


<p>一般情况下安装91助手，同步推这样的应用需要手机越狱，同时安装AppSync，这样才能使用，所以进行开发的必备条件也是如此。</p>

<p>上传的demo工程的地址，我的github链接：<a href="https://github.com/easonoutlook/IPAInstaller">https://github.com/easonoutlook/IPAInstaller</a></p>

<p>之前一直在fork别人的东西，也没做什么贡献，从现在开始，为开发为开源，做一点自己的贡献。</p>

<p>进入正题：</p>

<p>需要的工具和环境：</p>

<ul>
<li><ol type="a">
<li>iPhone or iPad越狱，安装AppSync</li>
</ol>
</li>
<li><ol type="a">
<li>Xcode安装 Command Line Tools</li>
</ol>
</li>
<li><ol type="a">
<li>下载最新版本的ldid <a href="https://github.com/downloads/rpetrich/ldid/ldid.zip">https://github.com/downloads/rpetrich/ldid/ldid.zip</a></li>
</ol>
</li>
</ul>


<h4>1、修改SDKSettings.plist文件</h4>

<p>我用的是Xcode4.6.3版本，iPhone的版本是6.1.2, 路径为：/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS6.1.sdk/</p>

<p>将这个目录下的 SDKSettings.plist里面的CODE_SIGNING_REQUIRED置为NO</p>

<p>执行命令为：</p>

<p>转到目录下</p>

<pre><code>cd /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS6.1.sdk
</code></pre>

<p>将原有文件备份</p>

<pre><code>sudo cp SDKSettings.plist SDKSettings.plist.orig
</code></pre>

<p>对SDKSettings.plist文件进行编辑</p>

<pre><code>sudo vim SDKSettings.plist
</code></pre>

<p>将下面对应的字段改为NO</p>

<pre><code>&lt;key&gt;CODE_SIGNING_REQUIRED&lt;/key&gt;
&lt;string&gt;YES&lt;/string&gt;  // 默认为YES, 需要改为NO
</code></pre>

<p>此操作参考的路径如下：<a href="http://kqwd.blog.163.com/blog/static/4122344820117191351263/">http://kqwd.blog.163.com/blog/static/4122344820117191351263/</a></p>

<h4>2、给工程添加相应的权限，iOS6里面需要赋予权限才可以，iOS5之前不需要此操作</h4>

<p>新建一个plist文件，命名为entitlements.</p>

<p><img src="http://al1020119.github.io/images/nixiang005.png" title="Caption" ></p>

<p>创建一个plist</p>

<p><img src="http://al1020119.github.io/images/nixiang006.png" title="Caption" ></p>

<p>将plist文件改为：</p>

<p>复制代码
复制代码</p>

<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;
&lt;plist version="1.0"&gt;
    &lt;dict&gt;
        &lt;key&gt;com.apple.private.mobileinstall.allowedSPI&lt;/key&gt;
        &lt;array&gt;
            &lt;string&gt;Install&lt;/string&gt;
            &lt;string&gt;Browse&lt;/string&gt;
            &lt;string&gt;Uninstall&lt;/string&gt;
            &lt;string&gt;Archive&lt;/string&gt;
            &lt;string&gt;RemoveArchive&lt;/string&gt;
        &lt;/array&gt;
    &lt;/dict&gt;
&lt;/plist&gt;
</code></pre>

<p>复制代码
复制代码
将Code Signing 的Code Signing Entilements设置为刚刚创建的entitlements.plist文件</p>

<p><img src="http://al1020119.github.io/images/nixiang007.png" title="Caption" ></p>

<p>后面还需要一个手续，将生产的app文件用ldid签名。后面再介绍。</p>

<p>3、实现越狱安装的代码：</p>

<p>复制代码
复制代码</p>

<pre><code>typedef NSDictionary *(*    PMobileInstallationLookup)(NSDictionary *params, id callback_unknown_usage);
NSDictionary *IPAInstalledApps()
{
    void *lib = dlopen("/System/Library/PrivateFrameworks/MobileInstallation.framework/MobileInstallation", RTLD_LAZY);
    if (lib)
    {
        PMobileInstallationLookup pMobileInstallationLookup = (PMobileInstallationLookup)dlsym(lib, "MobileInstallationLookup");
        if (pMobileInstallationLookup)
        {
            NSArray *wanted = nil;//[NSArray arrayWithObjects:@"com.celeware.IPADeploy",@"com.celeware.celedial",nil]; Lookup specified only
            NSDictionary *params = [NSDictionary dictionaryWithObjectsAndKeys:@"User", @"ApplicationType", wanted, @"BundleIDs",nil];
            NSDictionary *dict = pMobileInstallationLookup(params, NULL);
#ifdef DEBUG
            NSLog(@"%@", dict);
#endif
            return dict;
        }
    }
    return nil;
}
</code></pre>

<p>复制代码
复制代码
所有代码均在之前的github目录中，可以自行查看。</p>

<p>4、编译生成App文件</p>

<p>因为需要给APP签名加权限，所以不要生成IPA文件，而是生成APP文件。等把签名与权限加好后，再手动用APP制作IPA文件。</p>

<p> 在Xcode中选择设备（IOS Device）（图3），编译（Build）（图4）。编译完成后，在工程的Products文件夹中可以看到刚刚编译好的APP文件，右键Show in Finder（图5），就可以在文件夹中显示。将APP复制到一个别的文件夹中，什么地方都可以，后面需要用到。</p>

<p><img src="http://al1020119.github.io/images/nixiang008.png" title="Caption" ></p>

<p>5、制作ipa文件</p>

<p>将之前提到的ldid下载好后，将ldid文件放到/usr/bin中。</p>

<p>比如在 Download 目录下， sudo -i</p>

<p>然后 cp ldid /usr/bin/即可将文件拷贝到/usr/bin中。</p>

<p>然后对之前生成的文件，进行ldid签名</p>

<p><img src="http://al1020119.github.io/images/nixiang009.png" title="Caption" ></p>

<p>这个命令中“ldid -S” ，“ldid”与“-S”之间有一个空格。“-S”与“entitlements.xml”之间没有空格。“entitlements.xml”就是上面说到的XML文件，如果你的XML不是这个名，请将命令修改为你的XML文件名即可。</p>

<p>“-Sentitlements.xm”与“ipainstall.app”之间有一个空格。“ipainstall”是刚刚生成的APP文件，如果你的名字不一样，请修改为你的名字。“/“后面和APP的名字是一样的。  如果没有输出错误信息或是卡住（就是敲回车后没反应）就是添加权限成功了。</p>

<p>6、生成ipa文件，安装</p>

<p>新建一个文件夹，命名为“Payload”。将刚刚添加好权限的APP文件放到这个文件夹中。右键“压缩Payload”，得到一个“.zip”文件，将这个ZIP文件的后缀名改为“.ipa”。好了，IPA文件就制作完成了。</p>

<p>然后通过itools安装，测试刚刚生成的文件</p>

<p><img src="http://al1020119.github.io/images/nixiang010.png" title="Caption" ></p>

<p>整合了很多资源，有些地方弄的比较凌乱，后面加以完善</p>

<p>参考资源链接：</p>

<p><a href="http://since2006.com/blog/240/ios6-mobileinstallationinstall">http://since2006.com/blog/240/ios6-mobileinstallationinstall</a>
<a href="http://blog.sina.com.cn/s/blog_9cd1705d0101l4bo.html">http://blog.sina.com.cn/s/blog_9cd1705d0101l4bo.html</a>
<a href="http://kqwd.blog.163.com/blog/static/4122344820117191351263/">http://kqwd.blog.163.com/blog/static/4122344820117191351263/</a>
<a href="http://blog.csdn.net/linkai5696/article/details/5924356">http://blog.csdn.net/linkai5696/article/details/5924356</a>
<a href="http://www.yonsm.net/post/553">http://www.yonsm.net/post/553</a>
<a href="http://stackoverflow.com/questions/14871748/how-do-i-change-my-applications-entitlements-to-com-apple-backboard-client">http://stackoverflow.com/questions/14871748/how-do-i-change-my-applications-entitlements-to-com-apple-backboard-client</a>
<a href="http://stackoverflow.com/questions/13817569/how-to-programatically-install-a-ipa-file-in-ios-6/15062538#15062538">http://stackoverflow.com/questions/13817569/how-to-programatically-install-a-ipa-file-in-ios-6/15062538#15062538</a>
<a href="http://since2006.com/blog/240/ios6-mobileinstallationinstall">http://since2006.com/blog/240/ios6-mobileinstallationinstall</a>
<a href="http://hi.baidu.com/prognostic/item/831b622202b2dd0f72863e9c">http://hi.baidu.com/prognostic/item/831b622202b2dd0f72863e9c</a>
<a href="http://www.vsyo.com/a/t/89895554d4043c5a">http://www.vsyo.com/a/t/89895554d4043c5a</a>
<a href="http://mobile.dotblogs.com.tw/cmd4shell/archive/2013/03/26/98967.aspx">http://mobile.dotblogs.com.tw/cmd4shell/archive/2013/03/26/98967.aspx</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[资源文件夹获取]]></title>
    <link href="http://al1020119.github.io/blog/2016/03/12/ziyuanwenjianhuoqu/"/>
    <updated>2016-03-12T13:32:08+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/03/12/ziyuanwenjianhuoqu</id>
    <content type="html"><![CDATA[<p>用pngcrush反编译ios app 资源文件</p>

<p>时间：2012-12-27 11:56:45 类别：ios开发 访问: 3705 次</p>

<p>要提高app制作水平，最好的方法就是学习领先者，用pngcrush反编译ios app 资源文件，步骤很简单</p>

<!--more-->


<ol>
<li><p>在电脑的itunes中下载你选中的app，下载完成之后，然后在finder里面找到对应的ipa包，也可以在91等市场中直接下载ipa文件</p></li>
<li><p>ipa文件其实是zip包，重命名为zip后缀文件之后，双击打开
找到 xxx.app 文件，这其实是个目录，点击右键，在菜单中选中“查看包内容”，就可以进入目录，然后看到大量的资源文件，这些png文件都直接放在app的根目录，你可以在finder中直接浏览</p></li>
<li><p>但是这些png文件都是打包过程中被压缩过的，photoshop无法正确识别 （ 注：打包app的时候，你可以在xcode project选项中选择对png文件不压缩）</p></li>
<li><p>要把这些png文件还原，可以通过一个名叫 pngcrush 的开源软件，你可以到 sourceforge 下载，实际上ios的sdk也提供了这个程序（xcode就是利用它压缩png的）xcrun -sdk iphoneos -find pngcrush 可以获得 pngcrush的安装目录，然后直接使用，或者在你的$PATH目录里面做一个符号链接，这样可以在console窗口直接敲pngcrush</p></li>
</ol>


<p>进入资源文件存放目录，打开对应的命令行窗口，执行下面的命令即可</p>

<pre><code>pngcrush -d xxx reverted -revert-iphone-optimizations -q *.png
pngcrush -e xxx reverted -revert-iphone-optimizations -q *.png
</code></pre>

<p>上面提到的方法都是在mac操作系统下面，如果是windows/linux也可以用，pngcrush也提供了对应的版本</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Jingtaifenxiyushiyong]]></title>
    <link href="http://al1020119.github.io/blog/2016/03/10/jingtaifenxiyushiyong/"/>
    <updated>2016-03-10T00:00:00+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/03/10/jingtaifenxiyushiyong</id>
    <content type="html"><![CDATA[<hr />

<p>layout: post
title: &ldquo;静态分析与使用&rdquo;
date: 2016-03-10 13:32:08 +0800
comments: true</p>

<h2>categories: Summary</h2>

<p>逆向工程－静态分析及使用</p>

<p>看到一篇装逼技术，有机会好好研究一下。。。。。</p>

<p>最近在学习IOS逆向工程，查看网络上的资料也不是太多，边学边总结一下。</p>

<p>首先学习资料：</p>

<p>念茜（大神）的博客： <a href="http://nianxi.net">http://nianxi.net</a></p>

<p>《ios应用逆向工程 分析与实战》</p>

<!--more-->


<p>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-凌乱的分割线&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;</p>

<p>其次讲讲要用到的工具（ios安装工具使用Cydia中搜索安装，有些需要数据源可以自行查找）：</p>

<ul>
<li><p>已经越狱的IOS设备：这是必须的</p></li>
<li><p>OpenSSH（数据源：<a href="http://apt.saurik.com%EF%BC%89%EF%BC%9A%E7%94%A8%E4%BA%8E%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95ssh%E5%92%8C%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93scp">http://apt.saurik.com%EF%BC%89%EF%BC%9A%E7%94%A8%E4%BA%8E%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95ssh%E5%92%8C%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93scp</a></p></li>
<li><p>class-dump-z: 用于简单分析出工程中的类名和函数名</p></li>
<li><p>IDA：强大的反编译工具</p></li>
<li><p>Hopper Disassembler：类似IDA 我比较喜欢，能简单转换成OC的功能</p></li>
<li><p>Reveal:UI层解析工具</p></li>
<li><p>iFunBox 、 iTools ：两个都是强大的ios设备管理工具，越狱后能轻松读取应用文件等功能</p></li>
</ul>


<p>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-凌乱的分割线&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;</p>

<p>恩，差不多就这么多了！上面的工具大部分都是收费的，不过都是有试用版的，接下来我们一个个分析：</p>

<p>ios设备越狱，这个我就不讲了吧，不过我要赞@盘古团队一个，目前所有ios系统都可以越狱（包括ios8.x）</p>

<p>在ios设备上下载OpenSSH （数据源：<a href="http://apt.saurik.com%EF%BC%89%EF%BC%8C%E7%84%B6%E5%90%8E%E7%94%A8%E7%94%B5%E8%84%91%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95ios%EF%BC%9A">http://apt.saurik.com%EF%BC%89%EF%BC%8C%E7%84%B6%E5%90%8E%E7%94%A8%E7%94%B5%E8%84%91%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95ios%EF%BC%9A</a></p>

<p>然后输入密码，@后面是手机的IP号，越狱后默认密码好像是123456.</p>

<p>传输文件的命令是</p>

<pre><code>scp gdbinit root@172.168.1.100:/var/root
scp root@172.168.1.100:/var/root/123.txt ~/
</code></pre>

<ol>
<li>class-dump-z 是一个强大的函数提取工具，非常好用，也是基础工具</li>
</ol>


<p>下载地址：<a href="http://stevenygard.com/projects/class-dump">http://stevenygard.com/projects/class-dump</a></p>

<pre><code>              https://code.google.com/p/networkpx/wiki/class_dump_z
</code></pre>

<p>可以发到手机里调用，也可以在电脑上调用，要解析的文件是在应用目录下x.app（里面还有用到的所有文件资源）下面的x（x是你要分析的应用名）以唱吧为例，用ifunbox找到应用进入应用目录就可以看到ktv.app了打开包文件就能找到ktv。</p>

<pre><code>$ class-dump-z ktv &gt; ktv.txt       //导出所有内容到文件
$ class-dump-z -H ktv -o ktvdir/   //导出所有内容目录到文件夹（首先要创建ktvdir文件夹）
</code></pre>

<p>*这里会有一个问题，就是从app store下载的应用解析出来会是乱码，因为应用被加密了。解决办法</p>

<p><img src="http://al1020119.github.io/images/nixiang001.png" title="Caption" ></p>

<p>去渠道上下应用如同步推、91</p>

<p>解密工具 如AppCrackr(源<a href="http://cydia.xsellize.com">http://cydia.xsellize.com</a>)、Crackulous、Clutch</p>

<pre><code>  class-dump 只能解析出类名和函数名，不能看到具体的实现逻辑。但是很直观
</code></pre>

<p> 4.IDA和Hopper Disassembler差不多，能看到每个函数的具体逻辑（但是-都是汇编）IDA很强大，能在后面标记的oc的函数名，但是我更喜欢Hopper Disassembler，因为他能简单的模拟出oc源码，但是也是非常简单的。两者按空格键都能显示出分支逻辑来。</p>

<pre><code>汇编非常难看懂，我们需要的是耐心+耐心。后面可以加上动态工具联合分析能更有效
</code></pre>

<p><img src="http://al1020119.github.io/images/nixiang002.png" title="Caption" ></p>

<p> 5.Reveal的功能就更强大了，能表明出UI的具体结构来，告诉你每个View的类型是什么，这通常也是我们常用的分析一个app的切入点。</p>

<p>下载地址：<a href="http://revealapp.com">http://revealapp.com</a></p>

<p>下载完后打开reveal在菜单目录中help-show reveal library in finder打开库文件，将两个文件发到手机里</p>

<p><img src="http://al1020119.github.io/images/nixiang003.png" title="Caption" ></p>

<p>接下来编辑libReveal.plist文件</p>

<p>在/Library/MobileSubstrate/DynamicLibraries/下创建文件libReveal.plist，指定app的Bundle，可以指定多个</p>

<p>同学们会问了，app 的bundleID怎么查看呢，我们还是用ifunbox工具找到应用目录，在x.app文件夹中会有info.plist文件，打开就能找到。</p>

<p>最后重启设备-打开想分析的应用-电脑打开reveal接口，就可以点击分析了</p>

<p><img src="http://al1020119.github.io/images/nixiang004.png" title="Caption" ></p>

<p>总结一下吧，分析一个应用的逻辑是这样的：</p>

<ul>
<li><p>拿个越狱机-下好工具</p></li>
<li><p>去越狱平台下个想分析的应用（或者去app store下，用解密工具解密一下）</p></li>
<li><p>导入reveal分析页面，得到想要的知道的具体视图类或者大致范围</p></li>
<li><p>分析class-dump中，找到想要的类和函数</p></li>
<li><p>在IDA中找到具体函数，查看逻辑</p></li>
</ul>


<blockquote><p>单纯的静态分析只能知道个大概，想知道框架和具体内容还需要动态分析（下面分析）的帮助。不过想知道一个应用用到了什么库，界面是什么结构，有什么图片资源，上面的绝对够用了。总之逆向工程是比较枯燥无味的东西，资料又少，需要的是。。。。。加油</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[反编译和防反编译]]></title>
    <link href="http://al1020119.github.io/blog/2016/03/08/fanbianyihefangfanbianyi/"/>
    <updated>2016-03-08T13:32:08+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/03/08/fanbianyihefangfanbianyi</id>
    <content type="html"><![CDATA[<p>关于反编译和防止反编译</p>

<h3>反编译</h3>

<ul>
<li><p>内购破解</p>

<ul>
<li>iOS应用需防反编译风险之一：插件法（仅越狱）、iTools工具替换文件法（常见为存档破解）、八门神器修改</li>
</ul>
</li>
<li><p>网络安全风险</p>

<ul>
<li>iOS应用需防反编译风险之二：截获网络请求，破解通信协议并模拟客户端登录，伪造用户行为，对用户数据造成危害</li>
</ul>
</li>
</ul>


<!--more-->


<ul>
<li><p>应用程序函数PATCH破解</p>

<ul>
<li>iOS应用需防反编译风险之三：利用FLEX 补丁软件通过派遣返回值来对应用进行patch破解</li>
</ul>
</li>
<li><p>源代码安全风险</p>

<ul>
<li>iOS应用需防反编译风险之四：通过使用ida等反汇编工具对ipa进行逆向汇编代码，导致核心代码逻辑泄漏与被修改，影响应用安全</li>
</ul>
</li>
<li><p>面对这些iOS应用存在的风险，iOS应用如何防止被反编译，下面看下iOS应用加密技术</p></li>
</ul>


<h3>iOS应用加密防反编译技术</h3>

<ul>
<li><p>本地数据加密</p>

<ul>
<li>iOS应用防反编译加密技术之一：对NSUserDefaults，sqlite存储文件数据加密，保护帐号和关键信息</li>
</ul>
</li>
<li><p>URL编码加密</p>

<ul>
<li>iOS应用防反编译加密技术之二：对程序中出现的URL进行编码加密，防止URL被静态分析</li>
</ul>
</li>
<li><p>网络传输数据加密</p>

<ul>
<li>iOS应用防反编译加密技术之三：对客户端传输数据提供加密方案，有效防止通过网络接口的拦截获取数据</li>
</ul>
</li>
<li><p>方法体，方法名高级混淆</p>

<ul>
<li>iOS应用防反编译加密技术之四：对应用程序的方法名和方法体进行混淆，保证源码被逆向后无法解析代码</li>
</ul>
</li>
<li><p>程序结构混排加密</p>

<ul>
<li>iOS应用防反编译加密技术之五：对应用程序逻辑结构进行打乱混排，保证源码可读性降到最低</li>
</ul>
</li>
</ul>


<h3>下面是iOS应用加密防反编译前后对比</h3>

<p>iOS应用防反编译总结</p>

<ul>
<li><p>通过以上研究，iOS应用开发者必须要注意iOS应用反编译技术研究了，不要让iOS应用重蹈Android应用的覆辙，iOS应用防反编译！</p></li>
<li><p>反编译的流程，就是虚拟一个执行环境，看程序执行了那些指令，翻译成相应的语句一般的流程是先把程序调入到数据段， 虚拟运行环境，一般这分配文件头部，从纪录指令程序数据段，载入到虚拟环境中，纪录指令，遇到跳转指令，压入栈，形成树结构（看数据结构），遍历每个节点 的指令。形成完整程序</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[简单环境介]]></title>
    <link href="http://al1020119.github.io/blog/2016/03/05/jiandanhuanjinjieshao/"/>
    <updated>2016-03-05T13:32:08+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/03/05/jiandanhuanjinjieshao</id>
    <content type="html"><![CDATA[<h3>知识点准备</h3>

<h6>越狱的三点</h6>

<ul>
<li><p>第一点——越狱开放了iOS的文件系统，使得用户一下子获得了root权限，获得了整个iOS系统的掌控大权。越狱之后用iFunBox等工具可以可简单地看到iOS的整个文件系统，因此也可以修改系统UI、铃声，或者当U盘用。同样的，越狱之后安装的一些程序，也同样突破了沙盒的限制，甚至获得root权限，程序的行为可以不受用户和系统的限制。权利和责任的对等的，获得了root权限的用户就必须对这个系统对安全和完整性负责。可惜的是很多人越狱了，但又抱怨iPhone出现的耗电、卡机、白苹果等等现象。目测很多Android和越狱用户，确实没这个能力去负起这个责任。</p></li>
<li><p>第二点——cydia。基本所有人都把它当作越狱的显性标志。cydia表面上看来就是一个AppStore，实际上利用了另外一套软件管理系统——“Debian Package ”，也就是常说的dpkg，使用的安装包是deb，在Ubuntn上很是常见。deb的安装和卸载依靠的是一套完整的脚本，用control作为软件的标识信息，数据用tar压缩。另外，cydia还有软件源这个机制，由于我没搭过源服务器，完全不懂其中原理。</p></li>
<li><p>第三点——MobileSubstrate。这是越狱必装插件，也是tweak开发的前提。那些让iPhone能拦截黑名单电话的，或者让时间能显示年月日的，或者在状态栏添加个天气图标的程序，基本都依赖与此。</p></li>
</ul>


<!--more-->


<p>事实上，MobileSubstrate包含了三大组件。</p>

<pre><code>MobileHooker
</code></pre>

<p>俗称钩子。这把存在于内存里的钩子能钩住任何想钩住的系统方法，并替换成自己的实现方法。举例而言，黑名单的电话能被挂断，是因为在接通的那个系统方法里，并替换掉且不执行原有的方法，所以接通电话的事件也就被中断了。当然，那些奇怪问题诸如白苹果等事件基本都是由这个引起的。</p>

<pre><code>MobileLoader
</code></pre>

<p>钩子能够加载进内存并动态替换内存，靠的就是这个。其中编写.plist文件来限制加载范围必不可少。</p>

<pre><code>Safe mode
</code></pre>

<p>越狱后的机子基本都经历过安全模式，当SpringBoard崩溃时会自动进入安全模式，靠的就时这个的功劳，不然，这世界上不知又要多了多少部白苹果。</p>

<p>若想了解更多MobileSubstrate，可以点这里</p>

<p>何为越狱已经结束，为何越狱也就明朗起来了。</p>

<pre><code>想掌握iOS的整个文件系统，把iPhone当U盘使。
为了获得更好等功能，如电话增强功能、flash等
搞一些修改系统的行为，如更换UI、铃声、图标，等等
工作需要（比如说我）
安装免费软件（我故意放到最后的）
</code></pre>

<p>最后提醒一句，在非越狱机上，AppStore上的那些来电归属地，透视镜，指纹锁，基本都是假的，看完这篇文章，原因读者大概也能略知一二了。而那些省电、清内存之类的，反正我是不用，这些东西交给系统就行了，反正我上没见过iPhone4或4s会卡到游戏玩不了需要硬启动的。用户程序要操心这些东西，说真的，有心无力。有钱的话，买买几个正版的单机游戏，购买一次还提供永久的免费升级，也挺值了。</p>

<h3>环境准备</h3>

<p>曾经在cocoachina看过有人评论，越狱开发，只要找个稍微懂UNIX和Objective-C的开发人员就行了。看见这话真是无比痛心。AppStore开发者即使再痛恨越狱，但也没必要用如此言语贬低越狱开发人员。越狱开发可能想象中很是简单，但绝不是简单到用几个Private API或者在搞个重启关机等等事情（说实话重启手机还真不是一句代码能实现的）。越狱开发混了几个月，发现自己知识面完全不行。从我不成熟的眼光看来，越狱开发需要以下的几个素质：</p>

<pre><code>Objective-C以及iOS开发
</code></pre>

<p>这一点算是囊括了AppStore开发的东西。没有公司会愿意开发一个没有用户界面的东西。相比于AppStore开发，越狱开发的好处是可以使用Private API，但同时需要忍受无文档，以及一堆数据类型为id的变量带来的痛苦。</p>

<pre><code>UNIX
</code></pre>

<p>权限、脚本、进程管理，等等，哪一个不会都可能成为开发中的软肋。对于操作系统没好好学过的我，可怜了我的肋骨哟。</p>

<pre><code>iOS的特性
</code></pre>

<p>这一点抽象到连我自己也说不清。iOS作为一个类UNIX系统，肯定有一套属于自己的特性。掌握它的特性的人，需要是一个拥有理性头脑的果粉（可惜我不是）。对iOS特性的掌握可以快速找到各种奇奇怪怪的需求的解决方案，以及解决各种无log无法调试无稳定重现路径的bug甚至崩溃甚至白苹果。说个最近遇到的，某天发现了我的未接来电无法显示在通知栏了，于是我在某个文件夹里翻到了某张plist打开阅读之后果断删了，重启SpringBoard后一切正常，这能说成是一种敏感么？ 扯远了。</p>

<p>说说越狱的开发环境。其实作为一个不太入流的领域，不能指望哪个大公司某天推出一套越狱开发工具。不过，多亏了国外几位越狱大神，越狱开发才逐渐模板化。刚接触越狱开发时，最有名的莫过于theos了，模板多且编译简单。不过，今年二月发布的iOSOpenDev则集合了theos的所有优势，同时集合到Xcode之中，还能实现简单的deb打包，算是贴心尽意了。 安装iOSOpenDev之前，可先确认：</p>

<pre><code>Xcode4.0及以上
dpkg已安装。利用的是dpkg相关的东西，打包这些东西避免不了。推荐使用macports安装
git已安装。利用的是git相关的东西，很多开源项目都托管在git上
thoes已安装。很多旧的开源项目都是可不是由iOSOpenDev创建的，使用theos可以快速编译他们，同时iOSOpenDev的Logos模板是依托于theos的，而Logos模板，在我看来是tweak开发最优秀的模板，没有之一
</code></pre>

<p>接下来就可以安装iOSOpenDev。一直确定下去，假如不需要打包功能，则不需要填写IP等东西。事实上除了学习之外，基本可以忽略打包功能，脚本打包才是王道。 更详细的东西，可以看这里。 安装完毕，打开Xcode，新建工程，发现有iOSOpenDev一项，还有大量模板可选时，说明环境搭建已成功。Enjoy it！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Jianceshifouyueyu]]></title>
    <link href="http://al1020119.github.io/blog/2016/03/05/jianceshifouyueyu/"/>
    <updated>2016-03-05T00:00:00+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/03/05/jianceshifouyueyu</id>
    <content type="html"><![CDATA[<hr />

<p>layout: post
title: &ldquo;检测是否越狱&rdquo;
date: 2016-03-05 13:32:08 +0800
comments: true</p>

<h2>categories: Summary</h2>

<p>底层开发之越狱开发第二篇</p>

<p>今天项目中要用到检查iPhone是否越狱的方法。</p>

<p>Umeng统计的Mobclick.h里面已经包含了越狱检测的代码，可以直接使用</p>

<!--more-->


<p>复制代码
复制代码</p>

<pre><code>/*方法名:
 *        isJailbroken
 *介绍:
 *        类方法，判断设备是否越狱，判断方法根据 apt和Cydia.app的path来判断
 *参数说明:
 *        无
 *        
 *
 */

#pragma mark utils api
// 类方法，判断当前设备是否已经越狱
+ (BOOL)isJailbroken;
// 类方法，判断你的App是否被破解
+ (BOOL)isPirated;
</code></pre>

<p>复制代码
复制代码
apt和Cydia的方式来进行判断的，没看见源码</p>

<p>然后再介绍两种方法来查看是否已经越狱，知其然知其所以然、、、</p>

<ol>
<li><p>apt</p>

<p> 1 - (BOOL) hasAPT
 2 {
 3 return [[NSFileManager defaultManager] fileExistsAtPath:@&ldquo;/private/var/lib/apt/&rdquo;];
 4 }</p></li>
<li><p>system</p>

<p> 1 - (BOOL) successCallSystem
 2 {
 3 return (system(&ldquo;ls&rdquo;) == 0) ? YES : NO;
 4 }</p></li>
</ol>


<p>3.示例代码</p>

<p>复制代码</p>

<pre><code> 1 static const char* jailbreak_apps[] =
 2 
 3     {
 4         "/Applications/Cydia.app",
 5         "/Applications/limera1n.app",
 6         "/Applications/greenpois0n.app",
 7         "/Applications/blackra1n.app",
 8         "/Applications/blacksn0w.app",
 9         "/Applications/redsn0w.app",
10         "/Applications/Absinthe.app",
11         NULL,
12     };
13      
14     - (BOOL) isJailBroken
15     {
16         // Now check for known jailbreak apps. If we encounter one, the device is jailbroken.
17         for (int i = 0; jailbreak_apps[i] != NULL; ++i)
18         {
19             if ([[NSFileManager defaultManager] fileExistsAtPath:[NSString stringWithUTF8String:jailbreak_apps[i]]])
20             {
21                 //NSLog(@"isjailbroken: %s", jailbreak_apps[i]);
22                 return YES;
23             }
24         }
25          
26         // TODO: Add more checks? This is an arms-race we're bound to lose.
27          
28         return NO;
29     }
30  
31 
32 @interface UIDevice (Helper)  
33 - (BOOL)isJailbroken;  
34 @end
35 
36 @implementation UIDevice (Helper)  
37 - (BOOL)isJailbroken {  
38   BOOL jailbroken = NO;  
39   NSString *cydiaPath = @"/Applications/Cydia.app";  
40   NSString *aptPath = @"/private/var/lib/apt/";  
41   if ([[NSFileManager defaultManager] fileExistsAtPath:cydiaPath]) {  
42     jailbroken = YES;  
43   }  
44   if ([[NSFileManager defaultManager] fileExistsAtPath:aptPath]) {  
45     jailbroken = YES;  
46   }  
47   return jailbroken;  
48 }  
49 @end
</code></pre>

<p>复制代码</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[常见越狱方法]]></title>
    <link href="http://al1020119.github.io/blog/2016/03/04/changjianyueyufangfa/"/>
    <updated>2016-03-04T15:32:08+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/03/04/changjianyueyufangfa</id>
    <content type="html"><![CDATA[<p>iOS设备的越狱方法</p>

<p>最近公司的事情很忙，在开发一个类似于微信的App，经常加班，所以也没有时间去更新微信公众账号的内容了。iOSJailbreak, 申请这个账号大概有一个多月了吧，发布的内容不多，更多是针对开发者的内容，针对普通iPhone &amp; iPad用户的内容几乎没有，有收听的朋友经常发问，怎样去越狱，怎样去开发越狱的插件或者app。后面都会细细道来。</p>

<h3>一、先说iPhone 5S 和 iPhone5C吧</h3>

<p>最新的iPhone又要出来了，大概是9月21号左右美国和香港应该是可以购买的。新的iOS7应该是在9月16号发布。5C有5个颜色，配截图。</p>

<blockquote><p>其实我是大概在今年3月底4月初的时候听 富士康那边的朋友说的，有一款中端版本的iPhone5C, 价格大概在3000左右，估计香港，美国那边的更便宜，应该是2000+的样子。等待新机的到来，其实iPhone5的感觉就是轻，拿着很舒服。估计5C应该也差不多。</p></blockquote>

<!--more-->


<h3>二、怎么越狱</h3>

<p>越狱有很多种方法和工具，红雪的 (redsn0w)  ， 绿毒的(greenp0ison)，Absinthe， evasi0n等等， 还有一些其他的，不怎么知名，当然也比不上上面的了，就不过多介绍了。
我在网上找了相关的越狱教程，因为涉及到的系统版本，设备型号太多了，无法逐一验证。找了一个靠谱的链接，绝不是广告哦，我亲测过。
这个网站上几乎针对每种系统，每种机型都可以越狱。</p>

<ul>
<li><p>链接一、在这个链接里面选择对应的设备类型，比如iPhone5， iPad mini等等。
<a href="http://jb.appvv.com/shebei/">http://jb.appvv.com/shebei/</a></p></li>
<li><p>链接二、选择对应的设备之后，进入到选择设备对应的系统版本页面，不同的机型有差别，比如这个是4s的
<a href="http://jb.appvv.com/shebei/iphone4s/">http://jb.appvv.com/shebei/iphone4s/</a></p></li>
</ul>


<p>链接三、在选择对应的设备和系统版本之后，就可以自己开始越狱了，严格按照教程操作，比如4s的, iOS6.1.2的版本就可以按照如下链接操作
<a href="http://jb.appvv.com/news/19806.shtml">http://jb.appvv.com/news/19806.shtml</a></p>

<p>有时间可以多看下网站上的内容。</p>

<h3>三、关于越狱的安全性等问题</h3>

<p>很多人说，越狱的iPhone存在着安全性问题，从一个方面来讲，确实存在这样的问题。但是这并不是iOS系统的问题，包括Windows, Android系统都存在问题。同样的前提下，iOS的安全性绝对要高的多。听说过Windows系统下，Android系统下用户的账号被盗用，卡被盗刷的情况，但是iOS系统下的我没听说过类似的情况，包括越狱的iOS系统，安全性依然很高。</p>

<p>手机本来就是用来玩儿，越狱之后有很多好用的插件，还可以免费装各种应用，还有输入法，黑名单等等，一系列的“好处”吧。但是越狱之后，手机的安全性还是值得警惕，涉及到银行转账和交易的时候最好双方确认好，避免被骗。
总之越狱之后可玩儿性更高一些。对于越狱我保持中立吧，有些人拿着手机就打打电话，发发微信，不想折腾。喜欢玩儿的人，可以去试试。</p>

<blockquote><p>PS：之前我越狱了自己的iPad，把微信的打飞机刷了200多万分，天天爱消除刷了180W分，越狱之后用插件弄的。我推测了一下，手工打的话，打飞机不会超过160W分，后面太难了，大飞机太多了。爱消除我只用了40S刷了180W分，后面都没管了。大家可以自己试试。</p></blockquote>

<h4>实例方案</h4>

<p>办法1.</p>

<p>int xx=fork() //这个函数从这里起，程序被分为两个进程，父和子，子进程，返回0，父进程返回子进程ID，如果执行fork成功，说明沙盒被破坏，说明越狱了
if(!xx)。//子进程，关闭他
{
     exit(0);
}
if(xx>=0)父进程，说明越狱
{
return 1;
}
return 0 ;//，没有越狱，返回-1，</p>

<p>办法2
检测cydia.app是否存在
    struct stat s;
    int is_jailbroken=stat(&ldquo;/Applications/Cydia.app&rdquo;, &amp;s);
    NSLog(@&ldquo;&mdash;&ndash;is_jailbroken=%d&mdash;-&rdquo;,is_jailbroken);//返回为0说明有Cydia.app，否则-1
或者
   struct stat s;
    int is_jailbroken=stat(&ldquo;/Library/MobileSubstrate/DynamicLibraries/MobileSubstrate.dylib&rdquo;, &amp;s);
    NSLog(@&ldquo;&mdash;&ndash;is_jailbroken=%d&mdash;-&rdquo;,is_jailbroken);</p>

<p>办法3.判断文件大小</p>

<p>struct stat s
stat(“/etc/fstab”,&amp;s);
return s.st_size</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[逆向技术分析]]></title>
    <link href="http://al1020119.github.io/blog/2016/03/03/nixiangjishufenxi/"/>
    <updated>2016-03-03T13:32:08+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/03/03/nixiangjishufenxi</id>
    <content type="html"><![CDATA[<p>iOS App 的逆向工程: Hacking on Lyft
您的评价:</p>

<p> 收藏该经验</p>

<p>阅读目录</p>

<ol>
<li>介绍(0:00)</li>
<li>逆向 Lyft(1:44)</li>
<li>窥视 Lyft(2:48)</li>
<li>探测网络流量 - Charles 演示(4:08)</li>
<li>向 Lyft 里注入代码 - Cycript 演示(7:44)</li>
<li>解密可执行文件 - dumpdecrypted 演示(11:28)</li>
<li>分析可执行文件 - IDA 演示(13:47)</li>
<li>寻找 Lyft 的 URL Scheme(18:23)</li>
<li>Q&amp;A(22:50)</li>
</ol>


<p>原文  <a href="https://realm.io/cn/news/conrad-kramer-reverse-engineering-ios-apps-lyft/">https://realm.io/cn/news/conrad-kramer-reverse-engineering-ios-apps-lyft/</a></p>

<!--more-->


<p>如果你曾经想要知道某一部分代码如何工作，或者很同情某些人程序里的 Bug，你要是有代码，通常可以看看那部分代码。但是，如果没有代码可怎么办？ 在这个演讲里，Conrad 讲到了很多可以逆向 App 的概念和工具，这些方法和工具可以用来 debug 别人的库和你自己的代码。他还展示了逆向 iOS 版本的 Lyft （译者注：Lyft 是美国 Uber 之外的另一款打车软件），并且成功注入代码，探测网络流量，给我们活灵活现地展示逆向的艺术。通过 Conrad 的逆向技术，你也能成功地把 App Store 里所有的 App 的代码都暴露在你面前。</p>

<pre><code>Sign up to be notified of new videos — we won’t email you for any other reason, ever.
</code></pre>

<h4>介绍(0:00)</h4>

<p>我是 Conrad Kramer ，工作在 Workflow 的一枚 iOS 工程师，今天要跟大家聊聊 iOS Apps 逆向工程那些事儿。通常来说，逆向工程就是试图只通过最终产物来了解它背后工作原理的过程。在 iOS app 的世界里，这意味着你在没有源代码的前提下，只通过从 App Store 下载的 .app 来发现你想要的信息。</p>

<p>在做逆向工程的时候，会遇到两个痛点：</p>

<pre><code>使用的工具 通常很难用，因为这些工具本身就缺乏文档，而且很不出名。他们总是崩溃出错，而且没人去修复这些错误。另外，花时间找到他们以及用好他们都很难。
一旦你开始用这些工具了，清楚自己的目标也很重要，因为有太多事情可以干了。此外，你还能用工具去逆向苹果自己的框架，尽管他是闭源的。我们可以用这些技术来探索 UIKit 的某个 bug，或者某个 app 里的 bug。
</code></pre>

<p>所以逆向的第一步是像自己发问：“为什么这个 bug 会发生？他们在 UI 里用了哪些组件？” 比如，如果你很好奇一个 app 里是否用了 collection view 或者 table view”，你其实很容易回答这个问题，看一眼就好了。但是如果你问：“他们的 REST API 是什么结构的？”，这个时候逆向工程就能帮你一探究竟。
逆向 Lyft(1:44)</p>

<p>我决定通过一个项目来开始这个主题，目标是： Lyft’s iOS app ，它整个都是用 Swift 完成的。首先要做的事是我们了解我们感兴趣的点。假设我对 REST API 很感兴趣，比如我想要在另一个平台或者在 web 上写一个 Lyft 客户端，我可以看看他们的 API 然后产生好奇：“他们的 URL scheme 是什么样子的？”，当你想对 Lyft 做深度链接的时候，你就不得不解决这个问题。对 Workflow 来说，相关性就更高了，因为 Workflow 就是一个自动工具，我们集成了很多不同的 app。我总是需要做些类似的事情，来发现一些不公开的私有 URL scheme。</p>

<h4>窥视 Lyft(2:48)</h4>

<p>从 iTunes 下载下来的 Lyft 是一个 .IPA 文件（其实就是 zip 格式的）。它有很多的元数据，像 Info.plist 文件，资源文件，图片，本地化的字符串以及很多类似的文件。这里面也包含一些可执行文件，那些被编译了的代码就在里面。另外，因为 Lyft 是用 swift 写的，所以还包含很多附加的框架。</p>

<p>Lyft 现在看来是一个完完全全的黑盒子。我们不能直接的看透它，但我们依然有能力从特定的一些角度窥视到。一种方法就是通过监测网络流量来观察他的 API, 同时还能看到有哪些信息被它发送到了 Lyft 的服务器，这些通常对 App 而言是没有什么伤害的。</p>

<p>然后，我们还能 注入代码 ，真的非常爽。当 app 运行的时候，你可以打探打探这些 app 里被实例化而且存活的对象。当停止运行的时候，我们可以尝试去研究下 .app 是如何被组织的，同时通过特定的视角来看这些代码。</p>

<h4>探测网络流量 - Charles 演示(4:08)</h4>

<p>Charles 是一个 HTTPS 代理工具，它可以让流量在发往服务器前拦截网络流量。我们可以用这个工具来观察所有从 Lyft app 流向服务器的请求。</p>

<p>Lyft 事实上通过 SSL 加密了它的所有流量。但这些都很好破，通过 中间人攻击 的方法来解决这个问题。其实就是替换了加密证书。</p>

<p>当你在用 Lyft 的时候，Lyft 不断的把你的地理位置发给 Lyft 的服务器。 对车辆的请求和取消等操作会以格式化后的 JSON 在 Charles 中呈现出来。用 Charles，你会看到 app 里和网络交互的所有内容。</p>

<h4>向 Lyft 里注入代码 - Cycript 演示(7:44)</h4>

<p>下一个工具真的很赞，叫 Cycript 。使用这个工具的时候需要一个越狱设备，注入代码到 app 里。Cycript 可以让你看到别人的代码，当然你自己写的 app 也逃不过。这个工具是 Objective-C 和 Javascript 的混合 app，只用输入 Objective-C 的代码到控制台里，就能在 app 运行这些代码。它的交互编程环境（REPL）比 LLDB 的要好很多。尽管它不能中断，设置断点等等，但他对运行时代码非常友好。你可以直接输入下面的代码，基本上都是 Objective-C ：</p>

<pre><code>var application = [UIApplication sharedApplication];
[application openURL:[NSURL URLWithString:@"https://google.com"]];
</code></pre>

<p>我 SSH 进入我的破解过的 iPhone 6 以后，打开 Lyft，运行 Cycript，我可以通过选择功能来获取一个运行时的类实例，比如 view controller 的，或者统计类的实例。作为开发者，要确定设置 ACL 来防止特定 api key 的权限问题。如果 app 能拿到这些 key，那 Cycript 也一定能拿到。</p>

<p>你也可以修改 app 里的 views。比如，用 UIApp.keyWindow.recursiveDescription 通过内存寻址，把 “呼叫车辆” 的按钮变成绿色。</p>

<pre><code>var b = new Instance (ADDRESS)
b.backgroundColor = [UIColor greenColor]
</code></pre>

<p>Cycript 甚至还支持 tab 智能提示。这个功能不但对于逆向很有用，你还可以来测试你自己的 app，比如快速换个颜色测试测试效果什么的。
Q: 用 Crcript 测试自己的 app 的时候，设备一定需要越狱么？</p>

<p>Conrad: 对你自己的 app 的话，并不需要。在 cycript.org 官网上，提供了一些如何把这个工具嵌入到你自己的 app 的文档。</p>

<h4>解密可执行文件 - dumpdecrypted 演示(11:28)</h4>

<p>接下来，我们就要来感受下 app 运行时真正的代码了。这个稍微有些复杂，而且需要设备越狱，我们的演示会比较简单。因为有能力重签名我们的设备，所以苹果会加密商店里所有的 app，防止 app 被大家共享。然而，对于一个越狱设备来说，所有的这些加密的 app 都是可以被解密的。我从其他人那里 fork 了一个 repo，叫 dumpdecrypted ，原作者写这个是为了导出一个 app 的资源，我 fork 了一份，是为了让它能够支持所有的框架，毕竟现在很多 app 都含有 frameworks。</p>

<p>用它的时候，你只要简单的 clone 到本地，然后执行make，再在你越狱后的设备上对 app 执行一下。我对 Lyft 的 app 执行了这个，很快就解密了所有的文件。你看这些文件的时候，会发现所有的 framework 都以.decrypted后缀结尾。比较有意思的一些模块是 Lyft，LyftKit 和 LyftSDK，但是我们还发现了它还用了 SocketRocket，Stripe，Pusher，Mixpanel 等等的库。</p>

<h4>分析可执行文件 - IDA 演示(13:47)</h4>

<p>要分析我们导出的文件，查看源代码，我们要到 IDA ，和 Hopper 及 class-dump 类似的一个工具。当在编译一个 app 的时候，XCode 会创建一个由汇编组成的可执行文件。IDA 能很漂亮的输出这些可执行文件里的汇编代码，并且相互连接起来，你因此会看到一个由汇编代码组成的图。尽管 IDA 很贵，但是它的 免费版本 已经够用了。除了 64 位以外，基本都有。</p>

<p>要找到 Lyft 的 URL scheme，我们可以在 IDA 里执行一个简单的搜索，关键字是openURL，在类似的反编译工具中，Objective-C 是相对友好和容易的，因为它对于工作原理是相对透明的，Swift 就相对较差，很多工具还没有很好的支持 Swift，Swift 的汇编代码也更混乱，它的类信息很难被提取出来，不过，多练习练习，看看这些汇编，你会发现一些技巧来捕获你所想找的信息。</p>

<p>使用 IDA 的图表视野，我们发现了<em>TZFV4Lyft15DeepLinkManager13handleOpenURLfMS0_FCSo5NSURLSb，看起来是个很乱的字符串，然而我们依然可以发现LyftDeepLinkManager,handleOpenURL, 和NSURL这几个关键词。这些看似随机的字符串其实是有解释的，虽然没有文档来说明。如果想要了解这些字符串的含义，可以看看 Mike Ash 的博客里一篇叫做 Friday Q&amp;A 的文章，这些模糊的东西都有解释。比如</em>T意思是这是一个 Swift 的符号，F意思是这是一个函数，4Lyft是一个模块名称，等等。</p>

<h4>寻找 Lyft 的 URL Scheme(18:23)</h4>

<p>想要从我们所见之中发现 URL scheme，我们就要用开发者的思维来思考。</p>

<p>一个 URL scheme 结构大概是这样的：</p>

<pre><code>lyft://action?parameter=value 
</code></pre>

<p>我们现在要去找到action是什么，parameter可能会是哪些。我首先找到了DeepLinkAbleSwift 协议，了解了深度链接的工作原理。通过搜索DeepLinkAble关键字，我在一个类里发现了诸如ride，help，invite，profile的请求对象。</p>

<p>我们对如何开始一次打车很好奇，我们可以看一下 Lyft 的DeepLinkToRide类，看看他是如何工作的。想要看这些，你甚至不需要了解汇编，你只需知道如何搜索和扫描汇编中你需要的信息即可。就好比你即使不会法语，却经常看见到法语，看的足够多次后，你总是能悟出些东西来。很多时候 IDA 展示给我们的完全就是一种外语，其实我第一次尝试逆向 Swift 的时候，就是这样一种感受。</p>

<p>通过大致浏览DeepLinkToRide的图。我发现了一些不同的字符串，比如 “pickup”，“［latitude］”，“［longtitude］”，“destination” 等等。IDA 还展显示了 ”ridetype“，后面经过测试发现这是个 action，通过查看 “ridetype”，我们发现了 “lyft”, “lyft_line”, “lyft_plus”, 和 “access”，这些都是出行方式。</p>

<p>构造这些不同的 URL 部分，然后测试请求。我发现请求一个出行的 scheme 方式如下：</p>

<pre><code>lyft://ridetype
  ?id=lyft_line
  &amp;pickup[latitude]=0
  &amp;pickup[longitude]=0
  &amp;destination[latitude]=0
  &amp;destination[longitude]=0
</code></pre>

<p>现在，我明白了 Lyft 是如何工作的了，我可以集成到 Workflow 里了。这个过程其实就是二进制分析。尽管这些看起来很复杂，但事实上，只要像个开发者一样思考，其实也那么的难。
Q&amp;A(22:50)
Q: 证书绑定（pinning certificates）能否防止中间人攻击？</p>

<p>Conrad：证书绑定是一个用来防止中间人攻击的方法，在实践中确实很有用，前提是你的手机未越狱。比如 Twitter 就在用证书绑定技术。然而，用逆向工具 Cycript 能够轻松破解。 AFNetworking 支持证书绑定，只要设置一下SSLPinningMode这个属性。然而… 我们可以用 Cycript，再把它修改成none，如果你的 iPhone 越狱了，或者被人控制了。所以，并没有一种方案能够彻底防止你的流量被检测，如果没有越狱，倒是一种很好的保护方法。
Q: 是否推荐类似 cocoapods-keys 这样的工具来混淆字符串？</p>

<p>Conrad: 字符串混淆有以下的好处：</p>

<p>－ 如果你用苹果框架里的私有 API，能很容易的躲避过苹果审查的自动扫描工具。－ 如果那个人并没有一部越狱的 iPhone，或者它不知道如何解析混淆，他可能很难找到 app 里的字符串。</p>

<p>然而，你无法永远的把字符串藏起来。比如，在 Cycript 中，你可以轻易地解开混淆。所以字符串混淆也不是没法破的保护方案。</p>

<p>Q: class-dump 和 dumpdecryped 的区别是啥？</p>

<p>Conrad: 他们事实上是不同的工具。 dumpecrypted 能将一个 App Store 加密的工具解密。而 class-dump 能将一个解密后得二进制文件去除他的 Objective-C 接口文件，跟 IDA 有点像，不过很遗憾的是：它不支持 Swift。
Q: 导出 Apple framework 的库，比如： this one ，是不是也是用的 class-dump？</p>

<p>Conrad: 是的，苹果的框架没有加密，可以被轻易地导出所有的class。这意味着那些把苹果的私有interface 放到GitHub上的，你可以轻易地搞定他们。
Q: 逆向工程是否存在法律问题？Lyft 会不会不同意调用他们的私有代码和 api？</p>

<p>Conrad: 从法律上讲，我觉得没有太多问题。我们通常会跟所有的合作伙伴去聊到我们在做的事情。比如：我刚刚发现的这些东西我都会和 Lyft 讨论一下，在他们允许后集成到 Workflow 里。这些技术其实也有很多道德上的考虑。不过话说回来，这些技术也能阻止开发者们胡乱搞，就比如之前逆向 Twitter 发现他们上传用户手机里装的 App 列表到他们的服务器上。所以凡事总有两面，逆向工程只是个工具，善用就好了。
Q: 如何查看苹果框架的反汇编代码？</p>

<p>Conrad: 这个的过程跟我之前展示的一个很像，只不过你不再需要一个越狱后的设备。当你把线插到设备上的时候，iTunes 实际上获取到了设备的符号，你可以在 Xcode 里找到一个大概叫 “device symbol” 文件夹，在 IDA 或者 class-dump 里打开 Apple 的 frameworks，然后展开分析。这些都是没加密的，而且可以直接拿来用。在修复一些 beta 版本的 UIKit 的 bug 的时候很好使。</p>
]]></content>
  </entry>
  
</feed>
