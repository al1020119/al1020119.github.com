<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[iOS梦工厂]]></title>
  <link href="http://al1020119.github.io/atom.xml" rel="self"/>
  <link href="http://al1020119.github.io/"/>
  <updated>2015-12-01T03:07:34+08:00</updated>
  <id>http://al1020119.github.io/</id>
  <author>
    <name><![CDATA[iCocos]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[自己写套缓存机制]]></title>
    <link href="http://al1020119.github.io/blog/2015/12/03/huan-cun-ji-zhi-shen-jiu/"/>
    <updated>2015-12-03T02:59:42+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/12/03/huan-cun-ji-zhi-shen-jiu</id>
    <content type="html"><![CDATA[<ul>
<li>前言</li>
</ul>


<p>大家都知道UITableView，最经典在于循环利用，这里我自己模仿UITableView循环利用,写了一套自己的TableView实现方案，希望大家看了我的文章，循环利用思想有显著提升。</p>

<h2>一： 研究UITableView底层实现</h2>

<h5>1.系统UITabelView的简单使用，这里就不考虑分组了，默认为1组。</h5>

<pre><code> 1 // 返回第section组有多少行
 2 - (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section
 3 {
 4     NSLog(@"%s",__func__);
 5     return 10;
 6 }
 7  
 8 // 返回每一行cell的样子
 9 - (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath
10 {
11     NSLog(@"%s",__func__);
12     static NSString *ID = @"cell";
13     UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:ID];
14      
15     if (cell == nil) {
16          
17         cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:ID];
18     }
19      
20     cell.textLabel.text = [NSString stringWithFormat:@"%ld",indexPath.row];
21      
22     return cell;
23 }
24 // 返回每行cell的高度
25 - (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath
26 {
27     NSLog(@"%s--%@",__func__,indexPath);
28     return 100;
29 } 
</code></pre>

<h5>2.验证UITabelView的实现机制。</h5>

<p>如图打印结果:</p>

<p><img src="http://al1020119.github.io/images/huancun001.png" title="Caption" ></p>

<ul>
<li><p>分析：底层先获取有多少cell（10个），在获取每个cell的高度，返回高度的方法一开始调用10次。</p>

<ul>
<li>目的：确定tableView的滚动范围，一开始计算所有cell的frame,就能计算下tableView的滚动范围。</li>
</ul>
</li>
<li><p>分析：tableView:cellForRowAtIndexPath:方法什么时候调用。</p></li>
</ul>


<p>打印验证，如图：</p>

<p><img src="http://al1020119.github.io/images/huancun002.png" title="Caption" ></p>

<p>一开始调用了7次，因为一开始屏幕最多显示7个cell</p>

<pre><code>- 目的：一开始只加载显示出来的cell，等有新的cell出现的时候会继续调用这个方法加载cell。
</code></pre>

<h5>3.UITableView循环利用思想</h5>

<p>当新的cell出现的时候，首先从缓存池中获取，如果没有获取到，就自己创建cell。</p>

<p>当有cell移除屏幕的时候，把cell放到缓存池中去。</p>

<h2>二、自定义UIScroolView，模仿UITableView循环利用</h2>

<h5>1.提供数据源和代理方法，命名和UITableView一致。</h5>

<pre><code> 1 @class YZTableView;
 2 @protocol YZTableViewDataSource
 3  
 4 @required
 5  
 6 // 返回有多少行cell
 7 - (NSInteger)tableView:(YZTableView *)tableView numberOfRowsInSection:(NSInteger)section;
 8  
 9  
10 // 返回每行cell长什么样子
11 - (UITableViewCell *)tableView:(YZTableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath;
12  
13 @end
14  
15 @protocol YZTableViewDelegate
16  
17 // 返回每行cell有多高
18 - (CGFloat)tableView:(YZTableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath;
19  
20 @end 
</code></pre>

<h5>2.提供代理和数据源属性</h5>

<pre><code>1 @interface YZTableView : UIScrollView
2  
3 @property (nonatomic, weak) id dataSource;
4  
5 @property (nonatomic, weak) id delegate;
6  
7 @end 
</code></pre>

<p>警告:</p>

<p><img src="http://al1020119.github.io/images/huancun003.png" title="Caption" ></p>

<p>解决，在YZTableView.m的实现中声明。</p>

<p><img src="http://al1020119.github.io/images/huancun004.png" title="Caption" ></p>

<ul>
<li><p>原因：有人会问为什么我要定义同名的delegate属性，我主要想模仿系统的tableView，系统tableView也有同名的属性。</p>

<ul>
<li>思路：这样做，外界在使用设置我的tableView的delegate，就必须遵守的我的代理协议，而不是UIScrollView的代理协议。</li>
</ul>
</li>
</ul>


<h5>3.提供刷新方法reloadData，因为tableView通过这个刷新tableView。</h5>

<pre><code> 1 @interface YZTableView : UIScrollView
 2  
 3 @property (nonatomic, weak) id dataSource;
 4  
 5 @property (nonatomic, weak) id delegate;
 6  
 7 // 刷新tableView
 8 - (void)reloadData;
 9  
10 @end 
</code></pre>

<h5>4.实现reloadData方法，刷新表格</h5>

<p>回顾系统如何刷新tableView</p>

<ul>
<li><p>1).先获取有多少cell,在获取每个cell的高度。因此应该是先计算出每个cell的frame.</p></li>
<li><p>2).然后再判断当前有多少cell显示在屏幕上，就加载多少</p></li>
</ul>


<hr />

<pre><code> 1 // 刷新tableView
 2 - (void)reloadData
 3 {
 4     // 这里不考虑多组，假设tableView默认只有一组。
 5      
 6     // 先获取总共有多少cell
 7     NSInteger rows = [self.dataSource tableView:self numberOfRowsInSection:0];
 8      
 9     // 遍历所有cell的高度，计算每行cell的frame
10     CGRect cellF;
11     CGFloat cellX = 0;
12     CGFloat cellY = 0;
13     CGFloat cellW = self.bounds.size.width;
14     CGFloat cellH = 0;
15     CGFloat totalH = 0;
16      
17     for (int i = 0; i &lt; rows; i++) {
18         
19         NSIndexPath *indexPath = [NSIndexPath indexPathForRow:i inSection:0];
20         // 注意：这里获取的delegate，是UIScrollView中声明的属性
21         if ([self.delegate respondsToSelector:@selector(tableView:heightForRowAtIndexPath:)]) {
22             cellH = [self.delegate tableView:self heightForRowAtIndexPath:indexPath];
23         }else{
24             cellH = 44;
25         }
26         cellY = i * cellH;
27          
28         cellF = CGRectMake(cellX, cellY, cellW, cellH);
29          
30         // 记录每个cell的y值对应的indexPath
31         self.indexPathDict[@(cellY)] = indexPath;
32          
33         // 判断有多少cell显示在屏幕上,只加载显示在屏幕上的cell
34         if ([self isInScreen:cellF]) { // 当前cell的frame在屏幕上
35             // 通过数据源获取cell
36             UITableViewCell *cell = [self.dataSource tableView:self cellForRowAtIndexPath:indexPath];
37              
38             cell.frame = cellF;
39              
40             [self addSubview:cell];
41              
42         }
43          
44         // 添加分割线
45         UIView *divideV = [[UIView alloc] initWithFrame:CGRectMake(0, cellY + cellH - 1, cellW, 1)];
46         divideV.backgroundColor = [UIColor lightGrayColor];
47         divideV.alpha = 0.3;
48         [self addSubview:divideV];
49          
50         // 添加到cell可见数组中
51             [self.visibleCells addObject:cell];
52          
53         // 计算tableView内容总高度
54         totalH += cellY + cellH;
55      
56     }
57      
58     // 设置tableView的滚动范围
59     self.contentSize = CGSizeMake(self.bounds.size.width, totalH);
60      
61 } 
</code></pre>

<h5>5.如何判断cell显示在屏幕上</h5>

<p>当tableView内容往下走</p>

<p><img src="http://al1020119.github.io/images/huancun005.gif" title="Caption" ></p>

<p>当tableView内容往上走</p>

<p><img src="http://al1020119.github.io/images/huancun006.gif" title="Caption" ></p>

<pre><code> 1 // 根据cell尺寸判断cell在不在屏幕上
 2 - (BOOL)isInScreen:(CGRect)cellF
 3 {
 4     // tableView能滚动，因此需要加上偏移量判断
 5      
 6     // 当tableView内容往下走，offsetY会一直增加 ,cell的最大y值 &lt; offsetY偏移量   ,cell移除屏幕
 7     // tableView内容往上走 , offsetY会一直减少，屏幕的最大Y值 &lt;  cell的y值 ，Cell移除屏幕
 8     // 屏幕最大y值 = 屏幕的高度 + offsetY
 9      
10     // 这里拿屏幕来比较，其实是因为tableView的尺寸我默认等于屏幕的高度，正常应该是tableView的高度。
11     // cell在屏幕上， cell的最大y值 &gt; offsetY &amp;&amp; cell的y值 &lt; 屏幕的最大Y值(屏幕的高度 + offsetY)
12      
13     CGFloat offsetY = self.contentOffset.y;
14      
15     return CGRectGetMaxY(cellF) &gt; offsetY &amp;&amp; cellF.origin.y &lt; self.bounds.size.height + offsetY;
16  
17     } 
</code></pre>

<h5>6.在滚动的时候，如果有新的cell出现在屏幕上，先从缓存池中取，没有取到，在创建新的cell.</h5>

<ul>
<li>分析：</li>
</ul>


<p>需要及时监听tableView的滚动，判断下有没有新的cell出现。</p>

<p>大家都会想到scrollViewDidScroll方法，这个方法只要一滚动scrollView就会调用，但是这个方法有个弊端，就是tableView内部需要作为自身的代理，才能监听，这样不好，有时候外界也需要监听滚动，因此自身类最好不要成为自己的代理。（设计思想）</p>

<ul>
<li>解决：</li>
</ul>


<p>重写layoutSubviews，判断当前哪些cell显示在屏幕上。</p>

<p>因为只要一滚动，就会修改contentOffset,就会调用layoutSubviews，其实修改contentOffset，内部其实是修改tableView的bounds,而layoutSubviews刚好是父控件尺寸一改就会调用.具体需要了解scrollView底层实现。</p>

<ul>
<li>思路：</li>
</ul>


<p>判断下，当前tableView内容往上移动，还是往下移动，如何判断，取出显示在屏幕上的第一次cell，当前偏移量 > 第一个cell的y值，往下走。</p>

<p>需要搞个数组记录下，当前有多少cell显示在屏幕上，在一开始的时候记录.</p>

<pre><code> 1 @interface YZTableView ()
 2  
 3 @property (nonatomic, strong) NSMutableArray *visibleCells;
 4  
 5 @end
 6  
 7 @implementation YZTableView
 8  
 9 @dynamic delegate;
10  
11 - (NSMutableArray *)visibleCells
12 {
13  
14     if (_visibleCells == nil) {
15         _visibleCells = [NSMutableArray array];
16     }
17     return _visibleCells;
18      
19 }
20 @end 
</code></pre>

<h3>往下移动</h3>

<ul>
<li><p>1.如果已经滚动到tableView内容最底部，就不需要判断新的cell，直接返回.</p></li>
<li><p>2.需要判断之前显示在屏幕cell有没有移除屏幕</p></li>
<li><p>3.只需要判断下当前可见cell数组中第一个cell有没有离开屏幕</p></li>
<li><p>4.只需要判断下当前可见cell数组中最后一个cell的下一个cell显没显示在屏幕上即可。</p></li>
</ul>


<hr />

<pre><code> 1 // 判断有没有滚动到最底部
 2         if (offsetY + self.bounds.size.height &gt; self.contentSize.height) {
 3             return;
 4         }
 5          
 6         // 判断下当前可见cell数组中第一个cell有没有离开屏幕
 7         if ([self isInScreen:firstCell.frame] == NO) { // 如果不在屏幕
 8             // 从可见cell数组移除
 9             [self.visibleCells removeObject:firstCell];
10              
11             // 删除第0个从可见的indexPath
12             [self.visibleIndexPaths removeObjectAtIndex:0];
13              
14             // 添加到缓存池中
15             [self.reuserCells addObject:firstCell];
16              
17             // 移除父控件
18             [firstCell removeFromSuperview];
19              
20         }
21         // 判断下当前可见cell数组中最后一个cell的下一个cell显没显示在屏幕上
22         // 这里需要计算下一个cell的y值，需要获取对应的cell的高度
23         // 而高度需要根据indexPath，从数据源获取
24         // 可以数组记录每个可见cell的indexPath的顺序,然后获取对应可见的indexPath的角标，就能获取下一个indexPath.
25          
26         // 获取最后一个cell的indexPath
27         NSIndexPath *indexPath = [self.visibleIndexPaths lastObject];
28          
29         // 获取下一个cell的indexPath
30         NSIndexPath *nextIndexPath = [NSIndexPath indexPathForRow:indexPath.row + 1 inSection:0];
31          
32         // 获取cell的高度
33         if ([self.delegate respondsToSelector:@selector(tableView:heightForRowAtIndexPath:)]) {
34             cellH = [self.delegate tableView:self heightForRowAtIndexPath:nextIndexPath];
35         }else{
36             cellH = 44;
37         }
38          
39         // 计算下一个cell的y值
40         cellY = lastCellY + cellH;
41          
42         // 计算下下一个cell的frame
43         CGRect nextCellFrame = CGRectMake(cellX, cellY, cellW, cellH);
44          
45         if ([self isInScreen:nextCellFrame]) { // 如果在屏幕上，就加载
46              
47             // 通过数据源获取cell
48             UITableViewCell *cell = [self.dataSource tableView:self cellForRowAtIndexPath:nextIndexPath];
49              
50             cell.frame = nextCellFrame;
51              
52             [self insertSubview:cell atIndex:0];
53              
54             // 添加到cell可见数组中
55             [self.visibleCells addObject:cell];
56              
57             // 添加到可见的indexPaths数组
58             [self.visibleIndexPaths addObject:nextIndexPath];
59              
60              
61         } 
</code></pre>

<h3>往上移动</h3>

<ul>
<li><p>1.如果已经滚动到tableView最顶部，就不需要判断了有没有心的cell，直接返回.</p></li>
<li><p>2.需要判断之前显示在屏幕cell有没有移除屏幕</p></li>
<li><p>3.只需要判断下当前可见cell数组中最后一个cell有没有离开屏幕</p></li>
<li><p>4.只需要判断下可见cell数组中第一个cell的上一个cell显没显示在屏幕上即可</p></li>
</ul>


<p>注意点：如果可见cell数组中第一个cell的上一个cell显示到屏幕上，一定要记得是插入到可见数组第0个的位置。</p>

<pre><code> 1 // 判断有没有滚动到最顶部
 2         if (offsetY &lt; 0) {
 3             return;
 4         }
 5          
 6          
 7          
 8         // 判断下当前可见cell数组中最后一个cell有没有离开屏幕
 9         if ([self isInScreen:lastCell.frame] == NO) { // 如果不在屏幕
10             // 从可见cell数组移除
11             [self.visibleCells removeObject:lastCell];
12              
13             // 删除最后一个可见的indexPath
14             [self.visibleIndexPaths removeLastObject];
15              
16             // 添加到缓存池中
17             [self.reuserCells addObject:lastCell];
18              
19             // 移除父控件
20             [lastCell removeFromSuperview];
21              
22         }
23          
24         // 判断下可见cell数组中第一个cell的上一个cell显没显示在屏幕上
25         // 获取第一个cell的indexPath
26         NSIndexPath *indexPath = self.visibleIndexPaths[0];
27          
28          
29         // 获取下一个cell的indexPath
30         NSIndexPath *preIndexPath = [NSIndexPath indexPathForRow:indexPath.row - 1 inSection:0];
31          
32         // 获取cell的高度
33         if ([self.delegate respondsToSelector:@selector(tableView:heightForRowAtIndexPath:)]) {
34             cellH = [self.delegate tableView:self heightForRowAtIndexPath:preIndexPath];
35         }else{
36             cellH = 44;
37         }
38          
39         // 计算上一个cell的y值
40         cellY = firstCellY - cellH;
41          
42          
43         // 计算上一个cell的frame
44         CGRect preCellFrame = CGRectMake(cellX, cellY, cellW, cellH);
45          
46         if ([self isInScreen:preCellFrame]) { // 如果在屏幕上，就加载
47              
48             // 通过数据源获取cell
49             UITableViewCell *cell = [self.dataSource tableView:self cellForRowAtIndexPath:preIndexPath];
50              
51             cell.frame = preCellFrame;
52              
53             [self insertSubview:cell atIndex:0];
54              
55             // 添加到cell可见数组中,这里应该用插入，因为这是最上面一个cell,应该插入到数组第0个
56             [self.visibleCells insertObject:cell atIndex:0];
57              
58             // 添加到可见的indexPaths数组,这里应该用插入，因为这是最上面一个cell,应该插入到数组第0个
59             [self.visibleIndexPaths insertObject:preIndexPath atIndex:0];
60              
61         }
62          
63     } 
</code></pre>

<ul>
<li>问题1：</li>
</ul>


<p>判断下当前可见cell数组中最后一个cell的下一个cell显没显示在屏幕上</p>

<p>这里需要计算下一个cell的frame,frame就需要计算下一个cell的y值，需要获取对应的cell的高度 cellY = lastCellY + cellH</p>

<p>而高度需要根据indexPath，从数据源获取</p>

<ul>
<li>解决：</li>
</ul>


<p>可以搞个字典记录每个可见cell的indexPath,然后获取对应可见的indexPath，就能获取下一个indexPath.</p>

<pre><code> 1 @interface YZTableView ()
 2  
 3 // 屏幕可见数组
 4 @property (nonatomic, strong) NSMutableArray *visibleCells;
 5  
 6 // 缓存池
 7 @property (nonatomic, strong) NSMutableSet *reuserCells;
 8  
 9  
10 // 记录每个可见cell的indexPaths的顺序
11 @property (nonatomic, strong) NSMutableDictionary *visibleIndexPaths;
12  
13 @end
14  
15 - (NSMutableDictionary *)visibleIndexPaths
16 {
17     if (_visibleIndexPaths == nil) {
18         _visibleIndexPaths = [NSMutableDictionary dictionary];
19     }
20      
21     return _visibleIndexPaths;
22 } 
</code></pre>

<h5>注意：</h5>

<p>当cell从缓存池中移除，一定要记得从可见数组cell中移除，还有可见cell的indexPath也要移除.</p>

<pre><code> 1 // 判断下当前可见cell数组中第一个cell有没有离开屏幕
 2         if ([self isInScreen:firstCell.frame] == NO) { // 如果不在屏幕
 3             // 从可见cell数组移除
 4             [self.visibleCells removeObject:firstCell];
 5              
 6             // 删除第0个从可见的indexPath
 7             [self.visibleIndexPaths removeObjectAtIndex:0];
 8              
 9             // 添加到缓存池中
10             [self.reuserCells addObject:firstCell];
11              
12         }
13          
14  // 判断下当前可见cell数组中最后一个cell有没有离开屏幕
15         if ([self isInScreen:lastCell.frame] == NO) { // 如果不在屏幕
16             // 从可见cell数组移除
17             [self.visibleCells removeObject:lastCell];
18              
19             // 删除最后一个可见的indexPath
20             [self.visibleIndexPaths removeLastObject];
21              
22             // 添加到缓存池中
23             [self.reuserCells addObject:lastCell];
24              
25         } 
</code></pre>

<h5>7.缓存池搭建，缓存池其实就是一个NSSet集合。</h5>

<p>搞一个NSSet集合充当缓存池.</p>

<p>cell离开屏幕，放进缓存池</p>

<p>提供从缓存池获取方法，从缓存池中获取cell,记住要从NSSet集合移除cell.</p>

<pre><code> 1 @interface YZTableView ()
 2  
 3 // 屏幕可见数组
 4 @property (nonatomic, strong) NSMutableArray *visibleCells;
 5  
 6 // 缓存池
 7 @property (nonatomic, strong) NSMutableSet *reuserCells;
 8  
 9 // 记录每个cell的y值都对应一个indexPath
10 @property (nonatomic, strong) NSMutableDictionary *indexPathDict;
11  
12 @end
13 @implementation YZTableView
14 - (NSMutableSet *)reuserCells
15 {
16     if (_reuserCells == nil) {
17         _reuserCells = [NSMutableSet set];
18     }
19     return _reuserCells;
20 }
21  
22 // 从缓存池中获取cell
23 - (id)dequeueReusableCellWithIdentifier:(NSString *)identifier
24 {
25     UITableViewCell *cell = [self.reuserCells anyObject];
26      
27     // 能取出cell,并且cell的标示符正确
28     if (cell &amp;&amp; [cell.reuseIdentifier isEqualToString:identifier]) {     
29         // 从缓存池中获取
30         [self.reuserCells removeObject:cell];
31          
32         return cell;
33     }
34     return nil;
35 }
36  
37 @end 
</code></pre>

<h5>8.tableView细节处理</h5>

<p>原因：刷新方法经常要调用</p>

<p>解决：每次刷新的时候，先把之前记录的全部清空</p>

<pre><code> 1 // 刷新tableView
 2 - (void)reloadData
 3 {
 4      
 5     // 刷新方法经常要调用
 6     // 每次刷新的时候，先把之前记录的全部清空
 7     // 清空indexPath字典
 8     [self.indexPathDict removeAllObjects];
 9     // 清空屏幕可见数组
10     [self.visibleCells removeAllObjects];
11     ...
12 } 
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[够逼格的注释习惯]]></title>
    <link href="http://al1020119.github.io/blog/2015/12/03/you-xiu-cheng-xu-yuan-shi-zen-yao-xie-zhu-shi-de/"/>
    <updated>2015-12-03T02:59:30+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/12/03/you-xiu-cheng-xu-yuan-shi-zen-yao-xie-zhu-shi-de</id>
    <content type="html"><![CDATA[<p>够逼格的注释习惯总结</p>

<p>首先关于注意这里就不说什么VVDocument了，来点新鲜的！</p>

<h6>也许你使用过#warning 警告提示</h6>

<h6>也许你也使用过#pragma marks。</h6>

<p>但是你见过或者使用过下面这个吗？</p>

<pre><code>Comments containing:
MARK:
TODO:
FIXME:
!!!:
???:
</code></pre>

<p>没有，那么你就快速的看看下面的内容，非常好用，也非常简单，不过具体使用看个人</p>

<p> 首先说一下三个最常用的：</p>

<ul>
<li>1、TODO</li>
</ul>


<p> 等待实现的功能</p>

<ul>
<li>2、FIXME</li>
</ul>


<p> 需要修正的功能</p>

<ul>
<li>3、！！！</li>
</ul>


<p> 需要改进的功能</p>

<p>具体使用</p>

<pre><code>// FIXME:sss
/* FIXME: sss */


// MARK:sss
/* MARK:sss */


// !!!:sss
/* !!!: sss */


// ???:sss
/* ???: sss */


// TODO:sss
/* TODO: sss */


// Comments containing: sss
/* Comments containing: sss */
</code></pre>

<p>注意空格.</p>

<p> 最后你会发现下面的效果，虽然和#pragma marks没有什么区别，但是这就是装逼原因</p>

<p>关于最后一个/<em> Comments containing: sss </em>/，笔者还没照发对应的使用方法，如果你知道可以联系我哦！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[粘贴深究]]></title>
    <link href="http://al1020119.github.io/blog/2015/12/03/nian-tie-shen-jiu/"/>
    <updated>2015-12-03T02:59:00+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/12/03/nian-tie-shen-jiu</id>
    <content type="html"><![CDATA[<p>在iOS中，可以使用剪贴板实现应用程序之中以及应用程序之间实现数据的共享。比如你可以从iPhone QQ复制一个url，然后粘贴到safari浏览器中查看这个链接的内容。</p>

<h3>一、在iOS中下面三个控件，自身就有复制-粘贴的功能：</h3>

<ul>
<li>1、UITextView</li>
<li>2、UITextField</li>
<li>3、UIWebView</li>
</ul>


<h3>二、UIKit framework提供了几个类和协议方便我们在自己的应用程序中实现剪贴板的功能。</h3>

<ul>
<li>1、UIPasteboard：我们可以向其中写入数据，也可以读取数据</li>
<li>2、UIMenuController：显示一个快捷菜单，用来复制、剪贴、粘贴选择的项。</li>
<li>3、UIResponder中的 canPerformAction:withSender:用于控制哪些命令显示在快捷菜单中。</li>
<li>4、当快捷菜单上的命令点击的时候，UIResponderStandardEditActions将会被调用。</li>
</ul>


<h3>三、下面这些项能被放置到剪贴板中</h3>

<ul>
<li>1、UIPasteboardTypeListString —  字符串数组, 包含kUTTypeUTF8PlainText</li>
<li>2、UIPasteboardTypeListURL —   URL数组，包含kUTTypeURL</li>
<li>3、UIPasteboardTypeListImage —   图形数组, 包含kUTTypePNG 和kUTTypeJPEG</li>
<li>4、UIPasteboardTypeListColor —   颜色数组</li>
</ul>


<h3>四、剪贴板的类型分为两种：</h3>

<p>系统级：使用UIPasteboardNameGeneral和UIPasteboardNameFind创建，系统级的剪贴板，当应用程序关闭，或者卸载时，数据都不会丢失。
应用程序级：通过设置，可以让数据在应用程序关闭之后仍然保存在剪贴板中，但是应用程序卸载之后数据就会失去。我们可用通过pasteboardWithName:create：来创建。</p>

<p>了解这些之后，下面通过一系列的例子来说明如何在应用程序中使用剪贴板。</p>

<p>例子：</p>

<h5>1、复制剪贴文本。</h5>

<pre><code>下面通过一个例子，可以在tableview上显示一个快捷菜单，上面只有复制按钮，复制tableview上的数据之后，然后粘贴到title上。
</code></pre>

<p>定义一个单元格类CopyTableViewCell，在这个类的上显示快捷菜单，实现复制功能。</p>

<pre><code>@interface CopyTableViewCell : UITableViewCell {
    id delegate;
}
@property (nonatomic, retain) id delegate;
@end
</code></pre>

<p>实现CopyTableViewCell ：</p>

<pre><code>#import "CopyTableViewCell.h"

@implementation CopyTableViewCell

@synthesize delegate;

- (id)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier {
    if ((self = [super initWithStyle:style reuseIdentifier:reuseIdentifier])) {
    }
    return self;
}
- (void)setSelected:(BOOL)selected animated:(BOOL)animated {
    [super setSelected:selected animated:animated];
}
- (void)setHighlighted:(BOOL)highlighted animated:(BOOL)animated {
    [[self delegate] performSelector:@selector(showMenu:)
                          withObject:self afterDelay:0.9f];

    [super setHighlighted:highlighted animated:animated];

}
- (BOOL)canBecomeFirstResponder
{
    return YES;
}
- (BOOL)canPerformAction:(SEL)action withSender:(id)sender{
    if (action == @selector(cut:)){
        return NO;
    }
    else if(action == @selector(copy:)){
        return YES;
    }
    else if(action == @selector(paste:)){
        return NO;
    }
    else if(action == @selector(select:)){
        return NO;
    }
    else if(action == @selector(selectAll:)){
        return NO;
    }
    else
    {
        return [super canPerformAction:action withSender:sender];
    }
}
- (void)copy:(id)sender {
    UIPasteboard *pasteboard = [UIPasteboard generalPasteboard];
    [pasteboard setString:[[self textLabel]text]];
}
- (void)dealloc {
    [super dealloc];
}
@end
</code></pre>

<p>复制代码
定义CopyPasteTextController，实现粘贴功能。
    @interface CopyPasteTextController : UIViewController<UITableViewDelegate> {
        //用来标识是否显示快捷菜单
        BOOL menuVisible;
        UITableView *tableView;
    }</p>

<pre><code>@property (nonatomic, getter=isMenuVisible) BOOL menuVisible;

@property (nonatomic, retain) IBOutlet UITableView *tableView;
@end
</code></pre>

<p>实现CopyPasteTextController ：</p>

<pre><code>#import "CopyPasteTextController.h"
#import "CopyTableViewCell.h"

@implementation CopyPasteTextController
@synthesize menuVisible,tableView;
- (void)viewDidLoad {
    [super viewDidLoad];
    [self setTitle:@"文字复制粘贴"];
    //点击这个按钮将剪贴板的内容粘贴到title上
    UIBarButtonItem *addButton = [[[UIBarButtonItem alloc]
                                      initWithBarButtonSystemItem:UIBarButtonSystemItemRefresh
                                      target:self
                                      action:@selector(readFromPasteboard:)]
                                     autorelease];
    [[self navigationItem] setRightBarButtonItem:addButton];
}


// Customize the number of sections in the table view.
- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView
{
    return 1;
}

- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section
{
    return 9;
}

// Customize the appearance of table view cells.
- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath
{
    static NSString *CellIdentifier =@"Cell";
    CopyTableViewCell *cell = (CopyTableViewCell *)[tableView
                                                           dequeueReusableCellWithIdentifier:CellIdentifier];
    if (cell == nil)
    {
        cell = [[[CopyTableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:CellIdentifier] autorelease];
        [cell setDelegate:self];
    }

    // Configure the cell.
    NSString *text = [NSString stringWithFormat:@"Row %d", [indexPath row]];
    [[cell textLabel] setText:text];
    return cell;
}

- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath
{
    if([self isMenuVisible])
    {
        return;
    }
    [[[self tableView] cellForRowAtIndexPath:indexPath] setSelected:YES
                                                           animated:YES];
}
//显示菜单
- (void)showMenu:(id)cell {
    if ([cell isHighlighted]) {
        [cell becomeFirstResponder];

        UIMenuController * menu = [UIMenuController sharedMenuController];
        [menu setTargetRect: [cell frame] inView: [self view]];
        [menu setMenuVisible: YES animated: YES];
    }
}
- (void)readFromPasteboard:(id)sender {
    [self setTitle:[NSString stringWithFormat:@"Pasteboard = %@",
                      [[UIPasteboard generalPasteboard] string]]];
}

- (void)didReceiveMemoryWarning
{
    // Releases the view if it doesn't have a superview.
    [super didReceiveMemoryWarning];

    // Relinquish ownership any cached data, images, etc that aren't in use.
}

- (void)viewDidUnload
{
    [super viewDidUnload];
    [self.tableView release];

    // Relinquish ownership of anything that can be recreated in viewDidLoad or on demand.
    // For example: self.myOutlet = nil;
}
</code></pre>

<p>复制一行数据：
点击右上角的按钮粘贴，将数据显示在title上：</p>

<h6>2、图片复制粘贴</h6>

<p>   下面通过一个例子，将图片复制和剪贴到另外一个UIImageView中间。</p>

<ul>
<li>1、在界面上放置两个uiimageview，一个是图片的数据源，一个是将图片粘贴到的地方。CopyPasteImageViewController 代码如下：</li>
</ul>


<p>@interface CopyPasteImageViewController : UIViewController {
    UIImageView <em>imageView;
    UIImageView </em>pasteView;
    UIImageView <em>selectedView;
}
@property (nonatomic, retain) IBOutlet UIImageView </em>imageView;
@property (nonatomic, retain) IBOutlet UIImageView <em>pasteView;
@property (nonatomic, retain) UIImageView </em>selectedView;
- (void)placeImageOnPasteboard:(id)view;
@end
* 2、当触摸图片的时候我们显示快捷菜单：</p>

<hr />

<pre><code>- (void)touchesBegan:(NSSet*)touches withEvent:(UIEvent*)event {
    NSSet *copyTouches = [event touchesForView:imageView];
    NSSet *pasteTouches = [event touchesForView:pasteView];

    [self becomeFirstResponder];
    if ([copyTouches count] &gt; 0) {
        [self performSelector:@selector(showMenu:)
                   withObject:imageView afterDelay:0.9f];
    }
    else  if([pasteTouches count] &gt; 0) {
        [self performSelector:@selector(showMenu:)
                   withObject:pasteView afterDelay:0.9f];
    }
    [super touchesBegan:touches withEvent:event];
}

- (void)showMenu:(id)view {
    [self setSelectedView:view];

    UIMenuController * menu = [UIMenuController sharedMenuController];
    [menu setTargetRect: CGRectMake(5, 10, 1, 1) inView: view];
    [menu setMenuVisible: YES animated: YES];
}
</code></pre>

<p>这里的快捷菜单，显示三个菜单项：剪贴、粘贴、复制：</p>

<hr />

<pre><code>- (BOOL)canPerformAction:(SEL)action withSender:(id)sender{
    if (action == @selector(cut:)) {
        return ([self selectedView] == imageView) ? YES : NO;
    } else if (action == @selector(copy:)) {
        return ([self selectedView] == imageView) ? YES : NO;
    } else if (action == @selector(paste:)) {
        return ([self selectedView] == pasteView) ? YES : NO;
    } else if (action == @selector(select:)) {
        return NO;
    } else if (action == @selector(selectAll:)) {
        return NO;
    } else {
        return [super canPerformAction:action withSender:sender];
    }
}
- (void)cut:(id)sender {
    [self copy:sender];
    [imageView setHidden:YES];
}
- (void)copy:(id)sender {
    [self placeImageOnPasteboard:[self imageView]];
}
- (void)paste:(id)sender {
    UIPasteboard *appPasteBoard =
    [UIPasteboard pasteboardWithName:@"CopyPasteImage" create:YES];
    NSData *data =[appPasteBoard dataForPasteboardType:@"com.marizack.CopyPasteImage.imageView"];
    pasteView.image = [UIImage imageWithData:data];
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[消除警告]]></title>
    <link href="http://al1020119.github.io/blog/2015/12/02/xiao-chu-jing-gao/"/>
    <updated>2015-12-02T02:51:46+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/12/02/xiao-chu-jing-gao</id>
    <content type="html"><![CDATA[<h6>前言：</h6>

<p>现在你维护的项目有多少警告？看着几百条警告觉得心里烦么？你真的觉得警告又不是错误可以完全不管么？ 如果你也被这些问题困惑，可以和我一起进行下面的操作。其实大部分的警告都是很好改的，把自己整个项目的警告撸一遍应该也就耗费半小时的时间，一次麻烦带来之后的清净这样不好么？</p>

<p>本文分为三个部分：</p>

<ul>
<li>1.简单粗暴的消除警告。</li>
<li>2.详细科学的消除警告。（包括警告收录）</li>
<li>3.添加警告。</li>
</ul>


<h4>一、简单粗暴的消除警告</h4>

<p>警告如果是自己项目中的还好直接改了，如果是第三方库，你改了之后，pod下作者更新一下又白改了，所以可以用这种简单粗暴的方法：直接让第三方库的警告不显示</p>

<p> 就是在podfile文件里面加上一行指令 。
inhibit_all_warnings!
如果某警告实在无法消除，但是又不想让他显示，可以加入预编译指令</p>

<p>比如我已经知道某行会报上面警告了，我就用这个宏把这几行包住，就不会报引号中-Wunused-variable的警告了</p>

<pre><code>#pragma clang diagnostic push
#pragma clang diagnostic ignored"-Wunused-variable" //这里是会报警告的代码

#pragma clang diagnostic pop
</code></pre>

<p>这个-Wunused-variable代表的意思就是 有的东西 你实例化了但是没有使用（同上面第几条）。 但是如何得到一个警告的标示符？</p>

<ol>
<li><p>如图选择一个警告，点击右键，reveal in log  就能看到右边有个方括号[]里面的东西就是 这个警告对应的标示符</p></li>
<li><p>如果希望整个项目中都忽略 某种很无聊的警告，就在项目中Build Setting里加上这个标示符，可以连着加的。</p></li>
<li><p>如果不想整个项目都忽略，只想个别文件忽略，那就找到个别文件加上此指令，这个操作应该使用率不高（一般都是全项目忽略），就不上图了。去Build Phases 里面的 Compile Sources里面改。</p></li>
</ol>


<h4>二、详细科学的消除警告</h4>

<p>其实笔者本意是想把一些第一眼看不懂比较坑的警告收录进来，但是后来发现那基本没几个需要些写了，所以就采用了全收录的方法，遇到的就记录下以后也会不断更新。 可以直接按command+F 在本页面搜索警告</p>

<pre><code>Unused variable 'replyURL'
</code></pre>

<h6>1.没有使用</h6>

<pre><code>Cannot find protocol definition for 'TencentSessionDelegate'
</code></pre>

<h6>2.这种明明都能运行还说我没有定义的警告，是因为你这个协议虽然定义了，但是你这个协议可能还遵守了XX协议，然后这个XX协议没有定义导致会报这种警告，所以遇到这种警告要往“父协议”找。 举个栗子，上面这行就是腾讯授权的库里面报的警告，</h6>

<pre><code>@protocol TencentSessionDelegate
此协议遵守了TencentApiInterfaceDelegate协议，在TencentOAuth.h类中#import "TencentApiInterface.h" 警告可破


Null passed to a callee that requires a non-null argument
</code></pre>

<h6>3.这个警告比较新，是xcode6.3开始 为了让OC也能有swift的？和！的功能，你在声明一个属性的时候加上 <strong>nullable（？可以为空）与</strong>nonnull（！不能为空） 如果放在@property里面的话不用写下划线</h6>

<pre><code>@property (nonatomic, copy, nonnull) NSString * tickets;
@property (nonatomic, copy) NSString * __nonnull tickets;
</code></pre>

<p>或者用宏NS_ASSUME_NONNULL_BEGIN和NS_ASSUME_NONNULL_END 包住多个属性全部具备nonnull，然后仅对需要nullable的改下就行，有点类似于f-no-objc-arc那种先整体给个路线在单独改个别文件的思想。 此警告就是某属性说好的不能为空，你又在某地方写了XX = nil 所以冲突了。</p>

<pre><code>Auto property synthesis will not synthesize property 'privateCacheDirectory'; it will be implemented by its superclass, use @dynamic to acknowledge intention
</code></pre>

<h6>4.他说你的父类实现了setget方法，但是如果你什么都不写，就会系统自动生成出最一般的setget方法，请用@dynamic 来承认父类实现的这个getset方法。</h6>

<pre><code>Unsupported Configuration: Scene is unreachable due to lack of entry points and does not have an identifier for runtime access via -instantiateViewControllerWithIdentifier:.
</code></pre>

<h6>5.一般是storyboard报的警告，简而言之就是你有的页面没有和箭头所指的控制器连起来，导致最终改页面可能无法显示。</h6>

<pre><code>Deprecated: Push segues are deprecated in iOS 8.0 and later
</code></pre>

<h6>6.iOS8之后呢，不要再用push拖线了，统一用show，他会自己根据你是否有导航栏来判断走push还是走modal</h6>

<pre><code>Unsupported Configuration: Plain Style unsupported in a Navigation Item
</code></pre>

<h6>7.导航栏的item 不支持用plain ，那就用Bordered呗。</h6>

<pre><code>The launch image set "LaunchImage" has 2 unassigned images.
The app icon set "AppIcon" has 2 unassigned images.
</code></pre>

<h6>8.几张图标还是启动图找不到自己的位置，可能是一次导入了全部尺寸图片，但是右边的设置只勾了iOS8的 那iOS7尺寸的图标就会报此警告。删掉，或者对照右边匹配。</h6>

<pre><code>'sizeWithFont:constrainedToSize:lineBreakMode:' is deprecated: first deprecated in iOS 7.0 - Use -boundingRectWithSize:options:attributes:context:
</code></pre>

<h6>9.方法废除，旧的方法sizeWithFontToSize在iOS7后就废除了取而代之是boundingRectWithSize方法</h6>

<pre><code>Undeclared selector 'historyAction'
</code></pre>

<h6>10.使用未声明的方法，一般出现在@selector() 括号里写了个不存在的方法或方法名写错了。</h6>

<pre><code>PerformSelector may cause a leak because its selector is unknown
</code></pre>

<h6>11.这个和上面类似就是直接把上面那个@SEL拿来用会报这个警告</h6>

<pre><code>'strongify' macro redefined
</code></pre>

<h6>12.这个宏声明重复,删一个吧</h6>

<pre><code>'UITextAttributeFont' is deprecated: first deprecated in iOS 7.0 - Use NSFontAttributeName
'UITextAttributeTextColor' is deprecated: first deprecated in iOS 7.0 - Use NSForegroundColorAttributeName
'UITextAttributeTextShadowColor' is deprecated: first deprecated in iOS 7.0 - Use NSShadowAttributeName with an NSShadow instance as the value
</code></pre>

<h6>13.方法废除,一般一起出现</h6>

<pre><code>Code will never be executed
</code></pre>

<h6>14.他说这代码永远也轮不到他执行，估计是有几行代码写在了return之后</h6>

<pre><code>Assigning to 'id' from incompatible type 'SXTabViewController *const __strong'
</code></pre>

<h6>15.一般出现在xxx.delegate = self ，应该在上面遵守协议</h6>

<pre><code>Format specifies type 'unsigned long' but the argument has type 'unsigned int'
</code></pre>

<h6>16.这个警告一般会出现在NSStringWithFormat里面 前面%d %lu 什么的和后面填进去的参数不匹配就报了警告</h6>

<pre><code>Values of type 'NSInteger' should not be used as format arguments; add an explicit cast to 'long' instead
</code></pre>

<h6>17.类似于上面，也是format里面前后写的不匹配</h6>

<pre><code>Method 'dealWithURL:andTitle:andKeyword:' in protocol 'SXPostAdDelegate' not implemented
</code></pre>

<h6>18.经典警告，遵守了协议，但是没有实现协议方法。 也可能你实现了只是又加了个参数或是你写的方法和协议方法名字有点轻微不同</h6>

<pre><code>Using integer absolute value function 'abs' when argument is of floating point type
</code></pre>

<h6>19.这个可以自动修正，就是说abs适用于整数绝对值，要是float取绝对值要用fabsf</h6>

<pre><code>Attribute Unavailable: Automatic Preferred Max Layout Width is not available on iOS versions prior to 8.0
</code></pre>

<h6>20.有的方法你用的太落后了，也有的方法你用的太超前了。 说这个最大宽度在iOS8之前的系统是要坑的</h6>

<pre><code>Too many personality routines for compact unwind to encode
</code></pre>

<h6>21.你可以在otherlink 中加入 -Wl,-no_compact_unwind 去掉该警告，根据苹果的解释，这个是由于某些地方 c/c++/oc/oc++混用会造成编译警告。一般没有什么伤害。</h6>

<pre><code>Property 'ssid' requires method 'ssid' to be defined - use @synthesize, @dynamic or provide a method implementation in this class implementation
</code></pre>

<h6>22.说这个ssid必须要定义个这个属性的getter方法，如果警告是setSsid就是setter方法， 用@synthesize和@dynamic 都行，一个是让编译器生成getter和setter，一个是自己生成，如果你有模型分发或kvc之类的，选@dynamic就行</h6>

<pre><code>Unknown escape sequence '\)'
</code></pre>

<h6>23.未知的转义序列。 一般有个斜杠再加个东西他都会以为是转义字符，一看\）不认识就报警告了，一般正则表达式容易报这种警告</h6>

<pre><code>Property 'LoginPort' not found on object of type 'LoginLvsTestTask *'; did you mean to access property loginPort?
</code></pre>

<h6>24.这种可以点击自动修复，是典型的大小写写错了，他提醒了一下。</h6>

<pre><code>Variable 'type' is used uninitialized whenever switch default is taken
</code></pre>

<h6>25.这是出现在switch语句中的警告， 一般可能是switch外面定义了个type但是并没有初始化（初始化操作都写在switch的各个分支里），然后在最后return type。 但是switch的有个分支没有对type初始化，他说如果你来到这个分支的话，那还没初始化就要被return。</h6>

<h5>三、添加警告</h5>

<h6>1.首先最常用的就是 普通警告，这也没什么好说的了</h6>

<pre><code>#warning TODO
</code></pre>

<h6>2.如果是自己写的文件或第三方库，有了新的接口，然后提示旧的接口废除的话需要在方法后加上宏NS_DEPRECATED_IOS和范围</h6>

<pre><code>- (void)addTapAction:(SEL)tapAction target:(id)target NS_DEPRECATED_IOS(2_0, 4_0);
</code></pre>

<h6>3.如果需要在此方法后加上带信息的警告则需要这么写</h6>

<pre><code>- (void)addTapAction:(SEL)tapAction target:(id)target __attribute((deprecated("这个接口会爆内存 不建议使用")));
</code></pre>

<p>显示的效果像这样：</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[全屏返回（Runtime）]]></title>
    <link href="http://al1020119.github.io/blog/2015/12/02/quan-ping-fan-hui-(runtime)/"/>
    <updated>2015-12-02T02:51:33+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/12/02/quan-ping-fan-hui-(runtime)</id>
    <content type="html"><![CDATA[<blockquote><p>前言</p>

<p>此次文章，讲述的是导航控制器全屏滑动返回效果，而且代码量非常少，10行内搞定。</p></blockquote>

<p>如果喜欢我的文章，可以关注我，也可以来小码哥，了解下我们的iOS培训课程。陆续还会有更新ing&hellip;.</p>

<h5>一、自定义导航控制器</h5>

<p>目的：以后需要使用全屏滑动返回功能，就使用自己定义的导航控制器。</p>

<h5>二、分析导航控制器侧滑功能</h5>

<p>效果：导航控制器默认自带了侧滑功能，当用户在界面的左边滑动的时候，就会有侧滑功能。</p>

<p>系统自带的侧滑效果：</p>

<p>分析：</p>

<ul>
<li><p>1.导航控制器的view自带了滑动手势，只不过手势的触发范围只能在左边。</p></li>
<li><p>2.当用户在界面左边拖动，就会触发滑动手势方法，并且有滑动返回功能，说明系统手势触发的方法已经实现了滑动返回功能。</p></li>
<li><p>3.为什么说系统手势触发的方法已经实现了滑动返回功能？</p></li>
</ul>


<h3>原因：</h3>

<p>创建滑动手势对象的时候，需要绑定监听者，当触发手势的时候会调用target的action。</p>

<p>UIPanGestureRecognizer *pan = [[UIPanGestureRecognizer alloc] initWithTarget:target action:action];
当用户在界面左边滑动，有滑动返回功能，这是因为触发手势了，调用target的action方法，说明action方法内部实现滑动返回功能，否则就不会有滑动返回效果。</p>

<h5>三、实现全屏滑动功能分析</h5>

<p>打印导航控制器自带的滑动手势，看下它的真实面目。</p>

<p>系统自带的滑动手势interactivePopGestureRecognizer</p>

<pre><code>//  self指向的导航控制器，在导航控制器的viewDidLoad方法打印 
- (void)viewDidLoad { 
    [super viewDidLoad]; 
    NSLog(@"%@",self.interactivePopGestureRecognizer); 
} 
</code></pre>

<p>由图中可知：</p>

<ul>
<li><p>1.系统自带的手势是UIScreenEdgePanGestureRecognizer类型对象,屏幕边缘滑动手势</p></li>
<li><p>2.系统自带手势target是_UINavigationInteractiveTransition类型的对象</p></li>
<li><p>3.target调用的action方法名叫handleNavigationTransition:</p></li>
</ul>


<p>分析：</p>

<p>UIScreenEdgePanGestureRecognizer，看名称就知道，这个手势的范围只能在屏幕的周边，就是因为这个手势，系统自带的滑动效果，只能实现侧边滑动。</p>

<h5>四、如何实现全屏滑动功能</h5>

<p>给自己的导航控制器，添加一个全屏的滑动手势，调用系统自带滑动手势的target的action方法，利用系统实现的滑动返回功能，加上自己全屏滑动手势，就有全屏滑动功能了。</p>

<p>问题：如何拿到系统自带的target对象?，action方法名已经知道，而且系统肯定在target对象实现了，只要拿到target对象，调用这个方法就行。</p>

<p>通过打印系统自带的滑动手势的代理，发现正好是_UINavigationInteractiveTransition对象，因此我猜测这个代理对象就是target对象,只要拿到它，就拿到系统自带滑动手势的target对象。</p>

<pre><code>// 打印系统自带滑动手势的代理对象 
SLog(@"%@",self.interactivePopGestureRecognizer.delegate); 
</code></pre>

<p>导航控制器全屏滑动注意点:</p>

<ul>
<li><p>1.禁止系统自带滑动手势使用。</p></li>
<li><p>2.只有导航控制器的非根控制器才需要触发手势，使用手势代理，控制手势触发。</p></li>
</ul>


<p>全屏滑动代码实现</p>

<pre><code>- (void)viewDidLoad { 
    [super viewDidLoad]; 
    // 获取系统自带滑动手势的target对象 
    id target = self.interactivePopGestureRecognizer.delegate; 
    // 创建全屏滑动手势，调用系统自带滑动手势的target的action方法 
    UIPanGestureRecognizer *pan = [[UIPanGestureRecognizer alloc] initWithTarget:target action:@selector(handleNavigationTransition:)]; 
    // 设置手势代理，拦截手势触发 
    pan.delegate = self; 
    // 给导航控制器的view添加全屏滑动手势 
    [self.view addGestureRecognizer:pan]; 
    // 禁止使用系统自带的滑动手势 
    self.interactivePopGestureRecognizer.enabled = NO; 
} 
// 什么时候调用：每次触发手势之前都会询问下代理，是否触发。 
// 作用：拦截手势触发 
- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer 
{ 
    // 注意：只有非根控制器才有滑动返回功能，根控制器没有。 
    // 判断导航控制器是否只有一个子控制器，如果只有一个子控制器，肯定是根控制器 
    if (self.childViewControllers.count == 1) { 
        // 表示用户在根控制器界面，就不需要触发滑动手势， 
        return NO; 
    } 
    return YES; 
} 
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[切换控制器]]></title>
    <link href="http://al1020119.github.io/blog/2015/12/02/qie-huan-kong-zhi-qi/"/>
    <updated>2015-12-02T02:51:10+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/12/02/qie-huan-kong-zhi-qi</id>
    <content type="html"><![CDATA[<p>从一个视图控制器切换到另一个视图控制器的几种方式</p>

<h4>1,模态(modal)画面的显示方法：</h4>

<p>例如iphone通讯录管理程序中，追加新的通讯纪录时，就是使用这种模态画面
例：点击一个按钮，进入另一个界面
    - (IBAction)pressAbout:(id)sender {</p>

<pre><code>iCocosViewController *iCocos=[[[iCocosViewController alloc] initWithNibName:@"iCocosViewController" bundle:nil] autorelease];

[self presentModalViewController:aboutanimated:YES];//显示模态画面

关闭模态画面的方法：

[self dissmissModalViewControllerAnimationed:YES];
</code></pre>

<h4>2,SwitchViewController中有2个控制器的属性：BviewController,CViewController</h4>

<ul>
<li>使用方法：insertSubview: atIndex:
这种画面跳转方法并非最佳的跳转方法：</li>
<li>实际上并非真的实现了两个画面间的跳转，而是同时启动了2个画面，控制其中哪一个画面显示在前台，哪一个画面显示在后台而已。</li>
<li>这种画面跳转方式有一个很大的缺点，即当画面数量增加时，画面跳转的实现代码将月来越复杂，而且各个画面间不可避免的有相互依赖关系。</li>
</ul>


<h4>3,UITabBarController实现并列画面跳转（这里其实就是window的切花）</h4>

<pre><code>//将5个viewController实例放入TabBar的viewcontrollers属性中    

self.tabBarController.viewControllers = @[navFrist, navSecond,navThird,navFourth,navFifth];   

self.window.rootViewController = self.tabBarController;

[self.window addSubview:self.tabBarController.view];//将根控制器的视图加到应用程序主窗口
</code></pre>

<h4>4,UINavigationController实现多层画面跳转，在导航控制器中，载入有层级关系的界面</h4>

<pre><code>- (IBAction)addRightAction:(id)sender
{
    iCocosViewController *iCocos=[[[iCocosViewController alloc]initWithNibName:@"iCocosViewController" bundle:nil] autorelease];

[self.navigationController pushViewController:aiCocos animated:YES];
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[字典转模型深究]]></title>
    <link href="http://al1020119.github.io/blog/2015/12/01/zi-dian-zhuan-mo-xing-shen-jiu/"/>
    <updated>2015-12-01T02:33:18+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/12/01/zi-dian-zhuan-mo-xing-shen-jiu</id>
    <content type="html"><![CDATA[<blockquote><p>引言：
在文字开始之前先介绍两个软件：</p></blockquote>

<h5>JSONExport</h5>

<p><img src="http://al1020119.github.io/images/zidianzhuanmoxin005.png" title="Caption" ></p>

<h5>JSON Accelerator</h5>

<p><img src="http://al1020119.github.io/images/zidianzhuanmoxin006.png" title="Caption" ></p>

<blockquote><p>关于模型类的两个神器，我也是刚接触不久，但是感觉非常有用，基本上可以节省你在模型类上的99%的时间。</p></blockquote>

<ul>
<li>如果你觉得自己对应本文后面的内容非常了解，那么请直接下载上面的软件试试。</li>
<li>如果你并不是很熟练，那么轻认真看完后面的内容，相信对你有好处，再去下载对应的软件。</li>
</ul>


<p>关于Plist转模型在iOS开发中是非常常见的，每开一一个项目或者实现一个功能都要用到它，所以今天就给大家讲讲Plist怎么转成模型数据，</p>

<blockquote><p>前提：必须有一个Plist文件或者通过一定的方式返回的plist数据</p></blockquote>

<h2>一：直接加载Plist数据</h2>

<p><img src="http://al1020119.github.io/images/zidianzhuanmoxin001.png" title="Caption" ></p>

<pre><code>定义一个数组属性 
@property (nonatomic, assign) NSArray *apps; 
</code></pre>

<h6>获取Plist文件</h6>

<pre><code>//懒加载plist文件，返回一个apps数据，后面直接使用旧可以
-(NSArray *)apps
{
    if (_apps == nil) {
        _apps = [NSArray arrayWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@"iCocos.plist" ofType:nil]];
    }
    return _apps;
}
</code></pre>

<h6>加载Plsit中的数据</h6>

<pre><code>    //取出数组中对应的数据放到一个字典里面
    NSDictionary *dic = self.apps[i];


    //创建一个UIImageView
    UIImageView *icon = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, iW, 50)];
    /**
     取出字典中的icon
    */
     icon.image = [UIImage imageNamed:dic[@"icon"]];

    [view addSubview:icon];



    //创建一个Label
    UILabel *l = [[UILabel alloc] initWithFrame:CGRectMake(0, CGRectGetMaxY(icon.frame), iW, 20)];
    /**
     取出字典中的label
     */
    l.text = dic[@"label"];

    [view addSubview:l];



    //创建一个按钮
    UIButton *btn = [[UIButton alloc] initWithFrame:CGRectMake(0, CGRectGetMaxY(l.frame), iW, 20)];
    /**
     取出字典中的btn
     */
    [btn setTitle:dic[@"btn"] forState:UIControlStateNormal];

    [view addSubview:btn];
</code></pre>

<h2>二：使用简单的模型加载Plist数据</h2>

<p><img src="http://al1020119.github.io/images/zidianzhuanmoxin002.png" title="Caption" ></p>

<pre><code> 1 //定义一个数组属性

  2 @property (nonatomic, assign) NSArray *apps; 
</code></pre>

<h6>在模型中定义模型对应的属性</h6>

<pre><code>@property (nonatomic, copy) NSString *icon;


@property (nonatomic, copy) NSString *label;


@property (nonatomic, copy) NSString *btn;
</code></pre>

<h6>模型方法</h6>

<pre><code>/**
 模型数据方法
 */
+(instancetype)messageWithDict:(NSDictionary *)dict;


-(instancetype)initWithDict:(NSDictionary *)dict;
</code></pre>

<h6>模型的实现文件</h6>

<pre><code>/**
 模型数据方法的实现
 */

+ (instancetype)messageWithDict:(NSDictionary *)dict
{
    return [[self alloc] initWithDict:dict];
}

- (instancetype)initWithDict:(NSDictionary *)dict
{
    if (self = [super init]) {
        [self setValuesForKeysWithDictionary:dict];
    }
    return self;
}
</code></pre>

<h6>实用模型加载Plist文件</h6>

<pre><code>/**
 模型数据的加载，返回arry以后我们就只要使用array就能使用这个模型类里面的数据也就是使用plist数据
 */
//懒加载plist文件，返回一个apps数据，后面直接使用旧可以
-(NSMutableArray *)apps
{
    if (_apps == nil) {
        NSArray *array = [NSArray arrayWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@"iCocos.plist" ofType:nil]];

        NSMutableArray *arrayApps = [NSMutableArray array];

        for (NSDictionary *dic in array) {
            appsModel *model = [[appsModel alloc] init];
            model.label = dic[@"label"];
            model.btn = dic[@"btn"];
            model.icon = dic[@"icon"];

            [arrayApps addObject:model];
        }
        _apps = arrayApps;
    }
    return _apps;
}
</code></pre>

<h6>加载模型中对应的plist数据</h6>

<pre><code>    //取出数组中对应的数据放到一个字典里面
    appsModel *app = self.apps[i];


    //创建一个UIImageView
    UIImageView *icon = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, iW, 50)];
    /**
     取出字典中的icon
     */
    icon.image = [UIImage imageNamed:app.icon];
    [view addSubview:icon];



    //创建一个Label
    UILabel *l = [[UILabel alloc] initWithFrame:CGRectMake(0, CGRectGetMaxY(icon.frame), iW, 20)];
    /**
     取出字典中的label
     */
    l.text = app.label;
    [view addSubview:l];



    //创建一个按钮
    UIButton *btn = [[UIButton alloc] initWithFrame:CGRectMake(0, CGRectGetMaxY(l.frame), iW, 20)];
    /**
     取出字典中的btn
     */
    [btn setTitle:app.btn forState:UIControlStateNormal];
    [view addSubview:btn];
</code></pre>

<h5>注：上面是plist中的属性和模型中定义的属性一一对应的时候的，如果不是一一对应我们就要将模型一个一个的赋值与实现</h5>

<pre><code>- (instancetype)initWithDict:(NSDictionary *)dict
{
self = [super init];
if (self) {
    self.label = dict[@"label"];
    self.btn = dict[@"btn"];
    self.icon = dict[@"icon"];

//[self setValue:dict[@"label"] forKeyPath:@"label"];

    //封装
    [self setValuesForKeysWithDictionary:dict];
}

return self;
}
</code></pre>

<p>/<em>*
 模型数据的加载，返回arry以后我们就只要使用array就能使用这个模型类里面的数据也就是使用plist数据
 </em>/</p>

<pre><code>//懒加载plist文件，返回一个apps数据，后面直接使用旧可以
-(NSMutableArray *)apps
{
    if (_apps == nil) {
        NSArray *array = [NSArray arrayWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@"iCocos.plist" ofType:nil]];

        NSMutableArray *arrayApps = [NSMutableArray array];

        for (NSDictionary *dic in array) {
//            appsModel *model = [[appsModel alloc] initWithDict:dic];
            appsModel *model = [appsModel appsWithDict:dic];

            [arrayApps addObject:model];
        }
        _apps = arrayApps;
    }
    return _apps;
}
</code></pre>

<h6>我们也可以讲加载模型的代码进行封装，这样更加简单的实现模式数据的的使用</h6>

<p>在模型中定义并且实现一个模型封装的方法</p>

<pre><code>+(NSArray *)appList
{
        NSArray *array = [NSArray arrayWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@"iCocos.plist" ofType:nil]];

        NSMutableArray *arrayApps = [NSMutableArray array];

        for (NSDictionary *dic in array) {
            //            appsModel *model = [[appsModel alloc] initWithDict:dic];
            appsModel *model = [appsModel appsWithDict:dic];

            [arrayApps addObject:model];
    }
    return arrayApps;

}
</code></pre>

<h6>实用的时候只要直接使用封装好的模型方法就可以：</h6>

<pre><code>/**
 模型数据的加载，返回arry以后我们就只要使用array就能使用这个模型类里面的数据也就是使用plist数据
 */
//懒加载plist文件，返回一个apps数据，后面直接使用旧可以
-(NSArray *)apps
{
    if (_apps == nil) {

        _apps = [appsModel appList];
    }
    return _apps;
}
</code></pre>

<h2>三：复杂Plist转模型</h2>

<p>有的时候我们会遇到Plist中还有更小一级的节点和属性这个时候我们就需要更复杂的模型来加载，但是实用起来并不复杂</p>

<p>比如Plist中海油一个friends这歌子模型</p>

<p><img src="http://al1020119.github.io/images/zidianzhuanmoxin003.png" title="Caption" ></p>

<h6>那么我转模型的时候就可以根据plist中的数据进行处理，</h6>

<h6>首先我们一一般都是从子模型开始，我们就先定义子模型</h6>

<pre><code>/**
 根据plist里面存在的子列中的数据再创建一个模型数据
 */

/**
 设置子模型数据的属性
 */

@property (nonatomic, assign) NSString *icon;

@property (nonatomic, assign) NSString *intro;

@property (nonatomic, assign) NSString *name;

@property (nonatomic, assign, getter=isVip)BOOL vip;


/**
 子模型数据的方法
 */
+ (instancetype)friendWithDict:(NSDictionary *)dict;

- (instancetype)initWithDict:(NSDictionary *)dict;
</code></pre>

<h6>子模型的实现</h6>

<pre><code>/**
 子模型数据的方法de实现
 */

+ (instancetype)friendWithDict:(NSDictionary *)dict
{
    return [[self alloc] initWithDict:dict];
}

- (instancetype)initWithDict:(NSDictionary *)dict
{
    if (self = [super init]) {
        [self setValuesForKeysWithDictionary:dict];
    }
    return self;
}
</code></pre>

<h6>然后就是根模型</h6>

<pre><code>/**
 根据plist中的数据创建一个模型数据
 */

/**
 设置模型数据的中的属性
 */

@property (nonatomic, assign) NSArray *friends;

@property (nonatomic, copy) NSString *name;

@property (nonatomic, assign) NSNumber *online;

/**
 模型数据的方法
 */

+ (instancetype)groupWithDict:(NSDictionary *)dict;


- (instancetype)initWithDict:(NSDictionary *)dict;
</code></pre>

<h6>根模型的实现，这里只需要在根模型加载需要实现的子模型酒可以</h6>

<pre><code>/**
 模型数据的方法的实现
 */

+ (instancetype)groupWithDict:(NSDictionary *)dict
{
    return [[self alloc] initWithDict:dict];
}

- (instancetype)initWithDict:(NSDictionary *)dict
{
    if (self = [super init]) {
        [self setValuesForKeysWithDictionary:dict];

        NSMutableArray *friendArray = [NSMutableArray array];
        for (NSDictionary *dict in self.friends) {
            FriendsPlistChildren *friend = [FriendsPlistChildren friendWithDict:dict];
            [friendArray addObject:friend];
        }
        self.friends = friendArray;
    }
    return self;
}
</code></pre>

<h6>使用模型数据，方法还是和之前一样的，不需要去处理子模型，因为我们在跟模型里面已经处理好了</h6>

<pre><code>/**
 加载模型数据的方法
 */

- (NSArray *)groups
{
    if (_groups == nil) {
        NSArray *dictArray = [NSArray arrayWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@"friends.plist" ofType:nil]];

        NSMutableArray *groupArray = [NSMutableArray array];
        for (NSDictionary *dict in dictArray) {
            FirendsPlistRoot *group = [FirendsPlistRoot groupWithDict:dict];
            [groupArray addObject:group];
        }

        _groups = groupArray;
    }
    return _groups;
}
</code></pre>

<h2>四：使用第三份库</h2>

<p>在iOS届有一个神人不知道大家知不知道————他叫李明杰，他（MJ）不仅技术牛逼，而且对天朝iOS界的贡献也是无法用语言来形容的，如果你是老一辈的iOS开发者倒是很正常，如果你只是刚开始学习iOS或者学习iOS不久你都不知道或者没有听过这个名字那么就可以说明你真的out了，甚至说你你根本没有用心在学，关于这个神人我就不做多介绍了，如果你想知道更多，请点击www.520it.com</p>

<p>今天我就使用他的一个NB的框架来实现plist转模型数据，这个框架使用起来非常简单，一行代码就可以搞定你想的功能，</p>

<p>首先你需要去github上面下载这个框架：<a href="https://github.com/CoderMJLee/MJExtension">MJExtension</a></p>

<p>下载好了之后直接讲MJExtension拖到你的项目</p>

<p><img src="http://al1020119.github.io/images/zidianzhuanmoxin004.png" title="Caption" ></p>

<h6>首先根据plist数据新建对应的模型数据</h6>

<p>这里我一新浪微博中的小部分做测试</p>

<pre><code>#import "User.h"
#import "Status.h"
#import "StatusResult.h"

/**
 *  微博文本内容
 */
@property (copy, nonatomic) NSString *text;

/**
 *  微博作者
 */
@property (strong, nonatomic) User *user;

/**
 *  转发的微博
 */
@property (strong, nonatomic) Status *retweetedStatus;
/**
 *  存放着某一页微博数据（里面都是Status模型）
 */
@property (strong, nonatomic) NSMutableArray *statuses;

/**
 *  总数
 */
@property (assign, nonatomic) NSNumber *totalNumber;

/**
 *  上一页的游标
 */
@property (assign, nonatomic) long long previousCursor;

/**
 *  下一页的游标
 */
@property (assign, nonatomic) long long nextCursor;
/**
 *  名称
 */
@property (copy, nonatomic) NSString *name;

/**
 *  头像
 */
@property (copy, nonatomic) NSString *icon;
</code></pre>

<h6>下面就是证明去使用这个框架实现你想要的功能了，这里介绍了几乎你开发中需要用到的所有方法和例子，</h6>

<pre><code>/**
 MJ友情提醒：
 1.MJExtension是一套“字典和模型之间互相转换”的轻量级框架
 2.MJExtension能完成的功能
 * 字典 --&gt; 模型
 * 模型 --&gt; 字典
 * 字典数组 --&gt; 模型数组
 * 模型数组 --&gt; 字典数组
 3.具体用法主要参考 main.m中各个函数 以及 "NSObject+MJKeyValue.h"
 4.希望各位大神能用得爽
 */

#import &lt;Foundation/Foundation.h&gt;
#import "MJExtension.h"
#import "User.h"
#import "Status.h"
#import "StatusResult.h"

/**
 *  简单的字典 -&gt; 模型
 */
void keyValues2object()
{
    // 1.定义一个字典
    NSDictionary *dict = @{
                           @"name" : @"Jack",
                           @"icon" : @"lufy.png",
                           };

    // 2.将字典转为User模型
    User *user = [User objectWithKeyValues:dict];

    // 3.打印User模型的属性
    NSLog(@"name=%@, icon=%@", user.name, user.icon);
}

/**
 *  复杂的字典 -&gt; 模型 (模型里面包含了模型)
 */
void keyValues2object2()
{
    // 1.定义一个字典
    NSDictionary *dict = @{
                           @"text" : @"是啊，今天天气确实不错！",

                           @"user" : @{
                                   @"name" : @"Jack",
                                   @"icon" : @"lufy.png"
                                   },

                           @"retweetedStatus" : @{
                                   @"text" : @"今天天气真不错！",

                                   @"user" : @{
                                           @"name" : @"Rose",
                                           @"icon" : @"nami.png"
                                           }
                                   }
                           };

    // 2.将字典转为Status模型
    Status *status = [Status objectWithKeyValues:dict];

    // 3.打印status的属性
    NSString *text = status.text;
    NSString *name = status.user.name;
    NSString *icon = status.user.icon;
    NSLog(@"text=%@, name=%@, icon=%@", text, name, icon);

    // 4.打印status.retweetedStatus的属性
    NSString *text2 = status.retweetedStatus.text;
    NSString *name2 = status.retweetedStatus.user.name;
    NSString *icon2 = status.retweetedStatus.user.icon;
    NSLog(@"text2=%@, name2=%@, icon2=%@", text2, name2, icon2);
}

/**
 *  复杂的字典 -&gt; 模型 (模型的数组属性里面又装着模型)
 */
void keyValues2object3()
{
    // 1.定义一个字典
    NSDictionary *dict = @{
                           @"statuses" : @[
                                   @{
                                       @"text" : @"今天天气真不错！",

                                       @"user" : @{
                                               @"name" : @"Rose",
                                               @"icon" : @"nami.png"
                                               }
                                       },

                                   @{
                                       @"text" : @"明天去旅游了",

                                       @"user" : @{
                                               @"name" : @"Jack",
                                               @"icon" : @"lufy.png"
                                               }
                                       },

                                   @{
                                       @"text" : @"嘿嘿，这东西不错哦！",

                                       @"user" : @{
                                               @"name" : @"Jim",
                                               @"icon" : @"zero.png"
                                               }
                                       }

                                   ],

                           @"totalNumber" : @"2014",

                           @"previousCursor" : @"13476589",

                           @"nextCursor" : @"13476599"
                           };

    // 2.将字典转为StatusResult模型
    StatusResult *result = [StatusResult objectWithKeyValues:dict];

    // 3.打印StatusResult模型的简单属性
    NSLog(@"totalNumber=%d, previousCursor=%lld, nextCursor=%lld", result.totalNumber, result.previousCursor, result.nextCursor);

    // 4.打印statuses数组中的模型属性
    for (Status *status in result.statuses) {
        NSString *text = status.text;
        NSString *name = status.user.name;
        NSString *icon = status.user.icon;
        NSLog(@"text=%@, name=%@, icon=%@", text, name, icon);
    }
}

/**
 *  字典数组 -&gt; 模型数组
 */
void keyValuesArray2objectArray()
{
    // 1.定义一个字典数组
    NSArray *dictArray = @[
                           @{
                               @"name" : @"Jack",
                               @"icon" : @"lufy.png",
                               },

                           @{
                               @"name" : @"Rose",
                               @"icon" : @"nami.png",
                               },

                           @{
                               @"name" : @"Jim",
                               @"icon" : @"zero.png",
                               }
                           ];

    // 2.将字典数组转为User模型数组
    NSArray *userArray = [User objectArrayWithKeyValuesArray:dictArray];

    // 3.打印userArray数组中的User模型属性
    for (User *user in userArray) {
        NSLog(@"name=%@, icon=%@", user.name, user.icon);
    }
}

/**
 *  模型 -&gt; 字典
 */
void object2keyValues()
{
    // 1.新建模型
    User *user = [[User alloc] init];
    user.name = @"Jack";
    user.icon = @"lufy.png";

    Status *status = [[Status alloc] init];
    status.user = user;
    status.text = @"今天的心情不错！";

    // 2.将模型转为字典
    //    NSDictionary *dict = [status keyValues];
    NSDictionary *dict = status.keyValues;
    NSLog(@"%@", dict);
}

/**
 *  模型数组 -&gt; 字典数组
 */
void objectArray2keyValuesArray()
{
    // 1.新建模型数组
    User *user1 = [[User alloc] init];
    user1.name = @"Jack";
    user1.icon = @"lufy.png";

    User *user2 = [[User alloc] init];
    user2.name = @"Rose";
    user2.icon = @"nami.png";

    User *user3 = [[User alloc] init];
    user3.name = @"Jim";
    user3.icon = @"zero.png";

    NSArray *userArray = @[user1, user2, user3];

    // 2.将模型数组转为字典数组
    NSArray *dictArray = [User keyValuesArrayWithObjectArray:userArray];
    NSLog(@"%@", dictArray);
}

int main(int argc, const char * argv[])
{
    @autoreleasepool {
        // 简单的字典 -&gt; 模型
        keyValues2object();

        // 复杂的字典 -&gt; 模型 (模型里面包含了模型)
        keyValues2object2();

        // 复杂的字典 -&gt; 模型 (模型的数组属性里面又装着模型)
        keyValues2object3();

        // 字典数组 -&gt; 模型数组
        keyValuesArray2objectArray();

        // 模型转字典
        object2keyValues();

        // 模型数组 -&gt; 字典数组
        objectArray2keyValuesArray();
    }
    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ScrollView回到顶部复原]]></title>
    <link href="http://al1020119.github.io/blog/2015/12/01/scrollviewhui-dao-ding-bu-fu-yuan/"/>
    <updated>2015-12-01T02:33:00+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/12/01/scrollviewhui-dao-ding-bu-fu-yuan</id>
    <content type="html"><![CDATA[<p>相信细心的开发者都会发现scrollView自带一个功能,当用户点击顶部的状态栏时,scrollView的ContentOffset.y轴会自动滚动到初始位置,效果如图所示:</p>

<blockquote><p>单个scrollView单击顶部状态栏系统自带功能展示</p></blockquote>

<p>这个功能对用户来说非常实用,尤其是在scrollView(TableView, WebView, CollectionView一切继承scrollView的控件)展示的内容很多,当用户翻看很久以后,想回到最顶部时,只需单击一下顶部的状态栏位置就可以轻松返回到顶部(这里吐槽下.貌似很多用户都不知道有这个功能),而不用使劲用手滑动到顶部.</p>

<ul>
<li>可是功能在当前控制器有多个scrollView(TableView, WebView, CollectionView一切继承scrollView的控件)的时候就会失效,效果如下图所示:</li>
</ul>


<p>当控制器内有多个scrollView时,系统自带的滚动到顶的功能就会失效</p>

<p>实际开发中,我们的产品在同一个控制器经常会有多个scrollView组合在一起的情况,这就意味着系统的方法已经失效了,需要开发人员自己来实现这个效果,下面我们就来搞定这个需求</p>

<blockquote><p>我们分析下原生的方法为什么会失效,当一个控制器内只有一个scrollView时,点击状态栏,系统会遍历当前keyWindow的子控件,发现子控件中只有一个scrollView会调用这个scrollView的setContentOffset: animated:的这个方法,将scrollView的contentOffset.y值修改为初始值,但是当子控件中又多个scrollView时,系统会不知道掉用哪一个scrollView而失效,知道这点我们就知道该如何搞定这个问题了</p></blockquote>

<p>这里就直接将解决思路一一写出来不将代码分段展示了,在代码中我加了详细的注释objective-c的套路和swift基本一样,在最后会将Swift和objective-c的代码一起放上,如果需要直接解决问题的童鞋可以直接将代码拷贝到工程里即可</p>

<ul>
<li>首先创建一个topWindow继承至NSObject,这里我们考虑将这个功能完全封装起来,所以所有的方法都用的类方法,所以用最基本的类就可以</li>
<li>在initialize方法中初始化topWIndow,将topWIndow的级别改成最高的UIWindowLevelAlert级别,设置topWindow位置,并且添加点击手势</li>
<li>在topWIndow被点击调用的方法中,我们拿出UIApplication的keyWindow,遍历keyWindow的所有子控件,如果满足是scrollView同时又显示在当前keyWindow条件时,将subView的contentOffset的y值回复到原始</li>
<li>然后采用递归的套路在遍历subView内时候有满足条件的子控件,直到没有满足条件时会停止</li>
</ul>


<h4>Swift的代码</h4>

<pre><code>import UIKit
class TopWindow: UIWindow {
    private static let window_: UIWindow = UIWindow()
    ///  类初始化方法,保证window_只被创建一次
    override class func initialize() {
        window_.frame = CGRectMake(0, 0, global.appWidth, 20)
        window_.windowLevel = UIWindowLevelAlert
        window_.addGestureRecognizer(UITapGestureRecognizer(target: self, action: "topWindowClick"))
    }
    class func topWindowClick() {
        // 遍历当前主窗口所有view,将满足条件的scrollView滚动回原位
        searchAllowScrollViewInView(UIApplication.sharedApplication().keyWindow!)
    }
    private class func searchAllowScrollViewInView(superView: UIView) {
        for subview: UIView in superView.subviews as! [UIView] {
            if subview.isKindOfClass(UIScrollView.self) &amp;&amp; superView.viewIsInKeyWindow() {
                // 拿到scrollView的contentOffset
                var offest = (subview as! UIScrollView).contentOffset
                // 将offest的y轴还原成最开始的值
                offest.y = -(subview as! UIScrollView).contentInset.top
                // 重新设置scrollView的内容
                (subview as! UIScrollView).setContentOffset(offest, animated: true)
            }
            // 递归,让子控件再次调用这个方法判断时候还有满足条件的view
            searchAllowScrollViewInView(subview)
        }
    }
    ///  添加topWindow,使手势生效
    class func showTopWindow() {
        window_.hidden = false
    }
    ///  隐藏topWindow,移除手势
    class func hiddenTopWindow() {
        window_.hidden = true
    }
}
///  对UIView的一个扩展
extension UIView {
    ///  判断调用方法的view是否在keyWindow中
    func viewIsInKeyWindow() -&gt; Bool {
        let keyWindow = UIApplication.sharedApplication().keyWindow!
        // 将当前view的坐标系转换到window.bounds
        let viewNewFrame = keyWindow.convertRect(self.frame, fromView: self.superview)
        let keyWindowBounds = keyWindow.bounds
        // 判断当前view是否在keyWindow的范围内
        let isIntersects = CGRectIntersectsRect(viewNewFrame, keyWindowBounds)
        // 判断是否满足所有条件
        return !self.hidden &amp;&amp; self.alpha &gt; 0.01 &amp;&amp; self.window == keyWindow &amp;&amp; isIntersects
    }   
}
</code></pre>

<p>在AppDelegate里,程序启动完成方法时添加就OK了</p>

<pre><code>  func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -&gt; Bool {
      // 添加顶部的window
      TopWindow.showTopWindow()
      return true
  }
</code></pre>

<p>需要注意添加了自定义的window后,控制器的改变状态栏状态方法会失效,可以在info.plist中将改变状态栏的管理权交给UIApplication解决,或者在需要改变状态栏的控制器中调用TopWindow.hiddenTopWindow()即可,或者直接改info.plist,用UIApplication.sharedApplication().setStatusBarStyle来管理</p>

<h4>Objective-C代码</h4>

<p>.h文件只暴露显示和隐藏方法</p>

<pre><code>#import @interface WNXTopWindow : NSObject
+ (void)show;
+ (void)hide;
@end
</code></pre>

<p>.m文件</p>

<pre><code>#import "WNXTopWindow.h"
@implementation WNXTopWindow
static UIWindow *window_;
//初始化window
+ (void)initialize {
  window_ = [[UIWindow alloc] init];
  window_.frame = CGRectMake(0, 0, [UIScreen mainScreen].bounds.size.width, 20);
  window_.windowLevel = UIWindowLevelAlert;
  [window_ addGestureRecognizer:[[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(windowClick)]];
}  
+ (void)show {
  window_.hidden = NO;
}
+ (void)hide {
  window_.hidden = YES;
}
// 监听窗口点击
+ (void)windowClick {
  UIWindow *window = [UIApplication sharedApplication].keyWindow;
  [self searchScrollViewInView:window];
}
+ (void)searchScrollViewInView:(UIView *)superview {
  for (UIScrollView *subview in superview.subviews) {
      // 如果是scrollview, 滚动最顶部
      if ([subview isKindOfClass:[UIScrollView class]] &amp;&amp; [subview isShowingOnKeyWindow]) {
          CGPoint offset = subview.contentOffset;
          offset.y = - subview.contentInset.top;
          [subview setContentOffset:offset animated:YES];
      }
      // 递归继续查找子控件
      [self searchScrollViewInView:subview];
  }
}
+ (BOOL)isShowingOnKeyWindow:(UIView *)view {
  // 主窗口
  UIWindow *keyWindow = [UIApplication sharedApplication].keyWindow;
  // 以主窗口左上角为坐标原点, 计算self的矩形框
  CGRect newFrame = [keyWindow convertRect:view.frame fromView:view.superview];
  CGRect winBounds = keyWindow.bounds;
  // 主窗口的bounds 和 self的矩形框 是否有重叠
  BOOL intersects = CGRectIntersectsRect(newFrame, winBounds);
  return !view.isHidden &amp;&amp; view.alpha &gt; 0.01 &amp;&amp; view.window == keyWindow &amp;&amp; intersects;
}
@end
</code></pre>

<p>同样,也是在程序初始化完成AppDelegate文件中显示topWindow,整个工程这个问题就统统解决了</p>

<pre><code>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
  // 添加一个window, 点击这个window, 可以让屏幕上的scrollView滚到最顶部
  [WNXTopWindow show];
  return YES;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[传值方式总结]]></title>
    <link href="http://al1020119.github.io/blog/2015/12/01/chuan-zhi-fang-shi-zong-jie/"/>
    <updated>2015-12-01T02:32:36+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/12/01/chuan-zhi-fang-shi-zong-jie</id>
    <content type="html"><![CDATA[<ul>
<li>简单总结

<ul>
<li>代理</li>
<li>Block</li>
<li>通知</li>
</ul>
</li>
</ul>


<hr />

<ul>
<li>简单实用

<ul>
<li>代理</li>
<li>Block</li>
<li>通知</li>
</ul>
</li>
</ul>


<p>虽然这一期的主题是关于Foundation Framework的，不过本文中还介绍了一些超出Foundation Framework(KVO和Notification)范围的一些消息传递机制，另外还介绍了delegation，block和target- action。</p>

<p>大多数情况下，消息传递该使用什么机制，是很明确的了，当然了，在某些情况下该使用什么机制并没有明确的答案，需要你亲自去尝试一下。</p>

<hr />

<h3>简单总结</h3>

<ul>
<li><p>delegation</p>

<ul>
<li><p>在苹果的Framework中，delegation模式被广泛的只用着。delegation允许我们定制某个对象的行为，并且可以收到某些 确定的事件。为了使用delegation模式，消息的发送者需要知道消息的接收者(delegate)，反过来就不用了。这里的发送者和接收者是比较松 耦合的，因为发送者只知道它的delegate是遵循某个特定的协议。</p></li>
<li><p>delegate协议可以定义任意的方法，因此你可以准确的定义出你所需要的类型。你可以用函数参数的形式来处理消息内容，delegate还 可以通过返回值的形式给发送者做出回应。如果只需要在相对接近的两个模块之间进行消息传递，那么Delegation是一种非常灵活和直接方式。</p></li>
<li><p>不过，过渡使用delegation也有一定的风险，如果两个对象的耦合程度比较紧密，相互之间不能独立存在，那么此时就没有必要使用 delegate协议了，针对这种情况，对象之间可以知道相互间的类型，进而直接进行消息传递。例如UICollectionViewLayout和 NSURLSessionConfiguration。</p></li>
</ul>
</li>
<li><p>block</p>

<ul>
<li><p>Block相对来说，是一种比较新的技术，它首次出现是在OS X 10.6和iOS 4中。一般情况下，block可以满足用delegation实现的消息传递机制。不过这两种机制都有各自的需求和优势。</p></li>
<li><p>当不考虑使用block时，一般主要是考虑到block极易引起retain环。如果发送者需要reatain block，而又不能确保这个引用什么时候被nil，这样就会发生潜在的retain环。</p></li>
</ul>
</li>
<li><p>Notification</p>

<ul>
<li><p>在不相关的两部分代码中要想进行消息传递，通知(notifacation)是非常好的一种机制，它可以对消息进行广播。特别是想要传递丰富的信息，并且不一定指望有谁对此消息关心。</p></li>
<li><p>通知可以用来发送任意的消息，甚至包含一个userInfo字典，或者是NSNotifacation的一个子类。通知的独特之处就在于发送者 和接收者双方并不需要相互知道。这样就可以在非常松耦合的模块间进行消息的传递。记住，这种消息传递机制是单向的，作为接收者是不可以回复消息的。</p></li>
</ul>
</li>
</ul>


<hr />

<h3>简单使用</h3>

<p>初始化之后出现下面的界面</p>

<p><img src="http://al1020119.github.io/images/chuanzhi001.png" title="Caption" ></p>

<h5>准备：</h5>

<p>这里试试根据本文的实战做相应的介绍，关于拓展只要理解了这里的思路基本是三种传值的使用没有什么问题。</p>

<p>首先，由于我们要实现的点击对应的组实现展开分组显示对应组里面的所有行。</p>

<p>我这个项目使用的是多层分组模型，讲每一组合对应的属性还有friends作为组模型，再将friends作为子模型，实现表格数据的现实。</p>

<p><img src="http://al1020119.github.io/images/chuanzhi002.png" title="Caption" ></p>

<h6>定义一个BOOL值用来记录点击（由于我们需要实现点击对应组做事情，所以先在组模型中定义一个BOOL）</h6>

<pre><code>@property (nonatomic, assign, getter = isOpen) BOOL open; 
</code></pre>

<h6>在相应的点击方法里面是实现取反点击，这里的点击方法是分组View上面一个按钮的点击事件。</h6>

<pre><code>self.group.open = !self.group.open; 
</code></pre>

<h6>在numberOfRowsInSection中返回的时候使用三木判断是否点击，并且实现伸缩与展开，</h6>

<pre><code>return model.open?model.friends.cout:0; 
</code></pre>

<p>这里完成之后运行程序点一下试试，你会发现。。。。。。。。。。。。。。。。。什么效果也没有。</p>

<p>当然会没有效果，因为我们没有传值，后面才是本章的重点，学会了这里以后关于通知，代理。Block的使用基本上没有问题。</p>

<hr />

<p>/######################代理######################/</p>

<hr />

<h2>方法一：代理</h2>

<h6>在对应的View中创建一个协议</h6>

<pre><code>@class iCocosView



@protocol iCocoDelegate &lt;NSObject&gt;

@optional

-(void)headerView:(iCocosView *)view;



@end
</code></pre>

<h6>创建一个代理属性</h6>

<pre><code> @property (nonatomic, assign) id&lt;iCocoDelegate&gt; delegate; 
</code></pre>

<h6>在这个实现文件中判断有没有实现这个代理方法</h6>

<pre><code>if([self.delegate repondToSelector:selector(headerView)]) {

[self.delegate headerView];

}
</code></pre>

<h6>先在对应的控制器遵守这个协议，并且设置代理</h6>

<pre><code> &lt;iCocosDelegate&gt; 

header.delegate = self; //让控制器充当代理
</code></pre>

<h6>实现代理方法</h6>

<pre><code>－（void）headerView:(iCocosView *)view {[self.tableView reloadData];  }  
</code></pre>

<hr />

<p>/######################Block######################/</p>

<hr />

<h2>方法二：Block</h2>

<h6>定义一个Block</h6>

<pre><code>typedef void (^iCocosBlock)(id);  
</code></pre>

<h6>创建一个Block对应的属性（使用Copy）</h6>

<pre><code> @property （nonatomic， weak）iCocosBlock block; 
</code></pre>

<h6>实现文件中判读</h6>

<pre><code>  if(self.block) { self.block(self);}  
</code></pre>

<h6>在控制器中实现</h6>

<pre><code> header.block = ^(id sender) {  //sender是传过来的参数

 [self.tableView reloadData];

 };
</code></pre>

<hr />

<p>/######################通知######################/</p>

<hr />

<h2>方法三：通知</h2>

<p> 注意：通知的使用是前面的反向思维，在控制器里面注册并且实现通知方法，然后在分组View里面发布这个通知。</p>

<h6>在控制器中注册一个通知</h6>

<pre><code>[［NSNotificationCenter defaultCenter］ addObserver:self selector:@selector(notiClick) name:@“friends” object:nil]; 2 3  
</code></pre>

<h6>实现通知方法</h6>

<pre><code>－（void）notiClick

{

[self.tableView reloadData];

}
</code></pre>

<h6>同样在Header分组的实现文件中发布一个通知</h6>

<pre><code>[［NSNotificationCenter defaultCenter］postNotificationName: @“friends”object:self userInfo:nil]; 2 3  
</code></pre>

<h6>移除通知：我们可以在两个方法里面一出通知：ViewDidDidApper和Dealloc</h6>

<p>并且使用良种两种方法</p>

<p>@1:移除所有通知</p>

<pre><code>[［NSNotificationCenter defaultCenter］ removeObserver:self]; 
</code></pre>

<p>@2:根据名字移除通知</p>

<pre><code>[［NSNotificationCenter defaultCenter］removeObserver:self name:@“friedns” object:nil];  
</code></pre>

<p>这里需要注意：实际开发中使用完通知之后一定要移除通知，否则如果里面通知太多，当你再次发送一个通知的时候程序就不知道去找那个通知甚至会导致程序奔溃。</p>

<hr />

<p>/######################运行结果######################/</p>

<hr />

<p>使用上面任何一种方法都可以实现同样的功能，点击每一行的组的时候就会展开相应行并且显示对应组的所有行。</p>

<p><img src="http://al1020119.github.io/images/chuanzhi003.png" title="Caption" ></p>

<p>实现Header左边按钮上面图标的旋转：（这里是一个重点，也是以后以后开发中肯呢过遇到的一个难点，可能不是一样的但是或许思路和原理一样，这里是这篇文章中除了传值的三种方式以后最重要的地方）
    /<strong><strong><em>在这个方法里面实现旋转：当View移到父控件的时候，不然旋转也看不到选过，因为刷新实在旋转之后的，旋转之后再刷新，从缓存迟里面取出来</em></strong></strong>***/</p>

<pre><code>-(void)didMoveToSuperview
{
    if (self.group.open) {
        self.nameView.imageView.transform = CGAffineTransformMakeRotation(M_PI_2);
    }else {
        self.nameView.imageView.transform = CGAffineTransformMakeRotation(0);
    }

}
/ 
</code></pre>

<p>但是具体使用说明视情况而定：</p>

<p>总结：。。。。。。。。待续</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS生命周期]]></title>
    <link href="http://al1020119.github.io/blog/2015/11/30/iossheng-ming-zhou-qi/"/>
    <updated>2015-11-30T21:52:15+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/11/30/iossheng-ming-zhou-qi</id>
    <content type="html"><![CDATA[<h3>控制器（View）生命周期</h3>

<p>当一个视图控制器被创建，并在屏幕上显示的时候。 代码的执行顺序</p>

<pre><code>1、 alloc                                   创建对象，分配空间
2、init (initWithNibName) 初始化对象，初始化数据
3、loadView                          从nib载入视图 ，通常这一步不需要去干涉。除非你没有使用xib文件创建视图
4、viewDidLoad                   载入完成，可以进行自定义数据以及动态创建其他控件
5、viewWillAppear              视图将出现在屏幕之前，马上这个视图就会被展现在屏幕上了
6、viewDidAppear               视图已在屏幕上渲染完成
</code></pre>

<p>当一个视图被移除屏幕并且销毁的时候的执行顺序，这个顺序差不多和上面的相反</p>

<pre><code>1、viewWillDisappear            视图将被从屏幕上移除之前执行
2、viewDidDisappear             视图已经被从屏幕上移除，用户看不到这个视图了
3、dealloc                                 视图被销毁，此处需要对你在init和viewDidLoad中创建的对象进行释放
</code></pre>

<p>－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－</p>

<h3>app的启动过程</h3>

<pre><code>1.先执行main函数，main内部会调用UIApplicationMain函数

2.UIApplicationMain函数里面做了什么事情：

    1&gt; 创建UIApplication对象
    2&gt; 创建UIApplication的delegate对象—–PYAppDelegate
    3&gt; 开启一个消息循环

每监听到对应的系统事件时，就会通知MJAppDelegate

根据plist文件判断是否需要加载storyBoard
</code></pre>

<p>如果有storyBoard</p>

<pre><code>加载Info.plist文件，读取最主要storyboard文件的名称

加载最主要的storyboard文件，创建白色箭头所指的控制器对象

并且设置创建的控制器为UIWindow的rootViewController属性(根控制器)

初始化对应的子控件
</code></pre>

<p>如果没有storyBoard</p>

<pre><code>在代理的difinishLuaunchWithOPtions中为应用程序创建一个UIWindow对象(继承自UIView)，设置为PYAppDelegate的window属性

并且设置创建的控制器为UIWindow的rootViewController属性(根控制器)

初始化对应的子控件
</code></pre>

<p>－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－</p>

<h3>App的生命周期</h3>

<p>这里只是简单的总结，关于有些方法我们并没有解除过，所以就略过了。</p>

<pre><code> 1、application didFinishLaunchingWithOptions：当应用程序启动时执行，应用程序启动入口，只在应用程序启动时执行一次。若用户直接启动，lauchOptions内无数据,若通过其他方式启动应用，lauchOptions包含对应方式的内容。
 2、applicationWillResignActive：在应用程序将要由活动状态切换到非活动状态时候，要执行的委托调用，如 按下 home 按钮，返回主屏幕，或全屏之间切换应用程序等。

 3、applicationDidEnterBackground：在应用程序已进入后台程序时，要执行的委托调用。

 4、applicationWillEnterForeground：在应用程序将要进入前台时(被激活)，要执行的委托调用，刚好与applicationWillResignActive 方法相对应。

 5、applicationDidBecomeActive：在应用程序已被激活后，要执行的委托调用，刚好与applicationDidEnterBackground 方法相对应。

 6、applicationWillTerminate：在应用程序要完全推出的时候，要执行的委托调用，这个需要要设置UIApplicationExitsOnSuspend的键值。
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[长链接&amp;短链接]]></title>
    <link href="http://al1020119.github.io/blog/2015/11/30/chang-lian-jie-and-duan-lian-jie/"/>
    <updated>2015-11-30T21:30:21+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/11/30/chang-lian-jie-and-duan-lian-jie</id>
    <content type="html"><![CDATA[<ul>
<li>HTTP协议与TCP/IP协议的关系</li>
<li>如何理解HTTP协议是无状态的</li>
<li>什么是长连接、短连接？

<ul>
<li> TCP连接</li>
<li> TCP短连接</li>
<li> TCP长连接</li>
</ul>
</li>
<li>长连接短连接操作过程</li>
<li>长连接和短连接的优点和缺点</li>
<li>什么时候用长连接，短连接？</li>
</ul>


<h3>HTTP协议与TCP/IP协议的关系</h3>

<p>HTTP的长连接和短连接本质上是TCP长连接和短连接。HTTP属于应用层协议，在传输层使用TCP协议，在网络层使用IP协议。IP协议主要解决网络路由和寻址问题，TCP协议主要解决如何在IP层之上可靠的传递数据包，使在网络上的另一端收到发端发出的所有包，并且顺序与发出顺序一致。TCP有可靠，面向连接的特点。</p>

<h3>如何理解HTTP协议是无状态的</h3>

<p>HTTP协议是无状态的，指的是协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。也就是说，打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系。HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接）。</p>

<h3>什么是长连接、短连接？</h3>

<p>在HTTP/1.0中，默认使用的是短连接。也就是说，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。如果客户端浏览器访问的某个HTML或其他类型的 Web页中包含有其他的Web资源，如JavaScript文件、图像文件、CSS文件等；当浏览器每遇到这样一个Web资源，就会建立一个HTTP会话。</p>

<p>但从 HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头有加入这行代码：</p>

<p>Connection:keep-alive</p>

<p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的 TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接要客户端和服务端都支持长连接。</p>

<p>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</p>

<h5>TCP连接</h5>

<p>当网络通信时采用TCP协议时，在真正的读写操作之前，server与client之间必须建立一个连接，当读写操作完成后，双方不再需要这个连接 时它们可以释放这个连接，连接的建立是需要三次握手的，而释放则需要4次握手，所以说每个连接的建立都是需要资源消耗和时间消耗的</p>

<p>经典的三次握手示意图：</p>

<p>经典的四次握手关闭图：</p>

<h5>TCP短连接</h5>

<p>我们模拟一下TCP短连接的情况，client向server发起连接请求，server接到请求，然后双方建立连接。client向server 发送消息，server回应client，然后一次读写就完成了，这时候双方任何一个都可以发起close操作，不过一般都是client先发起 close操作。为什么呢，一般的server不会回复完client后立即关闭连接的，当然不排除有特殊的情况。从上面的描述看，短连接一般只会在 client/server间传递一次读写操作</p>

<p>短连接的优点是：管理起来比较简单，存在的连接都是有用的连接，不需要额外的控制手段</p>

<h5>TCP长连接</h5>

<p>接下来我们再模拟一下长连接的情况，client向server发起连接，server接受client连接，双方建立连接。Client与server完成一次读写之后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。</p>

<p>首先说一下TCP/IP详解上讲到的TCP保活功能，保活功能主要为服务器应用提供，服务器应用希望知道客户主机是否崩溃，从而可以代表客户使用资源。如果客户已经消失，使得服务器上保留一个半开放的连接，而服务器又在等待来自客户端的数据，则服务器将应远等待客户端的数据，保活功能就是试图在服务 器端检测到这种半开放的连接。</p>

<p>如果一个给定的连接在两小时内没有任何的动作，则服务器就向客户发一个探测报文段，客户主机必须处于以下4个状态之一：</p>

<p>客户主机依然正常运行，并从服务器可达。客户的TCP响应正常，而服务器也知道对方是正常的，服务器在两小时后将保活定时器复位。
客户主机已经崩溃，并且关闭或者正在重新启动。在任何一种情况下，客户的TCP都没有响应。服务端将不能收到对探测的响应，并在75秒后超时。服务器总共发送10个这样的探测 ，每个间隔75秒。如果服务器没有收到一个响应，它就认为客户主机已经关闭并终止连接。
客户主机崩溃并已经重新启动。服务器将收到一个对其保活探测的响应，这个响应是一个复位，使得服务器终止这个连接。
客户机正常运行，但是服务器不可达，这种情况与2类似，TCP能发现的就是没有收到探查的响应。</p>

<h5>长连接短连接操作过程</h5>

<p>短连接的操作步骤是：</p>

<p>建立连接——数据传输——关闭连接…建立连接——数据传输——关闭连接</p>

<p>长连接的操作步骤是：</p>

<p>建立连接——数据传输…（保持连接）…数据传输——关闭连接</p>

<h3>长连接和短连接的优点和缺点</h3>

<p>由上可以看出，长连接可以省去较多的TCP建立和关闭的操作，减少浪费，节约时间。对于频繁请求资源的客户来说，较适用长连接。不过这里存在一个问题，存活功能的探测周期太长，还有就是它只是探测TCP连接的存活，属于比较斯文的做法，遇到恶意的连接时，保活功能就不够使了。在长连接的应用场景下，client端一般不会主动关闭它们之间的连接，Client与server之间的连接如果一直不关闭的话，会存在一个问题，随着客户端连接越来越多，server早晚有扛不住的时候，这时候server端需要采取一些策略，如关闭一些长时间没有读写事件发生的连接，这样可 以避免一些恶意连接导致server端服务受损；如果条件再允许就可以以客户端机器为颗粒度，限制每个客户端的最大长连接数，这样可以完全避免某个蛋疼的客户端连累后端服务。</p>

<p>短连接对于服务器来说管理较为简单，存在的连接都是有用的连接，不需要额外的控制手段。但如果客户请求频繁，将在TCP的建立和关闭操作上浪费时间和带宽。</p>

<p>长连接和短连接的产生在于client和server采取的关闭策略，具体的应用场景采用具体的策略，没有十全十美的选择，只有合适的选择。</p>

<h3>什么时候用长连接，短连接？</h3>

<p>长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况，。每个TCP连接都需要三步握手，这需要时间，如果每个操作都是先连接，再操作的话那么处理速度会降低很多，所以每个操作完后都不断开，次处理时直接发送数据包就OK了，不用建立TCP连接。例如：数据库的连接用长连接， 如果用短连接频繁的通信会造成socket错误，而且频繁的socket 创建也是对资源的浪费。</p>

<p>而像WEB网站的http服务一般都用短链接，因为长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以并发量大，但每个用户无需频繁操作情况下需用短连好。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS版本适配问题（6，7，8，9）]]></title>
    <link href="http://al1020119.github.io/blog/2015/11/30/iosban-ben-gua-pei-wen-ti-(6,7,8,9)/"/>
    <updated>2015-11-30T20:52:45+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/11/30/iosban-ben-gua-pei-wen-ti-(6,7,8,9)</id>
    <content type="html"><![CDATA[<h2>iOS6新特性</h2>

<h4>一、关于内存警告</h4>

<p>ios6中废除了viewDidUnload，viewWillUnload这两个系统回调，收到内存警告时在didReceiveMemoryWarning中进行相关的处理。</p>

<pre><code>- (void)viewDidUnload {
    [super viewDidUnload];
    // 处理 ios6 以下的系统内存警告系统回调消息
}

// 这里处理ios6 的内存警告
- (void)didReceiveMemoryWarning {
    [super didReceiveMemoryWarning];

float sysVer = [[[UIDevice currentDevice] systemVersion] floatValue];
//ios6 的特殊处理

if (sysVer &gt;= 6.0f) {
    // 保证 invisible,  因为即使在当前界面也会收到系统回调
    if (self.view.window == nil) {
        //.......
        // 做相关的释放操作
        self.view = nil;   // 确保下次会重新加载
    }
}
}
</code></pre>

<h4>二、关于屏幕旋转</h4>

<p>同样ios6 废除了shouldAutorotateToInterfaceOrientation这个旋转屏幕的设置接口。</p>

<ul>
<li><p>必须在两个新接口中设置旋转属性:shouldAutorotate、supportedInterfaceOrientations。</p></li>
<li><p>收到旋转事件后的处理，同样在willRotateToInterfaceOrientation和didRotateFromInterfaceOrientation中进行。</p></li>
</ul>


<h4>三、UISwitch</h4>

<p>ios6下，新增了以下几个属性，可以设置开关的颜色以及背景图。</p>

<pre><code>@property (nonatomic,  retain) UIColor *tintColor;

@property (nonatomic,  retain) UIColor *thumbTintColor;

@property (nonatomic,  retain) UIImage *onImage;

@property (nonatomic,  retain) UIImage *offImage;
</code></pre>

<h4>四、UINavigationBar</h4>

<p>ios6新增了，设置阴影图片的属性。</p>

<pre><code>@property (nonatomic, retain) UIImage *shadowImage;
</code></pre>

<h4>五、UIImage</h4>

<p>可以在ios6下设置图片的scale比例尺寸了。</p>

<pre><code>+ (UIImage *)imageWithData:(NSData *)data scale:(CGFloat)scale;

- (id)initWithData:(NSData *)data scale:(CGFloat)scale;
</code></pre>

<h4>六、UIRefreshControl</h4>

<p>之前苹果官方是没有现成的下拉刷新的控件，都是自己实现或者使用比较成熟的开源库。</p>

<ul>
<li>ios6苹果加入了UIRefreshControl，配合UITableView直接实现下拉刷新。</li>
</ul>


<h4>七、UICollectionView</h4>

<p>全新的集合控件，应用场景有类似照片墙，瀑布流等。</p>

<h2>iOS7新特性</h2>

<h4>一、已禁用-[UIDevice uniqueIdentifier]</h4>

<p>苹果总是把用户的隐私看的很重要。-[UIDevice uniqueIdentifier]在iOS5实际在iOS5的时候已经被遗弃了，但是iOS7中已经完全的禁用了它。Xcode5甚至不会允许你编译包含了指引到-[UIDevice uniqueIdentifier]的app。</p>

<ul>
<li>此外，iOS7之前的使用了-[UIDevice uniqueIdentifier] 的app如果在iOS7上运行，它不会返回设备的UUID，而是会返回一串字符串，以FFFFFFFF开头，跟着-[UIDevice identifierForVendor]的十六进制值。</li>
</ul>


<h4>二、UIPasteboard由共享变为沙盒化了</h4>

<p>UIPasteboard过去是用来做app之间的数据分享的。UIPasteboard本无问题，但是开发者开始使用它来存储标识符，和其他的相关app分享这些标识符的时候问题就出现了。有一个使用这种把戏的就是OpenUDID。</p>

<ul>
<li>在iOS7中，使用 +[UIPasteboard pasteboardWithName:create:]和 +[UIPasteboard pasteboardWithUniqueName]创建剪贴板，而且只对相同的app group可见，这样就让OpenUDID不那么有用了。</li>
</ul>


<h4>三、MAC地址不能再用来设别设备</h4>

<p>还有一个生成iOS设备唯一标示符的方法是使用iOS设备的Media Access Control（MAC）地址。一个MAC地址是一个唯一的号码，它是物理网络层级方面分配给网络适配器的。这个地址苹果还有其他的名字，比如说是硬件地址（Hardware Address)或是Wifi地址，都是指同样的东西。</p>

<ul>
<li><p>有很多工程和框架都使用这个方法来生成唯一的设备ID。比如说ODIN。然而，苹果并不希望有人通过MAC地址来分辨用户，所以如果你在iOS7系统上查询MAC地址，它现在只会返回02:00:00:00:00:00。</p></li>
<li><p>现在苹果明确的表明你应该使用-[UIDevice identifierForVendor]或是-[ASIdentifierManager advertisingIdentifier]来作为你框架和应用的唯一标示符。坦白的来说，应对这些变化也不是那么的难，见以下代码片段：</p></li>
</ul>


<hr />

<pre><code>NSString *identifierForVendor = [[UIDevice currentDevice].identifierForVendor UUIDString];

NSString *identifierForAdvertising = [[ASIdentifierManager sharedManager].advertisingIdentifier UUIDString];
</code></pre>

<p>每种方法都适配一种特别的用法：</p>

<ul>
<li><p>identifierForVendor对供应商来说是唯一的一个值，也就是说，由同一个公司发行的的app在相同的设备上运行的时候都会有这个相同的标识符。然而，如果用户删除了这个供应商的app然后再重新安装的话，这个标识符就会不一致。</p></li>
<li><p>advertisingIdentifier会返回给在这个设备上所有软件供应商相同的 一个值，所以只能在广告的时候使用。这个值会因为很多情况而有所变化，比如说用户初始化设备的时候便会改变。</p></li>
</ul>


<h4>四、iOS现在要求app如需使用麦克风，需要征得用户同意</h4>

<p>以前如果app需要使用用户的位置，通讯录，日历，提醒以及照片，接受推送消息，使用用户的社交网络的时候需要征得用户的同意。现在在iOS7当中，使用麦克风也需要取得用户同意了。如果用户不允许app使用麦克风的话，那么需要使用麦克风的app就不能接收不到任何声音。</p>

<p>以下的代码是用来查询用户是否允许app使用麦克风：</p>

<pre><code>//第一次调用这个方法的时候，系统会提示用户让他同意你的app获取麦克风的数据
// 其他时候调用方法的时候，则不会提醒用户
// 而会传递之前的值来要求用户同意
[[AVAudioSession sharedInstance] requestRecordPermission:^(BOOL granted) {
    if (granted) {
        // 用户同意获取数据
    } else {
        // 可以显示一个提示框告诉用户这个app没有得到允许？
    }
}];
</code></pre>

<p>你同时还要注意，如果你在获得用户的同意之前使用任何方法来使用麦克风的话，会引起iOS系统弹出以下警示栏：</p>

<p><img src="http://al1020119.github.io/images/banbenshipei001.jpg" title="Caption" ></p>

<h4>五、[NSArray firstObject]的实现</h4>

<p>-[NSArray firstObject]可能是Objective-C中被调用做多的API。在Open Radar上一个简单的调查显示有一些需求苹果已经做了记录。好消息是现在这些需求已经得到了解决。. firstObject的使用可以追溯到iOS4.0，但是那时仅仅是一个私有方法。在iOS7以前，工程师用下面的方式来使用它：</p>

<pre><code>NSArray *arr = @[];
id item = [arr firstObject];

// 在之前你需要做以下工作
id item = [arr count] &gt; 0 ? arr[0] : nil;
</code></pre>

<p>因为上面的方式很平常，有些人将它作为一个类增加到NSArray中，然后创建他们自己的firstObject方法。</p>

<p>这个方法的问题是这个方法的名字必须是唯一的，否则的话这个方法所引发的问题无法预估。</p>

<ul>
<li>请确保检查你是否有任何自定义的代码在NSArray上实现了firstObject，如果有的话看看它是否是必须的，不是必须的话就把它全部移除。</li>
</ul>


<h4>六、增加了instancetype</h4>

<p>instancetype让iOS7API变得更加难懂。苹果改变了大部分 initializer和简易构造函数（convenience constructors），用instancetype代替id作返回类型。但是这个instancetype是什么呢？</p>

<ul>
<li><p>instancetype用来在声明一个方法时告诉编译器其返回类型，它表示返回调用该方法的类的对象。</p></li>
<li><p>这比之前返回id的通常做法要好，编译器可以对返回类型做一些检查，如果出现错误，在编译时就能提醒你，而不是在程序运行时发生崩溃。</p></li>
<li><p>同时，在调用子类方法时，使用它还可以省去对返回值的强制类型转换，编译器能够正确推断方法的返回值类型。</p></li>
<li><p>要说到instancetaype的缺点和优点吗？基本上，在任何可能的情况下都可以使用它。</p></li>
</ul>


<h4>七、设置UIImage的渲染模式：UIImage.renderingMode</h4>

<p>着色（Tint Color）是iOS7界面中的一个重大改变，你可以设置一个UIImage在渲染时是否使用当前视图的Tint Color。</p>

<pre><code>UIImage新增了一个只读属性：renderingMode，对应的还有一个新增方法：*imageWithRenderingMode:，它使用UIImageRenderingMode枚举值来设置图片的renderingMode属性。该枚举中包含下列值：



// 根据图片的使用环境和所处的绘图上下文自动调整渲染模式
UIImageRenderingModeAutomatic 

// 始终绘制图片原始状态，不使用Tint Color
UIImageRenderingModeAlwaysOriginal 

// 始终根据Tint Color绘制图片，忽略图片的颜色信息
UIImageRenderingModeAlwaysTemplate
</code></pre>

<p>renderingMode属性的默认值是UIImageRenderingModeAutomatic，即UIImage是否使用
Tint Color取决于它显示的位置。其他情况可以看下面的图例：</p>

<p><img src="http://al1020119.github.io/images/banbenshipei002.png" title="Caption" ></p>

<p>以下的代码说明了使用一个既定的rendering模式创建图片是多么简单：</p>

<pre><code>UIImage *img = [UIImage imageNamed:@"myimage"];

img = [img imageWithRenderingMode:UIImageRenderingModeAlwaysTemplate];
</code></pre>

<h4>八、tintcolor VS barTintColor</h4>

<p>iOS7中你可以使用一个给定的颜色，甚至是记入颜色主题来给整个app着色，帮助你的app脱颖而出。设置app的tint color很简答，只要使用UIView的新属性tintColor即可。</p>

<p>这个属性是否听上去很熟悉呢？应该很熟悉，有些类，比如说UINaviagtionBar，UISearchBar，UITabBar以及UIToolbar已经有了这么命名的属性。他们现在有了一个新的属性：barTintColor。</p>

<p>为了避免使用新属性的时候犯错误，如果你的appp需要支持iOS6以前的系统的时候，请检查一下。</p>

<pre><code>UINavigationBar *bar = self.navigationController.navigationBar;
UIColor *color = [UIColor greenColor];

if ([bar respondsToSelector:@selector(setBarTintColor:)]) { // iOS 7+
    bar.barTintColor = color;
} else { // what year is this? 2012?
    bar.tintColor = color;
}
</code></pre>

<h4>九、去掉了纹理颜色</h4>

<p><img src="http://al1020119.github.io/images/banbenshipei003.jpg" title="Caption" ></p>

<p>纹理颜色？对，不再使用他们了，不能再创建可以展现纹理的颜色。</p>

<p>根据UIInterface.h文件中的注释，-[UIColor groupTableViewBackgroundColor]应该是要在iOS6当中即被删除了，但是它仅仅只是不像之前那样返回纹理颜色了。然而，以下的颜色在iOS7当中被删除了:</p>

<pre><code>+ (UIColor *)viewFlipsideBackgroundColor;

+ (UIColor *)scrollViewTexturedBackgroundColor;

+ (UIColor *)underPageBackgroundColor;
</code></pre>

<h4>十、UIButtonTypeRoundRect被UIButtonTypeSystem取代了</h4>

<p><img src="http://al1020119.github.io/images/banbenshipei004.jpg" title="Caption" ></p>

<ul>
<li><p>在iOS开发刚开始就陪伴着你的老朋友现在也被删除了，它就是UIButtonTypeRoundRect ，被新的UIButtonTypeSystem取代了。</p></li>
<li><p>如果每次iOS系统的发布都没有一些新的功能会是什么样子？这些新功能相信大部分开发者已经知道了，你可能会发现一些新颖的方式将它们整合到你的app中去！</p></li>
</ul>


<h4>十一、检查无线路由是否可用</h4>

<p>定制一个视频播放器的能力在iOS版本每次的发布中一直有所进步。比如说，在iOS6之前，你不能在MPVolumeView中改变AirPlay的icon。</p>

<p>在iOS7当中，你可以通过AirPlay，蓝牙或是其他的虚线机制了解是否有一个远程的设备可用。了解它的话，就可以让你的app在恰当的时候做恰当的事，比如说，在没有远程设备的时候就不显示AirPlay的icon。</p>

<p>以下是新增加到MPVolumeView的新属性和推送</p>

<pre><code>@property (nonatomic, readonly) BOOL wirelessRoutesAvailable; //  是否有设备可以连接的无线线路？
@property (nonatomic, readonly) BOOL wirelessRouteActive; // 设备现在是否连接上了网络
NSString *const MPVolumeViewWirelessRoutesAvailableDidChangeNotification;
NSString *const MPVolumeViewWirelessRouteActiveDidChangeNotification;
</code></pre>

<h4>十二、了解蜂窝网络</h4>

<p>在iOS7之前，是使用Reachability来检测设备是否连接到WWAN或是Wifi的。iOS7在这个基础上更进了一步，它会告诉你的设备连接上的是那种蜂窝网络，比如说是Edge网络，HSDPA网络，或是LTE网络。告诉用户他们连接上的是哪种网络可以优化用户体验，因为这样他们会知道网速如何，不会去请求需要高网速的网络请求。</p>

<p>这是CTTelephonyNetworkInfo的部分功能，它是CoreTelephony框架的一部分。iOS7还增加了currentRadioAccessTechnology属性和CTRadioAccessTechnologyDidChangeNotification到这个类。还有一些新的字符串常量来定义可能的值，比如说是CTRadioAccessTechnologyLTE。</p>

<p>以下代码告诉你在app delegate中如何使用这个新功能：</p>

<pre><code>@import CoreTelephony.CTTelephonyNetworkInfo; // new modules syntax!
@interface AppDelegate ()
// we need to keep a reference to the CTTelephonyNetworkInfo object, otherwise the notifications won't be fired!
@property (nonatomic, strong) CTTelephonyNetworkInfo *networkInfo;
@end

@implementation ViewController

- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
    // whatever stuff your method does...

    self.networkInfo = [[CTTelephonyNetworkInfo alloc] init];
    NSLog(@"Initial cell connection: %@", self.networkInfo.currentRadioAccessTechnology);
    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(radioAccessChanged) name:
     CTRadioAccessTechnologyDidChangeNotification object:nil];

    // whatever stuff your method does...
}

- (void)radioAccessChanged {
    NSLog(@"Now you're connected via %@", self.networkInfo.currentRadioAccessTechnology);
}

@end
</code></pre>

<h6>##注意：研究一下CTTelephonyNetworkInfo.h 文件来看看是否有其他无线网络类型的的字符串常量。如果设备没有连上的话，currentRadioAccessTechnology 则会返回nil。</h6>

<h4>十三、通过iCloud同步用户设备的密码</h4>

<p>iOS7以及Mavericks增加了iCloud Keychain来提供密码，以及iCloud中一些敏感数据的同步。开发者可以通过keychain中的kSecAttrSynchronizable key来遍历dictionary对象。</p>

<p>由于直接处理keychain比较难，封装库提供了一个简单的处理keychain的方法。SSKeychain封装库可能是最有名的的一个，作为一种福利，现在它支持在iCloud同步。</p>

<p>以下代码片段显示了如何使用SSKeychain：</p>

<pre><code>#import &lt;SSKeychain.h&gt;

- (BOOL)saveCredentials:(NSError **)error {
    SSKeychainQuery *query = [[SSKeychainQuery alloc] init];
    query.password = @"MySecretPassword";
    query.service = @"MyAwesomeService";
    query.account = @"John Doe";
    query.synchronizable = YES;
    return [query save:&amp;error];
}

- (NSString *)savedPassword:(NSError **)error {
    SSKeychainQuery *query = [[SSKeychainQuery alloc] init];
    query.service = @"MyAwesomeService";
    query.account = @"John Doe";
    query.synchronizable = YES;
    query.password = nil;
    if ([query fetch:&amp;error]) {
        return query.password;
    }
    return nil;
}
</code></pre>

<p>不要忘记CocoaPods是快速便捷安装SSKeychian的好方法。</p>

<h4>十四、使用NSAttributedString显示HTML</h4>

<p>在app中使用webview有时会让人非常沮丧，即使只是显示少量的HTMLneirong ,webview也会消耗大量的内存。现在iOS7让这些变得简单了，你可以从用少量代码在HTML文件中创建一个NSAttributedString，比如：</p>

<pre><code>NSString *html = @"&lt;bold&gt;Wow!&lt;/bold&gt; Now &lt;em&gt;iOS&lt;/em&gt; can create &lt;h3&gt;NSAttributedString&lt;/h3&gt; from HTMLs!";
NSDictionary *options = @{NSDocumentTypeDocumentAttribute: NSHTMLTextDocumentType};

NSAttributedString *attrString = [[NSAttributedString alloc] initWithData:[html dataUsingEncoding:NSUTF8StringEncoding] options:options documentAttributes:nil error:nil];
</code></pre>

<p>现在你可以在任意的UIKit对象上使用NSAttributedString 了，比如说是一个UILabel或是一个UITextField。</p>

<p>注意：NSHTMLTextDocumentType 只是NSDocumentTypeDocumentAttribute key一种可能的值。你还可以使用NSPlainTextDocumentType，NSRTFTextDocumentType或是NSRTFDTextDocumentType。</p>

<p>你还可以从NSAttributedString中创建一个HTML字符串，如下：</p>

<pre><code>NSAttributedString *attrString; // from previous code
NSDictionary *options = @{NSDocumentTypeDocumentAttribute: NSHTMLTextDocumentType};

NSData *htmlData = [attrString dataFromRange:NSMakeRange(0, [attrString length]) documentAttributes:options error:nil];
NSString *htmlString = [[NSString alloc] initWithData:htmlData encoding:NSUTF8StringEncoding];
</code></pre>

<p>现在你估计在app中会更多的使用HTML了。</p>

<h4>十五、使用原生的Base64</h4>

<p>Base64是使用ASCII码显示二进制数据的一种流行方法。直到现在，开发者还不得不使用开源的工具来编码解码Base64的内容。</p>

<p>现在iOS7引入了以下四种新的NSData方法来操作Base64编码的数据：</p>

<pre><code>// From NSData.h
- (id)initWithBase64EncodedString:(NSString *)base64String options:(NSDataBase64DecodingOptions)options;

- (NSString *)base64EncodedStringWithOptions:(NSDataBase64EncodingOptions)options;

- (id)initWithBase64EncodedData:(NSData *)base64Data options:(NSDataBase64DecodingOptions)options;

- (NSData *)base64EncodedDataWithOptions:(NSDataBase64EncodingOptions)options;
这些方法可以帮助你轻易的将NSData对象转化为Base64，或者将Base64转化为NSData object。见以下的例子：


NSData* sampleData = [@"Some sample data" dataUsingEncoding:NSUTF8StringEncoding];

NSString * base64String = [sampleData base64EncodedStringWithOptions:0];
NSLog(@"Base64-encoded string is %@", base64String); // prints "U29tZSBzYW1wbGUgZGF0YQ=="

NSData* dataFromString = [[NSData alloc] initWithBase64EncodedString:base64String options:0];
NSLog(@"String is %@",[NSString stringWithUTF8String:[dataFromString bytes]]); // prints "String is Some sample data"
</code></pre>

<p>如果你需要支持iOS6或者更早以前的系统，你可以使用以下两个方法：</p>

<pre><code>/* These methods first appeared in NSData.h on OS X 10.9 and iOS 7.0. They are deprecated in the same releases in favor of
 the methods in the &lt;code&gt;NSDataBase64Encoding&lt;/code&gt; category. However, these methods have existed for several releases, so
 they may be used for applications targeting releases prior to OS X 10.9 and iOS 7.0.
 */
- (id)initWithBase64Encoding:(NSString *)base64String;
- (NSString *)base64Encoding;
</code></pre>

<h4>十六、使用UIApplicationUserDidTakeScreenshotNotification来检查截图</h4>

<p>在iOS7之前，像Snapshot或是Facebook Poke这样的app是使用一些很精巧的方法来检测用户是否有截图。然而，iOS7提供一个崭新的推送方法：UIApplicationUserDidTakeScreenshotNotification。只要像往常一样订阅即可知道什么时候截图了。</p>

<p>注意：UIApplicationUserDidTakeScreenshotNotification 将会在截图完成之后显示。现在在截图截取之前无法得到通知。希望苹果会在iOS8当中增加UIApplicationUserWillTakeScreenshotNotification。</p>

<h4>十七、实现多语言语音合成</h4>

<p>如果可以让app说话会不会很好呢？iOS7加入了两个新类：AVSpeechSynthesizer 以及AVSpeechUtterance。这两个类可以给你的app发声。很有意思不是吗？有多种语言可供选择——Siri不会说的语言也有，比如说巴西葡萄牙语。</p>

<p>使用这两个类给app提供语言合成的功能非常简单。AVSpeechUtterance 代表你想说什么，如何说。AVSpeechSynthesizer 用来发出这些声音，见以下代码片段：</p>

<pre><code>AVSpeechSynthesizer *synthesizer = [[AVSpeechSynthesizer alloc] init];
AVSpeechUtterance *utterance =
[AVSpeechUtterance speechUtteranceWithString:@"Wow, I have such a nice voice!"];
utterance.rate = AVSpeechUtteranceMaximumSpeechRate / 4.0f;
utterance.voice = [AVSpeechSynthesisVoice voiceWithLanguage:@"en-US"]; // defaults to your system language
[synthesizer speakUtterance:utterance];
</code></pre>

<h4>十八、使用了新的UIScreenEdgePanGestureRecognizer</h4>

<p>UIScreenEdgePanGestureRecognizer 继承自UIPanGestureRecognizer ，它可以让你从屏幕边界即可检测手势。</p>

<p>使用新的手势识别器很简单，见以下：</p>

<pre><code>UIScreenEdgePanGestureRecognizer *recognizer = [[UIScreenEdgePanGestureRecognizer alloc] initWithTarget:self action:@selector(handleScreenEdgeRecognizer:)];
recognizer.edges = UIRectEdgeLeft;
</code></pre>

<p>[self.view addGestureRecognizer:recognizer];
十九、使用UIScrollViewKeyboardDismissMode实现了Message app的行为
像Messages app一样在滚动的时候可以让键盘消失是一种非常好的体验。然而，将这种行为整合到你的app很难。幸运的是，苹果给UIScrollView添加了一个很好用的属性keyboardDismissMode，这样可以方便很多。</p>

<p>现在仅仅只需要在Storyboard中改变一个简单的属性，或者增加一行代码，你的app可以和办到和Messages app一样的事情了。</p>

<p>这个属性使用了新的UIScrollViewKeyboardDismissMode enum枚举类型。这个enum枚举类型可能的值如下：</p>

<pre><code>UIScrollViewKeyboardDismissModeNone        // the keyboard is not dismissed automatically when scrolling
UIScrollViewKeyboardDismissModeOnDrag      // dismisses the keyboard when a drag begins
UIScrollViewKeyboardDismissModeInteractive // the keyboard follows the dragging touch off screen, and may be
pulled upward again to cancel the dismiss
</code></pre>

<p>以下是让键盘可以在滚动的时候消失需要设置的属性：</p>

<p><img src="http://al1020119.github.io/images/banbenshipei005.png" title="Caption" ></p>

<h4>二十、使用Core Image来检测眨眼以及微笑</h4>

<p>iOS给Core Image增加了两种人脸检测功能：CIDetectorEyeBlink以及CIDetectorSmile。这也就是说你现在可以在照片中检测微笑以及眨眼。</p>

<p>以下是在app中使用它的方法：</p>

<pre><code>UIImage *image = [UIImage imageNamed:@"myImage"];
CIDetector *detector = [CIDetector detectorOfType:CIDetectorTypeFace
                                          context:nil
                                          options:@{CIDetectorAccuracy: CIDetectorAccuracyHigh}];

NSDictionary *options = @{ CIDetectorSmile: @YES, CIDetectorEyeBlink: @YES };

NSArray *features = [detector featuresInImage:image.CIImage options:options];

for (CIFaceFeature *feature in features) {
    NSLog(@"Bounds: %@", NSStringFromCGRect(feature.bounds));

if (feature.hasSmile) {
    NSLog(@"Nice smile!");
} else {
    NSLog(@"Why so serious?");

if (feature.leftEyeClosed || feature.rightEyeClosed) {
    NSLog(@"Open your eyes!");
}
</code></pre>

<p>}</p>

<h4>二十一、给UITextView增加了链接</h4>

<p>现在在iOS添加你自己的Twitter账户更加简单了，现在你可以给一个NSAttributedString增加链接了，然后当它被点击的时候唤起一个定制的action。</p>

<p>首先，创建一个NSAttributedString然后增加给它增加一个NSLinkAttributeName 属性，见以下：</p>

<pre><code>NSMutableAttributedString *attributedString = [[NSMutableAttributedString alloc] initWithString:@"This is an example by @marcelofabri_"];
[attributedString addAttribute:NSLinkAttributeName
                         value:@"username://marcelofabri_"
                         range:[[attributedString string] rangeOfString:@"@marcelofabri_"]];


NSDictionary *linkAttributes = @{NSForegroundColorAttributeName: [UIColor greenColor],
                                 NSUnderlineColorAttributeName: [UIColor lightGrayColor],
                                 NSUnderlineStyleAttributeName: @(NSUnderlinePatternSolid)};

// assume that textView is a UITextView previously created (either by code or Interface Builder)
textView.linkTextAttributes = linkAttributes; // customizes the appearance of links
textView.attributedText = attributedString;
textView.delegate = self;
</code></pre>

<p>这样就可以让链接在文本中显示。然而，你也可以控制当链接被点击的时候会发生什么，实现这个可以使用UITextViewDelegate协议的新的shouldInteractWithURL方法，就像这样：</p>

<pre><code>- (BOOL)textView:(UITextView *)textView shouldInteractWithURL:(NSURL *)URL inRange:(NSRange)characterRange {
    if ([[URL scheme] isEqualToString:@"username"]) {
        NSString *username = [URL host];
        // do something with this username
        // ...
        return NO;
    }
    return YES; // let the system open this URL
}
</code></pre>

<h2>iOS8新特性</h2>

<h4>一、UIAlertController对alert&amp;actionSheet的封装</h4>

<p>UIAlertController.h</p>

<p>提示框按钮的选择</p>

<pre><code>typedef NS_ENUM(NSInteger, UIAlertActionStyle) {

UIAlertActionStyleDefault = 0,

UIAlertActionStyleCancel,

UIAlertActionStyleDestructive

} NS_ENUM_AVAILABLE_IOS(8_0);
</code></pre>

<p>提示框的样式</p>

<pre><code>typedef NS_ENUM(NSInteger, UIAlertControllerStyle) {

UIAlertControllerStyleActionSheet = 0,

UIAlertControllerStyleAlert

} NS_ENUM_AVAILABLE_IOS(8_0);

NS_CLASS_AVAILABLE_IOS(8_0) @interface UIAlertAction : NSObject &lt;NSCopying&gt;
</code></pre>

<p>创建提示框按钮</p>

<pre><code>+ (instancetype)actionWithTitle:(NSString *)title style:(UIAlertActionStyle)style handler:(void (^)(UIAlertAction *action))handler;

@property (nonatomic, readonly) NSString *title;

@property (nonatomic, readonly) UIAlertActionStyle style;

@property (nonatomic, getter=isEnabled) BOOL enabled;

@end

NS_CLASS_AVAILABLE_IOS(8_0) @interface UIAlertController : UIViewController
</code></pre>

<p>创建提示框</p>

<pre><code>+ (instancetype)alertControllerWithTitle:(NSString *)title message:(NSString *)message preferredStyle:(UIAlertControllerStyle)preferredStyle;
</code></pre>

<p>添加按钮</p>

<pre><code>- (void)addAction:(UIAlertAction *)action;

@property (nonatomic, readonly) NSArray *actions;
</code></pre>

<p>添加文本输入框</p>

<pre><code>- (void)addTextFieldWithConfigurationHandler:(void (^)(UITextField *textField))configurationHandler;

@property (nonatomic, readonly) NSArray *textFields;

@property (nonatomic, copy) NSString *title;

@property (nonatomic, copy) NSString *message;

@property (nonatomic, readonly) UIAlertControllerStyle preferredStyle;
</code></pre>

<p>简单实用示例：</p>

<pre><code>// 1.创建提示框对象，默认是actionSheet效果
UIAlertController *alert = [UIAlertController alertControllerWithTitle:@"注意" message:@"我的呈现方式变了" preferredStyle:UIAlertControllerStyleAlert];

// 2.创建取消按钮并添加到提示框上
[alert addAction:[UIAlertAction actionWithTitle:@"取消" style:UIAlertActionStyleCancel handler:^(UIAlertAction *action) {

    NSLog(@"取消按钮被点击了");
}]];

// 3.呈现提示框
[self presentViewController:alert animated:YES completion:nil];
</code></pre>

<h4>二、UIPopoverController直接通过present方式呈现</h4>

<pre><code>UIViewController.h


typedef NS_ENUM(NSInteger, UIModalPresentationStyle) {

UIModalPresentationFullScreen = 0,

UIModalPresentationPageSheet NS_ENUM_AVAILABLE_IOS(3_2),

UIModalPresentationFormSheet NS_ENUM_AVAILABLE_IOS(3_2),

UIModalPresentationCurrentContext NS_ENUM_AVAILABLE_IOS(3_2),

UIModalPresentationCustom NS_ENUM_AVAILABLE_IOS(7_0),

UIModalPresentationOverFullScreen NS_ENUM_AVAILABLE_IOS(8_0),

UIModalPresentationOverCurrentContext NS_ENUM_AVAILABLE_IOS(8_0),

UIModalPresentationPopover NS_ENUM_AVAILABLE_IOS(8_0),

UIModalPresentationNone NS_ENUM_AVAILABLE_IOS(7_0) = -1,

};

@property (nonatomic,readonly) UIPopoverPresentationController *popoverPresentationController NS_AVAILABLE_IOS(8_0);
</code></pre>

<p>使用示例：</p>

<pre><code>// 1.创建内容控制器
UITableViewController *contentVc = [[UITableViewController alloc] init];

// 2.1 设置呈现方式
contentVc.modalPresentationStyle = UIModalPresentationPopover;

// 2.2设置在导航栏的左边按钮呈现
contentVc.popoverPresentationController.barButtonItem = self.navigationItem.leftBarButtonItem;

// 3.呈现
[self presentViewController:contentVc animated:YES completion:nil];
以前的方式：



// 1.创建内容控制器
UITableViewController *contentVc = [[UITableViewController alloc] init];

// 2.创建popover
UIPopoverController *popover = [[UIPopoverController alloc] initWithContentViewController:contentVc];

popover.popoverContentSize = CGSizeMake(100, 100);

// 3.呈现
[popover presentPopoverFromBarButtonItem:self.navigationItem.leftBarButtonItem permittedArrowDirections:UIPopoverArrowDirectionAny animated:YES];
</code></pre>

<h4>三、获取用户授权的用户隐私保护</h4>

<p>地图定位示例 ：</p>

<pre><code>// 导入定位框架
#import &lt;CoreLocation/CoreLocation.h&gt;

@interface ViewController ()&lt;CLLocationManagerDelegate&gt;

// 设置定位对象
@property(nonatomic,strong)CLLocationManager* maneger;

@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];

    // 当使用iOS8定位的时候需要请求用户授权，且在info.plist里添加字段NSLocationAlwaysUsageDescription 请求用户授权的描述
    // iOS7仅仅需要在info.plist里添加字段Privacy - Location Usage Description 请求用户授权的描述
    // 不需要再写下面的代码
    if (IOS8) {
        [self.maneger requestAlwaysAuthorization];//请求用户授权 
    }

    // 开启定位
    [self.maneger startUpdatingLocation];

}
</code></pre>

<h4>四、针对屏幕适配应运而生的size classes</h4>

<p>size classes是为了解决storyboard只能订制一种屏幕样式的问题，它不再是具体的尺寸，而是抽象尺寸通过宽/高 的compact、any、regular 组成了九种组合包含了所有苹果设备的尺寸。</p>

<h2>iOS9新特性</h2>

<h4>一、网络适配</h4>

<p>iOS9系统发送的网络请求将统一使用TLS 1.2 SSL。采用TLS 1.2 协议，目的是强制增强数据访问安全，而且系统Foundation框架下的相关网络请求，将不再默认使用HTTP等不安全的网络协议，而默认采用TLS 1.2。服务器因此需要更新，以解析相关数据。如不更新，可通过在 info.plist 中声明，倒退回不安全的网络请求。</p>

<p>什么是SSL/TLS？跟HTTP和HTTPS有什么关系？</p>

<p>跟往常一样，先说结论：</p>

<p>HTTP + SSL/TLS + TCP = HTTPS
TLS 是 SSL 新的别称。举个例子：</p>

<p>“TLS1.0”之于“SSL3.1”，犹“公元2015”之于“民国104”，或者是“一千克”之于“一公斤”，或者是“半斤”之于“八两”：称呼不同，但意思相同。</p>

<p>SSL 3.0版本之后的迭代版本被重新命名为TLS 1.0，也就是说：</p>

<p>TLS 1.0 ＝ SSL 3.1
所以他们是一个东西，我们平常也经常简单见到 “SSL/TLS” 这种说法。常用的是下面这些：</p>

<pre><code>SSL 2.0

SSL 3.0

TLS 1.0 (SSL 3.1)

TLS 1.1 (SSL 3.1)

TLS 1.2 (SSL 3.1)
</code></pre>

<p>那为什么标题是“使用HTTPS”而没有提及SSL和TLS什么事？ 要理解这个，要看下一个公式：</p>

<pre><code>HTTP + SSL/TLS + TCP = HTTPS
</code></pre>

<p>打个比方：如果原来的 HTTP 是塑料水管，容易被戳破；那么如今新设计的 HTTPS 就像是在原有的塑料水管之外，再包一层金属水管。一来，原有的塑料水管照样运行；二来，用金属加固了之后，不容易被戳破。</p>

<p>目前，应用最广泛的是TLS 1.0，接下来是SSL 3.0。但是，主流浏览器都已经实现了TLS 1.2的支持。Apple让你的HTTP采用SSL/TLS协议，就是让你从HTTP转到HTTPS。</p>

<p>以前的HTTP不是也能用吗？为什么要用SSL/TLS，闲得慌？！Apple是不是又在反人类？</p>

<p>不使用SSL/TLS的HTTP通信，就是不加密的通信！</p>

<p>所有信息明文传播，带来了三大风险：</p>

<pre><code>窃听风险（eavesdropping）：第三方可以获知通信内容。

篡改风险（tampering）：第三方可以修改通信内容。

冒充风险（pretending）：第三方可以冒充他人身份参与通信。
</code></pre>

<p>SSL/TLS协议是为了解决这三大风险而设计的，希望达到：</p>

<pre><code>所有信息都是加密传播，第三方无法窃听。

具有校验机制，一旦被篡改，通信双方会立刻发现。

配备身份证书，防止身份被冒充。

如何适配？---弱弱地问下：加班要多久？
</code></pre>

<p>正如文章开头所说：</p>

<p>TLS 1.2 协议 强制增强数据访问安全 系统 Foundation 框架下的相关网络请求，将不再默认使用 HTTP 等不安全的网络协议，而默认采用 TLS 1.2。服务器因此需要更新，以解析相关数据。如不更新，可通过在 Info.plist 中声明，倒退回不安全的网络请求。</p>

<ul>
<li><p>方案一：立即让公司的服务端升级使用TLS 1.2。</p></li>
<li><p>方案二：虽Apple不建议，但可通过在 Info.plist 中声明，倒退回不安全的网络请求依然能让App访问指定http，甚至任意的http。</p></li>
</ul>


<p>info.plist 配置中的XML源码如下所示:</p>

<p><img src="http://al1020119.github.io/images/banbenshipei006.jpg" title="Caption" ></p>

<p>上面是比较严谨的做法，指定了能访问哪些特定的HTTP。当然也有暴力的做法： 彻底倒退回不安全的HTTP网络请求，能任意进行HTTP请求，比如你在开发一款浏览器App，或者你想偷懒，或者后台想偷懒，或者公司不给你升级服务器。但目前Apple的官方文档并未提及如何在 info.plist 配置可以参考本文：<a href="http://blog.6ag.cn/1065.html">http://blog.6ag.cn/1065.html</a></p>

<h4>二、更灵活的后台定位</h4>

<p>如果不适配iOS9，就不能偷偷在后台定位。不过苹果将允许出现这种场景：</p>

<p>同一App中的多个location manager，一些只能在前台定位，另一些可在后台定位，并可随时开启或者关闭特定location manager的后台定位。</p>

<p>如何偷偷在后台定位：</p>

<pre><code>// 1. 实例化定位管理器
_locationManager = [[CLLocationManager alloc] init];

// 2. 设置代理
_locationManager.delegate = self;

// 3. 定位精度
[_locationManager setDesiredAccuracy:kCLLocationAccuracyBest];

// 4.请求用户权限：分为：?只在前台开启定位?在后台也可定位，
//注意：建议只请求?和?中的一个，如果两个权限都需要，只请求?即可，
//??这样的顺序，将导致bug：第一次启动程序后，系统将只请求?的权限，?的权限系统不会请求，只会在下一次启动应用时请求?
if ([[[UIDevice currentDevice] systemVersion] floatValue] &gt;= 8) {
    //[_locationManager requestWhenInUseAuthorization];//?只在前台开启定位
    [_locationManager requestAlwaysAuthorization];//?在后台也可定位
}

// 5.iOS9新特性：将允许出现这种场景：同一app中多个location manager：一些只能在前台定位，另一些可在后台定位（并可随时禁止其后台定位）。
if ([[[UIDevice currentDevice] systemVersion] floatValue] &gt;= 9) {
    _locationManager.allowsBackgroundLocationUpdates = YES;
}

// 6. 更新用户位置
[_locationManager startUpdatingLocation];
但是如果照着这种方式尝试，而没有配置info.plist，100%你的程序会崩溃掉，并报错：

*** Assertion failure in -[CLLocationManager setAllowsBackgroundLocationUpdates:], /BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-1808.1.5/Framework/CoreLocation/CLLocationManager.m:593
</code></pre>

<p>要将 info.plist 配置如下：</p>

<p><img src="http://al1020119.github.io/images/banbenshipei007.png" title="Caption" ></p>

<p>对应的 Info.plist 的XML源码是：</p>

<p><img src="http://al1020119.github.io/images/banbenshipei008.jpg" title="Caption" ></p>

<h4>三、Bitcode</h4>

<p>bitcode的理解应该是把程序编译成的一种过渡代码，然后苹果再把这个过渡代码编译成可执行的程序。bitcode也允许苹果在后期重新优化我们程序的二进制文件，有类似于App瘦身的思想。未来Watch应用须包含Bitcode，iOS不强制，但Xcode7默认会开启Bitcode。</p>

<p>用了xcode7的编译器编译之前没问题的项目可能会出现下列报错。</p>

<pre><code>XXXX’ does not contain bitcode. You must rebuild it with bitcode enabled (Xcode setting ENABLE_BITCODE), obtain an updated library from the vendor, or disable bitcode forthistarget. forarchitecture arm64
</code></pre>

<p>问题的原因是：某些第三方库还不支持bitcode。要不然是等待库的开发者升级了此项功能我们更新库，要不就是把这个bitcode禁用。禁用Bitcode，方法见下图：</p>

<p><img src="http://al1020119.github.io/images/banbenshipei009.png" title="Caption" ></p>

<h4>四、企业级分发</h4>

<p>iOS9之前，企业级分发十分方便：点击App出现“信任按钮”。</p>

<p>iOS9以后，企业级分发ipa包将遭到与Mac上dmg安装包一样的待遇。默认不能安装，也不再出现“信任按钮”，必须让用户进行gif图中的设置。</p>

<p><img src="http://al1020119.github.io/images/banbenshipei010.png" title="Caption" ></p>

<h4>五、URL scheme</h4>

<p>URL scheme一般使用的场景是应用程序有分享或跳其他平台授权的功能，分享或授权后再跳回来。在iOS8并没有做过多限制，在iOS9中，如果使用URL scheme必须在"info.plist"中将你要在外部调用的URL scheme列为白名单，否则不能使用。</p>

<pre><code>canOpenURL: failed forURL : "mqzone://qqapp"- error: "This app is not allowed to query for scheme mqzone"
</code></pre>

<p>具体的解决方案也是要在info.plist中设置 LSApplicationQueriesSchemes 类型为数组，下面添加所有你用到的scheme</p>

<p><img src="http://al1020119.github.io/images/banbenshipei011.png" title="Caption" ></p>

<p>推荐一篇博客: <a href="http://awkwardhare.com/post/121196006730/quick-take-on-ios-9-url-scheme-changes">http://awkwardhare.com/post/121196006730/quick-take-on-ios-9-url-scheme-changes</a></p>

<p>其中最关键的是以下部分：</p>

<pre><code>If you call the “canOpenURL” method on a URL that is not in your whitelist, it will return “NO”, even if there is an app installed that has registered to handle this scheme. A “This app is not allowed to query for scheme xxx” syslog entry will appear.

If you call the “openURL” method on a URL that is not in your whitelist, it will fail silently. A “This app is not allowed to query for scheme xxx” syslog entry will appear.
</code></pre>

<h4>六、新字体</h4>

<p>iOS8中，字体是Helvetica，中文的字体有点类似于“华文细黑”。只是苹果手机自带渲染，所以看上去可能比普通的华文细黑要美观。iOS9中，中文系统字体变为了专为中国设计的“苹方” 有点类似于一种word字体“幼圆”。字体有轻微的加粗效果，并且最关键的是字体间隙变大了！</p>

<p>所以很多原本写死了width的label可能会出现“&hellip;”的情况。</p>

<p><img src="http://al1020119.github.io/images/banbenshipei012.png" title="Caption" ></p>

<p><img src="http://al1020119.github.io/images/banbenshipei013.png" title="Caption" ></p>

<p>上面这两张图也可以直观的看出同一个界面，同一个label的变化。</p>

<p>所以为了在界面显示上不出错，就算是固定长度的文字也还是建议使用sizetofit 或者ios向上取整 ceilf() 或者提前计算。</p>

<pre><code>CGSize size = [title sizeWithAttributes:@{NSFontAttributeName: [UIFont systemFontOfSize:14.0f]}];
CGSize adjustedSize = CGSizeMake(ceilf(size.width), ceilf(size.height));
</code></pre>

<h4>七、tableview</h4>

<p>虽然现在的iOS9已经推送正式版了，但是iOS9使用时还是会感觉到App比以前更加卡顿了，tableView拖动时卡顿显示的最为明显。 并且之前遇到一个bug，原本好的项目用xcode7一编译，tableView刷新出了问题 ，[tableView reloadData]无效，有一行cell明明改变了但是刷新不出来。 感觉可能是这个方法和某种新加的特性冲突了，猜测可能是reloadData的操作被推迟到下一个RunLoop执行最终失效。</p>

<p>解决的方法是，注释[tableView reloadData]，改用局部刷新，问题居然就解决了。</p>

<p>[self.tableView reloadSections:[NSIndexSet indexSetWithIndex:0] withRowAnimation:UITableViewRowAnimationNone];</p>

<h4>八、iPad适配Slide Over 和 Split View</h4>

<p>iPad适配Slide Over 和 Split View，若想适配multi tasking特性，唯一的建议：</p>

<p>弃纯代码，改用storyboard、xib，纵观苹果WWDC所有Demo均是如此。</p>

<pre><code>Mysteries of Auto Layout, Part 1
What's New in Storyboards
Implementing UI Designs in Interface Builder
Getting Started with Multitasking on iPad in iOS 9
Optimizing Your App for Multitasking on iPad in iOS
</code></pre>

<p>本文部分内容来自网络整理，如有错误请留言指出，谢谢！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自定义相册删除复活的实现]]></title>
    <link href="http://al1020119.github.io/blog/2015/11/29/zi-ding-yi-xiang-ce-shan-chu-fu-huo-de-shi-xian/"/>
    <updated>2015-11-29T00:22:52+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/11/29/zi-ding-yi-xiang-ce-shan-chu-fu-huo-de-shi-xian</id>
    <content type="html"><![CDATA[<p>在这里（<a href="http://www.cnblogs.com/iCocos/p/4705585.html">http://www.cnblogs.com/iCocos/p/4705585.html</a>）我们提到了。</p>

<ul>
<li>简单的实现了获取系统相册图片并且保存图片到系统相册</li>
<li>定义自定义的相册，并且保存到自定义相册</li>
</ul>


<p>这里久以一个简单的例子实现一个上面的所有功能，并且添加一个很有用的功能实现
App中自定义的相册呗删除之后再次保存相片无法成功</p>

<p>这里使用的是一个系统的库：ALAssetsLibrary</p>

<p>先来看看咱们取得相册中的相片</p>

<pre><code>- (void)getAllPhotos
{
    ALAssetsLibrary *library = [[ALAssetsLibrary alloc] init];
    // 遍历所有的文件夹, 一个ALAssetsGroup对象就代表一个文件夹
    [library enumerateGroupsWithTypes:ALAssetsGroupAll usingBlock:^(ALAssetsGroup *group, BOOL *stop) {
        // 遍历文件夹内的所有多媒体文件（图片、视频）, 一个ALAsset对象就代表一张图片
        [group enumerateAssetsUsingBlock:^(ALAsset *result, NSUInteger index, BOOL *stop) {
            // 缩略图
            XMGLog(@"%@", [UIImage imageWithCGImage:result.thumbnail]);
            // 获得原始图片
            //            XMGLog(@"%@", [UIImage imageWithCGImage:result.defaultRepresentation.fullResolutionImage]);
        }];

   } failureBlock:nil];
}
</code></pre>

<p>下面我们看看代码具体的实现</p>

<p>一：首先定义一个属性涌来记录并且实现其他一些功能</p>

<pre><code> /** 相册库 */
@property (nonatomic, strong) ALAssetsLibrary *library;
</code></pre>

<p>二：然后就懒加载这个属性</p>

<pre><code>- (ALAssetsLibrary *)library
{
    if (!_library) {
        _library = [[ALAssetsLibrary alloc] init];
    }
    return _library;
}
</code></pre>

<p>三：点击保存按钮的实现</p>

<pre><code>- (IBAction)save
{
// 获得文件夹的名字
__block NSString *groupName = [self groupName];

// self的弱引用
XMGWeakSelf;

// 图片库
__weak ALAssetsLibrary *weakLibrary = self.library;

// 创建文件夹
[weakLibrary addAssetsGroupAlbumWithName:groupName resultBlock:^(ALAssetsGroup *group) {
    if (group) { // 新创建的文件夹
        // 添加图片到文件夹中
        [weakSelf addImageToGroup:group];
    } else { // 文件夹已经存在
        [weakLibrary enumerateGroupsWithTypes:ALAssetsGroupAll usingBlock:^(ALAssetsGroup *group, BOOL *stop) {
            NSString *name = [group valueForProperty:ALAssetsGroupPropertyName];
            if ([name isEqualToString:groupName]) { // 是自己创建的文件夹
                // 添加图片到文件夹中

                [weakSelf addImageToGroup:group];

                *stop = YES; // 停止遍历
            } else if ([name isEqualToString:@"Camera Roll"]) {
                // 文件夹被用户强制删除了
                groupName = [groupName stringByAppendingString:@" "];
                // 存储新的名字
                [[NSUserDefaults standardUserDefaults] setObject:groupName forKey:XMGGroupNameKey];
                [[NSUserDefaults standardUserDefaults] synchronize];
                // 创建新的文件夹
                [weakLibrary addAssetsGroupAlbumWithName:groupName resultBlock:^(ALAssetsGroup *group) {
                    // 添加图片到文件夹中
                    [weakSelf addImageToGroup:group];
                } failureBlock:nil];
            }
        } failureBlock:nil];
    }

    } failureBlock:nil];
    }
</code></pre>

<p>四：添加图片</p>

<pre><code>/**
 * 添加一张图片到某个文件夹中
 */
- (void)addImageToGroup:(ALAssetsGroup *)group
{
__weak ALAssetsLibrary *weakLibrary = self.library;
// 需要保存的图片

CGImageRef image = self.imageView.image.CGImage;

// 添加图片到【相机胶卷】
[weakLibrary writeImageToSavedPhotosAlbum:image metadata:nil completionBlock:^(NSURL *assetURL, NSError *error) {
    [weakLibrary assetForURL:assetURL resultBlock:^(ALAsset *asset) {
        // 添加一张图片到自定义的文件夹中
        [group addAsset:asset];
        [SVProgressHUD showSuccessWithStatus:@"保存成功!"];
    } failureBlock:nil];
}];
}
</code></pre>

<p>五：关于沙河中的组名</p>

<p>先定义一个用于保存名字用的key和一个需要保存的名字</p>

<pre><code>static NSString * const iCocosGroupNameKey = @"iCocosGroupNameKey";
static NSString * const iCocosDefaultGroupName = @"iCocos";
</code></pre>

<p>实现祖名的存取</p>

<pre><code>- (NSString *)groupName
{
    // 先从沙盒中取得名字

    NSString *groupName = [[NSUserDefaults standardUserDefaults] stringForKey:XMGGroupNameKey];
    if (groupName == nil) { // 沙盒中没有存储任何文件夹的名字
   groupName = XMGDefaultGroupName;

    // 存储名字到沙盒中
    [[NSUserDefaults standardUserDefaults] setObject:groupName forKey:XMGGroupNameKey];
 [[NSUserDefaults standardUserDefaults] synchronize];
}
return groupName;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[XMPP使用总结]]></title>
    <link href="http://al1020119.github.io/blog/2015/11/29/xmppshi-yong-zong-jie/"/>
    <updated>2015-11-29T00:21:39+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/11/29/xmppshi-yong-zong-jie</id>
    <content type="html"><![CDATA[<p>引言：
最近面试被问到了一个问题，笔者当时就懵了：什么XMPP，平时怎么使用，使用过程中遇到什么问题？。</p>

<p>但是还是通过记忆，简单的说了一下自己所知道了，不过那并没有撒卵用，所以你懂的</p>

<h6>##XMPPFramework是一个OS X/iOS平台的开源项目，使用Objective-C实现了XMPP协议（RFC-3920），同时还提供了用于读写XML的工具，大大简化了基于XMPP的通信应用的开发。</h6>

<h3>关于连接的</h3>

<pre><code>//此方法在stream开始连接服务器的时候调用
 - (void)xmppStreamDidConnect:(XMPPStream *)sender
 //此方法在stream连接断开的时候调用
 - (void)xmppStreamDidDisconnect:(XMPPStream *)sender withError:(NSError *)error;
</code></pre>

<h3>关于验证的</h3>

<pre><code>//验证失败后调用
 - (void)xmppStream:(XMPPStream *)sender didNotAuthenticate:(NSXMLElement *)error
//验证成功后调用
 - (void)xmppStreamDidAuthenticate:(XMPPStream *)sender
</code></pre>

<h3>关于通信的</h3>

<pre><code>//收到消息后调用
- (void)xmppStream:(XMPPStream *)sender didReceiveMessage:(XMPPMessage *)message
//接受到好友状态更新
- (void)xmppStream:(XMPPStream *)sender didReceivePresence:(XMPPPresence *)presence
</code></pre>

<h4>简单实战</h4>

<h6>登录和好友上下线</h6>

<h5>XMPP中常用对象们</h5>

<pre><code>XMPPStream：xmpp基础服务类
XMPPRoster：好友列表类
XMPPRosterCoreDataStorage：好友列表（用户账号）在core data中的操作类
XMPPvCardCoreDataStorage：好友名片（昵称，签名，性别，年龄等信息）在core data中的操作类
XMPPvCardTemp：好友名片实体类，从数据库里取出来的都是它
xmppvCardAvatarModule：好友头像
XMPPReconnect：如果失去连接,自动重连
XMPPRoom：提供多用户聊天支持
</code></pre>

<p>XMPPPubSub：发布订阅</p>

<h5>登录操作，也就是连接xmpp服务器</h5>

<pre><code>- (void)connect {
    if (self.xmppStream == nil) {
        self.xmppStream = [[XMPPStream alloc] init];
        [self.xmppStream addDelegate:self delegateQueue:dispatch_get_main_queue()];
    }
    if (![self.xmppStream isConnected]) {
        NSString *username = [[NSUserDefaults standardUserDefaults] objectForKey:@"username"];
        XMPPJID *jid = [XMPPJID jidWithUser:username domain:@"lizhen" resource:@"Ework"];
        [self.xmppStream setMyJID:jid];
        [self.xmppStream setHostName:@"10.4.125.113"];
        NSError *error = nil;
        if (![self.xmppStream connect:&amp;error]) {
            NSLog(@"Connect Error: %@", [[error userInfo] description]);
        }
    }
}
</code></pre>

<p>connect成功之后会依次调用XMPPStreamDelegate的方法，首先调用</p>

<pre><code>- (void)xmppStream:(XMPPStream *)sender socketDidConnect:(GCDAsyncSocket *)socket
</code></pre>

<p>&hellip;
然后</p>

<ul>
<li><p>(void)xmppStreamDidConnect:(XMPPStream *)sender
在该方法下面需要使用xmppStream 的authenticateWithPassword方法进行密码验证，成功的话会响应delegate的方法，就是下面这个</p></li>
<li><p>(void)xmppStreamDidAuthenticate:(XMPPStream *)sender</p></li>
</ul>


<h5>上线</h5>

<p>实现 - (void)xmppStreamDidAuthenticate:(XMPPStream *)sender 委托方法</p>

<pre><code>- (void)xmppStreamDidAuthenticate:(XMPPStream *)sender {
     XMPPPresence *presence = [XMPPPresence presenceWithType:@"available"];
    [self.xmppStream sendElement:presence];
 }
</code></pre>

<h5>退出并断开连接</h5>

<pre><code> - (void)disconnect {
     XMPPPresence *presence = [XMPPPresence presenceWithType:@"unavailable"];
    [self.xmppStream sendElement:presence];

      [self.xmppStream disconnect];
  }
</code></pre>

<h5>好友状态</h5>

<p>获取好友状态，通过实现</p>

<pre><code>- (void)xmppStream:(XMPPStream *)sender didReceivePresence:(XMPPPresence *)presence
</code></pre>

<p>&hellip;
方法，当接收到 presence 标签的内容时，XMPPFramework 框架回调该方法</p>

<pre><code>presence 的状态：
available 上线
away 离开
do not disturb 忙碌
unavailable 下线

- (void)xmppStream:(XMPPStream *)sender didReceivePresence:(XMPPPresence *)presence {
    NSString *presenceType = [presence type];
    NSString *presenceFromUser = [[presence from] user];
    if (![presenceFromUser isEqualToString:[[sender myJID] user]]) {
        if ([presenceType isEqualToString:@"available"]) {
            //
        } else if ([presenceType isEqualToString:@"unavailable"]) {
            //
        }
    }
}
</code></pre>

<h3>接收消息和发送消息</h3>

<h5>接收消息</h5>

<p>通过实现</p>

<ul>
<li><p>(void)xmppStream:(XMPPStream <em>)sender didReceiveMessage:(XMPPMessage </em>)message;
当接收到 message 标签的内容时，XMPPFramework 框架回调该方法
根据 XMPP 协议，消息体的内容存储在标签 body 内</p></li>
<li><p>(void)xmppStream:(XMPPStream <em>)sender didReceiveMessage:(XMPPMessage </em>)message {
  NSString *messageBody = [[message elementForName:@&ldquo;body&rdquo;] stringValue];
}</p></li>
</ul>


<h5>发送消息</h5>

<p>发送消息，我们需要根据 XMPP 协议，将数据放到标签内</p>

<pre><code>- (void)sendMessage:(NSString *) message toUser:(NSString *) user {
    NSXMLElement *body = [NSXMLElement elementWithName:@"body"];
    [body setStringValue:message];
    NSXMLElement *message = [NSXMLElement elementWithName:@"message"];
    [message addAttributeWithName:@"type" stringValue:@"chat"];
    NSString *to = [NSString stringWithFormat:@"%@@example.com", user];
    [message addAttributeWithName:@"to" stringValue:to];
    [message addChild:body];
    [self.xmppStream sendElement:message];
}
</code></pre>

<h3>获取好友信息和删除好友</h3>

<h5>好友列表和好友名片</h5>

<pre><code>[_xmppRoster fetchRoster];//获取好友列表
//获取到一个好友节点
- (void)xmppRoster:(XMPPRoster *)sender didRecieveRosterItem:(NSXMLElement *)item
//获取完好友列表
- (void)xmppRosterDidEndPopulating:(XMPPRoster *)sender
//到服务器上请求联系人名片信息
- (void)fetchvCardTempForJID:(XMPPJID *)jid;
//请求联系人的名片，如果数据库有就不请求，没有就发送名片请求
- (void)fetchvCardTempForJID:(XMPPJID *)jid ignoreStorage:(BOOL)ignoreStorage;
//获取联系人的名片，如果数据库有就返回，没有返回空，并到服务器上抓取
- (XMPPvCardTemp *)vCardTempForJID:(XMPPJID *)jid shouldFetch:(BOOL)shouldFetch;
//更新自己的名片信息
- (void)updateMyvCardTemp:(XMPPvCardTemp *)vCardTemp;
//获取到一盒联系人的名片信息的回调
- (void)xmppvCardTempModule:(XMPPvCardTempModule *)vCardTempModule
        didReceivevCardTemp:(XMPPvCardTemp *)vCardTemp
                     forJID:(XMPPJID *)jid
</code></pre>

<h5>添加好友</h5>

<pre><code>//name为用户账号
    - (void)XMPPAddFriendSubscribe:(NSString *)name
    {
        //XMPPHOST 就是服务器名，  主机名
        XMPPJID *jid = [XMPPJID jidWithString:[NSString stringWithFormat:@"%@@%@",name,XMPPHOST]];
        //[presence addAttributeWithName:@"subscription" stringValue:@"好友"];
        [xmppRoster subscribePresenceToUser:jid];

    }
</code></pre>

<h5>收到添加好友的请求</h5>

<pre><code>- (void)xmppRoster:(XMPPRoster *)sender didReceivePresenceSubscriptionRequest:(XMPPPresence *)presence
    {
        //取得好友状态
        NSString *presenceType = [NSString stringWithFormat:@"%@", [presence type]]; //online/offline
        //请求的用户
        NSString *presenceFromUser =[NSString stringWithFormat:@"%@", [[presence from] user]];
        NSLog(@"presenceType:%@",presenceType);

        NSLog(@"presence2:%@  sender2:%@",presence,sender);

        XMPPJID *jid = [XMPPJID jidWithString:presenceFromUser];
        //接收添加好友请求
        [xmppRoster acceptPresenceSubscriptionRequestFrom:jid andAddToRoster:YES];

    }
</code></pre>

<h5>删除好友</h5>

<pre><code>//删除好友，name为好友账号
- (void)removeBuddy:(NSString *)name  
{  
    XMPPJID *jid = [XMPPJID jidWithString:[NSString stringWithFormat:@"%@@%@",name,XMPPHOST]];  

    [self xmppRoster] removeUser:jid];  
}
</code></pre>

<h5>聊天室</h5>

<p>初始化聊天室</p>

<pre><code>     XMPPJID *roomJID = [XMPPJID jidWithString:ROOM_JID];

    xmppRoom = [[XMPPRoom alloc] initWithRoomStorage:self jid:roomJID];

    [xmppRoom activate:xmppStream];
     [xmppRoom addDelegate:self delegateQueue:dispatch_get_main_queue()];
</code></pre>

<p>创建聊天室成功</p>

<pre><code>`- (void)xmppRoomDidCreate:(XMPPRoom *)sender
{
    DDLogInfo(@"%@: %@", THIS_FILE, THIS_METHOD);
}`
</code></pre>

<p>加入聊天室，使用昵称</p>

<pre><code>[xmppRoom joinRoomUsingNickname:@"quack" history:nil];
</code></pre>

<p>获取聊天室信息</p>

<pre><code>- (void)xmppRoomDidJoin:(XMPPRoom *)sender
    {
        [xmppRoom fetchConfigurationForm];
        [xmppRoom fetchBanList];
        [xmppRoom fetchMembersList];
        [xmppRoom fetchModeratorsList];
    }
</code></pre>

<p>如果房间存在，会调用委托</p>

<pre><code>    // 收到禁止名单列表

    - (void)xmppRoom:(XMPPRoom *)sender didFetchBanList:(NSArray *)items;
    // 收到好友名单列表

    - (void)xmppRoom:(XMPPRoom *)sender didFetchMembersList:(NSArray *)items;
    // 收到主持人名单列表

    - (void)xmppRoom:(XMPPRoom *)sender didFetchModeratorsList:(NSArray *)items;
房间不存在，调用委托

    - (void)xmppRoom:(XMPPRoom *)sender didNotFetchBanList:(XMPPIQ *)iqError;
    - (void)xmppRoom:(XMPPRoom *)sender didNotFetchMembersList:(XMPPIQ *)iqError;
    - (void)xmppRoom:(XMPPRoom *)sender didNotFetchModeratorsList:(XMPPIQ *)iqError;
</code></pre>

<p>离开房间</p>

<pre><code>[xmppRoom deactivate:xmppStream];
</code></pre>

<p>XMPPRoomDelegate的其他代理方法:</p>

<p>离开聊天室</p>

<pre><code>    - (void)xmppRoomDidLeave:(XMPPRoom *)sender
    {
        DDLogVerbose(@"%@: %@", THIS_FILE, THIS_METHOD);
    }
</code></pre>

<p>新人加入群聊</p>

<pre><code>    - (void)xmppRoom:(XMPPRoom *)sender occupantDidJoin:(XMPPJID *)occupantJID
     {
         DDLogVerbose(@"%@: %@", THIS_FILE, THIS_METHOD);
    }
</code></pre>

<p>有人退出群聊</p>

<pre><code>    - (void)xmppRoom:(XMPPRoom *)sender occupantDidLeave:(XMPPJID *)occupantJID
    {
        DDLogVerbose(@"%@: %@", THIS_FILE, THIS_METHOD);
    }
</code></pre>

<p>有人在群里发言</p>

<pre><code>    - (void)xmppRoom:(XMPPRoom *)sender didReceiveMessage:(XMPPMessage *)message fromOccupant:(XMPPJID *)occupantJID
     {
         DDLogVerbose(@"%@: %@", THIS_FILE, THIS_METHOD);
    }
</code></pre>

<h5>消息回执</h5>

<p>这个是XEP－0184协议的内容
发送消息时附加回执请求
代码实现</p>

<pre><code>NSString *siID = [XMPPStream generateUUID];
    //发送消息
    XMPPMessage *message = [XMPPMessage messageWithType:@"chat" to:jid elementID:siID];
    NSXMLElement *receipt = [NSXMLElement elementWithName:@"request" xmlns:@"urn:xmpp:receipts"];
    [message addChild:receipt];
    [message addBody:@"测试"];
    [self.xmppStream sendElement:message];
</code></pre>

<p>收到回执请求的消息，发送回执</p>

<pre><code>- (void)xmppStream:(XMPPStream *)sender didReceiveMessage:(XMPPMessage *)message
    {
        //回执判断
        NSXMLElement *request = [message elementForName:@"request"];
        if (request)
        {
            if ([request.xmlns isEqualToString:@"urn:xmpp:receipts"])//消息回执
            {
                //组装消息回执
                XMPPMessage *msg = [XMPPMessage messageWithType:[message attributeStringValueForName:@"type"] to:message.from elementID:[message attributeStringValueForName:@"id"]];
                NSXMLElement *recieved = [NSXMLElement elementWithName:@"received" xmlns:@"urn:xmpp:receipts"];
                [msg addChild:recieved];

                //发送回执
                [self.xmppStream sendElement:msg];
            }
        }else
        {
            NSXMLElement *received = [message elementForName:@"received"];
            if (received)
            {
                if ([received.xmlns isEqualToString:@"urn:xmpp:receipts"])//消息回执
                {
                    //发送成功
                    NSLog(@"message send success!");
                }  
            }  
        }  

        //消息处理  
        //...  
    }
</code></pre>

<h5>添加AutoPing</h5>

<p>为 了监听服务器是否有效，增加心跳监听。用XEP-0199协议，在XMPPFrameWork框架下，封装了 XMPPAutoPing 和 XMPPPing两个类都可以使用，因为XMPPAutoPing已经组合进了XMPPPing类，所以XMPPAutoPing使用起来更方便。</p>

<pre><code>//初始化并启动ping
-(void)autoPingProxyServer:(NSString*)strProxyServer
{
    _xmppAutoPing = [[XMPPAutoPingalloc] init];
    [_xmppAutoPingactivate:_xmppStream];
    [_xmppAutoPingaddDelegate:selfdelegateQueue:  dispatch_get_main_queue()];
    _xmppAutoPing.respondsToQueries = YES;
    _xmppAutoPing.pingInterval=2;//ping 间隔时间
    if (nil != strProxyServer)
    {
       _xmppAutoPing.targetJID = [XMPPJID jidWithString: strProxyServer ];//设置ping目标服务器，如果为nil,则监听socketstream当前连接上的那个服务器
    }
}
//卸载监听
 [_xmppAutoPing   deactivate];
  [_xmppAutoPing   removeDelegate:self];
   _xmppAutoPing = nil;
//ping XMPPAutoPingDelegate的委托方法:
- (void)xmppAutoPingDidSendPing:(XMPPAutoPing *)sender
{
    NSLog(@"- (void)xmppAutoPingDidSendPing:(XMPPAutoPing *)sender");
}
- (void)xmppAutoPingDidReceivePong:(XMPPAutoPing *)sender
{
    NSLog(@"- (void)xmppAutoPingDidReceivePong:(XMPPAutoPing *)sender");
}

- (void)xmppAutoPingDidTimeout:(XMPPAutoPing *)sender
{
    NSLog(@"- (void)xmppAutoPingDidTimeout:(XMPPAutoPing *)sender");
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UITableView性能优化与卡顿问题]]></title>
    <link href="http://al1020119.github.io/blog/2015/11/29/uitableviewxing-neng-you-hua-yu-qia-dun-wen-ti/"/>
    <updated>2015-11-29T00:19:52+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/11/29/uitableviewxing-neng-you-hua-yu-qia-dun-wen-ti</id>
    <content type="html"><![CDATA[<p>引言：</p>

<p>在iOS开发中关于TableView算是已经用烂了的控件，但是又有几个人认真去考路过他的性能优化问题（卡顿）</p>

<p>最近项目中也遇到了不少卡顿的问题，为了更好的饿提高项目的性能，也为了提高自己的技术，专门花了一段时间研究了一下关于TableView的性能问题，在这里就总结了一下，希望可以帮你解决实际问题。</p>

<p>1.最常用的就是cell的重用， 注册重用标识符</p>

<pre><code>如果不重用cell时，每当一个cell显示到屏幕上时，就会重新创建一个新的cell
如果有很多数据的时候，就会堆积很多cell。如果重用cell，为cell创建一个ID
每当需要显示cell 的时候，都会先去缓冲池中寻找可循环利用的cell，如果没有再重新创建cell
设置正确的reuseIdentifer以重用cell
</code></pre>

<p>2.避免cell的重新布局</p>

<pre><code>cell的布局填充等操作 比较耗时，一般创建时就布局好
如可以将cell单独放到一个自定义类，初始化时就布局好
</code></pre>

<p>3.提前计算并缓存cell的属性及内容</p>

<pre><code>在cellForRowAtIndexPath:中尽量做更少的操作。如果需要做一些处理，那么最好做过一次之后，就将结果缓存起来。
当我们创建cell的数据源方法时，编译器并不是先创建cell 再定cell的高度
而是先根据内容一次确定每一个cell的高度，高度确定后，再创建要显示的cell，滚动时，每当cell进入凭虚都会计算高度，提前估算高度告诉编译器，编译器知道高度后，紧接着就会创建cell，这时再调用高度的具体计算方法，这样可以方式浪费时间去计算显示以外的cell
</code></pre>

<p>4.减少cell中控件的数量</p>

<pre><code>尽量使cell得布局大致相同，不同风格的cell可以使用不用的重用标识符，初始化时添加控件，
不适用的可以先隐藏
</code></pre>

<p>5.不要使用ClearColor，无背景色，透明度也不要设置为0</p>

<pre><code>渲染耗时比较长
尽量将view设置为不透明，包括cell本身。
</code></pre>

<p>6.使用局部更新</p>

<pre><code>如果只是更新某组的话，使用reloadSection进行局部更新
</code></pre>

<p>7.加载网络数据，下载图片，使用异步加载，并缓存</p>

<pre><code>如果cell显示的内容来此网络，那么确保这些内容是通过异步来获取的
</code></pre>

<p>8.少使用addView 给cell动态添加view</p>

<p>9.按需加载cell，cell滚动很快时，只加载范围内的cell</p>

<pre><code>注意正确使用懒加载
</code></pre>

<p>10.不要实现无用的代理方法，tableView只遵守两个协议</p>

<pre><code>非必要的代理或者数据源方法可以省略，比如numberofsention
</code></pre>

<p>11.缓存行高：</p>

<pre><code>如果row的高度不相同，那么将其缓存下来
estimatedHeightForRow不能和HeightForRow里面的layoutIfNeed同时存在，这两者同时存在才会出现“窜动”的bug。所以我的建议是：只要是固定行高就写预估行高来减少行高调用次数提升性能。如果是动态行高就不要写预估方法了，用一个行高的缓存字典来减少代码的调用次数即可
</code></pre>

<p>12.避免渐变，图像缩放以及离屏绘制</p>

<p>13.使用shadowPath来设置阴影。</p>

<p>14.使用适当的数据结构来保存需要的信息。不同的结构会带来不同的操作代价。</p>

<p>15.使用rowHeight, sectionFooterHeight 和 sectionHeaderHeight 来设置一个恒定 高度，而不要从delegate中获取。</p>

<hr />

<p>参考：相关性能优化问题</p>

<p><a href="http://www.cocoachina.com/ios/20150408/11501.html">iOS应用性能调优的25个建议和技巧</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[蓝牙开发你知道多少]]></title>
    <link href="http://al1020119.github.io/blog/2015/11/28/lan-ya-kai-fa-ni-zhi-dao-duo-shao/"/>
    <updated>2015-11-28T00:38:13+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/11/28/lan-ya-kai-fa-ni-zhi-dao-duo-shao</id>
    <content type="html"><![CDATA[<p>蓝牙简单介绍和4.0的基本使用</p>

<p>背景：</p>

<ul>
<li>iOS的蓝牙不能用来传输文件。</li>
<li>iOS与iOS设备之间进行数据通信，使用gameKit.framework</li>
<li>iOS与其他非iOS设备进行数据通信，使用coreBluetooth.framework</li>
</ul>


<h3>iOS中蓝牙的实现方案</h3>

<p>iOS中提供了4个框架用于实现蓝牙连接</p>

<ol>
<li><p>GameKit.framework（用法简单）</p>

<p> <code>只能用于iOS设备之间的连接，多用于游戏（比如五子棋对战），从iOS7开始过期</code></p></li>
<li><p>MultipeerConnectivity.framework</p>

<p> <code>只能用于iOS设备之间的连接，从iOS7开始引入，主要用于文件共享（仅限于沙盒的文件）</code></p></li>
<li><p>ExternalAccessory.framework</p>

<p> <code>可用于第三方蓝牙设备交互，但是蓝牙设备必须经过苹果MFi认证（国内较少）</code></p></li>
<li><h6>CoreBluetooth.framework（时下热门）</h6>

<p> <code>可用于第三方蓝牙设备交互，必须要支持蓝牙4.0</code></p>

<p> <code>硬件至少是4s，系统至少是iOS6</code></p>

<p> <code>蓝牙4.0以低功耗著称，一般也叫BLE（BluetoothLowEnergy）</code></p>

<p> <code>目前应用比较多的案例：运动手坏、嵌入式设备、智能家居</code></p></li>
</ol>


<p>下面具体介绍使用CoreBluetooth.framework的代码步骤：</p>

<h5>蓝牙系统库</h5>

<pre><code>#import &lt;CoreBluetooth/CoreBluetooth.h&gt;
</code></pre>

<h5>必须要由UUID来唯一标示对应的service和characteristic</h5>

<pre><code>#define kServiceUUID @"5C476471-1109-4EBE-A826-45B4F9D74FB9"

#define kCharacteristicHeartRateUUID @"82C7AC0F-6113-4EC9-92D1-5EEF44571398"

#define kCharacteristicBodyLocationUUID @"537B5FD6-1889-4041-9C35-F6949D1CA034"
</code></pre>

<hr />

<pre><code>@interface ViewController ()&lt;CBCentralManagerDelegate,CBPeripheralDelegate&gt;



@property (nonatomic,strong)CBCentralManager * centralManager;

@property (nonatomic,strong)CBPeripheral     * peripheral;

@end
</code></pre>

<h4>创建中心角色</h4>

<pre><code>#import &lt;CoreBluetooth/CoreBluetooth.h&gt;

- (void)viewDidLoad
{

    [super viewDidLoad];

    //初始化蓝牙 central manager

    _centralManager = [[CBCentralManager alloc]initWithDelegate:self queue:dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0) options:nil];    

}
</code></pre>

<h4>扫描外设</h4>

<pre><code>[manager scanForPeripheralsWithServices:nil options:@{CBCentralManagerRestoredStateScanOptionsKey:@(YES)}];
</code></pre>

<h4>连接外设</h4>

<pre><code>- (void)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)peripheral advertisementData:(NSDictionary *)advertisementData RSSI:(NSNumber *)RSSI
{
        if([peripheral.name  isEqualToString:BLE_SERVICE_NAME]){
                [self connect:peripheral];
        }
}       

-(BOOL)connect:(CBPeripheral *)peripheral{
        self.manager.delegate = self;
        [self.manager connectPeripheral:peripheral
                                options:[NSDictionary dictionaryWithObject:[NSNumber numberWithBool:YES] forKey:CBConnectPeripheralOptionNotifyOnDisconnectionKey]];
}
</code></pre>

<h4>扫描外设中的服务和特征</h4>

<pre><code>- (void)centralManager:(CBCentralManager *)central didConnectPeripheral:(CBPeripheral *)peripheral
{

   NSLog(@"Did connect to peripheral: %@", peripheral);       

   _testPeripheral = peripheral;
   [peripheral setDelegate:self];  &lt;br&gt;//查找服务
   [peripheral discoverServices:nil];


}
</code></pre>

<h4>发现服务：</h4>

<pre><code>- (void)peripheral:(CBPeripheral *)peripheral didDiscoverServices:(NSError *)error
{


NSLog(@"didDiscoverServices");

if (error)
{
    NSLog(@"Discovered services for %@ with error: %@", peripheral.name, [error localizedDescription]);

    if ([self.delegate respondsToSelector:@selector(DidNotifyFailConnectService:withPeripheral:error:)])
        [self.delegate DidNotifyFailConnectService:nil withPeripheral:nil error:nil];

    return;
}


for (CBService *service in peripheral.services)
{
     //发现服务
    if ([service.UUID isEqual:[CBUUID UUIDWithString:UUIDSTR_ISSC_PROPRIETARY_SERVICE]])
    {
        NSLog(@"Service found with UUID: %@", service.UUID);  &lt;br&gt;//查找特征
        [peripheral discoverCharacteristics:nil forService:service];
        break;
    }


}
}
</code></pre>

<h4>发现服务中的特征：</h4>

<pre><code>- (void)peripheral:(CBPeripheral *)peripheral didDiscoverCharacteristicsForService:(CBService *)service error:(NSError *)error
{

if (error)
{
    NSLog(@"Discovered characteristics for %@ with error: %@", service.UUID, [error localizedDescription]);

    [self error];
    return;
}

NSLog(@"服务：%@",service.UUID);
for (CBCharacteristic *characteristic in service.characteristics)
{
   //发现特征
        if ([characteristic.UUID isEqual:[CBUUID UUIDWithString:@"xxxxxxx"]]) {
            NSLog(@"监听：%@",characteristic);&lt;br&gt;//监听特征
            [self.peripheral setNotifyValue:YES forCharacteristic:characteristic];
        }

}
}
</code></pre>

<h4>与外设进行数据交互</h4>

<p>读取数据：</p>

<pre><code>- (void)peripheral:(CBPeripheral *)peripheral didUpdateValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error
{
    if (error)
    {
        NSLog(@"Error updating value for characteristic %@ error: %@", characteristic.UUID, [error localizedDescription]);
        self.error_b = BluetoothError_System;
        [self error];
        return;
}

//    NSLog(@"收到的数据：%@",characteristic.value);
[self decodeData:characteristic.value];
}
</code></pre>

<h4>写数据：</h4>

<pre><code>NSData *d2 = [[PBABluetoothDecode sharedManager] HexStringToNSData:@"0x02"];
            [self.peripheral writeValue:d2 forCharacteristic:characteristic type:CBCharacteristicWriteWithoutResponse];
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[cocoaPods简单粗暴]]></title>
    <link href="http://al1020119.github.io/blog/2015/11/28/cocoapodsjian-dan-cu-bao/"/>
    <updated>2015-11-28T00:32:20+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/11/28/cocoapodsjian-dan-cu-bao</id>
    <content type="html"><![CDATA[<p>直接上代码，不要问为什么，照着做就可以，我也是这么做的，具体的细节，请查看相关文档，网上太多！</p>

<p>1:移除ruby镜像（天朝的网你们懂的）</p>

<pre><code> $ gem sources --remove https://rubygems.org/ 
</code></pre>

<p>2:新增淘宝镜像</p>

<pre><code>$ gem sources -a http://ruby.taobao.org/ 
</code></pre>

<p>3:查看列表</p>

<pre><code> $ gem sources -l 
</code></pre>

<p>成功的征兆：</p>

<pre><code>*** CURRENT SOURCES ***
http://ruby.taobao.org/
$ sudo gem install cocoapods
</code></pre>

<p>4:正式安装</p>

<pre><code> sudo gem install cocoapods 
</code></pre>

<p>接下来就是开始使用了。</p>

<p>查看对应的框架</p>

<pre><code> $ pod search AFNetworking 
</code></pre>

<p>创建文件</p>

<pre><code> $ vim Podfile 
</code></pre>

<p> 或者在命令行行中cd到对应的项目文件夹使用</p>

<pre><code>touch Podfile
</code></pre>

<p>新建一个文件</p>

<p>然后在Podfile文件中输入以下文字：</p>

<pre><code>platform :ios, '7.0'
pod "AFNetworking", "~&gt; 2.0”
</code></pre>

<p>安装</p>

<pre><code> pod install  
</code></pre>

<p>更新</p>

<pre><code> $ pod update 
</code></pre>

<p>有时候可能上面的命令没有用可能是网络的原因，那么你可以试试下面的：</p>

<pre><code>pod update 换成pod update --verbose --no-repo-update
pod install 换成pod install --verbose --no-repo-update
</code></pre>

<ul>
<li>$ pod install只会按照Podfile的要求来请求类库，如果类库版本号有变化，那么将获取失败。
$ pod update会更新所有的类库，获取最新版本的类库。
或许还有一些情况是因为mac中对应的文件有问题，比如有两个Xcode的时候就会发生歧义（系统不知道用哪个），这个时候我们可以试试下面的方法。</li>
</ul>


<p>CocoaPods安装东西的时候它要找到Xcode的Developer文件夹, 如果找不到会报如下错误</p>

<ul>
<li>解决方案</li>
</ul>


<p>LNJ替换为你自己的用户名</p>

<pre><code>sudo xcode-select --switch /Users/LNJ/Applications/Xcode.app/Contents/Developer
</code></pre>

<p>而且你会发现，如果用了 $ pod update，再用 $ pod install 就成功了。</p>

<ul>
<li><p>那你也许会问，什么时候用 $ pod install，什么时候用 $ pod update 呢，我又不知道类库有没有新版本。</p></li>
<li><p>好吧，那你每次直接用 $ pod update 算了。或者先用 $ pod install，如果不行，再用 <br/>
  <code>$ pod update。</code></p></li>
</ul>


<p>当然你也可以使用Xcode插件，使用非常简单，这里就不多介绍，以后有机会给大家整理：</p>

<p><a href="https://github.com/kattrali/cocoapods-xcode-plugin">cocoapods-xcode-plugin</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[取消TableView的Header与Footer的黏性效果]]></title>
    <link href="http://al1020119.github.io/blog/2015/11/28/qu-xiao-tableviewde-headeryu-footerde-nian-xing-xiao-guo/"/>
    <updated>2015-11-28T00:24:40+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/11/28/qu-xiao-tableviewde-headeryu-footerde-nian-xing-xiao-guo</id>
    <content type="html"><![CDATA[<p>引言：</p>

<p>最近做一个项目的时候，遇到了一个bug问题，或者说个人能力有限，想了很久没有想到最好的方法去现实。</p>

<h6>那么是什么问题呢？</h6>

<p>首先当我在tabelView中为没饿过section设置一个header和footer之后，滑动tableView的时候，发现header和footer并不随着tableView中的cell一起滚动，而且会在顶部活着底部停留一段时间，这样的效果虽然好，但是上面就是不需要者也的功能，所以只好自己想办法解决。</p>

<p>我记得有时候header是不会停顿的，可是为什么这个时候header和footer都隐藏呢？</p>

<p>后来发现原来设置tableView.tableHeaderView = ?或者footerView的时候就不会停顿，那是当然，因为这个是tableView的一部分，不是section的一部分。</p>

<p>也在网上找了一段这样的代码</p>

<h3>去掉UItableview headerview黏性(sticky)</h3>

<pre><code>- (void)scrollViewDidScroll:(UIScrollView *)scrollView {

if (scrollView == self.tableView)

{

        CGFloat sectionHeaderHeight = 64; //sectionHeaderHeight

        if (scrollView.contentOffset.y &lt;= sectionHeaderHeight &amp;&amp; scrollView.contentOffset.y &gt;= 0) {

            scrollView.contentInset = UIEdgeInsetsMake(-scrollView.contentOffset.y, 0, 0, 0);

        } else if (scrollView.contentOffset.y &gt;= sectionHeaderHeight) {

            scrollView.contentInset = UIEdgeInsetsMake(-sectionHeaderHeight, 0, 0, 0);

        }

    }

}
</code></pre>

<p>但是他职能设置headerView不能设置footerView，自己也试着去补充footerView的实现，但是发现技术有限，所以，你懂的！</p>

<h3>最后看到国外一位大神写的一一篇文章找到了下面的代码</h3>

<pre><code> -(void)scrollViewDidScroll:(UIScrollView *)scrollView {

    if (scrollView == self.tableView)

        {

        UITableView *tableview = (UITableView *)scrollView;

        CGFloat sectionHeaderHeight = 64;

        CGFloat sectionFooterHeight = 120;

        CGFloat offsetY = tableview.contentOffset.y;

        if (offsetY &gt;= 0 &amp;&amp; offsetY &lt;= sectionHeaderHeight)

        {

            tableview.contentInset = UIEdgeInsetsMake(-offsetY, 0, -sectionFooterHeight, 0);

        }else if (offsetY &gt;= sectionHeaderHeight &amp;&amp; offsetY &lt;= tableview.contentSize.height - tableview.frame.size.height - sectionFooterHeight)

        {

            tableview.contentInset = UIEdgeInsetsMake(-sectionHeaderHeight, 0, -sectionFooterHeight, 0);

        }else if (offsetY &gt;= tableview.contentSize.height - tableview.frame.size.height - sectionFooterHeight &amp;&amp; offsetY &lt;= tableview.contentSize.height - tableview.frame.size.height)         {

            tableview.contentInset = UIEdgeInsetsMake(-offsetY, 0, -(tableview.contentSize.height - tableview.frame.size.height - sectionFooterHeight), 0);

        }

    }

}
</code></pre>

<p>注：sectionHeaderHeight和sectionFooterHeight根据项目进行设置。</p>

<p>发现基本上搞定，最后只需要设置对应的内边距即可！</p>

<!-- more -->



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[底层开发之越狱开发]]></title>
    <link href="http://al1020119.github.io/blog/2015/11/27/yue-yu-kai-fa-xiang-jie/"/>
    <updated>2015-11-27T22:32:50+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/11/27/yue-yu-kai-fa-xiang-jie</id>
    <content type="html"><![CDATA[<p>做越狱开发也有一些时间了，有很多东西想总结一下，希望给他人一些借鉴，也是自己对过去开发经历的一些总结。个人不推荐使用盗版，这里主要以技术介绍为主。</p>

<p>这个系列里面主要介绍怎样进行越狱开发，涉及到以下几个方面:</p>

<ul>
<li>(1)主要涉及到越狱市场的建立，在App内部实现ipa的安装和卸载以及更新。参照的对象就是91助手，25pp，同步推那样的应用。建立一个盗版的App Store.当然了，如果通过299刀的企业证书的话，是不需要通过Cydia的，直接通过网页链接就可以实现app的推广，有一定的风险。这里面涉及到一些协议，后面会进行介绍。</li>
<li>(2)在App内部实现壁纸和铃声的替换。这个过程涉及到的东西很多，特别是铃声的替换，iPhone里面非常麻烦；</li>
<li>(3)一些越狱插件的开发，通过里面有些插件非常好用，合理，而且非常美观漂亮。
这里先从App内部安装ipa包开始讲，后面逐步把上面提到的3点全部讲完。</li>
</ul>


<p>一般情况下安装91助手，同步推这样的应用需要手机越狱，同时安装AppSync，这样才能使用，所以进行开发的必备条件也是如此。</p>

<p>上传的demo工程的地址，我的github链接：<a href="https://github.com/easonoutlook/IPAInstaller">https://github.com/easonoutlook/IPAInstaller</a></p>

<p>之前一直在fork别人的东西，也没做什么贡献，从现在开始，为开发为开源，做一点自己的贡献。</p>

<p>进入正题：</p>

<p>需要的工具和环境：</p>

<ol type="a">
<li>iPhone or iPad越狱，安装AppSync</li>
<li>Xcode安装 Command Line Tools</li>
<li>下载最新版本的ldid <a href="https://github.com/downloads/rpetrich/ldid/ldid.zip">https://github.com/downloads/rpetrich/ldid/ldid.zip</a></li>
</ol>


<p>1、修改SDKSettings.plist文件</p>

<p>我用的是Xcode4.6.3版本，iPhone的版本是6.1.2, 路径为：</p>

<pre><code>/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS6.1.sdk/
</code></pre>

<p>将这个目录下的 SDKSettings.plist里面的CODE_SIGNING_REQUIRED置为NO</p>

<p>执行命令为：</p>

<p>转到目录下</p>

<pre><code>cd /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS6.1.sdk
</code></pre>

<p>将原有文件备份</p>

<pre><code>sudo cp SDKSettings.plist SDKSettings.plist.orig
</code></pre>

<p>对SDKSettings.plist文件进行编辑</p>

<pre><code>sudo vim SDKSettings.plist
</code></pre>

<p>将下面对应的字段改为NO</p>

<pre><code>&lt;key&gt;CODE_SIGNING_REQUIRED&lt;/key&gt;
&lt;string&gt;YES&lt;/string&gt;  // 默认为YES, 需要改为NO
</code></pre>

<p>此操作参考的路径如下：</p>

<pre><code>http://kqwd.blog.163.com/blog/static/4122344820117191351263/
</code></pre>

<p>2、给工程添加相应的权限，iOS6里面需要赋予权限才可以，iOS5之前不需要此操作</p>

<p>新建一个plist文件，命名为entitlements.</p>

<pre><code>![Alt text](/iamges/yueyu001.jpg)
</code></pre>

<p><img src="http://al1020119.github.io/images/yueyu001.png" title="Caption" ></p>

<p>创建一个plist</p>

<pre><code>![Alt text](/iamges/yueyu002.jpg)
</code></pre>

<p><img src="http://al1020119.github.io/images/yueyu002.png" title="Caption" ></p>

<p>将plist文件改为：</p>

<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;
&lt;plist version="1.0"&gt;
&lt;dict&gt;
    &lt;key&gt;com.apple.private.mobileinstall.allowedSPI&lt;/key&gt;
    &lt;array&gt;
        &lt;string&gt;Install&lt;/string&gt;
        &lt;string&gt;Browse&lt;/string&gt;
        &lt;string&gt;Uninstall&lt;/string&gt;
        &lt;string&gt;Archive&lt;/string&gt;
        &lt;string&gt;RemoveArchive&lt;/string&gt;
    &lt;/array&gt;
&lt;/dict&gt;
&lt;/plist&gt;
</code></pre>

<p>将Code Signing 的Code Signing Entilements设置为刚刚创建的entitlements.plist文件</p>

<pre><code>![Alt text](/iamges/yueyu003.jpg)
</code></pre>

<p><img src="http://al1020119.github.io/images/yueyu003.png" title="Caption" ></p>

<p>后面还需要一个手续，将生产的app文件用ldid签名。后面再介绍。</p>

<p>3、实现越狱安装的代码：</p>

<pre><code>typedef NSDictionary *(*PMobileInstallationLookup)(NSDictionary *params, id callback_unknown_usage);
NSDictionary *IPAInstalledApps()
{
void *lib = dlopen("/System/Library/PrivateFrameworks/MobileInstallation.framework/MobileInstallation", RTLD_LAZY);
if (lib)
{
    PMobileInstallationLookup pMobileInstallationLookup = (PMobileInstallationLookup)dlsym(lib, "MobileInstallationLookup");
    if (pMobileInstallationLookup)
    {
        NSArray *wanted = nil;//[NSArray arrayWithObjects:@"com.celeware.IPADeploy",@"com.celeware.celedial",nil]; Lookup specified only
        NSDictionary *params = [NSDictionary dictionaryWithObjectsAndKeys:@"User", @"ApplicationType", wanted, @"BundleIDs",nil];
        NSDictionary *dict = pMobileInstallationLookup(params, NULL);
#ifdef DEBUG
        NSLog(@"%@", dict);
#endif
        return dict;
    }
}
return nil;
}
</code></pre>

<p>所有代码均在之前的github目录中，可以自行查看。</p>

<p>4、编译生成App文件</p>

<p>因为需要给APP签名加权限，所以不要生成IPA文件，而是生成APP文件。等把签名与权限加好后，再手动用APP制作IPA文件。</p>

<p> 在Xcode中选择设备（IOS Device）（图3），编译（Build）（图4）。编译完成后，在工程的Products文件夹中可以看到刚刚编译好的APP文件，右键Show in Finder（图5），就可以在文件夹中显示。将APP复制到一个别的文件夹中，什么地方都可以，后面需要用到。</p>

<pre><code>![Alt text](/iamges/yueyu004.jpg)
</code></pre>

<p><img src="http://al1020119.github.io/images/yueyu004.png" title="Caption" ></p>

<p>5、制作ipa文件</p>

<p>将之前提到的ldid下载好后，将ldid文件放到/usr/bin中。</p>

<p>比如在 Download 目录下， sudo -i</p>

<p>然后 cp ldid /usr/bin/即可将文件拷贝到/usr/bin中。</p>

<p>然后对之前生成的文件，进行ldid签名</p>

<pre><code>![Alt text](/iamges/yueyu005.jpg)
</code></pre>

<p><img src="http://al1020119.github.io/images/yueyu005.png" title="Caption" ></p>

<ul>
<li><p>这个命令中“ldid -S” ，“ldid”与“-S”之间有一个空格。“-S”与“entitlements.xml”之间没有空格。“entitlements.xml”就是上面说到的XML文件，如果你的XML不是这个名，请将命令修改为你的XML文件名即可。</p></li>
<li><p>“-Sentitlements.xm”与“ipainstall.app”之间有一个空格。“ipainstall”是刚刚生成的APP文件，如果你的名字不一样，请修改为你的名字。“/“后面和APP的名字是一样的。  如果没有输出错误信息或是卡住（就是敲回车后没反应）就是添加权限成功了。</p></li>
</ul>


<p>6、生成ipa文件，安装</p>

<p>新建一个文件夹，命名为“Payload”。将刚刚添加好权限的APP文件放到这个文件夹中。右键“压缩Payload”，得到一个“.zip”文件，将这个ZIP文件的后缀名改为“.ipa”。好了，IPA文件就制作完成了。</p>

<p>然后通过itools安装，测试刚刚生成的文件</p>

<pre><code>![Alt text](/iamges/yueyu006.jpg)
</code></pre>

<p><img src="http://al1020119.github.io/images/yueyu006.png" title="Caption" ></p>

<p>整合了很多资源，有些地方弄的比较凌乱，后面加以完善</p>

<h1>检查iphone时候越狱</h1>

<p>今天项目中要用到检查iPhone是否越狱的方法。</p>

<p>Umeng统计的Mobclick.h里面已经包含了越狱检测的代码，可以直接使用</p>

<p>复制代码
复制代码</p>

<pre><code>/*方法名:
 *        isJailbroken
*介绍:
*        类方法，判断设备是否越狱，判断方法根据 apt和Cydia.app的path来判断
*参数说明:
*        无
*        
*
*/

#pragma mark utils api
// 类方法，判断当前设备是否已经越狱
+ (BOOL)isJailbroken;
// 类方法，判断你的App是否被破解
+ (BOOL)isPirated;
</code></pre>

<p>apt和Cydia的方式来进行判断的，没看见源码</p>

<p>然后再介绍两种方法来查看是否已经越狱，知其然知其所以然、、、</p>

<h3>apt</h3>

<pre><code>- (BOOL) asAP
{
return [[NSFileManager defaultManager] fileExistsAtPath:@"/private/var/lib/at/"];
4 }`
</code></pre>

<h3>system</h3>

<pre><code>`1 - (BOOL) successCallSystem
2 {
3 return (system("ls") == 0) ? YES : NO;
4 }`
</code></pre>

<h3>示例代码</h3>

<pre><code>static const char* jailbreak_apps[] =

  {
      "/Applications/Cydia.app",
      "/Applications/limera1n.app",
      "/Applications/greenpois0n.app",
      "/Applications/blackra1n.app",
      "/Applications/blacksn0w.app",
      "/Applications/redsn0w.app",
     "/Applications/Absinthe.app",
     NULL,
 };

 - (BOOL) isJailBroken
 {
     // Now check for known jailbreak apps. If we encounter one, the device is jailbroken.
     for (int i = 0; jailbreak_apps[i] != NULL; ++i)
     {
         if ([[NSFileManager defaultManager] fileExistsAtPath:[NSString stringWithUTF8String:jailbreak_apps[i]]])
         {
             //NSLog(@"isjailbroken: %s", jailbreak_apps[i]);
             return YES;
         }
     }

               // TODO: Add more checks? This is an arms-race we're bound to lose.

     return NO;
 }
</code></pre>

<hr />

<pre><code>@interface UIDevice (Helper)  
 - (BOOL)isJailbroken;  
 @end
</code></pre>

<hr />

<pre><code>@implementation UIDevice (Helper)  
- (BOOL)isJailbroken {  
BOOL jailbroken = NO;  
NSString *cydiaPath = @"/Applications/Cydia.app";  
NSString *aptPath = @"/private/var/lib/apt/";  
if ([[NSFileManager defaultManager] fileExistsAtPath:cydiaPath]) {  
 jailbroken = YES;  
}  
if ([[NSFileManager defaultManager] fileExistsAtPath:aptPath]) {  
 jailbroken = YES;  
}  
return jailbroken;  
}  
@end
</code></pre>

<hr />

<p>参考资源链接：</p>

<p><a href="http://since2006.com/blog/240/ios6-mobileinstallationinstall">http://since2006.com/blog/240/ios6-mobileinstallationinstall</a>
<a href="http://blog.sina.com.cn/s/blog_9cd1705d0101l4bo.html">http://blog.sina.com.cn/s/blog_9cd1705d0101l4bo.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[带你玩虐Ocotpress＋Github博客]]></title>
    <link href="http://al1020119.github.io/blog/2015/11/27/kuai-icocosdai-ni-kuai-su-jian-ocotpress+githubbo-ke/"/>
    <updated>2015-11-27T13:53:19+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/11/27/kuai-icocosdai-ni-kuai-su-jian-ocotpress+githubbo-ke</id>
    <content type="html"><![CDATA[<h5>简介</h5>

<p>Octopress是利用Jekyll博客引擎开发的一个博客系统，生成的静态页面能够很好的在github page上展现。号称是hacker专属的一个博客系统(A blogging framework for hackers.)</p>

<p>根据大家的反应，本文我就来介绍一下如何在苹果电脑(OS X 10.8.3)利用Octopress搭建一个Github博客。本文需要读者熟悉一些shell命令，并掌握基本的git操作。</p>

<p>目录</p>

<h2>一： 快速搭建</h2>

<ol>
<li>安装Ruby</li>
<li>安装Octopress</li>
<li>配置Octopress</li>
<li>将博客部署到GitHub上</li>
<li>开始写博客</li>
</ol>


<h2>二： 个性化配置（个性化初级篇）</h2>

<ol>
<li>Header（标题栏）</li>
<li>Navigation（导航栏）</li>
<li>footer（尾栏）</li>
<li>添加背景图片</li>
<li>LOGO图片</li>
<li>导航栏倒圆角</li>
<li>滑动返回顶部按钮</li>
<li>二维码展示</li>
</ol>


<h2>三： 个性化配置（个性化中级篇）</h2>

<ol>
<li>提高博客访问速度</li>
<li>设置链接在新窗口打开</li>
<li>首页文章以摘要形式展示</li>
<li>代码着色</li>
<li>修改代码生成css</li>
<li>添加侧边栏文章分类（category）</li>
<li>添加多说评论</li>
<li>自动为图片添加url前缀</li>
<li>添加访客统计</li>
</ol>


<h2>四： 个性化配置（个性化高级篇）</h2>

<ol>
<li>侧边栏</li>
<li>最新文章</li>
<li>GitHub Repos</li>
<li>微博秀</li>
<li>豆瓣展示</li>
<li>访客地图</li>
<li>酷站博客</li>
<li>最热文章</li>
<li>3D标签云与标签列表</li>
<li>相关文章功能</li>
<li>社会化评论与分享</li>
<li>为博文添加原文链接及声明</li>
<li>添加版权声明</li>
<li>公益404</li>
</ol>


<h2>五： 其他</h2>

<ol>
<li>mackdown语法<br></li>
</ol>


<hr />

<h1>一： 快速搭建</h1>

<h3>安装Ruby</h3>

<p>Octopress需要Ruby环境，RVM(Ruby Version Manager)负责安装和管理Ruby的环境。所以我们先在终端输入如下命令，来安装RVM：</p>

<pre><code>curl -L https://get.rvm.io | bash -s stable --ruby  
</code></pre>

<p>接着是安装Ruby 1.9.3，在终端依次运行如下命令：</p>

<pre><code>rvm install 1.9.3  
rvm use 1.9.3  
rvm rubygems latest  
</code></pre>

<p>完成上面的操作之后，运行ruby &ndash;version应该可以看到ruby 1.9.3环境已经安装好了。
参考：Installing Ruby With RVM</p>

<h3>安装Octopress</h3>

<p>在安装Octopress之前，请确保你的电脑上已经安装有git了，在终端输入git &ndash;version，应该可以看到电脑中的git版本(我电脑上输出:git version 1.7.12.4 (Apple Git-37))，如果没有显示相关内容，请先安装git。
git安装之后，利用git命令将octopress从github上clone到本机，如下命令：</p>

<pre><code>git clone git://github.com/imathis/octopress.git octopress  
cd octopress    # If you use RVM, You'll be asked if you trust  the .rvmrc file (say yes).  
ruby --version  # Should report Ruby 1.9.3  
</code></pre>

<p>接着安装相关依赖项：</p>

<pre><code>gem install bundler  
rbenv rehash    # If you use rbenv, rehash to be able to run the    bundle command  
bundle install  
</code></pre>

<p>最后安装默认的Octopress 主题。</p>

<pre><code>rake install  
</code></pre>

<h3>配置Octopress</h3>

<p>Octopress的作者已经尽量让配置简化了。大多数情况下只需要配置_config.yml和Rakefile文件即可。其中Rakefile是跟博客部署相关，一般情况下并不需要修改这个文件，除非使用了rsync。</p>

<p>config.yml是博客重要的一个配置文件，在config.yml文件中有三大配置项：Main Configs、Jekyll &amp; Plugins和3rd Party Settings。</p>

<p>一般，该文件中其中url是必须要填写的，这里的url是在github上创建的一个仓库地址，具体请看第四步中创建的地址。另外再修改一下title、subtitle和author，根据需求，在开启一些第三方组件服务。</p>

<p>关于_config.yml文件中的更多内容，请看这里的内容：Configuring Octopress</p>

<p>建议：最好把里面的twitter相关的信息全部删掉，否则由于GFW的原因，将会造成页面load很慢。同理，修改定制文件/source/_includes/custom/head.html 把google的自定义字体去掉。from唐巧的博文中—配置。</p>

<h3>将博客部署到GitHub上</h3>

<p>Github的Page service可以免费托管博客，并且还可以自定义域名。
首先需要在GitHub上创建一个仓库，并将仓库名称按照这样的方式进行命名：username.github.com或organization.github.com。等后面配置完毕之后，我们就可以在浏览器中使用页面地址</p>

<pre><code>http://username.github.com
</code></pre>

<p>来访问我们的博客。一般来说，我们希望在将博客的源码放到source分支下，并把生成的内容提交到master分支。</p>

<p>创建好仓库之后，我们需要利用octopress的一个配置rake任务来自动配置上面创建的仓库：可以让我们方便的部署GitHub page。在终端输入如下命令：
C代码  收藏代码</p>

<pre><code>$ rake setup_github_pages  
</code></pre>

<p>上面的命令会做一些事情(详细介绍看下面给出的参考链接)。其中最主要的就是创建一个_deploy目录，目录用来存放部署到master分支的内容。期间会要求你输入仓库的url，根据提示，进行输入即可。</p>

<p>完成上面的命令之后，我们就可以生成博客并真正的部署到仓库中了。执行如下命令：</p>

<pre><code>rake generate  
rake deploy  
</code></pre>

<p>上面的命令首先生成博客文件，并将生成的博客文件拷贝到_deploy/目录下，然后将这些内容添加到git中，并commit和push到仓库的master分支。</p>

<p>现在可以访问</p>

<pre><code>http://username.github.com
</code></pre>

<p>注意：有时候可能会有延时，要等几分钟才能打开。
至此，我们的博客已经完成基本的部署，不过博客的source需要单独提交，执行如下命令就可以将source提交到仓库的source分支下。</p>

<pre><code>$ git add .  
$ git commit -m 'Initial source commit'  
$ git push origin source  
</code></pre>

<p>如果在部署到仓库之前，需要先预览一下博客，可以在终端输入rake preview命令，然后就能在浏览器中进行本地预览访问了：</p>

<pre><code>http://127.0.0.1:4000/
</code></pre>

<p>或</p>

<pre><code>http://localhost:4000/
</code></pre>

<p>效果跟仓库中的一样。</p>

<h3>开始写博客</h3>

<p>Octopress为我们提供了一些task来创建博文和页面。博文必须存储在source/_posts目录下，并且需要按照Jekyll的命名规范对文章进行命名：YYYY-MM-DD-post-title.markdown。文章的名字会被当做url的一部分，而其中的日期用于对博文的区分和排序。</p>

<p>通过Octopress提供的task可以正确的按照命名规范创建一个博文，并且在博文中会附带常用的一些yaml元数据。只需要在终端输入如下命令：</p>

<pre><code>rake new_post["title"]  
</code></pre>

<p>其中title为博文的文件名，创建出来的文件默认是markdown格式。上面的命令会创建出这样一个文件：source/_posts/2013-08-03-title.markdown。打开这个文件，可以看到里面有如下一些内容了(告诉Jekyll博客引擎如何处理博文和页面)：</p>

<pre><code>layout: post  
title: "title"  
date: 2013-08-03 16:36  
comments: true  
categories:   
</code></pre>

<p>接着我们就可以在这个文件中写我们的博文啦。完成之后，我们可以预览和部署博文。下面是创建并部署博文的一个完整过程：</p>

<pre><code>$ rake new_post["New Post"]  
$ rake generate  
$ git add .  
$ git commit -am "Some comment here."   
$ git push origin source  
$ rake deploy  
</code></pre>

<h6>本节介绍了如何利用Octopress搭建一个Github博客，下面讲介绍桌面去个性化你的博客。</h6>

<hr />

<h1>个性化配置（初级篇）</h1>

<p>这几个部分是经常需要个性化定制的，在 source/<em>includes 中存在其对应的HTML文件，这是主题默认的文件，更换主题，更新octopress会被覆盖，所以应该编辑 source/</em>includes/custom 下的文件来实现修改。</p>

<h2>Header，Navigation，footer</h2>

<h3>Header（标题栏）</h3>

<p>标题栏显示的内容为 /source/<em>includes/custom/header.html 所实现的，其中title和subtitle在 </em>config.yml 中定义，你可以进行适量的修改：</p>

<pre><code>    &lt;hgroup&gt;
 &lt;h1&gt;&lt;a href="http://al1020119.github.io/"&gt;iOS梦工厂&lt;/a&gt;&lt;/h1&gt;

&lt;h2&gt;不战胜自己，何以改变未来！&lt;/h2&gt;

&lt;/hgroup&gt;
</code></pre>

<h3>Navigation（导航栏）</h3>

<p>可以自行为导航栏添加项目，链接至不同的页面，在 /source/_includes/custom/navigation.html 中编辑即可。</p>

<pre><code>&lt;ul class="main-navigation"&gt;
&lt;li&gt;&lt;a href="http://al1020119.github.io/"&gt;博客主页&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;&lt;a href="/blog/archives"&gt;文章列表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://al1020119.github.io/category-cloud"&gt;分类云&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://al1020119.github.io/about"&gt;关于&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</code></pre>

<p>当想添加一些页面，如“关于”页面，可以试验 rake new_page[&lsquo;name&rsquo;] 命令来创建，如 rake new_page[&lsquo;about&rsquo;] 后，会建立 source/about/index.html 文件，在此文件编辑，添加自己想要展示的内容，然后再 navigation.html 里添加正确的路径即可，如</p>

<pre><code>&lt;li&gt;&lt;a href="http://al1020119.github.io/about"&gt;关于&lt;/a&gt;&lt;/li&gt; 
</code></pre>

<h3>footer（尾栏）</h3>

<p>在 source/_includes/custom/footer.html 中编辑尾栏：</p>

<pre><code>&lt;p&gt;
    Copyright © 2015 - iCocos -
&lt;span class="credit"&gt;
      Powered by
      &lt;a href="http://octopress.org"&gt;Octopress&lt;/a&gt;
&lt;/span&gt;
&lt;/p&gt;
</code></pre>

<p>默认显示 Copyright@2013 - author - Powered by Octopress ，你可以添加自己想显示在尾栏的东西，第三方统计流量统计工具也可以添加到这，如CNZZ、Google analytics和百度统计等，使用这些工具可以更详细的分析网站流量，改善引流措施，完善网站，具体添加方法见统计工具与SEO。</p>

<h3>添加背景图片</h3>

<p>在 sass/custom/_styles.scss 中添加：</p>

<pre><code>html {
    background: #555555 url("/images/bg3.jpg");
    //background: #555555;
}

body &gt; div {
    background-image: none;
    //background: #F5F5D5
} //侧边栏

body &gt; div &gt; div { //文章内容
    background-image: none;
    //background: #F5F5D5; 
    //background: url("/images/bg.jpg");
}
</code></pre>

<p>将背景图片放入 source/images/ 中，修改上述代码中的路径指向想要的图片，即可 更改博客、侧边栏或文章的背景图片。博客使用背景图片后，与Header区不太和谐， 所以我在 /sass/base/_theme.scss 中将 header-bg 设置成透明色了。</p>

<h3>LOGO图片</h3>

<p>我所说的logo图片有两种，一个是打开一个网页时，标签栏上显示的小图片。还有一个是标题栏主标题旁的图片。</p>

<p>首先针对于第一种可以选择你喜欢的图片（大小适中），替换 source 目录下的 favicon.png 即可。</p>

<p>或者将logo图片放入 source/images 中，然后修改 source/_includes/head.html ，找到 favicon.png ，修改其路径指向你的图片即可。</p>

<p>对于主标题旁的图片需要在 sass/custom/_styles.scss 中填入如下语句：</p>

<pre><code>//Blog logo pic
@media only screen and (min-width: 550px) {

    body &gt; header h1{
            background: url("/images/logo1.png") no-repeat 0 1px;
            padding-left: 65px;
    }

    body &gt; header h2 { padding-left: 65px; }
}
</code></pre>

<p>根据自己情况进行修改即可。</p>

<h3>导航栏倒圆角</h3>

<p>我设置的header区背景色透明，所以导航栏的直角有些尖锐，在 sass/custom/_styles.scss 中添加如下语句，将其修改为圆角：</p>

<pre><code>//倒圆角
@media only screen and (min-width: 1040px) {
    body &gt; nav {
            @include border-top-radius(.4em);
    }

    body &gt; footer {
            @include border-bottom-radius(.4em);
    }
}
</code></pre>

<h3>滑动返回顶部按钮</h3>

<p>当文章较长，通常希望有一个返回顶部的按钮，如下方法实现了在页面右下方添加一个返回顶部的图片按钮，点击后可以滑动的返回顶部。</p>

<p>首先创建 source/javascripts/top.js ，实现滑动返回顶部效果，添加如下代码：</p>

<pre><code>function goTop(acceleration, time)
{
    acceleration = acceleration || 0.1;
    time = time || 16;

    var x1 = 0;
    var y1 = 0;
    var x2 = 0;
    var y2 = 0;
    var x3 = 0;
    var y3 = 0;

    if (document.documentElement)
    {
            x1 = document.documentElement.scrollLeft || 0;
            y1 = document.documentElement.scrollTop || 0;
    }
    if (document.body)
    {
            x2 = document.body.scrollLeft || 0;
            y2 = document.body.scrollTop || 0;
    }
    var x3 = window.scrollX || 0;
    var y3 = window.scrollY || 0;

    var x = Math.max(x1, Math.max(x2, x3));
    var y = Math.max(y1, Math.max(y2, y3));

    var speed = 1 + acceleration;
    window.scrollTo(Math.floor(x / speed), Math.floor(y / speed));

    if(x &gt; 0 || y &gt; 0)
    {
            var invokeFunction = "goTop(" + acceleration + ", " + time + ")";
            window.setTimeout(invokeFunction, time);
    }
}
</code></pre>

<p>然后创建 source/_includes/custom/totop.html ，设置返回顶部按钮样式和位置，代码如下：</p>

<pre><code>&lt;!--返回顶部开始--&gt;
&lt;div id="full" style="width:0px; height:0px; position:fixed; right:180px; bottom:150px; z-index:100; text-align:center; background-color:transparent; cursor:pointer;"&gt;
    &lt;a href="#" onclick="goTop();return false;"&gt;&lt;img src="http://al1020119.github.io/images/top.png" border=0 alt="返回顶部"&gt;&lt;/a&gt;
&lt;/div&gt;
&lt;script src="http://al1020119.github.io/javascripts/top.js" type="text/javascript"&gt;&lt;/script&gt;
&lt;!--返回顶部结束--&gt;
</code></pre>

<p>最后，还需要将返回顶部的图片放入 source/images ，命名为 top.png （或修改totop.html中图片的路径）。</p>

<h3>二维码展示</h3>

<p>在关于页面或边栏可以展示你的个人博客的二维码，方便移动终端扫描访问你的博客，插件主页 点击这里 。</p>

<p>在侧边栏显示，则将 qrcode.html 放入 source/<em>includes/custom/asides/ 中，在 </em>config.yml 中 default_asides 添加 custom/asides/qrcode.html 即可显示。</p>

<p>或者将 qrcode.html 代码添加到你想展示的页面的HTML文件中亦可。</p>

<hr />

<h1>个性化配置（中级篇）</h1>

<h3>提高博客访问速度</h3>

<p>因为“墙”的关系，所以Octopress建立以后会发现访问速度奇慢无比，竟然超过了40s。</p>

<p>仔细分析后我们发现其中都是一些被墙的请求报了404Error，所以导致访问博客巨慢无比，下面我们就一次阉割掉这些被墙的请求。T_T</p>

<h4>替换Google JS公共库</h4>

<p>Octopress默认使用的是Google的JS公共库地址，加载的过程无比的缓慢。因此我们要把它改为 百度的JS公共库 ，需要把 /source/_includes/head.html 文件中的Google公共库地址改为：</p>

<script src="//libs.baidu.com/jquery/1.7.2/jquery.min.js"></script>


<h4>去掉Twitter</h4>

<p>从上图可以看出加载失败的还有twitter，这个也得给去掉。</p>

<p>把在根目录下的 _config.yml 文件中Twitter内容给注释掉。</p>

<pre><code># Twitter
#twitter_user:
#twitter_tweet_button: true
</code></pre>

<p>把 \source_includes\after_footer.html 文件中的twitter内容给注释掉：</p>

<pre><code>include twitter_sharing.html
</code></pre>

<h4>删除Google font</h4>

<p>把在 \source_includes\custom\head.html 中的Google font样式给删除：</p>

<pre><code>&lt;link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css"&gt;
&lt;link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css"&gt;
</code></pre>

<h3>设置链接在新窗口打开</h3>

<p>在博文中，如果点击链接直接在本窗口打开了，那么用户体验就不是很好。而markdown的标准语法是不支持链接在新窗口打开的，虽然可以通过在markdown中直接写html标签来解决这个问题，但是这与markdown的简洁书写特性不符。但是我们可以通过设置Octopress来达到这种效果，即在 \source_includes\custom\head.html 文件中添加如下一段代码：</p>

<pre><code>&lt;script&gt;
function addBlankTargetForLinks () {
$('a[href^="http"]').each(function(){
  $(this).attr('target', '_blank');
});
}
$(document).bind('DOMNodeInserted', function(event) {
addBlankTargetForLinks();
});
&lt;/script&gt;
</code></pre>

<h3>首页文章以摘要形式展示</h3>

<p>2.在文章对应的markdown文件中，在需要显示在首页的文字后面添加 <!--more--> ，执行rake generate后在首页上会看到只显示&lt;!—more—>前面的文字，文字后面会显示 Read on 链接，点击后进入文字的详细页面;</p>

<p>1.如果想将Read on修改为中文，可以修改_config.yml文件</p>

<pre><code>excerpt_link: "Read on →"  #  "Continue reading" link text at the     bottom of excerpted articles
excerpt_link: "阅读全文→"  # "Continue reading" link text at the  bottom of excerpted articles
</code></pre>

<h3>代码着色</h3>

<p>Octopress使用的是Pygments来进行代码着色的，使用方式也比较简单如下所示：</p>

<figure class='code'><figcaption><span>xxx.java</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="c1">//java code</span>
</span></code></pre></td></tr></table></div></figure>


<p>Pygments支持的语言列表</p>

<h3>修改代码生成css</h3>

<p>当然你也可以修改Pygments生成的代码css样式。</p>

<p>Pygments默认提供了很多css样式，你可以在python shell中用下面命令列出当前pygments所支持的样式：</p>

<pre><code>&gt;&gt;&gt; from pygments.styles import STYLE_MAP
&gt;&gt;&gt; STYLE_MAP.keys()
['manni', 'igor', 'xcode', 'vim', 'autumn', 'vs', 'rrt', 'native', 'perldoc', 'borland', 'tango', 'emacs', 'friendly', 'monokai', 'paraiso-dark', 'colorful', 'murphy', 'bw', 'pastie', 'paraiso-light', 'trac', 'default', 'fruity']
&gt;&gt;&gt;
</code></pre>

<p>通过-S来选择，需要生成default的样式：</p>

<pre><code>pygmentize -S default -f html &gt; your/path/pygments.css
</code></pre>

<p>有时候Octopress会把我们想要展示的Ruby代码解析成HTML，如果只是想展示代码，而不让Octopress来解析，那么可以在代码前后加入和代码。</p>

<h3>添加侧边栏文章分类（category）</h3>

<p>1.在 plugins 目录下创建 category_list_tag.rb 文件，内容如下：</p>

<pre><code>module Jekyll 
class CategoryListTag &lt; Liquid::Tag 
def render(context) 
  html = "" 
  categories = context.registers[:site].categories.keys 
  categories.sort.each do |category| 
    posts_in_category = context.registers[:site].categories[category].size 
    category_dir = context.registers[:site].config['category_dir'] 
    category_url = File.join(category_dir, category.gsub(/_|\P{Word}/, '-').gsub(/-{2,}/, '-').downcase) 
    html &lt;&lt; "&lt;li class='category'&gt;&lt;a href='http://al1020119.github.io/#{category_url}/'&gt;#{category} (#{posts_in_category})&lt;/a&gt;&lt;/li&gt;\n" 
  end 
  html 
end 
end 
end

Liquid::Template.register_tag('category_list', Jekyll::CategoryListTag)
</code></pre>

<p>2.添加 source/_includes/asides/category_list.html 文件，内容如下：</p>

<pre><code>&lt;section&gt;
  &lt;h1&gt;Categories&lt;/h1&gt;
  &lt;ul id="categories"&gt;
  ***
    {百分号raw百分号}{百分号 category_list 百分号}{百分号endraw百分号} 
  ***
  &lt;/ul&gt;
&lt;/section&gt;
</code></pre>

<p>3.修改 _config.yml 文件，在 default_asides 项中添加 asides/category_list.html ，值之间以逗号隔开，值的先后顺序代表了侧边栏展现的先后顺序。</p>

<pre><code>default_asides: [asides/category_list.html, asides/recent_posts.html, asides/github.html, asides/delicious.html, asides/pinboard.html, asides/googleplus.html]
</code></pre>

<p>在侧边栏还可以添加其他组件，如微博、标签云等，添加方式和上面类似。</p>

<h3>添加多说评论</h3>

<p>Octopress默认自带了DISQUS，但是对于国内不是很好用。所以在经过考虑之后选择了国内比较流行的多说评论系统。 首先要去 多说网站注册 ，获取站点的 short_name 。</p>

<p>在 _config.yml 中添加</p>

<pre><code># duoshuo comments
duoshuo_comments: true
duoshuo_short_name: yourname 
</code></pre>

<p>在 ./source/_layouts/post.html 中的 disqus 代码</p>

<p>下方添加多说评论模块：</p>

<p>如果你希望一些单独的页面下方也放置评论功能，那么在 ./source/<em>layouts/page.html 中也做如上修改。 然后创建一个 ./source/</em>includes/post/duoshuo.html 文件，内容如下：</p>

<blockquote></blockquote>

<pre><code>&lt;div class="ds-thread" data-title="Octopress博客的个性化配置"&gt;&lt;/div&gt;
&lt;script type="text/javascript"&gt;
var duoshuoQuery = {short_name:"tianweili"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = 'http://static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
&lt;/script&gt;
</code></pre>

<p>最后再修改 _includes/article.html 文件，在</p>

<p>下方添加下面代码：</p>

<blockquote><p>注意：
以上所有F代表false，T代表true，更改对应的就可以
（不要问为撒）</p></blockquote>

<h3>自动为图片添加url前缀</h3>

<p>我把图片资源都 放在了七牛云存储 上，写博客时候就是用七牛的外链。但是这样有几个问题：</p>

<p>每次写博客插入图片外链地址时候都很麻烦，需要给每张图片都添加七牛外链地址url前缀；
如果以后更换了存储，那就麻烦了，需要依次编辑替换每个图片的url前缀
现在我们就使用一种灵活的方式来配置并自动生成图片的URL前缀：</p>

<p>首先修改 /plugins/image_tag.rb 文件，在 @img[&lsquo;class&rsquo;].gsub!(/&ldquo;/, &lsquo;&rsquo;) if @img[&lsquo;class&rsquo;] 后添加下面一行代码：</p>

<pre><code>./plugins/image_tag.rb
@img['src'] = Jekyll.configuration({})['static_file_prefix'] + @img['src'] if @img['src'][0] == '/'
</code></pre>

<p>然后再修改根目录下的 _config.yml 文件，添加如下配置：</p>

<pre><code># Add url prefix for image automatically
static_file_prefix: http://7u2i08.com1.z0.glb.clouddn.com
</code></pre>

<p>最后我们在插入图片的时候要记住不能再使用Markdown语法来写了，要 使用Ocotpress自定义的IMG标签来插入图片 。</p>

<p>本地预览先generate后preview，这样一来插入图片就灵活方便多了。</p>

<h3>添加访客统计</h3>

<p>本博客的访客统计系统使用的是Flag Counter，所以要 先去Flag Counter获取代码 。</p>

<p>拿到代码后添加 .\source_includes\custom\asides\flag_counter.html 文件：</p>

<pre><code>flag_counter.html
&lt;section&gt;
&lt;h1&gt;访客统计&lt;/h1&gt;
&lt;br/&gt;
&lt;a href="http://s07.flagcounter.com/more/2SH"&gt;&lt;img src="http://s07.flagcounter.com/count/2SH/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_1/flags_0/" alt="Flag Counter" border="0"&gt;&lt;/a&gt;
&lt;/section&gt;
</code></pre>

<p>将页面添加到侧边栏，在 ./_config.yml 配置文件中添加下面一行配置：</p>

<pre><code>default_asides: [……, custom/asides/flag_counter.html]
</code></pre>

<p>最后添加控制开关，在 ./_config.yml 配置文件中添加下面一行配置：</p>

<pre><code># Flag Counter
flag_counter: true
</code></pre>

<hr />

<h1>个性化配置（高级篇）</h1>

<p>在节章 中，已经搭建起了octopress博客。使用的是默认的主题，样式千篇一律，而且自带的一些功能和侧边栏并不适合国内的国情，得不到网络的支持，如facebook、twitter、google plus和disqus等。所以还是有必要进行一下改造，打造中国特色octopress博客的。</p>

<h3>第三方主题</h3>

<p>首先，你先要选定的是博客使用的第三方主题，因为如果你已经进行了很多的网页设置，添加了很多的插件，再来改主题，你就要面临悲剧了，你会发现你已经配置好的东西被替换掉了，这无疑会对你的热情带来打击。所以我们先来看看第三方主题。</p>

<p>你需要先找到自己喜欢的主题，之后可以在此主题上进行修改。 点击这里 是一个主题网站，给出了不同主题的预览图，使用该主题的博客和该主题的GitHub链接。选中你想要的，获得GitHub仓库地址，如下安装</p>

<pre><code>$ cd blog
$ git clone https://github.com/shashankmehta/greyshade.git ./themes/    greyshade
$ rake install['greyshade']
$ rake generate
</code></pre>

<p>这里我的博客在blog文件夹中，以安装greyshade主题为例。你按照自己的情况进行更改。 rake generate 后可以通过 rake preview 访问 <a href="http://localhost:4000">http://localhost:4000</a> 预览新的主题样式，不满意可以更换其他主题。</p>

<h3>侧边栏</h3>

<p>侧边栏可以添加的插件很多，新浪微博、豆瓣等很多网站都有相应的插件，也可以到 octopress的wiki页面 寻找。</p>

<p>侧边栏在 <em>config.yml 中设置，添加进 default_asides 中，先后顺序代表显示的先后顺序，各个侧边栏插件代码放入相应的位置即可，自己添加的一般放入 source/</em>includes/custom/asides ， default_asides 中默认从 _includes 之后路径开始写。</p>

<h3>最新文章</h3>

<p>首先说一下主题中可用的插件。</p>

<p>asides/recent_posts.html 是最近写的文章的一个展示，添加到 default_asides 中即可显示，在 _config.yml 中可以设置显示最近多少篇文章， recent_posts: 5 ，注意冒号后有空格。</p>

<h3>GitHub Repos</h3>

<p>asides/github.html 则是GitHub repos的一个展示，可以直接到达你的GitHub页面，在 _config.yml 中设置你的Github账号，并设置为 true 即可，如下：</p>

<pre><code>Github repositories
github_user: 812lcl   #我的github
github_repo_count: 0
github_show_profile_link: true
github_skip_forks: true
</code></pre>

<h3>微博秀</h3>

<p>新浪微博是一个信息传播非常迅速的媒介，如果你热衷于微博，可以在侧边栏添加自己的微博秀。首先需要获得自己的微博秀代码，链接为 <a href="http://app.weibo.com/tool/weiboshow">http://app.weibo.com/tool/weiboshow</a> ，进行相应的设置即可获得微博秀代码。</p>

<p>然后在 source/_includes/custom/asides 创建weibo.html，添加如下代码，刚刚获得的微博秀代码也要添加到相应位置：</p>

<pre><code>&lt;section&gt;
&lt;h1&gt;新浪微博&lt;/h1&gt;
&lt;ul id="weibo"&gt;
&lt;li&gt;

&lt;!-- 在此插入获得的微博秀代码 --&gt;

  &lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
</code></pre>

<p>最后在 default_asides 中加入 custom/asides/weibo.html 即可显示你的微博秀了。</p>

<h3>豆瓣展示</h3>

<p>你可以通过豆瓣读书、豆瓣电影、豆瓣音乐等多方面展示你自己，豆瓣也提供了类似微博秀的展示方式，添加方法也类似。获得豆瓣收藏秀的链接 <a href="http://www.douban.com/service/badgemakerjs">http://www.douban.com/service/badgemakerjs</a> ，根据自己的喜欢进行设置</p>

<p>然后在 source/_includes/custom/asides 创建douban.html，添加如下代码，刚刚获得的代码添加到 <div> 之间：</p>

<pre><code>&lt;section&gt;
&lt;h1&gt;My Douban&lt;/h1&gt;
&lt;div&gt;
&lt;!--添加到这--&gt;
&lt;/div&gt;
&lt;/section&gt;
</code></pre>

<p>最后在 default_asides 中加入 custom/asides/douban.html 显示你的豆瓣展示。</p>

<h3>访客地图</h3>

<p>效果如我的博客右侧那个精美的3D旋转地球所示，它可以显示访客数量，访客来自的地域，既有装饰作用，又有统计作用。它也有2D效果版，可以根据自己喜欢进行设置，地址在 这里 ，然后获得代码。</p>

<p>依然在 source/_includes/custom/asides 创建earth.html，代码如下：</p>

<pre><code>&lt;section&gt;
&lt;h1&gt;访客地图&lt;/h1&gt;
&lt;!--获得代码添加到这--&gt;
&lt;/section&gt;
</code></pre>

<p>在 default_asides 中加入 custom/asides/earth.html 显示你定制的访客地图。</p>

<h3>酷站博客</h3>

<p>你有一些经常去的网站、博客，想推荐给大家，则可以在侧边栏加上一个“酷站博客”，当然名字你自己取即可。</p>

<p>在 source/_includes/custom/asides 创建blog_link.html，代码如下：</p>

<pre><code>&lt;section&gt;
&lt;h1&gt;酷站博客&lt;/h1&gt;
&lt;ul&gt;
    &lt;li&gt;
    &lt;a href="http://blog.jobbole.com/"&gt;伯乐在线&lt;/a&gt;
    &lt;/li&gt;
    &lt;li&gt;
    &lt;a href="http://www.csdn.net/"&gt;CSDN&lt;/a&gt;
    &lt;/li&gt;
    &lt;li&gt;
    &lt;a href="http://www.cnblogs.com/"&gt;博客园&lt;/a&gt;
    &lt;/li&gt;
    &lt;li&gt;
    &lt;a href="http://coolshell.cn/"&gt;酷壳CoolShell&lt;/a&gt;
    &lt;/li&gt;
    &lt;li&gt;
    &lt;a href="http://www.cnblogs.com/Solstice/"&gt;陈硕&lt;/a&gt;
    &lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
</code></pre>

<p>可以自行添加喜爱网站，然后在 default_asides 中加入 custom/asides/blog_link.html 。</p>

<p>看到这，你应该很熟悉添加侧边栏的流程了吧。</p>

<h3>最热文章</h3>

<p>Octopress Popular Posts Plugin是根据Google page rank计算，展示出权值最高的文章，插件的项目主页为 点击这里 。</p>

<p>这个插件的安装与之前的方法不同，首先在 Gemfile 中添加</p>

<pre><code>gem 'octopress-popular-posts'
</code></pre>

<p>Gemfile 中的是bundle安装时安装的所有依赖的软件，然后用bundle安装</p>

<pre><code>bundle install
</code></pre>

<p>执行命令，将插件拷贝到你的source目录，如下：</p>

<pre><code>bundle exec octopress-popular-posts install
</code></pre>

<p>到这就安装完了，可以设置显示了，在 _config.yml 中设置，增加下面一行：</p>

<pre><code>popular_posts_count: 5      # Posts in the sidebar Popular Posts section
</code></pre>

<p>设置边栏显示文章数，最后在 default_asides 中添加 custom/asides/popular_posts.html ，即可显示出来。</p>

<p>这样就设置好了，同时建议将缓存的page rank文件添加进你的 .gitignore 中</p>

<pre><code>.page_rank
</code></pre>

<h3>3D标签云与标签列表</h3>

<p>octopress默认的只支持category的分类，而并没有tag。category和tag分别代表有序/无序的知识点归纳。一篇文章只能属于一个category，但可以有多个tag。原来的plugin下只有category_generator.rb插件，实现category功能，在github上有两个插件帮助实现了tag生成和tag cloud功能 插件1 ， 插件2 。但似乎并不支持中文，而category_generator.rb是支持中文的，所以我有样学样，改成了支持中文的，并且实现了3D标签云的，插件已经上传到 github 。clone到你博客的目录即可。</p>

<p>包含文件如下：</p>

<pre><code> ├─ plugins/
│  ├─ category_generator.rb
│  ├─ category_list.rb
│  ├─ category_tag_cloud.rb
│  ├─ tag_generator.rb
│  └─ tag_list.rb
└─ source/
   └─ _includes/
      └─ custom/
         └─ asides/
            ├─ category_cloud.html
            ├─ category_list.html
            ├─ tag_cloud.html
            └─ tag_list.html
</code></pre>

<p>其中 category_generator.rb 和 tag_generator.rb 定义了根据文章的category和tag标签分类存储文章的方法， category_tag_cloud.rb 则可以定义了根据category或tag生成3D标签云的方法。 category_list.rb 和 tag_list.rb 实现了将所有文章的category和tag列出来的方法，其中category可以显示文章个数，tag根据此标签文章多少，大小随着改变。</p>

<p>四个HTML文件则是category和tag的列表和3D标签云的侧边栏实现。需要哪个，在 default_asides 中添加即可。</p>

<p>还有一点需要注意，在_config.yml中默认设置了category的目录，需自己加入tag目录</p>

<pre><code>category_dir: blog/categories
tag_dir: blog/tags
</code></pre>

<p>这样可以观看效果了，不过3D效果的标签云，对于不支持flash的浏览器无效，如 safari 。</p>

<p>标签功能的实现，我参考了一下几篇文章：</p>

<p><a href="http://codemacro.com/2012/07/18/add-category-list-to-octopress/">为octopress添加分类(category)列表</a></p>

<p><a href="http://blog.log4d.com/2012/05/tag-cloud/">给 Octopress 加上标签功能</a></p>

<h3>相关文章功能</h3>

<p>此功能即根据当前阅读的文章，分析博客中其他与此相近的文章，进行推荐的一个功能，在octopress wiki中推荐的第三方插件中有一个插件实现此功能，项目主页 点击这里 。该插件，利用octopress自带的LSI实现对文章分析分类，然后进行推荐，但当文章较多时分类过慢，它推荐安装GSL来进行分类。我安装过这个功能，但不知道它是根据什么规则分类，而且之后不知道安装了什么，之后每次分类都会出错。你可以自己尝试一下，项目主页都有详细的步骤。</p>

<p>就在我想放弃这个功能的时候，我发现了它―― related_posts-jekyll_plugin 。这个插件很简单，只需下载_plugins/related_posts.rb放在自己的plugins文件夹中，然后在想添加相关文章推荐的地方添加如下语句：</p>

<pre><code>&lt;section&gt;
&lt;h2&gt;相关文章：&lt;/h2&gt;
  &lt;ul class="posts"&gt;

      &lt;li class="related"&gt;
      &lt;a href="http://al1020119.github.io/blog/2015/12/03/huan-cun-ji-zhi-shen-jiu/"&gt;自己写套缓存机制&lt;/a&gt;
      &lt;/li&gt;

      &lt;li class="related"&gt;
      &lt;a href="http://al1020119.github.io/blog/2015/12/03/you-xiu-cheng-xu-yuan-shi-zen-yao-xie-zhu-shi-de/"&gt;够逼格的注释习惯&lt;/a&gt;
      &lt;/li&gt;

      &lt;li class="related"&gt;
      &lt;a href="http://al1020119.github.io/blog/2015/12/03/nian-tie-shen-jiu/"&gt;粘贴深究&lt;/a&gt;
      &lt;/li&gt;

      &lt;li class="related"&gt;
      &lt;a href="http://al1020119.github.io/blog/2015/12/02/xiao-chu-jing-gao/"&gt;消除警告&lt;/a&gt;
      &lt;/li&gt;

      &lt;li class="related"&gt;
      &lt;a href="http://al1020119.github.io/blog/2015/12/02/quan-ping-fan-hui-(runtime)/"&gt;全屏返回（Runtime）&lt;/a&gt;
      &lt;/li&gt;

&lt;/ul&gt;
&lt;/section&gt;
</code></pre>

<p>我是在source/_layouts/post.html中加入的这些语句，这个html文件是打开博文时的布局，我将相关文章添加在博文的结束处。</p>

<p>这个插件是根据文章的tag进行分类的，根据所有博文与本篇文章共同tag的多少依次排序进行推荐，还是很简单有效的。</p>

<h3>社会化评论与分享</h3>

<h4>友言和加网</h4>

<p>octopress内置了disqus评论系统，不适合我国基本国情，所以需要用一些国内的第三方评论系统，如友言、多说，可以以微博、人人、QQ等账号登陆发表评论，网站通过验证后可以对评论进行分析，管理。</p>

<p>多说评论系统可参见 为 Octopress 添加多说评论系统 ，不多做介绍。</p>

<p>我主要使用的是友言的一套评论系统及插件，分享使用的是加网JiaThis。首先注册 友言 账号，否则无法进行后台管理。注册之后获得代码，添加到 source/_includes/post/share_comment.html 。加网 点击这里 ，定制自己喜欢的样式，获得代码也添加到上述文件中。</p>

<p>share_comment.html文件中代码如下（每个人不同）：</p>

<pre><code>&lt;!-- JiaThis BEGIN --&gt;
&lt;div class="jiathis_style_32x32"&gt;
    &lt;a class="jiathis_button_qzone"&gt;&lt;/a&gt;
    &lt;a class="jiathis_button_tsina"&gt;&lt;/a&gt;
    &lt;a class="jiathis_button_tqq"&gt;&lt;/a&gt;
    &lt;a class="jiathis_button_weixin"&gt;&lt;/a&gt;
    &lt;a class="jiathis_button_renren"&gt;&lt;/a&gt;
    &lt;a href="http://www.jiathis.com/share?uid=*******" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"&gt;&lt;/a&gt;
    &lt;a class="jiathis_counter_style"&gt;&lt;/a&gt;
&lt;/div&gt;
&lt;script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1361705530382241" charset="utf-8"&gt;&lt;/script&gt;
&lt;!-- JiaThis END --&gt;

&lt;!-- Baidu Button BEGIN 
&lt;div id="bdshare" class="bdshare_t bds_tools_32 get-codes-bdshare"&gt;
    &lt;a class="bds_tsina"&gt;&lt;/a&gt;
    &lt;a class="bds_qzone"&gt;&lt;/a&gt;
    &lt;a class="bds_tqq"&gt;&lt;/a&gt;
    &lt;a class="bds_renren"&gt;&lt;/a&gt;
    &lt;a class="bds_t163"&gt;&lt;/a&gt;
    &lt;a class="bds_hi"&gt;&lt;/a&gt;
    &lt;span class="bds_more"&gt;&lt;/span&gt;
    &lt;a class="shareCount"&gt;&lt;/a&gt;
&lt;/div&gt;
&lt;script type="text/javascript" id="bdshare_js" data="type=tools&amp;uid=6839808" &gt;&lt;/script&gt;
&lt;script type="text/javascript" id="bdshell_js"&gt;&lt;/script&gt;
&lt;script type="text/javascript"&gt;
    document.getElementById("bdshell_js").src = "http://bdimg.share.baidu.com/static/js/shell_v2.js?cdnversion=" + Math.ceil(new Date()/3600000)
&lt;/script&gt;
 Baidu Button END --&gt;

&lt;!-- UY BEGIN --&gt;
&lt;div id="uyan_frame"&gt;&lt;/div&gt;
&lt;script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=*******"&gt;&lt;/script&gt;
&lt;!-- UY END --&gt;
</code></pre>

<p>其中有一段代码注释掉了，那是我曾经添加的百度分享的代码，如果使用其他分享或评论，代码也可以添加到这。</p>

<p>现在功能代码在share_comment.html中了，下面需要使其显示到博文的底部。</p>

<p>首先在_config.yml中添加开关：</p>

<pre><code># comment and share
comment_share: true
</code></pre>

<p>然后在 source/_includes/post/sharing.html 中添加如下代码：</p>

<p>最后需要使你的网站通过友言的验证，才可以进行后台管理，后台可以进行评论管理、社交影响力分析、和评论栏的风格功能设置。</p>

<h4>评论热榜和最新评论侧边栏</h4>

<p>友言提供了多个嵌入式组件，如评论热榜、最新评论、评论计数等。我们可以将他们做成侧边栏进行展示，或在首页文章列表中，显示每篇文章的评论数目。</p>

<p>首先在你的友言后台管理中找到 安装设置->嵌入式组件 获得评论热榜和最新评论的代码，分别创建 source/<em>includes/custom/asides/uyan_hotcmt.html 和 source/</em>includes/custom/asides/uyan_newcmt.html ，代码如下：</p>

<pre><code>&lt;section&gt;
&lt;h1&gt;评论热榜&lt;/h1&gt;
&lt;div id="uyan_hotcmt_unit"&gt;&lt;/div&gt;
    &lt;script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=*******"&gt;&lt;/script&gt;
&lt;/section&gt;
&lt;section&gt;
&lt;h1&gt;最新评论&lt;/h1&gt;
&lt;div id="uyan_newcmt_unit"&gt;&lt;/div&gt;
    &lt;script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=*******"&gt;&lt;/script&gt;
&lt;/section&gt;
</code></pre>

<p>然后再 _config.yml 的 default_asides 中添加其路径即可显示在侧边栏中。</p>

<p>友言评论框、评论热榜、最新评论可以在后台进行设置，改变设置并不需要更改代码。</p>

<h4>评论计数显示</h4>

<p>友言提供评论计数功能，可以将每篇文章的评论数显示在博客首页相应文章题目旁。实现方法为：在 source/_includes/article.html 中</p>

<p>`</p>

<p> <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> `</p>

<p>的后边填入嵌入组件中获得的评论计数的代码，需要修改其中一些内容</p>

<pre><code>| &lt;a href="#comments" id="uyan_count_unit" du="" su=""&gt;0条评论&lt;/a&gt;
 &lt;script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=*******"&gt;&lt;/script&gt;
</code></pre>

<h3>为博文添加原文链接及声明</h3>

<p>可以为你的每篇博文末尾加上原文链接，方法很简单，只需创建 plugins/post_footer_filter.rb ，代码如下：</p>

<pre><code># post_footer_filter.rb
# Append every post some footer infomation like original url 
# Kevin Lynx
# 7.26.2012
#
require './plugins/post_filters'

module AppendFooterFilter
    def append(post)
            author = post.site.config['author']
            url = post.site.config['url']
            pre = post.site.config['original_url_pre']
            post.content + %Q[&lt;p class='post-footer'&gt;
                    #{pre or "original link:"}&lt;a    href='#{post.full_url}'&gt;#{post.full_url}&lt;/a&gt;&lt;br/&gt; written by &lt;a     href='#{url}'&gt;#{author}&lt;/a&gt; posted at &lt;a href='#{url}'&gt;#{url}&lt;/a&gt;&lt;/p&gt;]
    end
end

module Jekyll
    class AppendFooter &lt; PostFilter
            include AppendFooterFilter
            def pre_render(post)
                    post.content = append(post) if post.is_post?
            end
    end
end

Liquid::Template.register_filter AppendFooterFilter
</code></pre>

<p>并可以针对这一区域的样式进行美化，在 sass/custom/_style.scss 末尾增加下列内容：</p>

<pre><code>.post-footer{margin-top:10px;padding:5px;background:none repeat scroll 0pt 0pt #eee;font-size:90%;color:gray}
</code></pre>

<p>尊重原创，此功能来源 为octopress每篇文章添加一个文章信息 。</p>

<h3>添加版权声明</h3>

<p>这里所说的版权声明是指每篇文章后面的版权信息</p>

<p>首先source_includes\post目录中添加license.html文件，文件内容如下：</p>

<pre><code>&lt;DIV style="font-size:12px;BORDER-BOTTOM: #bbbbbb 1px solid; BORDER-LEFT: #bbbbbb 1px solid; BACKGROUND: #f6f6f6; HEIGHT: 120px; BORDER-TOP: #bbbbbb 1px solid; BORDER-RIGHT: #bbbbbb 1px solid" class=oec2003right&gt; 
&lt;DIV style="MARGIN-TOP: 10px; FLOAT: left; MARGIN-LEFT: 5px; MARGIN-RIGHT: 10px"&gt; 
&lt;IMG alt="" src="http://images.cnblogs.com/cnblogs_com/oec2003/219566/r_fw90100.jpg" width=90 height=100&gt;&lt;/DIV&gt; 
&lt;DIV style="LINE-HEIGHT: 200%; MARGIN-TOP: 10px; COLOR: #000000"&gt; 
作者： &lt;A href="http://oec2003.github.io/"&gt;冯威&lt;/A&gt; &lt;BR&gt; 
出处： &lt;A href="http://oec2003.github.io/"&gt;http://oec2003.github.io/&lt;/A&gt; 
&lt;BR&gt;本文基于&lt;a target="_blank" title="Creative Commons Attribution 2.5 China Mainland License" href="http://creativecommons.org/licenses/by/2.5/cn/"&gt; 
署名 2.5 中国大陆&lt;/a&gt;许可协议发布，欢迎转载，演绎或用于商业目的，但是必须保留本文的署名 
&lt;a href="http://oec2003.github.io/"&gt;冯威&lt;/a&gt;（包含链接）。 &lt;/DIV&gt;&lt;/DIV&gt; 
</code></pre>

<p>在sass\custom_styles.scss添加如下样式信息来控制版权信息的样式</p>

<pre><code>.oec2003right 
{ 
    background: #C3D9FF; 
    height:120px; 
    border:1px solid #BBBBBB; 
}

.oec2003right a:link 
{ 
    color: #0057b6; 
    text-decoration: none; 
} 
.oec2003right a:visited 
{ 
    color: #0057b6; 
    text-decoration: none; 
} 
.oec2003right a:active,a:hover 
{ 
    color: #0057b6; 
    text-decoration: underline; 
}
</code></pre>

<p>修改文件source_layouts\post.html</p>

<pre><code>在class中增加类类似的一行，修改为对应的html就可以
</code></pre>

<p>在_config.yml添加配置项用来控制是否显示页面的版权信息</p>

<pre><code># Post License 
post_license: true
</code></pre>

<h3>公益404</h3>

<p>在 source 目录下创建404.markdown，添加如下代码，即可实现公益404的功能，当你的网页出错找不到时，可以为公益尽一份力。</p>

<pre><code>layout: page
title: "404 Error"
date: 2013-10-10 19:17
comments: false
sharing: false
footer: false
---
&lt;script type="text/javascript" src="http://www.qq.com/404/  search_children,js" charset="utf-8&gt;&lt;/script&gt;
</code></pre>

<hr />

<h2>mackdown语法简介</h2>

<h3>下面简单介绍一下mackdown常用语法（mackdown语法程序员必备）</h3>

<ol>
<li><p>标题设置（让字体变大，和word的标题意思一样）
在Markdown当中设置标题，有两种方式：
第一种：通过在文字下方添加“=”和“-”，他们分别表示一级标题和二级标题。
第二种：在文字开头加上 “#”，通过“#”数量表示几级标题。（一共只有1~6级标题，1级标题字体最大）</p></li>
<li><p>块注释（blockquote）
通过在文字开头添加“>”表示块注释。（当>和文字之间添加五个blank时，块注释的文字会有变化。）</p></li>
<li><p>斜体
将需要设置为斜体的文字两端使用1个“*”或者“_”夹起来</p></li>
<li><p>粗体
将需要设置为斜体的文字两端使用2个“*”或者“_”夹起来</p></li>
<li><p>无序列表
在文字开头添加(<em>, +, and -)实现无序列表。但是要注意在(</em>, +, and -)和文字之间需要添加空格。（建议：一个文档中只是用一种无序列表的表示方式）</p></li>
<li><p>有序列表
使用数字后面跟上句号。（还要有空格）</p></li>
<li><p>链接（Links）
Markdown中有两种方式，实现链接，分别为内联方式和引用方式。
内联方式：This is an <a href="http://example.com/">example link</a>.
引用方式：
I get 10 times more traffic from <a href="http://google.com/" title="Google">Google</a> than from <a href="http://search.yahoo.com/" title="Yahoo Search">Yahoo</a> or <a href="http://search.msn.com/" title="MSN Search">MSN</a>.</p></li>
<li><p>图片（Images）
图片的处理方式和链接的处理方式，非常的类似。
内联方式：</p>

<p>  <code>![alt text](/path/to/img.jpg "Title")</code></p>

<p>  引用方式：</p>

<p>  <code>![alt text][id]</code></p>

<p>  <code>[id]: /path/to/img.jpg "Title"</code></p></li>
<li><p>代码（HTML中所谓的Code）
实现方式有两种：
第一种：简单文字出现一个代码框。使用<code>&lt;blockquote&gt;</code>。（<code>不是单引号而是左上角的ESC下面~中的</code>）
第二种：大片文字需要实现代码框。使用Tab和四个空格。</p></li>
<li><p>脚注（footnote）
实现方式如下：</p>

<p>  <code>hello[^hello]</code></p>

<p>  <code>[^hello]: hi</code></p></li>
<li><p>下划线
在空白行下方添加三条“-”横线。（前面讲过在文字下方添加“-”，实现的2级标题）</p></li>
</ol>


<p>相关参考</p>

<p><a href="http://www.cnblogs.com/itech/p/3800982.html">mackdoen语法简介</a></p>

<hr />

<p>版权声明：欢迎转载，请贴上源地址</p>

<p> <a href="https://al1020119.github.io">https://al1020119.github.io</a></p>

<p> <a href="http://www.cnblogs.com/iCocos/%EF%BC%88iOS%E6%A2%A6%E5%B7%A5%E5%8E%82%EF%BC%89">http://www.cnblogs.com/iCocos/（iOS梦工厂）</a></p>

<p>更多精彩请关注</p>

<p><a href="github%EF%BC%9Ahttps://github.com/al1020119?tab=repositories">github：https://github.com/al1020119?tab=repositories</a></p>

<!--more-->

]]></content>
  </entry>
  
</feed>
