<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[iOS梦工厂]]></title>
  <link href="http://al1020119.github.io/atom.xml" rel="self"/>
  <link href="http://al1020119.github.io/"/>
  <updated>2015-12-08T13:56:54+08:00</updated>
  <id>http://al1020119.github.io/</id>
  <author>
    <name><![CDATA[iCocos]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[相册深究]]></title>
    <link href="http://al1020119.github.io/blog/2015/12/15/xiang-ce-shen-jiu/"/>
    <updated>2015-12-15T13:38:22+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/12/15/xiang-ce-shen-jiu</id>
    <content type="html"><![CDATA[<h3>一. 概要</h3>

<p>在 iOS 设备中，照片和视频是相当重要的一部分。最近刚好在制作一个自定义的 iOS 图片选择器，顺便整理一下 iOS 中对照片框架的使用方法。在 iOS 8 出现之前，开发者只能使用 AssetsLibrary 框架来访问设备的照片库，这是一个有点跟不上 iOS 应用发展步伐以及代码设计原则但确实强大的框架，考虑到 iOS7 仍占有不少的渗透率，因此 AssetsLibrary 也是本文重点介绍的部分。而在 iOS8 出现之后，苹果提供了一个名为 PhotoKit 的框架，一个可以让应用更好地与设备照片库对接的框架，文末也会介绍一下这个框架。</p>

<p>另外值得强调的是，在 iOS 中，照片库并不只是照片的集合，同时也包含了视频。在 AssetsLibrary 中两者都有相同类型的对象去描述，只是类型不同而已。文中为了方便，大部分时候会使用「资源」代表 iOS 中的「照片和视频」。</p>

<h3>二. AssetsLibrary 组成介绍</h3>

<p>AssetsLibrary 的组成比较符合照片库本身的组成，照片库中的完整照片库对象、相册、相片都能在 AssetsLibrary 中找到一一对应的组成，这使到 AssetsLibrary 的使用变得直观而方便。</p>

<!--more-->


<ul>
<li>AssetsLibrary: 代表整个设备中的资源库（照片库），通过 AssetsLibrary 可以获取和包括设备中的照片和视频</li>
<li>ALAssetsGroup: 映射照片库中的一个相册，通过 ALAssetsGroup 可以获取某个相册的信息，相册下的资源，同时也可以对某个相册添加资源。</li>
<li>ALAsset: 映射照片库中的一个照片或视频，通过 ALAsset 可以获取某个照片或视频的详细信息，或者保存照片和视频。</li>
<li>ALAssetRepresentation: ALAssetRepresentation 是对 ALAsset 的封装（但不是其子类），可以更方便地获取 ALAsset 中的资源信息，每个 ALAsset 都有至少有一个 ALAssetRepresentation 对象，可以通过 defaultRepresentation 获取。而例如使用系统相机应用拍摄的 RAW + JPEG 照片，则会有两个 ALAssetRepresentation，一个封装了照片的 RAW 信息，另一个则封装了照片的 JPEG 信息。</li>
</ul>


<h3>三. AssetsLibrary 的基本使用</h3>

<p>AssetsLibrary 的功能很多，基本可以分为对资源的获取/保存两个部分，保存的部分相对简单，API 也比较少，因此这里不作详细介绍。获取资源的 API 则比较丰富了，一个常见的使用大量 AssetsLibrary API 的例子就是图片选择器（ALAsset Picker）。要制作一个图片选择器，思路应该是获取照片库-列出所有相册-展示相册中的所有图片-预览图片大图。</p>

<p>首先是要检查 App 是否有照片操作授权：</p>

<pre><code>NSString *tipTextWhenNoPhotosAuthorization; // 提示语
// 获取当前应用对照片的访问授权状态
ALAuthorizationStatus authorizationStatus = [ALAssetsLibrary authorizationStatus];
// 如果没有获取访问授权，或者访问授权状态已经被明确禁止，则显示提示语，引导用户开启授权
if (authorizationStatus == ALAuthorizationStatusRestricted || authorizationStatus == ALAuthorizationStatusDenied) {
    NSDictionary *mainInfoDictionary = [[NSBundle mainBundle] infoDictionary];
    NSString *appName = [mainInfoDictionary objectForKey:@"CFBundleDisplayName"];
    tipTextWhenNoPhotosAuthorization = [NSString stringWithFormat:@"请在设备的\"设置-隐私-照片\"选项中，允许%@访问你的手机相册", appName];
    // 展示提示语
}
</code></pre>

<p>如果已经获取授权，则可以获取相册列表：</p>

<pre><code>_assetsLibrary = [[ALAssetsLibrary alloc] init];
_albumsArray = [[NSMutableArray alloc] init];
[_assetsLibrary enumerateGroupsWithTypes:ALAssetsGroupAll usingBlock:^(ALAssetsGroup *group, BOOL *stop) {
    if (group) {
        [group setAssetsFilter:[ALAssetsFilter allPhotos]];
        if (group.numberOfAssets &gt; 0) {
            // 把相册储存到数组中，方便后面展示相册时使用
            [_albumsArray addObject:group];
        }
    } else {
        if ([_albumsArray count] &gt; 0) {
            // 把所有的相册储存完毕，可以展示相册列表
        } else {
            // 没有任何有资源的相册，输出提示
        }
    }
} failureBlock:^(NSError *error) {
    NSLog(@"Asset group not found!\n");
}];
</code></pre>

<p>上面的代码中，遍历出所有的相册列表，并把相册中资源数不为空的相册 ALAssetGroup 对象的引用储存到一个数组中。这里需要强调几点：</p>

<ul>
<li>iOS中允许相册为空，即相册中没有任何资源，如果不希望获取空相册，则需要像上面的代码中那样手动过滤</li>
<li>ALAssetsGroup 有一个 setAssetsFilter 的方法，可以传入一个过滤器，控制只获取相册中的照片或只获取视频。一旦设置过滤，ALAssetsGroup 中资源列表和资源数量的获取也会被自动更新。</li>
<li>整个 AssetsLibrary 中对相册、资源的获取和保存都是使用异步处理（Asynchronous），这是考虑到资源文件体积相当比较大（还可能很大）。例如上面的遍历相册操作，相册的结果使用 block 输出，如果相册遍历完毕，则最后一次输出的 block 中的 group 参数值为 nil。而 stop 参数则是用于手工停止遍历，只要把 *stop 置 YES，则会停止下一次的遍历。关于这一点常常会引起误会，所以需要注意。</li>
</ul>


<p>现在，已经可以获取相册了，接下来是获取相册中的资源：</p>

<pre><code>_imagesAssetArray = [[NSMutableArray alloc] init];
[assetsGroup enumerateAssetsWithOptions:NSEnumerationReverse usingBlock:^(ALAsset *result, NSUInteger index, BOOL *stop) {
    if (result) {
        [_imagesAssetArray addObject:result];
    } else {
        // result 为 nil，即遍历相片或视频完毕，可以展示资源列表
    }
}];
</code></pre>

<p>跟遍历相册的过程类似，遍历相片也是使用一系列的异步方法，其中上面的方法所输出的 block 中，除了 result 参数表示资源信息，stop 用于手工停止遍历外，还提供了一个 index 参数，这个参数表示资源的索引。一般来说，展示资源列表都会使用缩略图（result.thumbnail），因此即使资源很多，遍历资源的速度也会相当快。但如果确实需要加载资源的高清图或者其他耗时的处理，则可以利用上面的 index 参数和 stop 参数做一个分段拉取资源。例如：</p>

<pre><code>NSUInteger _targetIndex; // index 目标值，拉取资源直到这个值就手工停止拉取
NSUInteger _currentIndex; // 当前 index，每次拉取资源时从这个值开始

_targetIndex = 50;
_currentIndex = 0;

- (void)loadAssetWithAssetsGroup:(assetsGroup *)assetsGroup {
    [assetsGroup enumerateAssetsAtIndexes:[NSIndexSet indexSetWithIndex:_currentIndex] options:NSEnumerationReverse usingBlock:^(ALAsset *result, NSUInteger index, BOOL *stop) {
        _currentIndex = index;
        if (index &gt; _targetIndex) {
            // 拉取资源的索引如果比目标值大，则停止拉取
            *stop = YES;
        } else {
            if (result) {
                [_imagesAssetArray addObject:result];
            } else {
                // result 为 nil，即遍历相片或视频完毕
            }
        }
    }];
}
</code></pre>

<p>// 之前拉取的数据已经显示完毕，需要展示新数据，重新调用 loadAssetWithAssetsGroup 方法，并根据需要更新 _targetIndex 的值</p>

<p>最后一步是获取图片详细信息，例如：</p>

<pre><code>// 获取资源图片的详细资源信息，其中 imageAsset 是某个资源的 ALAsset 对象
ALAssetRepresentation *representation = [imageAsset defaultRepresentation];
// 获取资源图片的 fullScreenImage
UIImage *contentImage = [UIImage imageWithCGImage:[representation fullScreenImage]];
</code></pre>

<p>对于一个 ALAssetRepresentation，里面包含了图片的多个版本。最常用的是 fullResolutionImage 和 fullScreenImage。fullResolutionImage 是图片的原图，通过 fullResolutionImage 获取的图片没有任何处理，包括通过系统相册中“编辑”功能处理后的信息也没有被包含其中，因此需要展示“编辑”功能处理后的信息，使用 fullResolutionImage 就比较不方便，另外 fullResolutionImage 的拉取也会比较慢，在多张 fullResolutionImage 中切换时能明显感觉到图片的加载过程。因此这里建议获取图片的 fullScreenImage，它是图片的全屏图版本，这个版本包含了通过系统相册中“编辑”功能处理后的信息，同时也是一张缩略图，但图片的失真很少，缺点是图片的尺寸是一个适应屏幕大小的版本，因此展示图片时需要作出额外处理，但考虑到加载速度非常快的原因（在多张图片之间切换感受不到图片加载耗时），仍建议使用 fullScreenImage。</p>

<p>系统相册的处理过程大概也是如上，可以看出，在整个过程中并没有使用到图片的 fullResolutionImage，从相册列表展示到最终查看资源，都是使用缩略图，这也是 iOS 相册加载快的一个重要原因。</p>

<h3>三. AssetsLibrary 的坑点</h3>

<p>作为一套老框架，AssetsLibrary 不但有坑，而且还不少，除了上面提到的资源异步拉取时需要注意的事项，下面几点也是值得注意的：</p>

<h6>1. AssetsLibrary 实例需要强引用</h6>

<p>实例一个 AssetsLibrary 后，如上面所示，我们可以通过一系列枚举方法获取到需要的相册和资源，并把其储存到数组中，方便用于展示。但是，当我们把这些获取到的相册和资源储存到数组时，实际上只是在数组中储存了这些相册和资源在 AssetsLibrary 中的引用（指针），因而无论把相册和资源储存数组后如何利用这些数据，都首先需要确保 AssetsLibrary 没有被 ARC 释放，否则把数据从数组中取出来时，会发现对应的引用数据已经丢失（参见下图）。这一点较为容易被忽略，因此建议在使用 AssetsLibrary 的 viewController 中，把 AssetsLibrary 作为一个强持有的 property 或私有变量，避免在枚举出 AssetsLibrary 中所需要的数据后，AssetsLibrary 就被 ARC 释放了。</p>

<p>如下图：实例化一个 AssetsLibrary 的局部变量，枚举所有相册并储存在名为 _albumsArray 的数组中，展示相册时再次查看数组，发现 ALAssetsGroup 中的数据已经丢失。</p>

<pre><code>ALAssetsLibrary_release
</code></pre>

<h6>2. AssetsLibrary 遵循写入优先原则</h6>

<p>写入优先也就是說，在利用 AssetsLibrary 读取资源的过程中，有任何其它的进程（不一定是同一个 App）在保存资源时，就会收到 ALAssetsLibraryChangedNotification，让用户自行中断读取操作。最常见的就是读取 fullResolutionImage 时，用进程在写入，由于读取 fullResolutionImage 耗时较长，很容易就会 exception。</p>

<h6>3. 开启 Photo Stream 容易导致 exception</h6>

<p>本质上，这跟上面的 AssetsLibrary 遵循写入优先原则是同一个问题。如果用户开启了共享照片流（Photo Stream），共享照片流会以 mstreamd 的方式“偷偷”执行，当有人把相片写入 Camera Roll 时，它就会自动保存到 Photo Stream Album 中，如果用户刚好在读取，那就跟上面说的一样产生 exception 了。由于共享照片流是用户决定是否要开启的，所以开发者无法改变，但是可以通过下面的接口在需要保护的时刻关闭监听共享照片流产生的频繁通知信息。</p>

<p>[ALAssetsLibrary disableSharedPhotoStreamsSupport];</p>

<h3>四. PhotoKit 简介</h3>

<p>PhotoKit 是一套比 AssetsLibrary 更完整也更高效的库，对资源的处理跟 AssetsLibrary 也有很大的不同。</p>

<p>首先简单介绍几个概念：</p>

<ul>
<li>PHAsset: 代表照片库中的一个资源，跟 ALAsset 类似，通过 PHAsset 可以获取和保存资源</li>
<li>PHFetchOptions: 获取资源时的参数，可以传 nil，即使用系统默认值</li>
<li>PHFetchResult: 表示一系列的资源集合，也可以是相册的集合</li>
<li>PHAssetCollection: 表示一个相册或者一个时刻，或者是一个「智能相册（系统提供的特定的一系列相册，例如：最近删除，视频列表，收藏等等，如下图所示）</li>
<li>PHImageManager: 用于处理资源的加载，加载图片的过程带有缓存处理，可以通过传入一个 PHImageRequestOptions 控制资源的输出尺寸等规格</li>
<li>PHImageRequestOptions: 如上面所说，控制加载图片时的一系列参数</li>
</ul>


<p>下图中 UITableView 的第二个 section 就是 PhotoKit 所列出的所有智能相册</p>

<p>photoKit001.png</p>

<p>再列出几个代码片段，展示如何获取相册以及某个相册下资源的代码：</p>

<pre><code>// 列出所有相册智能相册
PHFetchResult *smartAlbums = [PHAssetCollection fetchAssetCollectionsWithType:PHAssetCollectionTypeSmartAlbum subtype:PHAssetCollectionSubtypeAlbumRegular options:nil];

// 列出所有用户创建的相册
PHFetchResult *topLevelUserCollections = [PHCollectionList fetchTopLevelUserCollectionsWithOptions:nil];

// 获取所有资源的集合，并按资源的创建时间排序
PHFetchOptions *options = [[PHFetchOptions alloc] init];
options.sortDescriptors = @[[NSSortDescriptor sortDescriptorWithKey:@"creationDate" ascending:YES]];
PHFetchResult *assetsFetchResults = [PHAsset fetchAssetsWithOptions:options];

// 在资源的集合中获取第一个集合，并获取其中的图片
PHCachingImageManager *imageManager = [[PHCachingImageManager alloc] init];
PHAsset *asset = assetsFetchResults[0];
[imageManager requestImageForAsset:asset
                         targetSize:SomeSize
                        contentMode:PHImageContentModeAspectFill
                            options:nil
                      resultHandler:^(UIImage *result, NSDictionary *info) {

                          // 得到一张 UIImage，展示到界面上

                      }];
</code></pre>

<p>结合上面几个代码片段上看，PhotoKit 相对 AssetsLibrary 主要有三点重要的改进：</p>

<ul>
<li>从 AssetsLibrary 中获取数据，无论是相册，还是资源，本质上都是使用枚举的方式，遍历照片库取得相应的数据。而 PhotoKit 则是通过传入参数，直接获取相应的数据，因而效率会提高不少。</li>
<li>在 AssetsLibrary 中，相册和资源是对应不同的对象（ALAssetGroup 和 ALAsset），因此获取相册和获取资源是两个完全没有关联的接口。而 PhotoKit 中则有 PHFetchResult 这个可以统一储存相册或资源的对象，因此处理相册和资源时也会比较方便。</li>
<li>PhotoKit 返回资源结果时，同时返回了资源的元数据，获取元数据在 AssetsLibrary 中是很难办到的一件事。同时通过 PHAsset，开发者还能直接获取资源是否被收藏（favorite）和隐藏（hidden），拍摄图片时是否开启了 HDR 或全景模式，甚至能通过一张连拍图片获取到连拍图片中的其他图片。这也是文章开头说的，PhotoKit 能更好地与设备照片库接入的一个重要因素。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[看我怎么拿到设备信息]]></title>
    <link href="http://al1020119.github.io/blog/2015/12/15/kan-wo-zen-yao-na-dao-she-bei-xin-xi/"/>
    <updated>2015-12-15T13:36:55+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/12/15/kan-wo-zen-yao-na-dao-she-bei-xin-xi</id>
    <content type="html"><![CDATA[<h4>设备唯一标识符：</h4>

<ul>
<li>1.已禁用-[UIDevice uniqueIdentifier]</li>
</ul>


<p>　　苹果总是把用户的隐私看的很重要。-[UIDevice uniqueIdentifier]在iOS5实际在iOS5的时候已经被遗弃了，但是iOS7中已经完全的禁用了它。Xcode5甚至不会允许你编译包含了指引到-[UIDevice uniqueIdentifier]的app。此外，iOS7之前的使用了-[UIDevice uniqueIdentifier] 的app如果在iOS7上运行，它不会返回设备的UUID，而是会返回一串字符串，以FFFFFFFF开头，跟着-[UIDevice identifierForVendor]的十六进制值。</p>

<!--more-->


<ul>
<li>2.MAC地址不能再用来设别设备</li>
</ul>


<p>　　还有一个生成iOS设备唯一标示符的方法是使用iOS设备的Media Access Control（MAC）地址。一个MAC地址是一个唯一的号码，它是物理网络层级方面分配给网络适配器的。这个地址苹果还有其他的名字，比如说是硬件地址（Hardware Address)或是Wifi地址，都是指同样的东西。</p>

<p>　　有很多工程和框架都使用这个方法来生成唯一的设备ID。比如说ODIN。然而，苹果并不希望有人通过MAC地址来分辨用户，所以如果你在iOS7系统上查询MAC地址，它现在只会返回02:00:00:00:00:00。</p>

<p>现在苹果明确的表明你应该使用-[UIDevice identifierForVendor]或是-[ASIdentifierManager advertisingIdentifier]来作为你框架和应用的唯一标示符。坦白的来说，应对这些变化也不是那么的难，见以下代码片段：</p>

<pre><code>NSString *identifierForVendor = [[UIDevice currentDevice].identifierForVendor UUIDString]; 
NSString *identifierForAdvertising = [[ASIdentifierManager sharedManager].advertisingIdentifier UUIDString]; 
</code></pre>

<p>每种方法都适配一种特别的用法：</p>

<p>　　identifierForVendor对供应商来说是唯一的一个值，也就是说，由同一个公司发行的的app在相同的设备上运行的时候都会有这个相同的标识符。然而，如果用户删除了这个供应商的app然后再重新安装的话，这个标识符就会不一致。</p>

<p>　　advertisingIdentifier会返回给在这个设备上所有软件供应商相同的 一个值，所以只能在广告的时候使用。这个值会因为很多情况而有所变化，比如说用户初始化设备的时候便会改变。</p>

<pre><code>-(void) setKeyChainValue
{
    KeychainItemWrapper *keyChainItem=[[KeychainItemWrapper alloc]initWithIdentifier:@"TestUUID" accessGroup:@"XXXXXX.h.HelloWorld"];
    NSString *strUUID = [keyChainItem objectForKey:(id)kSecValueData];
    if (strUUID==nil||[strUUID isEqualToString:@""])
    {
        [keyChainItem setObject:[self gen_uuid] forKey:(id)kSecValueData];
    }
    [keyChainItem release];

}

-(NSString *) gen_uuid
{
    CFUUIDRef uuid_ref=CFUUIDCreate(nil);
    CFStringRef uuid_string_ref=CFUUIDCreateString(nil, uuid_ref);
    CFRelease(uuid_ref);
    NSString *uuid=[NSString stringWithString:uuid_string_ref];
    CFRelease(uuid_string_ref);
    return uuid;
}  
</code></pre>

<h4>获取用户信息</h4>

<pre><code>-(void)getDeviceInfo{
    UIDevice *curDevice = [UIDevice currentDevice];

    iPhoneInfoModel *model = [[iPhoneInfoModel alloc] init];

    // 用户名称
    NSString *deviceInfo = [NSString stringWithFormat:@"%@", curDevice.name];
    model.key = @"名称:";
    model.value = deviceInfo;
    [self.infoArray addObject:model];

    // 系统信息
    iPhoneInfoModel *systemModel = [[iPhoneInfoModel alloc] init];
    NSString *systemInfo = [NSString stringWithFormat:@"%@(%@)", curDevice.systemName, curDevice.systemVersion];
    systemModel.key = @"系统:";
    systemModel.value = systemInfo;
    [self.infoArray addObject:systemModel];

    // UUID获取
    iPhoneInfoModel *uuidModel = [[iPhoneInfoModel alloc] init];
    NSString *uuidInfo = [NSString stringWithFormat:@"%@", [[curDevice identifierForVendor] UUIDString]];
    uuidModel.key = @"UUID:";
    uuidModel.value = uuidInfo;
    [self.infoArray addObject:uuidModel];
}
</code></pre>

<h4>获取屏幕信息</h4>

<pre><code>-(void)getScreenInfo{
    NSInteger kHeight = (NSInteger)kScreenHeight;
    NSString *screenSize = @"";
    NSInteger abs = 1;

    switch (kHeight) {
        case 480:
            screenSize = @"3.5寸";
            break;
        case 568:
            screenSize = @"4.0寸";
            abs = 2;
            break;
        case 667:
            screenSize = @"4.7寸";
            abs = 2;
            break;
        case 736:
            screenSize = @"5.5寸";
            abs = 2;
            break;
        default:
            break;
    }

    NSString *screenInfo = [NSString stringWithFormat:@"%@(%.0f*%.0f)", screenSize, kScreenWidth * abs, kScreenHeight * abs];
    iPhoneInfoModel *model = [[iPhoneInfoModel alloc] init];
    model.key = @"屏幕:";
    model.value = screenInfo;
    [self.infoArray addObject:model];
}
</code></pre>

<h4>获取运营商信息</h4>

<pre><code>-(void)getNetInfo{
    CTTelephonyNetworkInfo *info = [[CTTelephonyNetworkInfo alloc] init];

    // 运营商
    CTCarrier *carriver = info.subscriberCellularProvider;
    NSString *carriverName = [carriver carrierName];

    NSString *netInfo = [NSString stringWithFormat:@"%@", carriverName];
    iPhoneInfoModel *model = [[iPhoneInfoModel alloc] init];
    model.key = @"运营商:";
    model.value = netInfo;
    [self.infoArray addObject:model];
}
</code></pre>

<h4>获取电池信息</h4>

<pre><code>-(void)getBetaryInfo{
    UIDevice *curDevice = [UIDevice currentDevice];
    CGFloat batteryLevel = curDevice.batteryLevel * 100;
    NSString *batteryState = @"";
    if (curDevice.batteryState == UIDeviceBatteryStateCharging) {
        batteryState = [NSString stringWithFormat:@"正在充电--%.0f%%", fabs(curDevice.batteryLevel * 100)];
    }else if (curDevice.batteryState == UIDeviceBatteryStateFull){
        batteryState = [NSString stringWithFormat:@"满电量"];
    }else{
        batteryState = [NSString stringWithFormat:@"剩余电量 %.0f%%", fabs(curDevice.batteryLevel * 100)];
    }
    iPhoneInfoModel *model = [[iPhoneInfoModel alloc] init];
    model.key = @"电池:";
    model.value = batteryState;
    [self.infoArray addObject:model];
}
</code></pre>

<h4>获取内存信息</h4>

<pre><code>-(void)getMemInfo{
    vm_statistics_data_t    vmStats;
    mach_msg_type_number_t  infoCount = HOST_VM_INFO_COUNT;
    kern_return_t           kernReturn = host_statistics(mach_host_self(), HOST_VM_INFO, (host_info_t)&amp;vmStats, &amp;infoCount);

    double total = 0.0;
    double avalible = 0.0;

    if (kernReturn == KERN_SUCCESS) {
        total = vm_page_size * (vmStats.free_count + vmStats.active_count + vmStats.inactive_count + vmStats.wire_count) / 1024 / 1024.0;
        avalible = (vm_page_size * vmStats.free_count) / 1024 / 1024.0;
    }
    NSString *memInfo = [NSString stringWithFormat:@"%.2fM", avalible];
    iPhoneInfoModel *model = [[iPhoneInfoModel alloc] init];
    model.key = @"可用内存:";
    model.value = memInfo;
    [self.infoArray addObject:model];
}
</code></pre>

<h6>设备信息汇总：</h6>

<pre><code>NSDictionary* infoDict =[[NSBundle mainBundle] infoDictionary];
NSString* versionNum =[infoDict objectForKey:@"CFBundleVersion"];
NSString*appName =[infoDict objectForKey:@"CFBundleDisplayName"];
NSString*text =[NSString stringWithFormat:@"%@ %@",appName,versionNum];
</code></pre>

<h6>手机序列号</h6>

<pre><code>    NSString* identifierNumber = [[UIDevice currentDevice] uniqueIdentifier]; 
    NSLog(@"手机序列号: %@",identifierNumber); 
</code></pre>

<h6>手机别名： 用户定义的名称</h6>

<pre><code>    NSString* userPhoneName = [[UIDevice currentDevice] name]; 
    NSLog(@"手机别名: %@", userPhoneName); 
</code></pre>

<h6>设备名称</h6>

<pre><code>    NSString* deviceName = [[UIDevice currentDevice] systemName]; 
    NSLog(@"设备名称: %@",deviceName ); 
</code></pre>

<h6>手机系统版本</h6>

<pre><code>    NSString* phoneVersion = [[UIDevice currentDevice] systemVersion]; 
    NSLog(@"手机系统版本: %@", phoneVersion); 
</code></pre>

<h6>手机型号</h6>

<pre><code>    NSString* phoneModel = [[UIDevice currentDevice] model]; 
    NSLog(@"手机型号: %@",phoneModel ); 
</code></pre>

<h6>地方型号  （国际化区域名称）</h6>

<pre><code>    NSString* localPhoneModel = [[UIDevice currentDevice] localizedModel]; 
    NSLog(@"国际化区域名称: %@",localPhoneModel ); 

    NSDictionary *infoDictionary = [[NSBundle mainBundle] infoDictionary]; 
</code></pre>

<h6>当前应用名称</h6>

<pre><code>    NSString *appCurName = [infoDictionary objectForKey:@"CFBundleDisplayName"]; 
    NSLog(@"当前应用名称：%@",appCurName); 
</code></pre>

<h6>当前应用软件版本  比如：1.0.1</h6>

<pre><code>    NSString *appCurVersion = [infoDictionary objectForKey:@"CFBundleShortVersionString"]; 
    NSLog(@"当前应用软件版本:%@",appCurVersion); 
</code></pre>

<h6>当前应用版本号码   int类型</h6>

<pre><code>    NSString *appCurVersionNum = [infoDictionary objectForKey:@"CFBundleVersion"]; 
    NSLog(@"当前应用版本号码：%@",appCurVersionNum); 
</code></pre>

<p>参考文章：<a href="http://www.jianshu.com/p/b83b0240bd0e">http://www.jianshu.com/p/b83b0240bd0e</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS9-CoreSpotlight]]></title>
    <link href="http://al1020119.github.io/blog/2015/12/15/ios9-corespotlight/"/>
    <updated>2015-12-15T13:35:30+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/12/15/ios9-corespotlight</id>
    <content type="html"><![CDATA[<p>iOS9 Day-by-Day是作者Chris Grant新开的一个系列博客，覆盖了iOS开发者必须知道的关于iOS 9的新技术与API，并且还进行了实际操作演练，每篇文章中相关的代码Chris都会将其托管到GitHub。</p>

<p>在第一篇文章中，Chris介绍了iOS 9的三种搜索API，分别为：</p>

<ul>
<li><p>NSUserActivity，索引用户活动以及App的状态。</p></li>
<li><p>Web Markup，Web内容可被搜索。</p></li>
<li><p>iOS 9新增的CoreSpotlight.framework提供了增、删、改、查等搜索API，可以索引App的内容。
译文如下：</p></li>
</ul>


<p>在苹果发布iOS 9之前，你只能在Spotlight中输入名称来寻找App，而随着苹果发布了一套全新的iOS 9 Search APIs之后，开发者不但可以自由选择App的部分内容编入索引，还能对Spotlight上的搜索结果以及点击不同结果显示的内容进行设置。</p>

<h3>三大API</h3>

<!--more-->


<h5>NSUserActivity</h5>

<ul>
<li><p>NSUserActivity是iOS 8专为Handoff推出的API，iOS 9之后得到了提升。现在用户只需提供元数据（metadata）就能搜索不同的activity（活动）了。</p></li>
<li><p>换言之，Spotlight可以将activity编入索引，而NSUserActivity就好比网页浏览器的历史堆栈（history stack），使用户能在Spotlight上搜到最近的活动。</p></li>
</ul>


<h5>Web Markup</h5>

<ul>
<li><p>Web Markup在网页上显示App的内容并编入Spotlight索引，如此一来即便没有安装某个App，苹果的索引器也能在网页上搜索特别的标记（markup），在Safari或Spotlight上显示搜索结果。</p></li>
<li><p>显示未安装App的搜索结果是一大亮点，有望为开发者带来更多潜在用户。公布在搜索API上的App深链接则储存在苹果的cloud index中。更多详情，请参阅苹果的“Web Markup使用指南（Use Web Markup to Make App Content Searchable）”。</p></li>
</ul>


<h5>CoreSpotlight</h5>

<ul>
<li>NSUserActivity帮助储存用户历史，而全新的Core Spotlight则能将App中的任何内容编入索引，实质是在用户设备上提供基础的Core Spotlight索引渠道，满足用户另外一个需求。</li>
</ul>


<hr />

<p>至于前面两个这里就不过多介绍，这里只介绍iOS9相关新特性，所以就来说我们应该怎么去学习并使用CoreSpotlight。</p>

<blockquote><p>对于CoreSpotlight可以类比NSUserDefault，都是全局的存储空间。不同的是CoreSpotlight是系统的存储空间，每个App都能访问（可能这个访问有限制，目前还没有时间研究），但是NSUserDefault是每个App私有的。另外对于存储的内容CoreSpotlight存储的是item，即CSSearchableItem，而每个CSSearchableItem又有许多属性，这些属性是通过CSSearchableItemAttributeSet进行设置。具体都有神马属性，大家自己去看头文件吧。</p></blockquote>

<p> 下面写一下简单得步骤：</p>

<ul>
<li><p>1 引入CoreSpotlight.framework</p></li>
<li><p>2 创建CSSearchableItemAttributeSet、CSSearchableItem</p></li>
<li><p>3 调用CSSearchableIndex.defaultSearchableIndex()的相关的方法对item进行操作。</p></li>
</ul>


<blockquote><p>由于本人水平有限，只找到了添加、删除itme的操作，并没有找到更新itme的方法，如果谁清楚了，麻烦告知一下。</p></blockquote>

<p> 下面贴出本人测试的一个简单例子的代码：
    import UIKit</p>

<pre><code>@UIApplicationMain
class AppDelegate: UIResponder, UIApplicationDelegate {

    var window: UIWindow?

    // 从搜索结果点击的时候将会调用这个方法
    func application(application: UIApplication, continueUserActivity userActivity: NSUserActivity, restorationHandler: ([AnyObject]?) -&gt; Void) -&gt; Bool {
        // 这里能够获取到点击搜索结果的identifier 但是不清楚是不是应该这样做
        let identifier = userActivity.userInfo?["kCSSearchableItemActivityIdentifier"]
        print("continueUserActivity \(identifier!)")
        return true
    }


}
</code></pre>

<hr />

<pre><code>import UIKit
import CoreSpotlight

class ViewController: UIViewController {
    let identifier = "com.mxy.test.identifier"
    var index = 1 // 用于标识添加的itme

    override func viewDidLoad() {
        super.viewDidLoad()
        CSSearchableIndex.defaultSearchableIndex().deleteAllSearchableItemsWithCompletionHandler { (error) -&gt; Void in

        }
    }


    @IBAction func insertItem() {
        let attributeSet = CSSearchableItemAttributeSet(itemContentType: "com.mxy.test")
        attributeSet.title = "孟祥月 测试 mxy \(index)"
        attributeSet.contentDescription = "this 这里写点什么好呢 mxy \(index)"
        // 设置搜索结果的缩略图 不知道 为何就是不生效 我给应用程序添加了icon后，搜索结果那里显示的是icon
        attributeSet.thumbnailURL = NSURL(fileURLWithPath: NSBundle.mainBundle().pathForResource("aa", ofType: "png")!)
        attributeSet.thumbnailData = UIImagePNGRepresentation(UIImage(named: "aa")!)
        let item = CSSearchableItem(uniqueIdentifier: "\(identifier) \(index)", domainIdentifier: "mxy", attributeSet: attributeSet)
        let tmpItmes: [CSSearchableItem] = [item]
        CSSearchableIndex.defaultSearchableIndex().indexSearchableItems(tmpItmes) { (error) -&gt; Void in

        }
        index++
    }

    // 貌似是没有更新操作 所以只好根据identifier先删除，修改后再添加进去。
    @IBAction func updateItem() {
        if index &gt; 0 {
            let tmpIdentifier = "\(identifier) \(index - 1)"
            CSSearchableIndex.defaultSearchableIndex().deleteSearchableItemsWithIdentifiers([tmpIdentifier], completionHandler: { (error) -&gt; Void in

            })

            let attributeSet = CSSearchableItemAttributeSet(itemContentType: "com.mxy.test")
            attributeSet.title = "孟祥月 测试 mxy \(index - 1)"
            attributeSet.contentDescription = "this 这里写点更新后 mxy \(index - 1)"
            let item = CSSearchableItem(uniqueIdentifier: tmpIdentifier, domainIdentifier: "mxy", attributeSet: attributeSet)
            let tmpItmes: [CSSearchableItem] = [item]
            CSSearchableIndex.defaultSearchableIndex().indexSearchableItems(tmpItmes) { (error) -&gt; Void in

            }

        }

    }

    @IBAction func deleteItem() {
        let identifiers = ["\(identifier) \(index)"]
        index--
        if index &lt;= 0 {
            return
        }
        CSSearchableIndex.defaultSearchableIndex().deleteSearchableItemsWithIdentifiers(identifiers) { (error) -&gt; Void in

        }
    }

}
</code></pre>

<p>在storyboard中只是添加了三个按钮，关联对应的操作。下面是演示，点击更新的时候会更新最后一个item的内容：</p>

<p><img src="http://al1020119.github.io/images/Spotlight001.gif" title="Caption" ></p>

<p>例子代码的下载地址：<a href="http://download.csdn.net/detail/mengxiangyue/8827141">http://download.csdn.net/detail/mengxiangyue/8827141</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS9+Xcode总结]]></title>
    <link href="http://al1020119.github.io/blog/2015/12/14/ios9-plus-xcodezong-jie/"/>
    <updated>2015-12-14T23:56:09+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/12/14/ios9-plus-xcodezong-jie</id>
    <content type="html"><![CDATA[<p>刚更新了Xcode 9 beat 2，运行了之前的工程，发现了一些问题，就针对性的做了一下iOS9的适配。</p>

<h4>1，默认使用HTTPS请求</h4>

<p>如果在Xcode 9之前使用的时http请求，那么在XCode 9上编译的App是不能联网的，会提示如下错误:</p>

<pre><code>App Transport Security has blocked a cleartext HTTP (http://) resource load since it is insecure. Temporary exceptions can be configured via your app's Info.plist file.
</code></pre>

<p>修改方法是要么使服务器支持https访问，要么关闭https的使用。第一种方法对于个人开发者来说代价还是比较大的，因此推荐使用后面一种方法，具体的做法是:在工程的Info.plist文件里添加NSAppTransportSecurity字典类型的，添加一个元素：key为NSAllowsArbitraryLoads，值为YES。</p>

<h4>2，iOS 9使用URL scheme必须将其加入白名单</h4>

<p>否则会提示类似如下错误:</p>

<!--more-->


<pre><code>    canOpenURL: failed for URL: "mqqopensdkapiV2://qqapp" - error: "This app is not allowed to query for scheme mqqopensdkapiV2”
</code></pre>

<p>修正方法是，Info.plist文件中添加一个key为LSApplicationQueriesSchemes的数组值，里面包含需要添加白名单的string类型的scheme。特酷吧在项目中使用了qq，微信等分享登录功能，需要添加的值为：</p>

<ul>
<li>mqqopensdkapiV2</li>
<li>mqqOpensdkSSoLogin</li>
<li>mqq</li>
<li>mqzoneopensdkapiV2</li>
<li>mqzoneopensdkapi19</li>
<li>mqzoneopensdkapi</li>
<li>mqzoneopensdk</li>
<li>mqzone</li>
<li>weixin</li>
<li>wechat
更多其他适配点后续不断跟进。</li>
</ul>


<h4>3，bitcode</h4>

<p>使用Xcode7编译提示：</p>

<pre><code>XXX does not contain bitcode. You must rebuild it with bitcode enabled (Xcode setting ENABLE_BITCODE), obtain an updated library from the vendor, or disable bitcode for this target. for architecture arm64
</code></pre>

<p>bitcode是被编译程序的一种中间形式的代码。包含bitcode配置的程序将会在App store上被编译和链接。bitcode允许苹果在后期重新优化我们程序的二进制文件，而不需要我们重新提交一个新的版本到App store上。
Xcode7 默认开启了bitcode，如果App使用的第三方类库不支持bitcode会提示错误，只需要在”Build Settings”->”Enable Bitcode”选项中看关闭bitcode即可。</p>

<blockquote><p>开启Bitcode编译后，编译产生的文件体积会变大 (因为是中间代码，不是用户下载的包)，且dSYM文件不能用来崩溃日志的符号化 (用户下载的包是Apple服务重新编译产生的，有产生新的符号文件)。通过Archive方式上传AppStore的包，可以在 Xcode的Organizer工具中下载对应安装包的新的符号文件。
转载请注明来自特酷吧,本文地址:www.tekuba.net/program/364/
 
 </p>

<h4>4，使用XCode7链接第三方库提示warning</h4>

<pre><code>Lots of warnings when building with Xcode 7 with 3rd party libraries
warning: Could not resolve external type c:objc(cs)NSString
warning: Could not resolve external type c:objc(cs)NSDictionary
warning: Could not resolve external type c:objc(cs)NSMutableString
warning: Could not resolve external type c:objc(cs)NSError
</code></pre>

<p><a href="https://forums.developer.apple.com/thread/17921">https://forums.developer.apple.com/thread/17921</a>
目前没发现好的解决办法，可以尝试如下:
I had this problem too.  Here&rsquo;s how I fixed it.</p></blockquote>

<ul>
<li>1)  Go to Build Settings -> Build Options -> Debug Information Format</li>
<li>2)  Change the Debug setting from &ldquo;DWARF with dSYM File&rdquo; to &ldquo;DWARF&rdquo;</li>
<li>3)  Leave the Release setting at &ldquo;DWARF with dSYM File&rdquo;</li>
</ul>


<p>The problem appears to be that Xcode was trying to create dSYM files for Debug builds.  You don&rsquo;t need dSYM files for Debug builds &ndash; it&rsquo;s release builds where you need them. </p>

<hr />

<h6>既然提到了Xcode7，那么Xcode7中也有几个需要注意的地方（Xcode7是随着ios9一起出来的，其实也就是ios9的新特性，只是不是sdk），</h6>

<p>升级到XCode7之后，编译和上传到itunes connect中遇到了一些问题（特酷吧XCode版本7.0.1），在这里总结下：</p>

<h4>1，was built for newer iOS version (9.0) than being linked (7.0)</h4>

<p>解决方法参考：<a href="http://qaseeker.com/32270491-xcode-7-warning-was-built-for-newer-ios-version-5-1-1-than-being-linked-5-1/">http://qaseeker.com/32270491-xcode-7-warning-was-built-for-newer-ios-version-5-1-1-than-being-linked-5-1/</a></p>

<pre><code>the -w flag can be added to Build Settings -&gt; Other Linker Flags
</code></pre>

<h4>2，Could not resolve external type c:objc(cs)</h4>

<p>解决方法参考：</p>

<pre><code>https://community.pushwoosh.com/questions/2774/lot-of-warnings-with-xcode-70-and-pushwoosh-304
</code></pre>

<p>It looks like a bug of XCode 7. See the discussion here:</p>

<pre><code>https://forums.developer.apple.com/thread/17921
</code></pre>

<hr />

<pre><code>To get rid of this warning you need to change debug information from "DWARF + dSYM" to DWARF.
DWARF seems to be the default setting for new projects created in Xcode 7, but existing projects that are migrating to Xcode 7 probably still have DWARF with dSYM File as the setting.
</code></pre>

<p>特酷吧亲测发现使用XCode7新建工程的时候，Debug模式默认选择了DWARF。</p>

<h4>3，"The resulting API analysis file is too large. We were unable to validate your API usage prior to delivery</h4>

<p><a href="https://forums.developer.apple.com/thread/18493">https://forums.developer.apple.com/thread/18493</a>
建议处理</p>

<ul>
<li>1，export IPA file (after you select Archive from within xCode)</li>
<li>2，Use Application Loader to upload</li>
<li>3，de-select Bitcode and Symbols</li>
</ul>


<p>似乎目前对bitcode的支持还不是很好，建议关闭。再上传。</p>

<h4>4.最后就是和swift相关的。</h4>

<p>如果使用了混编技术，也就是说里面涉及到了swift代码，实现了桥接，那么系统会偶尔出现崩溃的现象，这个时候需要修改一个属性</p>

<ul>
<li>1：选中项目</li>
<li>2：选中target，在build Setting中搜索swift</li>
<li><p>3：在出现的embedded content contains swift code选中对应的值</p>

<ul>
<li>使用了swift就是YES</li>
<li>没有swift就是NO</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS9-WKWebView+SFSafariViewController]]></title>
    <link href="http://al1020119.github.io/blog/2015/12/14/ios9xin-te-xing-wkwebview/"/>
    <updated>2015-12-14T19:35:40+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/12/14/ios9xin-te-xing-wkwebview</id>
    <content type="html"><![CDATA[<h2>一：WKWebView简单介绍</h2>

<p>webkit使用WKWebView来代替IOS的UIWebView和OSX的WebView，并且使用Nitro JavaScript引擎，这意味着所有第三方浏览器运行JavaScript将会跟safari一样快。</p>

<p>先来看看WKWebView和UIWebView有什么区别：</p>

<h6>UIWebView：</h6>

<ul>
<li>始祖级别，支持的iOS版本比较多</li>
<li>可支持打开URL，包括各种URL模式，例如 Https，FTP等</li>
<li>可支持打开各种不同文件格式，例如 txt，docx，ppt,，音视频文件等，很多文档阅读器会经常使用这个特性，感兴趣的可以查一下Apple的文档，支持的格式还是挺多，只是不同iOS 版本的支持程度不太一样，使用时请多留意测试确认~</li>
<li>占用内存比较多，尤其是网页中包含比较多CSS+DIV之类内容时，很容易出现内存警告（Memory Warning）</li>
<li>效率低，不灵活，尤其是和 JavaScript交互时</li>
<li>无法清除本地存储数据（Local Storage）</li>
<li>代理（delegate）之间的回调比较麻烦，提供的内容比较低级，尤其是UI部分。如果想自己定制一个类似 Safari 的内嵌浏览器（Browser），那就坑爹无极限了，例如我们PDF Reader系列中的内嵌Browser，自己* 手动模拟实现Tab切换，底部Tool及各种Menu等，说多了都是泪~~</li>
</ul>


<h6>WKWebView：</h6>

<ul>
<li>iOS 8引入的，比较年轻</li>
<li>在内存和执行效率上要比UIWebView高很多</li>
<li>开放度较高但据说Bug成吨</li>
<li>类似UIWebView，UI定制比较麻烦···</li>
<li>没具体测试使用过，就不继续列举了 L~</li>
</ul>


<!--more-->


<h5>第一、WKWebView增加的属性和方法</h5>

<p>类比UIWebView，跟UIWebView的API对比，
增加的属性：</p>

<pre><code>* 1、estimatedProgress 加载进度条，在IOS8之前我们是通过一个假的进度条来实现
* 2、backForwardList 表示historyList
* 3、WKWebViewConfiguration *configuration; 初始化webview的配置
</code></pre>

<p>增加的方法：</p>

<pre><code>- (instancetype)initWithFrame:(CGRect)frame configuration:(WKWebViewConfiguration *)configuration 
</code></pre>

<p>初始化</p>

<pre><code>    - (WKNavigation *)goToBackForwardListItem:(WKBackForwardListItem *)item; 
</code></pre>

<p>跳到历史的某个页面</p>

<!--more-->


<h5>第二、相同的属性和方法</h5>

<ul>
<li>goBack、</li>
<li>goForward、</li>
<li>canGoBack、</li>
<li>canGoForward、</li>
<li>stopLoading、</li>
<li>loadRequest、</li>
<li>scrollView</li>
</ul>


<h5>第三、被删去的属性和方法：</h5>

<pre><code>- (NSString *)stringByEvaluatingJavaScriptFromString:(NSString *)script;
</code></pre>

<p>在跟js交互时，我们使用这个API，目前WKWebView完档没有给出实现类似功能的API</p>

<ul>
<li>无法设置缓存
在UIWebView，使用NSURLCache缓存，通过setSharedURLCache可以设置成我们自己的缓存，但WKWebView不支持NSURLCache

<h5>第四、delegate方法的不同</h5>

<p>UIWebView支持的代理是UIWebViewDelegate，WKWebView支持的代理是WKNavigationDelegate和
WKUIDelegate
WKNavigationDelegate主要实现了涉及到导航跳转方面的回调方法
WKUIDelegate主要实现了涉及到界面显示的回调方法：如WKWebView的改变和js相关内容
具体来说WKNavigationDelegate除了有开始加载、加载成功、加载失败的API外，还具有额外的三个代理方法：</p>

<pre><code>  -(void)webView:(WKWebView *)webView didReceiveServerRedirectForProvisionalNavigation:(WKNavigation *)navigation
</code></pre>

<p>这个代理是服务器redirect时调用</p>

<pre><code>  -(void)webView:(WKWebView *)webView decidePolicyForNavigationResponse:(WKNavigationResponse *)navigationResponse decisionHandler:(void (^)(WKNavigationResponsePolicy))decisionHandler
</code></pre>

<p>这个代理方法表示当客户端收到服务器的响应头，根据response相关信息，可以决定这次跳转是否可以继续进行。</p>

<pre><code>  -(void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler
</code></pre>

<p>根据webView、navigationAction相关信息决定这次跳转是否可以继续进行,这些信息包含HTTP发送请求，如头部包含User-Agent,Accept</p></li>
</ul>


<hr />

<h2>二、WKWebView新特性</h2>

<ul>
<li>在性能、稳定性、功能方面有很大提升（最直观的体现就是加载网页是占用的内存，模拟器加载百度与开源中国* 网站时，WKWebView占用23M，而UIWebView占用85M）；</li>
<li>允许JavaScript的Nitro库加载并使用（UIWebView中限制）；</li>
<li>支持了更多的HTML5特性；</li>
<li>高达60fps的滚动刷新率以及内置手势；</li>
<li>将UIWebViewDelegate与UIWebView重构成了14类与3个协议（查看苹果官方文档）；</li>
</ul>


<hr />

<h2>三：基本使用</h2>

<p>WKWebView相对于UIWebView强大了很多，内存的消耗相对少了，所提供的接口也丰富了。
现在谈一谈WKWebView的基本使用</p>

<h4>1. navigationDelegate</h4>

<pre><code>- (void)webView:(WKWebView *)webView didStartProvisionalNavigation:(WKNavigation *)navigation { // 类似UIWebView的 -webViewDidStartLoad:  
    NSLog(@"didStartProvisionalNavigation");  
    [UIApplication sharedApplication].networkActivityIndicatorVisible = YES;  
}  

- (void)webView:(WKWebView *)webView didCommitNavigation:(WKNavigation *)navigation {  
    NSLog(@"didCommitNavigation");  
}  

- (void)webView:(WKWebView *)webView didFinishNavigation:(WKNavigation *)navigation { // 类似 UIWebView 的 －webViewDidFinishLoad:  
    NSLog(@"didFinishNavigation");  
    [self resetControl];  
    if (webView.title.length &gt; 0) {  
        self.title = webView.title;  
    }  

}  
- (void)webView:(WKWebView *)webView didFailProvisionalNavigation:(WKNavigation *)navigation withError:(NSError *)error {  
    // 类似 UIWebView 的- webView:didFailLoadWithError:  

    NSLog(@"didFailProvisionalNavigation");  

}  
- (void)webView:(WKWebView *)webView decidePolicyForNavigationResponse:(WKNavigationResponse *)navigationResponse decisionHandler:(void (^)(WKNavigationResponsePolicy))decisionHandler {  

    decisionHandler(WKNavigationResponsePolicyAllow);  
}  


- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler {  
    // 类似 UIWebView 的 -webView: shouldStartLoadWithRequest: navigationType:  

    NSLog(@"4.%@",navigationAction.request);  


    NSString *url = [navigationAction.request.URL.absoluteString stringByReplacingPercentEscapesUsingEncoding:NSUTF8StringEncoding];  



    decisionHandler(WKNavigationActionPolicyAllow);  

}  
- (void)webView:(WKWebView *)webView didReceiveAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition, NSURLCredential *))completionHandler {  

}  
</code></pre>

<h4>2 UIDelegate</h4>

<pre><code>- (WKWebView *)webView:(WKWebView *)webView createWebViewWithConfiguration:(WKWebViewConfiguration *)configuration forNavigationAction:(WKNavigationAction *)navigationAction windowFeatures:(WKWindowFeatures *)windowFeatures {  
    // 接口的作用是打开新窗口委托  
    [self createNewWebViewWithURL:webView.URL.absoluteString config:configuration];  

    return currentSubView.webView;  
}  

- (void)webView:(WKWebView *)webView runJavaScriptAlertPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)())completionHandler  
{    // js 里面的alert实现，如果不实现，网页的alert函数无效  
    UIAlertController *alertController = [UIAlertController alertControllerWithTitle:message  
                                                                             message:nil  
                                                                      preferredStyle:UIAlertControllerStyleAlert];  
    [alertController addAction:[UIAlertAction actionWithTitle:@"确定"  
                                                        style:UIAlertActionStyleCancel  
                                                      handler:^(UIAlertAction *action) {  
                                                          completionHandler();  
                                                      }]];  

    [self presentViewController:alertController animated:YES completion:^{}];  

}  


- (void)webView:(WKWebView *)webView runJavaScriptConfirmPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(BOOL))completionHandler {  
    //  js 里面的alert实现，如果不实现，网页的alert函数无效  ,   

    UIAlertController *alertController = [UIAlertController alertControllerWithTitle:message  
                                                                             message:nil  
                                                                      preferredStyle:UIAlertControllerStyleAlert];  
    [alertController addAction:[UIAlertAction actionWithTitle:@"确定"  
                                                        style:UIAlertActionStyleDefault  
                                                      handler:^(UIAlertAction *action) {  
                                                          completionHandler(YES);  
                                                      }]];  
    [alertController addAction:[UIAlertAction actionWithTitle:@"取消"  
                                                        style:UIAlertActionStyleCancel  
                                                      handler:^(UIAlertAction *action){  
                                                          completionHandler(NO);  
                                                      }]];  

    [self presentViewController:alertController animated:YES completion:^{}];  

}  

- (void)webView:(WKWebView *)webView runJavaScriptTextInputPanelWithPrompt:(NSString *)prompt defaultText:(NSString *)defaultText initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(NSString *))completionHandler {  

    completionHandler(@"Client Not handler");  

}  
</code></pre>

<h4>3. WKWebView 执行脚本方法</h4>

<pre><code>- (void)evaluateJavaScript:(NSString *)javaScriptString completionHandler:(void (^)(id, NSError *))completionHandler;  

completionHandler 拥有两个参数，一个是返回错误，一个可以返回执行脚本后的返回值  
</code></pre>

<h4>4. WKWebView 的Cookie问题</h4>

<p>UIWebView 中会自动保存Cookie，如果登录了一次，下次再次进入的时候，会记住登录状态
而在WKWebView中，并不会这样，WKWebView在初始化的时候有一个方法</p>

<pre><code>- (instancetype)initWithFrame:(CGRect)frame configuration:(WKWebViewConfiguration *)configuration  
</code></pre>

<p>通过这个方法，设置 configuration 让WKWebView知道登录状态，configuration 可以通过已有的Cookie进行设置，也可以通过保存上一次的configuration进行设置</p>

<p>参考 stackoverflow上回答：</p>

<p><a href="http://stackoverflow.com/questions/26573137/can-i-set-the-cookies-to-be-used-by-a-wkwebview/26577303#26577303">http://stackoverflow.com/questions/26573137/can-i-set-the-cookies-to-be-used-by-a-wkwebview/26577303#26577303</a></p>

<pre><code>WKWebView * webView = /*set up your webView*/  
NSMutableURLRequest * request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"http://example.com/index.html"]];  
[request addValue:@"TeskCookieKey1=TeskCookieValue1;TeskCookieKey2=TeskCookieValue2;" forHTTPHeaderField:@"Cookie"];  
// use stringWithFormat: in the above line to inject your values programmatically  
[webView loadRequest:request];  

[objc] view plaincopyprint?在CODE上查看代码片派生到我的代码片
WKUserContentController* userContentController = WKUserContentController.new;  
WKUserScript * cookieScript = [[WKUserScript alloc]   
    initWithSource: @"document.cookie = 'TeskCookieKey1=TeskCookieValue1';document.cookie = 'TeskCookieKey2=TeskCookieValue2';"  
    injectionTime:WKUserScriptInjectionTimeAtDocumentStart forMainFrameOnly:NO];  
// again, use stringWithFormat: in the above line to inject your values programmatically  
[userContentController addUserScript:cookieScript];  
WKWebViewConfiguration* webViewConfig = WKWebViewConfiguration.new;  
webViewConfig.userContentController = userContentController;  
WKWebView * webView = [[WKWebView alloc] initWithFrame:CGRectMake(/*set your values*/) configuration:webViewConfig];  
</code></pre>

<hr />

<h2>四：WKWebView与js通信</h2>

<p>iOS 8 引入WKWebView, WKWebView 不支持JavaScriptCore的方式但提供message handler的方式为JavaScript 与Objective-C 通信.
在Objective-C 中使用WKWebView的以下方法调用JavaScript:</p>

<pre><code>- (void)evaluateJavaScript:(NSString *)javaScriptString
         completionHandler:(void (^)(id, NSError *))completionHandler
如果JavaScript 代码出错, 可以在completionHandler 进行处理.
在Objective-C 中注册 message handler:
// WKScriptMessageHandler protocol?

- (void)userContentController:(WKUserContentController *)userContentController
    didReceiveScriptMessage:(WKScriptMessage *)message
{
    NSLog(@"Message: %@", message.body);
}

[userContentController addScriptMessageHandler:handler name:@"myName"];
在JavaScript 将信息发给Objective-C:
// window.webkit.messageHandlers.&lt;name&gt;.postMessage();?

function postMyMessage()? {?
    var message = { 'message' : 'Hello, World!', 'numbers' : [ 1, 2, 3 ] };?
    window.webkit.messageHandlers.myName.postMessage(message);?
}
</code></pre>

<hr />

<h2>五：常见问题：</h2>

<p>32 位的app在使用WKWebView的时候，如果运行在64位的设备上，会出现一下问题：</p>

<ul>
<li>（1）iOS8.1 系统，部分网页加载白屏，例如 百度，iOS8.3 似乎没问题</li>
<li>（2）web输入框输入汉字也会出现白屏</li>
</ul>


<p>通过搜索得到问题根源：</p>

<blockquote><p>WKWebView&rsquo;s WebProcess runs out-of-process as a 64-bit process on hardware supporting 64bit. There is a 32bit/64bit marshalling IPC bug for 32 bit apps using the WKWebView client on such hardware. The bug causes the WebProcess to exit, leaving a blank screen.</p></blockquote>

<ul>
<li>也就是一个进程间通讯的bug引起的。</li>
</ul>


<h6>解决方案，可以使app支持arm64，便不会出现问题。</h6>

<hr />

<h2>六：SFSafariViewController：</h2>

<ul>
<li>iOS 9引入，更加年轻，意味着是Apple的新菜，总是有什么优势的</li>
<li>也是用来显示网页内容的</li>
<li>这是一个特殊的View Controller，而不是一个单独的 View，和前面两个的区别</li>
<li>在当前App中使用Safari的UI框架展现Web内容，包括相同的地址栏，工具栏等，类似一个内置于App的小型Safari</li>
<li>共享Safari的一些便利特性，包括：相似的用户体验，和Safari共享Cookie，iCloud Web表单数据，密码、证书自动填充，Safari阅读器（Safari Reader）</li>
<li>可定制性比较差，甚至连地址栏都是不可编辑的，只能在init的时候，传入一个URL来指定网页的地址</li>
<li>只能用来展示单个页面，并且有一个完成按钮用来退出</li>
</ul>


<p><img src="http://al1020119.github.io/images/safari001.png" title="Caption" ></p>

<p>如果你的App需要显示网页，但是又不想自己去定制浏览器界面的话，可以考虑用SFSafariViewController来试试。从好的方面看，SFSafariViewController也去掉了从App中跳转到Safari的撕裂感，不同App之间切换总是让人感觉麻烦和不舒服。</p>

<p>代码例子:</p>

<pre><code>- (IBAction)onButtonClick:(id)sender

{

    NSString *urlString = @"http://www.kdanmobile.com";

    SFSafariViewController *sfViewControllr = [[SFSafariViewController alloc] initWithURL:[NSURL URLWithString:urlString]];

    sfViewControllr.delegate = self;

    [self presentViewController:sfViewControllr animated:YES completion:^{

       //...

    }];

}



// Done 按钮

- (void)safariViewControllerDidFinish:(nonnull SFSafariViewController *)controller

{

    [controller dismissViewControllerAnimated:YES completion:nil];

}
</code></pre>

<p>SFSafariViewController 的接口比较少，就不再继续一一列举了。另外一个定制功能在于SFSafariViewControllerDelegate里面的一个方法：</p>

<pre><code>-(NSArray&lt;UIActivity *&gt; *)safariViewController:(SFSafariViewController *)controller activityItemsForURL:(NSURL *)URL title:(nullable NSString *)title;
</code></pre>

<p>这个代理会在用户点击动作（Action）按钮（底部工具栏中间的按钮）的时候调用，可以传入UIActivity的数组，创建添加一些自定义的各类插件式的服务，比如分享到微信，微博什么的。</p>

<p><img src="http://al1020119.github.io/images/safari001.png" title="Caption" ></p>

<blockquote><p>小细节：
SFSafariViewController有保存Cookies的功能，但是貌似不能和Safari浏览器共享，也可能是Beta版的bug</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS9-Unit Test]]></title>
    <link href="http://al1020119.github.io/blog/2015/12/14/ios9-unit-test/"/>
    <updated>2015-12-14T00:59:07+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/12/14/ios9-unit-test</id>
    <content type="html"><![CDATA[<p> XCode7(iOS9)中新增了跟多特性，包括：</p>

<ul>
<li>WKWebView+SFSafariViewController</li>
<li>UI Test</li>
<li>Multitasking</li>
<li>watchOS 2</li>
<li>Swift 2</li>
<li>App Thinning</li>
<li>人工智能和搜索 API</li>
<li>HomeKit，CloudKit，HealthKit 等等杂七杂八的框架</li>
</ul>


<p> 前面的文章中我们已经将WKWebView+SFSafariViewController完整的介绍了一遍，现在我们就开始着手探究一下单元测试（后面的文章中我将会集中介绍一下常用功能新特性），敬请关注：<a href="http://al1020119.github.io/">iOS梦工厂</a></p>

<h3>UI Tests是什么？</h3>

<p>UI Tests是一个自动测试UI与交互的Testing组件</p>

<!--more-->


<h3>UI Tests有什么用？</h3>

<p>它可以通过编写代码、或者是记录开发者的操作过程并代码化，来实现自动点击某个按钮、视图，或者自动输入文字等功能。</p>

<h3>UI Tests的重要性</h3>

<p>在实际的开发过程中，随着项目越做越大，功能越来越多，仅仅靠人工操作的方式来覆盖所有测试用例是非常困难的，尤其是加入新功能以后，旧的功能也要重新测试一遍，这导致了测试需要花非常多的时间来进行回归测试，这里产生了大量重复的工作，而这些重复的工作有些是可以自动完成的，这时候UI Tests就可以帮助解决这个问题了</p>

<h2>使用方法</h2>

<h6>第一步：添加UI Tests</h6>

<p>如果是新项目，则创建工程的时候可以直接勾选选项，如下图</p>

<p><img src="http://al1020119.github.io/images/unittest001.png" title="Caption" ></p>

<p>如果是已有的项目，可以通过添加target的方式添加一个UI Tests，点击xcode的菜单，找到target栏</p>

<p><img src="http://al1020119.github.io/images/unittest002.png" title="Caption" ></p>

<p>在Test选项中选择Cocoa Touch UI Testing Bundle</p>

<p><img src="http://al1020119.github.io/images/unittest003.png" title="Caption" ></p>

<p>这时候test组件添加成功，它在项目中的位置如下图所示</p>

<p><img src="http://al1020119.github.io/images/unittest004.png" title="Caption" ></p>

<h6>第二步：创建测试代码</h6>

<p>手动创建测试代码
打开测试文件，在testExample()方法中添加测试代码</p>

<p><img src="http://al1020119.github.io/images/unittest005.png" title="Caption" ></p>

<p>如果不知道如何写测试代码，则可以参考自动生成的代码样式</p>

<h5>自动生成测试步骤</h5>

<p>选择测试文件后，点击录制按钮</p>

<p><img src="http://al1020119.github.io/images/unittest006.png" title="Caption" ></p>

<p>这时候开始进行操作，它会记录你的操作步骤，并生成测试代码
下图就是在一些操作后自动生成的测试代码</p>

<p><img src="http://al1020119.github.io/images/unittest007.png" title="Caption" ></p>

<p>这时候可以分析测试代码的语法，以便你自己手动修改或者手写测试代码</p>

<h6>第三步：开始测试</h6>

<p>点击testExample方法旁边的播放按钮，它就开始进行自动测试了，这时候你会看到app在自动操作</p>

<p><img src="http://al1020119.github.io/images/unittest008.png" title="Caption" ></p>

<h6>下面介绍一下测试元素的语法</h6>

<p>XCUIApplication：
继承XCUIElement，这个类掌管应用程序的生命周期，里面包含两个主要方法</p>

<pre><code>launch():
</code></pre>

<p>启动程序</p>

<pre><code>terminate():
</code></pre>

<p>终止程序</p>

<h6>XCUIElement:</h6>

<p>继承NSObject，实现协议XCUIElementAttributes, XCUIElementTypeQueryProvider
可以表示系统的各种UI元素</p>

<pre><code>exist:
</code></pre>

<p>可以让你判断当前的UI元素是否存在，如果对一个不存在的元素进行操作，会导致测试组件抛出异常并中断测试</p>

<pre><code>descendantsMatchingType(type:XCUIElementType)-&gt;XCUIElementQuery:
</code></pre>

<p>取某种类型的元素以及它的子类集合</p>

<pre><code>childrenMatchingType(type:XCUIElementType)-&gt;XCUIElementQuery:
</code></pre>

<p>取某种类型的元素集合，不包含它的子类</p>

<p>这两个方法的区别在于，你仅使用系统的UIButton时，用childrenMatchingType就可以了，如果你还希望查询自己定义的子Button，就要用descendantsMatchingType</p>

<p>另外UI元素还有一些交互方法</p>

<pre><code>tap():
</code></pre>

<p>点击</p>

<pre><code>doubleTap():
</code></pre>

<p>双击</p>

<pre><code>pressForDuration(duration: NSTimeInterval):
</code></pre>

<p>长按一段时间，在你需要进行延时操作时，这个就派上用场了</p>

<pre><code>swipeUp():
</code></pre>

<p>这个响应不了pan手势，暂时没发现能用在什么地方，也可能是beta版的bug，先不解释</p>

<pre><code>typeText(text: String):
</code></pre>

<p>用于textField和textView输入文本时使用，使用前要确保文本框获得输入焦点，可以使用tap()函数使其获得焦点</p>

<h6>XCUIElementAttributes协议</h6>

<p>里面包含了UIAccessibility中的部分属性
如下图</p>

<p><img src="http://al1020119.github.io/images/unittest009.png" title="Caption" ></p>

<p>可以方便你查看当前元素的特征，其中identifier属性可用于直接读取元素，不过该属性在UITextField中有bug，暂时不清楚原因</p>

<p>XCUIElementTypeQueryProvider协议
里面包含了系统中大部分UI控件的类型，可通过读属性的方式取得某种类型的UI集合
部分属性截图如下</p>

<p><img src="http://al1020119.github.io/images/unittest010.png" title="Caption" ></p>

<h3>创建Demo</h3>

<p>首先创建一个登录页面</p>

<p><img src="http://al1020119.github.io/images/unittest011.png" title="Caption" ></p>

<p>点击login按钮进行登录验证，点击clear按钮会清除文本
登录成功后可以去到个人信息页面</p>

<p>个人信息页面如下</p>

<p><img src="http://al1020119.github.io/images/unittest012.png" title="Caption" ></p>

<p>点击modify按钮可以修改个人信息，点击Message按钮可以查看个人消息</p>

<p>最后是消息界面</p>

<p><img src="http://al1020119.github.io/images/unittest013.png" title="Caption" ></p>

<h4>登录页面的测试</h4>

<ul>
<li>输入一个错误的账号</li>
<li>验证结果</li>
<li>关闭警告窗</li>
<li>清除输入记录</li>
<li>输入一个正确的账号</li>
<li>验证结果</li>
<li>进入个人信息页面</li>
</ul>


<p>测试代码如下:</p>

<pre><code>func testLoginView() {
    let app = XCUIApplication()

    // 由于UITextField的id有问题，所以只能通过label的方式遍历元素来读取
    let nameField = self.getFieldWithLbl("nameField")
    if self.canOperateElement(nameField) {
        nameField!.tap()
        nameField!.typeText("xiaoming")
    }

    let psdField = self.getFieldWithLbl("psdField")
    if self.canOperateElement(psdField) {
        psdField!.tap()
        psdField!.typeText("1234321")
    }

    // 通过UIButton的预设id来读取对应的按钮
    let loginBtn = app.buttons["Login"]
    if self.canOperateElement(loginBtn) {
        loginBtn.tap()
    }

    // 开始一段延时，由于真实的登录是联网请求，所以不能直接获得结果，demo通过延时的方式来模拟联网请求
    let window = app.windows.elementAtIndex(0)
    if self.canOperateElement(window) {
        // 延时3秒, 3秒后如果登录成功，则自动进入信息页面，如果登录失败，则弹出警告窗
        window.pressForDuration(3)
    }

    // alert的id和labe都用不了，估计还是bug，所以只能通过数量判断
    if app.alerts.count &gt; 0 {
        // 登录失败
        app.alerts.collectionViews.buttons["确定"].tap()

        let clear = app.buttons["Clear"]
        if self.canOperateElement(clear) {
            clear.tap()

            if self.canOperateElement(nameField) {
                nameField!.tap()
                nameField!.typeText("sun")
            }

            if self.canOperateElement(psdField) {
                psdField!.tap()
                psdField!.typeText("111111")
            }

            if self.canOperateElement(loginBtn) {
                loginBtn.tap()
            }
            if self.canOperateElement(window) {
                // 延时3秒, 3秒后如果登录成功，则自动进入信息页面，如果登录失败，则弹出警告窗
                window.pressForDuration(3)
            }
            self.loginSuccess()
        }
    } else {
        // 登录成功
        self.loginSuccess()
    }
}
</code></pre>

<blockquote><p>这里有几个需要特别注意的点：
当你的元素不存在时，它仍然可能返回一个元素对象，但这时候不能对其进行操作
当你要点击的元素被键盘或者UIAlertView遮挡时，执行tap方法会抛异常
详细实现可参照demo:
<a href="https://github.com/sunljz/demo/tree/master/iOS9/UITestDemo">https://github.com/sunljz/demo/tree/master/iOS9/UITestDemo</a></p></blockquote>

<h4>个人信息页测试</h4>

<ul>
<li>修改性别</li>
<li>修改年龄</li>
<li>修改心情</li>
<li>保存修改</li>
</ul>


<p>测试代码如下：</p>

<pre><code>    func testInfo() {
        let app = XCUIApplication()
        let window = app.windows.elementAtIndex(0)
        if self.canOperateElement(window) {
            // 延时2秒, 加载数据需要时间
            window.pressForDuration(2)
        }

        let modifyBtn = app.buttons["modify"];
        modifyBtn.tap()

        let sexSwitch = app.switches["sex"]
        sexSwitch.tap()

        let incrementButton = app.buttons["Increment"]
        incrementButton.tap()
        incrementButton.tap()
        incrementButton.tap()
        app.buttons["Decrement"].tap()

        let textView = app.textViews["feeling"]
        textView.tap()
        app.keys["Delete"].tap()
        app.keys["Delete"].tap()
        textView.typeText(" abc ")

        // 点击空白区域
        let clearBtn = app.buttons["clearBtn"]
        clearBtn.tap()

        // 保存数据
        modifyBtn.tap()
        window.pressForDuration(2)

        let messageBtn = app.buttons["message"]
        messageBtn.tap();

        // 延时1秒, push view需要时间
        window.pressForDuration(1)

        self.testMessage()
    }
</code></pre>

<blockquote><p>这里需要特别注意以下两点：
textview获取焦点时无法选择焦点的位置
tap事件的触发位置是view的中心，所以当view的中心被遮挡时，要考虑使用其他view来代替</p></blockquote>

<h4>个人消息界面测试</h4>

<p>单元格的点击
测试代码如下：</p>

<pre><code>    func testMessage() {
        let app = XCUIApplication()
        let window = app.windows.elementAtIndex(0)
        if self.canOperateElement(window) {
            // 延时2秒, 加载数据需要时间
            window.pressForDuration(2)
        }

        let table = app.tables
        table.childrenMatchingType(.Cell).elementAtIndex(8).tap()
        table.childrenMatchingType(.Cell).elementAtIndex(1).tap()

    }
</code></pre>

<blockquote><p>这里需要注意一点：
暂时无法获取到tableView的元素指针</p></blockquote>

<h3>总结</h3>

<p>总的来说，UI Tests只能用于一些基础功能的测试，验证app的功能是否可以正常使用，是否存在崩溃问题。但它也有很多不足之处，编写测试用例的过程非常繁琐，自动生成的代码几乎无法运行，功能单一，很多用例无法覆盖，而且bug很多，大大地限制了UI Tests在实际开发中的应用。希望正式版出来的时候能够修复这些问题，并开放更多的功能。</p>

<p>demo地址：</p>

<p><a href="https://github.com/sunljz/demo/tree/master/iOS9/UITestDemo">https://github.com/sunljz/demo/tree/master/iOS9/UITestDemo</a></p>

<p>最后介绍几个常见的第三方测试框架：</p>

<p>Frank， KIF， Subliminal， Apple 的 UIAutomation，我把他们都试了一遍。你要是希望了解更多可以访问我的故障特征测试框架。它不是开发者的失败，而是因为 Apple 对待测试只有有限的开放性。这使得这些框架有一系列的补丁，而在这些补丁之上，这些框架不外乎都成为了一堆破碎的工具。
没有涉及到的更多细节：</p>

<ul>
<li>Frank 一直被遗弃。</li>
<li>KIF 已经与主要的 iOS 修订版本决裂。</li>
<li>Subliminal 不能在命令行中可靠地运行。</li>
<li>UIAutomation 是用 JavaScript 和 clunky 写的。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[移动端性能优化]]></title>
    <link href="http://al1020119.github.io/blog/2015/12/13/yi-dong-duan-xing-neng-you-hua/"/>
    <updated>2015-12-13T14:16:31+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/12/13/yi-dong-duan-xing-neng-you-hua</id>
    <content type="html"><![CDATA[<p>之前写过一篇</p>

<p><a href="http://al1020119.github.io/blog/2015/03/02/uitableviewxing-neng-you-hua-yu-qia-dun-wen-ti/">UItableView性能优化和卡顿问题</a></p>

<p>还有一篇</p>

<p><a href="http://al1020119.github.io/blog/2015/11/16/appqia-dun-liao-zen-yao-ban-%3F/">App卡顿了怎么办</a></p>

<p>今天看到一篇总结的非常好的文章（<a href="http://tgideas.qq.com/webplat/info/news_version3/804/808/811/m579/201412/293834.shtml">移动端性能优化</a>），就移过来，后期我也会根据自己所做的项目做一个开发中性能优化的总结，希望你们喜欢！</p>

<p>随着移动互联网的发展，我们越发要关注移动页面的性能优化，今天跟大家谈谈这方面的事情。</p>

<!--more-->


<h3>首先，为什么要最移动页面进行优化？</h3>

<p>先来一篇前端优化的文章：腾讯一个大神的分享：</p>

<p><a href="http://www.cocoachina.com/webapp/20150126/11020.html">http://www.cocoachina.com/webapp/20150126/11020.html</a></p>

<p>纵观目前移动网络的现状，</p>

<p><img src="http://al1020119.github.io/images/xn001.png" title="Caption" ></p>

<p>   移动页面布局越来越复杂，效果越来越炫，直接导致了文件越来越大，下载和运行速度越来越低，而速度低会造成不良影响，据统计：</p>

<p><img src="http://al1020119.github.io/images/xn002.png" title="Caption" ></p>

<p> 71%的用户期望移动页面跟pc页面一样快，74%的用户能容忍的响应时间为5秒，所以我们必须保证移动端页面有足够的速度。</p>

<p> 移动页面的速度跟三个因素有关，分别是：移动网络带宽速度，设备性能（CPU，GPU，浏览器），页面本身。</p>

<ul>
<li>目前主流的移动网络制式为3g</li>
</ul>


<p><img src="http://al1020119.github.io/images/xn003.png" title="Caption" ></p>

<p> 今年，我们还看到了4g网络制式在快速发展，这再一次提升了移动页面的加载速度；</p>

<p> 而移动设备本身，截止到目前，以iphong6三星Note4等设备为首，智能设备已经变得比以往屏幕更大，CPU、GPU、内存更靠谱</p>

<p><img src="http://al1020119.github.io/images/xn004.png" title="Caption" ></p>

<p> 而与其同时，浏览器产商也为提升页面的速度做出了不可磨灭的努力，这里大家可以看一个视频<a href="http://www.iqiyi.com/w_19rsgfld99.html">http://www.iqiyi.com/w_19rsgfld99.html</a></p>

<p> 网络制式供应商，手机制造商，浏览器产商如此给力，我们呢？我们能做什么。</p>

<p> 我们能做得是对移动端页面本身优化，这也是我们专业价值的体现，所以我们必须做移动端页面性能优化。</p>

<h3>那怎么做移动端页面优化呢？</h3>

<p> 在说这个前，要提一下pc常用的优化手段：</p>

<ul>
<li>代码优化（css、html、js优化）</li>
<li>减少HTTP请求（雪碧图，文件合并&hellip;）</li>
<li>减少DOM节点</li>
<li>无阻塞（内联CSS，JS置后&hellip;）</li>
<li>缓存</li>
<li>&hellip;</li>
</ul>


<p> 这些手段大部分适用于移动端，这都是一些耳熟能详的手段，今天这里就讲了，有兴趣可以参考PDI课程《网站性能优化》。</p>

<p> 今天要讲的主要是一些适用于移动端的优化手段，现在进入正题。</p>

<p> 首先我们得关注一下一个页面从开始到呈现完毕需要经历什么阶段，主要有四个阶段：</p>

<p><img src="http://al1020119.github.io/images/xn005.png" title="Caption" ></p>

<p> 每个阶段的主要工作如上图所示，而我们的优化目标是：</p>

<p><img src="http://al1020119.github.io/images/xn006.png" title="Caption" ></p>

<p> 下面我们来针对上面的几个阶段细说一下都有哪些优化手段。</p>

<p> 首先，来看看加载中有哪些优化手段：</p>

<h5>1. 预加载</h5>

<p> 预加载方式有两种：</p>

<ul>
<li>A.显性加载</li>
</ul>


<p><img src="http://al1020119.github.io/images/xn007.png" title="Caption" ></p>

<p> 类似这种用户能明显感知的，我把它称为&ldquo;显性加载&rdquo;，互动页面都建议加上这种加载方式，它一方面能增加页面的趣味性，另一方面能让后续页面体验更流畅</p>

<ul>
<li>B.隐性加载</li>
</ul>


<p><img src="http://al1020119.github.io/images/xn008.png" title="Caption" ></p>

<p>这种在加载第一张图片的时候已经预先加载了第二张图片，从而使得页面体验更流畅的方式，我把它称为隐性加载，这种方式的好处是节省流量之余又能使得体验增强。</p>

<h5>2.    按需加载</h5>

<p>按需加载是不可或缺的优化手段，主要有以下两种方式：</p>

<p><img src="http://al1020119.github.io/images/xn009.png" title="Caption" ></p>

<p> 对于这种方式，在首屏加载的时候把首屏的内容加载尽量，而位于首屏之外的元素都只在出现在首屏时才加载，很大程度地节省了流量，提升了首次加载时间。</p>

<p><img src="http://al1020119.github.io/images/xn010.jpg" title="Caption" ></p>

<p> 这种叫响应式加载方式，意思是利用js或者css判断分辨率，从而选择不同尺寸的图片进行引入，这种的好处显而易见，同样可以加快加载速度和节省流量。</p>

<h5>3.    压缩图片</h5>

<p> 对于压缩图片，首先要提的是jpg文件：</p>

<p><img src="http://al1020119.github.io/images/xn011.png" title="Caption" ></p>

<p> 对于移动端的Jpg文件，有这样的结论：</p>

<pre><code>  a.使用大尺寸大有损压缩比的jpg

  b.使用jpegtran进行无损压缩
</code></pre>

<p><img src="http://al1020119.github.io/images/xn012.png" title="Caption" ></p>

<p> 而对于png有以下结论：</p>

<pre><code>  a.多彩图片使用png24

  b.低彩图片使用png8

  c.推荐使用pngquant
</code></pre>

<h5>4.尽量避免重定向</h5>

<p> 为什么要尽量避免重定向呢？因为如图：</p>

<p><img src="http://al1020119.github.io/images/xn013.png" title="Caption" ></p>

<p> 这是一个同一网速下的测试结果，重定向之所以会比较慢，是因为它重复了域名查找，tcp链接，发送请求。</p>

<h5>5. 使用其他方式代替图片</h5>

<p> 有两种方式，第一种是：依靠css3绘制图片</p>

<p><img src="http://al1020119.github.io/images/xn014.png" title="Caption" ></p>

<p> 第二种：使用iconfont代替图片</p>

<p><img src="http://al1020119.github.io/images/xn015.png" title="Caption" ></p>

<p> 但iconfont不一定比图片好，这里做了个实验：</p>

<p><img src="http://al1020119.github.io/images/xn016.png" title="Caption" ></p>

<p> 对于大图片，iconfont并不比雪碧图好，建议单侧小尺寸图标才使用iconfont.</p>

<p> 然后，针对脚本执行中有哪些优化手段，这里只提两点：</p>

<h5>1.尽量避免DataURI</h5>

<p> DataUri在移动端并不如它在pc端吃香，因为：</p>

<p><img src="http://al1020119.github.io/images/xn017.png" title="Caption" ></p>

<p> 经测试，DataURI要比简单的外链资源慢6倍，生成的代码文件相对图片文件体积没有减少反而增大，而且浏览器在对这种base64解码过程中需要消耗内存和cpu，这个在移动端坏处特别明显。</p>

<h5>2.点击事件优化</h5>

<p> 在移动端请适当使用touchstart，touchend，touch等事件代替延迟比较大的click事件。Click之所以慢是因为mousedown导致的：</p>

<p><img src="http://al1020119.github.io/images/xn018.png" title="Caption" ></p>

<p> 然后，针对渲染阶段中有哪些优化手段，这里也只提两点：</p>

<h5>1. 动画优化</h5>

<p>   a) 尽量使用css3动画</p>

<ul>
<li><p>优点：</p>

<ul>
<li><p>不占用js主线程</p></li>
<li><p>可利用硬件加速</p></li>
<li><p>浏览器可对动画做优化</p></li>
</ul>
</li>
<li><p>缺点：</p>

<ul>
<li>不支持中间状态监听</li>
</ul>


<p> b) 适当使用canvas动画</p></li>
<li><p>优点：</p>

<ul>
<li>可规避渲染树的计算渲染更快</li>
</ul>
</li>
<li><p>缺点：</p>

<ul>
<li><p>开发成本高</p></li>
<li><p>维护较麻烦</p></li>
</ul>
</li>
</ul>


<p> 通过对css3动画和canvas动画对比：</p>

<p><img src="http://al1020119.github.io/images/xn019.png" title="Caption" ></p>

<p> 得到结论：5个元素以内使用css3动画，5个以上使用canvas动画。</p>

<p>   c) 合理使用RAF(requestAnimationFrame)</p>

<ul>
<li><p> 优点：</p>

<ul>
<li><p>能解决脚本问题引起的丢帧，卡顿问题</p></li>
<li><p>支持中间状态监听</p></li>
</ul>
</li>
<li><p> 缺点：</p>

<ul>
<li>兼容问题</li>
</ul>
</li>
</ul>


<p><img src="http://al1020119.github.io/images/xn020.png" title="Caption" ></p>

<p> 通过RAF动画与settimeout动画对比：</p>

<p><img src="http://al1020119.github.io/images/xn021.png" title="Caption" ></p>

<p> 得到结论：不需要兼容android 4.3浏览器的情况下，请使用RAF制作脚本动画</p>

<ol>
<li>高频事件优化</li>
</ol>


<p><img src="http://al1020119.github.io/images/xn022.png" title="Caption" ></p>

<p> 类似touchmove，scroll这类的事件可导致多次渲染，对于这种事件可以通过以下手段进行优化：</p>

<ul>
<li><p>1.使用requestAnimationFrame监听帧变化，使得在正确的时间进行渲染</p></li>
<li><p>2.增加响应变化的时间间隔，减少重绘次数。</p></li>
</ul>


<p> 最后，针对合成/绘制只提一个优化手段：</p>

<p>   GPU加速</p>

<p> 触发GPU加速的方式有：</p>

<ul>
<li><p>CSS3 transitions</p></li>
<li><p>CSS3 3D transforms</p></li>
<li><p>WebGL 3D 绘制</p></li>
<li><p>Video</p></li>
<li><p>&hellip;</p></li>
</ul>


<p> 使用GPU加速前有对比实验：</p>

<p><img src="http://al1020119.github.io/images/xn023.png" title="Caption" ></p>

<p> GPU加速实际上是大幅减少了合成/绘制时间，从而大大地提高了页面速度，但GPU加速有自己的缺点：</p>

<p> 过多的GPU层会带来性能开销，主要原因是使用GPU加速其实是利用了GPU层的缓存，让渲染资源可以重复使用，所以一旦层多了，缓存增大，就会引起别的性能问题。</p>

<p>总结</p>

<p><img src="http://al1020119.github.io/images/xn024.png" title="Caption" ></p>

<blockquote><p>本文针对页面呈现的四个阶段提出了比较典型的优化手段，到最后，再提醒读者一下：其实优化是双刃剑。
  按需加载提升速度，但可能导致大量重绘；
  Touch响应快，但很多场景不适合；
  GPU加速效率高，但内存开销大等等
  Loading会让整体体验流畅，但容易造成用户流失
  图片压缩让带宽成本降低，但可能会导致视觉效果变差
 类似这样的矛盾点还有很多，请结合业务按照实际情况进行优化。</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NSProxy&amp;NSObject初探]]></title>
    <link href="http://al1020119.github.io/blog/2015/12/13/nsproxy-and-nsobjectchu-tan/"/>
    <updated>2015-12-13T13:20:37+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/12/13/nsproxy-and-nsobjectchu-tan</id>
    <content type="html"><![CDATA[<p>NSObject类属于根类。根类在层级结构中处于最高级，也就是说除此以外没有更高层级。而且Objective-c中还有其他根类，不像Java里只有一个java.lang.Object根类，其他所有的类都直接或间接的继承于它。因此，</p>

<p>Java代码可以依据任何对象来实现它的基本方法。Cocoa有多个根类，除了NSObject还有NSProxy等其他等级的根类。这只是部分原因，NSObject协议定义了一套所有的根类都可以实现的基础方法，这样在编码时就容易找到了。</p>

<p>NSObject类遵循NSObject协议，这就是说，NSObject类实现了下面这些基础方法：</p>

<pre><code>@interface NSObject  
</code></pre>

<p>NSProxy同样遵循NSObject协议：</p>

<pre><code>@interface NSProxy      
</code></pre>

<!--more-->


<p>NSObject协议包含了hash，isEqual:，description等方法。事实上，NSProxy遵循NSObject协议意味着你可以依靠实现NSProxy来实现NSObject方法。</p>

<h3>NSObjetc：</h3>

<p>NSObject协议组对所有的Object－C下的objects都生效。
如果objects遵从该协议，就会被看作是first－class objects（一级类）。
另外，遵从该协议的objects的retain，release，autorelease等方法也服从objects的管理和在Foundation中定义的释放方法。一些容器中的对象也可以管理这些objects，比如
说NSArray 和NSDictionary定义的对象。
Cocoa的根类也遵循该协议，所以所有继承NSObjects的objects都有遵循该协议的特性。</p>

<h3>NSProXY：</h3>

<p>NSProxy 是一个虚基类，它为一些表现的像是其它对象替身或者并不存在的对象定义一套API。一般的，发送给代理的消息被转发给一个真实的对象或者代理本身load(或者将本身转换成)一个真实的对象。NSProxy的基类可以被用来透明的转发消息或者耗费巨大的对象的lazy 初始化。</p>

<p>NSProxy实现了包括NSObject协议在内基类所需的基础方法，但是作为一个虚拟的基类并没有提供初始化的方法。它接收到任何自己没有定义的方法他都会产生一个异常，所以一个实际的子类必须提供一个初始化方法或者创建方法，并且重载forwardInvocation:方法和methodSignatureForSelector:方法来处理自己没有实现的消息。一个子类的forwardInvocation:实现应该采取所有措施来处理invocation,比如转发网络消息，或者加载一个真实的对象，并把invocation转发给他。methodSignatureForSelector:需要为给定消息提供参数类型信息，子类的实现应该有能力决定他应该转发消息的参数类型，并构造相对应的NSMethodSignature对象。详细信息可以查看NSDistantObject, NSInvocation, and NSMethodSignature的类型说明。</p>

<h4>简单使用</h4>

<h6>NSProxy</h6>

<pre><code>// MyProxy.h
#import&lt;Foundation/Foundation.h&gt;

@interface MyProxy :NSProxy {
    NSObject *object;
}

- (id)transformToObject:(NSObject *)anObject;

@end

// MyProxy.m
#import"MyProxy.h"

@implementation MyProxy

- (void)dealloc
{
    [objectrelease];
    object = nil;
    [superdealloc];
}

- (void)fun
{
   // Do someting virtual
    //先做一些代理工作，然后创建一个后台线程，在后台线程中再调用真正的[object fun];
}

// Stupid transform implementation just by assigning a passed in object as transformation target. You can write your factory here and use passed in object as id for object that need ot be created.
- (id)transformToObject:(NSObject *)anObject 
{
    if(object != anObject) {
        [objectrelease];
    }
    object = [anObject retain];
    return object;
}

- (void)forwardInvocation:(NSInvocation *)invocation 
{
    if (object != nil) {
        [invocation setTarget:object];    

        [invocation invoke];
    }
}

- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel 
{
   NSMethodSignature *result;
    if (object != nil) {
        result = [objectmethodSignatureForSelector:sel];
    } else {
       // Will throw an exception as default implementation
        result = [supermethodSignatureForSelector:sel];
    }
    return result;
}

@end
</code></pre>

<hr />

<h6>NSObject</h6>

<pre><code>// RealSubject.h
#import&lt;Foundation/Foundation.h&gt;
@implementation RealSubject : NSObject

- (void)fun;

@end

// RealSubject.m
#import"RealSubject.h"

@implementation RealSubject

- (void)fun
{
    //这个方法需要代理进行惰性调用
   // Do something real
}

- (void)otherFun
{
    //这个方法不需要代理做任何处理，可直接被调用
   // Do something real
}

@end

// main.m
int main(int argc,char *argv[]) 
{
   NSAutoreleasePool * pool = [[NSAutoreleasePoolalloc] init];

    MyProxy *myProxy = [MyProxy alloc];
    RealSubject *realSub = [[RealSubject alloc] init];
    [myProxytransformToObject:realSub];
    [myProxyfun]; // 直接调用myProxy的fun，执行代理工作
    [myProxyotherFun]; // 依次调用myProxy的methodSignatureForSelector和forwardInvocation转发给realSub，realSub调用otherFun

    [realSubject release];
    [myProxyrelease];

    [pool release];
    return 0;
}
</code></pre>

<blockquote><p>注意，调用MyProxy中未定义的方法otherFun会出现'MyProxy' may not respond to &lsquo;fun'的警告，可通过使用私有范畴或通过performSelector:withObject:来避免，如果有更好的方法，请告知。</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[安全机制]]></title>
    <link href="http://al1020119.github.io/blog/2015/12/12/an-quan-ji-zhi/"/>
    <updated>2015-12-12T22:46:51+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/12/12/an-quan-ji-zhi</id>
    <content type="html"><![CDATA[<p>关于安全机制，作为一个程序员必须要时刻记住的，不然你的app不仅没有人用，还会被举报甚至更加严重，所以这里大概的总结了一下。</p>

<ul>
<li>苹果安全机制</li>
<li>ios开发安全处理</li>
</ul>


<!--more-->


<hr />

<p>苹果的安全机制</p>

<p><img src="http://al1020119.github.io/images/anquanjizhi001.png" title="Caption" ></p>

<p>客户端开发安全机制</p>

<p><img src="http://al1020119.github.io/images/anquanjizhi002.png" title="Caption" ></p>

<p>其中网络安全是非常重要的，所以总结了几个网络相关技术。</p>

<p><img src="http://al1020119.github.io/images/anquanjizhi003.png" title="Caption" ></p>

<hr />

<p>概述：iOS应用程序因为其特殊性，被攻击的可能也是很高的。在开发过程中，需要从三个方面考虑程序安全性。</p>

<ul>
<li>iOS应用程序安全开发须知(一)</li>
<li>iOS应用程序安全开发须知(二)</li>
<li>iOS应用程序安全开发须知(三)</li>
</ul>


<h3>网络安全</h3>

<h6>安全地传输用户密码</h6>

<p>大 部分的iOS应用都需要连网，通过和服务器端进行通信，获得最新的信息并且将内容展现给用户。由于网络传输过程中有可能经过不安全的中间节点，所以我们应 该对敏感数据加密，用于保证用户信息的安全。黑客可以在受害者的手机上设置网络通信的代理服务器，从而截获所有的网络请求。即使是HTTPS的加密通信， 黑客也可以通过中间人攻击（Man-In-The-Middle Attack，指的是攻击者与通信的两端分别创建独立的联系，并交换其所收到的数据，使通信的两端认为他们正在通过一个私密的连接与对方直接对话，但事实 上，整个会话都被攻击者完全控制）来截取通信内容。</p>

<p>黑客可以在Mac下使用Charles软件（如果在Windows下，可以使用 Fiddler软件）来将自己的电脑设置成代理服务器，从而截取应用的网络请求，分析目标应用在通信协议上是否有安全问题。为了测试，我选取了在国内最大 的两家租车公司（神州租车和一嗨租车）的iOS应用。</p>

<p><img src="http://al1020119.github.io/images/anquanjizhixiangjie001.jpg" title="Caption" ></p>

<p>从图1可以看到，神州租车和一嗨租车在用户登录时，均采用明文的方式，将密码直接发送给服务器。其中一嗨租车不但采用明文方式发送密码，而且在发送 时使用了Http Get的方式，而GET的URL数据一般都会保存在服务器的Access Log中，所以黑客一旦攻破服务器，只需要扫描Acesss Log，则可以轻易获得所有用户的明文密码（在本文发表前，一嗨租车已修改了登录协议，采用了POST的方式来登录，但仍然传递的是明文密码）。</p>

<p>如 果每一个移动应用都像以上两种应用那样，明文传输用户密码，那么我们可以想象这样一个场景：黑客在咖啡馆或机场等一些公共场所，将自己的电脑设置成与该场 所一样名字的免费Wi-Fi，受害者只要不小心使用了该Wi-Fi，则可能泄漏自己的明文密码。对于大多数普通人来说，他们会使用一样的密码登录他的所有 的账号，这就意味着他的其他账号：例如淘宝或网上银行账号也有被盗的风险。</p>

<p>正 确的做法应该是这样：事先生成一对用于加密的公私钥，客户端在登录时，使用公钥将用户的密码加密后，将密文传输到服务器。服务器使用私钥将密码解密，然后 加盐（Salt，在密码学中是指，通过在密码任意固定位置插入特定的字符串，让散列后的结果和使用原始密码的散列结果不相符，这个过程称为“加盐”），之 后再多次求MD5，然后再和服务器原来存储的用同样方法处理过的密码匹配，如果一致，则登录成功。这样的做法保证黑客即使截获了加密后的密文，由于没有私 钥，也无法还原出原始的密码。而服务器即使被黑客攻陷，黑客除了暴力尝试，也无法从加盐和多次MD5后的密码中还原出原始的密码。这就保证了用户密码的安 全。</p>

<h6>防止通信协议被轻易破解</h6>

<p>除了上面提到的明文传输密码的问题外，移动端应用还要面对黑客对于通信协议的破解的威胁。</p>

<p>在 成功破解了通信协议后，黑客可以模拟客户端登录，进而伪造一些用户行为，可能对用户数据造成危害。例如腾讯出品的消除游戏《天天爱消除》，在淘宝上就有很 多售价仅为1元的代练服务，如果真正是人工代练，是不可能卖这么便宜的，只有可能是该游戏的通信协议被破解，黑客制作出了代练的机器人程序。通信协议被破 解除了对于移动端游戏有严重危害外，对于应用也有很大的危害。例如针对微信，黑客可以制作一些僵尸账号，通过向微信公共账号后台发送垃圾广告，达到赢利的 目的。而iPhone设备上的iMessage通信协议居然也被破解了，所以很多iPhone用户会收到来自iMessage的垃圾广告。</p>

<p>对 于以上提到的问题，开发者可以选择类似ProtoBuf（Google提供的一个开源数据交换格式，其最大的特点是基于二进制，因此比传统的JSON格式 要短小得多）之类的二进制通信协议或自己实现通信协议，对于传输的内容进行一定程度的加密，以增加黑客破解协议的难度。图2是我截取的淘宝客户端的通信数 据，可以看到其中的值都不能直观地猜出内容，所以这对于通信协议是有一定的保护作用。</p>

<p><img src="http://al1020119.github.io/images/anquanjizhixiangjie002.jpg" title="Caption" ></p>

<h6>验证应用内支付的凭证</h6>

<p>iOS 应用内支付（IAP）是众多应用赢利的方式，通过先让用户免费试用或试玩，然后提供应用内支付来为愿意付费的用户提供更强大的功能，这种模式特别适合不习 惯一开始就掏钱的中国用户。但国内越狱用户的比例较大，所以我们也需要注意应用内支付环节中的安全问题。简单来说，越狱后的手机由于没有沙盒作为保护，黑 客可对系统进行任意地修改，所以在支付过程中，苹果返回的已付款成功的凭证可能是伪造的。客户端拿到付款凭证后，还需要将凭证上传到自己的服务器上，进行 二次验证，以保证凭证的真实性。</p>

<p>另外，我们发现越狱用户的手机上，很可能被黑客用中间人攻击技术来劫持支付凭证。这对于黑客有什么好处呢？ 因为苹果为了保护用户的隐私，支付凭证中并不包含任何用户的账号信息，所以我们的应用和服务器无法知道这个凭证是谁买的，而只能知道这个凭证是真的还是假 的。所以在验证凭证时，哪个账号发起了验证请求，我们就默认这个凭证是该账号拥有的。如果黑客将凭证截获，就可以伪装成真实用户来验证凭证或者转手出售获 利。</p>

<p>打个比方，这就类似于很多商场的购物卡一样，由于是不记名的，黑客如果将你买的购物卡偷窃然后去刷卡购物，商场是无法简单地区分出来的。因此，对于应用内支付，开发者除了需要仔细地验证购买凭证外，也需要告知用户在越狱手机上进行支付的风险。</p>

<h3>本地文件和数据安全</h3>

<h6>程序文件的安全</h6>

<p>iOS 应用的大部分逻辑都是在编译后的二进制文件中，但由于近年来混合式（Hybrid）编程方式的兴起，很多应用的部分功能也采用内嵌Web浏览器的方式来实 现。例如腾讯QQ iOS客户端的内部，就有部分逻辑是用Web方式实现的。由于iOS安装文件其实就是一个zip包，所以我们可以通过解压，看到包内的内容。以下是我解开 腾讯QQ客户端，看到的其qqapi.js文件的内容。</p>

<p><img src="http://al1020119.github.io/images/anquanjizhixiangjie003.jpg" title="Caption" ></p>

<p>可以看到，这些文件都有着完整清晰的注释。通过分析这些JavaScript文件，黑客可以很轻松地知道其调用逻辑。在越狱手机上，还可以修改这些JavaScript代码，达到攻击的目的。</p>

<p>我也曾尝试查看支付宝客户端中的彩票功能，通过分析，也可以找到其完整的、带着清晰注释的JavaScript代码，如图3所示（支付宝现在已对相应代码进行了加密）。</p>

<p>支付宝应用内的JavaScript文件
图3  支付宝应用内的JavaScript文件</p>

<p><img src="http://al1020119.github.io/images/anquanjizhixiangjie004.jpg" title="Caption" ></p>

<p>通过将JavaScript源码进行混淆和加密，可以防止黑客轻易地阅读和篡改相关的逻辑，也可以防止自己的Web端与Native端的通信协议泄漏。</p>

<h6>本地数据安全</h6>

<p>iOS 应用的数据在本地通常保存在本地文件或本地数据库中。如果对本地的数据不进行加密处理，很可能被黑客篡改。比如一款名为《LepsWorld 3》的游戏，打开它的本地文件，可以很容易地找到，它使用了一个名为ItempLifes的变量保存生命数值（如图4所示）。于是我们可以简单修改该值， 达到修改游戏参数的目的。而在某宝上，也可以找到许多以此挣钱的商家。对于本地的重要数据，我们应该加密存储或将其保存到keychain中，以保证其不被篡改。</p>

<p><img src="http://al1020119.github.io/images/anquanjizhixiangjie005.jpg" title="Caption" ></p>

<h3>源代码安全</h3>

<p>通过file、class-dump、theos、otool等工具，黑客可以分析编译之后的二进制程序文件，不过相对于这些工具来说，IDA的威胁最大。 IDA是一个收费的反汇编工具，对于Objective-C代码，它常常可以反汇编到可以方便阅读的程度，这对于程序的安全性，也是一个很大的危害。因为 通过阅读源码，黑客可以更加方便地分析出应用的通信协议和数据加密方式。</p>

<p>下面分别示例了一段代码的原始内容和通过IDA反汇编之后的结果。可以看到，IDA几乎还原了原本的逻辑，而且可读性也非常高。</p>

<p>原始代码：</p>

<p><img src="http://al1020119.github.io/images/anquanjizhixiangjie006.jpg" title="Caption" ></p>

<p>反汇编后：</p>

<p><img src="http://al1020119.github.io/images/anquanjizhixiangjie007.jpg" title="Caption" ></p>

<p>反 汇编的代码被获得后，由于软件内部逻辑相比汇编代码来说可读性高了很多。黑客可以用来制作软件的注册机，也可以更加方便地破解网络通信协议，从而制作出机 器人（“僵尸”）账号。最极端的情况下，黑客可以将反汇编的代码稍加修改，植入木马，然后重新打包发布在一些越狱渠道上，这将对用户产生巨大的危害。</p>

<p>对于IDA这类工具，我们的应对措施就比较少了。除了可以用一些宏来简单混淆类名外，也可以通过市面上收费的加密工具来实现，如：.NET Reactor v4.9  Dotfuscator DashO Pro v7.3 Zend Guard等，也达到复用的目的。</p>

<p>总结</p>

<p>由于移动互联网的快速发展，人们的购物、理财等需求也在移动端出现，使得移动应用的安全性越来越重要。由于部署在用户终端上，移动应用比服务器应用更容易被攻击，大家也需要在移动应用的网络通信、本地文件和数据、源代码三方面做好防范，只有这样才能保证应用安全。</p>

<h6>最后分享一份最近加密的demo，由于公司项目的需要，所以就整了一下这个！</h6>

<pre><code>@interface ViewController ()
@property (weak, nonatomic) IBOutlet UITextField *username;
@property (weak, nonatomic) IBOutlet UITextField *pwd;
- (IBAction)login;
@end

@implementation ViewController

- (void)viewDidLoad
{
    [super viewDidLoad];
    // Do any additional setup after loading the view, typically from a nib.
}

- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event
{
    [self.view endEditing:YES];
}

- (IBAction)login {
    // 1.用户名
    NSString *usernameText = self.username.text;
    if (usernameText.length == 0) {
        [MBProgressHUD showError:@"请输入用户名"];
        return;
    }

    // 2.密码
    NSString *pwdText = self.pwd.text;
    if (pwdText.length == 0) {
        [MBProgressHUD showError:@"请输入密码"];
        return;
    }

    // 增加蒙板
    [MBProgressHUD showMessage:@"正在拼命登录中...."];

    // 3.发送用户名和密码给服务器(走HTTP协议)
    // 创建一个URL ： 请求路径
    NSURL *url = [NSURL URLWithString:@"http://218.83.161.124:8080/job/login"];

    // 创建一个请求
    NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url];

    // 5秒后算请求超时（默认60s超时）
    request.timeoutInterval = 15;

    request.HTTPMethod = @"POST";

#warning 对pwdText进行加密
    pwdText = [self MD5Reorder:pwdText];

    // 设置请求体
    NSString *param = [NSString stringWithFormat:@"username=%@&amp;pwd=%@", usernameText, pwdText];

    NSLog(@"%@", param);

    // NSString --&gt; NSData
    request.HTTPBody = [param dataUsingEncoding:NSUTF8StringEncoding];

    // 设置请求头信息
    [request setValue:@"iPhone 6" forHTTPHeaderField:@"User-Agent"];

    // 发送一个同步请求(在主线程发送请求)
    // queue ：存放completionHandler这个任务
    NSOperationQueue *queue = [NSOperationQueue mainQueue];
    [NSURLConnection sendAsynchronousRequest:request queue:queue completionHandler:
     ^(NSURLResponse *response, NSData *data, NSError *connectionError) {
         // 隐藏蒙板
         [MBProgressHUD hideHUD];

        // 这个block会在请求完毕的时候自动调用
        if (connectionError || data == nil) { // 一般请求超时就会来到这
            [MBProgressHUD showError:@"请求失败"];
            return;
        }

        // 解析服务器返回的JSON数据
        NSDictionary *dict = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableLeaves error:nil];
        NSString *error = dict[@"error"];
        if (error) {
            [MBProgressHUD showError:error];
        } else {
            NSString *success = dict[@"success"];
            [MBProgressHUD showSuccess:success];
        }
     }];
}

/**
 *  MD5($pass.$salt)
 *
 *  @param text 明文
 *
 *  @return 加密后的密文
 */
- (NSString *)MD5Salt:(NSString *)text
{
    // 撒盐：随机地往明文中插入任意字符串
    NSString *salt = [text stringByAppendingString:@"aaa"];
    return [salt md5String];
}

/**
 *  MD5(MD5($pass))
 *
 *  @param text 明文
 *
 *  @return 加密后的密文
 */
- (NSString *)doubleMD5:(NSString *)text
{
    return [[text md5String] md5String];
}

/**
 *  先加密，后乱序
 *
 *  @param text 明文
 *
 *  @return 加密后的密文
 */
- (NSString *)MD5Reorder:(NSString *)text
{
    NSString *pwd = [text md5String];

    // 加密后pwd == 3f853778a951fd2cdf34dfd16504c5d8
    NSString *prefix = [pwd substringFromIndex:2];
    NSString *subfix = [pwd substringToIndex:2];

    // 乱序后 result == 853778a951fd2cdf34dfd16504c5d83f
    NSString *result = [prefix stringByAppendingString:subfix];

    NSLog(@"\ntext=%@\npwd=%@\nresult=%@", text, pwd, result);

    return result;
}
</code></pre>

<p>资源分享：</p>

<p>原文地址：<a href="http://www.csdn.net/article/2014-05-28/2819994">http://www.csdn.net/article/2014-05-28/2819994</a></p>

<p>通信安全工具：</p>

<p><a href="http://www.evget.com/product/170">IP*Works! Internet Toolkit v9.0</a></p>

<p><a href="http://www.evget.com/product/178">IP*Works! EDI/AS2 v9.0</a></p>

<p><a href="http://www.evget.com/product/173">IP*Works! S/MIME v9.0</a></p>

<p><a href="http://www.evget.com/product/1915">IP*Works! SSH</a></p>

<p><a href="http://www.evget.com/product/171">IP*Works! SSL</a></p>

<p>代码混淆工具：</p>

<p><a href="http://www.evget.com/product/2399">.NET Reactor v4.9</a></p>

<p><a href="http://www.evget.com/product/676">Dotfuscator</a></p>

<p><a href="http://www.evget.com/product/1339">DashO Pro v7.3</a></p>

<p><a href="http://www.evget.com/product/1339">Zend Guard</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[KeyChain初探]]></title>
    <link href="http://al1020119.github.io/blog/2015/12/12/keychainchu-tan/"/>
    <updated>2015-12-12T22:46:16+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/12/12/keychainchu-tan</id>
    <content type="html"><![CDATA[<p>iOS的keychain服务提供了一种安全的保存私密信息（密码，序列号，证书等）的方式，每个ios程序都有一个独立的keychain存储。相对于NSUserDefaults、文件保存等一般方式，keychain保存更为安全，而且keychain里保存的信息不会因App被删除而丢失，所以在重装App后，keychain里的数据还能使用。</p>

<blockquote><p>“yourAppID.com.yourCompany.whatever”就是你要起的公共区名称，除了whatever字段可以随便定之外，其他的都必须如实填写。这个文件的路径要配置在 Project->build setting->Code Signing Entitlements里，否则公共区无效，配置好后，须用你正式的证书签名编译才可通过，否则xcode会弹框告诉你code signing有问题。所以，苹果限制了你只能同公司的产品共享KeyChain数据，别的公司访问不了你公司产品的KeyChain。</p></blockquote>

<!--more-->


<h3>一.基本知识</h3>

<h6>1.方法</h6>

<ul>
<li>SecItemAdd 增</li>
<li>SecItemUpdate 改</li>
<li>SecItemDelete 删</li>
<li>SecItemCopyMatching 查</li>
</ul>


<h6>2.权限</h6>

<p>文档上说iOS的keyChain是一个相对独立的空间，当程序替换，删除时并不会删除keyChain的内容，这个要比Library/Cache好。刷机，恢复出厂应该就没有了。关于备份，只会备份数据，到那时不会备份设备的密钥，换句话说，即使拿到数据，也没有办法解密里面的内容。有人说似乎破解的手机就能破解keyChain,本人并不清楚，希望有大神能指教。但个人认为，keyChain只是沙盒的升级版，可以存放一些非私密的信息，即使破解也不影响其它用户，只影响那个破解了的设备。（比如针对该设备的一个密钥）。</p>

<p>可访问性一般来说，自己的程序只能访问自己的keychain,相同bundle的程序通过设置group可以互相共享同组的keychain，从而实现程序间可以共同访问一些数据。详细后面介绍一些我测试下来的经验。</p>

<h6>3.如何查询keyChain</h6>

<pre><code>[objc] view plaincopyprint?在CODE上查看代码片派生到我的代码片
genericPasswordQuery = [[NSMutableDictionary alloc] init];   
[genericPasswordQuery setObject:(id)kSecClassGenericPassword forKey:(id)kSecClass];//1  
[genericPasswordQuery setObject:identifier forKey:(id)kSecAttrGeneric];//2  
if (accessGroup != nil){  
    [genericPasswordQuery setObject:accessGroup forKey:(id)kSecAttrAccessGroup];//3  
}  
[genericPasswordQuery setObject:(id)kSecMatchLimitOne forKey:(id)kSecMatchLimit];//4  
[genericPasswordQuery setObject:(id)kCFBooleanTrue forKey:(id)kSecReturnAttributes];//5  
NSDictionary *tempQuery = [NSDictionary dictionaryWithDictionary:genericPasswordQuery];  
NSMutableDictionary *outDictionary = nil;      
if (SecItemCopyMatching((CFDictionaryRef)tempQuery, (CFTypeRef *)&amp;outDictionary) == noErr){//6  
//found and outDicitionary is not nil  
}else{  
//not found  
}  
</code></pre>

<ul>
<li>1.设置Class值，每个Class对应的都有不同的参数类型</li>
<li>2.用户确定的参数，一般是程序中使用的类别，比如说是"Password"或"Account Info"，作为search的主力条件</li>
<li>3.设置Group,如果不同程序都拥有这个组，那么不同程序间可以共享这个组的数据</li>
<li>4.只返回第一个匹配数据，查询方法使用，还有值kSecMatchLimitAll</li>
<li>5.返回数据为CFDicitionaryRef，查询方法使用</li>
<li>6.执行查询方法，判断返回值</li>
</ul>


<blockquote><p>eg:这个是none-ARC的代码哦！ARC情况下会有bridge提示。</p></blockquote>

<h6>4.类型转换</h6>

<p>介绍增删改方法调用前，先介绍转换方法，如何将NSDictionary转换成KeyChain方法可以设置的Dicitionary，一般在写程序过程中，应该尽量避免直接访问KeyChain，一般会创建一个NSDictionary来同步对应的数据，所以两者需要做转换。</p>

<pre><code>//data to secItem  
- (NSMutableDictionary *)dictionaryToSecItemFormat:(NSDictionary *)dictionaryToConvert  
{  
    // Create a dictionary to return populated with the attributes and data.  
    NSMutableDictionary *returnDictionary = [NSMutableDictionary dictionaryWithDictionary:dictionaryToConvert];  

    //设置kSecClass  
    [returnDictionary setObject:(id)kSecClassGenericPassword forKey:(id)kSecClass];  
    //将Dictionary里的kSecValueData(一般就是这个keyChain里主要内容，比如说是password),NSString转换成NSData  
    NSString *passwordString = [dictionaryToConvert objectForKey:(id)kSecValueData];  
    [returnDictionary setObject:[passwordString dataUsingEncoding:NSUTF8StringEncoding] forKey:(id)kSecValueData];  
    return returnDictionary;  
}  
//secItem to data  
- (NSMutableDictionary *)secItemFormatToDictionary:(NSDictionary *)dictionaryToConvert  
{  
    NSMutableDictionary *returnDictionary = [NSMutableDictionary dictionaryWithDictionary:dictionaryToConvert];  

    // Add the proper search key and class attribute.  
    [returnDictionary setObject:(id)kCFBooleanTrue forKey:(id)kSecReturnData];  
    [returnDictionary setObject:(id)kSecClassGenericPassword forKey:(id)kSecClass];  

    // Acquire the password data from the attributes.  
    NSData *passwordData = NULL;  
    if (SecItemCopyMatching((CFDictionaryRef)returnDictionary, (CFTypeRef *)&amp;passwordData) == noErr)  
    {  
        // 删除多余的kSecReturnData数据  
        [returnDictionary removeObjectForKey:(id)kSecReturnData];  

        // 对应前面的步骤，将数据从NSData转成NSString  
        NSString *password = [[[NSString alloc] initWithBytes:[passwordData bytes] length:[passwordData length]  
                                                     encoding:NSUTF8StringEncoding] autorelease];  
        [returnDictionary setObject:password forKey:(id)kSecValueData];  
    }  
    else  
    {  
        NSAssert(NO, @"Serious error, no matching item found in the keychain.\n");  
    }  
    [passwordData release];   
    return returnDictionary;  
}  
</code></pre>

<h6>5.增删改</h6>

<p>用代码来说明</p>

<pre><code>- (void)writeToKeychain  
{  
    NSDictionary *attributes = NULL;  
    NSMutableDictionary *updateItem = NULL;  
    OSStatus result;  
    //判断是增还是改  
    if (SecItemCopyMatching((CFDictionaryRef)genericPasswordQuery, (CFTypeRef *)&amp;attributes) == noErr)  
    {  
            // First we need the attributes from the Keychain.  
            updateItem = [NSMutableDictionary dictionaryWithDictionary:attributes];  
        // Second we need to add the appropriate search key/values.  
            [updateItem setObject:[genericPasswordQuery objectForKey:(id)kSecClass] forKey:(id)kSecClass];  
            // Lastly, we need to set up the updated attribute list being careful to remove the class.  
            NSMutableDictionary *tempCheck = [self dictionaryToSecItemFormat:keychainItemData];  
            //删除kSecClass update不能update该字段，否则会报错  
            [tempCheck removeObjectForKey:(id)kSecClass];  
        //参数1表示search的，参数2表示需要更新后的值  
            result = SecItemUpdate((CFDictionaryRef)updateItem, (CFDictionaryRef)tempCheck);  
    }else{  
            //增加  
            result = SecItemAdd((CFDictionaryRef)[self dictionaryToSecItemFormat:keychainItemData], NULL);  
    }  
}  
</code></pre>

<p>删除很简单，就不写注释了</p>

<pre><code>- (void)resetKeychainItem  
{  
    OSStatus junk = noErr;  
    if (!keychainItemData)  
    {  
        self.keychainItemData = [[NSMutableDictionary alloc] init];  
    }  
    else if (keychainItemData)  
    {  
        NSMutableDictionary *tempDictionary = [self dictionaryToSecItemFormat:keychainItemData];  
        junk = SecItemDelete((CFDictionaryRef)tempDictionary);  
        NSAssert( junk == noErr || junk == errSecItemNotFound, @"Problem deleting current dictionary." );  
    }  

    // Default attributes for keychain item.  
    [keychainItemData setObject:@"" forKey:(id)kSecAttrAccount];  
    [keychainItemData setObject:@"" forKey:(id)kSecAttrLabel];  
    [keychainItemData setObject:@"" forKey:(id)kSecAttrDescription];  

    // Default data for keychain item.  
    [keychainItemData setObject:@"" forKey:(id)kSecValueData];  
}  
</code></pre>

<p>二.Group的配置
配置Target的Code Signing Entitlements.</p>

<p><img src="http://al1020119.github.io/images/keyChain001.png" title="Caption" ></p>

<p>配置该文件</p>

<p><img src="http://al1020119.github.io/images/keyChain002.png" title="Caption" ></p>

<p><img src="http://al1020119.github.io/images/keyChain003.png" title="Caption" ></p>

<p>可以配置一个Array列表，表示该程序可以支持多个group
这样就可以在创建secItem时候添加kSecAttrAccessGroup了。
经过测试有以下经验同大家分享：</p>

<ul>
<li><p>1.相同bundle下生成的程序都可以共享相同group的keyChain.
相同bundle解释下就是：比如:2个程序分别使用的provision对应bundle是com.jv.key1和com.jv.key2，那你配置文件肯定是{Identifer}.com.jv.{name},其中identifer是苹果生成的随机串号，可以在申请证书时看到，复制过来即可，name可以自己取，程序中指定属于哪个Group即可。</p></li>
<li><p>2.如果你在 addkey时，没有指定group,则会默认添加你keychain-access-groups里第一个group，如果你没有设置Entitlements,则默认使用对应的程序的bundle name,比如com.jv.key1,表示只能给自己程序使用。</p></li>
<li><p>3.如果你程序添加的group并不存在你的配置文件中，程序会奔溃，表示无法添加。因此你只能添加你配置文件中支持的keychain。</p></li>
</ul>


<p>三、保存私密信息（工具）
在应用里使用使用keyChain，我们需要导入Security.framework ，keychain的操作接口声明在头文件SecItem.h里。直接使用SecItem.h里方法操作keychain，需要写的代码较为复杂，为减轻咱们程序员的开发，我们可以使用一些已经封装好了的工具类，下面我会简单介绍下我用过的两个工具类：KeychainItemWrapper和SFHFKeychainUtils。</p>

<p>（一）KeychainItemWrapper是apple官方例子“GenericKeychain”里一个访问keychain常用操作的封装类，在官网上下载了GenericKeychain项目后，只需要
把“KeychainItemWrapper.h”和“KeychainItemWrapper.m”拷贝到我们项目，并导入Security.framework 。KeychainItemWrapper的用法：</p>

<pre><code>/** 初始化一个保存用户帐号的KeychainItemWrapper */
KeychainItemWrapper *wrapper = [[KeychainItemWrapper alloc] initWithIdentifier:@"Account Number"
                                                                   accessGroup:@"YOUR_APP_ID_HERE.com.yourcompany.AppIdentifier"];  

//保存帐号
[
wrapper setObject:@"&lt;帐号&gt;" forKey:(id)kSecAttrAccount];    

//保存密码
[
wrapper setObject:@"&lt;帐号密码&gt;" forKey:(id)kSecValueData];    

//从keychain里取出帐号密码
NSString *password = [wrapper objectForKey:(id)kSecValueData];      

//清空设置
[
wrapper resetKeychainItem];
</code></pre>

<p>其中方法“- (void)setObject:(id)inObject forKey:(id)key;”里参数“forKey”的值应该是Security.framework 里头文件“SecItem.h”里定义好的key，用其他字符串做key程序会崩溃！</p>

<p>（二）SFHFKeychainUtils 提供了在 iOS keychain中安全的存储密码的工具</p>

<p>下载地址<a href="https://github.com/ldandersen/scifihifi-iphone/tree/master/security">https://github.com/ldandersen/scifihifi-iphone/tree/master/security</a></p>

<ul>
<li><p>1、引入Security.frameWork框架。</p></li>
<li><p>2、引入头文件：SFHKeychainUtils.h.</p></li>
<li><p>3、存密码：</p></li>
</ul>


<hr />

<pre><code>[SFHFKeychainUtils storeUsername:@"dd" andPassword:@"aa"forServiceName:SERVICE_NAME updateExisting:1 error:nil];

[SFHFKeychainUtils deleteItemForUsername:@"dd" andServiceName:SERVICE_NAME error:nil];
</code></pre>

<ul>
<li>4、取密码：</li>
</ul>


<hr />

<pre><code>NSString *passWord =  [SFHFKeychainUtils getPasswordForUsername:@"dd"andServiceName:SERVICE_NAME error:nil];
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SVN实战总结]]></title>
    <link href="http://al1020119.github.io/blog/2015/12/12/svnshi-zhan-zong-jie/"/>
    <updated>2015-12-12T22:44:29+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/12/12/svnshi-zhan-zong-jie</id>
    <content type="html"><![CDATA[<ul>
<li>A：add，新增</li>
<li>C：conflict，冲突</li>
<li>D：delete，删除</li>
<li>M：modify，本地已经修改</li>
<li>G：modify and merGed，本地文件修改并且和服务器的进行合并</li>
<li>U：update，从服务器更新</li>
<li>R：replace，从服务器替换</li>
<li>I：ignored，忽略</li>
</ul>


<p>常见提示图标：</p>

<h6>黄色感叹号(有冲突):</h6>

<pre><code>--这是有冲突了，冲突就是说你对某个文件进行了修改，别人也对这个文件进行了修改，别人抢在你提交之前先提交了，这时你再提交就会被提示发生冲突，而不允许你提交，防止你的提交覆盖了别人的修改。要解决冲突，如果你确认你的修改是无效的，则用TSVN还原你的修改就行了；如果认为你的修改是正确的，别人的提交是无效的，那么用TSVN先标记为“解决冲突”，然后就可以提交了；如果你认为你的修改和别人的修改都有一部分是有效的，那么你就把别人的修改手动合并到你的修改中，然后使用TSVN标注为“解决冲突”，然后就可以提交了。进入文件夹，寻找有黄色感叹号的文件，这些文件就是发生冲突的地方，根据实际情况处理冲突
</code></pre>

<!--more-->


<h6>米字号(有本地修改代码)：</h6>

<pre><code>--这是说明你有未提交的本地代码。
</code></pre>

<h6>问好(新加入的资源):</h6>

<pre><code>--这说明该文件是项目中新增文件资源，新增资源可以是文件、图片、代码等。
</code></pre>

<h6>红色感叹号(本地代码与库没有保持一致)：</h6>

<pre><code>--这说明本地代码跟库上没有保持一致，如果用户想修复，可以将带红色感叹号图标文件删除，直接update即可。
</code></pre>

<h6>灰色向右箭头(本地修改过)</h6>

<pre><code>--本地代码没有及时上库。
</code></pre>

<h6>蓝色向左箭头(SVN上修改过)</h6>

<pre><code>--记得更新代码后修改，提交前跟svn对比习惯。
</code></pre>

<h6>灰色向右且中间有个加号的箭头(本地比SVN上多出的文件)</h6>

<pre><code>--修改完记得跟svn保持一致
</code></pre>

<h6>蓝色向左且中间有个加号的箭头(SVN上比本地多出的文件)</h6>

<pre><code>--删除该文件后，再次更新，将svn上文件全部更新下来。
</code></pre>

<h6>灰色向右且中间有个减号的箭头(本地删除了,而SVN上未删除的文件)</h6>

<pre><code>--也就是说你删除确认后，一定要记得上库，跟svn保持一致
</code></pre>

<h6>蓝色向左且中间有个减号的箭头(SVN上删除了,而本地未删除的文件)</h6>

<pre><code>--比对svn库上代码，确定需要删除后，更新svn(删除无用代码)。
</code></pre>

<h6>红色双向箭头(SVN上修改过,本地也修改过的文件 )</h6>

<pre><code>--这个表示本地和svn上都修改过，最好就是把本地修改合并到svn，修改代码前最后先更新。
</code></pre>

<h4>版本回退</h4>

<ul>
<li><p>本地版本回退：</p>

<ul>
<li>右键选中对应的项目或者文件，弹出菜单中选中Revert</li>
<li>提示你当前工程有一些修改，但是还没提交，"Discard XXX"-点击后当前修改的内容会被取消，“Copy XXX”-点击会会先复制一份代码到废纸篓</li>
<li>点击 “Discard XXX”后，本地工程已更新至选择的版本，如果想将服务器上的也更新到选择的版本，可以再commit。</li>
</ul>
</li>
<li><p>服务器版本回退：误将错误的文件上传到了svn服务器，回滚的办法是：</p>

<ul>
<li>1：svn merge -r100:99 .  （注意有个点，表示当前路径）</li>
<li>2：svn ci -m &ldquo;revert version&rdquo; . （代码提交，实际上删除之前误传的文件）</li>
</ul>
</li>
</ul>


<h4>.a（库文件）</h4>

<ul>
<li>首先打开软件左上角 CornerStone-Preferences-SubVersion</li>
<li>第一个地方把对号去掉，第二个地方把.a那个删除，然后save。</li>
<li>然后把你的.a文件放到本地的相应文件夹下，</li>
<li>但是 CornerStone（我的是v2.7.10 版本的） 里相应文件夹下看不到带问号的.a文件的话，点击上边 View-Show Ignored  Items</li>
<li>到这里就ok了，选中你的静态库 点击底部Add 问号会变成A，然后就可以提交了。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[爬虫必备-java抓包]]></title>
    <link href="http://al1020119.github.io/blog/2015/12/11/java/"/>
    <updated>2015-12-11T12:03:23+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/12/11/java</id>
    <content type="html"><![CDATA[<p>前面我们介绍了怎么使用青花瓷和正则表达式抓包，今天就来介绍一下最后一篇：使用java抓包</p>

<p>java是大家再熟悉不过了，所以不用太担心有多难，因为里面涉及的java技术几乎为0（有点夸张），所以想想看完这篇之后你就会知道怎么使用java快速抓包，还能根据自己的喜好选择对应的方式！</p>

<p>我们开始吧！</p>

<p>前提：熟悉java语法（能看懂就行）</p>

<ul>
<li>准备阶段：从网页中获取html代码</li>
<li>实战阶段：将对应的html代码使用java语言解析出来，最后保存到plist文件</li>
</ul>


<!--more-->


<h2>一:准备阶段－－》获取html代码</h2>

<h6>1:打开你对应想要获取数据的网页，使用firefox打开（因为他有一个自带的神器叫：firebug，关于firebug这里就多说了，反正对于网页开发来说她就是神器），这里我们使用的是dota首页英雄的介绍。</h6>

<p>首先来看看我们需要的数据</p>

<p><img src="http://al1020119.github.io/images/ava001.png" title="Caption" ></p>

<h6>2:由于在网页开发中也是分模块开发的，所以一定的区域在html中对应对应的html代码模块，所以我们选取界面中一个小的模块作为练习。</h6>

<p>找到对应的模块，点击右键在firebug中查看元素</p>

<p><img src="http://al1020119.github.io/images/ava002.png" title="Caption" ></p>

<p>（确保已安装firebug，没有安装的去火狐工具栏中工具标签里面的一个附加组件搜索并下载安装就可以）</p>

<p>这个时候网页的下面就会显示对应模块的html代码，我们需要找到我们想要获取的数据对应的html模块代码，点击右键拷贝我们需要的html。</p>

<p> <img src="http://al1020119.github.io/images/ava003.png" title="Caption" ></p>

<h6>3:在界面简一个html文件将拷贝好的html代码粘贴到文件中，然后就需要哪么一丢丢的html相关知识了，就是补充html中的数据，使他成为完整的html文件</h6>

<p><img src="http://al1020119.github.io/images/ava004.png" title="Caption" ></p>

<p>这里注意一下编码方式：开发中常用的都是utf－8的格式</p>

<h2>二:实战阶段－－》抓取html（网页数据）</h2>

<p>然后我们就要正式开工了，后面才是重点，前面那都是傻瓜是的操作（后面的才做中需要有那么一丢丢的java或者android开发的基础，当然不会耶没有关系，笔者会完整的介绍流程）</p>

<h6>1:代开Eclipse</h6>

<p><img src="http://al1020119.github.io/images/ava005.png" title="Caption" ></p>

<p>新建一个java项目，并且点击项目中的src新建一个class专门用来实现数据的解析</p>

<p><img src="http://al1020119.github.io/images/ava006.png" title="Caption" ></p>

<h6>2:新建好项目之后就要用到我们的一个java的jar包，专门用来抓取网络数据的包：关于包的下载后面笔者会给出下载链接</h6>

<p><img src="http://al1020119.github.io/images/ava007.png" title="Caption" ></p>

<p>将下载好的jar包导入到java工程项目中。</p>

<p>然后我们需要将他添加到build路径（这里是一个常识，java中的jar包没有添加到build路径是不能使用的，添加之后对应的咖啡图标会变成奶瓶）</p>

<p><img src="http://al1020119.github.io/images/ava008.png" title="Caption" ></p>

<p>成功之后的显示</p>

<p><img src="http://al1020119.github.io/images/ava009.png" title="Caption" ></p>

<p>下面开始使用java正式抓取并解析html（网页）数据</p>

<p>根据下面的图片在java工程项目中书写html数据解析的代码：（注意里面的步骤）</p>

<p><img src="http://al1020119.github.io/images/ava0010.png" title="Caption" ></p>

<p>java核心代码：</p>

<pre><code>try {

　　　　　　//文件路径

　　　　　　　　String path = " /Users/icocos/Desktop/iCocos.html";



　　　　　　　　//加载网页

　　　　　　　　Document doc = Jsoup.parse(new File(path), "UTF-8");



　　　　　　　　//解析网页

　　　　　　　　Elements lis = doc.select("li");



　　　　　　　 //遍历数组

　　　　　　　　for(int i = 0; i &lt; eles.size(); i++) {

　　　　　　　　//根据i获取对应的元素

　　　　　　　　Element li = lis.get(i);



　　　　　　　　//取图片

　　　　　　　　Element img = li.select("img").get(0);

　　　　　　　　// System.out.println(img.attr("src"));



　　　　　　　　//获取图片名

　　　　　　　　String imgName = img.attr("src");



　　　　　　　 Element p = li.select("p").get(0);

　　　　　　　　String personName = p.text();



　　　　　　　　//打印数据

　　　　　　　　System.out.println(imgName + "," + personName);



　　　　　　}

　　　　　} catch {

　　　　//错误（异常）处理

　　　　e.printStackTrace();

}
</code></pre>

<p>此时点击Run运行之后，Eclipse就会根据你的代码输出对应的信息</p>

<p><img src="http://al1020119.github.io/images/ava011.png" title="Caption" ></p>

<p>但是这个时候我并不能直接使用数据所以需要在java代码中做一些相应的修改，使得输出的数据可以直接拷贝并且读到plist中，其实就是数组或者字典数据</p>

<p>我们知道在ios开发中从plist文件中读取数据时最常见的，当然你也可以使用其他方式，但是没有比这更简单了。</p>

<p>下面我给java代码做一些调整</p>

<p>1:在for循环之前输入这一行代码，实现数据拼接并且数据</p>

<pre><code>System.out.println("NSArray *apps = @[");
</code></pre>

<p>2:接着就需要在for循环结束之后输入预知对应的拼接数组结尾标志</p>

<pre><code>System.out.println("]");
</code></pre>

<p>3:在for循环内部的最后面我们需要在每次循环的时候都要使用上面的代码进行拼接并且使用逗号做相应的分割</p>

<pre><code>System.out.println("@{@\"name\":@\"" + personName + "\", @\"icon\":@\""+ imgName + "\"},");
</code></pre>

<p>最后完整的java获取并且解析html数据如下；</p>

<pre><code>public class iCocos {

public static void main (String[] args) {

　　　 try {

　　　　　　//文件路径

　　　　　　String path = " /Users/icocos/Desktop/iCocos.html";

　　　　　　//加载网页
　　　　　　Document doc = Jsoup.parse(new File(path), "UTF-8");

　　　　　　//解析网页
　　　　　　Elements lis = doc.select("li");

　　　　　　System.out.println("NSArray *apps = @[");


　　　　　　//遍历数组

　　　　　　for(int i = 0; i &lt; eles.size(); i++) {

　　　　　　//根据i获取对应的元素

　　　　　　Element li = lis.get(i);


　　　　　　//取图片

　　　　　　Element img = li.select("img").get(0);

　　　　　　// System.out.println(img.attr("src"));

　　　　　　//获取图片名

　　　　　　String imgName = img.attr("src");

　　　　　　Element p = li.select("p").get(0);

　　　　　　String personName = p.text();

　　　　　　//打印数据
　　　　　　// System.out.println(imgName + "," + personName);

　　　　　　System.out.println("@{@\"name\":@\"" + personName + "\", @\"icon\":@\""+ imgName + "\"},");
　　　　　　}
　　　　　　System.out.println("]");

　　　　} catch {

　　　　　　//错误（异常）处理
　　　　　　e.printStackTrace();

　　　　}

　　}

}
</code></pre>

<p>这个时候回打印输出下面的代码，</p>

<p><img src="http://al1020119.github.io/images/ava012.png" title="Caption" ></p>

<p>下面我们就需要在xcode中做事情了，做什么事呢，就是将输出的以NSArray开头的所有数据在Xcode中转换为plist的数据，当然你也可以不转换，做少部分的修改之后直接使用JSON解析技术去解析，但是那样不是最好的办法。</p>

<p>在Xcode中新建一个项目工程，在ViewDidLoad中粘贴拷贝过来的代码，这个时候是不是看起来非常熟悉，对了，她就是我吗开发中常用到的数组数据。</p>

<p>下面我就使用循环遍历去讲NSArray数组数据写到plist文件中。</p>

<pre><code>- (void)viewDidLoad

{

    [super viewDidLoad];



    NSArray *apps = @[

  @{@"name":@"敌法师", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/dfss.jpg"},

  @{@"name":@"火枪", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/arjj.jpg"},

  @{@"name":@"德鲁伊", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/dlyy.jpg"},

  @{@"name":@"月骑", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/yzqs.jpg"},

  @{@"name":@"变体精灵", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/btjl.jpg"},

  @{@"name":@"娜迦海妖", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/njhy.gif"},

  @{@"name":@"猴子", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/hycm.jpg"},

  @{@"name":@"白虎", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/yzjs.jpg"},

  @{@"name":@"隐形刺客", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/yxck.jpg"},

  @{@"name":@"巨魔", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/jmzj.jpg"},

  @{@"name":@"直升机", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/arzs.jpg"},

  @{@"name":@"赏金猎人", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/Naka.gif"},

  @{@"name":@"骷髅射手", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/KLSS.gif"},

  @{@"name":@"育母蜘蛛", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/YMZZ.gif"},

  @{@"name":@"血魔", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/XM.gif"},

  @{@"name":@"黑暗游侠", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/Nbrn.gif"},

  @{@"name":@"虚空假面", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/EC45.gif"},

  @{@"name":@"蛇发女妖", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/H00V.gif"},

  @{@"name":@"地卜师", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/H00I.gif"},

  @{@"name":@"地穴刺客", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/DXCK.gif"},

  @{@"name":@"蚂蚁", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/DXBZ.gif"},

  @{@"name":@"幻影刺客", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/HYCK.gif"},

  @{@"name":@"闪电幽魂", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/E002.gif"},

  @{@"name":@"影魔", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/YM01.gif"},

  @{@"name":@"小鱼人", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/yryx.gif"},

  @{@"name":@"幽鬼", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/YG1.gif"},

  @{@"name":@"圣堂刺客", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/E01Y.gif"},

  @{@"name":@"灵魂守卫", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/LHSW.gif"},

  @{@"name":@"熊战士", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/Huth.gif"},

  @{@"name":@"剧毒术士", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/JDSS.gif"},

  @{@"name":@"冥界亚龙", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/MJYL.gif"},

  @{@"name":@"复仇之魂", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/Hvwd.jpg"},

  @{@"name":@"剑圣", @"icon":@"http://dotadb.uuu9.com/UploadFiles/Dota/Hero/jsjs.jpg"}

  ];



    [newApps writeToFile:@"/Users/icocos/Desktop/apps.plist" atomically:YES];
</code></pre>

<p>这个时候我吗的左面就有了这个plist文件，打开之后你会看到</p>

<p><img src="http://al1020119.github.io/images/ava013.png" title="Caption" ></p>

<p>最后的步骤就是图片的下载，</p>

<pre><code>//简单写入

//    for (NSDictionary *dict in apps) {

//        NSString *icon = dict[@"icon"];

//        

//        // 新建网络图片的URL路径

//        NSURL *url = [NSURL URLWithString:icon];

//        

//        // 下载图片的二进制数据

//        NSData *data = [NSData dataWithContentsOfURL:url];

//        

//        // 截取文件名

//        NSString *filename = [icon lastPathComponent];

//        

//        // 文件路径

//        NSString *iconPath = [NSString stringWithFormat:@"/Users/icocos/Desktop/Icons/%@", filename];

//        

//        [data writeToFile:iconPath atomically:YES];

//    }
</code></pre>

<p>由于plist中图片名使用的都是对应链接的最后一个名字，所以我们不能使用上面的方法，还需要做一些处理，才能真正使用</p>

<pre><code>NSMutableArray *newApps = [NSMutableArray array];

    for (NSDictionary *dict in apps) {

        NSMutableDictionary *newDict = [NSMutableDictionary dictionary];

        newDict[@"name"] = dict[@"name"];

        newDict[@"icon"] = [dict[@"icon"] lastPathComponent];

        [newApps addObject:newDict];

    }



    [newApps writeToFile:@"/Users/icocos/Desktop/apps.plist" atomically:YES];



}
</code></pre>

<p><img src="http://al1020119.github.io/images/ava014.png" title="Caption" ></p>

<p>图片下载完成之后你会回看到对应的文件夹中快速的出现了好多的图片</p>

<p><img src="http://al1020119.github.io/images/ava015.png" title="Caption" ></p>

<p>此时我们就得到了一份和网页想相对应比较完整的plist数据，后面我们要做的就是将我们的plist数据显示到界面，后面我就不介绍了，详细请看：plist文件读取</p>

<blockquote><p>最后总结一下，如果以后遇到了关于需要抓取网络数据实现网络爬虫的功能的时候，我们基本上想到的第一种方法就是使用java语言，当然公司一般不会有这样的要求，公司一般都是使用自己服务器的api来实现，特殊情况除外。</p></blockquote>

<p>当然你也可以使用正则表达式或者Python，关于正则表达式相对来说还是比较难的，主要是细节比较多。而Python本人还没有研究过，有机会尝试一下，如果您还有什么好的方法欢迎笔者联系，相互学习与讨论。</p>

<p>我们基本上可以按照上面的思路去实现，只需要做少部分的修改，这里大致说一下</p>

<ul>
<li>1:准备阶段根据你需要的数据会有不同的html产生</li>
<li>2:产生不同的html之后你html内部的结构就会做响应的变化，这个时候你就要去把java那段核心代码搞懂来就没问题了，最重要的还是这里。</li>
<li>3:根据对应的NSArray数据写入到plist文件中，这里是iOS开发中常用的技术我就不多说。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[爬虫必备-Phthon抓包]]></title>
    <link href="http://al1020119.github.io/blog/2015/12/11/pa-chong-bi-bei-phthonzhua-bao/"/>
    <updated>2015-12-11T11:03:23+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/12/11/pa-chong-bi-bei-phthonzhua-bao</id>
    <content type="html"><![CDATA[<p>由于最近都在研究网络爬虫技术，自己也总结了一些。接住一个朋友（boyXiong）的博文，了解到了python抓包技术，所以就整理到这里，希望你能喜欢！</p>

<h4>准备搭建环境</h4>

<p>因为是MAC电脑，所以自动安装了Python 2.7的版本</p>

<p>添加一个 库 Beautiful Soup ,方法这里说两种</p>

<ul>
<li>1.在终端输入 pip install BeautifulSoup</li>
<li>2.手动下载包后，终端切换到 解压的文件夹，输入 sudo python setup.py install 下载地址BeautifulSoup</li>
</ul>


<!--more-->


<h4>开始写代码吧</h4>

<p>先找一个想要抓取东西的网站，这里我就随便找一个吧 地址是：<a href="http://movie.douban.com/chart">http://movie.douban.com/chart</a>
好了在终端输入 vim 我知道这个东西，对于新手来说，就是一个挑战，这里我也建议使用轻量的Sublime
代码如下 (注意python是严格的缩进,以下代码要顶格写)</p>

<pre><code>#-*- coding:utf-8 -*-
import urllib2
import urllib
html=urllib2.urlopen("http://movie.douban.com/chart").read()
print html
</code></pre>

<p>输出的结果就是一个HTML的网页，这里我就看到自己想要抓取的图片和图片名的文字片段</p>

<pre><code>&lt;a class="nbg" href="http://movie.douban.com/subject/24879839/"  title="道士下山"&gt;
           &lt;img src="http://img3.douban.com/view/movie_poster_cover/ipst/public/p2251450614.jpg" alt="道士下山" class=""/&gt;
&lt;/a&gt;
</code></pre>

<p>分析我们想要的，一个是图片的名称，一个是图片的链接地址，直接上Python代码
    #-<em>- coding:utf-8 -</em>-
    import urllib2
    from bs4 import BeautifulSoup</p>

<pre><code>import sys  
reload(sys)  
sys.setdefaultencoding('utf8')

# 函数
def  printPlistCode():
    #1.得到这个网页的 html 代码 #
    html = urllib2.urlopen("http://movie.douban.com/chart").read()

    #2.转换 一种格式，方便查找
    soup = BeautifulSoup(html)
    #3.  得到 找到的所有 包含 a 属性是class = nbg 的代码块,数组
    liResutl = soup.findAll('a', attrs = {"class" : "nbg"})
    #4.用于拼接每个字典的字符串
    tmpDictM = ''

    #5. 遍历这个代码块  数组
    for li in liResutl:

        #5.1 找到 img 标签的代码块 数组
        imageEntityArray = li.findAll('img')

        #5.2 得到每个image 标签
        for image in imageEntityArray:
            #5.3 得到src 这个属性的 value  后面也一样 类似 key value
            link = image.get('src')
            imageName = image.get('alt')
            #拼接 由于 py中 {} 是一种数据处理格式，类似占位符
            tmpDict = '''@{0}@\"name\" : @\"{1}\", @\"imageUrl\" : @\"{2}\"{3},'''

            tmpDict =  tmpDict.format('{',imageName,link,'}')

            tmpDictM = tmpDictM + tmpDict

    #6.去掉最后一个 , 
    tmpDictM = tmpDictM[0:len(tmpDictM) - 1].decode('utf8')

    #7 拼接全部
    restultStr = '@[{0}];'.format(tmpDictM)

    print restultStr


if __name__ == '__main__':
    printPlistCode()
</code></pre>

<p>输出结果就是Objective-C的 数组</p>

<pre><code>@[@{@"name" : @"进击的巨人真人版：前篇", @"imageUrl" : @"http://img3.douban.com/view/movie_poster_cover/ipst/public/p2251690571.jpg"},@{@"name" : @"花与爱丽丝杀人事件", @"imageUrl" : @"http://img3.douban.com/view/movie_poster_cover/ipst/public/p2222398443.jpg"},@{@"name" : @"小黄人大眼萌", @"imageUrl" : @"http://img4.douban.com/view/movie_poster_cover/ipst/public/p2258235689.jpg"},@{@"name" : @"小森林 冬春篇", @"imageUrl" : @"http://img4.douban.com/view/movie_poster_cover/ipst/public/p2215147728.jpg"},@{@"name" : @"道士下山", @"imageUrl" : @"http://img3.douban.com/view/movie_poster_cover/ipst/public/p2251450614.jpg"},@{@"name" : @"深夜食堂 电影版", @"imageUrl" : @"http://img3.douban.com/view/movie_poster_cover/ipst/public/p2205014862.jpg"},@{@"name" : @"小男孩", @"imageUrl" : @"http://img4.douban.com/view/movie_poster_cover/ipst/public/p2230105606.jpg"},@{@"name" : @"头脑特工队", @"imageUrl" : @"http://img4.douban.com/view/movie_poster_cover/ipst/public/p2231021196.jpg"},@{@"name" : @"百元之恋", @"imageUrl" : @"http://img4.douban.com/view/movie_poster_cover/ipst/public/p2205471169.jpg"},@{@"name" : @"杀破狼2", @"imageUrl" : @"http://img4.douban.com/view/movie_poster_cover/ipst/public/p2246885606.jpg"}];
</code></pre>

<p>使用Xcode 写到Plist中去</p>

<pre><code>#import &lt;Foundation/Foundation.h&gt;

int main(int argc, const char * argv[]) {


NSArray *plistArray = @[@{@"name" : @"进击的巨人真人版：前篇", @"imageUrl" : @"http://img3.douban.com/view/movie_poster_cover/ipst/public/p2251690571.jpg"},@{@"name" : @"花与爱丽丝杀人事件", @"imageUrl" : @"http://img3.douban.com/view/movie_poster_cover/ipst/public/p2222398443.jpg"},@{@"name" : @"小黄人大眼萌", @"imageUrl" : @"http://img4.douban.com/view/movie_poster_cover/ipst/public/p2258235689.jpg"},@{@"name" : @"小森林 冬春篇", @"imageUrl" : @"http://img4.douban.com/view/movie_poster_cover/ipst/public/p2215147728.jpg"},@{@"name" : @"道士下山", @"imageUrl" : @"http://img3.douban.com/view/movie_poster_cover/ipst/public/p2251450614.jpg"},@{@"name" : @"深夜食堂 电影版", @"imageUrl" : @"http://img3.douban.com/view/movie_poster_cover/ipst/public/p2205014862.jpg"},@{@"name" : @"小男孩", @"imageUrl" : @"http://img4.douban.com/view/movie_poster_cover/ipst/public/p2230105606.jpg"},@{@"name" : @"头脑特工队", @"imageUrl" : @"http://img4.douban.com/view/movie_poster_cover/ipst/public/p2231021196.jpg"},@{@"name" : @"百元之恋", @"imageUrl" : @"http://img4.douban.com/view/movie_poster_cover/ipst/public/p2205471169.jpg"},@{@"name" : @"杀破狼2", @"imageUrl" : @"http://img4.douban.com/view/movie_poster_cover/ipst/public/p2246885606.jpg"}];
//路径可以自己选择
[plistArray writeToFile:@"/Users/xxx/Desktop/test/movie.plist" atomically:YES];

return 0;
</code></pre>

<p>到这里，就可以看到plist 文件可以用于测试了</p>

<p><img src="http://al1020119.github.io/images/python001.png" title="Caption" ></p>

<p>这里写图片描述
如果想要复制粘贴这里面的代码，那就选择Sublime编辑器</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[爬虫必备-正则表达式抓包]]></title>
    <link href="http://al1020119.github.io/blog/2015/12/11/zhengze/"/>
    <updated>2015-12-11T10:03:23+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/12/11/zhengze</id>
    <content type="html"><![CDATA[<p>第一篇我们有介绍到使用青花瓷抓包，也提到了后面会介绍java和python实现，本篇就介绍一下怎么使用python抓取网络数据。</p>

<p>先来看看网络爬虫的基本原理：</p>

<p>一个通用的网络爬虫的框架如图所示：</p>

<p><img src="http://al1020119.github.io/images/zhengze001.png" title="Caption" ></p>

<!--more-->


<h5>网络爬虫的基本工作流程如下：</h5>

<ol>
<li><p>首先选取一部分精心挑选的种子URL；</p></li>
<li><p>将这些URL放入待抓取URL队列；</p></li>
<li><p>从待抓取URL队列中取出待抓取在URL，解析DNS，并且得到主机的ip，并将URL对应的网页下载下来，存储进已下载网页库中。此外，将这些URL放进已抓取URL队列。</p></li>
<li><p>分析已抓取URL队列中的URL，分析其中的其他URL，并且将URL放入待抓取URL队列，从而进入下一个循环。</p></li>
</ol>


<p>以下内容均为本人个人理解。</p>

<p>网络数据抓取</p>

<ol>
<li>概念：网络数据抓取，也叫网络爬虫。是在我们iOS程序中，获取要抓取到的网页上的数据。</li>
<li>用处：如果要用到某网站的一些数据，这个时候我们就要用到抓取数据技术。</li>
<li>建议：建议抓取过程中，多利用分类，多写一些分类方法，有助于提高程序可读性，也可提高效率。</li>
</ol>


<p>今天先来介绍一下第一种：正则表达式</p>

<blockquote><p>注意点：其实网络抓取数据很简单，但是有用到正则表达式，这个有人说难，有人说很难，有人说非常难，其实我们抓取数据只会用到“.&ldquo; 、&rdquo;*&ldquo;、&rdquo;?&ldquo;这三个符号！</p></blockquote>

<p>正则表达式中：“.”是包括任何字符不包括换行符，“*”是任意多个的字符，“？”是指到最近的一个URL，如果没有就是到最远的一个！</p>

<pre><code> NSString *pantten = [NSString stringWithFormat:@"&lt;ul class=\"cs_list\"&gt;(.*?)&lt;/ul&gt;"];

 NSRegularExpression *regx = [NSRegularExpression regularExpressionWithPattern:pantten options:NSRegularExpressionCaseInsensitive |NSRegularExpressionDotMatchesLineSeparators error:NULL];
</code></pre>

<p>其中有两个参数需要大家了解一下，很重要</p>

<ul>
<li>NSRegularExpressionCaseinsensitive 不区分大小写</li>
<li>NSRegularExpressionDotMatcheLineSeparators 让“点”字符可以匹配换行符</li>
</ul>


<p>抓数据，其实主要会写匹配字符串就行</p>

<pre><code>(.*?)表示要抓到的内容
.*?表示要忽略的内容，爱是啥是啥
字符串转义双引号用\转义括号用\\
</code></pre>

<p>在开发项目的过程，很多情况下我们需要利用互联网上的一些数据，在这种情况下，我们可能要写一个爬虫来爬我们所需要的数据。一般情况下都是利用正则表达式来匹配Html,获取我们所需要的数据。一般情况下分以下三步。</p>

<ul>
<li>1、获取网页的html</li>
<li>2、利用正则表达式，获取我们所需要的数据</li>
<li>3、分析，使用获取到的数据，（例如，保存到数据库）</li>
</ul>


<p>接下来我们分析代码：</p>

<h3>1、获取网页的html</h3>

<p>　　对于一些网页，不需要提交Post提交数据时，我们可以简单的利用NSURL类来获取我们所需要的html，交将其转换中kCFStringEncodingGB_18030_2000格式，解决中文乱码问题。</p>

<p>　　</p>

<pre><code>+(NSString*) urlstring:(NSString*)strurl{
　　　　NSURL *url = [NSURL URLWithString:strurl];
　　　　NSData *data = [NSData dataWithContentsOfURL:url];

　　　　NSStringEncoding enc = CFStringConvertEncodingToNSStringEncoding(kCFStringEncodingGB_18030_2000); 
　　　　NSString *retStr = [[NSString alloc] initWithData:data encoding:enc];

　　　　//NSLog(@" html = %@",retStr);

　　　　return retStr;
　　}
</code></pre>

<p> 对于需要Post提交数据的网页，我们可以利用强大的ASIFormDataRequest类来实现，例如：</p>

<pre><code>+(void)getPostResult:(NSString*)startqi{
　　　　ASIFormDataRequest *request = [[ASIFormDataRequest alloc] initWithURL:[NSURL URLWithString:URLPost]];

　　　　[request setPostValue:startqi forKey:@"startqi"];
　　　　[request setPostValue:@"20990101001" forKey:@"endqi"];
　　　　[request setPostValue:@"qihao" forKey:@"searchType"];//网页的中的搜索方式
　　　　[request startSynchronous];

　　　　NSData* data = [request responseData];

　　if (data==nil) {
　　　　FCLOG(@"has not data");
　　}
　　else{
　　　　NSStringEncoding enc = CFStringConvertEncodingToNSStringEncoding(kCFStringEncodingGB_18030_2000); 
　　　　NSString *retStr = [[NSString alloc] initWithData:data encoding:enc];
　　　　FCLOG(@"html = %@",retStr); 
　　}
}
</code></pre>

<p>这样的话，我们就通过了两种方式获取了我们所需要的html</p>

<h3>2、分析html</h3>

<p>　　关于利用正则表达式匹配问题，我又对NSString类扩展了一个方法-(NSMutableArray <em>)substringByRegular:(NSString </em>)regular。根据传入的正则表达式，返回所有匹配的数组。</p>

<p>　　</p>

<pre><code>@implementation NSString(StringRegular)


-(NSMutableArray *)substringByRegular:(NSString *)regular{

  　　　　　NSString * reg=regular;

　　　　　　NSRange r= [self rangeOfString:reg options:NSRegularExpressionSearch];

　　　　　　NSMutableArray *arr=[NSMutableArray array];

　　　　　　if (r.length != NSNotFound &amp;&amp;r.length != 0) {

　　　　　　int i=0;

　　　　　　while (r.length != NSNotFound &amp;&amp;r.length != 0) {

　　　　　　FCLOG(@"index = %i regIndex = %d loc = %d",(++i),r.length,r.location);

　　　　　　NSString* substr = [self substringWithRange:r];

　　　　　　FCLOG(@"substr = %@",substr);

　　　　　　[arr addObject:substr];

　　　　　　NSRange startr=NSMakeRange(r.location+r.length, [self length]-r.location-r.length);

　　　　　　r=[self rangeOfString:reg options:NSRegularExpressionSearch range:startr];
　　　　}
　　}
　　return arr;
}
@end
</code></pre>

<p>在这种情况下，我们首先我得到我们要获取数据的正则表达式，关于正则表达式这种火星文我就不多说了，我也很纠结，我就不多说了，但是有一点就是，所写的正则表达式一定是我们所需要的数据，并且能够屏蔽无效信息的，有可能在一次匹配中无法获取，可以多次利用正则表达式来分段获取。下面是我的语句，在我的例子中，就是两次利用正则表达式。</p>

<pre><code>NSString *regstr = @"&lt;td class=\'z_bg_05\'&gt;\\w{11}&lt;/td&gt;&lt;td class=\'z_bg_13\'&gt;(\\w{2}\\s{0,1})*&lt;/td&gt;";
NSMutableArray *arr=[strhtml substringByRegular:regstr];
</code></pre>

<h3>3、分析或利用数据，在这里，我只是利用上一篇博客上所述方法简单的把这些数据保存到了数据库（sqlite3）中。</h3>

<p>其实在这个arr数组中一条就是对应我数据库表中的一条记录，但是像td class等这些信息我是不需要的，所以再次利用正则表达式来分析NSString</p>

<pre><code>if (arr!=nil&amp;&amp;[arr count]&gt;0) {

　　　　　　NSString *prereg=@"\\w{11}";
　　　　　　NSString *backreg=@"(\\w{2}\\s{0,1}){8}";

　　　　　　TicketResultService *service=[[TicketResultService alloc] init];
　　　　　　[[Sqlite3Helper Instance] openDB];
　　　　for (NSString *sub in arr) {

　　　　　　TicketResult* r=[[[TicketResult alloc] init] autorelease];

　　　　　　NSMutableArray* prearr=[sub substringByRegular:prereg];

　　　　　　if (prearr!=nil&amp;&amp;[prearr count]&gt;0) {
　　　　　　　　r.sectionID=(NSString*)[prearr objectAtIndex:0];
　　　　　　}
　　　　　　else{
　　　　　　　　continue;
　　　　　　}

　　　　　　NSMutableArray *backarr=[sub substringByRegular:backreg];
　　　　　　if (backarr!=nil&amp;&amp;[backarr count]&gt;0) {
　　　　　　r.result=[backarr objectAtIndex:0];
　　　　　　}
　　　　　　else{
　　　　　　　　continue;
　　　　　　}

　　　　　　if([service isExist:r.sectionID]){
　　　　　　　　continue;
　　　　　　}

　　　　r.type=[NSNumber numberWithInt:1];

　　　　[service addModel:r];

　　}
　　[[Sqlite3Helper Instance] closeDB];

　　[service release];
}
</code></pre>

<blockquote><p>以上爬虫才算正式完成，其实，在此之前还有一个第0步，即判断设备目前的网络状态，如果没有联网的就没有必要去爬虫了，因为你也爬不到任何的数据。判断网络状态我是利用Apple官方的一个例子Reachability，网上也有很多关于这个的例子，我就不再细说了，非常感谢网上的各位大牛们提供的很好的办法，让我能更快的写出这些。</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[爬虫必备-青花瓷抓包]]></title>
    <link href="http://al1020119.github.io/blog/2015/12/11/qinghuaci/"/>
    <updated>2015-12-11T09:03:23+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/12/11/qinghuaci</id>
    <content type="html"><![CDATA[<p>在之前个人学习ios开发的时候听过抓包相关的技术，但是自己没有实现，所以也只是当听听。</p>

<p>这段时间，由于公司新项目的原因，但是后台和UI都还没有，而又需要我先开始封装对应的工具或者一下大概的逻辑，我当时就蒙了，最后还是乖乖的来做。</p>

<p>网上找了一些接口，也找了不少类似的网站，但是发现再美我用不了有什么用呢？最后我想到了之前听别人说的网络爬虫，找了不少资料研究了一番。发现效果还不错，就在这里记录下来，希望对你有用！</p>

<p>关于网络数据抓取不仅仅在iOS开发中有，其他开发中也有，也叫网络爬虫，大致分为三种方式实现</p>

<ul>
<li>1: 青花瓷</li>
<li>2: 正则表达</li>
<li>3: 利用其他语言的工具包：java／Python</li>
</ul>


<p>写本文的契机主要是前段时间有次用青花瓷抓包有一步忘了，在网上查了半天也没找到写的完整的教程，于是待问题解决后抽时间截了图，自己写一遍封存在博客园中以便以后随时查阅。</p>

<!--more-->


<p>charles又名青花瓷，在iOS开发中的抓包中具有重要作用。最大的三点用处，一就是拦截别人软件的发送的请求和后端接口，练习开发。二是自己后端返回的response拦截修改后再接收以达到测试临界数据的作用。三写脚本重复拦截抓取别人的数据。(因为不太道德，本文不提第三点)</p>

<p>如果你不是在董铂然博客园看到本文，请点击查看原文。</p>

<h3>1.开始之前的准备工作</h3>

<p>首先安装一下这个软件</p>

<p>这个相信很多人电脑里应该都安装了，没安装的搜charles破解版也能很容易搜到。如果没安装java环境，首次进入charles会提示让你安装java包得，直接给你链接是苹果官网的，去下一个一键安装就行了。</p>

<p> <img src="http://al1020119.github.io/images/qinghuaci001.jpg" title="Caption" ></p>

<p>安装完成后先打开，在进行下面操作。</p>

<p>然后去自己电脑的系统偏好设置-》网络-》选中现在连着的网(大部分人应该都是WiFi吧)可以查到自己这个电脑在现在这个wifi里的IP地址，比如我现在这个就是192.168.0.105(建议最好用私人网络，用公司网络的话可能会有限制会出现没反应的问题)</p>

<p><img src="http://al1020119.github.io/images/qinghuaci002.jpg" title="Caption" ></p>

<p>然后找到自己手机也连着这个同名的wifi，然后选中右边的蓝色i。</p>

<p> <img src="http://al1020119.github.io/images/qinghuaci003.jpg" title="Caption" ></p>

<p><img src="http://al1020119.github.io/images/qinghuaci004.jpg" title="Caption" ></p>

<p>然后进入到了这个无线局域网的高级设置页面。进去之后拉到最下方，找到HTTP代理字样。然后选中手动代理，并在服务器中填自己电脑查到的ip地址，然后把端口调8888，最后点击左上角返回。返回值后系统会自动设置代理重新连接。</p>

<p>这时候你的手机上网的过程中就要经过你的电脑了。刚用手机打开一个联网的程序，你的电脑上应该会显示一个弹窗问你【allow】还是【deny】肯定不能拒绝啊就点allow吧。这个只有第一次才弹窗，图没截上，你到时候看见肯定能看懂的。点了同意之后你手机发出的每一个请求都会被拦截出痕迹。</p>

<h3>2.拦截某个软件的接口数据</h3>

<p>拿网易新闻举例，以前就练习这写过网易新闻的项目，其中网易的接口全是用charles拦截的。拦截到了网易发请求时发的是什么，然后在练习项目中需要获取数据的地方也把这一串链接直接拿过来用即可。</p>

<p><img src="http://al1020119.github.io/images/qinghuaci005.jpg" title="Caption" ></p>

<p>当然这上面拦到的比较多，如果有过开发经验的话应该能很快看出来右边哪个是真正返回json数据的接口。或者一个一个点看内容也行啊。</p>

<p>比如选中一个url然后右键点击copy。</p>

<p><img src="http://al1020119.github.io/images/qinghuaci006.jpg" title="Caption" ></p>

<p>放到浏览器地址栏里打一下。能看到</p>

<p><img src="http://al1020119.github.io/images/qinghuaci007.jpg" title="Caption" ></p>

<p>这就说明这个接口是对的了。可以获取到数据。然后可以给他转化一下看的更清楚。虽然很多人都是用bash看，但我还是推荐一个网址<a href="http://www.w3cschool.cc/jsontool">http://www.w3cschool.cc/jsontool</a>。转JSON之后看的非常清晰。大部分软件json整理后都是默认把大括号全都打开，而仅有这个网站是默认全给你把大括号关上。想点哪个再点开，而且能知道字典里有多少个键值对，所以看着非常清晰。</p>

<p><img src="http://al1020119.github.io/images/qinghuaci008.jpg" title="Caption" ></p>

<p>到此就已经完成了一次完整的，拉取接口，和获得数据。</p>

<p>这里有两点我想说下：</p>

<p>①就是如果这个App发的请求加密了或是RSA什么的，这个就算拦截了你也弄不到数据。网易是没有做任何加密，所以可以抓取到数据。以前试了拦截百度医生的就不行。他设置的是一分钟内能获取到数据，超过了1分钟这个复制过来的接口就取不到数据了。怀疑可能是用的HMAC方法加密，并且在里面加入了时间判断。32分和33分发出的请求经过编码后是不一样的，后台可能做了容错，会把32分和31分都和你判断下，只要有一个对上就让你过，但是超过了整整一分钟后是肯定获取不到数据了。</p>

<p>②就是很多比较大型的网站，一般会开放一个开发者平台，里面注册开发者账号后会向你公开一个接口文档，你不用再去费事的拦截了。像新浪微博和大众点评都有开发者平台。</p>

<h3>3.更改返回数据来测试临界情况</h3>

<p>这个是重点了。因为这种做法可以让一个iOS前端的开发人员独立完成测试而不用拉过来一个后端一起联调。并且各种特殊维度，或是临界的账号也不用再去辛苦找了，仅仅自己在青花瓷上改来改去就可以达到效果了。比如这个地方如果返回了nil程序会不会崩，直接改response就行了。下面是具体操作方案。</p>

<p>打开青花瓷切换成结构页面</p>

<p><img src="http://al1020119.github.io/images/qinghuaci009.jpg" title="Caption" ></p>

<p>这里可以看到断点和调试信息</p>

<p><img src="http://al1020119.github.io/images/qinghuaci010.jpg" title="Caption" ><br/>
<img src="http://al1020119.github.io/images/qinghuaci011.jpg" title="Caption" ></p>

<p>然后找一个我们公司的页面。这个页面本来应该返回是这样的：如上图右边</p>

<p>你先正常的打开这个页面把玩几下，这个青花瓷就会抓取很多接口和域名分类了。在这里找到你这个页面所属的域名分类应该不难。然后打上断点。这里要注意是在域名上打断点而不是在下面的单个请求上打断点。</p>

<p>再次用手机进入这个页面，就会通过你刚才打断点的那个域名来请求数据，就会被断点拦住，如下图所示。</p>

<p><img src="http://al1020119.github.io/images/qinghuaci012.jpg" title="Caption" ></p>

<p>右边的信息也很清晰，一开始可以编辑请求。如果点击单步执行，等一下相应回来了也可以编辑响应。</p>

<p><img src="http://al1020119.github.io/images/qinghuaci013.jpg" title="Caption" ></p>

<p><img src="http://al1020119.github.io/images/qinghuaci014.jpg" title="Caption" ></p>

<p>这里的有好几种查看的方式，但是推荐使用JSON Text看的比较清楚。 现在我们对拦截回来的数据进行修改，我把这些统计数据全改成999如下图</p>

<p> <img src="http://al1020119.github.io/images/qinghuaci015.jpg" title="Caption" ></p>

<p>然后再次点击下方的Execute单步执行，更改后的数据就会像正常返回回来的数据那样显示到，APP的页面上展示。</p>

<p><img src="http://al1020119.github.io/images/qinghuaci016.jpg" title="Caption" ></p>

<p>能来到这一步就说明已经完整的掌握了用青花瓷篡改返回数据测试App的技术。</p>

<p>如果你不是在董铂然博客园看到本文，请点击查看原文。</p>

<p>这么做的意义：</p>

<p>这里只是简单的更改了一些数字，在页面显示更加直观。实际的操作中，你可以经常用来把某些值改为临界情况以看到App在处理这些临界状况时的反应，这样比找那些临界数据的测试账号成本要低得多。也可以把一些可能不会反回数值的字段找到，直接将里面的值删成nil，看看会不会报异常等等。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[H5应用实战]]></title>
    <link href="http://al1020119.github.io/blog/2015/12/10/h5ying-yong-shi-zhan/"/>
    <updated>2015-12-10T11:03:23+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/12/10/h5ying-yong-shi-zhan</id>
    <content type="html"><![CDATA[<blockquote><p>前言:
ObjectiveC与Js交互是常见的需求，可对于新手或者所谓的高手而言，其实并不是那么简单明了。</p></blockquote>

<p>标准通用标记语言下的一个应用HTML标准自1999年12月发布的HTML4.01后，后继的HTML5和其它标准被束之高阁，为了推动Web标准化运动的发展，一些公司联合起来，成立了一个叫做 Web Hypertext Application Technology Working Group （Web超文本应用技术工作组 -WHATWG） 的组织。WHATWG 致力于 Web 表单和应用程序，而W3C（World Wide Web Consortium，万维网联盟） 专注于XHTML2.0。在 2006 年，双方决定进行合作，来创建一个新版本的 HTML。</p>

<p>这段时间在研究H5相关，由于本人主攻的是ios开发，所以后期主要的任务就是，使用H5+Css+JP编写好的代码在OC中使用，或者相互调用。</p>

<p>这里就给大家介绍一下后面的内容，关于前面的内容后期会陆续更新相关文章与总结。</p>

<!--more-->


<h3>OC——调用——HTML</h3>

<p>这里有两种方式
直接使用网络链接（接口）
使用本地的html</p>

<p>由于没有完成一个完整的html项目，这里就以链接演示。</p>

<p>先来看看官方链接显示情况
<img src="http://al1020119.github.io/images/html&oc001.png" title="Caption" ></p>

<p>1.使用WebView，设置代理，加载对应的Html（略过部分细节），并且增加一个指示器</p>

<pre><code>// 加载网页
NSURL *url = [NSURL URLWithString:@"http://www.xianhua.cn/m/"];
NSURLRequest *request = [NSURLRequest requestWithURL:url];
[self.webView loadRequest:request];

self.webView.scrollView.hidden = YES;
self.webView.backgroundColor = [UIColor grayColor];

UIActivityIndicatorView *displayView = [[UIActivityIndicatorView alloc] initWithActivityIndicatorStyle:UIActivityIndicatorViewStyleWhiteLarge];
[displayView startAnimating];
self.displayView = displayView;
displayView.center = self.view.center;
[self.webView addSubview:displayView];
</code></pre>

<p>2.在WebView加载完成的方法中实现我们想要的功能需求</p>

<pre><code>#pragma mark -&lt;UIWebViewDelegate&gt;
- (void)webViewDidFinishLoad:(UIWebView *)webView{

    // 改变标题
    NSString *str = @"document.getElementsByTagName('h1')[0].innerText = 'iCocos鲜花网';";
    [webView stringByEvaluatingJavaScriptFromString:str];

    // 删除广告
    NSString *str2 =@"document.getElementsByClassName('detail_btns2')[0].remove();";
    [webView stringByEvaluatingJavaScriptFromString:str2];

    // 改变尾部
    NSString *str3 = @"document.getElementById('xiazaiapp').getElementsByTagName('a')[0].innerText='iCocos鲜花网App';";
    [webView stringByEvaluatingJavaScriptFromString:str3];

    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.25 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
        self.webView.scrollView.hidden = NO;
        [self.displayView stopAnimating];
    });
}
</code></pre>

<p>修改后子在手机就是这样的效果</p>

<p><img src="http://al1020119.github.io/images/html&oc002.png" title="Caption" ></p>

<h3>HTML——调用——OC</h3>

<p>这里的例子是通过在html中点击一个按钮去调用OC代码，访问系统系相册</p>

<h6>先来看看OC中需要怎么写：</h6>

<p>1.使用WebView，设置代理，加载对应的Html（略过部分细节）</p>

<pre><code>// 加载网页
NSURL *url = [[NSBundle mainBundle] URLForResource:@"test" withExtension:@"html"];
NSURLRequest *request = [NSURLRequest requestWithURL:url];
[self.webView loadRequest:request];
</code></pre>

<p>2.在Web开始加载请求的代理方法中拼接方法（包装）</p>

<pre><code>#pragma mark - &lt;UIWebViewDelegate&gt;
- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType{
//    NSLog(@"------%@", request.URL.absoluteString);
    NSString *requestUrl = request.URL.absoluteString;
    NSRange range = [requestUrl rangeOfString:@"ds3q:///"];
    NSUInteger location = range.location;
    if (location != NSNotFound) {
        NSString *str = [requestUrl substringFromIndex:location + range.length];
        NSLog(@"%@", str);
        // 包装SEL
        SEL method = NSSelectorFromString(str);
        [self performSelector:method];
    }

    return YES;
}
</code></pre>

<p>3.实现打开相册的OC方法</p>

<pre><code>// 打开相册
- (void)openCamera{
    UIImagePickerController *vc = [[UIImagePickerController alloc] init];
    vc.sourceType = UIImagePickerControllerSourceTypePhotoLibrary;
    [self presentViewController:vc animated:YES completion:nil];
}
</code></pre>

<p>4.再来看看html中简单的写法</p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head lang="en"&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;style&gt;
        body{
            margin-top: 50px;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;button onclick="openCamera();"&gt;访问相册&lt;/button&gt;
    &lt;script type="text/javascript"&gt;
        function openCamera(){
            window.location.href = 'ds3q:///openCamera';
        }
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p> 显示效果</p>

<p> <img src="http://al1020119.github.io/images/html&oc003.png" title="Caption" ></p>

<hr />

<p>  <img src="http://al1020119.github.io/images/html&oc004.png" title="Caption" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Core Image 初探]]></title>
    <link href="http://al1020119.github.io/blog/2015/12/10/core-image-chu-tan/"/>
    <updated>2015-12-10T10:09:37+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/12/10/core-image-chu-tan</id>
    <content type="html"><![CDATA[<blockquote><p>前言：
Core Image 是 IOS 的图片处理框架，有使用方便、易于管理，性能优异的特点。</p>

<ul>
<li>用途

<ul>
<li>在照片、视频处理，把滤镜作为最后一步，添加水印</li>
<li>给照相机提供实时效果</li>
<li>面部检测，自动滤镜增益,图片分析算法</li>
<li>更多</li>
</ul>
</li>
</ul>
</blockquote>

<!--more-->


<h2>coreimage framework 组成</h2>

<p>apple 已经帮我们把image的处理分类好，来看看它的结构：</p>

<p><img src="http://al1020119.github.io/images/coreimage001.png" title="Caption" ></p>

<p>主要分为三部分：</p>

<h5>定义部分：</h5>

<p> CoreImage 何CoreImageDefines。见名思义，代表了CoreImage 这个框架和它的定义。</p>

<h5>操作部分：</h5>

<pre><code>滤镜（CIFliter）：CIFilter 产生一个CIImage。典型的，接受一到多的图片作为输入，经过一些过滤操作，产生指定输出的图片。

检测（CIDetector）：CIDetector 检测处理图片的特性，如使用来检测图片中人脸的眼睛、嘴巴、等等。

特征（CIFeature）：CIFeature 代表由 detector处理后产生的特征。
</code></pre>

<h5>图像部分：</h5>

<pre><code>画布（CIContext）：画布类可被用与处理Quartz 2D 或者 OpenGL。可以用它来关联CoreImage类。如滤镜、颜色等渲染处理。

颜色（CIColor）：   图片的关联与画布、图片像素颜色的处理。

向量（CIVector）： 图片的坐标向量等几何方法处理。

图片（CIImage）： 代表一个图像，可代表关联后输出的图像。　　
</code></pre>

<p><img src="http://al1020119.github.io/images/coreimage002.jpg" title="Caption" ></p>

<h2>2.  处理步骤：</h2>

<pre><code>  1）create a ciimage object;

  2) create a cifilter object and set input values

  3)  create a cicontext object.

  4) render the filter output image into a cgimage
</code></pre>

<p>　　　　</p>

<h2>3.注意</h2>

<p>　　　　a。关注Ciimage 产生的途径：</p>

<p>　　　　　　　　1）通过URL和Data</p>

<p>　　　　　　　　 2）通过其他图片类转换，CGImageRef或其他图片。</p>

<p>　　　　　　　　 3）通过CVpixelBufferRef。</p>

<p>　　　　　　　　 4）一组像素Data。</p>

<p>　　　　b.  图片颜色，KCCImageColorSpace 来重载默认颜色空间。</p>

<p>　　　　c. 图片Metadata。</p>

<p>　　　　</p>

<h2>4. 使用滤镜。</h2>

<p>　　　　CISepiaTone、CiColorControls、CIHueBlendMode。</p>

<p><img src="http://al1020119.github.io/images/coreimage003.png" title="Caption" ></p>

<p>处理过程：多个CImage输入 －－ 》 CIHeBlendMode  －－》 CiSepiatone。</p>

<p><img src="http://al1020119.github.io/images/coreimage004.jpg" title="Caption" ></p>

<p>渲染输出：</p>

<p><img src="http://al1020119.github.io/images/coreimage005.jpg" title="Caption" ></p>

<p>流程： 获取context  －》 转成CIimage －》 渲染成CGImageRef  －》 转换为UIimage －》 释放 CGImageRef －》 使用UIImage。</p>

<h2>5.脸部检测</h2>

<p>　　自动增强： CIRedEyeCorrection  、CIFaceBalance（调整图片来给出更好的皮肤色调）、CIVibrance（在不扭曲皮肤色调的情况下，增加饱和度）、CIToneCurve（调整图片对比）、高亮阴影调整。
　　
　　</p>

<hr />

<p>&mdash;-基本使用&mdash;-</p>

<hr />

<h5>Core Image 处理图片的工作流程</h5>

<ul>
<li>创建新的CIImage</li>
<li>创建新的CIFilter，通过键-值编码设置输入值，一定要给inputImage加入一个值，这个属性是图像数据源</li>
<li>从CIFilter中生成输出图片。通过访问CIFilter的outputImage属性，可以得到输出图像，这是一个新的CIImage对象，包含了原始图片的数据以及一个滤镜链。 在得到输出图像后，可以使用滤镜来渲染出最终的效果图像。也可以将其作为一个新滤镜的输入图像，这样会产生出一条滤镜链</li>
<li>用CIContext 渲染CIImage 对象，这个CIContext 可以是基于CPU的，输出为CGImageRef，通过 LibDispatch（GCD）渲染 ，更加可靠，也更加易用。也可以是基于GPU的，开发者可通过Open ES 2.0 画出来。使用GPU渲染时CPU没有负担，更好地性能，但无法在后台运行</li>
</ul>


<p>使用例子：</p>

<pre><code> CIImage *myCoreImage = [CIImage imageWithCGImage:self.myImageView.image.CGImage options:nil];  

// 创建Filter，@"CISepiaTone"这个名字是系统指定的  
CIFilter *sepia = [CIFilter filterWithName:@"CISepiaTone"];  

// 设置Filter  
[sepia setValue:myCoreImage forKey:@"inputImage"];  

NSNumber *intensity = [NSNumber numberWithFloat:.5f];  
[sepia setValue:intensity forKey:@"inputIntensity"];  

// 生成新的 CIImage  
CIImage *outputImage = [sepia outputImage];  

// 取出UIImage  
CGImageRef renderImage = [_imageContext createCGImage:outputImage fromRect:[outputImage extent]];  
[self.myImageView setImage:[UIImage imageWithCGImage:renderImage]];
</code></pre>

<blockquote><p>DemoCoreImage 是直接从IOS 核心框架拿过来的。
CoreImageMySelf 是我自己提取的只为实现优化功能的demo
提取的功能模块有，filter的使用、自动优化的使用、脸部检测</p></blockquote>

<p>再来看看常见的使用方式</p>

<ul>
<li>CIImage</li>
</ul>


<p>保存图像数据的类，可以通过UIImage，图像文件或者像素数据来创建，包括未处理的像素数据如：</p>

<pre><code>- imageWithCVPixelBuffer:

- imageWithData:
</code></pre>

<p>方法等等。</p>

<p>也可以通过图像数据类比如UIImage，CGImageRef等等。</p>

<ul>
<li>CIFilter</li>
</ul>


<p>滤镜类，这个框架中对图片属性进行细节处理的类。它对所有的像素进行操作，用一些键-值设置来决定具体操作的程度。</p>

<ul>
<li>CIContext</li>
</ul>


<p>上下文类，如CoreGraphics以及CoreData中的上下文用于处理绘制渲染以及处理托管对象一样，CoreImage的上下文也是实现对图像处理的具体对象。</p>

<p>这里需要注意的是在Context创建的时候，我们需要给它设定为是基于GPU还是CPU。(这里使用GPU)</p>

<blockquote><p>基于GPU的话，处理速度更快，因为利用了GPU硬件的并行优势。但是GPU受限于硬件纹理尺寸，而且如果你的程序在后台继续处理和保存图片的话，那么需要使用CPU，因为当app切换到后台状态时GPU处理会被打断。</p></blockquote>

<h3>使用步骤：</h3>

<h6>0.导入CIImage图片</h6>

<pre><code>CIImage *ciImage = [[CIImage alloc]initWithImage:[UIImage imageNamed:@"test.jpg"]];
</code></pre>

<h6>1.创建出Filter滤镜</h6>

<pre><code>CIFilter *filterOne = [CIFilter filterWithName:@"CIPixellate"];
[filterOne setValue:ciImage forKey:kCIInputImageKey];
[filterOne setDefaults];

CIImage *outImage = [filterOne valueForKey:kCIOutputImageKey];
</code></pre>

<h6>2.用CIContext将滤镜中的图片渲染出来</h6>

<pre><code>CIContext *context = [CIContext contextWithOptions:nil];

CGImageRef cgImage = [context createCGImage:outImage fromRect:[outImage extent]];
</code></pre>

<h6>3.导出图片</h6>

<pre><code>UIImage *showImage = [UIImage imageWithCGImage:cgImage];
CGImageRelease(cgImage);
</code></pre>

<h6>4.加载图片</h6>

<pre><code> _image.image = showImage;
</code></pre>

<hr />

<h3>如果要使用组合滤镜</h3>

<h6>在步骤1中设置组合滤镜，只需要将上一个滤镜的输出变为下一个滤镜的输入就行了</h6>

<pre><code>//第一个滤镜
CIFilter *filterOne = [CIFilter filterWithName:@"CIPixellate"];
[filterOne setValue:ciImage forKey:kCIInputImageKey];
[filterOne setDefaults];
CIImage *outImage = [filterOne valueForKey:kCIOutputImageKey];
//第二个滤镜
CIFilter *filterTwo = [CIFilter filterWithName:@"CIHueAdjust"];
[filterTwo setValue:outImage forKey:kCIInputImageKey];
[filterTwo setDefaults];
[filterTwo setValue:@(1.f) forKey:kCIInputAngleKey];
CIImage *outputImage = [filterTwo valueForKey:kCIOutputImageKey];
</code></pre>

<h6>记住渲染的时候，步骤2，要将最后输出的CIImage传入</h6>

<pre><code>CIContext *context = [CIContext contextWithOptions:nil];

CGImageRef cgImage = [context createCGImage:outputImage fromRect:[outImage extent]];
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[玩转定时器]]></title>
    <link href="http://al1020119.github.io/blog/2015/12/09/wan-zheng-ding-shi-qi/"/>
    <updated>2015-12-09T18:17:51+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/12/09/wan-zheng-ding-shi-qi</id>
    <content type="html"><![CDATA[<p> <img src="http://al1020119.github.io/images/dingshiqi.png" title="Caption" ></p>

<p>在软件开发过程中，我们常常需要在某个时间后执行某个方法，或者是按照某个周期一直执行某个方法。在这个时候，我们就需要用到定时器。</p>

<blockquote><p>然而，在iOS中有很多方法完成以上的任务，到底有多少种方法呢？经过查阅资料，大概有三种方法：NSTimer、CADisplayLink、GCD。接下来我就一一介绍它们的用法。</p></blockquote>

<!--more-->


<h2>一、NSTimer</h2>

<h5>1. 创建方法</h5>

<pre><code>1     // 设置定时器
2     [NSTimer scheduledTimerWithTimeInterval:.1 target:self selector:@selector(timeChange) userInfo:nil repeats:YES];
3     
4     // 0.1 setNeedsDisplay 绑定一个标识,等待下次刷新的时候才会调用drawRect方法
5     // 0.15 屏幕的刷新时间
</code></pre>

<ul>
<li><p>TimerInterval : 执行之前等待的时间。比如设置成1.0，就代表1秒后执行方法</p></li>
<li><p>target : 需要执行方法的对象。</p></li>
<li><p>selector : 需要执行的方法</p></li>
<li><p>repeats : 是否需要循环</p></li>
</ul>


<h5>2. 释放方法</h5>

<pre><code> [timer invalidate]; 
</code></pre>

<blockquote><p>注意 :
调用创建方法后，target对象的计数器会加1，直到执行完毕，自动减1。如果是循环执行的话，就必须手动关闭，否则可以不执行释放方法。</p></blockquote>

<h5>3. 特性</h5>

<ul>
<li>存在延迟</li>
</ul>


<p>不管是一次性的还是周期性的timer的实际触发事件的时间，都会与所加入的RunLoop和RunLoop Mode有关，如果此RunLoop正在执行一个连续性的运算，timer就会被延时出发。重复性的timer遇到这种情况，如果延迟超过了一个周期，则会在延时结束后立刻执行，并按照之前指定的周期继续执行。</p>

<ul>
<li>必须加入Runloop</li>
</ul>


<p>使用上面的创建方式，会自动把timer加入MainRunloop的NSDefaultRunLoopMode中。如果使用以下方式创建定时器，就必须手动加入Runloop:</p>

<pre><code>NSTimer *timer = [NSTimer timerWithTimeInterval:5 target:self &lt;span style="color: #3366ff;"&gt;selector&lt;/span&gt;:@selector(timerAction) userInfo:nil repeats:YES];&lt;br&gt;&lt;br&gt;
[[NSRunLoop mainRunLoop] &lt;span style="color: #3366ff;"&gt;addTimer&lt;/span&gt;:timer forMode:NSDefaultRunLoopMode];
</code></pre>

<p> 注意NSTimer还有一个方法，因为每次用的时候都是使用带target的这个方法，突然有一天很好奇就研究了一下，他的使用也很简单，只是相对上面那个有点繁琐，</p>

<h5>1:创建一个签名：</h5>

<pre><code> NSMethodSignature *singature = [NSMethodSignature signatureWithObjCTypes:"v@:"]; 2  
</code></pre>

<p>这里我想如果你仔细的话肯定注意到了：后面的“v@：”，这里是运行时的语法</p>

<p>在这里是指一个方法</p>

<pre><code>v放回viod类型
@一个id类型的对象
：对应SEL
</code></pre>

<p>关于运行时这里不多介绍请查看笔者之前的文章，或者查看官方文档，这是一个iOS开发者必须会的知识点</p>

<h5>2:通过前面创建一个请求，并且设置对应的target和SEL</h5>

<pre><code>&lt;span style="color: #3366ff;"&gt;    NSInvocation&lt;/span&gt; *vocation = [NSInvocation invocationWithMethodSignature:singature];
    vocation.target = self;
    vocation.selector = @selector(timeChange);
</code></pre>

<h5>3:在讲请求传到NSTimer中去实现定时</h5>

<pre><code>[NSTimer scheduledTimerWithTimeInterval:1 invocation:vocation repeats:YES]; 
</code></pre>

<h2>二、CADisplayLink</h2>

<h5>1. 创建方法</h5>

<pre><code>self.displayLink = [CADisplayLink displayLinkWithTarget:self &lt;span style="color: #3366ff;"&gt;selector&lt;/span&gt;:@selector(handleDisplayLink:)];   
[self.displayLink &lt;span style="color: #3366ff;"&gt;addToRunLoop&lt;/span&gt;:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];
</code></pre>

<h5>2. 停止方法</h5>

<pre><code>self.displayLink &lt;span style="color: #3366ff;"&gt;invalidate&lt;/span&gt;]; 
self.displayLink = nil;
</code></pre>

<p> 当把CADisplayLink对象add到runloop中后，selector就能被周期性调用，类似于重复的NSTimer被启动了；执行invalidate操作时，CADisplayLink对象就会从runloop中移除，selector调用也随即停止，类似于NSTimer的invalidate方法。</p>

<h5>3. 特性</h5>

<ul>
<li>屏幕刷新时调用</li>
</ul>


<p>CADisplayLink是一个能让我们以和屏幕刷新率同步的频率将特定的内容画到屏幕上的定时器类。CADisplayLink以特定模式注册到runloop后，每当屏幕显示内容刷新结束的时候，runloop就会向CADisplayLink指定的target发送一次指定的selector消息， CADisplayLink类对应的selector就会被调用一次。所以通常情况下，按照iOS设备屏幕的刷新率60次/秒</p>

<ul>
<li>延迟</li>
</ul>


<p>iOS设备的屏幕刷新频率是固定的，CADisplayLink在正常情况下会在每次刷新结束都被调用，精确度相当高。但如果调用的方法比较耗时，超过了屏幕刷新周期，就会导致跳过若干次回调调用机会。</p>

<p>如果CPU过于繁忙，无法保证屏幕60次/秒的刷新率，就会导致跳过若干次调用回调方法的机会，跳过次数取决CPU的忙碌程度。</p>

<ul>
<li>使用场景</li>
</ul>


<p>从原理上可以看出，CADisplayLink适合做界面的不停重绘，比如视频播放的时候需要不停地获取下一帧用于界面渲染。</p>

<h5>4. 重要属性</h5>

<ul>
<li>frameInterval</li>
</ul>


<p>NSInteger类型的值，用来设置间隔多少帧调用一次selector方法，默认值是1，即每帧都调用一次。</p>

<ul>
<li>duration</li>
</ul>


<p>readOnly的CFTimeInterval值，表示两次屏幕刷新之间的时间间隔。需要注意的是，该属性在target的selector被首次调用以后才会被赋值。selector的调用间隔时间计算方式是：调用间隔时间 = duration × frameInterval。</p>

<h5>CADisplayLink底层实现：</h5>

<pre><code> setNeedsDisplay:底层并不会马上调用drawRect,只会给当前的控件绑定一个刷新的标识,每次屏幕刷新的时候,就会把绑定了刷新(重绘)标识的控件重新刷新(绘制)一次,就会调用drawRect去重绘
</code></pre>

<blockquote><p> 注意：如果以后每隔一段时间需要重绘,一般不使用NSTimer,使用CADisplayLink,不会刷新的时候有延迟</p></blockquote>

<h2>三、GCD方式</h2>

<h5>执行一次</h5>

<pre><code>1 double delayInSeconds = 2.0;
2 dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, delayInSeconds * NSEC_PER_SEC); 
3 dispatch_after(popTime, dispatch_get_main_queue(), ^(void){ 
4     //执行事件
5 });
</code></pre>

<h5>重复执行</h5>

<pre><code>1 NSTimeInterval period = 1.0; //设置时间间隔
2 dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
3 dispatch_source_t _timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);
4 dispatch_source_set_timer(_timer, dispatch_walltime(NULL, 0), period * NSEC_PER_SEC, 0); //每秒执行
5 dispatch_source_set_event_handler(_timer, ^{
6     //在这里执行事件
7 });
8 dispatch_resume(_timer);
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[事件处理与图像渲染深究]]></title>
    <link href="http://al1020119.github.io/blog/2015/12/09/shi-jian-chu-li-yu-tu-xiang-xuan-ran-shen-jiu/"/>
    <updated>2015-12-09T09:47:11+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/12/09/shi-jian-chu-li-yu-tu-xiang-xuan-ran-shen-jiu</id>
    <content type="html"><![CDATA[<h3>iOS 事件处理机制与图像渲染过程</h3>

<ul>
<li>iOS RunLoop都干了什么</li>
<li>iOS 为什么必须在主线程中操作UI</li>
<li>事件响应</li>
<li>CALayer</li>
<li>CADisplayLink 和 NSTimer</li>
<li>iOS 渲染过程</li>
<li>渲染时机</li>
<li>CPU 和 GPU渲染</li>
<li>Core Animation</li>
<li>Facebook Pop介绍</li>
<li>AsyncDisplay介绍</li>
<li>参考文章</li>
</ul>


<!--more-->


<h5>iOS RunLoop都干了什么</h5>

<p>RunLoop是一个接收处理异步消息事件的循环，一个循环中：等待事件发生，然后将这个事件送到能处理它的地方。
如图1-1所示，描述了一个触摸事件从操作系统层传送到应用内的main runloop中的简单过程。</p>

<p><img src="http://al1020119.github.io/images/tupianxuanran001.jpg" title="Caption" ></p>

<p>简单的说，RunLoop是事件驱动的一个大循环，如下代码所示</p>

<pre><code>int main(int argc, char * argv[]) {
     //程序一直运行状态
     while (AppIsRunning) {
          //睡眠状态，等待唤醒事件
          id whoWakesMe = SleepForWakingU  p();
          //得到唤醒事件
          id event = GetEvent(whoWakesMe);
          //开始处理事件
          HandleEvent(event);
     }
     return 0;
}
</code></pre>

<p>RunLoop主要处理以下6类事件：</p>

<pre><code>static void __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__();
static void __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__();
static void __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__();
static void __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__();
static void __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__();
static void __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__();
</code></pre>

<ul>
<li><p>Observer事件，runloop中状态变化时进行通知。（微信卡顿监控就是利用这个事件通知来记录下最近一次main runloop活动时间，在另一个check线程中用定时器检测当前时间距离最后一次活动时间过久来判断在主线程中的处理逻辑耗时和卡主线程）。这里还需要特别注意，CAAnimation是由RunloopObserver触发回调来重绘，接下来会讲到。</p></li>
<li><p>Block事件，非延迟的NSObject PerformSelector立即调用，dispatch_after立即调用，block回调。</p></li>
<li><p>Main_Dispatch_Queue事件：GCD中dispatch到main queue的block会被dispatch到main loop执行。</p></li>
<li><p>Timer事件：延迟的NSObject PerformSelector，延迟的dispatch_after，timer事件。</p></li>
<li><p>Source0事件：处理如UIEvent，CFSocket这类事件。需要手动触发。触摸事件其实是</p></li>
<li>Source1接收系统事件后在回调 <em>_IOHIDEventSystemClientQueueCallback() 内触发的 Source0，Source0 再触发的 </em>UIApplicationHandleEventQueue()。source0一定是要唤醒runloop及时响应并执行的，如果runloop此时在休眠等待系统的 mach_msg事件，那么就会通过source1来唤醒runloop执行。</li>
</ul>


<blockquote><p>Source1事件：处理系统内核的mach_msg事件。（推测CADisplayLink也是这里触发）。</p></blockquote>

<p>RunLoop执行顺序的伪代码</p>

<pre><code>SetupThisRunLoopRunTimeoutTimer(); // by GCD timer
//通知即将进入runloop__CFRUNLLOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(KCFRunLoopEntry);
do {
     __CFRunLoopDoObservers(kCFRunLoopBeforeTimers);
     __CFRunLoopDoObservers(kCFRunLoopBeforeSources);

     __CFRunLoopDoBlocks();  //一个循环中会调用两次，确保非延迟的NSObject PerformSelector调用和非延迟的dispatch_after调用在当前runloop执行。还有回调block
     __CFRunLoopDoSource0(); //例如UIKit处理的UIEvent事件

     CheckIfExistMessagesInMainDispatchQueue(); //GCD dispatch main queue

     __CFRunLoopDoObservers(kCFRunLoopBeforeWaiting); //即将进入休眠，会重绘一次界面
     var wakeUpPort = SleepAndWaitForWakingUpPorts();
     // mach_msg_trap，陷入内核等待匹配的内核mach_msg事件
     // Zzz...
     // Received mach_msg, wake up
     __CFRunLoopDoObservers(kCFRunLoopAfterWaiting);
     // Handle msgs
     if (wakeUpPort == timerPort) {
          __CFRunLoopDoTimers();
     } else if (wakeUpPort == mainDispatchQueuePort) {
          //GCD当调用dispatch_async(dispatch_get_main_queue(),block)时，libDispatch会向主线程的runloop发送mach_msg消息唤醒runloop，并在这里执行。这里仅限于执行dispatch到主线程的任务，dispatch到其他线程的仍然是libDispatch来处理。
          __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__()
     } else {
          __CFRunLoopDoSource1();  //CADisplayLink是source1的mach_msg触发？
     }
 __CFRunLoopDoBlocks();
} while (!stop &amp;&amp; !timeout);

//通知observers，即将退出runloop
__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBERVER_CALLBACK_FUNCTION__(CFRunLoopExit);
</code></pre>

<p>结合上面的Runloop事件执行顺序，思考下面代码逻辑中为什么可以标识tableview是否reload完成</p>

<pre><code>dispatch_async(dispatch_get_main_queue(), ^{
    _isReloadDone = NO;
    [tableView reload]; //会自动设置tableView layoutIfNeeded为YES，意味着将会在runloop结束时重绘table
    dispatch_async(dispatch_get_main_queue(),^{
        _isReloadDone = YES;
    });
});
</code></pre>

<blockquote><p>提示：这里在GCD dispatch main queue中插入了两个任务，一次RunLoop有两个机会执行GCD dispatch main queue中的任务，分别在休眠前和被唤醒后。</p></blockquote>

<h5>iOS 为什么必须在主线程中操作UI</h5>

<blockquote><p>因为UIKit不是线程安全的。试想下面这几种情况：</p></blockquote>

<p>两个线程同时设置同一个背景图片，那么很有可能因为当前图片被释放了两次而导致应用崩溃。
两个线程同时设置同一个UIView的背景颜色，那么很有可能渲染显示的是颜色A，而此时在UIView逻辑树上的背景颜色属性为B。
两个线程同时操作view的树形结构：在线程A中for循环遍历并操作当前View的所有subView，然后此时线程B中将某个subView直接删除，这就导致了错乱还可能导致应用崩溃。
iOS4之后苹果将大部分绘图的方法和诸如 UIColor 和 UIFont 这样的类改写为了线程安全可用，但是仍然强烈建议讲UI操作保证在主线程中执行。</p>

<h6>事件响应</h6>

<p>苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。</p>

<p>当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。</p>

<ul>
<li><p>SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。</p></li>
<li><p>_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。</p></li>
</ul>


<h6>CALayer</h6>

<p>在iOS当中，所有的视图都从一个叫做UIVIew的基类派生而来，UIView可以处理触摸事件，可以支持基于Core Graphics绘图，可以做仿射变换（例如旋转或者缩放），或者简单的类似于滑动或者渐变的动画。</p>

<p>CALayer类在概念上和UIView类似，同样也是一些被层级关系树管理的矩形块，同样也可以包含一些内容（像图片，文本或者背景色），管理子图层的位置。它们有一些方法和属性用来做动画和变换。和UIView最大的不同是CALayer不处理用户的交互。CALayer并不清楚具体的响应链。</p>

<p>UIView和CALayer是一个平行的层级关系，每一个UIView都有一个CALayer实例的图层属性，也就是所谓的backing layer，视图的职责就是创建并管理这个图层，以确保当子视图在层级关系中添加或者被移除的时候，他们关联的图层也同样对应在层级关系树当中有相同的操作。实际上这些背后关联的Layer图层才是真正用来在屏幕上显示和做动画，UIView仅仅是对它的一个封装，提供了一些iOS类似于处理触摸的具体功能，以及Core Animation底层方法的高级接口。</p>

<h6>UIView 的 Layer 在系统内部，被维护着三份同样的树形数据结构，分别是：</h6>

<pre><code>图层树（这里是代码可以操纵的，设置属性的最终值会立刻在这里更新）；
呈现树（是一个中间层，系统就在这一层上更改属性，进行各种渲染操作。比如一个动画是更改alpha值从0到1，那么在逻辑树上此属性会被立刻更新为最终属性1，而在动画树上会根据设置的动画时间从0逐步变化到1）；
渲染树（其属性值就是当前正被显示在屏幕上的属性值）；
</code></pre>

<h5>CADisplayLink 和 NSTimer</h5>

<p>NSTimer 其实就是 CFRunLoopTimerRef。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。</p>

<ul>
<li><p>RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。</p></li>
<li><p>RunLoop 是用GCD的 dispatch_source_t 实现的 Timer。 当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。</p></li>
<li><p>CADisplayLink 是一个和屏幕刷新率（每秒刷新60次）一致的定时器（但实际实现原理更复杂，和 NSTimer 并不一样，其内部实际是操作了一个 Source）。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去，造成界面卡顿的感觉。</p></li>
</ul>


<h5>iOS 渲染过程</h5>

<p><img src="http://al1020119.github.io/images/tupianxuanran002.png" title="Caption" ></p>

<p>通常来说，计算机系统中 CPU、GPU、显示器是以上面这种方式协同工作的。CPU 计算好显示内容提交到 GPU，GPU 渲染完成后将渲染结果放入帧缓冲区，随后视频控制器会按照 VSync 信号如下图1-4所示，逐行读取帧缓冲区的数据，经过可能的数模转换传递给显示器显示。</p>

<p><img src="http://al1020119.github.io/images/tupianxuanran003.png" title="Caption" ></p>

<p>在 VSync 信号到来后，系统图形服务会通过 CADisplayLink 等机制通知 App，App 主线程开始在 CPU 中计算显示内容，比如视图的创建、布局计算、图片解码、文本绘制等。随后 CPU 会将计算好的内容提交到 GPU 去，由 GPU 进行变换、合成、渲染。随后 GPU 会把渲染结果提交到帧缓冲区去，等待下一次 VSync 信号到来时显示到屏幕上。由于垂直同步的机制，如果在一个 VSync 时间内，CPU 或者 GPU 没有完成内容提交，则那一帧就会被丢弃，等待下一次机会再显示，而这时显示屏会保留之前的内容不变。这就是界面卡顿的原因。从上图中可以看到，CPU 和 GPU 不论哪个阻碍了显示流程，都会造成掉帧现象。所以开发时，也需要分别对 CPU 和 GPU 压力进行评估和优化。</p>

<p><img src="http://al1020119.github.io/images/tupianxuanran004.png" title="Caption" ></p>

<p>iOS 的显示系统是由 VSync 信号驱动的，VSync 信号由硬件时钟生成，每秒钟发出 60 次（这个值取决设备硬件，比如 iPhone 真机上通常是 59.97）。iOS 图形服务接收到 VSync 信号后，会通过 IPC 通知到 App 内。App 的 Runloop 在启动后会注册对应的 CFRunLoopSource 通过 mach_port 接收传过来的时钟信号通知，随后 Source 的回调会驱动整个 App 的动画与显示。</p>

<p>Core Animation 在 RunLoop 中注册了一个 Observer，监听了 BeforeWaiting 和 Exit 事件。当一个触摸事件到来时，RunLoop 被唤醒，App 中的代码会执行一些操作，比如创建和调整视图层级、设置 UIView 的 frame、修改 CALayer 的透明度、为视图添加一个动画；这些操作最终都会被 CALayer 标记，并通过 CATransaction 提交到一个中间状态去。当上面所有操作结束后，RunLoop 即将进入休眠（或者退出）时，关注该事件的 Observer 都会得到通知。这时 Core Animation 注册的那个 Observer 就会在回调中，把所有的中间状态合并提交到 GPU 去显示；如果此处有动画，通过 DisplayLink 稳定的刷新机制会不断的唤醒runloop，使得不断的有机会触发observer回调，从而根据时间来不断更新这个动画的属性值并绘制出来。</p>

<blockquote><p>为了不阻塞主线程，Core Animation 的核心是 OpenGL ES 的一个抽象物，所以大部分的渲染是直接提交给GPU来处理。 而Core Graphics/Quartz 2D的大部分绘制操作都是在主线程和CPU上同步完成的，比如自定义UIView的drawRect里用CGContext来画图。</p></blockquote>

<h5>渲染时机</h5>

<p>上面已经提到过：Core Animation 在 RunLoop 中注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件 。当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。当Oberver监听的事件到来时，回调执行函数中会遍历所有待处理的UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。</p>

<p>这个函数内部的调用栈大概是这样的：</p>

<pre><code>_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()
    QuartzCore:CA::Transaction::observer_callback:
        CA::Transaction::commit();
            CA::Context::commit_transaction();
                CA::Layer::layout_and_display_if_needed();
                    CA::Layer::layout_if_needed();
                          [CALayer layoutSublayers];
                          [UIView layoutSubviews];
                    CA::Layer::display_if_needed();
                          [CALayer display];
                          [UIView drawRect];
</code></pre>

<h5>CPU 和 GPU渲染</h5>

<p>OpenGL中，GPU屏幕渲染有以下两种方式：</p>

<ul>
<li>On-Screen Rendering</li>
</ul>


<p>意为当前屏幕渲染，指的是GPU的渲染操作是在当前用于显示的屏幕缓冲区中进行。</p>

<ul>
<li>Off-Screen Rendering</li>
</ul>


<p>意为离屏渲染，指的是GPU在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。</p>

<blockquote><p>按照这样的说法，如果将不在GPU的当前屏幕缓冲区中进行的渲染都称为离屏渲染，那么就还有另一种特殊的“离屏渲染”方式：CPU渲染。如果我们重写了drawRect方法，并且使用任何Core Graphics的技术进行了绘制操作，就涉及到了CPU渲染。整个渲染过程由CPU在App内同步地完成，渲染得到的bitmap最后再交由GPU用于显示。</p></blockquote>

<p>相比于当前屏幕渲染，离屏渲染的代价是很高的，主要体现在两个方面：</p>

<pre><code>创建新缓冲区 
要想进行离屏渲染，首先要创建一个新的缓冲区。
上下文切换 
</code></pre>

<p>离屏渲染的整个过程，需要多次切换上下文环境：</p>

<ul>
<li>先是从当前屏幕（On-Screen）切换到离屏（Off-Screen）</li>
<li>等到离屏渲染结束以后，将离屏缓冲区的渲染结果显示到屏幕上有需要将上下文环境从离屏切换到当前屏幕</li>
<li><p>而上下文环境的切换是要付出很大代价的。</p></li>
<li><p>设置了以下属性时，都会触发离屏绘制：</p></li>
</ul>


<hr />

<pre><code>shouldRasterize（光栅化）
masks（遮罩）
shadows（阴影）
edge antialiasing（抗锯齿）
group opacity（不透明） 
</code></pre>

<blockquote><p>需要注意的是，如果shouldRasterize被设置成YES，在触发离屏绘制的同时，会将光栅化后的内容缓存起来，如果对应的layer及其sublayers没有发生改变，在下一帧的时候可以直接复用。这将在很大程度上提升渲染性能。</p></blockquote>

<p>而其它属性如果是开启的，就不会有缓存，离屏绘制会在每一帧都发生。
在开发时需要根据实际情况来选择最优的实现方式，尽量使用On-Screen Rendering。简单的Off-Screen Rendering可以考虑使用Core Graphics让CPU来渲染。</p>

<h5>Core Animation</h5>

<ol>
<li>隐式动画</li>
</ol>


<p>隐式动画是系统框架自动完成的。Core Animation在每个runloop周期中自动开始一次新的事务，即使你不显式的用[CATransaction begin]开始一次事务，任何在一次runloop循环中属性的改变都会被集中起来，然后做一次0.25秒的动画。</p>

<pre><code>在iOS4中，苹果对UIView添加了一种基于block的动画方法：+animateWithDuration:animations:。 
</code></pre>

<p>这样写对做一堆的属性动画在语法上会更加简单，但实质上它们都是在做同样的事情。
CATransaction的+begin和+commit方法在+animateWithDuration:animations:内部自动调用，这样block中所有属性的改变都会被事务所包含。</p>

<p>Core Animation通常对CALayer的所有属性（可动画的属性）做动画，但是UIView是怎么把它关联的图层的这个特性关闭了呢？
每个UIView对它关联的图层都扮演了一个委托，并且提供了-actionForLayer:forKey的实现方法。当不在一个动画块的实现中，UIView对所有图层行为返回nil，但是在动画block范围之内，它就返回了一个非空值。</p>

<pre><code>@interface ViewController ()

@property (nonatomic, weak) IBOutlet UIView *layerView;

@end

@implementation ViewController

- (void)viewDidLoad
{
    [super viewDidLoad];
    //test layer action when outside of animation block
    NSLog(@"Outside: %@", [self.layerView actionForLayer:self.layerView.layer forKey:@"backgroundColor"]);
    //begin animation block
    [UIView beginAnimations:nil context:nil];
    //test layer action when inside of animation block
    NSLog(@"Inside: %@", [self.layerView actionForLayer:self.layerView.layer forKey:@"backgroundColor"]);
    //end animation block
    [UIView commitAnimations];
}

@end
</code></pre>

<hr />

<pre><code>$ LayerTest[21215:c07] Outside: &lt;null&gt;
$ LayerTest[21215:c07] Inside: &lt;CABasicAnimation: 0x757f090&gt;
</code></pre>

<ol>
<li>显式动画</li>
</ol>


<p>Core Animation提供的显式动画类型，既可以直接对退曾属性做动画，也可以覆盖默认的图层行为。</p>

<p>我们经常使用的CABasicAnimation，CAKeyframeAnimation，CATransitionAnimation，CAAnimationGroup等都是显式动画类型，这些CAAnimation类型可以直接提交到CALayer上。</p>

<p>无论是隐式动画还是显式动画，提交到layer后，经过一系列处理，最后都经过上文描述的绘制过程最终被渲染出来。</p>

<h5>Facebook Pop介绍</h5>

<p>在计算机的世界里面，其实并不存在绝对连续的动画，你所看到的屏幕上的动画本质上都是离散的，只是在一秒的时间里面离散的帧多到一定的数量人眼就觉得是连续的了，</p>

<p>在iOS中，最大的帧率是60帧每秒。 iOS提供了Core Animation框架，只需要开发者提供关键帧信息，比如提供某个animatable属性终点的关键帧信息，然后中间的值则通过一定的算法进行插值计算，从而实现补间动画。 Core Aniamtion中进行插值计算所依赖的时间曲线由CAMediaTimingFunction提供。</p>

<blockquote><p>Pop Animation在使用上和Core Animation很相似，都涉及Animation对象以及Animation的载体的概念，不同的是Core Animation的载体只能是CALayer，而Pop Animation可以是任意基于NSObject的对象。当然大多数情况Animation都是界面上显示的可视的效果，所以动画执行的载体一般都直接或者间接是UIView或者CALayer。</p></blockquote>

<p>但是如果你只是想研究Pop Animation的变化曲线，你也完全可以将其应用于一个普通的数据对象。Pop Animation应用于CALayer时，在动画运行的任何时刻，layer和其presentationLayer的相关属性值始终保持一致，而Core Animation做不到。 Pop Animation可以应用任何NSObject的对象，而Core Aniamtion必须是CALayer。</p>

<p>下面这个例子就是自定义Pop readBlock和writeBlock处理自定义的动画属性：</p>

<pre><code>prop = [POPAnimatableProperty propertyWithName:@"com.foo.radio.volume" initializer:^(POPMutableAnimatableProperty *prop) {
    // read value
    prop.readBlock = ^(id obj, CGFloat values[]) {
        values[0] = [obj volume];
    };
    // write value
    prop.writeBlock = ^(id obj, const CGFloat values[]) {
        [obj setVolume:values[0]];
    };
    // dynamics threshold
    prop.threshold = 0.01;
}];

POPSpringAnimation *anim = [POPSpringAnimation animation];
anim.property = prop;
</code></pre>

<p>Pop实现依赖的核心就是CADisplayLink。</p>

<p>最后附上一篇介绍Facebook Pop如何使用的文章 《Introducing Facebook Pop》</p>

<h5>AsyncDisplay介绍</h5>

<p>阻塞主线程的绘制任务主要是这三大类：</p>

<ul>
<li><p>Layout计算视图布局文本宽高</p></li>
<li><p>Rendering文本渲染图片解码图片绘制</p></li>
<li><p>UIKit对象创建更新释放。</p></li>
</ul>


<p>除了UIKit和CoreAnimation相关操作必须在主线程中进行，其他的都可以挪到后台线程异步执行。</p>

<p>AsyncDisplay通过抽象UIView的关系创建了ASDisplayNode类，ASDisplayNode是线程安全的，它可以在后台线程创建和修改。Node 刚创建时，并不会在内部新建 UIView 和 CALayer，直到第一次在主线程访问 view 或 layer 属性时，它才会在内部生成对应的对象。当它的属性（比如frame/transform）改变后，它并不会立刻同步到其持有的 view 或 layer 去，而是把被改变的属性保存到内部的一个中间变量，稍后在需要时，再通过某个机制一次性设置到内部的 view 或 layer。从而可以实现异步并发操作。</p>

<p>AsyncDisplay实现依赖如同Core Animation在runloop中注册observer事件来触发。
同样附上一篇介绍AsyncDisplay的好文 《iOS保持界面流畅的技巧和AsyncDisplay介绍》</p>

<hr />

<p>参考文章</p>

<p><a href="https://github.com/ming1016/study/wiki/CFRunLoop">runloop原理</a></p>

<p><a href="http://blog.ibireme.com/2015/05/18/runloop/">深入理解runloop</a></p>

<p><a href="http://objccn.io/issue-2-4/">线程安全类的设计</a></p>

<p><a href="http://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/">iOS保持界面流畅的技巧和AsyncDisplay介绍</a></p>

<p><a href="http://foggry.com/blog/2015/05/06/chi-ping-xuan-ran-xue-xi-bi-ji/">离屏渲染</a></p>

<p><a href="https://zsisme.gitbooks.io/ios-/content/index.html">ios核心动画高级技巧</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Watch OS2 初探]]></title>
    <link href="http://al1020119.github.io/blog/2015/12/08/watch-os2-chu-tan/"/>
    <updated>2015-12-08T17:44:31+08:00</updated>
    <id>http://al1020119.github.io/blog/2015/12/08/watch-os2-chu-tan</id>
    <content type="html"><![CDATA[<blockquote><p>这一年的WWDC大会上,苹果公司推出了watchOS 2,这标志着Apple Watch的开发产生了巨大的变化。现在,你可以开发能运行在你手表上原生的app了。 在这篇watchOS 2教程中,你会开发一个简单但是功能齐全的watchOS 2的app。
在这个过程中,你会学到:</p></blockquote>

<ul>
<li>如何为iOS app添加watchOS 2的target</li>
<li>如何在两个target之间共享数据</li>
<li>如何添加一个watchOS 2界面控制器到Storyboard,并放置界面对象</li>
<li>如何创建WKInterfaceController的子类并连线</li>
</ul>


<!--more-->


<p>正式开始吧</p>

<p>首先下载教程的起始项目吧。</p>

<p>在Xcode中打开它然后编译运行。你应该会看到一个空白界面:</p>

<p><img src="http://al1020119.github.io/images/watchOS001.png" title="Caption" ></p>

<p>这个项目没有太多的文件,只包含一些你需要的最基本的文件。</p>

<p>添加WatchKit App</p>

<p>选择File\New\Target…,在出现的对话框中选择watchOS\Application\WatchKit App然后点击Next:</p>

<p><img src="http://al1020119.github.io/images/watchOS002.png" title="Caption" ></p>

<p>在接下来的界面中,设置项目名字为Watch,确保语言设置为Swift,然后取消选中任何复选框。点击Finish:</p>

<p><img src="http://al1020119.github.io/images/watchOS003.png" title="Caption" ></p>

<p>之后会询问你是否想要激活watch scheme,你需要这么做,所以确保选择了激活:</p>

<p><img src="http://al1020119.github.io/images/watchOS004.png" title="Caption" ></p>

<p>祝贺,你刚刚创建了你的第一个手表app!这真的很容易。</p>

<p>你会注意到,这个操作实际上创建了两个target,而不是一个,在项目导航中看到两个对应的组。这是因为手表app的代码实际是作为一个扩展形式存在的,类似iOS上的Today extensions。</p>

<p>当你在项目导航中点开Watch和Watch Extensions组的时候,你会看到所有storyboard放在Watch组,当前target创建的所有的类文件放在Watch Extensions组中:</p>

<p><img src="http://al1020119.github.io/images/watchOS005.png" title="Caption" ></p>

<p>你需要遵循如下的原则:任何你添加的代码必须放在Watch Extension组中然后添加到Watch Extension target,而所有的assets或者storyboards需要放在Watch组里。</p>

<p><img src="http://al1020119.github.io/images/watchOS006.png" title="Caption" ></p>

<p>在继续前,你需要删掉一些target模板添加的你不需要的文件。</p>

<p>在项目导航里面右键点击InterfaceController.swift然后选择删除。 当弹出提示,选择Move to Trash来确保文件确实从项目中删掉了:</p>

<p><img src="http://al1020119.github.io/images/watchOS007.png" title="Caption" ></p>

<p>下一步,打开Interface.storyboard,选择其中仅有的界面控制器,按下backspace键来删除它。现在就剩下一个空storyboard,或者是我认为的,一个空白画布。</p>

<p>共享数据和代码</p>

<p>起始项目包含一个记录所有Aber航空公司航班信息的JSON文件,一个模型类表示飞行数据。这正是应该共享的数据,因为iOS app和手表app使用相同的模型类和数据-你记得DRY(不要写重复的代码)原则吗?</p>

<p>在项目导航中点开Shared组然后选择Flights.json。之后,在File Inspector中找到Target Membership区域,选中Watch Extension</p>

<p><img src="http://al1020119.github.io/images/watchOS008.png" title="Caption" ></p>

<p>文件现在应该被AirAber和Watch Extensions这两个target所包含。 为其他Shared组的文件重复这个步骤,比如说Flight.swift。 这些都做完后,你可以开始开发航班详情界面了!</p>

<p>构造界面</p>

<p>打开 Watch\Interface.storyboard,从对象库拖一个界面控制器到storyboard里面.选中这个界面控制器,打开属性检查器设置它的Identificer为Flight,然后勾选Is Initial Controller:</p>

<p><img src="http://al1020119.github.io/images/watchOS009.png" title="Caption" ></p>

<p>你设置的这个Identifier让你可以在代码中引用这个界面控制器。选中Is Initial Controller简单告诉WatchKit你希望当应用程序启动的时候首先显示这个界面。</p>

<p>下一步,从对象库中拖动一个组到界面控制器:</p>

<p><img src="http://al1020119.github.io/images/watchOS010.png" title="Caption" ></p>

<p>之后这个组会包含Aber公司的logo,航班号和路线。</p>

<p>选中这个组,在属性检查器的顶部改变它的Insets为Custom。这会显示四个额外的文本框让你可以手动的设置组的上下左右。设置Top为6:</p>

<p><img src="http://al1020119.github.io/images/watchOS011.png" title="Caption" ></p>

<p>这仅仅让你的组到顶部有个额外的空隙。</p>

<p>下一步,拖动Image到组中。组会相应的收缩来改变Top inset(感谢Xcode!),之后在文档大纲中检查来确保Image是组的子节点,而不是同级:</p>

<p><img src="http://al1020119.github.io/images/watchOS012.png" title="Caption" ></p>

<p>现在需要显示一张图片,下载logo图片然后把它拖动到Watch\Assets.xcassets中。这会创建一个新的logo图片,存放在2x的部分。</p>

<p><img src="http://al1020119.github.io/images/watchOS013.png" title="Caption" ></p>

<p>为了给图片染色,选中这张图片,在属性检查器中修改Render As为Template Image。</p>

<p>重新打开 Watch\Interface.storyboard 选中之前的image.使用属性检查器,做如下的改变:</p>

<ul>
<li>设置图片为Logo - 当下拉列表没有出现,你可以自己输入;</li>
<li>设置Tint为#FA114F(也可以在颜色面板中输入值);</li>
<li>设置Width为Fixed,值为40;</li>
<li>设置Height为Fixed,值为40。</li>
</ul>


<p>属性检查器现在应该像下面这样:</p>

<p><img src="http://al1020119.github.io/images/watchOS014.png" title="Caption" ></p>

<p>不要担心看不到logo,因为Xcode设计时无法给模板图片染色!</p>

<p>下一步,往已经存在的组中拖动另外一个组,确保它出现在image的右侧,使用属性检查器设置Layout属性为Vertical.同样修改Spacing为0、Width为Size to Fit Content。然后拖动两个label到新的组中,放置一个到另一个的下面。</p>

<p><img src="http://al1020119.github.io/images/watchOS015.png" title="Caption" ></p>

<p>选择上面的label,使用属性检查器,设置文本为Flight 123,文字颜色为#FA114F。</p>

<p>选择下面的label,设置文本为MAM to SFO。界面控制器最后看起来像下面这样:</p>

<p><img src="http://al1020119.github.io/images/watchOS016.png" title="Caption" ></p>

<p>这些文本仅仅充当占位符,之后会被控制器中设置的文本取代。</p>

<p>下一步,拖动另一个组到界面控制器中,但是这次确保与第一个组同级。当不能设置组级别关系请使用文档大纲(Document Outline)。</p>

<p><img src="http://al1020119.github.io/images/watchOS017.png" title="Caption" ></p>

<p>选中新的组,设置它的Layout为Vertical、Spacing为0。</p>

<p>现在,拖动三个label到新的组中:</p>

<p><img src="http://al1020119.github.io/images/watchOS018.png" title="Caption" ></p>

<p>确保label都在group中,而不是与group同级!</p>

<p>选择顶部的label使用属性检查器修改它的文本为AA123 Boards。</p>

<p>选中中间的label,修改文本颜色为#FA114F,字体选择System,Regulaer样式和54.0的size.最后,修改Height为Fixed,值是44。</p>

<p>选中底部的label修改文本为On time,文本颜色为#04DE71。 你的界面控制器应该现在像下面这样:</p>

<p><img src="http://al1020119.github.io/images/watchOS019.png" title="Caption" ></p>

<p>从对象库中拖动一个新的组到下面的组,这次确保它是在子节点而不是在同级,之后向其中添加两个label,你完全的界面对象关系应该像这样:</p>

<p><img src="http://al1020119.github.io/images/watchOS020.png" title="Caption" ></p>

<p>使用属性检查器,设置左边的label文本为Gate 1A。右边的label设置为Seat 64A,之后设置它的Horizontal alignment为Right 完全的界面应该像如下这样:</p>

<p><img src="http://al1020119.github.io/images/watchOS021.png" title="Caption" ></p>

<p>恭喜,你已经完成你的第一个watch app界面的布局了,现在是时候给它填充一些真实的数据然后在模拟器上运行。</p>

<p>创建控制器</p>

<p>在项目导航中右击Watch Extensions组,选择New File,在出现的对话框中选择watchOS\Source\WatchKit Class然后点击Next。命名新的类为FlightInterfaceController,确保它为WKInterfaceController的子类,语言设置为Swift:</p>

<p><img src="http://al1020119.github.io/images/watchOS022.png" title="Caption" ></p>

<p>点击Next,之后是Create</p>

<p>可以看到新的文件在代码编辑器中打开了,删除其中的三个空方法,只剩下import语句和类定义。</p>

<p>添加这些Outlets到FlightInterfaceController的顶部:</p>

<pre><code>@IBOutlet var flightLabel: WKInterfaceLabel!
@IBOutlet var routeLabel: WKInterfaceLabel!
@IBOutlet var boardingLabel: WKInterfaceLabel!
@IBOutlet var boardTimeLabel: WKInterfaceLabel!
@IBOutlet var statusLabel: WKInterfaceLabel!
@IBOutlet var gateLabel: WKInterfaceLabel!
@IBOutlet var seatLabel: WKInterfaceLabel!
</code></pre>

<p>这里仅仅为之前的每个label添加一个Outlet。稍后会把他们连接起来。</p>

<p>下一步,在outlets下面添加flight属性和对应的属性观察器:</p>

<pre><code>// 1
var flight: Flight? {
  // 2
  didSet {
    // 3
    if let flight = flight {
      // 4
      flightLabel.setText("Flight \(flight.shortNumber)")
      routeLabel.setText(flight.route)
      boardingLabel.setText("\(flight.number) Boards")
      boardTimeLabel.setText(flight.boardsAt)
      // 5
      if flight.onSchedule {
        statusLabel.setText("On Time")
      } else {
        statusLabel.setText("Delayed")
        statusLabel.setTextColor(UIColor.redColor())
      }
      gateLabel.setText("Gate \(flight.gate)")
      seatLabel.setText("Seat \(flight.seat)")
    }
  }
}
</code></pre>

<p>会一步步讲解发生的事情:</p>

<ul>
<li><p>1.你定义了一个可选的属性类型为Flight。这个类在Flight.swift中定义;</p></li>
<li><p>2.你添加了一个属性观察器,当属性设值时候会触发它;</p></li>
<li><p>3.在可选属性中确保有一个真的flight而不是nil,当flight存在才会去设置labels的值;</p></li>
<li><p>4.使用flight的相关属性去设置labels</p></li>
<li><p>5.如果航班被延误，那么你就将标签的文本颜色改为红色</p></li>
</ul>


<p>在控制器第一次显示时候设置航班。添加以下声明：</p>

<pre><code>override func awakeWithContext(context: AnyObject?) {
  super.awakeWithContext(context)
  flight = Flight.allFlights().first!
}
</code></pre>

<p>本后面的教程会修改为在上下文中传递值给它,但现在你只需要从共享的JSON文件中加载所有的航班,然后使用数组中的第一个。</p>

<p>在后面的教程你将学到更多关于awakeWithContext（_：)的知识,但是现在你仅仅需要知道它是界面控制器生命周期第一环节,一个设置flight值的地方。 现在仅剩最后一步你就可以编译运行了,就是去连接outlets</p>

<p>连接outlets</p>

<p>打开 Watch\Interface.storyboard 选择界面控制器,使用Identity Inspector,设置Class\Custom Class为FlightInterfaceController</p>

<p>下一步,右击界面控制器顶部的黄色图片弹出窗口:</p>

<p><img src="http://al1020119.github.io/images/watchOS023.png" title="Caption" ></p>

<p>现在,按下面的列表连接outlets:</p>

<pre><code>boardingLabel: AA123 Boards
boardTimeLabel: 15:06
flightLabel: Flight 123
gateLabel: Gate 1A
routeLabel: MAN to SFO
seatLabel: Seat 64A
statusLabel: On time
</code></pre>

<p>在运行之前,有一件事情要做。本教程的实例app专为42mm的Apple Watch开发的,所以你需要确保正确设置了模拟器,否则界面元素看起来会有点小。对于一个现实app,需要确保界面能很好运行在两种大小的手表上,但这在本教程的范围之外。</p>

<p>在Xcode中,选择Window\Devices打开设备管理器,点击右下角的 + 图标.在弹出的对话框中,命名模拟器为iPhone 6 - 42mm,设置设备类型为iPhone 6,修改配对的Apple watch为Apple Watch - 42mm (WatchOS 2.0)然后点击Create:</p>

<p><img src="http://al1020119.github.io/images/watchOS024.png" title="Caption" ></p>

<p>关闭设备管理器,选择Watch Scheme,然后选中新的模拟器:</p>

<p><img src="http://al1020119.github.io/images/watchOS025.png" title="Caption" ></p>

<p>编译运行。一段模拟器启动完成你会看到下面界面:</p>

<p><img src="http://al1020119.github.io/images/watchOS026.png" title="Caption" ></p>

<blockquote><p>注意:如果收到一条错误消息,说明安装失败,然后你可以再次尝试使用Xcode,或者在手表模拟器上手动安装app。为此,打开iOS模拟器中的手表app,点击AirAber,在Apple Watch弹出我们的app。一旦这么做了,返回手表模拟器,按Shift + Ctrl + H导航到主界面, 然后点击AirAber图片来启动手表app。</p></blockquote>

<p>恭喜!你已经完成WatchKit初始界面,并使用真实的数据使它很好运行在手表模拟器上。</p>

<p>稍后会做什么?</p>

<p>下面是这个系列教程完整示例项目。</p>

<p>在这个练习中你已经学会了如何往现有的iOS app中添加手表app，如何创建一个界面控制器和使用嵌套组构造一个非常复杂的界面，以及使用WKInterfaceController类来配合这项工作。那么，接下来呢？</p>

<p>本教程系列的第二部分，你将学习所有关于表和导航WatchKit的使用。</p>
]]></content>
  </entry>
  
</feed>
