<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[iOS梦工厂]]></title>
  <link href="http://al1020119.github.io/atom.xml" rel="self"/>
  <link href="http://al1020119.github.io/"/>
  <updated>2016-08-31T12:42:00+08:00</updated>
  <id>http://al1020119.github.io/</id>
  <author>
    <name><![CDATA[iCocos]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[多线程安全？应该不止这些😂！]]></title>
    <link href="http://al1020119.github.io/blog/2016/08/31/duo-xian-cheng-an-quan-%3Fying-gai-bu-zhi-zhe-xie-%3F!/"/>
    <updated>2016-08-31T12:33:27+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/08/31/duo-xian-cheng-an-quan-?ying-gai-bu-zhi-zhe-xie-?!</id>
    <content type="html"><![CDATA[<ul>
<li>前言</li>
<li>介绍与使用</li>
<li>总结</li>
<li>其他实战使用</li>
</ul>


<h2>一、前言</h2>

<p>前段时间看了几个开源项目，发现他们保持线程同步的方式各不相同，有@synchronized、NSLock、dispatch_semaphore、NSCondition、pthread_mutex、OSSpinLock。后来网上查了一下，发现他们的实现机制各不相同，性能也各不一样。不好意思，我们平常使用最多的@synchronized是性能最差的。下面我们先分别介绍每个加锁方式的使用，在使用一个案例来对他们进行性能对比。</p>

<h2>二、介绍与使用</h2>

<!--more-->


<h4>2.1、@synchronized</h4>

<pre><code>    NSObject *obj = [[NSObject alloc] init];



    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{

        @synchronized(obj) {

            NSLog(@"需要线程同步的操作1 开始");

            sleep(3);

            NSLog(@"需要线程同步的操作1 结束");

        }

    });



    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{

        sleep(1);

        @synchronized(obj) {

            NSLog(@"需要线程同步的操作2");

        }

    });
</code></pre>

<p>@synchronized(obj)指令使用的obj为该锁的唯一标识，只有当标识相同时，才为满足互斥，如果线程2中的@synchronized(obj)改为@synchronized(self),刚线程2就不会被阻塞，@synchronized指令实现锁的优点就是我们不需要在代码中显式的创建锁对象，便可以实现锁的机制，但作为一种预防措施，@synchronized块会隐式的添加一个异常处理例程来保护代码，该处理例程会在异常抛出的时候自动的释放互斥锁。所以如果不想让隐式的异常处理例程带来额外的开销，你可以考虑使用锁对象。</p>

<p>上面结果的执行结果为：</p>

<pre><code>2016-06-29 20:48:35.747 SafeMultiThread[35945:580107] 需要线程同步的操作1 开始

2016-06-29 20:48:38.748 SafeMultiThread[35945:580107] 需要线程同步的操作1 结束

2016-06-29 20:48:38.749 SafeMultiThread[35945:580118] 需要线程同步的操作2
</code></pre>

<h4>2.2、dispatch_semaphore</h4>

<pre><code>dispatch_semaphore_t signal = dispatch_semaphore_create(1);

    dispatch_time_t overTime = dispatch_time(DISPATCH_TIME_NOW, 3 * NSEC_PER_SEC);



    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{

        dispatch_semaphore_wait(signal, overTime);

            NSLog(@"需要线程同步的操作1 开始");

            sleep(2);

            NSLog(@"需要线程同步的操作1 结束");

        dispatch_semaphore_signal(signal);

    });



    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{

        sleep(1);

        dispatch_semaphore_wait(signal, overTime);

            NSLog(@"需要线程同步的操作2");

        dispatch_semaphore_signal(signal);

    });
</code></pre>

<p>dispatch_semaphore是GCD用来同步的一种方式，与他相关的共有三个函数，分别是dispatch_semaphore_create，dispatch_semaphore_signal，dispatch_semaphore_wait。</p>

<h6>（1）dispatch_semaphore_create的声明为：</h6>

<pre><code>dispatch_semaphore_t dispatch_semaphore_create(long value);
</code></pre>

<p>传入的参数为long，输出一个dispatch_semaphore_t类型且值为value的信号量。</p>

<p>值得注意的是，这里的传入的参数value必须大于或等于0，否则dispatch_semaphore_create会返回NULL。</p>

<h6>（2）dispatch_semaphore_signal的声明为：</h6>

<pre><code>long dispatch_semaphore_signal(dispatch_semaphore_t dsema)
</code></pre>

<p>这个函数会使传入的信号量dsema的值加1；</p>

<h6>(3) dispatch_semaphore_wait的声明为：</h6>

<pre><code>long dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)；
</code></pre>

<p>这个函数会使传入的信号量dsema的值减1；这个函数的作用是这样的，如果dsema信号量的值大于0，该函数所处线程就继续执行下面的语句，并且将信号量的值减1；如果desema的值为0，那么这个函数就阻塞当前线程等待timeout（注意timeout的类型为dispatch_time_t，不能直接传入整形或float型数），如果等待的期间desema的值被dispatch_semaphore_signal函数加1了，且该函数（即dispatch_semaphore_wait）所处线程获得了信号量，那么就继续向下执行并将信号量减1。如果等待期间没有获取到信号量或者信号量的值一直为0，那么等到timeout时，其所处线程自动执行其后语句。</p>

<p>dispatch_semaphore 是信号量，但当信号总量设为 1 时也可以当作锁来。在没有等待情况出现时，它的性能比 pthread_mutex 还要高，但一旦有等待情况出现时，性能就会下降许多。相对于 OSSpinLock 来说，它的优势在于等待时不会消耗 CPU 资源。</p>

<p>如上的代码，如果超时时间overTime设置成>2，可完成同步操作。如果overTime</p>

<p>上面代码的执行结果为：</p>

<pre><code>2016-06-29 20:47:52.324 SafeMultiThread[35945:579032] 需要线程同步的操作1 开始

2016-06-29 20:47:55.325 SafeMultiThread[35945:579032] 需要线程同步的操作1 结束

2016-06-29 20:47:55.326 SafeMultiThread[35945:579033] 需要线程同步的操作2
</code></pre>

<p>如果把超时时间设置为</p>

<pre><code>2016-06-30 18:53:24.049 SafeMultiThread[30834:434334] 需要线程同步的操作1 开始

2016-06-30 18:53:25.554 SafeMultiThread[30834:434332] 需要线程同步的操作2

2016-06-30 18:53:26.054 SafeMultiThread[30834:434334] 需要线程同步的操作1 结束
</code></pre>

<h4>2.3、NSLock</h4>

<pre><code>   NSLock *lock = [[NSLock alloc] init];

    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{

        //[lock lock];

        [lock lockBeforeDate:[NSDate date]];

            NSLog(@"需要线程同步的操作1 开始");

            sleep(2);

            NSLog(@"需要线程同步的操作1 结束");

        [lock unlock];



    });



    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{

        sleep(1);

        if ([lock tryLock]) {//尝试获取锁，如果获取不到返回NO，不会阻塞该线程

            NSLog(@"锁可用的操作");

            [lock unlock];

        }else{

            NSLog(@"锁不可用的操作");

        }



        NSDate *date = [[NSDate alloc] initWithTimeIntervalSinceNow:3];

        if ([lock lockBeforeDate:date]) {//尝试在未来的3s内获取锁，并阻塞该线程，如果3s内获取不到恢复线程, 返回NO,不会阻塞该线程

            NSLog(@"没有超时，获得锁");

            [lock unlock];

        }else{

            NSLog(@"超时，没有获得锁");

        }



    });
</code></pre>

<p>NSLock是Cocoa提供给我们最基本的锁对象，这也是我们经常所使用的，除lock和unlock方法外，NSLock还提供了tryLock和lockBeforeDate:两个方法，前一个方法会尝试加锁，如果锁不可用(已经被锁住)，刚并不会阻塞线程，并返回NO。lockBeforeDate:方法会在所指定Date之前尝试加锁，如果在指定时间之前都不能加锁，则返回NO。</p>

<p>上面代码的执行结果为：</p>

<pre><code>2016-06-29 20:45:08.864 SafeMultiThread[35911:575795] 需要线程同步的操作1 开始

2016-06-29 20:45:09.869 SafeMultiThread[35911:575781] 锁不可用的操作

2016-06-29 20:45:10.869 SafeMultiThread[35911:575795] 需要线程同步的操作1 结束

2016-06-29 20:45:10.870 SafeMultiThread[35911:575781] 没有超时，获得锁
</code></pre>

<p>源码定义如下：</p>

<pre><code>@protocol NSLocking



- (void)lock;

- (void)unlock;



@end



@interface NSLock : NSObject  {

&lt;a href="http://www.jobbole.com/members/kaishu6296"&gt;@private&lt;/a&gt;

    void *_priv;

}



- (BOOL)tryLock;

- (BOOL)lockBeforeDate:(NSDate *)limit;



@property (nullable, copy) NSString *name NS_AVAILABLE(10_5, 2_0);



@end
</code></pre>

<h4>2.4、NSRecursiveLock递归锁</h4>

<pre><code>    //NSLock *lock = [[NSLock alloc] init];

    NSRecursiveLock *lock = [[NSRecursiveLock alloc] init];



    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{



        static void (^RecursiveMethod)(int);



        RecursiveMethod = ^(int value) {



            [lock lock];

            if (value &gt; 0) {



                NSLog(@"value = %d", value);

                sleep(1);

                RecursiveMethod(value - 1);

            }

            [lock unlock];

        };



        RecursiveMethod(5);

    });
</code></pre>

<p>NSRecursiveLock实际上定义的是一个递归锁，这个锁可以被同一线程多次请求，而不会引起死锁。这主要是用在循环或递归操作中。</p>

<p>这段代码是一个典型的死锁情况。在我们的线程中，RecursiveMethod是递归调用的。所以每次进入这个block时，都会去加一次锁，而从第二次开始，由于锁已经被使用了且没有解锁，所以它需要等待锁被解除，这样就导致了死锁，线程被阻塞住了。调试器中会输出如下信息：</p>

<pre><code>2016-06-30 19:08:06.393 SafeMultiThread[30928:449008] value = 5

2016-06-30 19:08:07.399 SafeMultiThread[30928:449008] -[NSLock lock]: deadlock ( ‘(null)’)

2016-06-30 19:08:07.399 SafeMultiThread[30928:449008] Break on _NSLockError() to debug.
</code></pre>

<p>在这种情况下，我们就可以使用NSRecursiveLock。它可以允许同一线程多次加锁，而不会造成死锁。递归锁会跟踪它被lock的次数。每次成功的lock都必须平衡调用unlock操作。只有所有达到这种平衡，锁最后才能被释放，以供其它线程使用。</p>

<p>如果我们将NSLock代替为NSRecursiveLock，上面代码则会正确执行。</p>

<pre><code>2016-06-30 19:09:41.414 SafeMultiThread[30949:450684] value = 5

2016-06-30 19:09:42.418 SafeMultiThread[30949:450684] value = 4

2016-06-30 19:09:43.419 SafeMultiThread[30949:450684] value = 3

2016-06-30 19:09:44.424 SafeMultiThread[30949:450684] value = 2

2016-06-30 19:09:45.426 SafeMultiThread[30949:450684] value = 1
</code></pre>

<p>如果需要其他功能，源码定义如下：</p>

<pre><code>@interface NSRecursiveLock : NSObject  {

&lt;a href="http://www.jobbole.com/members/kaishu6296"&gt;@private&lt;/a&gt;

    void *_priv;

}



- (BOOL)tryLock;

- (BOOL)lockBeforeDate:(NSDate *)limit;



@property (nullable, copy) NSString *name NS_AVAILABLE(10_5, 2_0);



@end
</code></pre>

<h2>2.5、NSConditionLock条件锁</h2>

<pre><code>    NSMutableArray *products = [NSMutableArray array];



    NSInteger HAS_DATA = 1;

    NSInteger NO_DATA = 0;



    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{

        while (1) {

            [lock lockWhenCondition:NO_DATA];

            [products addObject:[[NSObject alloc] init]];

            NSLog(@"produce a product,总量:%zi",products.count);

            [lock unlockWithCondition:HAS_DATA];

            sleep(1);

        }



    });



    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{

        while (1) {

            NSLog(@"wait for product");

            [lock lockWhenCondition:HAS_DATA];

            [products removeObjectAtIndex:0];

            NSLog(@"custome a product");

            [lock unlockWithCondition:NO_DATA];

        }



    });
</code></pre>

<p>当我们在使用多线程的时候，有时一把只会lock和unlock的锁未必就能完全满足我们的使用。因为普通的锁只能关心锁与不锁，而不在乎用什么钥匙才能开锁，而我们在处理资源共享的时候，多数情况是只有满足一定条件的情况下才能打开这把锁：</p>

<p>在线程1中的加锁使用了lock，所以是不需要条件的，所以顺利的就锁住了，但在unlock的使用了一个整型的条件，它可以开启其它线程中正在等待这把钥匙的临界地，而线程2则需要一把被标识为2的钥匙，所以当线程1循环到最后一次的时候，才最终打开了线程2中的阻塞。但即便如此，NSConditionLock也跟其它的锁一样，是需要lock与unlock对应的，只是lock,lockWhenCondition:与unlock，unlockWithCondition:是可以随意组合的，当然这是与你的需求相关的。</p>

<p>上面代码执行结果如下：</p>

<pre><code>2016-06-30 20:31:58.699 SafeMultiThread[31282:521698] wait for product

2016-06-30 20:31:58.699 SafeMultiThread[31282:521708] produce a product,总量:1

2016-06-30 20:31:58.700 SafeMultiThread[31282:521698] custome a product

2016-06-30 20:31:58.700 SafeMultiThread[31282:521698] wait for product

2016-06-30 20:31:59.705 SafeMultiThread[31282:521708] produce a product,总量:1

2016-06-30 20:31:59.706 SafeMultiThread[31282:521698] custome a product

2016-06-30 20:31:59.706 SafeMultiThread[31282:521698] wait for product

2016-06-30 20:32:00.707 SafeMultiThread[31282:521708] produce a product,总量:1

2016-06-30 20:32:00.708 SafeMultiThread[31282:521698] custome a product
</code></pre>

<p>如果你需要其他功能，源码定义如下：</p>

<pre><code>@interface NSConditionLock : NSObject  {

&lt;a href="http://www.jobbole.com/members/kaishu6296"&gt;@private&lt;/a&gt;

    void *_priv;

}



- (instancetype)initWithCondition:(NSInteger)condition NS_DESIGNATED_INITIALIZER;



@property (readonly) NSInteger condition;

- (void)lockWhenCondition:(NSInteger)condition;

- (BOOL)tryLock;

- (BOOL)tryLockWhenCondition:(NSInteger)condition;

- (void)unlockWithCondition:(NSInteger)condition;

- (BOOL)lockBeforeDate:(NSDate *)limit;

- (BOOL)lockWhenCondition:(NSInteger)condition beforeDate:(NSDate *)limit;



@property (nullable, copy) NSString *name NS_AVAILABLE(10_5, 2_0);



@end
</code></pre>

<h4>2.6、NSCondition</h4>

<pre><code>   NSCondition *condition = [[NSCondition alloc] init];



    NSMutableArray *products = [NSMutableArray array];



    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{

        while (1) {

            [condition lock];

            if ([products count] == 0) {

                NSLog(@"wait for product");

                [condition wait];

            }

            [products removeObjectAtIndex:0];

            NSLog(@"custome a product");

            [condition unlock];

        }



    });



    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{

        while (1) {

            [condition lock];

            [products addObject:[[NSObject alloc] init]];

            NSLog(@"produce a product,总量:%zi",products.count);

            [condition signal];

            [condition unlock];

            sleep(1);

        }



    });
</code></pre>

<h6>一种最基本的条件锁。手动控制线程wait和signal。</h6>

<p>[condition lock];一般用于多线程同时访问、修改同一个数据源，保证在同一时间内数据源只被访问、修改一次，其他线程的命令需要在lock 外等待，只到unlock ，才可访问</p>

<pre><code>[condition unlock];与lock 同时使用



[condition wait];让当前线程处于等待状态



[condition signal];CPU发信号告诉线程不用在等待，可以继续执行
</code></pre>

<p>上面代码执行结果如下：</p>

<pre><code>2016-06-30 20:21:25.295 SafeMultiThread[31256:513991] wait for product

2016-06-30 20:21:25.296 SafeMultiThread[31256:513994] produce a product,总量:1

2016-06-30 20:21:25.296 SafeMultiThread[31256:513991] custome a product

2016-06-30 20:21:25.297 SafeMultiThread[31256:513991] wait for product

2016-06-30 20:21:26.302 SafeMultiThread[31256:513994] produce a product,总量:1

2016-06-30 20:21:26.302 SafeMultiThread[31256:513991] custome a product

2016-06-30 20:21:26.302 SafeMultiThread[31256:513991] wait for product

2016-06-30 20:21:27.307 SafeMultiThread[31256:513994] produce a product,总量:1

2016-06-30 20:21:27.308 SafeMultiThread[31256:513991] custome a product
</code></pre>

<h4>2.7、pthread_mutex</h4>

<pre><code>    __block pthread_mutex_t theLock;

    pthread_mutex_init(&amp;theLock, NULL);



    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{

            pthread_mutex_lock(&amp;theLock);

            NSLog(@"需要线程同步的操作1 开始");

            sleep(3);

            NSLog(@"需要线程同步的操作1 结束");

            pthread_mutex_unlock(&amp;theLock);



    });



    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{

            sleep(1);

            pthread_mutex_lock(&amp;theLock);

            NSLog(@"需要线程同步的操作2");

            pthread_mutex_unlock(&amp;theLock);



    });
</code></pre>

<p>c语言定义下多线程加锁方式。</p>

<pre><code>1：pthread_mutex_init(pthread_mutex_t mutex,const pthread_mutexattr_t attr);

初始化锁变量mutex。attr为锁属性，NULL值为默认属性。

2：pthread_mutex_lock(pthread_mutex_t mutex);加锁

3：pthread_mutex_tylock(*pthread_mutex_t *mutex);加锁，但是与2不一样的是当锁已经在使用的时候，返回为EBUSY，而不是挂起等待。

4：pthread_mutex_unlock(pthread_mutex_t *mutex);释放锁

5：pthread_mutex_destroy(pthread_mutex_t* mutex);使用完后释放
</code></pre>

<p>代码执行操作结果如下：</p>

<pre><code>2016-06-30 21:13:32.440 SafeMultiThread[31429:548869] 需要线程同步的操作1 开始

2016-06-30 21:13:35.445 SafeMultiThread[31429:548869] 需要线程同步的操作1 结束

2016-06-30 21:13:35.446 SafeMultiThread[31429:548866] 需要线程同步的操作2
</code></pre>

<h4>2.8、pthread_mutex(recursive)</h4>

<p>这是pthread_mutex为了防止在递归的情况下出现死锁而出现的递归锁。作用和NSRecursiveLock递归锁类似。</p>

<p>如果使用pthread_mutex_init(&amp;theLock, NULL);初始化锁的话，上面的代码会出现死锁现象。如果使用递归锁的形式，则没有问题。</p>

<h4>2.9、OSSpinLock</h4>

<p>OSSpinLock 自旋锁，性能最高的锁。原理很简单，就是一直 do while 忙等。它的缺点是当等待时会消耗大量 CPU 资源，所以它不适用于较长时间的任务。 不过最近YY大神在自己的博客不再安全的 OSSpinLock中说明了OSSpinLock已经不再安全，请大家谨慎使用。</p>

<p>三、性能对比</p>

<p>对以上各个锁进行1000000此的加锁解锁的空操作时间如下：</p>

<pre><code>OSSpinLock: 46.15 ms

dispatch_semaphore: 56.50 ms

pthread_mutex: 178.28 ms

NSCondition: 193.38 ms

NSLock: 175.02 ms

pthread_mutex(recursive): 172.56 ms

NSRecursiveLock: 157.44 ms

NSConditionLock: 490.04 ms

@synchronized: 371.17 ms
</code></pre>

<h2>三.总的来说：</h2>

<ul>
<li><p>OSSpinLock和dispatch_semaphore的效率远远高于其他。</p></li>
<li><p>@synchronized和NSConditionLock效率较差。</p></li>
<li><p>鉴于OSSpinLock的不安全，所以我们在开发中如果考虑性能的话，建议使用dispatch_semaphore。</p></li>
<li><p>如果不考虑性能，只是图个方便的话，那就使用@synchronized。</p>

<blockquote><p> 总感觉这个标题怪怪的,但是我自身词汇有限,也不知道怎么描述好了.用一个简单的需求来解释一下吧.我之前开发的一个项目,需要向服务器上传图片,多图片上传,然后每次上传之后会返回一个图片的AID, 然后需要所有图片上传完成之后, 拿着一个全是AID的数组作为参数进行另一个异步请求&hellip;好吧,我感觉又绕了&hellip;</p></blockquote>

<p>  前几天,我在一个技术交流圈,看到一个朋友去JINGDONG的面试题, 其中一个题目的描述是:有a、b、c、d 4个异步请求，如何判断a、b、c、d都完成执行？, 跟我上面的需求大同小异.</p>

<p>  所以在这儿,我把我工作中曾经用到过的一些方法做一个小的总结,有遗漏的或者错误的地方,请大家留意指正,非常感谢哈!!!</p>

<p>  特别注意:所有的代码都基于JINGDONG这道面试题, 不过我只打印了A和B而已..</p></li>
</ul>


<h2>四.实战应用</h2>

<p>我们公司App前段时间刚好有一个功能需求，就是关于发动态的时候图片上传的需求。以前一般来说的话，我们是讲所有图片打包一起发给服务器，但是这依稀不一样的是，必须每一张每一张的传，具体为什么老大说了一各位自己体会。</p>

<p>需求是：</p>

<ul>
<li>1：每次上传图片的时候必须一张一张的传。</li>
<li>2：上传完一张之后服务器返回给我们一个url，把他存起来</li>
<li>3：全部传完之后再把所有存起来的url一起通过json格式发送给服务器</li>
</ul>


<p>这里试了各种方法，问了各种大牛都没找到好的方法，只能说有些能解决，但是达不到非常满意的效果。这里总结一下常见的使用。</p>

<ol>
<li><p>RunLoop</p>

<p> 需要注意一点: 这儿用的是NSURLSession, 不是AFN, 所以block里面的线程是子线程,不是主线程, 不能直接使用CFRunLoopGetCurrent</p>

<pre><code> CFRunLoopGetCurrent : Returns the CFRunLoop object for the current thread.
 CFRunLoopGetMain: Returns the main CFRunLoop object.
</code></pre>

<p> NSURLSessionDataTask *task = [[NSURLSession sharedSession] dataTaskWithRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:@&ldquo;<a href="http://www.baidu.com">http://www.baidu.com</a>&rdquo;]] completionHandler:^(NSData * <em>Nullable data, NSURLResponse * </em>Nullable response, NSError * _Nullable error) {
         NSLog(@&ldquo;A&rdquo;);
         CFRunLoopStop(CFRunLoopGetMain());
     }] ;
     [task resume];
  CFRunLoopRun();
  NSLog(@&ldquo;B&rdquo;);</p></li>
<li><p>GCD的group</p>

<p> dispatch_group_notify就是需要等queue里面的子线程都执行完毕之后才会执行
 这种方法比较常见, 不多说</p>

<p> dispatch_group_t group = dispatch_group_create();
     dispatch_queue_t queue = dispatch_get_global_queue(0, 0);
     dispatch_group_async(group, queue, ^{
         NSLog(@&ldquo;A&rdquo;);
     });
     dispatch_group_notify(group, dispatch_get_main_queue(), ^{
         NSLog(@&ldquo;B&rdquo;);
     });</p></li>
<li><p>dispatch_barrier_async</p>

<p> barrier的中文意思就是障碍, 屏障
 一般使用dispatch_barrier_async, 会让barrier之前的线程执行完成之后才会执行barrier后面的操作</p>

<p>  dispatch_queue_t queue =  dispatch_queue_create(0, DISPATCH_QUEUE_CONCURRENT);
     dispatch_async(queue, ^{
         NSLog(@&ldquo;A&rdquo;);
     });
     dispatch_async(queue, ^{
         NSLog(@&ldquo;C&rdquo;);
     });
     dispatch_barrier_async(queue, ^{
         NSLog(@&ldquo;拿到了A的值&rdquo;);
     });</p>

<pre><code> dispatch_async(queue, ^{
     NSLog(@"D");
 });
 dispatch_async(queue, ^{
     NSLog(@"E");
 });dispatch_async(queue, ^{
     NSLog(@"F");
 });
</code></pre></li>
</ol>


<p>4.NSOperationQueue</p>

<p>   主要就是用到NSOperationQueue的一个对象方法-addDependency
   需要注意一点: waitUntilFinished如果是YES,必须等到queue中所有Operation执行完毕之后, 才会打印HAHA, 反之的话, HAHA的打印顺序是随机的了,就看哪个线程跑得快了&hellip;</p>

<pre><code>NSOperationQueue *queue = [[NSOperationQueue alloc] init];
    NSBlockOperation *p1 = [NSBlockOperation blockOperationWithBlock:^{
        NSLog(@"A");
    }];
    NSBlockOperation *p2 = [NSBlockOperation blockOperationWithBlock:^{
        NSLog(@"B");
    }];
    NSBlockOperation *p3 = [NSBlockOperation blockOperationWithBlock:^{
        NSLog(@"C");
    }];
    [p3 addDependency:p1];
    [p3 addDependency:p2];
    // waitUntilFinished是否阻塞当前线程
    [queue addOperations:@[p1,p2,p3] waitUntilFinished:NO];

    // 如果是NO,那么这行打印就是随机的, 反之就是等A,B,C都打印完之后才执行
    NSLog(@"HAHA");
</code></pre>

<ol>
<li><p>使用AFN中的batchOfRequestOperations</p>

<p> 这个和GCD一样, 我工作中比较常用的一种方法
 batchOfRequestOperations方法其实是AFHTTPRequestOperation的父类AFURLConnectionOperation的一个方法.
 这儿的waitUntilFinished同4. NSOperationQueue
 progressBlock一般用在进度计算中, 比如执行了多少百分比, 可以自定义一些炫酷动画</p>

<pre><code> AFHTTPRequestOperation *queue = [[AFHTTPRequestOperation alloc] initWithRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:@"http://www.baidu.com"]]];
     [queue setCompletionBlockWithSuccess:^(AFHTTPRequestOperation *operation, id responseObject) {
         NSLog(@"A");
     } failure:^(AFHTTPRequestOperation *operation, NSError *error) {
         NSLog(@"A");
     }];
     [queue resume];

 AFHTTPRequestOperation *queue2 = [[AFHTTPRequestOperation alloc] initWithRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:@"http://www.baidu.com"]]];
 [queue2 setCompletionBlockWithSuccess:^(AFHTTPRequestOperation *operation, id responseObject) {
     NSLog(@"B");
 } failure:^(AFHTTPRequestOperation *operation, NSError *error) {
     NSLog(@"B");
 }];
 [queue2 resume];

 NSArray *operations = [AFHTTPRequestOperation batchOfRequestOperations:@[queue, queue2] progressBlock:^(NSUInteger numberOfFinishedOperations, NSUInteger totalNumberOfOperations) {
     NSLog(@"%ld/%ld", numberOfFinishedOperations, totalNumberOfOperations);
 } completionBlock:^(NSArray *operations) {
     NSLog(@"C");
 }];

 [[NSOperationQueue mainQueue] addOperations:operations waitUntilFinished:NO];
</code></pre></li>
</ol>


<p>6.其他</p>

<pre><code>老早以前, 我一般是在一个异步请求中的completionBlock或者successBlock中拿到需要的值, 为空判断后,直接在block里面再写一个异步线程...其实这样的写法可能很多人都用过,但是代码的阅读性太弱了,花括号太多,看的眼花缭乱的...
其实还可以设置flag进行判断等等方法...
暂时就想到这么多, 还有别的方案的话, 欢迎留言哈,大家共同学习!!!
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[修行篇-数据结构常见操作与总结]]></title>
    <link href="http://al1020119.github.io/blog/2016/08/28/xiu-xing-pian-shu-ju-jie-gou-chang-jian-cao-zuo-yu-zong-jie/"/>
    <updated>2016-08-28T12:33:11+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/08/28/xiu-xing-pian-shu-ju-jie-gou-chang-jian-cao-zuo-yu-zong-jie</id>
    <content type="html"><![CDATA[<h1>一、栈</h1>

<p>栈是只能在一端进行插入和删除的线性表。
（别看只是个定义，非常重要，已经道出了运算方法：只能在一端插入和删除。)</p>

<blockquote><p>栈的特征：后进先出，先进后出。</p></blockquote>

<p>插入和删除元素的一端称为栈顶。（说明了我们在栈顶操作）
另一端称为栈底。
插入元素和删除元素的操作称为入栈和出栈。</p>

<!--more-->


<h3>1.顺序栈</h3>

<p>结构：(top总是指向数组最后的元素，比如data[n]，而不是前面)</p>

<pre><code>#define MAXSIZE 100
typedef struct
{
    elementtype data[MAXSIZE];
    int top;
} seqstack;
</code></pre>

<p>初始化栈：</p>

<pre><code>void init_stack(seqstack *S)
{
    S-&gt;top = -1;    //一个元素也没有，注意因为TOP是下标而不是元素个数，用-1
}
</code></pre>

<p>判断栈是否为空：</p>

<pre><code>int stack_empty(seqstack *S)
{
    if (S-&gt;top == -1)
        return 1;
    else
        return 0;
}
</code></pre>

<p>取栈顶元素：</p>

<pre><code>elementtype stack_top(seqstack *S)
{
    if (stack_empty(S))
        error("栈为空！");
    else
        return S-&gt;data[S-&gt;top];
}
</code></pre>

<p>入栈：</p>

<pre><code>void push_stack(seqstack *S, elementtype x)
{
    if (S-&gt;top == MAXSIZE -1)
        error("溢出！");
    else
        S-&gt;data[++S-&gt;top] = x;    //注意-&gt;运算符的优先级是最高的
}
</code></pre>

<p>出栈：</p>

<pre><code>elementtype pop_stack(seqstack *S)
{
    if (stack_empty(S))
        error("栈为空！");
    else
        return S-&gt;data[S-&gt;top--];
}
</code></pre>

<p>判断栈是否为满：</p>

<pre><code>int stack_full(seqstack *S)
{
    if (S-&gt;top == MAXSIZE -1)
        return 1;
    else
        return 0;
}
</code></pre>

<p>总体来说，顺序栈很简单，出的时候取最后的元素，进的时候一样进在尾部。</p>

<h3>2.链栈</h3>

<p>栈的链式存储结构称为链栈。
其插入和删除操作仅限制在表头位置上进行。
由于只能在链表头部进行操作，故链栈没有必要象单链表那样添加头结点。栈顶指针就是链表的头指针。
结构：</p>

<pre><code>typedef struct node    //和一般链表的结构一样。
{
    elementtype data;
    struct node *next;
} linkstack; 
linkstack *top;
当top=NULL时，链栈为空栈。
</code></pre>

<p>入栈：</p>

<pre><code>void push_stack(linkstack *top, elementtype x)
{
    linkstack *P = (linkstack *)malloc(sizeof(linkstack));
    P-&gt;data = x;
    P-&gt;next = top-&gt;next;
    top = P;
}
</code></pre>

<p>出栈：</p>

<pre><code>elementype pop_stack(linkstack *top)
{
    elementtype x;
    linkstack *P;
    if (top == NULL)
        error("栈为空！");
    else
    {
        x = top-&gt;data;
        P = top;
        top = top-&gt;next;
        free(P);
        return x;
    }
}
</code></pre>

<h1>二、队列</h1>

<p>队列是只能在一端插入，另一端删除的线性表。
特征是：先进先出，后进后出。</p>

<h1>1.顺序队列</h1>

<p>注意顺序队列多是循环队列，这里要注意几点：</p>

<ul>
<li>(1)front是队头的前一个位置。</li>
<li>(2)尾部入队，头部出队。</li>
<li><p>(3)由于循环，任何的位置移动计算之后要取余：P = (P + 1) % MAXSIZE 。
结构：</p>

<p>  #define MAXSIZE 100
  typedef struct
  {
      elementtype data[MAXSIZE];
      int front;    //头序号（注意是队头的前一个位置）
      int rear;    //尾序号（直接指向尾元素）
  } seqqueue;</p></li>
</ul>


<p>初始化队列：</p>

<pre><code>void init_queue(seqqueue *Q)
{
    Q-&gt;front = 0;
    Q-&gt;rear = 0;
}
</code></pre>

<p>还有一种写法：</p>

<pre><code>void init_queue(seqqueue *Q)
{
    Q-&gt;front = MAXSIZE - 1;
    Q-&gt;rear = MAXSIZE - 1;
}
</code></pre>

<p>两种方法的区别是第一种插入第一个元素是data[1]，而第二种是data[0]。
判断队列是否为空：</p>

<pre><code>int queue_empty(seqqueue *Q)
{
    if (Q-&gt;front == Q-&gt;rear)
        return 1;
    else
        return -1;
}
</code></pre>

<p>判断队列是否为满：</p>

<pre><code>int queue_full(seqqueue *Q)
{
    if ((Q-&gt;rear + 1) % MAXSIZE == Q-&gt;front)
        return 1;
    else
        return 0;
}
</code></pre>

<p>取队头元素：</p>

<pre><code>elementtype queue_front(seqqueue *Q)
{
    if (queue_empty(Q))
        error("队列为空！");
    else
        return Q-&gt;data[(Q-&gt;front + 1) % MAXSIZE];
}
</code></pre>

<p>入队：</p>

<pre><code>void Enqueue(seqqueue *Q, elementtype x)
{
    if (queue_full(Q))
        error("队列满！");
    else
    {
        Q-&gt;rear = (Q-&gt;rear + 1) % MAXSIZE;    //千万不能直接用Q-&gt;rear++，在循环队列要特别注意
        Q-&gt;data[Q-&gt;rear] = x;
    }
}
</code></pre>

<p>出队：</p>

<pre><code>elementtype Outqueue(seqqueue *Q)
{
    if (queue_empty(Q))
        error("队列为空！");
    else
    {
        Q-&gt;front = (Q-&gt;front + 1) % MAXSIZE;
        return Q-&gt;data[Q-&gt;front];
    }
}
</code></pre>

<h3>2.链队列</h3>

<p>出队时，删除表头操作，入队时，在表尾添加结点。（也就是头部出，尾部进）
使用带头结点的单链表形式。（注意链栈是不带头结点的）
结构：</p>

<pre><code>typedef struct mynode
{
    elementtype data;
    mynode *next;
} node;    //就是单链表
typedef struct
{
    node *front;
    node *rear;
} linkqueue;
</code></pre>

<p>初始化队列：</p>

<pre><code>void init_queue(linkqueue *Q)
{
    Q-&gt;front = (node *)malloc(sizeof(node));    //生成头结点（注意是NODE类型，Q结构是已有的一个结构，这里有点特殊，仔细体会）
    Q-&gt;rear = Q-&gt;front;
    Q-&gt;front = NULL;
}
</code></pre>

<p>判断队列是否为空：</p>

<pre><code>int queue_empty(linkqueue *Q)
{
    if (Q-&gt;front == Q-&gt;rear)
        return 1;
    else
        return 0;
}
</code></pre>

<p>取队头元素：</p>

<pre><code>elementtype queue_front(linkqueue *Q)
{
    if (queue_empty(Q))
        error("队列为空！");
    else
        return Q-&gt;front-&gt;next-&gt;data;
}
</code></pre>

<p>入队：</p>

<pre><code>void Enqueue(linkqueue *Q, elementtype x)
{
    node *P = (node *)malloc(sizeof(node));
    P-&gt;data = x;
    P-&gt;next = NULL;
    Q-&gt;rear-&gt;next = P;
    Q-&gt;rear = P;
}
</code></pre>

<p>出队：</p>

<pre><code>elementtype Outqueue(linkqueue *Q)
{
    node *P;
    elmenttype x;
    if (queue_empty(Q))
        error("队列为空！");
    else
    {
        P = Q-&gt;front-&gt;next;
        Q-&gt;front-&gt;next = P-&gt;next;
        x = P-&gt;data;
        free(P);
    }
    if (Q-&gt;front-&gt;next == NULL)    //只剩一个结点删除后队列为空时的特殊情况，一定要注意处理
        Q-&gt;rear = Q-&gt;front;
    return x;
}
</code></pre>

<h1>数组</h1>

<p>主要是稀疏矩阵的压缩存储：
当数组中非零元素非常少时，称之为稀疏矩阵。
存储特别如下：</p>

<ul>
<li>(1)对稀疏矩阵压缩存储时，除了存储非零元素的值v以外，还要存储其行列号i和j，故每个元素对应一个三元组(i, j, v)。将这些元素的三元组组织起来构成三元组表。</li>
<li>(2)需要在三元组表中增设元素个数、行列数，以唯一确定一个稀疏矩阵。</li>
</ul>


<p>结构如下：</p>

<pre><code>#define MAXSIZE 100
typedef struct    //三元组结构
{
    int i, j;
    elementtype v;
} tuple;
typedef struct
{
    int mu, nu, tu;    //行数、列数、非0元素个数
    tuple data[MAXSIZE];
} spmatrix;
</code></pre>

<h1>树</h1>

<h3>一、树</h3>

<p>树中的每个结点最多只有一个前驱（父辈），但可能有多个后继（后代）。
一个结点的度是指该结点的孩子数目。
若一个结点的度为0，称为叶子结点或终结点，否则称为分支结点或非终结点。
一棵树的度是树中最大的结点的度。
某个结点的子树的根称为其孩子结点，而该结点为其孩子结点的双亲结点或父结点。
同一个结点的孩子互相称为兄弟结点。
根的层次为1，其余结点的层次为父结点的层次数加1，而最大的层次数称为树的高度或深度。
如果树中各兄弟结点之间的排列次序是无关的，则称之为有序树，否则称为无序树。
称多棵树为森林。</p>

<h3>二叉树</h3>

<p>二叉树和树一样，都可以为空树。
注意二叉树每个结点的孩子都有左右之分，每个结点都有左右两个子树，这与树结构明显不同。
二叉树和树本质上是完全不同的两种结构。
 定义：满二叉树是指每层都有最大数目结点的二叉树，即高度为k的满二叉树中有2k-1个结点。而完全二叉树则是指在满二叉树的最下层从右到左连续地删除若干个结点所得到的二叉树。</p>

<p>二叉树的性质：</p>

<ul>
<li>1.在二叉树的第i层上的结点个数&lt;=2i-1(i>0)</li>
<li>2.深度（高度）为k的二叉树的结点个数&lt;=2k-1</li>
<li>3.对任一棵非空的二叉树，如果其叶子数为n0, 度为2的结点数为n2, 则有下面的关系式成立：n0=n2+1
(这个性质很重要。主要是有个概念：除去根结点，每个结点都与一个它上面的分支一一对应，也就是说，结点数＝分支数＋1，所以有：n-1=n1+2*n2)</li>
<li>4.有n个结点的完全二叉树(n>0)的深度为[log2n]+1([]为取整)</li>
<li>5.在编号的完全二叉树中，各结点的编号之间的关系为：
编号为i的结点如果存在左孩子，则其编号为2i，如果存在右孩子，则其编号为2i+1，如果存在父结点，则其编号为[i/2]。</li>
</ul>


<p>二叉树的存储结构：
1.顺序存储结构：
按完全二叉树的编号次序进行，即编号为i的结点存储在数组中下标为i的元素中。
缺点：若二叉树不是完全二叉树，则为了保持结点之间的关系，不得不空出许多元素来，这就造成了空间的浪费。</p>

<p>2.二叉链表存储结构：</p>

<pre><code>typedef struct node
{
    datatype data;
    struct node *lchild, *rchild;
} bitree;
</code></pre>

<h3>二叉树的遍历：</h3>

<p>所谓遍历二叉树是指按某种次序访问二叉树中每个结点一次且仅一次。
根据访问根结点的次序，可以分为先序遍历，中序遍历，后序遍历。
先序遍历可描述为：
若二叉树T不为空：</p>

<ul>
<li>(1)访问T的根结点；</li>
<li>(2)先序遍历T的左子树；</li>
<li><p>(3)先序遍历T的右子树。
遍历的算法非常简单，只写出先序遍历算法：</p>

<p>  void preorder(bitree *T)
  {
      if (T != NULL)
      {
          visit(T);    //一般用的最多的就是输出
          preorder(T->lchild);
          preorder(T->rchild);
      }
  }</p></li>
</ul>


<h3>线索二叉树</h3>

<p>线索二叉树主要是为了求解在某种次序下的前驱或后继结点。
将二叉树各结点中的空的左孩子指针域改为指向其前驱，空的右孩子指针域改为指向其后继。称这种新的指针（前驱或后继）为线索，所得到的二叉树被称为线索二叉树，将二叉树转变成线索二叉树的过程称为线索化。
同时，为了区分到底指针是指向前驱（后继）还是孩子，要加入两个标志来判断。
结构：</p>

<pre><code>typedef struct node
{
    int ltag, rtag;    //0为孩子，1为前驱或后继
    datatype data;
    struct node *lchild, *rchild;
} ordertree;
</code></pre>

<p>先序后继的求解：</p>

<pre><code>ordertree *presuc(ordertree *P)
{
    if (P-&gt;ltag == 0)
        return P-&gt;lchild;
    else
        return P-&gt;rchild;
}
</code></pre>

<p>中序后继：</p>

<pre><code>ordertree *insuc(ordertree *P)
{
    ordertree *q = P-&gt;rchild;
    if (P-&gt;rtag == 1)
        return q;
    else
    {
        while (q-&gt;ltag == 0)
            q = q-&gt;lchild;
        return q;
    }
}
</code></pre>

<p>中序先驱：</p>

<pre><code>ordertree *infore(ordertree *P)
{
    ordertree *q = P-&gt;lchild;
    if (P-&gt;ltag == 1)
        return q;
    else
    {
        while (q-&gt;rtag == 0)
            q = q-&gt;rchild;
        return q;
    }
}
</code></pre>

<p>后序先驱：</p>

<pre><code>ordertree *postfore(ordertree *P)
{
    if (P-&gt;rtag == 0)
        return P-&gt;rchild;
    else
        return P-&gt;lchild;
}
</code></pre>

<h3>树和森林</h3>

<h5>1.树的存储结构：</h5>

<p>(1)双亲表示法</p>

<pre><code>struct tnode
{
    datatype data;
    int parent;
}
struct tnode treelist[MAXSIZE];    //整个树的存储数组说明
</code></pre>

<p>其中parent指示该结点父结点的下标，data存放结点的值。
优点：便于搜索相应结点的父结点和祖先结点。
缺点：若要搜索孩子结点或后代结点需要搜索整个表，浪费时间。</p>

<p>(2)孩子链表表示法
分别将每个结点的孩子结点连成一个链表，然后将各表头指针放在一个表中构成一个整体结构。</p>

<pre><code>typedef struct node    //链表中每个孩子结点的定义
{
    int data;
    struct node *next;
} listnode;
typedef struct    //数组元素的定义，每个数组元素都是一个单链表，单头元素不同
{
    datatype info;
    listnode *firstchild;
} arrnode;
arrnode tree[MAXSIZE];    //MAXSIZE为所有结点的个数
</code></pre>

<p>优缺点：与双亲表示法恰好相反。</p>

<p>(3)孩子－兄弟链表表示法（二叉链表表示法，二叉树表示法）
树中每个结点用一个链表结点来存储，每个链表结点中除了存放结点的值外，还有两个指针，一个用来指示该结点的第一个孩子，另一个用于指示该结点的下一个兄弟结点。</p>

<pre><code>typedef struct node
{
    datatype data;
    struct node *firstchild, *nextbrother;
} tnode;
</code></pre>

<h5>2.树（森林）与二叉树的转换</h5>

<p>树或森林的子树转换为二叉树的左子树，兄弟转化为右子树。</p>

<h5>3.树（森林）的遍历</h5>

<p>树的遍历可分为先序遍历和后序遍历。（注意没有中序，因为树有不只两个孩子）即结点是在其子树之前还是之后访问。
遍历树（森林）要转换为遍历其对应的二叉树：
先序遍历：（同二叉树的先序遍历）</p>

<pre><code>void preorder(tnode *T)
{
    if (T != NULL)
    {
        visit(T);
        preorder(T-&gt;firstchild);
        preorder(T-&gt;nextbrother);
    }
}
</code></pre>

<p>后序遍历：（同二叉树的中序遍历）</p>

<pre><code>void postorder(tnode *T)
{
    if (T != NULL)
    {
        postorder(T-&gt;firstchild);
        visit(T);
        postorder(T-&gt;nextbrother);
    }
}
</code></pre>

<h3>哈夫曼树</h3>

<p>哈夫曼树主要用来处理压缩算法。
一般的判断问题的流程就象是一棵二叉树，其中分支（判断）结点对应于二叉树的分支结点；而最后得出的结论对应于叶子结点；一个结论所需要的判断次数是从根结点到该叶子结点的分支线数（层次数-1）；每个结论成立的次数作为叶子结点的权值。
(这个权值可能比较少接触,但是其实它非常重要,因为我们平时设计的系统,判断的结果常常都是通过长年的实践会有一个出现机率分配,而不可能是平分的,比如考试,如果常常80-90分的比较多,也许就要换一种算法,当然这是后话,和考试无关了.)</p>

<p>哈夫曼算法步骤如下:</p>

<ul>
<li>(1)根据给定的n个权值,构成一排结点T,每个的值都是相应的权值.</li>
<li>(2)从T中选两棵权值最小的二叉树,作为左右子树构成一棵新的二叉树T',并且新二叉树的权值为左右子树权值之和.</li>
<li>(3)将新二叉树T'并入到T中,删除原来的两棵二叉树.</li>
<li>(4)重复2,3直到只剩一棵二叉树.这棵树就是哈夫曼树.</li>
</ul>


<p>哈夫曼树的带权路径长度WPL=∑wL
即所有叶子结点的 权值*比较次数(层次数-1) 之和.
而WPL也正好等于所有分支结点(不包括叶子结点)的值之和.</p>

<h1>图</h1>

<p>图中将每个对象用一个顶点表示，并常用一个序号来标识一个顶点。
其中弧表示单向关系，边表示双向关系，用离散数学中的术语来说，则分别表示为非对称关系和对称关系。
弧用&lt;A, B>表示（A为尾，B为头），边用(A, B)表示。</p>

<pre><code>一个图G由两部分内容构成，即顶点(vertex)集合(V)和边(或弧edge)的集合(E)，并用二元组(V, E)来表示，记做G = (V, E) 
</code></pre>

<ul>
<li>根据顶点间的关系是否有向而引入有向图和无向图。</li>
<li>给每条边或弧加上权值，这样的带权图称为网络。</li>
<li>若无向图中任意两点间都有一条边，则称此图G为无向完全图。(共有边数 n*(n-1)/2 )</li>
<li><p>若有向图中任意一个顶点到其余各点间均有一条弧，则称为有向完全图。(共有弧数 n*(n-1) )
若一个图G1是从G中选取部分顶点和部分边（或弧）组成，则称G1是G的子图。（注意，顶点和边必须都为子关系）</p></li>
<li><p>若无向图中两个顶点i, j之间存在一条边，则称i, j相邻接，并互为邻接点。
在有向图中，若存在弧&lt;Vi, Vj>，也做Vi, Vj相邻接，但为区别弧的头、尾顶点，可进一步称做Vi邻接到Vj，Vj邻接于Vi。</p></li>
</ul>


<p>与一个顶点相邻接的顶点数称为该顶点的度。
在有向图中，进入一个顶点的弧数称为该顶点的入度，从一个顶点发出的弧数为该顶点的出度，并将入度和出度之和作为该顶点的度。</p>

<p>一个顶点经过一定的可经路程到达另一个顶点，就为顶点之间的路径。</p>

<ul>
<li>若某路径所经过的顶点不重复，则称此路径为简单路径。</li>
<li>若某路径的首尾相同，则称此路径为回路（或称为环）。</li>
<li><p>若某回路的中间不重复，则称之为简单回路。</p></li>
<li><p>若无向图中任意两点之间均存在路径，则称G为连通图，否则不连通，就存在若干个连通分量。</p></li>
<li>若有向图中任意两点间可以互相到达，则称为强连通图。</li>
</ul>


<p>一个无向图，连通并且无回路，称这样的图为树。
若有向图中仅有一个顶点的入度为0，其余顶点的入度都为1，称此图为有向树，入度为0的顶点为根。</p>

<h3>图的存储结构：</h3>

<h5>1。邻接矩阵表示</h5>

<p>对n个顶点的图来说，其邻接矩阵为n*n阶的。
邻接矩阵的元素存放边（弧）的权值，对不存在的边（弧），则用0或∞表示。
定义格式如下：</p>

<pre><code>#define n 6    /* 图顶点数 */ 
#define e 8    /* 图的边（弧）数 */
typedef struct
{
    vextype vexs[n];    /* 顶点类型 */
    datatype arcs[n][n];    /* 权值类型 */
} graph; 
</code></pre>

<p>建立一个无向网络的算法：</p>

<pre><code>CreateGraph(graph *G) 
{ 
    int i, j, k; 
    float w; 
    for (i=0; i&lt;n; i++) 
        G-&gt;vexs[i] = getchar();    /* 读入顶点信息，创建表，这里用字符型 */ 
    for (i=0; i&lt;n; i++) 
        for (j=0; j&lt;n; j++) 
            G-&gt;arcs[i][j] = 0;    /* 邻接矩阵初始化 */ 
    for (k=0; k&lt;e; k++) 
    { 
        scanf("%d%d%f", &amp;i, &amp;j, &amp;w);    /* 读入边(vi, vj)上的权w(暂用float类型) */ 
        G-&gt;arcs[i][j] = w; 
        G-&gt;arcs[j][i] = w; 
    } 
}
</code></pre>

<h5>2.邻接表表示法</h5>

<p>将每个顶点的邻接点连成链表，并将各链表的表头指针合在一起（用数组或链表表示均可），其中每个头指针与该结点的信息合为一个整体结点。
如果将邻接表中各顶点的邻接表变为其前驱顶点即可，从而得到逆邻接表。
用邻接表存储网络时，需要将各条边（弧）的权值作为相应邻接结点中的一个字段。
结构：</p>

<pre><code>typedef struct node
{
    int adjvex;    /* 邻接点域 */
    struct node *next;    /* 链域 */
    datatype arc;    /* 权值 */
} edgenode;    /* 边表指针 */
typedef struct
{
    vextype vertex;    /* 顶点信息 */
    edgenode *link;    /* 边表头指针 */
} vexnode;    /* 顶点表结点 */
vexnode gnode[n];    /* 整个图的构成 */
 建立无向图的邻接表：
CreateAdjlist(gnode)
{
    int i, j, k;
    edgenode *s;
    for (i=0; i&lt;n; i++)    /* 读入顶点信息 */
    {
        gnode[i].vertex = getchar();
        gnode[i].link = NULL;    /* 边表指针初始化 */
    }
    for (k=0; k&lt;e; k++)    /* 建立边表 */
    {
        scanf("%d%d", &amp;i, &amp;j);    /* 读入边(vi,vj)的顶点序号 */
        s = malloc(sizeof(edgenode));    /* 生成邻接点序号为j的表结点 */
        s-&gt;adjvex = j;
        s-&gt;next = gnode[i].link;
        gnode[i].link = s;    /* 将*s插入顶点vi的边表头部(插到头部比尾部简单) */
        s = malloc(sizeof(edgenode));    /* 生成邻接点序号为i的边表结点*s */
        s-&gt;adjvex = i;
        s-&gt;next = gnode[j].link;
        gnode[j].link = s;    /* 将*s插入顶点vj的边表头部(最后四行由于是无向图，所以相互，两次) */
    }
}
</code></pre>

<h3>图的遍历算法及其应用</h3>

<h5>1.深度遍历</h5>

<ul>
<li>(1)访问V0</li>
<li>(2)依次从V0 的各个未被访问的邻接点出发深度遍历
（两句话说的非常清楚。是一种以深度为绝对优先的访问。）</li>
</ul>


<h5>2。深度优先搜索遍历算法</h5>

<p>由于实际算法比较复杂，这里算法依赖两个函数来求解（对于不同的存储结构有不同的写法）
firstadj(G, v)：返回图G中顶点v的第一个邻接点。若不存在，返回0。
nextadj(G, v, w)：返回图G中顶点v的邻接点中处于w之后的那个邻接点。若不存在，返回0。
depth first search:</p>

<pre><code>void dfs(graph G, int v)
{
    int w;
    visit(v);
    visited[v] = 1;
    w = firstadj(G, v)
    while (w != 0)
    {
        if (visited[w] == 0)
            dfs(w);
        w = nextadj(G, v, w);
    }
}
</code></pre>

<p>如果不是连通图，或者是有向图，那么访问一个v不可能遍历所有顶点。所以，需要再选择未被访问的顶点作为起点再调用dfs.</p>

<p>所以，深度遍历图的算法如下：</p>

<pre><code>void dfs_travel(graph G)
{
    int i;
    for (i=1; i&lt;=n; i++)
        visited[i] = 0;        //初始化各顶点的访问标志
    for (i=1; i&lt;=n; i++)
        if (visited[i] == 0)
            dfs(G, i);
}
</code></pre>

<h5>3.广度优先搜索遍历算法</h5>

<p>广度优先搜索遍历算法(bfs)是一种由近而远的层次遍历算法，从顶点V0出发的广度遍历bfs描述为：</p>

<ul>
<li>(1)访问V0（可作为访问的第一层）；</li>
<li>(2)假设最近一层的访问顶点依次为V1, V2, &hellip;, Vk，则依次访问他们的未被访问的邻接点。</li>
<li>(3)重复2，直到找不到未被访问的邻接点为止。</li>
</ul>


<p>算法</p>

<pre><code>void bfs(graph G, int V0)
{
    int w;
    int v;
    queue Q;
    init_queue(Q);
    visit(V0);
    visited[V0] = 1;
    Enqueue(Q, V0);
    while (!empty(Q))
    {
        v = Outqueue(Q);
        w = firstadj(G, v);
        while (w != 0)
        {
            if (visited[w] == 0)
            {
                visit(w);
                visited[w] = 1;
                Enqueue(Q, w);
            }
            w = nextadj(G, v, w);
        }
    }
}
</code></pre>

<p>广度遍历图的算法和深度一样：</p>

<pre><code>void bfs_travel(graph G)
{
    int i;
    for (i=1; i&lt;=n; i++)
        visited[i] = 0;
    for (i=1; i&lt;=n; i++)
        if (visited[i] = 0)
            bfs(G, i);
}
</code></pre>

<p>最小生成树：</p>

<pre><code>从图中选取若干条边，将所有顶点连接起来，并且所选取的这些边的权值之和最小。
</code></pre>

<p>这样所选取的边构成了一棵树，称这样的树为生成树，由于权值最小，称为最小生成树。</p>

<h3>构造最小生成树有两种方法：</h3>

<h6>1.Prim算法：</h6>

<pre><code>首先将所指定的起点作为已选顶点，然后反复在满足如下条件的边中选择一条最小边，直到所有顶点成为已选顶点为止（选择n-1条边）：一端已选，另一端未选。
</code></pre>

<p>(简单的说，就是先任选一点，然后每次选择一条最小权值的边，而且只连接到一个已选顶点)</p>

<h6>2.Kruskal算法：</h6>

<pre><code>反复在满足如下条件的边中选出一条最小的，和已选边不够成回路。
(条件就是不够成回路就OK，反复选最小边，知道所有顶点都有连接）
</code></pre>

<p>最短路径：
一般即是要一个顶点到其余各个顶点的最短路径。（比如隔很远的顶点，要绕哪几条边走）
求解方法：</p>

<pre><code>首先，我们要画一个表，每个顶点有path和dist两个值，分别用来存储到各点的最短路径（比如(1,5,6)，就是1-5-6这个路径）和相应的长度（到该点的权值之和）。
</code></pre>

<ul>
<li>(1)对V以外的各顶点，若两点间的邻接路径存在，则将其作为最短路径和最短长度存到path[v]和dist[v]中。(实际上也就是最开始对顶点的直接后继进行处理）</li>
<li>(2)从未解顶点中选择一个dist值最小的顶点v，则当前的path[v]和dist[v]就是顶点v的最终解（从而使v成为已解顶点）。</li>
<li>(3)如果v的直接后继经过v会更近一些，则修改v的直接后继的path和dist值。</li>
</ul>


<p>(上面的确是很难懂，只能通过例子自己慢慢熟悉。）</p>

<h1>查找</h1>

<blockquote><p>在软件设计中，通常是将待查找的数据元素集以某种表的形式给出，从而构成一种新的数据结构－－查找表。
表包括一些“元素”，“字段”等等概念。</p></blockquote>

<p>在一个数据表中，若某字段的值可以标识一个数据元素，则称之为关键字（或键）。
若此关键字的每个值均可以唯一标识一个元素，则称之为主关键字，否则，若该关键字可以标识若干个元素，则称之为次关键字。</p>

<p>查找算法的时间性能一般以查找次数来衡量。所谓查找长度是指查找一个元素所进行的关键字的比较次数。常以平均查找次数、最大查找次数来衡量查找算法的性能。</p>

<h5>一、简单顺序查找</h5>

<pre><code>int seq_seach(elementtype A[], int n, keytype x)
{
    int i;
    A[0].key = x;        //设定监视哨
    for (i=n; A[i].key!=x; i--);
    return i;
}
</code></pre>

<p>监视哨是一个小技巧，查找失败时，这里设定的数据是A[1]-A[n]，肯定可以在A[0]中找到该元素，并返回0表示查找失败。如果不设定监视哨，则在每次循环中要判断下标是否越界：for (i=1; i!=n&amp;&amp;A[i].key!=x;i&ndash;); 可以节省一半的时间。</p>

<h5>二、有序表的二分查找</h5>

<pre><code>int bin_search(elementtype A[], int n, keytype x)
{
    int mid, low, high;
    low = 0;
    high = n - 1;
    while (low &lt;= high)
    {
        mid = (low + high) / 2;
        if (x == A[mid].key)
            return mid;
        else if (x &lt; A[mid].key)
            high = mid - 1;
        else
            low = mid + 1;
    }
    return -1;
}
</code></pre>

<p>也可以使用递归算法：</p>

<pre><code>int bin_search(elementtype A[], int low, int high, keytype x)
{
    int mid;
    if (low &lt; high)
        return -1;
    else
    {
        mid = (low + high) / 2;
        if (x == A[mid].key)
            return mid;
        else if (x &lt; A[mid],key)
            return bin_search(A, low, mid - 1, x);
        else
            return bin_search(A, mid - 1, high, x);
    }
}
</code></pre>

<h1>排序</h1>

<ul>
<li>增排序和减排序：如果排序的结果是按关键字从小到大的次序排列的，就是增排序，否则就是减排序。</li>
<li>内部排序和外部排序：如果在排序过程中，数据表中所有数据均在内存中进行，则这类排序为内部排序，否则就是外部排序。</li>
<li>稳定排序和不稳定排序：在排序过程中，如果关键字相同的两个元素的相对次序不变，则称为稳定排序，否则是不稳定排序。</li>
</ul>


<p>在分析算法的时间性能时，主要以算法中用的最多的基本操作的执行次数（或者其数量级）来衡量，这些操作主要是比较、移动和交换元素。有时，可能要用这些次数的平均数来表示。</p>

<h3>一、插入排序</h3>

<p>基本思想：</p>

<blockquote><p>把整个待排序子表看作是左右两部分，其中左边为有序区，右边为无序区，整个排序过程就是把右边无序区中的元素逐个插入到左边的有序区中，以构成新的有序区。
实际中，开始排序时把第一个元素A[0]（或A[1]）看作左边的有序区，然后把剩下的2～N个元素依次插入到有序表中。</p></blockquote>

<pre><code>void insert_sort(elementtype A[n+1])
{
    int i;
    for (i=2; i&lt;=n; i++)
    {
        A[0] = A[i];        //设置监视哨，这个数组同样是从1开始，A[0]就设为监视哨
        j = i - 1;
        while (A[j].key &gt; A[0].key)
        {
            A[j + 1] = A[j];
            j--;
        }
        A[j + 1] = A[0];
    }
}
</code></pre>

<p>明白这种方法的简单原理：
a1 a2 a3 &hellip; a(i-1) ai &hellip;
先将ai临时保存起来，然后把a(i-1)向前只要是比ai大的向后移，再把ai填进去即可。</p>

<h3>二、快速排序</h3>

<p>速度最快的办法！一定要掌握，考试重点。</p>

<p>基本思想：</p>

<blockquote><p>首先，选定一个元素作为中间元素，然后将表中所有元素与该中间元素相比较，将表中比中间元素小的元素调到表的前面，将比中间元素大的元素调到后面，再将中间数放在这两部分之间作为分界点，这样便得到一个划分；然后再对左右两部分分别进行快速排序，如此反复，直到每个子表仅有一个元素或空表为止。
中间数一般选择部分的第一个元素。</p></blockquote>

<pre><code>int partition(elementtype A[n], int s, int t)    //s,t是要排序元素的起点和终点,并返回最后中间元素位置
{
    elementtype x = A[s];    //保存中间元素到临时变量x,以腾出空位
    int i = s;                        //置两端搜索位置的初值
    int j = t;
    while (i != j)        //两端位置重和再停止
    {
        while (i &lt; j &amp;&amp; A[j].key &gt; x.key) j--;    //从后面搜索“小”的元素
        if (i &lt; j)        //如果找到，就调到前面的空位中
        {
            A[i] = A[j];
            i++;
        }
        while (i &lt; j &amp;&amp; A[i].key &lt; x.key) i++;    //从前面搜索“大”的元素
        if (i &lt; j)        //如果找到，调到后面的空位中
        {
            A[j] = A[i];
            j--;
        }
    }
    A[i] = x;        //将中间数移到最终位置上
    return i;
}
</code></pre>

<p>整个算法：</p>

<pre><code>void quick_sort(elementtype A[n], int s, int t)    //对数组中下标从s到t的部分进行快速排序，如果是整个表就是0, n-1
{
    int i;
    if (s &lt; t)    //表中至少有两个元素时
    {
        i = partition(A, s, t);    //划分排序一次
        quick_sort(A, i + 1, t);    //对后面部分快速排序
        quick_sort(A, s, i - 1);    //对前面部分快速排序
    }
}
</code></pre>

<h3>三、选择排序：</h3>

<p>在待排序子表中完整地比较一遍以确定最大（小）元素，并将该元素放在子表的最前（后）面。
【注：可能发觉和冒泡法比较类似，但注意选择法是全部比较一遍，找到最小元素的下标，再进行一次交换，而冒泡则是进行多次交换】</p>

<pre><code>void select_sort(elementtype A[n])
{
   int min, i, j;
   elementtype temp;
   for (i=0; i&lt;n-1; i++)
   {
      min = i;
      for (j=i+1; j&lt;n; j++)
         if (A[min].key &gt; A[j].key) min = j;
      if (min != i)
      {
         temp = A[i];
         A[i] = A[min];
         A[min] = temp;
      }
   }
}
</code></pre>

<h3>四、归并排序</h3>

<p>所谓归并是指将两个或两个以上的有序表合并成一个新的有序表。
归并算法：</p>

<p>假设两个序列A[m]和B[n]为非降序列（即存在相同元素的升序列），现要把他们合并为一个非降序列C[m+n]。</p>

<pre><code>void merge(elementtype A[], elementtype B[], elementtype C[], int m, int n)
{
    int ia = 0, ib = 0, ic = 0;
    while (ia &lt; m &amp;&amp; ib &lt; n)
        if (A[ia] &lt;= B[ib])
            C[ic++] = A[ia++];
        else
            C[ic++] = B[ib++];
    while (ia &lt; m)
        C[ic++] = A[ia++];
    while (ib &lt; n)
        C[ic++] = B[ib++];
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[修行篇-算法之精华-算法&amp;冒泡]]></title>
    <link href="http://al1020119.github.io/blog/2016/08/25/xiu-xing-pian-suan-fa-zhi-jing-hua-suan-fa-and-mou-pao/"/>
    <updated>2016-08-25T12:32:56+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/08/25/xiu-xing-pian-suan-fa-zhi-jing-hua-suan-fa-and-mou-pao</id>
    <content type="html"><![CDATA[<ul>
<li><p>冒泡排序（交换）</p>

<ul>
<li>改进</li>
</ul>
</li>
<li><p>快速排序（交换）</p>

<ul>
<li>改进</li>
</ul>
</li>
</ul>


<h2>交换排序—冒泡排序（Bubble Sort）</h2>

<p>基本思想：</p>

<blockquote><p>在要排序的一组数中，对当前还未排好序的范围内的全部数，自上而下对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。即：每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。
算法的实现：</p></blockquote>

<pre><code>void bubbleSort(int a[], int n){  
    for(int i =0 ; i&lt; n-1; ++i) {  
        for(int j = 0; j &lt; n-i-1; ++j) {  
            if(a[j] &gt; a[j+1])  
            {  
                int tmp = a[j] ; a[j] = a[j+1] ;  a[j+1] = tmp;  
            }  
        }  
    }  
}  
</code></pre>

<h4>改进</h4>

<!--more-->


<blockquote><p>对冒泡排序常见的改进方法是加入一标志性变量exchange，用于标志某一趟排序过程中是否有数据交换，如果进行某一趟排序时并没有进行数据交换，则说明数据已经按要求排列好，可立即结束排序，避免不必要的比较过程。本文再提供以下两种改进算法：</p></blockquote>

<p>1．设置一标志性变量pos,用于记录每趟排序中最后一次进行交换的位置。由于pos位置之后的记录均已交换到位,故在进行下一趟排序时只要扫描到pos位置即可。
改进后算法如下:</p>

<pre><code>void Bubble_1 ( int r[], int n) {  
    int i= n -1;  //初始时,最后位置保持不变  
    while ( i&gt; 0) {   
        int pos= 0; //每趟开始时,无记录交换  
        for (int j= 0; j&lt; i; j++)  
            if (r[j]&gt; r[j+1]) {  
                pos= j; //记录交换的位置   
                int tmp = r[j]; r[j]=r[j+1];r[j+1]=tmp;  
            }   
        i= pos; //为下一趟排序作准备  
     }   
}    
</code></pre>

<p>2．传统冒泡排序中每一趟排序操作只能找到一个最大值或最小值,我们考虑利用在每趟排序中进行正向和反向两遍冒泡的方法一次可以得到两个最终值(最大者和最小者) , 从而使排序趟数几乎减少了一半。
改进后的算法实现为:</p>

<pre><code>void Bubble_2 ( int r[], int n){  
    int low = 0;   
    int high= n -1; //设置变量的初始值  
    int tmp,j;  
    while (low &lt; high) {  
        for (j= low; j&lt; high; ++j) //正向冒泡,找到最大者  
            if (r[j]&gt; r[j+1]) {  
                tmp = r[j]; r[j]=r[j+1];r[j+1]=tmp;  
            }   
        --high;                 //修改high值, 前移一位  
        for ( j=high; j&gt;low; --j) //反向冒泡,找到最小者  
            if (r[j]&lt;r[j-1]) {  
                tmp = r[j]; r[j]=r[j-1];r[j-1]=tmp;  
            }  
        ++low;                  //修改low值,后移一位  
    }   
}   
</code></pre>

<h2>交换排序—快速排序（Quick Sort）</h2>

<p>基本思想：</p>

<ul>
<li><p>1）选择一个基准元素,通常选择第一个元素或者最后一个元素,</p></li>
<li><p>2）通过一趟排序讲待排序的记录分割成独立的两部分，其中一部分记录的元素值均比基准元素值小。另一部分记录的 元素值比基准值大。</p></li>
<li><p>3）此时基准元素在其排好序后的正确位置</p></li>
<li><p>4）然后分别对这两部分记录用同样的方法继续进行排序，直到整个序列有序。</p></li>
</ul>


<p>算法的实现：
 递归实现：</p>

<pre><code>void print(int a[], int n){  
    for(int j= 0; j&lt;n; j++){  
        cout&lt;&lt;a[j] &lt;&lt;"  ";  
    }  
    cout&lt;&lt;endl;  
}  

void swap(int *a, int *b)  
{  
    int tmp = *a;  
    *a = *b;  
    *b = tmp;  
}  
int partition(int a[], int low, int high)  
{  
    int privotKey = a[low];                             //基准元素  
    while(low &lt; high){                                   //从表的两端交替地向中间扫描  
        while(low &lt; high  &amp;&amp; a[high] &gt;= privotKey) --high;  //从high 所指位置向前搜索，至多到low+1 位置。将比基准元素小的交换到低端  
        swap(&amp;a[low], &amp;a[high]);  
        while(low &lt; high  &amp;&amp; a[low] &lt;= privotKey ) ++low;  
        swap(&amp;a[low], &amp;a[high]);  
    }  
    print(a,10);  
    return low;  
}  
void quickSort(int a[], int low, int high){  
    if(low &lt; high){  
        int privotLoc = partition(a,  low,  high);  //将表一分为二  
        quickSort(a,  low,  privotLoc -1);          //递归对低子表递归排序  
        quickSort(a,   privotLoc + 1, high);        //递归对高子表递归排序  
    }  
}  
int main(){  
    int a[10] = {3,1,5,7,2,4,9,6,10,8};  
    cout&lt;&lt;"初始值：";  
    print(a,10);  
    quickSort(a,0,9);  
    cout&lt;&lt;"结果：";  
    print(a,10);  

}  
</code></pre>

<p>分析：</p>

<blockquote><p>快速排序是通常被认为在同数量级（O(nlog2n)）的排序方法中平均性能最好的。但若初始序列按关键码有序或基本有序时，快排序反而蜕化为冒泡排序。为改进之，通常以“三者取中法”来选取基准记录，即将排序区间的两个端点与中点三个记录关键码居中的调整为支点记录。快速排序是一个不稳定的排序方法。
快速排序的改进</p></blockquote>

<h4>改进</h4>

<p>在本改进算法中,只对长度大于k的子序列递归调用快速排序,让原序列基本有序，然后再对整个基本有序序列用插入排序算法排序。实践证明，改进后的算法时间复杂度有所降低，且当k取值为 8 左右时,改进算法的性能最佳。算法思想如下：</p>

<pre><code>void print(int a[], int n){  
    for(int j= 0; j&lt;n; j++){  
        cout&lt;&lt;a[j] &lt;&lt;"  ";  
    }  
    cout&lt;&lt;endl;  
}  
void swap(int *a, int *b)  
{  
    int tmp = *a;  
    *a = *b;  
    *b = tmp;  
}  
int partition(int a[], int low, int high)  
{  
    int privotKey = a[low];                 //基准元素  
    while(low &lt; high){                   //从表的两端交替地向中间扫描  
        while(low &lt; high  &amp;&amp; a[high] &gt;= privotKey) --high; //从high 所指位置向前搜索，至多到low+1 位置。将比基准元素小的交换到低端  
        swap(&amp;a[low], &amp;a[high]);  
        while(low &lt; high  &amp;&amp; a[low] &lt;= privotKey ) ++low;  
        swap(&amp;a[low], &amp;a[high]);  
    }  
    print(a,10);  
    return low;  
}  
void qsort_improve(int r[ ],int low,int high, int k){  
    if( high -low &gt; k ) { //长度大于k时递归, k为指定的数  
        int pivot = partition(r, low, high); // 调用的Partition算法保持不变  
        qsort_improve(r, low, pivot - 1,k);  
        qsort_improve(r, pivot + 1, high,k);  
    }   
}   
void quickSort(int r[], int n, int k){  
    qsort_improve(r,0,n,k);//先调用改进算法Qsort使之基本有序  
    //再用插入排序对基本有序序列排序  
    for(int i=1; i&lt;=n;i ++){  
        int tmp = r[i];   
        int j=i-1;  
        while(tmp &lt; r[j]){  
            r[j+1]=r[j]; j=j-1;   
        }  
        r[j+1] = tmp;  
    }   

}   
int main(){  
    int a[10] = {3,1,5,7,2,4,9,6,10,8};  
    cout&lt;&lt;"初始值：";  
    print(a,10);  
    quickSort(a,9,4);  
    cout&lt;&lt;"结果：";  
    print(a,10);  

}  
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[修行篇-23种设计模式]]></title>
    <link href="http://al1020119.github.io/blog/2016/08/23/xiu-xing-pian-23chong-she-ji-mo-shi/"/>
    <updated>2016-08-23T12:32:39+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/08/23/xiu-xing-pian-23chong-she-ji-mo-shi</id>
    <content type="html"><![CDATA[<h2>设计模式</h2>

<p>总体来说设计模式分为三大类：</p>

<ul>
<li><p>创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</p></li>
<li><p>结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</p></li>
<li><p>行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p>

<ul>
<li>其实还有两类：并发型模式和线程池模式。</li>
</ul>
</li>
</ul>


<!--more-->


<h2>创建型模式</h2>

<h3>工厂方法模式</h3>

<p>简单工厂模式的最大优点在于工厂类中包含了必要的逻辑判断，根据客户端输入的选择条件动态的实例化相关的类，对于客户端来说，去除了与具体产品的依赖。</p>

<p>但是简单工厂方法违背了开放——封闭模式。</p>

<h6>1、思想</h6>

<pre><code>工厂方法模式：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。
</code></pre>

<h6>2、核心思想</h6>

<pre><code> 核心工厂类不再负责所有产品的创建，而是将具体创建的工作交给了子类去做，成为一个抽象工厂角色，仅仅负责具体工厂类必须实现的接口，而不接触哪一个产品类应当被实例化的细节。
</code></pre>

<h6>3、优缺点分析</h6>

<p>GOOD：修正了简单工厂模式中不遵守开放－封闭原则。工厂方法模式把选择判断移到了客户端去实现，如果想添加新功能就不用修改原来的类，直接修改客户端即可，从而保持了封装对象创建过程的优点。使得更换对象时，不需要做大的改动就可以实现，降低了客户程序与产品对象的耦合。</p>

<p>BAD：每增加一个产品，就需要增加一个产品工厂类，即增加了额外的开发量</p>

<h3>抽象工厂模式</h3>

<h6>一、思想</h6>

<pre><code> 定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory使一个类的实例化延迟到其子类。（四人团）

实际上： 工厂模式主要就是用于创建对象。新添加类时，不会影响以前的系统代码。
</code></pre>

<h6>二、基本思想</h6>

<p>   核心思想：是用一个工厂来根据输入的条件产生不同的类，然后根据不同类的virtual函数得到不同的结果。</p>

<pre><code> 客户类和工厂类分开，消费者任何时候需要某种产品类对象，只需要向工厂类（有静态成员函数接收）提交参数和请求即可。消费者无需修改（直接用所有产品共同的父类指针指向）就可以接纳和使用新产品类的对象。
</code></pre>

<h6>三、优缺点分析</h6>

<p>GOOD: 适用于不同情况创建不同的类时</p>

<p>BAD：  客户端必须要知道基类和工厂类，耦合性差，而且当产品修改时，工厂类也要做相应修改（如：如何创建及如何向客户端提供）</p>

<h3>单例模式</h3>

<h6>1、思想</h6>

<pre><code>保证一个类仅有一个实例，并提供一个访问它的全局访问点
</code></pre>

<h6>2、核心思想</h6>

<p>确保某个类只有一个实例（类的静态成员变量），而且自行实例化并向整个系统提供这个实例单例模式。</p>

<p>直接将类的构造方法改成私有的（所有类都有构造方法，不编码则系统默认生成空的构造方法，若有显示定义的构造方法，默认的构造方法就会失效），然后在一个public的实例化函数中调用私有构造函数，完成仅有的一次实例化。</p>

<h6>3、优缺点分析</h6>

<p>GOOD:单例模式只应在有真正的“单一实例”的需求时才可使用。</p>

<p>单例模式因为Singleton类封装它的唯一实例，这样它可以严格地控制客户怎样访问它以及何时访问它，简单的说就是对唯一实例的受控访问。</p>

<h3>建造者模式</h3>

<h6>1、思想</h6>

<pre><code>建造者模式：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示
</code></pre>

<h6>2、核心思想</h6>

<pre><code> 将产品的内部表象和产品的生成过程分割开来，从而使一个建造过程生成具有不同的内部表象的产品对象。建造模式使得产品内部表象可以独立的变化，客户不必知道产品内部组成的细节。
</code></pre>

<p>即用户就只需要指定需要建造的类型就可以得到产品，而具体的建造过程和细节就不需要知道了。</p>

<p>建造模式可以强制实行一种分步骤进行的建造过程。</p>

<h6>3、优缺点分析</h6>

<p>GOOD：使得建造代码与表示代码分离，由于建造者隐藏了该产品是如何组装的，所以若需要改变一个产品的内部表示，只需要再定义一个具体的建造者就可以了。</p>

<h6>适用于：</h6>

<p>（1）在当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时适用。</p>

<p>就是说：主要用于创建一些复杂的对象，这些对象内部的构建顺序通常是稳定的，但是对象内部的具体各个构建方法通常面临着复杂的变化。</p>

<p>（2）当构造过程必须允许被构造的对象有不同的表示时。</p>

<h3>原型模式</h3>

<h6>1、思想</h6>

<pre><code>原型模式：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。
</code></pre>

<h6>2、核心思想</h6>

<pre><code> 通过给出一个原型对象来指明所要创建的对象的类型，然后用复制这个原型对象的方法创建出更多同类型的对象。原型模式允许动态的增加或减少产品类，产品类不需要非得有任何事先确定的等级结构。
</code></pre>

<h6>3、优缺点分析</h6>

<p>GOOD：</p>

<p>从一个对象再创建另外一个可定制的对象，而无需知道任何创建的细节。并能提高创建的性能。 说白了就COPY技术，把一个对象完整的COPY出一份。</p>

<p>一般在初始化的信息不发生变化的情况下，克隆是最好的办法。这既隐藏了对象创建的细节，又对性能是大大的提高。
BAD：</p>

<p>缺点是每一个类都必须配备一个复制方法。
必须注意：</p>

<p>浅复制和深复制的问题：如果字段是基本数据类型的，则用拷贝构造函数即可进行逐位复制，但如果字段是指针或引用类型的，则复制就不仅仅要复制指针和引用本身，还需要对其所指的实际数据对象进行复制。</p>

<h2>结构型模式</h2>

<h3>适配器模式</h3>

<h6>1、思想</h6>

<pre><code>把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不兼容而无法一起工作的两个类能够一起工作。
</code></pre>

<h6>2、优缺点分析</h6>

<p>适用情况：当系统的数据和行为都正确，但接口不符时，我们应该考虑使用适配器，目的是使控制范围之外的一个原有对象与某个接口匹配。适配器模式主要应用于希望复用一些现存的类，但是接口又与复用环境要求不一致的情况。
装饰器模式</p>

<h3>装饰模式</h3>

<h6>1、思想</h6>

<pre><code>装饰模式：动态的给一个对象添加一些额外的职责（不重要的功能，只是偶然一次要执行）。就增加功能来说，Decorator模式比使用继承生成子类更为灵活。

 建造过程不稳定，需要把所需的功能按正确的顺序串联起来进行控制。
</code></pre>

<h6>2、优缺点分析</h6>

<p>GOOD:当你向旧的类中添加新代码时，一般是为了添加核心职责或主要行为。而当需要加入的仅仅是一些特定情况下才会执行的特定的功能时（简单点就是不是核心应用的功能），就会增加类的复杂度。</p>

<pre><code>装饰模式就是把要添加的附加功能分别放在单独的类中，并让这个类包含它要装饰的对象，

当需要执行时，客户端就可以有选择地、按顺序地使用装饰功能包装对象。
</code></pre>

<h3>代理模式</h3>

<h6>一、思想</h6>

<pre><code>代理模式：为其他对象提供一种代理以控制对这个对象的访问
</code></pre>

<h6>二、基本思想</h6>

<pre><code> 代理模式实际就是在访问对象时引入一定程度的间接性，因为这种间接性，可以附加多种用途。
</code></pre>

<h6>三、优缺点分析</h6>

<p>GOOD：（适用场合）</p>

<p>远程代理：也就是为一个对象在不同的地址空间提供局部代表，这样可以隐藏一个对象在不同地址空间的事实。</p>

<pre><code>              例如：客户端程序调用代理就可以解决远程访问的问题
</code></pre>

<p>虚拟代理：是根据需要创建开销很大的对象，通过代理来存放实例化需要很长时间的真实对象，从而达到性能的最优化（例如浏览器使用代理模式来优化下载）。</p>

<pre><code>              例如：打开大网页时，未马上打开的图片就是通过虚拟代理来替代了真实的图片，而代理存储了真实图片的路径和尺寸。
</code></pre>

<p>安全代理：用来控制真实对象的访问权限</p>

<p>智能引用：当调用真实对象时，代理处理另外一些事</p>

<h3>外观模式</h3>

<h6>1、思想</h6>

<pre><code>外观模式：为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。
</code></pre>

<h6>2、核心思想</h6>

<pre><code> 外部与一个子系统的通信必须通过一个统一的外观对象进行。外观模式提供一个高层次的接口，使得子系统更易于使用。每一个子系统只有一个外观类，而且此外观类只有一个实例，也就是还说它是一个单例模式。但整个系统可以有多个外观类。
</code></pre>

<h6>3、优缺点分析</h6>

<p>GOOD：</p>

<p>为子系统的一组接口提供一个一致的界面。使用户使用起来更加方便。</p>

<pre><code>完美体现了依赖倒转原则和迪米特原则
</code></pre>

<p>适用情况：</p>

<pre><code>分三个阶段：

1、首先，在设计初期阶段，应该有意识的将不同的两个层分离，即在层与层之间建立外观Facade

2、其次，在开发阶段，子系统往往因为不断的重构演化，而变得越来越复杂，增加外观Facade可以提供一个简单的接口，减少它们之间的依赖。

3、在维护一个遗留的大型系统时，可能这个系统已经非常难以维护和扩展了，就可以为新系统开发一个外观Facade类，来提供设计粗糙或高度复杂的遗留代码的比较清晰简单的接口，让新系统与Facade对象交互，Facade与遗留代码交互所有复杂的工作。
</code></pre>

<h3>桥接模式</h3>

<h6>1、合成聚合原则</h6>

<p>缘由：对象的继承关系是在编译时就定义好了，所以无法在运行时改变从父类继承的实现。子类的实现与它的父类有非常紧密的依赖关系，以至于父类实现中的任何变化必然会导致子类发生变化。当你需要复用子类时，如果继承下来的实现不适合解决新的问题，则父类必须重写或被其他更适合的类替换。这种依赖关系限制了灵活性并最终限制了复用性。</p>

<p>原则：</p>

<pre><code>合成/聚合原则(CARP)：尽量使用合成/聚合，尽量不要使用类继承
</code></pre>

<ul>
<li><p>聚合：一种弱的’拥有’关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分</p></li>
<li><p>合成：一种强的’拥有’关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样。</p></li>
</ul>


<h6>合成聚合的好处：</h6>

<p>优先使用对象的合成/聚合将有助于你保持每个类被封装，并被集中在单个任务上，这样类和类继承层次会保持较小规模，并且不太可能增长为不可控制的庞然大物。</p>

<h6>2、桥模式思想</h6>

<pre><code>桥接模式(Bridge)：将抽象部分与它的实现部分分离，使它们都可以独立地变化
</code></pre>

<p>抽象与实现分离：指的是抽象类和它的派生类用来实现自己的对象</p>

<h6>3、核心思想</h6>

<p>桥模式就是将抽象化与实现化脱耦，使得二者可以独立的变化，也就是说将他们之间的强关联变成弱关联，也就是指在一个软件系统的抽象化与实现化之间使用组合/聚合关系而不是继承关系，从而让二者独立的变化。</p>

<h6>4、优缺点分析</h6>

<p>GOOD：</p>

<pre><code>将抽象部分与实现部分分离，使它们可以独立变化。

这里说的意思不是让抽象基类与具体类分离，而是现实系统可能有多角度分类，每一种分类都有可能变化，那么把这种多角度分离出来让它们独立变化，减少它们之间的耦合性，即如果继承不能实现“开放－封闭原则”的话，就应该考虑用桥接模式 
</code></pre>

<h3>组合模式</h3>

<h6>1、思想</h6>

<pre><code>组合模式：将对象组合成树形结构以表示“部分——整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性
</code></pre>

<h6>2、优缺点分析</h6>

<p>GOOD：</p>

<pre><code>整体和部分可以被一致对待（如WORD中复制一个文字、一段文字、一篇文章都是一样的操作）

用户不用关心到底是处理一个叶结点还是处理一个组合组件，也就不用为定义组合而写一些选择判断语句，即用户可以一致的使用组合结构和单个对象。
</code></pre>

<h6>适用情况：</h6>

<p>当需求中是体现部分与整体层次的结构时，以及希望用户可以忽略组合对象与单个对象的不同，统一地使用组合结构中的所有对象时，就应该考虑用组合模式</p>

<h3>享元模式。</h3>

<h6>1、思想</h6>

<pre><code>享元模式：运用共享技术有效地支持大量细粒度的对象
</code></pre>

<h6>2、核心思想</h6>

<pre><code>  享元模式以共享的方式高效的支持大量的细粒度对象。享元模式能做到共享的关键是区分内蕴状态和外蕴状态。

 内蕴状态存储在享元内部，不会随环境的改变而有所不同。外蕴状态是随环境的改变而改变的。外蕴状态不能影响内蕴状态，它们是相互独立的。

  将可以共享的状态和不可以共享的状态从常规类中区分开来，将不可以共享的状态从类里剔除出去。

  客户端不可以直接创建被共享的对象，而应当使用一个工厂对象负责创建被共享的对象。享元模式大幅度的降低内存中对象的数量。
</code></pre>

<h6>3、优缺点分析</h6>

<p>GOOD：</p>

<pre><code>（1）运用共享技术有效地支持大量细粒度的对象（对于C++来说就是共用一个内存块啦，对象指针指向同一个地方）。

（2）如果一个应用程序使用了大量的对象，而这些对象造成了很大的存储开销就应该考虑使用。

（3）还有就是对象的大多数状态可以外部状态，如果删除对象的外部状态，那么可以用较少的共享对象取代多组对象，此时可以考虑使用享元。 
</code></pre>

<h2>行为型模式</h2>

<h3>策略模式</h3>

<h6>一、思想</h6>

<pre><code> 定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换，本模式使得算法可独立于使用它的客户而变化——四人团
</code></pre>

<h6>二、基本思想</h6>

<pre><code>定义算法家族，分别封装起来，让它们之间可以互相替换，让算法的变化，不会影响到使用算法的用户。
</code></pre>

<h6>三、优缺点分析</h6>

<p>GOOD:</p>

<p>（1）策略模式是一种定义一系列算法的方法，从概念上看，所有这些算法完成的都是相同的工作，只是实现不同。</p>

<pre><code>   所以使用策略模式，就可以以相同的方式调用所有的算法，减少了各种算法类与使用算法类之间的耦合。
</code></pre>

<p>（2）策略模式的Strategy类层次为Context定义了一系列的可供重用的算法或行为。继承有助于析取出这些算法中的公共功能</p>

<p>（3）简化了单元测试（因为每个算法都有自己的类，可以通过自己的接口单独测试）</p>

<p>BUG:客户端要做出判断使用哪个具体算法（可通过在context中与工厂模式的结合来消除这个问题，虽然当新增加需求时，还是要改context中的代码，但是任何需求的变更本身就是需要成本的）
四、适用情况</p>

<pre><code> 策略模式和简单工厂基本相同，但简单工厂模式只能解决对象创建问题，对于类中的成员以方法为主，而且算法经常变动的类，应使用策略模式。

 在实践中，策略模式实际上可以封装几乎任何类型的规则，只要在分析过程中听到需要不同时间应用不同的业务规则，就可以考虑使用策略模式处理这种变化的可能性。
</code></pre>

<h3>模板方法模式</h3>

<h6>1、思想</h6>

<pre><code>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。template method使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤
</code></pre>

<h6>2、核心思想</h6>

<pre><code> 模板方法模式准备一个抽象类，将部分逻辑以具体方法以及具体构造子类的形式实现，然后声明一些抽象方法来迫使子类剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。先制定一个顶级逻辑框架，而将逻辑的细节留给具体的子类去实现。

 当要完成在某一细节层次一致的一个过程或一系列步骤，但其个别步骤在更详细的层次上的实现可能不同时，通常考虑用模板方法来处理。也就是说：有时候，我们遇到由一系列步骤构成的过程需要执行。这个过程从高层次上看是相同的，但从底层看有些具体步骤实现又可能不同，这时候，就要考虑使用模板方法模式。
</code></pre>

<h6>3、优缺点分析</h6>

<p>GOOD：</p>

<pre><code>把不变的代码部分都转移到父类中，将可变的代码用virtual留到子类重写，从而提供了一个很好的代码复用平台。
</code></pre>

<p>即当不变的和可变的行为在方法的子类实现中混合在一起的时候，不变的行为就会在子类中重复出现。我们就可以通过模板方法模式把这些行为搬移到单一的地方，这样就帮助子类摆脱重复的不变行为的纠缠。</p>

<h3>观察者模式</h3>

<h6>1、思想</h6>

<pre><code>定义对象间的一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生改变时，会通知所有观察者对象，使它们能够自动更新自己。
</code></pre>

<h6>2、核心思想</h6>

<pre><code> 观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使他们能够自动更新自己。
</code></pre>

<h6>使用动机：</h6>

<p>　　将一个系统分割成一系列相互协作的类有一个很不好的副作用，那就是需要维护相关对象间的一致性。我们不希望为了维持一致性而使各类紧密耦合，这样会给维护、扩展和重用都带来不便。</p>

<h6>本模式适用情况：</h6>

<p>（1）当一个对象的改变需要同时改变其他对象的时候，而且它不知道具体有多少对象有待改变时，应该考虑使用观察者模式。</p>

<p>（2）当一个抽象模型有两个方面，其中一方面依赖于另一方面，这时用观察者模式可以将这两者封装在独立的对象中，使它们各自独立地改变和复用。
总结：</p>

<pre><code>观察者模式所做的工作其实就是解除耦合，让耦合的双方都依赖于抽象，而不是依赖于具体。从而使得各自的变化都不会影响另一边的变化。

本模式是依赖倒置原则的最佳体现！

设计原则：为了交互对象之间的松耦合设计而奋斗到底！
</code></pre>

<h6>3、优缺点分析</h6>

<p>GOOD：</p>

<pre><code>定义了一种一对多的关系，让多个观察对象（公司员工）同时监听一个主题对象（秘书），主题对象状态发生变化时，会通知所有的观察者，使它们能够更新自己。
</code></pre>

<p>BAD:</p>

<pre><code>尽管使用了“依赖倒置原则”，但是“抽象通知者”还是依赖于“抽象观察者”。而且每个具体观察者不一定是“更新”方法需要调用。

在.net中可通过事件委托方法，使得通知者和观察者之间根本就互相不知道。  
</code></pre>

<h3>迭代子模式</h3>

<h6>1、思想</h6>

<pre><code>迭代器模式：提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。
</code></pre>

<h6>2、核心思想</h6>

<h6>3、优缺点分析</h6>

<p>适用情况：</p>

<p>（1）当需要访问一个聚集对象，而且不管这些对象是什么都需要遍历的时候，就应该考虑使用迭代器模式</p>

<p>（2）当需要对聚集有多种方式遍历时，可以考虑使用迭代器模式</p>

<p>GOOD：</p>

<pre><code>提供一种方法顺序访问一个聚敛对象的各个元素，而又不暴露该对象的内部表示。

为遍历不同的聚集结构提供如开始，下一个，是否结束，当前一项等统一接口。 
</code></pre>

<h3>责任链模式</h3>

<h6>1、思想</h6>

<pre><code>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系，将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。
</code></pre>

<h6>2、核心思想</h6>

<p>在责任链模式中，很多对象由每一个对象对其下家的引用而接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。客户并不知道链上具体的哪一个对象最终处理了这个请求，系统可以在不影响客户端的情况下，动态的重新组织链和分配责任。处理者有两个选择：承担责任或者把责任推给下家。一个请求可以最终不被任何接收端对象所接受。</p>

<h6>3、优缺点分析</h6>

<p>关键点：当客户提交一个请求时，请求是沿链传递直至有一个ConcreteHandler对象负责处理它。</p>

<p>GOOD：</p>

<pre><code>（1）这就使得接受者和发送者之间都没有对方明确的信息，且链中的对象自己也并不知道整个链的结构。结果是职责链可简化对象的相互连接，它们仅需保持一个指向其后继者的引用，而不需要保持它所有的候选接受者的引用。

（2）可以随时地增加或修改一个请求的结构，增强了给对象指派职责的灵活性

（3）一个请求极有可能到了链的末端都得不到处理，或者因为没有正确配置而得不到处理
</code></pre>

<h3>命令模式</h3>

<h6>1、思想</h6>

<pre><code>命令模式：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作
</code></pre>

<h6>2、核心思想</h6>

<p>命令模式：把一个请求或者操作封装到一个对象中，命令模式把发出命令的责任和执行命令的责任分割开来，委派给不同的对象。命令模式允许请求的一方和发送的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否执行，何时被执行以及是怎么被执行的。</p>

<h6>3、优缺点分析</h6>

<p>GOOD：</p>

<pre><code>一、能较容易地建立一个命令队列；

二、在需要的情况下，可以较容易地将命令记入日志；

三、允许接收请求的一方是否拒绝请求；

四、可以容易地实现对请求的撤销和重做，

五、由于加进新的具体命令类不影响其他的类，因此添加一个新命令类不影响其它类；
</code></pre>

<p>最关键的优点：命令模式把请求一个操作的对象与知道怎么操行一个操作的对象分开</p>

<p>适用原则：敏捷开发原则告诉我们，不要为代码添加基于猜测的、实际不需要的功能。如果不清楚一个系统是否需要命令模式，一般不要着急去实现它，事实上、在需要的时候通过重构实现这个模式并不困难，只有在真正需要如撤销、恢复等操作功能时，才把原有的代码重构为命令模式才有意义。</p>

<h3>备忘录模式</h3>

<h6>1、思想</h6>

<pre><code>在不破坏封装的条件下，将一个对象的状态捉住，并在该对象外部保存这个状态，从而可以在将来合适的时候把这个对象还原到存储起来的状态。
</code></pre>

<h6>2、核心思想</h6>

<pre><code> 备忘录对象是一个用来存储另外一个对象内部状态的快照的对象。
</code></pre>

<h6>3、优缺点分析</h6>

<p>适用于功能比较复杂的，但需要记录或维护属性历史的类；或者需要保存的属性只是众多属性中的一小部分时Originator可以根据保存的Memo还原到前一状态。</p>

<h3>状态模式</h3>

<h6>1、思想</h6>

<pre><code>状态模式：当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。
</code></pre>

<h6>2、核心思想</h6>

<pre><code> 状态模式允许一个对象在其内部状态改变的时候改变行为。这个对象看上去像是改变了它的类一样。状态模式把所研究的对象的行为包装在不同的状态对象里，每一个状态对象都属于一个抽象状态类的一个子类。状态模式的思想是让一个对象在其内部状态改变的时候，其行为也随之改变。状态模式需要对每一个系统可能取得的状态创立一个状态类的子类。当系统的状态变化时，系统便改变所选的子类。

 状态模式主要解决的是当控制一个对象状态转换的条件表达式过于复杂时的情况。把状态的判断逻辑转移到表示不同状态的一系列类当中，可以把复杂的判断逻辑简化。
</code></pre>

<h6>3、优缺点分析</h6>

<ul>
<li><p>优点：</p>

<ul>
<li><p>状态模式的好处是将与特定状态相关的行为局部化，并且将不同状态的行为分割开来。</p>

<pre><code>  即：将特定的状态相关的行为都放入一个对象中，由于所有与状态相关的代码都存在于某个ConcreteState中，所以通过定义新的子类可以很容易地增加新的状态和转换。
</code></pre></li>
<li><p>消除了庞大的条件分支语句，并且通过把各种状态转移逻辑分布到State的子类之间，来减少相互间的依赖。
适用情况：</p></li>
<li><p>当一个对象的行为取决于它的状态，并且它必须在运行时刻根据状态改变它的行为时，可考虑用到状态模式。</p></li>
</ul>
</li>
</ul>


<h3>中介者模式</h3>

<h6>1、思想</h6>

<pre><code>中介者模式：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互
</code></pre>

<h6>2、核心思想</h6>

<p>包装了一系列对象相互作用的方式，使得这些对象不必相互明显作用。从而使他们可以松散耦合。当某些对象之间的作用发生改变时，不会立即影响其他的一些对象之间的作用。保证这些作用可以彼此独立的变化。调停者模式将多对多的相互作用转化为一对多的相互作用。调停者模式将对象的行为和协作抽象化，把对象在小尺度的行为上与其他对象的相互作用分开处理。</p>

<h6>3、优缺点分析</h6>

<p>中介者模式很容易在系统中应用，也很容易在系统中误用。当系统中出现了’多对多’交互复杂的对象群时，不要急于使用中介者模式，而要反思你的系统在设计上是不是合理。</p>

<p>GOOD:</p>

<p>（1）Mediator的出现减少了各个Colleague的耦合，使得可以独立地改变和复用各个Colleague类和Mediator</p>

<p>（2）由于把对象如何协作进行了抽象，将中介作为一个独立的概念并将其封装在一个对象中，这样关注的对象就从对象各自本身的行为转移到了它们之间的交互上来，也就是站在一个更宏观的角度去看待系统。</p>

<p>BAD:</p>

<p>由于ConcreteMediator控制了集中化，于是就把交互复杂性变为了中介者的复杂性，这就使得中介者会变得比任何一个ConcreteColleague都复杂。</p>

<h6>适用场合：</h6>

<p>中介者模式一般应用于一组对象以定义良好但是复杂的方式进行通信的场合，以及想定义一个分布在多个类中的行为，而又不想生成太多的子类的场合。</p>

<h3>解释器模式</h3>

<h6>思想</h6>

<pre><code>Interpreter是一种特殊的设计模式，它建立一个解释器，对于特定的计算机程序设计语言，用来解释预先定义的文法。简单地说，Interpreter模式是一种简单的语法解释器构架。

给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。
</code></pre>

<h6>适用场景：</h6>

<pre><code>    1.当有一个语言需要解释执行，并且你可将该语言中的句子表示为一个抽象语法树，可以使用解释器模式。而当存在以下情况时该模式效果最好

    2.该文法的类层次结构变得庞大而无法管理。此时语法分析程序生成器这样的工具是最好的选择。他们无需构建抽象语法树即可解释表达式，这样可以节省空间而且还可能节省时间。

    3.效率不是一个关键问题，最高效的解释器通常不是通过直接解释语法分析树实现的，而是首先将他们装换成另一种形式，例如，正则表达式通常被装换成状态机，即使在这种情况下，转换器仍可用解释器模式实现，该模式仍是有用的
</code></pre>

<h6>优缺点：</h6>

<ul>
<li><p>优点： 1、可扩展性比较好，灵活。 2、增加了新的解释表达式的方式。 3、易于实现简单文法。</p></li>
<li><p>缺点： 1、可利用场景比较少。 2、对于复杂的文法比较难维护。 3、解释器模式会引起类膨胀。 4、解释器模式采用递归调用方法。</p></li>
</ul>


<h3>访问者模式</h3>

<h6>思想：</h6>

<pre><code>封装某些作用于某种数据结构中各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。
</code></pre>

<h6>优点</h6>

<pre><code>符合单一职责原则：凡是适用访问者模式的场景中，元素类中需要封装在访问者中的操作必定是与元素类本身关系不大且是易变的操作，使用访问者模式一方面符合单一职责原则，另一方面，因为被封装的操作通常来说都是易变的，所以当发生变化时，就可以在不改变元素类本身的前提下，实现对变化部分的扩展。
扩展性良好：元素类可以通过接受不同的访问者来实现对不同操作的扩展。
</code></pre>

<h6>访问者模式的适用场景</h6>

<pre><code>   假如一个对象中存在着一些与本对象不相干（或者关系较弱）的操作，为了避免这些操作污染这个对象，则可以使用访问者模式来把这些操作封装到访问者中去。

   假如一组对象中，存在着相似的操作，为了避免出现大量重复的代码，也可以将这些重复的操作封装到访问者中去。
</code></pre>

<hr />

<h4>其他：</h4>

<h3>单一职责原则</h3>

<pre><code>就一个类而言，应该仅有一个引起它变化的原因。
</code></pre>

<p>　　如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其它职责能力。这种耦合会导制脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏。</p>

<pre><code>软件设计真正要做的许多内容，就是发现职责并把那些职责相互分离。

如果你能够想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责。
</code></pre>

<h3>开放——封闭原则</h3>

<h6>一、基本概念</h6>

<pre><code>  OCP: 软件实体（类、模块、函数等）应该可以扩展，但是不可修改。

 解释：即对于扩展是开放的，对于修改是封闭的。
</code></pre>

<h6>二、实际技巧</h6>

<pre><code> 实际上，无论模式多么的‘封闭’，都会存在一些无法对之封闭的变化，既然不可能完全封闭，设计人员必须对于他设计的模块应该对哪种变化封闭做出选择。他必须先猜测出最有可能发生的变化种类，然后构造抽象来隔离那些变化。

 即：当变化发生时，我们就创建抽象来隔离以后发生同类的变化。（等到变化发生时立即采取行动）    

 面对需求，对程序的改动是通过增加代码来完成的，而不是改动现有的代码。（例如简单工厂模式思想）
</code></pre>

<h6>三、优点</h6>

<pre><code> 开放――封闭原则是面向对象的核心所在。这个原则所带来的优点就是可维护、可扩展、可复用、灵活型好。

 开发人员应该对程序中呈现出频繁变化的那部分做出抽象，拒绝对任何部分都刻意抽象及不成熟的抽象。
</code></pre>

<h3>里氏代换原则</h3>

<h6>一、基本概念</h6>

<pre><code>  抽象不应该依赖细节，细节应该依赖抽象。即针对接口编程，不要对实现编程。

A：高层模块不能依赖低层模块，两者都应依赖抽象。

B：抽象不应该依赖细节，细节应该依赖抽象。 
</code></pre>

<h6>二、里氏代换原则（LSP）</h6>

<pre><code>子类型必须能够替换掉它们的父类型
</code></pre>

<p>解释：一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且它察觉不出父类对象和子类对象的区别。</p>

<pre><code>   也就是说，在软件里面，把父类都替换成它的子类，程序的行为没有变化。

   只有当子类可以替换父类，软件单位的功能不受到影响时，父类才真正被复用，而子类也能够在父类的基础上增加新的行为。

   所以，正是由于子类型的可替换性才使得使用父类类型的模块在无需修改的情况下就可以扩展。
</code></pre>

<h3>最少知识原则</h3>

<h6>一、基本概念</h6>

<pre><code>迪米特法则：如果两个类不直接通信，那么这两个类就不应当发生直接的相互作用。如果一个类需要调用另一个类的某个方法的话，可以通过第三个类转发这个调用。
</code></pre>

<h6>二、核心思想</h6>

<pre><code> 在类的结构设计上，每一个类都应该尽量降低成员的访问权限。也就是说：一个类包装好自己的private状态，不需要让别的类知道的字段或行为就不要公开。

迪米特原则的根本思想：强调了类之间的松耦合。     

 类之间的耦合越弱，越有利于复用，一个处在弱耦合的类被修改，不会对有关系的类造成波及。

  该法则在后面的适配器模式、解释模式等中有强烈的体现。    
</code></pre>

<hr />

<hr />

<h2>总结：</h2>

<ul>
<li><p>1、当涉及到“维护”时，为了“复用”目的而使用继承，并不是最好的方法。</p></li>
<li><p>2、利用继承来提供对象的行为，会导致以下缺点：</p>

<ul>
<li><p>1）代码在多个子类中重复；</p></li>
<li><p>2）运行时的行为不容易改变；</p></li>
<li><p>3）很难知道所有子类的全部行为；</p></li>
<li><p>4）改变父类会牵一发而动全身，造成其他子类不想要的改变；</p></li>
</ul>
</li>
<li><p>3、使用接口（JAVA）或虚基类加多重继承（C++）方法，则会需要对需要维护的代码中的每个子类都分别考虑其特有方法的继承来源。</p></li>
<li><p>4、设计原则：找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。即：把会变化的部分取出并“封装”起来，以便以后可以轻易的改动或扩充此部分，而不影响不需要变化的部分。</p></li>
<li><p>5、设计原则：针对接口编程，而不是针对实现编程。</p></li>
</ul>


<p>将对象的行为放在分开的类中，此类专门提供某行为接口的实现，并且在对象类中包含可设定行为的方法，使得程序可在“运行时”动态的改变特定对象的行为。</p>

<ul>
<li>6、封装行为的大局观</li>
</ul>


<p>设计原则：多用组合，少用继承</p>

<ul>
<li><p>7、策略模型：定义了算法族，分别封装起来，让它们之间可以相互替换，此模式让算法的变化独立于使用算法的客户。</p></li>
<li><p>8、设计模式的名词使用主要为了程序员间交流方便</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[修行篇-七大查找算法]]></title>
    <link href="http://al1020119.github.io/blog/2016/08/20/xiu-xing-pian-qi-da-cha-zhao-suan-fa/"/>
    <updated>2016-08-20T12:32:08+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/08/20/xiu-xing-pian-qi-da-cha-zhao-suan-fa</id>
    <content type="html"><![CDATA[<p>阅读目录</p>

<ul>
<li><p>1、顺序查找</p></li>
<li><p>2、二分查找</p></li>
<li><p>3、插值查找</p></li>
<li><p>4、斐波那契查找</p></li>
<li><p>5、树表查找</p></li>
<li><p>6、分块查找</p></li>
<li><p>7、哈希查找</p></li>
</ul>


<p>查找是在大量的信息中寻找一个特定的信息元素，在计算机应用中，查找是常用的基本运算，例如编译程序中符号表的查找。</p>

<!--more-->


<blockquote><p>本文简单概括性的介绍了常见的七种查找算法，说是七种，其实二分查找、插值查找以及斐波那契查找都可以归为一类——插值查找。插值查找和斐波那契查找是在二分查找的基础上的优化查找算法。树表查找和哈希查找会在后续的博文中进行详细介绍。</p></blockquote>

<p>查找定义：根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素（或记录）。</p>

<p>查找算法分类：</p>

<p>1）静态查找和动态查找；</p>

<pre><code>注：静态或者动态都是针对查找表而言的。动态表指查找表中有删除和插入操作的表。
</code></pre>

<p>2）无序查找和有序查找。</p>

<pre><code>无序查找：被查找数列有序无序均可；

有序查找：被查找数列必须为有序数列。
</code></pre>

<p>平均查找长度（Average Search Length，ASL）：</p>

<ul>
<li>需和指定key进行比较的关键字的个数的期望值，称为查找算法在查找成功时的平均查找长度。</li>
</ul>


<p>对于含有n个数据元素的查找表，查找成功的平均查找长度为：ASL = Pi*Ci的和。</p>

<pre><code>Pi：查找表中第i个数据元素的概率。

Ci：找到第i个数据元素时已经比较过的次数。
</code></pre>

<h3>1、顺序查找</h3>

<ul>
<li>说明：顺序查找适合于存储结构为顺序存储或链接存储的线性表。</li>
</ul>


<p>基本思想：</p>

<pre><code>顺序查找也称为线形查找，属于无序查找算法。从数据结构线形表的一端开始，顺序扫描，依次将扫描到的结点关键字与给定值k相比较，若相等则表示查找成功；若扫描结束仍没有找到关键字等于k的结点，表示查找失败。
</code></pre>

<p>复杂度分析：　</p>

<pre><code>查找成功时的平均查找长度为：（假设每个数据元素的概率相等） ASL = 1/n(1+2+3+…+n) = (n+1)/2 ;
</code></pre>

<p>当查找不成功时，需要n+1次比较，时间复杂度为O(n);</p>

<blockquote><p>所以，顺序查找的时间复杂度为O(n)。</p></blockquote>

<pre><code>//顺序查找
int SequenceSearch(int a[], int value, int n)
{
    int i;
    for(i=0; i&lt;n; i++)
        if(a[i]==value)
            return i;
    return -1;
}
</code></pre>

<h3>2、二分查找</h3>

<blockquote><p>说明：元素必须是有序的，如果是无序的则要先进行排序操作。</p></blockquote>

<p>基本思想：</p>

<pre><code>也称为是折半查找，属于有序查找算法。用给定值k先与中间结点的关键字比较，中间结点把线形表分成两个子表，若相等则查找成功；若不相等，再根据k与该中间结点关键字的比较结果确定下一步查找哪个子表，这样递归进行，直到查找到或查找结束发现表中没有这样的结点。
</code></pre>

<p>复杂度分析：</p>

<pre><code>最坏情况下，关键词比较次数为log2(n+1)，且期望时间复杂度为O(log2n)；
</code></pre>

<blockquote><p>注：折半查找的前提条件是需要有序表顺序存储，对于静态查找表，一次排序后不再变化，折半查找能得到不错的效率。但对于需要频繁执行插入或删除操作的数据集来说，维护有序的排序会带来不小的工作量，那就不建议使用。——《大话数据结构》</p></blockquote>

<pre><code>    //二分查找（折半查找），版本1
int BinarySearch1(int a[], int value, int n)
{
    int low, high, mid;
    low = 0;
    high = n-1;
    while(low&lt;=high)
    {
        mid = (low+high)/2;
        if(a[mid]==value)
            return mid;
        if(a[mid]&gt;value)
            high = mid-1;
        if(a[mid]&lt;value)
            low = mid+1;
    }
    return -1;
}

//二分查找，递归版本
int BinarySearch2(int a[], int value, int low, int high)
{
    int mid = low+(high-low)/2;
    if(a[mid]==value)
        return mid;
    if(a[mid]&gt;value)
        return BinarySearch2(a, value, low, mid-1);
    if(a[mid]&lt;value)
        return BinarySearch2(a, value, mid+1, high);
}
</code></pre>

<h3>3、插值查找</h3>

<p>在介绍插值查找之前，首先考虑一个新问题，为什么上述算法一定要是折半，而不是折四分之一或者折更多呢？</p>

<pre><code>打个比方，在英文字典里面查“apple”，你下意识翻开字典是翻前面的书页还是后面的书页呢？如果再让你查“zoo”，你又怎么查？很显然，这里你绝对不会是从中间开始查起，而是有一定目的的往前或往后翻。
</code></pre>

<p>同样的，比如要在取值范围1 ~ 10000 之间 100 个元素从小到大均匀分布的数组中查找5， 我们自然会考虑从数组下标较小的开始查找。</p>

<p>经过以上分析，折半查找这种查找方式，不是自适应的（也就是说是傻瓜式的）。二分查找中查找点计算如下：</p>

<pre><code>mid=(low+high)/2, 即mid=low+1/2*(high-low);
</code></pre>

<p>通过类比，我们可以将查找的点改进为如下：</p>

<pre><code>mid=low+(key-a[low])/(a[high]-a[low])*(high-low)，
</code></pre>

<p>也就是将上述的比例参数1/2改进为自适应的，根据关键字在整个有序表中所处的位置，让mid值的变化更靠近关键字key，这样也就间接地减少了比较次数。</p>

<p>基本思想：</p>

<pre><code>基于二分查找算法，将查找点的选择改进为自适应选择，可以提高查找效率。当然，差值查找也属于有序查找。
</code></pre>

<blockquote><p>注：对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好的多。反之，数组中如果分布非常不均匀，那么插值查找未必是很合适的选择。</p></blockquote>

<p>复杂度分析：查找成功或者失败的时间复杂度均为O(log2(log2n))。</p>

<pre><code>//插值查找
int InsertionSearch(int a[], int value, int low, int high)
{
    int mid = low+(value-a[low])/(a[high]-a[low])*(high-low);
    if(a[mid]==value)
        return mid;
    if(a[mid]&gt;value)
        return InsertionSearch(a, value, low, mid-1);
    if(a[mid]&lt;value)
        return InsertionSearch(a, value, mid+1, high);
}
</code></pre>

<h3>4、斐波那契查找</h3>

<blockquote><p>在介绍斐波那契查找算法之前，我们先介绍一下很它紧密相连并且大家都熟知的一个概念——黄金分割。</p></blockquote>

<p>黄金比例又称黄金分割，</p>

<pre><code>是指事物各部分间一定的数学比例关系，即将整体一分为二，较大部分与较小部分之比等于整体与较大部分之比，其比值约为1:0.618或1.618:1。
</code></pre>

<p>0.618被公认为最具有审美意义的比例数字，这个数值的作用不仅仅体现在诸如绘画、雕塑、音乐、建筑等艺术领域，而且在管理、工程设计等方面也有着不可忽视的作用。因此被称为黄金分割。</p>

<p>大家记不记得斐波那契数列：</p>

<ul>
<li>1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89…….（从第三个数开始，后边每一个数都是前两个数的和）。然后我们会发现，随着斐波那契数列的递增，前后两个数的比值会越来越接近0.618，利用这个特性，我们就可以将黄金比例运用到查找技术中。</li>
</ul>


<p>基本思想：</p>

<pre><code>也是二分查找的一种提升算法，通过运用黄金比例的概念在数列中选择查找点进行查找，提高查找效率。同样地，斐波那契查找也属于一种有序查找算法。
</code></pre>

<p>相对于折半查找，一般将待比较的key值与第mid=（low+high）/2位置的元素比较，比较结果分三种情况：</p>

<ul>
<li><p>1）相等，mid位置的元素即为所求</p></li>
<li><p>2）>，low=mid+1;</p></li>
<li><p>3）&lt;，high=mid-1。</p></li>
</ul>


<p>斐波那契查找与折半查找很相似，他是根据斐波那契序列的特点对有序表进行分割的。他要求开始表中记录的个数为某个斐波那契数小1，及n=F(k)-1;</p>

<p>开始将k值与第F(k-1)位置的记录进行比较(及mid=low+F(k-1)-1),比较结果也分为三种</p>

<ul>
<li><p>1）相等，mid位置的元素即为所求</p></li>
<li><p>2）>，low=mid+1,k-=2;</p>

<ul>
<li>说明：low=mid+1说明待查找的元素在[mid+1,high]范围内，k-=2 说明范围[mid+1,high]内的元素个数为n-(F(k-1))= Fk-1-F(k-1)=Fk-F(k-1)-1=F(k-2)-1个，所以可以递归的应用斐波那契查找。</li>
</ul>
</li>
<li><p>3）&lt;，high=mid-1,k-=1。</p></li>
</ul>


<p>说明：low=mid+1说明待查找的元素在[low,mid-1]范围内，k-=1 说明范围[low,mid-1]内的元素个数为F(k-1)-1个，所以可以递归 的应用斐波那契查找。</p>

<p>复杂度分析：最坏情况下，时间复杂度为O(log2n)，且其期望复杂度也为O(log2n)。</p>

<pre><code>// 斐波那契查找.cpp 

#include "stdafx.h"
#include &lt;memory&gt;
#include  &lt;iostream&gt;
using namespace std;

const int max_size=20;//斐波那契数组的长度

/*构造一个斐波那契数组*/ 
void Fibonacci(int * F)
{
    F[0]=0;
    F[1]=1;
    for(int i=2;i&lt;max_size;++i)
        F[i]=F[i-1]+F[i-2];
}

/*定义斐波那契查找法*/  
int FibonacciSearch(int *a, int n, int key)  //a为要查找的数组,n为要查找的数组长度,key为要查找的关键字
{
  int low=0;
  int high=n-1;

  int F[max_size];
  Fibonacci(F);//构造一个斐波那契数组F 

  int k=0;
  while(n&gt;F[k]-1)//计算n位于斐波那契数列的位置
      ++k;

  int  * temp;//将数组a扩展到F[k]-1的长度
  temp=new int [F[k]-1];
  memcpy(temp,a,n*sizeof(int));

  for(int i=n;i&lt;F[k]-1;++i)
     temp[i]=a[n-1];

  while(low&lt;=high)
  {
    int mid=low+F[k-1]-1;
    if(key&lt;temp[mid])
    {
      high=mid-1;
      k-=1;
    }
    else if(key&gt;temp[mid])
    {
     low=mid+1;
     k-=2;
    }
    else
    {
       if(mid&lt;n)
           return mid; //若相等则说明mid即为查找到的位置
       else
           return n-1; //若mid&gt;=n则说明是扩展的数值,返回n-1
    }
  }  
  delete [] temp;
  return -1;
}

int main()
{
    int a[] = {0,16,24,35,47,59,62,73,88,99};
    int key=100;
    int index=FibonacciSearch(a,sizeof(a)/sizeof(int),key);
    cout&lt;&lt;key&lt;&lt;" is located at:"&lt;&lt;index;
    return 0;
}
</code></pre>

<h3>5、树表查找</h3>

<h5>5.1 最简单的树表查找算法——二叉树查找算法。</h5>

<p>基本思想：</p>

<pre><code>二叉查找树是先对待查找的数据进行生成树，确保树的左分支的值小于右分支的值，然后在就行和每个节点的父节点比较大小，查找最适合的范围。 这个算法的查找效率很高，但是如果使用这种查找方法要首先创建树。 
</code></pre>

<p>二叉查找树（BinarySearch Tree，也叫二叉搜索树，或称二叉排序树Binary Sort Tree）或者是一棵空树，或者是具有下列性质的二叉树：</p>

<ul>
<li><p>1）若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</p></li>
<li><p>2）若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</p></li>
<li><p>3）任意节点的左、右子树也分别为二叉查找树。</p></li>
</ul>


<p>二叉查找树性质：</p>

<pre><code>对二叉查找树进行中序遍历，即可得到有序的数列。
</code></pre>

<p>不同形态的二叉查找树如下图所示：</p>

<p>有关二叉查找树的查找、插入、删除等操作的详细讲解，请移步浅谈算法和数据结构: 七 二叉查找树。</p>

<p>复杂度分析：它和二分查找一样，插入和查找的时间复杂度均为O(logn)，但是在最坏的情况下仍然会有O(n)的时间复杂度。原因在于插入和删除元素的时候，树没有保持平衡（比如，我们查找上图（b）中的“93”，我们需要进行n次查找操作）。我们追求的是在最坏的情况下仍然有较好的时间复杂度，这就是平衡查找树设计的初衷。</p>

<p>下图为二叉树查找和顺序查找以及二分查找性能的对比图：</p>

<p>基于二叉查找树进行优化，进而可以得到其他的树表查找算法，如平衡树、红黑树等高效算法。</p>

<h5>5.2 平衡查找树之2-3查找树（2-3 Tree）</h5>

<p>2-3查找树定义：</p>

<pre><code>和二叉树不一样，2-3树运行每个节点保存1个或者两个的值。对于普通的2节点(2-node)，他保存1个key和左右两个自己点。对应3节点(3-node)，保存两个Key，2-3查找树的定义如下：
</code></pre>

<ul>
<li><p>1）要么为空，要么：</p></li>
<li><p>2）对于2节点，该节点保存一个key及对应value，以及两个指向左右节点的节点，左节点也是一个2-3节点，所有的值都比key要小，右节点也是一个2-3节点，所有的值比key要大。</p></li>
<li><p>3）对于3节点，该节点保存两个key及对应value，以及三个指向左中右的节点。左节点也是一个2-3节点，所有的值均比两个key中的最小的key还要小；中间节点也是一个2-3节点，中间节点的key值在两个跟节点key值之间；右节点也是一个2-3节点，节点的所有key值比两个key中的最大的key还要大。</p></li>
</ul>


<p>2-3查找树的性质：</p>

<ul>
<li><p>1）如果中序遍历2-3查找树，就可以得到排好序的序列；</p></li>
<li><p>2）在一个完全平衡的2-3查找树中，根节点到每一个为空节点的距离都相同。（这也是平衡树中“平衡”一词的概念，根节点到叶节点的最长距离对应于查找算法的最坏情况，而平衡树中根节点到叶节点的距离都一样，最坏情况也具有对数复杂度。）</p></li>
</ul>


<p>复杂度分析：</p>

<p>2-3树的查找效率与树的高度是息息相关的。</p>

<pre><code>在最坏的情况下，也就是所有的节点都是2-node节点，查找效率为lgN

在最好的情况下，所有的节点都是3-node节点，查找效率为log3N约等于0.631lgN
</code></pre>

<p>距离来说，对于1百万个节点的2-3树，树的高度为12-20之间，对于10亿个节点的2-3树，树的高度为18-30之间。</p>

<p>对于插入来说，只需要常数次操作即可完成，因为他只需要修改与该节点关联的节点即可，不需要检查其他节点，所以效率和查找类似。下面是2-3查找树的效率：</p>

<h5>5.3 平衡查找树之红黑树（Red-Black Tree）</h5>

<p>2-3查找树能保证在插入元素之后能保持树的平衡状态，最坏情况下即所有的子节点都是2-node，树的高度为lgn，从而保证了最坏情况下的时间复杂度。但是2-3树实现起来比较复杂，于是就有了一种简单实现2-3树的数据结构，即红黑树（Red-Black Tree）。</p>

<p>基本思想：红黑树的思想就是对2-3查找树进行编码，尤其是对2-3查找树中的3-nodes节点添加额外的信息。红黑树中将节点之间的链接分为两种不同类型，红色链接，他用来链接两个2-nodes节点来表示一个3-nodes节点。黑色链接用来链接普通的2-3节点。特别的，使用红色链接的两个2-nodes来表示一个3-nodes节点，并且向左倾斜，即一个2-node是另一个2-node的左子节点。这种做法的好处是查找的时候不用做任何修改，和普通的二叉查找树相同。</p>

<p>红黑树的定义：红黑树是一种具有红色和黑色链接的平衡查找树，同时满足：</p>

<pre><code>红色节点向左倾斜

一个节点不可能有两个红色链接

整个树完全黑色平衡，即从根节点到所以叶子结点的路径上，黑色链接的个数都相同。
</code></pre>

<p>下图可以看到红黑树其实是2-3树的另外一种表现形式：如果我们将红色的连线水平绘制，那么他链接的两个2-node节点就是2-3树中的一个3-node节点了。</p>

<p>红黑树的性质：</p>

<pre><code>整个树完全黑色平衡，即从根节点到所以叶子结点的路径上，黑色链接的个数都相同（2-3树的第2）性质，从根节点到叶子节点的距离都相等）。
</code></pre>

<p>复杂度分析：</p>

<pre><code>最坏的情况就是，红黑树中除了最左侧路径全部是由3-node节点组成，即红黑相间的路径长度是全黑路径长度的2倍。
</code></pre>

<p>下图是一个典型的红黑树，从中可以看到最长的路径(红黑相间的路径)是最短路径的2倍：</p>

<pre><code>　　红黑树的平均高度大约为logn。
</code></pre>

<p>下图是红黑树在各种情况下的时间复杂度，可以看出红黑树是2-3查找树的一种实现，它能保证最坏情况下仍然具有对数的时间复杂度。</p>

<p>红黑树这种数据结构应用十分广泛，在多种编程语言中被用作符号表的实现，如：</p>

<pre><code>Java中的java.util.TreeMap,java.util.TreeSet；

C++ STL中的：map,multimap,multiset；

.NET中的：SortedDictionary,SortedSet 等。
</code></pre>

<h5>5.4 B树和B+树（B Tree/B+ Tree）</h5>

<p>平衡查找树中的2-3树以及其实现红黑树。2-3树种，一个节点最多有2个key，而红黑树则使用染色的方式来标识这两个key。</p>

<blockquote><p>维基百科对B树的定义为“在计算机科学中，B树（B-tree）是一种树状数据结构，它能够存储数据、对其进行排序并允许以O(log n)的时间复杂度运行进行查找、顺序读取、插入和删除的数据结构。B树，概括来说是一个节点可以拥有多于2个子节点的二叉查找树。与自平衡二叉查找树不同，B树为系统最优化大块数据的读和写操作。B-tree算法减少定位记录时所经历的中间过程，从而加快存取速度。普遍运用在数据库和文件系统。</p></blockquote>

<h6>B树定义：</h6>

<pre><code>B树可以看作是对2-3查找树的一种扩展，即他允许每个节点有M-1个子节点。

根节点至少有两个子节点

每个节点有M-1个key，并且以升序排列

位于M-1和M key的子节点的值位于M-1 和M key对应的Value之间

其它节点至少有M/2个子节点
</code></pre>

<p>下图是一个M=4 阶的B树:</p>

<p>可以看到B树是2-3树的一种扩展，他允许一个节点有多于2个的元素。B树的插入及平衡化操作和2-3树很相似，这里就不介绍了。</p>

<h6>B+树定义：</h6>

<p>B+树是对B树的一种变形树，它与B树的差异在于：</p>

<pre><code>有k个子结点的结点必然有k个关键码；

非叶结点仅具有索引作用，跟记录有关的信息均存放在叶结点中。

树的所有叶结点构成一个有序链表，可以按照关键码排序的次序遍历全部记录。
</code></pre>

<p>如下图，是一个B+树:</p>

<pre><code>B和B+树的区别在于，B+树的非叶子结点只包含导航信息，不包含实际的值，所有的叶子结点和相连的节点使用链表相连，便于区间查找和遍历。
</code></pre>

<p>B+ 树的优点在于：</p>

<pre><code>由于B+树在内部节点上不好含数据信息，因此在内存页中能够存放更多的key。 数据存放的更加紧密，具有更好的空间局部性。因此访问叶子几点上关联的数据也具有更好的缓存命中率。

B+树的叶子结点都是相链的，因此对整棵树的便利只需要一次线性遍历叶子结点即可。而且由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树则需要进行每一层的递归遍历。相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。
</code></pre>

<p>但是B树也有优点，其优点在于，由于B树的每一个节点都包含key和value，因此经常访问的元素可能离根节点更近，因此访问也更迅速。</p>

<p>B/B+树常用于文件系统和数据库系统中，它通过对每个节点存储个数的扩展，使得对连续的数据能够进行较快的定位和访问，能够有效减少查找时间，提高存储的空间局部性从而减少IO操作。它广泛用于文件系统及数据库中，如：</p>

<pre><code>Windows：HPFS文件系统；

Mac：HFS，HFS+文件系统；

Linux：ResiserFS，XFS，Ext3FS，JFS文件系统；

数据库：ORACLE，MYSQL，SQLSERVER等中。
</code></pre>

<p>有关B/B+树在数据库索引中的应用，请看张洋的MySQL索引背后的数据结构及算法原理这篇文章，这篇文章对MySQL中的如何使用B+树进行索引有比较详细的介绍，推荐阅读。</p>

<p>树表查找总结：</p>

<pre><code>二叉查找树平均查找性能不错，为O(logn)，但是最坏情况会退化为O(n)。在二叉查找树的基础上进行优化，我们可以使用平衡查找树。平衡查找树中的2-3查找树，这种数据结构在插入之后能够进行自平衡操作，从而保证了树的高度在一定的范围内进而能够保证最坏情况下的时间复杂度。但是2-3查找树实现起来比较困难，红黑树是2-3树的一种简单高效的实现，他巧妙地使用颜色标记来替代2-3树中比较难处理的3-node节点问题。红黑树是一种比较高效的平衡查找树，应用非常广泛，很多编程语言的内部实现都或多或少的采用了红黑树。
</code></pre>

<p>除此之外，2-3查找树的另一个扩展——B/B+平衡树，在文件系统和数据库系统中有着广泛的应用。</p>

<h3>6、分块查找</h3>

<p>分块查找又称索引顺序查找，它是顺序查找的一种改进方法。</p>

<p>算法思想：</p>

<pre><code>将n个数据元素"按块有序"划分为m块（m ≤ n）。每一块中的结点不必有序，但块与块之间必须"按块有序"；即第1块中任一元素的关键字都必须小于第2块中任一元素的关键字；而第2块中任一元素又都必须小于第3块中的任一元素，……
</code></pre>

<p>算法流程：</p>

<ol>
<li>step1 先选取各块中的最大关键字构成一个索引表；</li>
<li>step2 查找分两个部分：先对索引表进行二分查找或顺序查找，以确定待查记录</li>
</ol>


<p>在哪一块中；然后，在已确定的块中用顺序法进行查找。</p>

<h3>7、哈希查找</h3>

<p>什么是哈希表（Hash）？</p>

<pre><code>我们使用一个下标范围比较大的数组来存储元素。可以设计一个函数（哈希函数， 也叫做散列函数），使得每个元素的关键字都与一个函数值（即数组下标）相对应，于是用这个数组单元来存储这个元素；也可以简单的理解为，按照关键字为每一个元素"分类"，然后将这个元素存储在相应"类"所对应的地方。但是，不能够保证每个元素的关键字与函数值是一一对应的，因此极有可能出现对于不同的元素，却计算出了相同的函数值，这样就产生了"冲突"，换句话说，就是把不同的元素分在了相同的"类"之中。后面我们将看到一种解决"冲突"的简便做法。
</code></pre>

<p>总的来说，"直接定址"与"解决冲突"是哈希表的两大特点。</p>

<p>什么是哈希函数？哈希函数的规则是：</p>

<pre><code>通过某种转换关系，使关键字适度的分散到指定大小的的顺序结构中，越分散，则以后查找的时间复杂度越小，空间复杂度越高。
</code></pre>

<p>算法思想：</p>

<pre><code>哈希的思路很简单，如果所有的键都是整数，那么就可以使用一个简单的无序数组来实现：将键作为索引，值即为其对应的值，这样就可以快速访问任意键的值。这是对于简单的键的情况，我们将其扩展到可以处理更加复杂的类型的键。
</code></pre>

<p>算法流程：</p>

<ul>
<li><p>1）用给定的哈希函数构造哈希表；</p></li>
<li><p>2）根据选择的冲突处理方法解决地址冲突；</p>

<ul>
<li>常见的解决冲突的方法：拉链法和线性探测法。</li>
</ul>
</li>
<li><p>3）在哈希表的基础上执行哈希查找。</p></li>
</ul>


<p>哈希表是一个在时间和空间上做出权衡的经典例子。如果没有内存限制，那么可以直接将键作为数组的索引。那么所有的查找时间复杂度为O(1)；如果没有时间限制，那么我们可以使用无序数组并进行顺序查找，这样只需要很少的内存。哈希表使用了适度的时间和空间来在这两个极端之间找到了平衡。只需要调整哈希函数算法即可在时间和空间上做出取舍。</p>

<p>复杂度分析：</p>

<pre><code>单纯论查找复杂度：对于无冲突的Hash表而言，查找复杂度为O(1)（注意，在查找之前我们需要构建相应的Hash表）。
</code></pre>

<p>使用Hash，我们付出了什么？</p>

<pre><code>我们在实际编程中存储一个大规模的数据，最先想到的存储结构可能就是map，也就是我们常说的KV pair，经常使用Python的博友可能更有这种体会。使用map的好处就是，我们在后续处理数据处理时，可以根据数据的key快速的查找到对应的value值。map的本质就是Hash表，那我们在获取了超高查找效率的基础上，我们付出了什么？
</code></pre>

<blockquote><p>Hash是一种典型以空间换时间的算法，比如原来一个长度为100的数组，对其查找，只需要遍历且匹配相应记录即可，从空间复杂度上来看，假如数组存储的是byte类型数据，那么该数组占用100byte空间。现在我们采用Hash算法，我们前面说的Hash必须有一个规则，约束键与存储位置的关系，那么就需要一个固定长度的hash表，此时，仍然是100byte的数组，假设我们需要的100byte用来记录键与位置的关系，那么总的空间为200byte,而且用于记录规则的表大小会根据规则，大小可能是不定的。</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[修行篇-五大常用算法]]></title>
    <link href="http://al1020119.github.io/blog/2016/08/18/xiu-xing-pian-wu-da-chang-yong-suan-fa/"/>
    <updated>2016-08-18T12:31:31+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/08/18/xiu-xing-pian-wu-da-chang-yong-suan-fa</id>
    <content type="html"><![CDATA[<h3>分治算法</h3>

<h6>概念：分而治之</h6>

<pre><code>把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并

排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)……
</code></pre>

<p>思想：将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之</p>

<pre><code>分治策略是：对于一个规模为n的问题，若该问题可以容易地解决（比如说规模n较小）则直接解决，否则将其分解为k个规模较小的子问题，这些子问题互相独立且与原问题形式相同，递归地解这些子问题，然后将各子问题的解合并得到原问题的解。这种算法设计策略叫做分治法

这自然导致递归过程的产生。分治与递归像一对孪生兄弟
</code></pre>

<!--more-->


<h6>特征：</h6>

<p>分治法所能解决的问题一般具有以下几个特征：</p>

<pre><code>1) 该问题的规模缩小到一定的程度就可以容易地解决

2) 该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。

3) 利用该问题分解出的子问题的解可以合并为该问题的解；

4) 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题。
</code></pre>

<p>综上：</p>

<ul>
<li><p>第一条特征是绝大多数问题都可以满足的，因为问题的计算复杂性一般是随着问题规模的增加而增加；</p></li>
<li><p>第二条特征是应用分治法的前提它也是大多数问题可以满足的，此特征反映了递归思想的应用；、</p></li>
<li><p>第三条特征是关键，能否利用分治法完全取决于问题是否具有第三条特征，如果具备了第一条和第二条特征，而不具备第三条特征，则可以考虑用贪心法或动态规划法。</p></li>
<li><p>第四条特征涉及到分治法的效率，如果各子问题是不独立的则分治法要做许多不必要的工作，重复地解公共的子问题，此时虽然可用分治法，但一般用动态规划法较好。</p></li>
</ul>


<h6>性能：</h6>

<p> 一个分治法将规模为n的问题分成k个规模为n／m的子问题去解。设分解阀值n0=1，且adhoc解规模为1的问题耗费1个单位时间。再设将原问题分解为k个子问题以及用merge将k个子问题的解合并为原问题的解需用f(n)个单位时间。用T(n)表示该分治法解规模为|P|=n的问题所需的计算时间，则有：</p>

<p> T（n）= k T(n/m)+f(n)</p>

<pre><code>通过迭代法求得方程的解：
递归方程及其解只给出n等于m的方幂时T(n)的值，但是如果认为T(n)足够平滑，那么由n等于m的方幂时T(n)的值可以估计T(n)的增长速度。通常假定T(n)是单调上升的，从而当                  mi≤n&lt;mi+1时，T(mi)≤T(n)&lt;T(mi+1)。 
</code></pre>

<h6>经典问题</h6>

<ul>
<li>（1）二分搜索</li>
<li>（2）大整数乘法</li>
<li>（3）Strassen矩阵乘法</li>
<li>（4）棋盘覆盖</li>
<li>（5）合并排序</li>
<li>（6）快速排序</li>
<li>（7）线性时间选择</li>
<li>（8）最接近点对问题</li>
<li>（9）循环赛日程表</li>
<li>（10）汉诺塔</li>
</ul>


<h6>思维过程</h6>

<pre><code>实际上就是类似于数学归纳法，找到解决本问题的求解方程公式，然后根据方程公式设计递归程序。
</code></pre>

<ol>
<li>一定是先找到最小问题规模时的求解方法</li>
<li>然后考虑随着问题规模增大时的求解方法</li>
<li>找到求解的递归函数式后（各种规模或因子），设计递归程序即可。</li>
</ol>


<h3>动态规划</h3>

<h6>概念</h6>

<pre><code>每次决策依赖于当前状态，又随即引起状态的转移。一个决策序列就是在变化的状态中产生出来的，所以，这种多阶段最优化决策解决问题的过程就称为动态规划
</code></pre>

<h6>思想</h6>

<pre><code>基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解
</code></pre>

<h6>特点：</h6>

<pre><code>叠子问题这个特点，为减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在一个二维数组中
</code></pre>

<h6>与分治法最大的差别是：</h6>

<pre><code>适合于用动态规划法求解的问题，经分解后得到的子问题往往不是互相独立的（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）。
</code></pre>

<h6>使用</h6>

<ul>
<li><p>(1) 最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。</p></li>
<li><p>(2) 无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。</p></li>
<li><p>（3）有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）
实际应用</p></li>
</ul>


<h6>三要素：</h6>

<p>使用动态规划求解问题，最重要的就是确定动态规划三要素：</p>

<pre><code>（1）问题的阶段 

（2）每个阶段的状态

（3）从前一个阶段转化到后一个阶段之间的递推关系。
</code></pre>

<h6>总结</h6>

<p>递推关系必须是从次小的问题开始到较大的问题之间的转化，从这个角度来说，动态规划往往可以用递归程序来实现，不过因为递推可以充分利用前面保存的子问题的解来减少重复计算，所以对于大规模问题来说，有递归不可比拟的优势，这也是动态规划算法的核心之处。</p>

<pre><code>确定了动态规划的这三要素，整个求解过程就可以用一个最优决策表来描述，最优决策表是一个二维表，其中行表示决策的阶段，列表示问题状态，表格需要填写的数据一般对应此问题的在某个阶段某个状态下的最优值（如最短路径，最长公共子序列，最大价值等），填表的过程就是根据递推关系，从1行1列开始，以行或者列优先的顺序，依次填写表格，最后根据整个表格的数据通过简单的取舍或者运算求得问题的最优解。

      f(n,m)=max{f(n-1,m), f(n-1,m-w[n])+P(n,m)}
</code></pre>

<h3>贪心算法</h3>

<h6>概念</h6>

<pre><code>在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的仅是在某种意义上的局部最优解。
</code></pre>

<blockquote><p>贪心算法不是对所有问题都能得到整体最优解，选择的贪心策略必须具备无后效性，即某个状态以后的过程不会影响以前的状态，只与当前状态有关。</p></blockquote>

<h6>思想</h6>

<ol>
<li>建立数学模型来描述问题。</li>
<li>把求解的问题分成若干个子问题。</li>
<li>对每一子问题求解，得到子问题的局部最优解。</li>
<li>把子问题的解局部最优解合成原来解问题的一个解。</li>
</ol>


<h6>使用</h6>

<p>局部最优策略能导致产生全局最优解。</p>

<pre><code>实际上，贪心算法适用的情况很少。一般，对一个问题分析是否适用于贪心算法，可以先选择该问题下的几个实际数据进行分析，就可做出判断。
</code></pre>

<p>实际应用</p>

<p>实现框架
    从问题的某一初始解出发；
    while （能朝给定总目标前进一步）
    {
          利用可行的决策，求出可行解的一个解元素；
    }
    由所有解元素组合成问题的一个可行解；</p>

<pre><code>    因为用贪心算法只能通过解局部最优解的策略来达到全局最优解，因此，一定要注意判断问题是否适合采用贪心算法策略，找到的解是否一定是问题的最优解。
</code></pre>

<h6>总结</h6>

<blockquote><p>贪心算法并不是完全不可以使用，贪心策略一旦经过证明成立后，它就是一种高效的算法。</p></blockquote>

<ul>
<li>需要证明: 贪心算法的证明围绕着：整个问题的最优解一定由在贪心策略中存在的子问题的最优解得来的。</li>
</ul>


<h3>回溯算法</h3>

<h6>概念</h6>

<pre><code>一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径

回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。
</code></pre>

<p>特点：有“通用解题方法”的美称。</p>

<h6>思想</h6>

<p>在包含问题的所有解的解空间树中，按照深度优先搜索的策略，从根结点出发深度探索解空间树。当探索到某一结点时，要先判断该结点是否包含问题的解，如果包含，就从该结点出发继续探索下去，如果该结点不包含问题的解，则逐层向其祖先结点回溯。（其实回溯法就是对隐式图的深度优先搜索算法）。</p>

<pre><code>   若用回溯法求问题的所有解时，要回溯到根，且根结点的所有可行的子树都要已被搜索遍才结束。

   而若使用回溯法求任一个解时，只要搜索到问题的一个解就可以结束。
</code></pre>

<h6>使用</h6>

<pre><code>（1）针对所给问题，确定问题的解空间：首先应明确定义问题的解空间，问题的解空间应至少包含问题的一个（最优）解。

（2）确定结点的扩展搜索规则

（3）以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。实际应用
</code></pre>

<h3>分支限界法</h3>

<h6>概念</h6>

<pre><code> 类似于回溯法，也是一种在问题的解空间树T上搜索问题解的算法。但在一般情况下，分支限界法与回溯法的求解目标不同。回溯法的求解目标是找出T中满足约束条件的所有解，而分支限界法的求解目标则是找出满足约束条件的一个解，或是在满足约束条件的解中找出使某一目标函数值达到极大或极小的解，即在某种意义下的最优解。
</code></pre>

<p>回溯法和分支限界法的一些区别</p>

<pre><code>有一些问题其实无论用回溯法还是分支限界法都可以得到很好的解决，但是另外一些则不然。也许我们需要具体一些的分析——到底何时使用分支限界而何时使用回溯呢？
</code></pre>

<h6>搜索算法</h6>

<pre><code>所谓“分支”就是采用广度优先的策略，依次搜索E-结点的所有分支，也就是所有相邻结点，抛弃不满足约束条件的结点，其余结点加入活结点表。然后从表中选择一个结点作为下一个E-结点，继续搜索。

 选择下一个E-结点的方式不同，则会有几种不同的分支搜索方式。
</code></pre>

<p>   1）FIFO搜索</p>

<p>   2）LIFO搜索</p>

<p>   3）优先队列式搜索</p>

<h6>回溯法和分支限界法的区别：</h6>

<ul>
<li><p>方法对解空间树的搜索方式       存储结点的常用数据结构      结点存储特性常用应用</p></li>
<li><p>回溯法深度优先搜索堆栈活结点的所有可行子结点被遍历后才被从栈中弹出找出满足约束条件的所有解</p></li>
<li><p>分支限界法广度优先或最小消耗优先搜索队列、优先队列每个结点只有一次成为活结点的机会找出满足约束条件的一个解或特定意义下的最优解</p></li>
</ul>


<hr />

<p>总结</p>

<blockquote><p>多理解，多理解，多理解。。。。</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[修行篇-八大排序算法]]></title>
    <link href="http://al1020119.github.io/blog/2016/08/16/xiu-xing-pian-chang-jian-pai-xu-suan-fa/"/>
    <updated>2016-08-16T12:31:14+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/08/16/xiu-xing-pian-chang-jian-pai-xu-suan-fa</id>
    <content type="html"><![CDATA[<p>常用排序算法</p>

<blockquote><p>这里我们大概按照重要性的先后顺序介绍</p></blockquote>

<h2>快速排序</h2>

<ul>
<li><p>快速排序是不稳定的，其时间平均时间复杂度是O ( nlgn )。</p></li>
<li><p>快速排序采用的思想是分治思想。</p></li>
</ul>


<p>思路:快速排序是找出一个元素（理论上可以随便找一个）作为基准(pivot),然后对数组进行分区操作,使基准左边元素的值都不大于基准值,基准右边的元素值 都不小于基准值，如此作为基准的元素调整到排序后的正确位置。递归快速排序，将其他n-1个元素也调整到排序后的正确位置。最后每个元素都是在排序后的正 确位置，排序完成。所以快速排序算法的核心算法是分区操作，即如何调整基准的位置以及调整返回基准的最终位置以便分治递归。</p>

<!--more-->


<p>伪代码</p>

<pre><code>void quickSort(int a[], int len, int left, int right) {
   // 所有都排序完毕了，就退出递归
   if left &gt;= right {
     return;
   }

   // 每一趟划分，使左边的比基准小，右边的比基准大，并返回新的基准的位置
   int baseIndex = partition(a, len, left, right);

   // 递归排序左部分
   quickSort(a, len, left, baseIndex - 1);
   // 递归排序右部分
   quickSort(a, len, baseIndex + 1, right)
}

int partition(int a[], int len, int left, int right) {
   // 记录哪个是基准数
   int base = a[left];
   // 记录当前基准数的位置
   int baseIndex = left;

   while left &lt; right {
     // 先从右边往左边扫描，找到第一个比base还要小的数，但是不能与left相遇
     while left &lt; right &amp;&amp; a[right] &gt;= base {
       right--;
     }

     // 再从左边往右边扫描，找到第一个比base还要大的数，但是不能与right相遇
     while left &lt; right &amp;&amp; a[left] &lt;= base {
       left++;
     }

     // 将所扫描到的第一个比基准数小和第一个比基准数大的数交换
     swap(a, left, right);
   }

   // 交换left与baseIndex对应的元素，将left位置的元素作为新的基准数
   swap(a, baseIndex, left);

   // 返回新的基准位置
   return left;
}

void swap(int a[], int i, int j) {
   int temp = a[i];

   a[i] = a[j];
   a[j] = temp;
}
</code></pre>

<p>C语言版</p>

<pre><code>void quickSort(int a[], int len, int left, int right) {
  if (left &gt;= right) {
    return;
  }

  // 一次划分后，得到基准数据的位置
 int baseIndex = partition(a, len, left, right);

  // 快排左边部分
  quickSort(a, len, left, baseIndex - 1);
  // 快排右边部分
  quickSort(a, len, baseIndex + 1, right);
}

int partition(int a[], int len, int left, int right) {
  // 每一次的划分，都让第一个元素作为基准
  int base = a[left];
  // 记下刚开始的基准的位置， 便于最后相遇时交换
  int baseIndex = left;

  while (left &lt; right) {
    // 查找右部分比base还小的元素的下标
    while (left &lt; right &amp;&amp; a[right] &gt;= base) {
      right--;
    }

    // 查找左部分比base还大的元素的下标
    while (left &lt; right &amp;&amp; a[left] &lt;= base) {
      left++;
    }

    // 将这一趟比基准大和比基准小的所找到的第一个值，互相交换
    swap(a, left, right);
  }

  // 在left与right相遇时，将基准数与相遇点交换
  // 这样这一次划分，就可以保证左边的比基准数小，右边的比基准数大
  swap(a, baseIndex, left);

  // 划分完成后，以left位置的元素作为新的基准，分成左右序列，分别递归排序
  return left;
}

void swap(int a[], int i, int j) {
  int temp = a[i];
  a[i] = a[j];
  a[j] = temp;
}
</code></pre>

<p>Swift版</p>

<pre><code>func quickSort(inout a: [Int], left: Int, right: Int) {
  if left &gt;= right {
    return
  }

  let baseIndex = partition(&amp;a, left: left, right: right)

  quickSort(&amp;a, left: left, right: baseIndex - 1)
  quickSort(&amp;a, left: baseIndex + 1, right: right)
}

func partition(inout a: [Int], var left: Int, var right: Int) -&gt;Int {
  let base = a[left]
  let baseIndex = left

  while left &lt; right {
    while left &lt; right &amp;&amp; a[right] &gt;= base {
      right--
    }

    while left &lt; right &amp;&amp; a[left] &lt;= base {
      left++
    }

    swapInt(&amp;a, i: left, j: right)
  }

  swapInt(&amp;a, i: baseIndex, j: left)

  return left
}

func swapInt(inout a: [Int], i: Int, j: Int) {
  let temp = a[i]
  a[i] = a[j]
  a[j] = temp
}
</code></pre>

<hr />

<h2>冒泡排序</h2>

<p>算法思路：冒泡排序的核心思想就是通过与相邻元素的比较和交换，把小的数交换到最前面。因为这个过程类似于水泡向上升一样，因此被命名为冒泡排序。</p>

<blockquote><p>冒泡排序需要两个循环来控制遍历，也就是需要n * n趟才能判断、交换完成。</p></blockquote>

<p>冒泡排序的时间复杂度为O ( n2 )。</p>

<p>伪代码</p>

<pre><code>void bubbleSort(int a[], int len) {
   for i = 0; i &lt; len - 1; ++i {
      for j = len - 1; j &gt; i; --j {
         if a[j] &lt; a[j - 1] {
            swap(a, j, j - 1);
         }
      }
   }
}

void swap(int a[], int i, int j) {
   int temp = a[i];
   a[i] = a[j];
   a[j] = temp;
}
</code></pre>

<p>C语言版</p>

<pre><code>void bubbleSortUsingC(int arr[], int len) {
  // 代表走多少趟，最后一趟就不用再走了
  for (int i = 0; i &lt; len - 1; ++i) {

    // 从后往前走，相当于泡从水底冒出来到水面
    for (int j = len - 1; j &gt; i; --j) {

      // 如果后面的比前面一个的值还要小，则需要交换
      if (arr[j] &lt; arr[j - 1]) {
        swap(arr, j, j - 1);
      }
    }
  }
}

void swap(int arr[], int i, int j) {
  int temp = arr[i];
  arr[i] = arr[j];
  arr[j] = temp;
}
</code></pre>

<p>测试一下：</p>

<pre><code>int a[5] = {5,3,8,6,4};

bubbleSortUsingC(a, sizeof(a) / sizeof(int));

for (int i = 0; i &lt; sizeof(a) / sizeof(int); ++i) {
    NSLog(@"%d", a[i]);
}

// 打印: 3, 4, 5, 6, 8 初步如期效果

ObjC版

- (void)bubbleSort:(int [])array len:(size_t)len {
  for (size_t i = 0; i &lt; len - 1; ++i) {
    for (size_t j = len - 1; j &gt; i; --j) {
      if (array[j] &lt; array[j - 1]) {
        // 交换
        int temp = array[j];
        array[j] = array[j - 1];
        array[j - 1] = temp;
      }
    }
  }
}
</code></pre>

<p>测试使用：</p>

<p>int a[5] = {5,3,8,6,4};
[self bubbleSort:a len:sizeof(a) / sizeof(int)];
for (int i = 0; i &lt; sizeof(a) / sizeof(int); ++i) {
    NSLog(@&ldquo;%d&rdquo;, a[i]);
}</p>

<p>Swift版</p>

<pre><code>func bubbleSort(var arr: [Int]) -&gt;[Int] {
  // 走多少趟
  for var i = 0; i &lt; arr.count - 1; ++i {

    // 从后往前
    for var j = arr.count - 1; j &gt; i; --j {

      // 后者 &lt; 前者 ？ 交换 ： 不交换
      if arr[j] &lt; arr[j - 1] {
        let temp = arr[j]

        arr[j] = arr[j - 1]
        arr[j - 1] = temp
      }
    }
  }

  return arr
}
</code></pre>

<p>测试使用：</p>

<pre><code>// 由于swift中数组也是结构体，是值类型，因此需要接收返回值才能得到排序后的数组
var arr = [5, 3, 8, 6, 4]
arr = bubbleSort(arr)
print(arr)

尝试给Model排序

- (void)bubbleSort:(NSMutableArray *)array {
  for (NSUInteger i = 0; i &lt; array.count - 1; ++i) {

    for (NSUInteger j = array.count - 1; j &gt; i; --j) {
      HYBTestModel *modelj = [array objectAtIndex:j];
      HYBTestModel *modelj_1 = [array objectAtIndex:j - 1];

      // 前者 &lt; 后者 ？ 交换 ： 不交换
      if ([modelj.uid compare:modelj_1.uid options:NSCaseInsensitiveSearch] == NSOrderedAscending) {
        [array exchangeObjectAtIndex:j withObjectAtIndex:j - 1];
      }
    }
  }
}
</code></pre>

<p>测试：</p>

<pre><code>NSMutableArray *array = [[NSMutableArray alloc] init];
for (NSUInteger i = 0; i &lt; 10; ++i) {
  HYBTestModel *model = [[HYBTestModel alloc] init];
  model.title = [NSString stringWithFormat:@"标哥的技术博客：%ld", 10 - (i + 1)];
  model.uid = [NSString stringWithFormat:@"%ld", 10 - (i + 1)];

  [array addObject:model];
}

[self bubbleSort:array];

for (HYBTestModel *model in array) {
  NSLog(@"%@ %@", model.uid, model.title);
}
</code></pre>

<p>// 打印:</p>

<pre><code>2016-03-10 22:57:37.524 DataAgorithmDemos[96148:3779265] 0 标哥的技术博客：0
2016-03-10 22:57:37.526 DataAgorithmDemos[96148:3779265] 1 标哥的技术博客：1
2016-03-10 22:57:37.526 DataAgorithmDemos[96148:3779265] 2 标哥的技术博客：2
2016-03-10 22:57:37.526 DataAgorithmDemos[96148:3779265] 3 标哥的技术博客：3
2016-03-10 22:57:37.582 DataAgorithmDemos[96148:3779265] 4 标哥的技术博客：4
2016-03-10 22:57:37.588 DataAgorithmDemos[96148:3779265] 5 标哥的技术博客：5
2016-03-10 22:57:37.589 DataAgorithmDemos[96148:3779265] 6 标哥的技术博客：6
2016-03-10 22:57:37.593 DataAgorithmDemos[96148:3779265] 7 标哥的技术博客：7
2016-03-10 22:57:37.594 DataAgorithmDemos[96148:3779265] 8 标哥的技术博客：8
2016-03-10 22:57:37.596 DataAgorithmDemos[96148:3779265] 9 标哥的技术博客：9
</code></pre>

<p>说明排序正常的~</p>

<h2>选择排序</h2>

<ul>
<li>选择排序:的思想其实和冒泡排序有点类似，都是在一次排序后把最小的元素放到最前面。但是过程不同，冒泡排序是通过相邻的比较和交换。而选择排序是通过对整体的选择</li>
</ul>


<p>算法思想：每一趟从前往后查找出值最小的索引（下标），最后通过比较是否需要交换。每一趟都将最小的元素交换到最前面。</p>

<p>其实选择排序可以看成是冒泡排序的优化，因为其目的相同，只是选择排序只有在确定了最小数的前提下才进行交换，大大减少了交换的次数，而比较次数是一样的。</p>

<blockquote><p>注意：冒泡排序是从后往前扫，使大的往下沉，而小的往上浮；选择排序是从前往后扫，每趟找出值最小的索引，使每趟最小值都交换到该趟的最前面，从而得到升序序列</p></blockquote>

<p>选择排序可以看作冒泡排序的优化版本，一样要两层循环才能排序完成。</p>

<p>所以，选择排序的时间复杂度为O ( n2 )</p>

<p>伪代码</p>

<pre><code>void selectSort(int arr[], int len) {
  int min = 0;

  // 只需要n-1趟即可，到最后一趟只有一个元素，一定是最小的了
  for i = 0; i &lt; len - 1; ++i {

    // 每一趟的开始，假设该趟的第一个元素是最小的
    min = i;

    // 查找该趟有没有更小的，如果找到更小的，则更新最小值的下标
    for j = i + 1; j &lt; len; ++j {
       if arr[j] &lt; arr[min] {
          min = j;
       } 
    }

    // 如果该趟的第一个元素不是最小的，说明需要交换
    if min != i {
       int temp = arr[i];
       arr[i] = arr[min];
       arr[min] = temp;
    }
  }
}
</code></pre>

<p>C语言版</p>

<pre><code>void selectSort(int arr[], int len) {
  int min = 0;

  // 只需要n-1趟
  for (int i = 0; i &lt; len - 1; ++i) {
    min = i;

    // 从第n+1趟起始找到末尾
    for (int j = i + 1; j &lt; len; ++j) {

      // 找到比min位置更小的，就更新这一趟所找到的最小值的位置
      if (arr[j] &lt; arr[min]) {
        min = j;
      }
    }

    // 如果min与i不相等，说明有比i位置更小的，所以需要交换
    if (min != i) {
      int temp = arr[min];
      arr[min] = arr[i];
      arr[i] = temp;
    }
  }
}
</code></pre>

<p>ObjC版</p>

<pre><code>- (void)selectSort:(int [])arr len:(int)len {
  int min = 0;

  // 只需要n-1趟
  for (int i = 0; i &lt; len - 1; ++i) {
    min = i;

    // 从第n+1趟起始找到末尾
    for (int j = i + 1; j &lt; len; ++j) {

      // 找到比min位置更小的，就更新这一趟所找到的最小值的位置
      if (arr[j] &lt; arr[min]) {
        min = j;
      }
    }

    // 如果min与i不相等，说明有比i位置更小的，所以需要交换
    if (min != i) {
      int temp = arr[min];
      arr[min] = arr[i];
      arr[i] = temp;
    }
  }
}
</code></pre>

<p>Swift版</p>

<pre><code>func selectSort(var arr: [Int]) -&gt;[Int] {
  var min = 0

  // 只需要n-1趟
  for var i = 0; i &lt; arr.count - 1; ++i {
    min = i

    // 从第n+1趟起始找到末尾
    for var j = i + 1; j &lt; arr.count; ++j {

      // 找到比min位置更小的，就更新这一趟所找到的最小值的位置
      if arr[j] &lt; arr[min] {
        min = j
      }
    }

    // 如果min与i不相等，说明有比i位置更小的，所以需要交换
    if min != i {
      let temp = arr[i]
      arr[i] = arr[min]
      arr[min] = temp
    }
  }

  return arr
}
</code></pre>

<p>尝试ObjC实现模型选择排序</p>

<pre><code>- (void)selectSort:(NSMutableArray *)array {
  NSUInteger minIndex = 0;

  for (NSUInteger i = 0; i &lt; array.count - 1; ++i) {
    minIndex = i;

    for (NSUInteger j = i + 1; j &lt; array.count; ++j) {
      HYBTestModel *modelj = [array objectAtIndex:j];
      HYBTestModel *model = [array objectAtIndex:minIndex];

      // 比min下的还要小，则更新min
      if ([modelj.uid compare:model.uid options:NSCaseInsensitiveSearch] == NSOrderedAscending) {
        minIndex = j;
      }
    }

    if (minIndex != i) {
      [array exchangeObjectAtIndex:minIndex withObjectAtIndex:i];
    }
  }
}
</code></pre>

<p>测试：</p>

<pre><code>NSMutableArray *array = [[NSMutableArray alloc] init];
for (NSUInteger i = 0; i &lt; 10; ++i) {
  HYBTestModel *model = [[HYBTestModel alloc] init];
  model.title = [NSString stringWithFormat:@"标哥的技术博客：%ld", 10 - (i + 1)];
  model.uid = [NSString stringWithFormat:@"%ld", 10 - (i + 1)];

  [array addObject:model];

}

[self selectSort:array];

for (HYBTestModel *model in array) {
  NSLog(@"%@ %@", model.uid, model.title);
}
</code></pre>

<p>// 打印:</p>

<pre><code>2016-03-11 11:52:47.482 DataAgorithmDemos[97923:4012461] 0 标哥的技术博客：0
2016-03-11 11:52:47.484 DataAgorithmDemos[97923:4012461] 1 标哥的技术博客：1
2016-03-11 11:52:47.484 DataAgorithmDemos[97923:4012461] 2 标哥的技术博客：2
2016-03-11 11:52:47.484 DataAgorithmDemos[97923:4012461] 3 标哥的技术博客：3
2016-03-11 11:52:47.484 DataAgorithmDemos[97923:4012461] 4 标哥的技术博客：4
2016-03-11 11:52:47.484 DataAgorithmDemos[97923:4012461] 5 标哥的技术博客：5
2016-03-11 11:52:47.484 DataAgorithmDemos[97923:4012461] 6 标哥的技术博客：6
2016-03-11 11:52:47.485 DataAgorithmDemos[97923:4012461] 7 标哥的技术博客：7
2016-03-11 11:52:47.487 DataAgorithmDemos[97923:4012461] 8 标哥的技术博客：8
2016-03-11 11:52:47.487 DataAgorithmDemos[97923:4012461] 9 标哥的技术博客：9
</code></pre>

<h2>堆排序</h2>

<p>堆是指二叉堆，二叉堆又称完全二叉树或者叫近似完全二叉树。二叉堆又分为最大堆和最小堆。</p>

<p>堆排序(Heapsort)是指利用堆这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。数组可以根据索引直接获取元素，时间复杂度为O（1），也就是常量，因此对于取值效率极高。</p>

<p>最大堆的特性如下：</p>

<pre><code>父结点的键值总是大于或者等于任何一个子节点的键值
每个结点的左子树和右子树都是一个最大堆
</code></pre>

<p>最小堆的特性如下：</p>

<pre><code>父结点的键值总是小于或者等于任何一个子节点的键值
每个结点的左子树和右子树都是一个最小堆
</code></pre>

<p>堆排序的时间，主要由建立初始堆和反复调整堆这两部分的时间开销构成.由于堆排序是不稳定的，它得扭到的时间复杂度会根据实际情况较大，因此只能取平均时间复杂度。</p>

<p>平均时间复杂度为：O( N * log2(N) )</p>

<p>使用建议：</p>

<pre><code>由于初始化堆需要比较的次数较多，因此，堆排序比较适合于数据量非常大的场合（百万数据或更多）。由于高效的快速排序是基于递归实现的，所以在数据量非常大时会发生堆栈溢出错误。
</code></pre>

<p>基于最大堆实现升序排序</p>

<pre><code>// 初始化堆
void initHeap(int a[], int len) {
  // 从完全二叉树最后一个非子节点开始
  // 在数组中第一个元素的索引是0
  // 第n个元素的左孩子为2n+1，右孩子为2n+2，
  // 最后一个非子节点位置在(n - 1) / 2
  for (int i = (len - 1) / 2; i &gt;= 0; --i) {
    adjustMaxHeap(a, len, i);
  }
}

void adjustMaxHeap(int a[], int len, int parentNodeIndex) {
  // 若只有一个元素，那么只能是堆顶元素，也没有必要再排序了
  if (len &lt;= 1) {
    return;
  }

  // 记录比父节点大的左孩子或者右孩子的索引
  int targetIndex = -1;

  // 获取左、右孩子的索引
  int leftChildIndex = 2 * parentNodeIndex + 1;
  int rightChildIndex = 2 * parentNodeIndex + 2;

  // 没有左孩子
  if (leftChildIndex &gt;= len) {
    return;
  }

  // 有左孩子，但是没有右孩子
  if (rightChildIndex &gt;= len) {
    targetIndex = leftChildIndex;
  }
  // 有左孩子和右孩子
  else {
    // 取左、右孩子两者中最大的一个
    targetIndex = a[leftChildIndex] &gt; a[rightChildIndex] ? leftChildIndex : rightChildIndex;
  }

  // 只有孩子比父节点的值还要大，才需要交换
  if (a[targetIndex] &gt; a[parentNodeIndex]) {
    int temp = a[targetIndex];

    a[targetIndex] = a[parentNodeIndex];
    a[parentNodeIndex] = temp;


    // 交换完成后，有可能会导致a[targetIndex]结点所形成的子树不满足堆的条件，
    // 若不满足堆的条件，则调整之使之也成为堆
    adjustMaxHeap(a, len, targetIndex);
  }
}

void heapSort(int a[], int len) {
  if (len &lt;= 1) {
    return;
  }

  // 初始堆成无序最大堆
  initHeap(a, len);

  for (int i = len - 1; i &gt; 0; --i) {
    // 将当前堆顶元素与最后一个元素交换，保证这一趟所查找到的堆顶元素与最后一个元素交换
    // 注意：这里所说的最后不是a[len - 1]，而是每一趟的范围中最后一个元素
    // 为什么要加上&gt;0判断？每次不是说堆顶一定是最大值吗？没错，每一趟调整后，堆顶是最大值的
    // 但是，由于len的范围不断地缩小，导致某些特殊的序列出现异常
    // 比如说，5, 3, 8, 6, 4序列，当调整i=1时，已经调整为3,4,5,6,8序列，已经有序了
    // 但是导致了a[i]与a[0]交换，由于变成了4,3,5,6,8反而变成无序了!
    if (a[0] &gt; a[i]) {
      int temp = a[0];
      a[0] = a[i];
      a[i] = temp;
    }

    // 范围变成为：
    // 0...len-1
    // 0...len-1-1
    // 0...1 // 结束
    // 其中，0是堆顶，每次都是找出在指定的范围内比堆顶还大的元素，然后与堆顶元素交换
    adjustMaxHeap(a, i - 1, 0);
  }
}
</code></pre>

<p>基于最小堆实现降序排序</p>

<pre><code>// 初始化堆
void initHeap(int a[], int len) {
  // 从完全二叉树最后一个非子节点开始
  // 在数组中第一个元素的索引是0
  // 第n个元素的左孩子为2n+1，右孩子为2n+2，
  // 最后一个非子节点位置在(n - 1) / 2
  for (int i = (len - 1) / 2; i &gt;= 0; --i) {
    adjustMinHeap(a, len, i);
  }
}

void adjustMinHeap(int a[], int len, int parentNodeIndex) {
  // 若只有一个元素，那么只能是堆顶元素，也没有必要再排序了
  if (len &lt;= 1) {
    return;
  }

  // 记录比父节点大的左孩子或者右孩子的索引
  int targetIndex = -1;

  // 获取左、右孩子的索引
  int leftChildIndex = 2 * parentNodeIndex + 1;
  int rightChildIndex = 2 * parentNodeIndex + 2;

  // 没有左孩子
  if (leftChildIndex &gt;= len) {
    return;
  }

  // 有左孩子，但是没有右孩子
  if (rightChildIndex &gt;= len) {
    targetIndex = leftChildIndex;
  }
  // 有左孩子和右孩子
  else {
    // 取左、右孩子两者中最上的一个
    targetIndex = a[leftChildIndex] &lt; a[rightChildIndex] ? leftChildIndex : rightChildIndex;
  }

  // 只有孩子比父节点的值还要小，才需要交换
  if (a[targetIndex] &lt; a[parentNodeIndex]) {
    int temp = a[targetIndex];

    a[targetIndex] = a[parentNodeIndex];
    a[parentNodeIndex] = temp;


    // 交换完成后，有可能会导致a[targetIndex]结点所形成的子树不满足堆的条件，
    // 若不满足堆的条件，则调整之使之也成为堆
    adjustMinHeap(a, len, targetIndex);
  }
}

void heapSort(int a[], int len) {
  if (len &lt;= 1) {
    return;
  }

  // 初始堆成无序最小堆
  initHeap(a, len);

  for (int i = len - 1; i &gt; 0; --i) {
    // 将当前堆顶元素与最后一个元素交换，保证这一趟所查找到的堆顶元素与最后一个元素交换
    // 注意：这里所说的最后不是a[len - 1]，而是每一趟的范围中最后一个元素
    // 为什么要加上&gt;0判断？每次不是说堆顶一定是最小值吗？没错，每一趟调整后，堆顶是最小值的
    // 但是，由于len的范围不断地缩小，导致某些特殊的序列出现异常
    // 比如说，5, 3, 8, 6, 4序列，当调整i=1时，已经调整为3,4,5,6,8序列，已经有序了
    // 但是导致了a[i]与a[0]交换，由于变成了4,3,5,6,8反而变成无序了!
    if (a[0] &lt; a[i]) {
      int temp = a[0];
      a[0] = a[i];
      a[i] = temp;
    }

    // 范围变成为：
    // 0...len-1
    // 0...len-1-1
    // 0...1 // 结束
    // 其中，0是堆顶，每次都是找出在指定的范围内比堆顶还小的元素，然后与堆顶元素交换
    adjustMinHeap(a, i - 1, 0);
  }
}
</code></pre>

<p>C语言版测试</p>

<p>大家可以测试一下：</p>

<pre><code>//  int a[] = {5, 3, 8, 6, 4};
int a[] = {89,-7,999,-89,7,0,-888,7,-7};
heapSort(a, sizeof(a) / sizeof(int));

for (int i = 0; i &lt; sizeof(a) / sizeof(int); ++i) {
    NSLog(@"%d", a[i]);
}
</code></pre>

<p>Swift版实现
基于最大堆实现升序排序</p>

<pre><code>func initHeap(inout a: [Int]) {
  for var i = (a.count - 1) / 2; i &gt;= 0; --i {
    adjustMaxHeap(&amp;a, len: a.count, parentNodeIndex: i)
  }
}

func adjustMaxHeap(inout a: [Int], len: Int, parentNodeIndex: Int) {
  // 如果len &lt;= 0，说明已经无序区已经缩小到0
  guard len &gt; 1 else {
    return
  }

  // 父结点的左、右孩子的索引
  let leftChildIndex = 2 * parentNodeIndex + 1

  // 如果连左孩子都没有， 一定没有右孩子，说明已经不用再往下了
  guard leftChildIndex &lt; len else {
    return
  }

  let rightChildIndex = 2 * parentNodeIndex + 2

  // 用于记录需要与父结点交换的孩子的索引
  var targetIndex = -1

  // 若没有右孩子，但有左孩子，只能选择左孩子
  if rightChildIndex &gt; len {
    targetIndex = leftChildIndex
  } else {
    // 左、右孩子都有，则需要找出最大的一个
    targetIndex = a[leftChildIndex] &gt; a[rightChildIndex] ? leftChildIndex : rightChildIndex
  }

  // 只有孩子比父结点还要大，再需要交换
  if a[targetIndex] &gt; a[parentNodeIndex] {
    let temp = a[targetIndex]

    a[targetIndex] = a[parentNodeIndex]
    a[parentNodeIndex] = temp

    // 由于交换后，可能会破坏掉新的子树堆的性质，因此需要调整以a[targetIndex]为父结点的子树，使之满足堆的性质
    adjustMaxHeap(&amp;a, len: len, parentNodeIndex: targetIndex)
  }
}

func maxHeapSort(inout a: [Int]) {
  guard a.count &gt; 1 else {
    return
  }

  initHeap(&amp;a)

  for var i = a.count - 1; i &gt; 0; --i {
    // 每一趟都将堆顶交换到指定范围内的最后一个位置
    if a[0] &gt; a[i] {
      let temp = a[0]

      a[0] = a[i]
      a[i] = temp
    }
    print(a)
    print(i - 1)
    // 有序区长度+1，而无序区长度-1，继续缩小无序区，所以i-1
    // 堆顶永远是在0号位置，所以父结点调整从堆顶开始就可以了
    adjustMaxHeap(&amp;a, len: i - 1, parentNodeIndex: 0)
    print(a)
  }
}
</code></pre>

<p>基于最小堆降序排序</p>

<pre><code>func initHeap(inout a: [Int]) {
  for var i = (a.count - 1) / 2; i &gt;= 0; --i {
    adjustMinHeap(&amp;a, len: a.count, parentNodeIndex: i)
  }
}

func adjustMinHeap(inout a: [Int], len: Int, parentNodeIndex: Int) {
  // 如果len &lt;= 0，说明已经无序区已经缩小到0
  guard len &gt; 1 else {
    return
  }

  // 父结点的左、右孩子的索引
  let leftChildIndex = 2 * parentNodeIndex + 1

  // 如果连左孩子都没有， 一定没有右孩子，说明已经不用再往下了
  guard leftChildIndex &lt; len else {
    return
  }

  let rightChildIndex = 2 * parentNodeIndex + 2

  // 用于记录需要与父结点交换的孩子的索引
  var targetIndex = -1

  // 若没有右孩子，但有左孩子，只能选择左孩子
  if rightChildIndex &gt; len {
    targetIndex = leftChildIndex
  } else {
    // 左、右孩子都有，则需要找出最大的一个
    targetIndex = a[leftChildIndex] &lt; a[rightChildIndex] ? leftChildIndex : rightChildIndex
  }

  // 只有孩子比父结点还要大，再需要交换
  if a[targetIndex] &lt; a[parentNodeIndex] {
    let temp = a[targetIndex]

    a[targetIndex] = a[parentNodeIndex]
    a[parentNodeIndex] = temp

    // 由于交换后，可能会破坏掉新的子树堆的性质，因此需要调整以a[targetIndex]为父结点的子树，使之满足堆的性质
    adjustMinHeap(&amp;a, len: len, parentNodeIndex: targetIndex)
  }
}

func minHeapSort(inout a: [Int]) {
  guard a.count &gt; 1 else {
    return
  }

  initHeap(&amp;a)

  for var i = a.count - 1; i &gt; 0; --i {
    // 每一趟都将堆顶交换到指定范围内的最后一个位置
    if a[0] &lt; a[i] {
      let temp = a[0]

      a[0] = a[i]
      a[i] = temp
    } else {
       return // 可以直接退出了，因为已经全部有序了
    }

    // 有序区长度+1，而无序区长度-1，继续缩小无序区，所以i-1
    // 堆顶永远是在0号位置，所以父结点调整从堆顶开始就可以了
    adjustMinHeap(&amp;a, len: i - 1, parentNodeIndex: 0)
  }
}
</code></pre>

<p>测试：</p>

<pre><code>var arr = [5, 3, 8, 6, 4]
//var arr = [89,-7,999,-89,7,0,-888,7,-7]
maxHeapSort(&amp;arr)

print(arr)

// 打印日志如下：
[4, 6, 5, 3, 8]
3
[6, 4, 5, 3, 8]

[3, 4, 5, 6, 8]
2
[5, 4, 3, 6, 8]

[3, 4, 5, 6, 8]
1
[3, 4, 5, 6, 8]

[3, 4, 5, 6, 8]
0
[3, 4, 5, 6, 8]

[3, 4, 5, 6, 8]
</code></pre>

<h2>归并排序</h2>

<p>归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</p>

<p>归并排序的效率是比较高的，假设数列长度为N，采用中分法的方式将数列分开成若干个小数列一共要log2N 步，每步都是一个合并有序数列的过程，时间复杂度可以记为O ( N )，故一共为O ( N * log2N )。</p>

<p>因为归并排序每次都是在相邻的数据中进行操作，所以归并排序在常用的几种排序方法（快速排序，归并排序，希尔排序，堆排序）中也是效率比较高的。</p>

<p>时间复杂度：O ( N * log2N )</p>

<p>C语言实现</p>

<pre><code>/**
 *  归并排序算法
 *
 *  @param list   待排序的序列
 *  @param first    子序列的起点索引
 *  @param last   子序列的终点索引
 *  @param temp   临时数组，用于将两个子序列二路归并时存储
 */
void mergeSort(int list[], int first, int last, int temp[]) {
  if (first &lt; last) {
    int mid = (first + last) / 2;

    // 递归归并中分左子序列，使子序列有序
    mergeSort(list, first, mid, temp);

    // 递归归并中分右子序列，使子序列有序
    mergeSort(list, mid + 1, last, temp);

    // 最后二路归并，使序列成有序
    // 必须明白的一点，每次中分递归归并都需要二路归并，因为中分后的任意子序列
    // 在有序后，都要二路归并成一个序列
    mergeList(list, first, mid, last, temp);
  }
}

/**
 *  二路归并list[first...mid]子序列与list[mid+1...last]
 *
 *  @param list 序列
 *  @param first    左子序列的起点
 *  @param mid      序列中间分割点
 *  @param last 右序列终点
 *  @param temp 临时序列，用于将两个无序的子序列归并到temp中，使之有序
 */
void mergeList(int list[], int first, int mid, int last, int temp[]) {
  int leftIndex = first;
  int leftEndIndex = mid;

  int rightIndex = mid + 1;
  int rightEndIndex = last;

  int tempIndex = 0;

  // 寻找两个子序列，顺序遍历，将值小的复制到临时数组中，直到其中一个子序列遍历完毕
  while (leftIndex &lt;= leftEndIndex &amp;&amp; rightIndex &lt;= rightEndIndex) {
    // 值小的就复制到临时数组中
    if (list[leftIndex] &lt;= list[rightIndex]) {
      temp[tempIndex] = list[leftIndex];
      tempIndex++;
      leftIndex++;
    } else {
      temp[tempIndex] = list[rightIndex];
      tempIndex++;
      rightIndex++;
    }
  }

  // 有可能左子序列更长，因此将剩下的部分直接复制到临时数组中
  while (leftIndex &lt;= leftEndIndex) {
    temp[tempIndex++] = list[leftIndex++];
  }

  // 有可能右子序列更长，因此将剩下的部分直接复制到临时数组中
  while (rightIndex &lt;= rightEndIndex) {
    temp[tempIndex++] = list[rightIndex++];
  }

  // 最后还需要将有序的临时数组复制到原始序列中
  for (int i = 0; i &lt; tempIndex; ++i) {
    list[first + i] = temp[i];
  }

 // 这里添加一个打印，记录归并
 NSMutableString *str = [[NSMutableString alloc] init];
  for (int i = 0; i &lt; sizeof(list) - 1; ++i) {
    if (i == 0) {
      [str appendFormat:@"%d", list[i]];
    } else {
      [str appendFormat:@", %d", list[i]];
    }
  }
  NSLog(@"此次二路归并后，得到的序列为：(%@)", str);
}
</code></pre>

<p>测试：</p>

<pre><code>int list[] = {6, 202, 100, 301, 38, 8, 1};
int temp[7] = {0};
mergeSort(list, 0, 7-1, temp);
</code></pre>

<p>打印效果：</p>

<pre><code>此次二路归并后，得到的序列为：(6, 202, 100, 301, 38, 8, 1)
此次二路归并后，得到的序列为：(6, 202, 100, 301, 38, 8, 1)
此次二路归并后，得到的序列为：(6, 100, 202, 301, 38, 8, 1)
此次二路归并后，得到的序列为：(6, 100, 202, 301, 8, 38, 1)
此次二路归并后，得到的序列为：(6, 100, 202, 301, 1, 8, 38)
此次二路归并后，得到的序列为：(1, 6, 8, 38, 100, 202, 301)
</code></pre>

<p>从打印结果可以看出来，果然与我们前面的算法分析是一样的。</p>

<h2>插入排序</h2>

<p>插入排序有两种：</p>

<pre><code>直接插入排序
折半插入排序
</code></pre>

<p>原理：</p>

<pre><code>第一个元素就认为是有序的
取第二个元素，判断是否大于第一个元素。若是大于，表示已经有序，不用移动，否则将已经有序的序列整体向后移动一个位置
依此类推，直到所有元素已经有序。
</code></pre>

<p>直接插入排序</p>

<p>需要到两层循环来处理，外层循环用于跑多少趟，而内层循环用于移动元素位置，因此时间复杂度仍为 O ( n2 )</p>

<p>伪代码</p>

<pre><code>void insertSort(int a[], int len) {
  for i = 1; i &lt; len; ++i {     
     // 后者&gt;前者，才需要移动和插入
     if a[i] &lt; a[i - 1] {
        // 记录下要移动的元素
        int target = a[i];

        // 将前j-1个有序的元素分别后移一个位置
        int j = i;
        while j &gt; 0 &amp;&amp; a[j - 1] &gt; target {
          a[j] = a[j - 1];
          j--;
        }

        // 将目标元素插入对应的位置，使之有序
        a[j] = target;
     }
  }
}
</code></pre>

<p>C语言版</p>

<pre><code>void insertSort(int a[], int len) {
  for (int i = 1; i &lt; len; ++i) {

    // 遇到不是有序的，才进入移动元素
    if (a[i] &lt; a[i - 1]) {
      int target = a[i];

      // 移动前j-1元素，分别向后移动一个位置
      int j = i;
      while (j &gt; 0 &amp;&amp; a[j - 1] &gt; target) {
        a[j] = a[j - 1];

        j--;
      }

      // 将目标元素放到目标位置，使之有序
      a[j] = target;
    }
  }
}
</code></pre>

<p>OjbC版</p>

<pre><code>- (void)insertSort:(int[])a len:(int)len {
  for (int i = 1; i &lt; len; ++i) {

    // 遇到不是有序的，才进入移动元素
    if (a[i] &lt; a[i - 1]) {
      int target = a[i];

      // 移动前j-1元素，分别向后移动一个位置
      int j = i;
      while (j &gt; 0 &amp;&amp; a[j - 1] &gt; target) {
        a[j] = a[j - 1];

        j--;
      }

      // 将目标元素放到目标位置，使之有序
      a[j] = target;
    }
  }
}
</code></pre>

<p>Swift版</p>

<pre><code>func insertSort(var a: [Int]) -&gt;[Int] {
  for var i = 1; i &lt; a.count; ++i {
    if a[i] &lt; a[i - 1] {
      let target = a[i]

      var j = i
      while j &gt; 0 &amp;&amp; a[j - 1] &gt; target {
        a[j] = a[j - 1]

        j--
      }

      a[j] = target
    }
  }

  return a
}
</code></pre>

<p>折半插入排序</p>

<p>从第二个元素开始逐个置入监视哨，使用low、high标签进行折半判断比较大小，并确认插入位置，该位置到最后一个数全部后移一位，然后腾出该位置，把监视哨里面的数置入该位置。依此类推进行排序，直到最后一个数比较完毕。
时间复杂度</p>

<p>折半插入排序, 即查找插入点的位置, 可以使用折半查找，这样可以减少比较的次数, 但是移动的次数不变，因此，时间复杂度仍为 O(n2) ;
伪代码</p>

<pre><code>void binaryInsertSort(int a[], int len) {
  for int i = 2; i &lt; len; ++i {
     // 将元素放到哨兵的位置
     a[0] = a[i];

     int low = 1;
     int high = i - 1;

     // 折半查找位置
     while low &lt;= high {
        int mid = (low + high) / 2;

        // 在低半区
        if a[mid] &gt; a[0] {
          high = mid - 1;
        } else { // 在高半区
          low = mid + 1;
        }
     }

     // 将前i - 1个元素后移
     // 找到high，那么high+1就是i要插入的位置  
     for int j = i - 1; j &gt;= high + 1; --j {
        a[j + 1] = a[j];
     }

     // 将临时放在岗哨的元素放到所查找到的位置处
     a[high + 1] = a[0];
  }
}
</code></pre>

<p>C语言版</p>

<pre><code>void binaryInsertSort(int a[], int len) {
  for (int i = 2; i &lt; len; ++i) {
    // 第一个位置永远只是当作哨兵用
    a[0] = a[i];

    int low = 1;
    int high = i - 1;

    while (low &lt;= high) {
      int mid = (low + high) / 2;

      if (a[mid] &gt; a[0]) {
        high = mid - 1;
      } else {
        low = mid + 1;
      }
    }

    // 移动前i - 1个元素
    for (int j = i - 1; j &gt;= high + 1; --j) {
      a[j + 1] = a[j];
    }

    // 放到查找到的位置处
    a[high + 1] = a[0];
  }
}
</code></pre>

<p>Swift版</p>

<pre><code>func binaryInsertSort(var a: [Int]) -&gt;[Int] {
  for var i = 2; i &lt; a.count; ++i {
    a[0] = a[i]

    var low = 1
    var high = i - 1
    while low &lt;= high {
      let mid = (low + high) / 2

      if a[mid] &gt; a[0] {
        high = mid - 1
      } else {
        low = mid + 1
      }
    }

    for var j = i - 1; j &gt;= high + 1; --j {
      a[j + 1] = a[j]
    }

    a[high + 1] = a[0]
  }

  return a
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[修行篇-数据结构]]></title>
    <link href="http://al1020119.github.io/blog/2016/08/15/xiu-xing-pian-shu-ju-jie-gou/"/>
    <updated>2016-08-15T12:30:55+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/08/15/xiu-xing-pian-shu-ju-jie-gou</id>
    <content type="html"><![CDATA[<p>概念：数据元素相互之间的关系称为结构。</p>

<p>有四类基本结构：集合、线性结构、树形结构、图状结构;</p>

<ul>
<li><p>集合结构:除了同属于一种类型外，别无其它关系</p></li>
<li><p>线性结构:元素之间存在一对一关系常见类型有: 数组,链表,队列,栈,它们之间在操作上有所区别.例如:链表可在任意位置插入或删除元素,而队列在队尾插入元素,队头删除元素,栈只能在栈顶进行插
入,删除操作.</p></li>
<li><p>树形结构:元素之间存在一对多关系,常见类型有:树(有许多特例:二叉树、平衡二叉树、查找树等)</p></li>
<li><p>图形结构:元素之间存在多对多关系,图形结构中每个结点的前驱结点数和后续结点多个数可以任意</p></li>
</ul>


<p>总结+实战+方案</p>

<ol>
<li>堆</li>
<li>栈</li>
<li>树（二叉树）</li>
<li>图</li>
<li>队列（循环队列）</li>
<li>表（单链表，线性表，hash表）</li>
</ol>


<!--more-->


<h2>堆</h2>

<blockquote><p>堆(heap)又被为优先队列(priority queue)。</p></blockquote>

<p>尽管名为优先队列，但堆并不是队列。回忆一下，在队列中，我们可以进行的限定操作是dequeue和enqueue。dequeue是按照进入队列的先后顺序来取出元素。而在堆中，我们不是按照元素进入队列的先后顺序取出元素的，而是按照元素的优先级取出元素。</p>

<ul>
<li><p>堆是实现调度器(Linux:使用nice控制)的理想数据结构。</p></li>
<li><p>插入元素，删除最大优先级元素</p></li>
<li><p>堆的一个经典的实现是完全二叉树(complete binary tree)。这样实现的堆成为二叉堆(binary heap)。</p></li>
</ul>


<p>完全二叉树是增加了限定条件的二叉树。假设一个二叉树的深度为n。为了满足完全二叉树的要求，该二叉树的前n-1层必须填满，第n层也必须按照从左到右的顺序被填满</p>

<h2>栈</h2>

<blockquote><p>特性：后进先出</p></blockquote>

<h6>注意：如果栈为空的时候，会导致下溢</h6>

<p>栈中的每个元素称为一个frame。而最上层元素称为top frame。栈只支持三个操作， pop, top, push。</p>

<pre><code>pop取出栈中最上层元素(8)，栈的最上层元素变为早先进入的元素(9)。

top查看栈的最上层元素(8)。

push将一个新的元素(5)放在栈的最上层。
</code></pre>

<p>实现方式</p>

<ul>
<li>数组实现：需要一个变量来标记栈顶位置</li>
<li>链表实现：插入元素时对表头操作需要注意</li>
</ul>


<p>常见题目</p>

<ul>
<li>括号匹配</li>
<li>翻转字符串</li>
<li>模拟递归（N皇后问题）</li>
</ul>


<p>栈最经典的计算机应用是函数调用。每个进程都会有一个栈，每个frame中记录了调用函数的参数，自动变量和返回地址。当该函数调用一个新的函数时，栈中会 push一个frame。当函数执行完毕返回时，该frame会pop，从而进入调用该函数的原函数，继续执行</p>

<p>+由于栈是限定了操作的有序的元素集合，所以我们既可以在数组的基础上来实现栈，也可以在表的基础上来实现栈。如果使用数组来实现栈，我们需要预留充足的空间供栈使用，并需要一个下标来记录最上层元素的位置</p>

<h2>树</h2>

<blockquote><p>树(Tree)是元素的集合</p></blockquote>

<p>严格的定义树的方法：</p>

<ol>
<li><p>树是元素的集合。</p></li>
<li><p>该集合可以为空。这时树中没有元素，我们称树为空树 (empty tree)。</p></li>
<li><p>如果该集合不为空，那么该集合有一个根节点，以及0个或者多个子树。根节点与它的子树的根节点用一个边(edge)相连。</p></li>
</ol>


<p>上面的第三点是以递归的方式来定义树，也就是在定义树的过程中使用了树自身(子树)。由于树的递归特征，许多树相关的操作也可以方便的使用递归实现</p>

<ul>
<li><p>二叉树(binary)是一种特殊的树。二叉树的每个节点最多只能有2个子节点</p></li>
<li><p>二叉搜索树(binary search tree)的特殊二叉树。二叉搜索树要求：每个节点都不比它左子树的任意元素小，而且不比它的右子树的任意元素大</p>

<p>  叉搜索树可以方便的实现搜索算法。在搜索元素x的时候，我们可以将x和根节点比较:</p>

<ol>
<li><p>如果x等于根节点，那么找到x，停止搜索 (终止条件)</p></li>
<li><p>如果x小于根节点，那么搜索左子树</p></li>
<li><p>如果x大于根节点，那么搜索右子树</p></li>
</ol>


<p>  二叉搜索树所需要进行的操作次数最多与树的深度相等。n个节点的二叉搜索树的深度最多为n，最少为log(n)。</p></li>
</ul>


<h2>图</h2>

<p>图(graph)是一种比较松散的数据结构。它有一些节点(vertice)，在某些节点之间，由边(edge)相连。节点的概念在树中也出现过，我们通常在节点中储存数据。边表示两个节点之间的存在关系。在树中，我们用边来表示子节点和父节点的归属关系。树是一种特殊的图，但限制性更强一些</p>

<ul>
<li>定义：图G=(V,E)是由节点的集合V和边的集合E构成的。一个图的所有节点构成一个集合V。一个边可以表示为(v1,v2)，其中v1,v2∈V，即两个节点。如果(v1,v2)有序，即(v1,v2)与(v2,v1)不同，那么图是有向的(directed)。有序的边可以理解为单行道，只能沿一个方向行进。如果(v1,v2)无序，那么图是无向的(undirected)。无序的边可以理解成双向都可以行进的道路。一个无序的边可以看作连接相同节点的两个反向的有序边，所以无向图可以理解为有向图的一种特殊情况</li>
</ul>


<p>一种简单的实现图的方法是使用二维数组</p>

<blockquote><p>图的组织方式比较松散，自由度比较大，但也造成比较高的算法复杂度</p></blockquote>

<h2>队列</h2>

<blockquote><p>队列最大的特征是First In, First Out (FIFO，先进先出)</p></blockquote>

<p>队列(queue)是一个简单而常见的数据结构。队列也是有序的元素集合。</p>

<ul>
<li>队首的元素离开队列(dequeue)，和新元素加入队尾(enqueue)。</li>
</ul>


<p>应用</p>

<ul>
<li>一个经典的应用是消息队列(参考Linux进程间通信)，实际上就是利用队列来分配有限的进程。</li>
<li>还有FIFO文件(哦，你可以看到，这种文件叫做FIFO，肯定是和队列有关)，用以实现管道传输。</li>
<li>再比如，我们将多个打印任务发送给打印机，打印机也是使用队列来安排任务的顺序</li>
</ul>


<p>和栈相似，队列也可以有多种实现方式，这里是基于单链表的实现。</p>

<p>与表(list)中的实现方式略有不同的是，这里的head node有两个指针，一个(next)指向下一个元素，一个(end)指向队列的最后一个元素。这样做的目的是方便我们找到队尾，以方便的进行enqueue操作。我们依然可以使用之前定义的表，在需要找到队尾的时候遍历搜索到最后一个元素。</p>

<h2>表</h2>

<blockquote><p>内存中离散分布的有序节点</p></blockquote>

<p>表(list)是常见的数据结构。从数学上来说，表是一个有序的元素集合。在C语言的内存中，表储存为分散的节点(node)。每个节点包含有一个元素，以及一个指向下一个(或者上一个)元素的指针</p>

<p>图中的表中有四个节点。第一个节点是头节点(head node)，这个节点不用于储存元素，只用于标明表的起始。头节点可以让我们方便的插入或者删除表的第一个元素。整个表中包含有三个元素(5， 2， 15)。每个节点都有一个指针，指向下一个节点。最后一个节点的指针为NULL，我们用“接地”来图示该指针。</p>

<ul>
<li><p>表的功能与数组(array)很类似，数组也是有序的元素集合，但数组在内存中为一段连续内存，而表的每个节点占据的内存可以是离散的。在数组中，我们通过跳过固定的内存长度来寻找某个编号的元素。但在表中，我们必须沿着指针联系起的长链，遍历查询元素。此外，数组有固定的大小，表可以根据运行情况插入或者删除节点，动态的更改大小。表插入节点时需要从进程空间的堆中开辟内存空间，用以储存节点。删除节点可以将节点占据的内存归还给进程空间</p></li>
<li><p>表有多种变种。上面的表中，指针指向是从前向后的，称为单向链表(linked list)。</p></li>
<li>还有双向链表(double-linked list)，即每个节点增加一个指向前面一个元素的指针。</li>
<li>以及循环链表(tabular list)，最后一个元素的指针并不为NULL，而是指向头节点。不同类型的链表有不同的应用场景。</li>
</ul>


<p>一个数据结构的实现有两方面:</p>

<ol>
<li>数据结构的内存表达方式;</li>
<li>定义在该数据结构上的操作。</li>
</ol>


<p>我们这里实现最简单的单向链表</p>

<h2>哈希表</h2>

<p>哈希表(hash table)是从一个集合A到另一个集合B的映射(mapping)。映射是一种对应关系，而且集合A的某个元素只能对应集合B中的一个元素。但反过来，集合B中的一个元素可能对应多个集合A中的元素。如果B中的元素只能对应A中的一个元素，这样的映射被称为一一映射</p>

<p>hash只要求从A到B的对应为一个映射，它并没有限定该对应关系为一一映射。</p>

<ul>
<li>因此会有这样的可能：两个不同的键值对应同一个hash值。这种情况叫做hash碰撞(hash collision)。</li>
<li>比如网络协议中的checksum就可能出现这种状况，即所要校验的内容与原文并不同，但与原文生成的checksum(hash值)相同。</li>
<li>再比如，MD5算法常用来计算密码的hash值。已经有实验表明，MD5算法有可能发生碰撞，也就是不同的明文密码生成相同的hash值，这将给系统带来很大的安全漏洞</li>
</ul>


<p>hash表被广泛的用于搜索（区别去数组：遍历整数组，算法复杂度为n），算法复杂度为1</p>

<pre><code>数组虽然可以随机读取，但数组下标是随机的，它与元素值没有任何关系，所以我们要逐次访问各个元素。通过hash函数，我们限定了每个下标位置可能存储的元素。这样，我们利用键值和hash函数，就可以具备相当的先验知识，来选择适当的下标进行搜索。在没有hash碰撞的前提下，我们只需要选择一次，就可以保证该下标指向的元素是我们想要的元素
</code></pre>

<p>hash函数需要解决hash冲突的问题。</p>

<pre><code>比如，上面的hash函数中，"Obama"和"Oaamb"有相同的hash值一个方案是将发生冲突的记录用链表储存起来，让hash值指向该链表，这叫做open hashing:
</code></pre>

<ul>
<li><p>我们在搜索的时候，先根据hash值找到链表，再根据key值遍历搜索链表，直到找到记录。我们可以用其他数据结构代替链表。</p></li>
<li><p>open hashing需要使用指针。我们有时候想要避免使用指针，以保持随机存储的优势，所以采用closed hashing的方式来解决冲突。（closed hashing的关键在如何探测下一个位置）</p></li>
</ul>


<hr />

<p>说在最后
一、栈：</p>

<pre><code>1、后缀表达式的求值； 
2、中缀到后缀表达式的转换； 
3、深度优先搜索的非递归实现； 
4、动态规划的优化：用于维护一个凸序列，便于二分查找，如LIS问题的O(nlgn)算法。 
</code></pre>

<p>二、队列：</p>

<pre><code>1、树的层序遍历； 
2、广度优先搜索； 
3、Bellman-Ford算法的SPFA实现； 
4、网络流中FF算法的Edmonds-Karp实现，以及Preflow算法的队列优化实现。 
</code></pre>

<p>三、二叉搜索树：</p>

<pre><code>1、对大量的关键字的索引查找； 
2、有很多平衡策略以改善其平均性能： 
</code></pre>

<p>常用平衡树：AVL，红黑树，随机化BST，Splay Tree，Treap（或叫笛卡儿树）。</p>

<p>四、散列表（hash表）：</p>

<pre><code>1、一般针对值域较大但状态很稀疏的应用，比如状态压缩记忆化搜索； 
2、实现映射功能。 
</code></pre>

<p>五、检索树（Trie）：</p>

<pre><code>1、一般用于字符串索引算法，速度快，但占用空间较大（相对hash）； 
2、常用的改进结构：Patricia线索树，多叉检索树（TST）。 
</code></pre>

<p>六、优先队列：</p>

<pre><code>1、常用的是二叉堆的实现，具体应用如堆排序和Dijkstra算法； 
2、当需要快速合并两个优先队列时，常用二项式队列，实现简单。 
3、注意最大最小堆的配对使用。 
</code></pre>

<p>七、线段树和树状数组：</p>

<pre><code>1、两者都可以用于离散对象的统计； 
2、后者的步进函数的性质和应用值得注意； 
3、前者基本上适用于任何的区间操作，如求区间最值，改变区间的值等。 
4、线段树还可以用于优化状态的枚举，经常和动态规划结合。 
</code></pre>

<p>八、后缀树与后缀数组：</p>

<pre><code>1、总体规律是两者的实现都比较复杂，前者更甚，但是前者的功能也更强大； 
2、几乎可以解决所有常见的关于字符串的算法，如最长回文子串，最长重复子串，以及很多的模式匹配问题。 
</code></pre>

<p>九、并查集：</p>

<pre><code>1、解决无向图的连通性问题，如用于Kruskal算法； 
2、解决等价关系的查询（这是它的主要用武之地），如05年Baidu之星初赛的石头剪子布游戏； 
3、优点是实现异常简单，缺点是合并后无法分离，若需要可以选择用动态树。 
</code></pre>

<p>十、邻接表和边表：</p>

<pre><code>1、表示图的最直接的方法； 
2、后者更省空间，并且在一定程度上更好用，比如Bellman-Ford算法。 
</code></pre>

<p>ps:数组、链表太基础不在考虑之列。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[修行篇-探程序之精华]]></title>
    <link href="http://al1020119.github.io/blog/2016/08/08/oneday/"/>
    <updated>2016-08-08T23:53:19+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/08/08/oneday</id>
    <content type="html"><![CDATA[<blockquote><p>做了这么久ios开发，由于最近发现自己在性能和底层相关方面，还有有待提高，一句话总结就是：知其然，而不知其所以然。</p></blockquote>

<p>最近也一直在研究相关方面的技术，包括ios相关技术的底层实现，但是这还是远远不够的，一个真正的程序员是必须做到“学无止境”。</p>

<p>经过这几年的开发与学习，包括和同行朋友的了解，作为一个程序员，必备的技术有以下四种。</p>

<ul>
<li>算法</li>
<li>数据结构

<ul>
<li>程序=算法+数据结构</li>
</ul>
</li>
<li>设计模式</li>
<li>数据库</li>
</ul>


<!--more-->


<p>当然可能还有其他的，比如操作系统，软件工程，当然C语音是不能再基础的基础，但是除了上面四点，笔者可能不会专门去研究，最多作为了解。</p>

<blockquote><p>从今天开始，我将从上面四点开始人生的第二次攀爬，希望能爬到一个属于我自己的高峰，也希望能对和我有意义心态的人有所帮助。</p></blockquote>

<h4>路线</h4>

<ol>
<li>算法，数据结构，设计模式，数据库，相关概念的介绍与理解(可能会有部分的软件工程和操作系统相关)</li>
<li>简单代码演示以便更加深刻理解</li>
<li>实际应用以便更加深入理解</li>
<li>举一反三</li>
<li>相关总结</li>
</ol>


<hr />

<p>更新中，敬请关注。。。。。。</p>

<pre><code>Q Q：2211523682/790806573

微信：18370997821/13148454507

微博WB:http://weibo.com/u/3288975567?is_hot=1

git博文：http://al1020119.github.io/

github：https://github.com/al1020119
</code></pre>

<p><img src="http://al1020119.github.io/images/iCocosCoder.jpg" title="Caption" ></p>

<p><img src="http://al1020119.github.io/images/iCocosPublic.jpg" title="Caption" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS开发各种底层实现--包你满意😘！]]></title>
    <link href="http://al1020119.github.io/blog/2016/08/01/gezhongdicenshixian/"/>
    <updated>2016-08-01T23:30:19+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/08/01/gezhongdicenshixian</id>
    <content type="html"><![CDATA[<p>iOS开发常用技术底层实现（精简概述）</p>

<p>本章将对ios开发技术底层实现的总结，其实关于ios开发中各种底层的实现，网上相关文章多到数不过来，而不且非常不错，我也没有自信我能比他们做的更好，因为毕竟每个人专研的东西不一样，本文主要正对三类用户！</p>

<ol>
<li>资深的ios开发者，对底层做过专门研究，但是没有一个系统整理，或者说不能很清楚的表达。</li>
<li>ios开发初学者，没有专门研究过底层或者相关源码的初学者，但是不太建议一开始就看，因为如果你没有过一点接触，看了也看不懂，或者看了也白看，最多就是留个印象在脑子了，对初学者来说，切记不能靠背或者了解，而且细细研究每一个技术点，再慢慢深入挖掘。</li>
<li>ios开发待业程序员（面试）专用，不管你有没有接触过ios开发相关的底层，只要你是在准备找工作的程序员，我相信你看了绝对有用，但是并不能正面你就真的理解了，所以希望这对你来说只是短暂的，后续得花大量时间去专门研究才能在这条路上走得更远，不然你永远只是个码农！</li>
</ol>


<p>好了，废话也不多说了，我们开始吧。。。。。</p>

<h6>系统篇</h6>

<ul>
<li>内存管理</li>
<li>Runtime</li>
</ul>


<h6>事件篇</h6>

<ul>
<li>事件传递</li>
<li>事件响应</li>
</ul>


<h6>代码篇</h6>

<ul>
<li>Block</li>
<li>__Block</li>
</ul>


<!--more-->


<h6>实战</h6>

<ul>
<li>KVO</li>
<li>KVC</li>
</ul>


<h6>高级</h6>

<ul>
<li>GCD</li>
</ul>


<h6>全栈篇</h6>

<ul>
<li>JSPatch</li>
<li>React Native</li>
</ul>


<h6>必备篇</h6>

<ul>
<li>多线程</li>
<li>网络</li>
<li>数据持久化</li>
</ul>


<h6>通用篇</h6>

<ul>
<li>数组</li>
<li>字典</li>
<li>集合</li>
</ul>


<h6>#写在最后</h6>

<hr />

<h1>系统篇</h1>

<hr />

<h3>内存管理</h3>

<ul>
<li><p>黄金法则</p>

<ul>
<li>如果一个对象使用了alloc，[mutable] copy，retain，那么你必须使用相应的release或autonrelease</li>
</ul>
</li>
</ul>


<p>MRC:</p>

<pre><code> 手动管理内存（retain, release, autorelease,不多说） 持有对象,retain +1 ,引用计数加1, 释放对象:release -1, 引用计数减1,当引用计数为0时,会自动释放内存.  autorelease对象内存的管理放到autoreleasepool中, 当pool drain时,回收内存. (这是基于 objective-c的运行时特性和垃圾回收机制)
</code></pre>

<p>ARC:</p>

<pre><code> 手动管理内存, 这是xcode4.x版本的特性,(4.1及以前没有,我从4.6开始的), 原理是:在编译代码的时候为你自动在合适的位置插入release 和 autorelease, (运行时处理垃圾回收就如何MRC一样).
</code></pre>

<p>总结: ARC机制拥有和MRC一样的效率, ARC通过在部分优化和在最合适的地方完成引用计数的维护,所以支持使用ARC.</p>

<p>规则</p>

<p>规则：</p>

<ul>
<li><p>1、Objective-C类中实现了引用计数器，对象知道自己当前被引用的次数</p></li>
<li><p>2、最初对象的计数器为1</p></li>
<li><p>3、如果需要引用对象，可以给对象发送一个retain消息，这样对象的计数器就加1</p></li>
<li><p>4、当不需要引用对象了，可以给对象发送release消息，这样对象计数器就减1</p></li>
<li><p>5、当计数器减到0，自动调用对象的dealloc函数，对象就会释放内存</p></li>
<li><p>6、计数器为0的对象不能再使用release和其他方法</p></li>
</ul>


<h3>Runtime</h3>

<p>一套纯低层的C语言库
平时我们编写的OC代码都会转成Runtime去执行</p>

<p>特性：</p>

<pre><code>动态类型：程序直到执行时才能确定所属的类。

动态绑定：程序直到执行时才能确定实际要调用的方法。

动态加载：根据需求加载所需要的资源
</code></pre>

<p>Runtime消息机制</p>

<p>首先通过obj的isa指针找到obj对应的class。</p>

<ul>
<li>首先检测这个 selector 是不是要忽略。比如 Mac OS X 开发，有了垃圾回收就不理会 retain，release 这些函数。</li>
<li>检测这个 selector 的 target 是不是 nil，Objc 允许我们对一个 nil 对象执行任何方法不会 Crash，因为运行时会被忽略掉。</li>
<li>如果上面两步都通过了，那么就开始查找这个类的实现 IMP，</li>
<li>在Class中先去cache中 通过SEL查找对应函数method，找到就执行对应的实现。</li>
<li>若cache中未找到，再去methodList中查找，找到就执行对应的实现。</li>
<li>若methodlist中未找到，则取superClass中查找（重复执行以上两个步骤），直到找到最根的类为止。</li>
<li>若任何一部能找到，则将method加 入到cache中，以方便下次查找，并通过method中的函数指针跳转到对应的函数中去执行。</li>
<li>如果以上都不能找到，则会开始进行消息转发</li>
</ul>


<p>消息转发</p>

<ul>
<li>1.动态方法解析：向当前类发送 resolveInstanceMethod: 信号，检查是否动态向该类添加了方法。（迷茫请搜索：@dynamic）</li>
<li>2.快速消息转发：检查该类是否实现了 forwardingTargetForSelector: 方法，若实现了则调用这个方法。若该方法返回值对象非nil或非self，则向该返回对象重新发送消息。</li>
<li>3.标准消息转发：runtime发送methodSignatureForSelector:消息获取Selector对应的方法签名。返回值非空则通过forwardInvocation:转发消息，返回值为空则向当前对象发送doesNotRecognizeSelector:消息，程序崩溃退出</li>
</ul>


<p>总结就是：
在一个函数找不到时，OC提供了三种方式去补救：</p>

<ul>
<li>1、调用resolveInstanceMethod给个机会让类添加这个实现这个函数</li>
<li>2、调用forwardingTargetForSelector让别的对象去执行这个函数</li>
<li>3、调用forwardInvocation（函数执行器）灵活的将目标函数以其他形式执行。
如果都不中，调用doesNotRecognizeSelector抛出异常。</li>
</ul>


<hr />

<h1>事件篇</h1>

<h3>应用如何找到最合适的控件来处理事件？</h3>

<pre><code>1.首先判断主窗口（keyWindow）自己是否能接受触摸事件
2.判断触摸点是否在自己身上
3.子控件数组中从后往前遍历子控件，重复前面的两个步骤（所谓从后往前遍历子控件，就是首先查找子控件数组中最后一个元素，然后执行1、2步骤）
4.view，比如叫做fitView，那么会把这个事件交给这个fitView，再遍历这个fitView的子控件，直至没有更合适的view为止。
5.如果没有符合条件的子控件，那么就认为自己最合适处理这个事件，也就是自己是最合适的view
</code></pre>

<h2>事件的传递和响应的区别：</h2>

<ul>
<li>事件的传递是从上到下（父控件到子控件），事件的响应是从下到上（顺着响应者链条向上传递：子控件到父控件。</li>
</ul>


<h3>事件响应</h3>

<h5>响应者链的事件传递过程:</h5>

<pre><code>1&gt;如果当前view是控制器的view，那么控制器就是上一个响应者，事件就传递给控制器；如果当前view不是控制器的view，那么父视图就是当前view的上一个响应者，事件就传递给它的父视图
2&gt;在视图层次结构的最顶级视图，如果也不能处理收到的事件或消息，则其将事件或消息传递给window对象进行处理
3&gt;如果window对象也不处理，则其将事件或消息传递给UIApplication对象
4&gt;如果UIApplication也不能处理该事件或消息，则将其丢弃
</code></pre>

<h3>事件传递</h3>

<h5>事件处理的整个流程总结：</h5>

<pre><code>　　1.触摸屏幕产生触摸事件后，触摸事件会被添加到由UIApplication管理的事件队列中（即，首先接收到事件的是UIApplication）。
　　2.UIApplication会从事件队列中取出最前面的事件，把事件传递给应用程序的主窗口（keyWindow）。
　　3.主窗口会在视图层次结构中找到一个最合适的视图来处理触摸事件。（至此，第一步已完成)
　　4.最合适的view会调用自己的touches方法处理事件
　　5.touches默认做法是把事件顺着响应者链条向上抛。
</code></pre>

<hr />

<h1>代码篇</h1>

<hr />

<h3>Block的底层实现</h3>

<p>一句话:</p>

<pre><code>栈地址和对地址值的拷贝

block就是一个里面存储了指向函数体中包含定义block时的代码块的函数指针，以及block外部上下文变量等信息的结构体。
</code></pre>

<p>Block结构体中含有isa指针，这就证明了Block其实就是对象，并具有一般对象的所有功能。这个isa指针被初始化为 <em>NSConcreteStackBlock 或者 </em>NSConcreteGlobalBlock 类的地址。在没有开启ARC的情况下，如果Block中包含有局部变量则isa被初始化为前者，否则就被初始化为后者。而当ARC开启后，如果Block中包含有局部变量则isa被初始化为 <em>NSConcreteMallocBlock ，否则就被初始化为 </em>NSConcreteGlobalBlock 。invoke是一个函数指针，它指向的是Block被转换成函数的地址。最后的imported variables部分是Block需要访问的外部的局部变量，他们在编译就会被拷贝到Block中，这样一来Block就是成为一个闭包了。</p>

<h3>__block底层实现</h3>

<pre><code>一句话：传值 和传址
</code></pre>

<p><strong>block打印C++源码可以看到</strong>Block_byref_a_0结构体，这个结构体中含有isa指针，所以也是一个对象，它是用来包装局部变量a的。当block被copy到堆中时，<strong>Person</strong>test_block_impl_0的拷贝辅助函数<strong>Person</strong>test_block_copy_0会将__Block_byref_a_0拷贝至堆中，所以即使局部变量所在堆被销毁，block依然能对堆中的局部变量进行操作</p>

<pre><code>这样做是为了保证操作的值始终是堆中的拷贝，而不是栈中的值。（处理在局部变量所在栈还没销毁，就调用block来改变局部变量值的情况，如果没有__forwarding指针，则修改无效）
</code></pre>

<hr />

<h1>实战篇</h1>

<hr />

<h2>KVO/KVC</h2>

<p>VC/KVO是观察者模式的一种实现，在Cocoa中是以被万物之源NSObject类实现的NSKeyValueCoding/NSKeyValueObserving非正式协议的形式被定义为基础框架的一部分。从协议的角度来说，KVC/KVO本质上是定义了一套让我们去遵守和实现的方法。
当然，KVC/KVO实现的根本是Objective-C的动态性和runtime，这在后文的原理部分会有详述。
另外，KVC/KVO机制离不开访问器方法的实现，这在后文中也有解释。</p>

<p>1、KVC简介</p>

<pre><code>全称是Key-value coding，翻译成键值编码。顾名思义，在某种程度上跟map的关系匪浅。它提供了一种使用字符串而不是访问器方法去访问一个对象实例变量的机制。
</code></pre>

<p>2、KVO简介</p>

<pre><code>全称是Key-value observing，翻译成键值观察。提供了一种当其它对象属性被修改的时候能通知当前对象的机制。再MVC大行其道的Cocoa中，KVO机制很适合实现model和controller类之间的通讯。
</code></pre>

<h3>KVO的底层实现（基于KVC-》运行时）</h3>

<p>当某个类的对象第一次被观察时，系统就会在运行期动态地创建该类的一个派生类，在这个派生类中重写基类中任何被观察属性的 setter 方法。</p>

<pre><code>派生类在被重写的 setter 方法实现真正的通知机制，就如前面手动实现键值观察那样。这么做是基于设置属性会调用 setter 方法，而通过重写就获得了 KVO 需要的通知机制。当然前提是要通过遵循 KVO 的属性设置方式来变更属性值，如果仅是直接修改属性对应的成员变量，是无法实现 KVO 的。

同时派生类还重写了 class 方法以“欺骗”外部调用者它就是起初的那个类。然后系统将这个对象的 isa 指针指向这个新诞生的派生类，因此这个对象就成为该派生类的对象了，因而在该对象上对 setter 的调用就会调用重写的 setter，从而激活键值通知机制。此外，派生类还重写了 dealloc 方法来释放资源
</code></pre>

<p>isa指针指向的其实是类的元类，如果之前的类名为：Person，那么被runtime更改以后的类名会变成：NSKVONotifying_Person。
新的NSKVONotifying_Person类会重写以下方法：
增加了监听的属性对应的set方法，class，dealloc，_isKVOA</p>

<h3>KVC的底层实现</h3>

<p>KVC运用了一个isa-swizzling技术。isa-swizzling就是类型混合指针机制。KVC主要通过isa-swizzling，来实现其内部查找定位的。isa指针，如其名称所指，（就是is a kind of的意思），指向维护分发表的对象的类。该分发表实际上包含了指向实现类中的方法的指针，和其它数据。</p>

<p>一个对象在调用setValue的时候，</p>

<ul>
<li>（1）首先根据方法名找到运行方法的时候所需要的环境参数。</li>
<li>（2）他会从自己isa指针结合环境参数，找到具体的方法实现的接口。</li>
<li>（3）再直接查找得来的具体的方法实现。</li>
</ul>


<hr />

<h1>高级</h1>

<hr />

<h3>GCD底层实现</h3>

<p>GCD内部是怎么实现的</p>

<ul>
<li>1 IOS和OS X的核心是XNU内核，GCD是基于XUN内核实现的</li>
<li>2 GCD的API全部在libdispatch库中</li>
<li><p>3 GCD的底层实现主要有Dispatch Queue 和Dispatch Source</p>

<ul>
<li>Dispatch Queue ：管理block操作</li>
<li>Dispatch Source :处理事件(比如线程间通信)</li>
</ul>
</li>
</ul>


<p>NSOperationQueue 和GCD的区别和类似的地方</p>

<ul>
<li>1 GCD是纯C语言的API， NSOperationQueue是基于GCD的OC版本封装</li>
<li>2 GCD只支持FIFO的队列，NSOperationQueue可以很方便地调整执行顺序 设置最大并发数量</li>
<li>3 NSOperationQueue 可以轻松地在operation 间设置依赖关系，而GCD需要写很多的代码</li>
<li>4 NSOperationQueue支持KVO，可以监测operation是否正在执行(is Executed),是否结束(is finished),是否取消( is canceld);</li>
<li>5 GCD的执行速度比NSOperationQueue快</li>
</ul>


<hr />

<h1>全栈篇</h1>

<hr />

<h3>JSpatch底层实现</h3>

<p>JSPatch 能做到通过 JS 调用和改写 OC 方法最根本的原因是 Objective-C 是动态语言，OC 上所有方法的调用/类的生成都通过 Objective-C Runtime 在运行时进行，我们可以通过类名/方法名反射得到相应的类和方法：</p>

<pre><code>Class class = NSClassFromString("UIViewController");
id viewController = [[class alloc] init];
SEL selector = NSSelectorFromString("viewDidLoad");
[viewController performSelector:selector];
</code></pre>

<p>也可以替换某个类的方法为新的实现：</p>

<pre><code>static void newViewDidLoad(id slf, SEL sel) {}
class_replaceMethod(class, selector, newViewDidLoad, @"");
</code></pre>

<p>还可以新注册一个类，为类添加方法：</p>

<pre><code>Class cls = objc_allocateClassPair(superCls, "JPObject", 0);
objc_registerClassPair(cls);
class_addMethod(cls, selector, implement, typedesc);
</code></pre>

<p>对于 Objective-C 对象模型和动态消息发送的原理已有很多文章阐述得很详细，这里就不详细阐述了。理论上你可以在运行时通过类名/方法名调用到任何 OC 方法，替换任何类的实现以及新增任意类。所以 JSPatch 的基本原理就是：JS 传递字符串给 OC，OC 通过 Runtime 接口调用和替换 OC 方法。这是最基础的原理，实际实现过程还有很多怪要打，接下来看看具体是怎样实现的。</p>

<h6>总结：</h6>

<p>使用JS利用OC的动态特性，执行我们想要执行的代码</p>

<h3>React Native</h3>

<p>RN主要的通信在于java与js之间，平常我们写的jsx代码最终会调用到原生的View。上一篇博客我们也了解到了要新建一个原生模块需要在java层和js层分别写一个Module</p>

<p>特点：</p>

<ul>
<li><p>可以基于 React Native使用 JavaScript 编写应用逻辑，UI 则可以保持全是原生的。这样的话就没有必要就 HTML5 的 UI 做出常见的妥协；</p></li>
<li><p>React 引入了一种与众不同的、略显激进但具备高可用性的方案来构建用户界面。长话短说，应用的 UI 简单通过一个基于应用目前状态的函数来表达。</p></li>
</ul>


<p>RN总共分为三层，java层，C++层，js层</p>

<ul>
<li>Java层：java层就是app原生代码，它通过启动C++层的javascript解析器javascriptCore来执行js代码，从而构建原生UI等。java层依赖于众多优秀开源库，在图片处理使用的是Fresco，网络通信使用的是okhttp，Json解析工具用jackson,动画库用NineOldAndroids等，在java层原生的功能均封装为Module，如Toast和Log等。</li>
<li>C++层：c++层最主要是封装了JavaScriptCore，它是一个全新的支持ES6的webKit。Bridge连接了java与js之间的通信。解析js文件是通过JSCExectutor进行的。</li>
<li>Js层：主要处理事件分发及UI Layout，平常开发最常用的。通用jsx来写业务代码，通过flexbox来实现布局。不依赖DOM。由于react有 DOM diff这个算法，所以它的效率非常高。
通信机制</li>
</ul>


<p>在Java层与Js层的bridge分别存有相同一份模块配置表，Java与Js互相通信时，通过将里配置表中的moduleID，methodID转换成json数据的形式传递给到C++层，C++层传送到js层，通过js层的的模块配置表找到对应的方法进行执行，如果有callback，则回传给java层。这里只是大概介绍。</p>

<p>总结：</p>

<ul>
<li>在程序启动的时候，首先会调用ReactActivity的onCreate函数中，我们会去创建一个ReactInstanceManagerImpl对象。通过ReactRootView的startReactApplication方法开启整个RN世界的大门。</li>
<li>在这个方法中，我们会通过一个AsyncTask去创建ReactContext</li>
<li>在创建ReactContext中，我们把我们自己注入和CoreModulesPackage通过processPackage方法将其中的各个modules注入到了对应的Registry中。最后通过CatalystInstanceImpl中的ReactBridge将NativeModule和JSModule注册表通过jni传输到了JS层。</li>
<li>java调用js时，会在ReactApplicationContext创建的时候存入注册表类JavaScriptModuleRegistry中，同时通过动态代理生成代理实例，并在代理拦截类JavaScriptModuleInvocationHandler中统一处理发向Javascript的所有通信请求。</li>
<li>JSCExecutor将所有来自Java层的通信请求封装成Javascript执行语句。</li>
<li>接着在js层中的MessageQueue里匹配ModuleId和MethodId。找到调用模块。</li>
<li>如果是js层调用java层，js最终都会调用<em>_nativeCall方法，通过flushedQueue将this.</em>queue返回给Bridger。</li>
<li>C++层调用PlatformBridgeCallback对象的onCallNativeModules方法，执行makeJavaCall方法，里面最终通过env->CallVoidMethod调用了Java层的方法。</li>
<li>调用Java层NativeModulesReactCallback的call方法，通过moduleID从保存在其内部的NativeModule映射表，匹配到需要被执行的NativeModule对象，再通过methodID匹配到所要调用的方法。通过invoke反射方式执行NativeModule的方法。</li>
</ul>


<hr />

<h1>必备篇</h1>

<hr />

<h5>多线程</h5>

<h5>网络</h5>

<h5>数据持久化</h5>

<hr />

<hr />

<h1>通用篇</h1>

<hr />

<h5>数组</h5>

<h5>字典</h5>

<h5>集合</h5>

<hr />

<p>更新中，敬请关注。。。。。。</p>

<pre><code>Q Q：2211523682/790806573

微信：18370997821/13148454507

微博WB:http://weibo.com/u/3288975567?is_hot=1

git博文：http://al1020119.github.io/

github：https://github.com/al1020119
</code></pre>

<p><img src="http://al1020119.github.io/images/iCocosCoder.jpg" title="Caption" ></p>

<p><img src="http://al1020119.github.io/images/iCocosPublic.jpg" title="Caption" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[福利：抢红包神器就是这么来的]]></title>
    <link href="http://al1020119.github.io/blog/2016/08/01/weixinhongbao/"/>
    <updated>2016-08-01T11:52:15+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/08/01/weixinhongbao</id>
    <content type="html"><![CDATA[<p>微信红包</p>

<p><img src="http://al1020119.github.io/images/weixinhongbao0001.jpg" title="Caption" ></p>

<p>本文摘自简书大牛<a href="http://www.jianshu.com/p/189afbe3b429">east520</a>.</p>

<p>别告诉我你对红包不感兴趣，如果真的是这样，那么请绕道，哈哈。</p>

<p>现在由于微信和QQ的普及，几乎所有用户都会使用红包这个功能，但是对于一个程序员来说，每看到一个好的功能都会努力试着研究一下，哪怕不能成功，由于看到了一篇比较看的文章，所以就专门花时间去搞一顿，结果大吃一惊。</p>

<p>最近有不少朋友找我要红包尾数的功能，我也不知道他们为什么要这个，可能是笔者太年轻了。但是我觉得这个可能不简单，而且这样的功能做好了也不能外漏，不然笔者的程序员职业生涯估计就到头了！</p>

<pre><code>前言：最近笔者在研究iOS逆向工程，顺便拿微信来练手，在非越狱手机上实现了微信自动抢红包的功能。
</code></pre>

<p>题外话：此教程是一篇严肃的学术探讨类文章，仅仅用于学习研究，也请读者不要用于商业或其他非法途径上，笔者一概不负责哟~~</p>

<p>好了，接下来可以进入正题了！</p>

<!--more-->


<h2>此教程所需要的工具/文件</h2>

<pre><code>yololib
class-dump
dumpdecrypted
iOSOpenDev
iTools
OpenSSH(Cydia)
iFile(Cydia)
Cycript(Cydia)
Command Line Tools
Xcode
苹果开发者证书或企业证书
一台越狱的iPhone
</code></pre>

<p>是的，想要实现在非越狱iPhone上达到自动抢红包的目的，工具用的可能是有点多（工欲善其事必先利其器^_^）。不过，没关系，大家可以按照教程的步骤一步一步来执行，不清楚的步骤可以重复实验，毕竟天上不会掉馅饼嘛。</p>

<h1>解密微信可执行文件(Mach-O)</h1>

<p>因为从Appstore下载安装的应用都是加密过的，所以我们需要用一些工具来为下载的App解密，俗称砸壳。这样才能便于后面分析App的代码结构。</p>

<p>首先我们需要一台已经越狱的iPhone手机(现在市面上越狱已经很成熟，具体越狱方法这里就不介绍了)。然后进入Cydia，安装OpenSSH、Cycript、iFile(调试程序时可以方便地查看日志文件)这三款软件。</p>

<pre><code>PS：笔者的手机是iPhone 6Plus，系统版本为iOS9.1。
</code></pre>

<p>在电脑上用iTunes上下载一个最新的微信，笔者当时下载的微信版本为6.3.13。下载完后，iTunes上会显示出已下载的app。</p>

<p>itnues</p>

<p><img src="http://al1020119.github.io/images/weixinhongbao0002.jpg" title="Caption" ></p>

<p>连上iPhone，用iTunes装上刚刚下载的微信应用。</p>

<p>打开Mac的终端，用ssh进入连上的iPhone(确保iPhone和Mac在同一个网段，笔者iPhone的IP地址为192.168.8.54)。OpenSSH的root密码默认为alpine。</p>

<p>ssh
<img src="http://al1020119.github.io/images/weixinhongbao0003.jpg" title="Caption" ></p>

<p>接下来就是需要找到微信的Bundle id了，，这里笔者有一个小技巧，我们可以把iPhone上的所有App都关掉，唯独保留微信，然后输入命令 ps -e</p>

<p>微信bundle id
<img src="http://al1020119.github.io/images/weixinhongbao0004.jpg" title="Caption" ><br/>
这样我们就找到了微信的可执行文件Wechat的具体路径了。接下来我们需要用Cycript找出微信的Documents的路径，输入命令cycript -p WeChat</p>

<p>cycript
<img src="http://al1020119.github.io/images/weixinhongbao0005.jpg" title="Caption" ></p>

<pre><code>编译dumpdecrypted
先记下刚刚我们获取到的两个路径(Bundle和Documents)，这时候我们就要开始用dumpdecrypted来为微信二进制文件(WeChat)砸壳了。
确保我们从Github上下载了最新的dumpdecrypted源码，进入dumpdecrypted源码的目录，编译dumpdecrypted.dylib，命令如下:
</code></pre>

<p>dumpdecrypted.dylib
<img src="http://al1020119.github.io/images/weixinhongbao0006.jpg" title="Caption" ><br/>
这样我们可以看到dumpdecrypted目录下生成了一个dumpdecrypted.dylib的文件。</p>

<pre><code>scp
拷贝dumpdecrypted.dylib到iPhone上，这里我们用到scp命令.
scp 源文件路径 目标文件路径 。具体如下：
</code></pre>

<p>scp
<img src="http://al1020119.github.io/images/weixinhongbao0007.jpg" title="Caption" ><br/>
    开始砸壳
    dumpdecrypted.dylib的具体用法是：DYLD_INSERT_LIBRARIES=/PathFrom/dumpdecrypted.dylib /PathTo</p>

<p>dumpdecrypted
<img src="http://al1020119.github.io/images/weixinhongbao0008.jpg" title="Caption" ><br/>
这样就代表砸壳成功了，当前目录下会生成砸壳后的文件，即WeChat.decrypted。同样用scp命令把WeChat.decrypted文件拷贝到电脑上,接下来我们要正式的dump微信的可执行文件了。</p>

<h1>dump微信可执行文件</h1>

<pre><code>从Github上下载最新的class-dump源代码，然后用Xcode编译即可生成class-dump(这里比较简单，笔者就不详细说明了)。

导出微信的头文件
使用class-dump命令,把刚刚砸壳后的WeChat.decrypted,导出其中的头文件。./class-dump -s -S -H ./WeChat.decrypted -o ./header6.3-arm64
</code></pre>

<p>导出的头文件
<img src="http://al1020119.github.io/images/weixinhongbao0009.jpg" title="Caption" ><br/>
这里我们可以新建一个Xcode项目，把刚刚导出的头文件加到新建的项目中，这样便于查找微信的相关代码。</p>

<p>微信的头文件
<img src="http://al1020119.github.io/images/weixinhongbao0010.jpg" title="Caption" ><br/>
找到CMessageMgr.h和WCRedEnvelopesLogicMgr.h这两文件，其中我们注意到有这两个方法：- (void)AsyncOnAddMsg:(id)arg1 MsgWrap:(id)arg2; ，- (void)OpenRedEnvelopesRequest:(id)arg1;。没错，接下来我们就是要利用这两个方法来实现微信自动抢红包功能。其实现原理是，通过hook微信的新消息函数，我们判断是否为红包消息，如果是，我们就调用微信的打开红包方法。这样就能达到自动抢红包的目的了。哈哈，是不是很简单，我们一起来看看具体是怎么实现的吧。</p>

<pre><code>新建一个dylib工程，因为Xcode默认不支持生成dylib，所以我们需要下载iOSOpenDev，安装完成后(Xcode7环境会提示安装iOSOpenDev失败，请参考iOSOpenDev安装问题)，重新打开Xcode，在新建项目的选项中即可看到iOSOpenDev选项了。
</code></pre>

<p>iOSOpenDev
<img src="http://al1020119.github.io/images/weixinhongbao0011.jpg" title="Caption" ><br/>
    dylib代码
    选择Cocoa Touch Library，这样我们就新建了一个dylib工程了，我们命名为autoGetRedEnv。</p>

<pre><code>删除autoGetRedEnv.h文件，修改autoGetRedEnv.m为autoGetRedEnv.mm，然后在项目中加入CaptainHook.h

因为微信不会主动来加载我们的hook代码，所以我们需要把hook逻辑写到构造函数中。

__attribute__((constructor)) static void entry()
{
  //具体hook方法
}

hook微信的AsyncOnAddMsg: MsgWrap:方法，实现方法如下：

//声明CMessageMgr类
CHDeclareClass(CMessageMgr);
CHMethod(2, void, CMessageMgr, AsyncOnAddMsg, id, arg1, MsgWrap, id, arg2)
{
  //调用原来的AsyncOnAddMsg:MsgWrap:方法
  CHSuper(2, CMessageMgr, AsyncOnAddMsg, arg1, MsgWrap, arg2);
  //具体抢红包逻辑
  //...
  //调用原生的打开红包的方法
  //注意这里必须为给objc_msgSend的第三个参数声明为NSMutableDictionary,不然调用objc_msgSend时，不会触发打开红包的方法
  ((void (*)(id, SEL, NSMutableDictionary*))objc_msgSend)(logicMgr, @selector(OpenRedEnvelopesRequest:), params);
}
__attribute__((constructor)) static void entry()
{
  //加载CMessageMgr类
  CHLoadLateClass(CMessageMgr);
  //hook AsyncOnAddMsg:MsgWrap:方法
  CHClassHook(2, CMessageMgr, AsyncOnAddMsg, MsgWrap);
}

    项目的全部代码，笔者已放入Github中。

完成好具体实现逻辑后，就可以顺利生成dylib了。
</code></pre>

<h1>重新打包微信App</h1>

<pre><code>为微信可执行文件注入dylib
要想微信应用运行后，能执行我们的代码，首先需要微信加入我们的dylib，这里我们用到一个dylib注入神器:yololib，从网上下载源代码，编译后得到yololib。

使用yololib简单的执行下面一句就可以成功完成注入。注入之前我们先把之前保存的WeChat.decrypted重命名为WeChat，即已砸完壳的可执行文件。
./yololib 目标可执行文件 需注入的dylib
注入成功后即可见到如下信息：

dylib注入
</code></pre>

<p><img src="http://al1020119.github.io/images/weixinhongbao0012.jpg" title="Caption" ><br/>
    新建Entitlements.plist</p>

<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;
&lt;plist version="1.0"&gt;
&lt;dict&gt;
  &lt;key&gt;application-identifier&lt;/key&gt;
  &lt;string&gt;123456.com.autogetredenv.demo&lt;/string&gt;
  &lt;key&gt;com.apple.developer.team-identifier&lt;/key&gt;
  &lt;string&gt;123456&lt;/string&gt;
  &lt;key&gt;get-task-allow&lt;/key&gt;
  &lt;true/&gt;
  &lt;key&gt;keychain-access-groups&lt;/key&gt;
  &lt;array&gt;
      &lt;string&gt;123456.com.autogetredenv.demo&lt;/string&gt;
  &lt;/array&gt;
&lt;/dict&gt;
&lt;/plist&gt;

这里大家也许不清楚自己的证书Teamid及其他信息，没关系，笔者这里有一个小窍门，大家可以找到之前用开发者证书或企业证书打包过的App(例如叫Demo)，然后在终端中输入以下命令即可找到相关信息，命令如下：
./ldid -e ./Demo.app/demo

给微信重新签名
接下来把我们生成的dylib(libautoGetRedEnv.dylib)、刚刚注入dylib的WeChat、以及embedded.mobileprovision文件(可以在之前打包过的App中找到)拷贝到WeChat.app中。

命令格式：codesign -f -s 证书名字 目标文件

    PS:证书名字可以在钥匙串中找到

分别用codesign命令来为微信中的相关文件签名,具体实现如下：

重新签名
</code></pre>

<p><img src="http://al1020119.github.io/images/weixinhongbao0013.jpg" title="Caption" ><br/>
    打包成ipa
    给微信重新签名后，我们就可以用xcrun来生成ipa了，具体实现如下：
    xcrun -sdk iphoneos PackageApplication -v WeChat.app  -o ~/WeChat.ipa</p>

<h1>安装拥有抢红包功能的微信</h1>

<p>以上步骤如果都成功实现的话，那么真的就是万事俱备，只欠东风了~~~</p>

<p>我们可以使用iTools工具，来为iPhone(此iPhone Device id需加入证书中)安装改良过的微信了。</p>

<p>iTools
<img src="http://al1020119.github.io/images/weixinhongbao0014.jpg" title="Caption" ></p>

<h1>大工告成！！</h1>

<p>好了，我们可以看看hook过的微信抢红包效果了~</p>

<p>自动抢红包
<img src="http://al1020119.github.io/images/weixinhongbao0015.gif" title="Caption" ><br/>
哈哈，是不是觉得很爽啊，"妈妈再也不用担心我抢红包了。"。大家如果有兴趣可以继续hook微信的其他函数，这样既加强了学习，又满足了自己的特(zhuang)殊(bi)需求嘛。</p>

<pre><code>Q Q：2211523682/790806573

微信：18370997821/13148454507

微博WB:http://weibo.com/u/3288975567?is_hot=1

git博文：http://al1020119.github.io/

github：https://github.com/al1020119
</code></pre>

<p><img src="http://al1020119.github.io/images/iCocosCoder.jpg" title="Caption" ></p>

<p><img src="http://al1020119.github.io/images/iCocosPublic.jpg" title="Caption" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[重整之道（面试+技术+底层+高级）]]></title>
    <link href="http://al1020119.github.io/blog/2016/07/26/chongzhengzhidao/"/>
    <updated>2016-07-26T13:53:19+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/07/26/chongzhengzhidao</id>
    <content type="html"><![CDATA[<p>重整之道（面试+技术+底层+高级）</p>

<p>不要问我为什么写这篇文章。</p>

<p>我，就是这么有尿性。。。。。。。。。。</p>

<p>前面三部分已经基本上完成，后面部分会陆续更新，敬请期待。但是光靠一篇这么短的文章想将通这些事不可能的，这里主要正对面试族，或者健忘族，亦或者是装逼族。好了废话不多说，我们开始吧！</p>

<ul>
<li>运行时（底层）</li>
<li>RunLoop（底层）</li>
<li>多线程（底层与安全）</li>
</ul>


<hr />

<ul>
<li>网络（底层与安全）</li>
<li>数据持久化（各种使用与区别）（CoreData、SQLite）</li>
<li>Block（底层/__Block）</li>
<li>音视频</li>
<li>直播</li>
<li>安全</li>
<li>优化（性能、卡顿）</li>
<li>常见错误</li>
<li>常用技术</li>
<li>全栈相关</li>
<li>算法（常用、排序）</li>
<li>数据结构</li>
<li>设计模式（32中）</li>
<li>架构设计</li>
<li>逆向工程</li>
<li>实战应用</li>
</ul>


<!--more-->


<h3>运行时（底层）</h3>

<h6>介绍</h6>

<p>runtime是一个c和汇编写的动态库(感谢Lision的指正)，是一套比较底层的C语言API，属于一个C语言库，平时我们所写的OC代码，最终都会转成runtime的C语言代码去执行。</p>

<p>这个系统主要做两件事 ：</p>

<ol>
<li>封装C语言的结构体和函数，让开发者在运行时创建、检查或者修改类、对象和方法等等。</li>
<li>传递消息，找出方法的最终执行代码。</li>
</ol>


<h6>常用关键字</h6>

<p>要想全面了解 Runtime 机制，我们必须先了解 Runtime 的一些术语，他们都对应着数据结构。</p>

<p>SEL</p>

<pre><code>它是selector在 Objc 中的表示(Swift 中是 Selector 类)。selector 是方法选择器，其实作用就和名字一样，日常生活中，我们通过人名辨别谁是谁，注意 Objc 在相同的类中不会有命名相同的两个方法。selector 对方法名进行包装，以便找到对应的方法实现。它的数据结构是：

typedef struct objc_selector *SEL;

我们可以看出它是个映射到方法的 C 字符串，你可以通过 Objc 编译器器命令@selector() 或者 Runtime 系统的 sel_registerName 函数来获取一个 SEL 类型的方法选择器。

注意：
不同类中相同名字的方法所对应的 selector 是相同的，由于变量的类型不同，所以不会导致它们调用方法实现混乱。
</code></pre>

<p>id</p>

<pre><code>id 是一个参数类型，它是指向某个类的实例的指针。定义如下：

以上定义，看到 objc_object 结构体包含一个 isa 指针，根据 isa 指针就可以找到对象所属的类。

注意：
isa 指针在代码运行时并不总指向实例对象所属的类型，所以不能依靠它来确定类型，要想确定类型还是需要用对象的 -class 方法。

PS:KVO 的实现机理就是将被观察对象的 isa 指针指向一个中间类而不是真实类型，详见:KVO章节。
</code></pre>

<p>Class</p>

<pre><code>typedef struct objc_class *Class;

Class 其实是指向 objc_class 结构体的指针。

一个运行时类中关联了它的父类指针、类名、成员变量、方法、缓存以及附属的协议。


由此可见，我们可以动态修改 *methodList 的值来添加成员方法，这也是 Category 实现的原理，同样解释了 Category 不能添加属性的原因。这里可以参考下美团技术团队的文章：深入理解 Objective-C: Category。

objc_ivar_list 结构体用来存储成员变量的列表，而 objc_ivar 则是存储了单个成员变量的信息；同理，objc_method_list 结构体存储着方法数组的列表，而单个方法的信息则由 objc_method 结构体存储。

值得注意的时，objc_class 中也有一个 isa 指针，这说明 Objc 类本身也是一个对象。为了处理类和对象的关系，Runtime 库创建了一种叫做 Meta Class(元类) 的东西，类对象所属的类就叫做元类。Meta Class 表述了类对象本身所具备的元数据。

我们所熟悉的类方法，就源自于 Meta Class。我们可以理解为类方法就是类对象的实例方法。每个类仅有一个类对象，而每个类对象仅有一个与之相关的元类。

当你发出一个类似 [NSObject alloc](类方法) 的消息时，实际上，这个消息被发送给了一个类对象(Class Object)，这个类对象必须是一个元类的实例，而这个元类同时也是一个根元类(Root Meta Class)的实例。所有元类的 isa 指针最终都指向根元类。

所以当 [NSObject alloc] 这条消息发送给类对象的时候，运行时代码 objc_msgSend() 会去它元类中查找能够响应消息的方法实现，如果找到了，就会对这个类对象执行方法调用。



super_class 指针，虚线时 isa 指针。而根元类的父类是 NSObject，isa指向了自己。而 NSObject 没有父类。

最后 objc_class 中还有一个 objc_cache ，缓存，它的作用很重要，后面会提到。
</code></pre>

<p>Method</p>

<pre><code>Method 代表类中某个方法的类型

typedef struct objc_method *Method;

objc_method 存储了方法名，方法类型和方法实现：

方法名类型为 SEL
方法类型 method_types 是个 char 指针，存储方法的参数类型和返回值类型
method_imp 指向了方法的实现，本质是一个函数指针
</code></pre>

<p>Ivar</p>

<pre><code>Ivar 是表示成员变量的类型。

typedef struct objc_ivar *Ivar;


其中 ivar_offset 是基地址偏移字节
</code></pre>

<p>IMP</p>

<pre><code>IMP在objc.h中的定义是：

typedef id (*IMP)(id, SEL, ...);

它就是一个函数指针，这是由编译器生成的。当你发起一个 ObjC 消息之后，最终它会执行的那段代码，就是由这个函数指针指定的。而 IMP 这个函数指针就指向了这个方法的实现。

如果得到了执行某个实例某个方法的入口，我们就可以绕开消息传递阶段，直接执行方法，这在后面 Cache 中会提到。

你会发现 IMP 指向的方法与 objc_msgSend 函数类型相同，参数都包含 id 和 SEL 类型。每个方法名都对应一个 SEL 类型的方法选择器，而每个实例对象中的 SEL 对应的方法实现肯定是唯一的，通过一组 id和 SEL 参数就能确定唯一的方法实现地址。

而一个确定的方法也只有唯一的一组 id 和 SEL 参数。
</code></pre>

<p>Cache</p>

<pre><code>typedef struct objc_cache *Cache

Cache 为方法调用的性能进行优化，每当实例对象接收到一个消息时，它不会直接在 isa 指针指向的类的方法列表中遍历查找能够响应的方法，因为每次都要查找效率太低了，而是优先在 Cache 中查找。

Runtime 系统会把被调用的方法存到 Cache 中，如果一个方法被调用，那么它有可能今后还会被调用，下次查找的时候就会效率更高。就像计算机组成原理中 CPU 绕过主存先访问 Cache 一样。
</code></pre>

<p>Property
    typedef struct objc_property *objc_property_t;//这个更常用</p>

<pre><code>可以通过class_copyPropertyList 和 protocol_copyPropertyList 方法获取类和协议中的属性：

注意：
返回的是属性列表，列表中每个元素都是一个 objc_property_t 指针
</code></pre>

<h6>动态特性</h6>

<pre><code>Objective-C具有相当多的动态特性，基本的，也是经常被提到和用到的有

    动态类型（Dynamic typing）
    动态绑定（Dynamic binding）
    动态加载（Dynamic loading）

动态类型：程序直到执行时才能确定所属的类。

id 数据类型，id 通用的对象类型，可以存储任意类型的对象，id后面没有号，它本身就是个指针，类似于void ，但只可以指向对象类型

静态类型与动态类型

    编译期检查与运行时检查
    静态类型在编译期就能检查出错误
    静态类型声明代码可读性好
    动态类型只有在运行时才能发现错误

动态绑定：程序直到执行时才能确定实际要调用的方法。

动态绑定所做的，即是在实例所属类确定后，将某些属性和相应的方法绑定到实例上。

说明：objective-c 中的BOOL实际上是一种对带符号的字符类型（signed char）的类型定义（typedef），它使用8位的存储空间。通过#define指令把YES定义为1，NO定义为0。

动态加载：根据需求加载所需要的资源

这点很容易理解，对于iOS开发来说，基本就是根据不同的机型做适配。最经典的例子就是在Retina设备上加载@2x的图片，而在老一些的普通屏设备上加载原图。随着Retina iPad的推出，和之后可能的Retina Mac的出现，这个特性相信会被越来越多地使用。
多态的出现时为了让不同的类能使用同名的方法。这个让程序的可读性大大提高，也降低了编程难度。

动态类型与动态绑定是为了解决随多态的便利而引起的弊端，有了动态类型与动态绑定，不用去考虑输出中的方法是哪个类型的方法，会自动判定。

而id类型的出现就是为了更好的承接动态类型与动态方法出来的返回值。
</code></pre>

<h6>常用方法</h6>

<p>Ivar <em>ivars = class_copyIvarList([iCocosObject class], &amp;count);
Method </em>met = class_copyMethodList([iCocosObject class], &amp;meth);
objc_property_t *xsL = class_copyPropertyList([iCocosObject class], &amp;xs);
Method ic =  class_getInstanceMethod(NSClassFromString(@&ldquo;<em>NSArrayM&rdquo;), @selector(iCocosobject:));
Method add =  class_getInstanceMethod(NSClassFromString(@&ldquo;</em>NSArrayM&rdquo;), @selector(addObject:));</p>

<pre><code>objc_msgSend : 给对象发送消息
class_copyMethodList : 遍历某个类所有的方法
class_copyIvarList : 遍历某个类所有的成员变量
class_..... 这是我们学习runtime必须知道的函数！
</code></pre>

<h6>属性与成员变量</h6>

<p>Ivar: 实例变量类型，是一个指向objc_ivar结构体的指针。objc_property_t：声明的属性的类型，是一个指向objc_property结构体的指针</p>

<ol>
<li>属性变量 是已经设置了 setter getter方法的 OC已经自己给设置了</li>
<li>属性变量 你每次调用 self.属性变量 的时候 都要调用getter或者setter方法
封装</li>
</ol>


<p>如果成员变量是private，程序中的其它对象很难直接访问该成员变量。如果是属性，相对更容易用父类方法读写属性。</p>

<p>性能</p>

<pre><code>成员变量地址可以根据实例的内存地址偏移寻址。而属性的读写都需要函数调用，相对更慢。
</code></pre>

<p>非基础类型</p>

<pre><code>对于复杂的C++类型，往往设为成员变量更合适，也许这种类型不支持copy，或者完全复制很麻烦。
</code></pre>

<p>多线程</p>

<pre><code>多线程环境下，为保证数据一致性，在需要同步执行的代码段更应该使用成员变量。如果对需要同步更新的数据用getter/setter 方法，数据更新效率低，会带来更多的获取锁请求失败。
</code></pre>

<p>程序正确性</p>

<pre><code>成员变量可以做直观的内存管理。属性可以一层层继承，还可以复写。容易出错。
</code></pre>

<p>二进制文件的体积</p>

<pre><code>默认用属性，会生成不必要的getter/setter 方法，程序体积会变大。
</code></pre>

<p>1.如果只是单纯的private变量，最好声明在implementation里.
2.如果是类的public属性，就用property写在.h文件里
3.如果自己内部需要setter和getter来实现一些东西，就在.m文件的类目里用property来声明</p>

<h6>消息机制消息机制</h6>

<pre><code>[obj makeText];==objc_msgSend(obj, @selector (makeText));


首先通过obj的isa指针找到obj对应的class。

首先检测这个 selector 是不是要忽略。比如 Mac OS X 开发，有了垃圾回收就不理会 retain，release 这些函数。
检测这个 selector 的 target 是不是 nil，Objc 允许我们对一个 nil 对象执行任何方法不会 Crash，因为运行时会被忽略掉。
如果上面两步都通过了，那么就开始查找这个类的实现 IMP，
在Class中先去cache中 通过SEL查找对应函数method，找到就执行对应的实现。
若cache中未找到，再去methodList中查找，找到就执行对应的实现。
若methodlist中未找到，则取superClass中查找（重复执行以上两个步骤），直到找到最根的类为止。
若任何一部能找到，则将method加 入到cache中，以方便下次查找，并通过method中的函数指针跳转到对应的函数中去执行。
如果以上都不能找到，则会开始进行消息转发
</code></pre>

<h6>消息转发</h6>

<pre><code>1.动态方法解析：向当前类发送 resolveInstanceMethod: 信号，检查是否动态向该类添加了方法。（迷茫请搜索：@dynamic）
2.快速消息转发：检查该类是否实现了 forwardingTargetForSelector: 方法，若实现了则调用这个方法。若该方法返回值对象非nil或非self，则向该返回对象重新发送消息。
3.标准消息转发：runtime发送methodSignatureForSelector:消息获取Selector对应的方法签名。返回值非空则通过forwardInvocation:转发消息，返回值为空则向当前对象发送doesNotRecognizeSelector:消息，程序崩溃退出

总结就是：
在一个函数找不到时，OC提供了三种方式去补救：
1、调用resolveInstanceMethod给个机会让类添加这个实现这个函数
2、调用forwardingTargetForSelector让别的对象去执行这个函数
3、调用forwardInvocation（函数执行器）灵活的将目标函数以其他形式执行。
如果都不中，调用doesNotRecognizeSelector抛出异常。
</code></pre>

<h6>常见用途</h6>

<ul>
<li>增加，删除，修改一个类，属性，成员变量，方法</li>
</ul>


<h6>实际应用</h6>

<ul>
<li>关联对象</li>
<li>方法混淆</li>
<li>NSCoding(归档和解档, 利用runtime遍历模型对象的所有属性)</li>
<li>字典 &ndash;> 模型 (利用runtime遍历模型对象的所有属性, 根据属性名从字典中取出对应的值, 设置到模型的属性上)</li>
<li>KVO(利用runtime动态产生一个类)</li>
<li>用于封装框架(想怎么改就怎么改) 这就是我们runtime机制的只要运用方向</li>
</ul>


<h3>RunLoop（底层）</h3>

<h6>RunLoop 的简单概述</h6>

<p>RunLoop:</p>

<pre><code>   Runloop是事件接收和分发机制的一个实现。

   Runloop提供了一种异步执行代码的机制，不能并行执行任务。

   在主队列中，Main RunLoop直接配合任务的执行，负责处理UI事件、定时器以及其他内核相关事件。
</code></pre>

<p>主要目的：</p>

<pre><code>   保证程序执行的线程不会被系统终止。   
</code></pre>

<p>使用Runloop ？</p>

<pre><code>   当需要和该线程进行交互的时候才会使用Runloop.


   每一个线程都有其对应的RunLoop，但是默认非主线程的RunLoop是没有运行的，需要为RunLoop添加至少一个事件源，然后去run它。


   一般情况下我们是没有必要去启用线程的RunLoop的，除非你在一个单独的线程中需要长久的检测某个事件。
</code></pre>

<p>主线程默认有Runloop。当自己启动一个线程，如果只是用于处理单一的事件，则该线程在执行完之后就退出了。所以当我们需要让该线程监听某项事务
时，就得让线程一直不退出，runloop就是这么一个循环，没有事件的时候，一直卡着，有事件来临了，执行其对应的函数。</p>

<pre><code>   RunLoop,正如其名所示,是线程进入和被线程用来相应事件以及调用事件处理函数的地方.需要在代码中使用控制语句实现RunLoop的循环,也就是说,需要代码提供while或者for循环来驱动RunLoop.


   在这个循环中,使用一个runLoop对象[NSRunloop currentRunloop]执行接收消息,调用对应的处理函数.


    Runloop接收两种源事件:input sources和timer sources。


   input sources 传递异步事件，通常是来自其他线程和不同的程序中的消息；


   timer sources(定时器) 传递同步事件（重复执行或者在特定时间上触发）。


   除了处理input sources，Runloop
</code></pre>

<p>也会产生一些关于本身行为的notificaiton。注册成为Runloop的observer，可以接收到这些notification，做一些额外
的处理。（使用CoreFoundation来成为runloop的observer）。</p>

<p>Runloop工作的特点:</p>

<pre><code>   1&gt;当有时间发生时,Runloop会根据具体的事件类型通知应用程序作出相应;


   2&gt;当没有事件发生时,Runloop会进入休眠状态,从而达到省电的目的;


   3&gt;当事件再次发生时,Runloop会被重新唤醒,处理事件.
</code></pre>

<p>提示:一般在开发中很少会主动创建Runloop,而通常会把事件添加到Runloop中.</p>

<p>苹果提供了两个途径来获取分别是Cocoe里面定义的NSRunLoop以及CoreFoundation里面定义的CFRunLoopRef。</p>

<pre><code>CFRunLoopRef提供了纯C函数的API，所有这些API都是线程安全的。
NSRunLoop提供了面向对象的API，但这些API不是线程安全的。
</code></pre>

<h6>RunLoop 与线程的关系</h6>

<p>iOS 开发中能遇到两个线程对象: pthread_t 和 NSThread。过去苹果有份文档标明了 NSThread 只是 pthread_t 的封装，但那份文档已经失效了，现在它们也有可能都是直接包装自最底层的 mach thread。苹果并没有提供这两个对象相互转换的接口，但不管怎么样，可以肯定的是 pthread_t 和 NSThread 是一一对应的。比如，你可以通过 pthread_main_np() 或 [NSThread mainThread] 来获取主线程；也可以通过 pthread_self() 或 [NSThread currentThread] 来获取当前线程。CFRunLoop 是基于 pthread 来管理的。</p>

<p>苹果不允许直接创建 RunLoop，它只提供了两个自动获取的函数：CFRunLoopGetMain() 和 CFRunLoopGetCurrent()。</p>

<p>线程和 RunLoop 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 RunLoop（主线程除外）。</p>

<h6>RunLoop 的 Mode</h6>

<ol>
<li><p>kCFRunLoopDefaultMode: App的默认 Mode，通常主线程是在这个 Mode 下运行的。</p></li>
<li><p>UITrackingRunLoopMode: 界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响。</p></li>
<li><p>UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用。</p></li>
<li><p>GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到。</p></li>
<li><p>kCFRunLoopCommonModes: 这是一个占位的 Mode，没有实际作用。</p></li>
</ol>


<p>你可以在这里看到更多的苹果内部的 Mode，但那些 Mode 在开发中就很难遇到了。</p>

<p>一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。</p>

<h6>RunLoop 的底层实现(内部逻辑)</h6>

<p>RunLoop 的核心是基于 mach port 的，其进入休眠时调用的函数是 mach_msg()</p>

<p>RunLoop 的核心就是一个 mach_msg() (见上面代码的第7步)，RunLoop 调用这个函数去接收消息，如果没有别人发送 port 消息过来，内核会将线程置于等待状态。例如你在模拟器里跑起一个 iOS 的 App，然后在 App 静止时点击暂停，你会看到主线程调用栈是停留在 mach_msg_trap() 这个地方。</p>

<h6>应用</h6>

<ul>
<li><p>AutoreleasePool</p></li>
<li><p>事件响应</p></li>
<li><p>手势识别</p></li>
<li><p>界面更新</p></li>
<li><p>定时器</p></li>
<li><p>PerformSelecter</p></li>
<li><p>关于GCD</p></li>
<li><p>关于网络请求</p></li>
<li><p>AFNetworking</p></li>
<li><p>AsyncDisplayKit</p></li>
</ul>


<h3>多线程（底层与安全）</h3>

<p>线程：1个进程要想执行任务，必须得有线程.线程是进程的基本执行单元，一个进程（程序）的所有任务都在线程中执行</p>

<p>底层：Mach是第一个以多线程方式处理任务的系统，因此多线程的底层实现机制是基于Mach的线程。</p>

<pre><code> 1》C语言的POSIX接口：#include&lt;pthread.h&gt;POSIX线程（POSIX threads），简称Pthreads，是线程的POSIX标准。该标准定义了创建和操纵线程的一整套API。在类Unix操作系统（Unix、Linux、Mac OS X等）中，都使用Pthreads作为操作系统的线程
 2》OC的NSThread
 3》 C语言的GCD接口（性能最好，代码更精简）  
 4》  OC的NSOperation和NSOperationQueue（基于GCD）
</code></pre>

<p>好处：</p>

<pre><code>1、使用线程可以把程序中占据时间长的任务放到后台去处理，如图片、视频的下载

2、发挥多核处理器的优势，并发执行让系统运行的更快、更流畅，用户体验更好
</code></pre>

<p>缺点：</p>

<pre><code>1、大量的线程降低代码的可读性，

2、更多的线程需要更多的内存空间

3、当多个线程对同一个资源出现争夺的时候要注意线程安全的问题。
</code></pre>

<p>GCD内部怎么实现的</p>

<pre><code>  1》 iOS和OSX的核心是XNU内核（苹果电脑发展的操作系统内核），GCD是基于XNU内核实现的。
  2》GCD的API全部在libdispatch库中
  3》GCD的底层实现主要有：Dispatch Queue和Dispatch Source
    Dispatch Queue :管理block操作
    Dispatch Source：处理事件（比如说线程间的通信）
</code></pre>

<p>6.GCD和NSOperationQueue</p>

<pre><code>   1》GCD是纯C语言的API，NSOperationQueue是基于GCD的OC版本的封装
   2》GCD只支持FIFO的队列，NSOperationQueue可以很方便的调整执行顺序，可以添加依赖设置最大并发数量。
   3》GCD的执行速度比NSOperationQueue快
   4》NSOperationQueue支持KVO，可以检测Operation是否正在执行，是否结束，是否取消。
</code></pre>

<p>如何进行选择？
任务之间不太相互依赖，选用GCD；
任务之间有依赖，或者要监听任务的执行情况：NSOperationQueue</p>

<p>一、前言
     1》只在主线程刷新访问UI
     2》如果要防止资源抢夺，得用synchronize进行加锁保护。
     3》如果异步操作要保证线程安全等问题，尽量使用GCD。（GCD有些函数默认就是安全的）</p>

<p>前段时间看了几个开源项目，发现他们保持线程同步的方式各不相同，有@synchronized、NSLock、dispatch_semaphore、NSCondition、pthread_mutex、OSSpinLock。后来网上查了一下，发现他们的实现机制各不相同，性能也各不一样。不好意思，我们平常使用最多的@synchronized是性能最差的。下面我们先分别介绍每个加锁方式的使用，在使用一个案例来对他们进行性能对比。</p>

<p>二、介绍与使用</p>

<p>2.1、@synchronized</p>

<pre><code>NSObject *obj = [[NSObject alloc] init];
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    @synchronized(obj) {
       NSLog(@"需要线程同步的操作1 开始");
       sleep(3);
       NSLog(@"需要线程同步的操作1 结束");
    }
});
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    sleep(1);
    @synchronized(obj) {
       NSLog(@"需要线程同步的操作2");
    }
});
</code></pre>

<p>@synchronized(obj)指令使用的obj为该锁的唯一标识，只有当标识相同时，才为满足互斥，如果线程2中的@synchronized(obj)改为@synchronized(self),刚线程2就不会被阻塞，@synchronized指令实现锁的优点就是我们不需要在代码中显式的创建锁对象，便可以实现锁的机制，但作为一种预防措施，@synchronized块会隐式的添加一个异常处理例程来保护代码，该处理例程会在异常抛出的时候自动的释放互斥锁。所以如果不想让隐式的异常处理例程带来额外的开销，你可以考虑使用锁对象。</p>

<p>2.2、dispatch_semaphore</p>

<pre><code>dispatch_semaphore_t signal = dispatch_semaphore_create(1);
dispatch_time_t overTime = dispatch_time(DISPATCH_TIME_NOW, 3 * NSEC_PER_SEC);
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    dispatch_semaphore_wait(signal, overTime);
            NSLog(@"需要线程同步的操作1 开始");
            sleep(2);
            NSLog(@"需要线程同步的操作1 结束");
        dispatch_semaphore_signal(signal);
});
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        sleep(1);
        dispatch_semaphore_wait(signal, overTime);
            NSLog(@"需要线程同步的操作2");
        dispatch_semaphore_signal(signal);
});
</code></pre>

<p>dispatch_semaphore是GCD用来同步的一种方式，与他相关的共有三个函数，分别是dispatch_semaphore_create，dispatch_semaphore_signal，dispatch_semaphore_wait。</p>

<p>（1）dispatch_semaphore_create的声明为：</p>

<p>dispatch_semaphore_t dispatch_semaphore_create(long value);</p>

<p>传入的参数为long，输出一个dispatch_semaphore_t类型且值为value的信号量。</p>

<p>值得注意的是，这里的传入的参数value必须大于或等于0，否则dispatch_semaphore_create会返回NULL。</p>

<p>（2）dispatch_semaphore_signal的声明为：</p>

<p>long dispatch_semaphore_signal(dispatch_semaphore_t dsema);</p>

<p>这个函数会使传入的信号量dsema的值加1；</p>

<p>(3) dispatch_semaphore_wait的声明为：</p>

<p>long dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout);</p>

<p>这个函数会使传入的信号量dsema的值减1；这个函数的作用是这样的，如果dsema信号量的值大于0，该函数所处线程就继续执行下面的语句，并且将信号量的值减1；如果desema的值为0，那么这个函数就阻塞当前线程等待timeout（注意timeout的类型为dispatch_time_t，不能直接传入整形或float型数），如果等待的期间desema的值被dispatch_semaphore_signal函数加1了，且该函数（即dispatch_semaphore_wait）所处线程获得了信号量，那么就继续向下执行并将信号量减1。如果等待期间没有获取到信号量或者信号量的值一直为0，那么等到timeout时，其所处线程自动执行其后语句。</p>

<p>dispatch_semaphore 是信号量，但当信号总量设为 1 时也可以当作锁来。在没有等待情况出现时，它的性能比 pthread_mutex 还要高，但一旦有等待情况出现时，性能就会下降许多。相对于 OSSpinLock 来说，它的优势在于等待时不会消耗 CPU 资源。</p>

<p>如上的代码，如果超时时间overTime设置成>2，可完成同步操作。如果overTime&lt;2的话，在线程1还没有执行完成的情况下，此时超时了，将自动执行下面的代码。</p>

<p>2.3、NSLock</p>

<pre><code>NSLock *lock = [[NSLock alloc] init];
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    //[lock lock];
    [lock lockBeforeDate:[NSDate date]];
    NSLog(@"需要线程同步的操作1 开始");
    sleep(2);
    NSLog(@"需要线程同步的操作1 结束");
    [lock unlock];
});
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    sleep(1);
    if ([lock tryLock]) {//尝试获取锁，如果获取不到返回NO，不会阻塞该线程
        NSLog(@"锁可用的操作");
        [lock unlock];
    }else{
        NSLog(@"锁不可用的操作");
    }
    NSDate *date = [[NSDate alloc] initWithTimeIntervalSinceNow:3];
    if ([lock lockBeforeDate:date]) {//尝试在未来的3s内获取锁，并阻塞该线程，如果3s内获取不到恢复线程, 返回NO,不会阻塞该线程
        NSLog(@"没有超时，获得锁");
        [lock unlock];
    }else{
        NSLog(@"超时，没有获得锁");
    }
});
</code></pre>

<p>NSLock是Cocoa提供给我们最基本的锁对象，这也是我们经常所使用的，除lock和unlock方法外，NSLock还提供了tryLock和lockBeforeDate:两个方法，前一个方法会尝试加锁，如果锁不可用(已经被锁住)，刚并不会阻塞线程，并返回NO。lockBeforeDate:方法会在所指定Date之前尝试加锁，如果在指定时间之前都不能加锁，则返回NO。</p>

<pre><code>@protocol NSLocking
- (void)lock;
- (void)unlock;
@end
@interface NSLock : NSObject  {
@private
    void *_priv;
}
- (BOOL)tryLock;
- (BOOL)lockBeforeDate:(NSDate *)limit;
@property (nullable, copy) NSString *name NS_AVAILABLE(10_5, 2_0);
@end
</code></pre>

<p>2.4、NSRecursiveLock递归锁</p>

<pre><code>//NSLock *lock = [[NSLock alloc] init];
NSRecursiveLock *lock = [[NSRecursiveLock alloc] init];
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
       static void (^RecursiveMethod)(int);
       RecursiveMethod = ^(int value) {
       [lock lock];
         if (value &gt; 0) {
                NSLog(@"value = %d", value);
                sleep(1);
                RecursiveMethod(value - 1);
          }
         [lock unlock];
     };
     RecursiveMethod(5);
});
</code></pre>

<p>NSRecursiveLock实际上定义的是一个递归锁，这个锁可以被同一线程多次请求，而不会引起死锁。这主要是用在循环或递归操作中。</p>

<p>这段代码是一个典型的死锁情况。在我们的线程中，RecursiveMethod是递归调用的。所以每次进入这个block时，都会去加一次锁，而从第二次开始，由于锁已经被使用了且没有解锁，所以它需要等待锁被解除，这样就导致了死锁，线程被阻塞住了。调试器中会输出如下信息：</p>

<p>在这种情况下，我们就可以使用NSRecursiveLock。它可以允许同一线程多次加锁，而不会造成死锁。递归锁会跟踪它被lock的次数。每次成功的lock都必须平衡调用unlock操作。只有所有达到这种平衡，锁最后才能被释放，以供其它线程使用。</p>

<p>如果我们将NSLock代替为NSRecursiveLock，上面代码则会正确执行。</p>

<p>如果需要其他功能，源码定义如下：</p>

<pre><code>@interface NSRecursiveLock : NSObject  {
@private
    void *_priv;
}
- (BOOL)tryLock;
- (BOOL)lockBeforeDate:(NSDate *)limit;
@property (nullable, copy) NSString *name NS_AVAILABLE(10_5, 2_0);
@end
</code></pre>

<p>2.5、NSConditionLock条件锁</p>

<pre><code>NSMutableArray *products = [NSMutableArray array];
NSInteger HAS_DATA = 1;
NSInteger NO_DATA = 0;
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    while (1) {
        [lock lockWhenCondition:NO_DATA];
        [products addObject:[[NSObject alloc] init]];
        NSLog(@"produce a product,总量:%zi",products.count);
        [lock unlockWithCondition:HAS_DATA];
        sleep(1);
    }
});
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    while (1) {
       NSLog(@"wait for product");
        [lock lockWhenCondition:HAS_DATA];
       [products removeObjectAtIndex:0];
       NSLog(@"custome a product");
       [lock unlockWithCondition:NO_DATA];
    }
});
</code></pre>

<p>当我们在使用多线程的时候，有时一把只会lock和unlock的锁未必就能完全满足我们的使用。因为普通的锁只能关心锁与不锁，而不在乎用什么钥匙才能开锁，而我们在处理资源共享的时候，多数情况是只有满足一定条件的情况下才能打开这把锁：</p>

<p>在线程1中的加锁使用了lock，所以是不需要条件的，所以顺利的就锁住了，但在unlock的使用了一个整型的条件，它可以开启其它线程中正在等待这把钥匙的临界地，而线程2则需要一把被标识为2的钥匙，所以当线程1循环到最后一次的时候，才最终打开了线程2中的阻塞。但即便如此，NSConditionLock也跟其它的锁一样，是需要lock与unlock对应的，只是lock,lockWhenCondition:与unlock，unlockWithCondition:是可以随意组合的，当然这是与你的需求相关的。</p>

<p>如果你需要其他功能，源码定义如下：</p>

<pre><code>@interface NSConditionLock : NSObject  {
@private
    void *_priv;
}
- (instancetype)initWithCondition:(NSInteger)condition NS_DESIGNATED_INITIALIZER;
@property (readonly) NSInteger condition;
- (void)lockWhenCondition:(NSInteger)condition;
- (BOOL)tryLock;
- (BOOL)tryLockWhenCondition:(NSInteger)condition;
- (void)unlockWithCondition:(NSInteger)condition;
- (BOOL)lockBeforeDate:(NSDate *)limit;
- (BOOL)lockWhenCondition:(NSInteger)condition beforeDate:(NSDate *)limit;
@property (nullable, copy) NSString *name NS_AVAILABLE(10_5, 2_0);
@end
</code></pre>

<p>2.6、NSCondition</p>

<pre><code>NSCondition *condition = [[NSCondition alloc] init];
NSMutableArray *products = [NSMutableArray array];
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        while (1) {
            [condition lock];
            if ([products count] == 0) {
                NSLog(@"wait for product");
                [condition wait];
            }
            [products removeObjectAtIndex:0];
            NSLog(@"custome a product");
            [condition unlock];
        }
    });
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        while (1) {
            [condition lock];
            [products addObject:[[NSObject alloc] init]];
            NSLog(@"produce a product,总量:%zi",products.count);
            [condition signal];
            [condition unlock];
            sleep(1);
        }
});
</code></pre>

<p>一种最基本的条件锁。手动控制线程wait和signal。</p>

<p>[condition lock];一般用于多线程同时访问、修改同一个数据源，保证在同一时间内数据源只被访问、修改一次，其他线程的命令需要在lock 外等待，只到unlock ，才可访问</p>

<p>[condition unlock];与lock 同时使用</p>

<p>[condition wait];让当前线程处于等待状态</p>

<p>[condition signal];CPU发信号告诉线程不用在等待，可以继续执行</p>

<p>2.7、pthread_mutex</p>

<pre><code>__block pthread_mutex_t theLock;
pthread_mutex_init(&amp;theLock, NULL);
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        pthread_mutex_lock(&amp;theLock);
        NSLog(@"需要线程同步的操作1 开始");
        sleep(3);
        NSLog(@"需要线程同步的操作1 结束");
        pthread_mutex_unlock(&amp;theLock);
});
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        sleep(1);
        pthread_mutex_lock(&amp;theLock);
        NSLog(@"需要线程同步的操作2");
        pthread_mutex_unlock(&amp;theLock);
});
</code></pre>

<p>c语言定义下多线程加锁方式。</p>

<p>1：pthread_mutex_init(pthread_mutex_t mutex,const pthread_mutexattr_t attr);</p>

<p>初始化锁变量mutex。attr为锁属性，NULL值为默认属性。</p>

<p>2：pthread_mutex_lock(pthread_mutex_t mutex);加锁</p>

<p>3：pthread_mutex_tylock(<em>pthread_mutex_t </em>mutex);加锁，但是与2不一样的是当锁已经在使用的时候，返回为EBUSY，而不是挂起等待。</p>

<p>4：pthread_mutex_unlock(pthread_mutex_t *mutex);释放锁</p>

<p>5：pthread_mutex_destroy(pthread_mutex_t* mutex);使用完后释放</p>

<p>代码执行操作结果如下：</p>

<p>2.8、pthread_mutex(recursive)</p>

<pre><code> __block pthread_mutex_t theLock;
//pthread_mutex_init(&amp;theLock, NULL);
pthread_mutexattr_t attr;
pthread_mutexattr_init(&amp;attr);
pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE);
pthread_mutex_init(&amp;lock, &amp;attr);
pthread_mutexattr_destroy(&amp;attr);
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    static void (^RecursiveMethod)(int);
    RecursiveMethod = ^(int value) {
            pthread_mutex_lock(&amp;theLock);
            if (value &gt; 0) {
                NSLog(@"value = %d", value);
                sleep(1);
                RecursiveMethod(value - 1);
            }
            pthread_mutex_unlock(&amp;theLock);
     };
    RecursiveMethod(5);
});
</code></pre>

<p>这是pthread_mutex为了防止在递归的情况下出现死锁而出现的递归锁。作用和NSRecursiveLock递归锁类似。</p>

<p>如果使用pthread_mutex_init(&amp;theLock, NULL);初始化锁的话，上面的代码会出现死锁现象。如果使用递归锁的形式，则没有问题。</p>

<p>2.9、OSSpinLock</p>

<pre><code>__block OSSpinLock theLock = OS_SPINLOCK_INIT;
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    OSSpinLockLock(&amp;theLock);
    NSLog(@"需要线程同步的操作1 开始");
    sleep(3);
    NSLog(@"需要线程同步的操作1 结束");
    OSSpinLockUnlock(&amp;theLock);
});
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    OSSpinLockLock(&amp;theLock);
    sleep(1);
    NSLog(@"需要线程同步的操作2");
    OSSpinLockUnlock(&amp;theLock);
});
</code></pre>

<p>OSSpinLock 自旋锁，性能最高的锁。原理很简单，就是一直 do while 忙等。它的缺点是当等待时会消耗大量 CPU 资源，所以它不适用于较长时间的任务。 不过最近YY大神在自己的博客不再安全的 OSSpinLock中说明了OSSpinLock已经不再安全，请大家谨慎使用。</p>

<p>三、性能对比</p>

<pre><code>OSSpinLock和dispatch_semaphore的效率远远高于其他。

@synchronized和NSConditionLock效率较差。

鉴于OSSpinLock的不安全，所以我们在开发中如果考虑性能的话，建议使用dispatch_semaphore。

如果不考虑性能，只是图个方便的话，那就使用@synchronized。
</code></pre>

<h3>网络（底层与安全）</h3>

<h3>数据持久化（各种使用与区别）（CoreData、SQLite）</h3>

<h3>Block（底层/__Block）</h3>

<h3>音视频</h3>

<h3>直播</h3>

<h3>安全</h3>

<h3>优化（性能、卡顿）</h3>

<h3>常见错误</h3>

<h3>常用技术</h3>

<p>KVC</p>

<pre><code>KVC运用了一个isa-swizzling技术。isa-swizzling就是类型混合指针机制。KVC主要通过isa-swizzling，来实现其内部查找定位的。isa指针，如其名称所指，（就是is a kind of的意思），指向维护分发表的对象的类。该分发表实际上包含了指向实现类中的方法的指针，和其它数据
一个对象在调用setValue的时候，（1）首先根据方法名找到运行方法的时候所需要的环境参数。（2）他会从自己isa指针结合环境参数，找到具体的方法实现的接口。（3）再直接查找得来的具体的方法实现。
</code></pre>

<p>KVO</p>

<pre><code>观察者为一个对象的属性进行了注册，被观察对象的isa指针被修改的时候，isa指针就会指向一个中间类（setter/getter方法），而不是真实的类。所以isa指针其实不需要指向实例对象真实的类。所以我们的程序最好不要依赖于isa指针。在调用类的方法的时候，最好要明确对象实例的类名。
熟悉KVO的朋友都知道，只有当我们调用KVC去访问key值的时候KVO才会起作用。所以肯定确定的是，KVO是基于KVC实现的。其实看了上面我们的分析以后，关系KVO的架构的构思也就水到渠成了。
</code></pre>

<p>任何工程产品（注意是任何工程产品）都可以使用以下两种方法之一进行测试。
黑盒测试：已知产品的功能设计规格，可以进行测试证明每个实现了的功能是否符合要求。
白盒测试：已知产品的内部工作过程，可以通过测试证明每种内部操作是否符合设计规格要求，所有内部成分是否以经过检查。</p>

<h5>黑盒测试</h5>

<p>软件的黑盒测试意味着测试要在软件的接口处进行。这种方法是把测试对象看做一个黑盒子，测试人员完全不考虑程序内部的逻辑结构和内部特性，只依据程序的需求规格说明书，检查程序的功能是否符合它的功能说明。因此黑盒测试又叫功能测试或数据驱动测试。</p>

<pre><code>黑盒测试主要是为了发现以下几类错误：
1、是否有不正确或遗漏的功能？
2、在接口上，输入是否能正确的接受？能否输出正确的结果？
3、是否有数据结构错误或外部信息（例如数据文件）访问错误？
4、性能上是否能够满足要求？
5、是否有初始化或终止性错误？
</code></pre>

<h5>白盒测试</h5>

<p>软件的白盒测试是对软件的过程性细节做细致的检查。这种方法是把测试对象看做一个打开的盒子，它允许测试人员利用程序内部的逻辑结构及有关信息，设计或选择测试用例，对程序所有逻辑路径进行测试。通过在不同点检查程序状态，确定实际状态是否与预期的状态一致。因此白盒测试又称为结构测试或逻辑驱动测试。</p>

<pre><code>白盒测试主要是想对程序模块进行如下检查：
1、对程序模块的所有独立的执行路径至少测试一遍。
2、对所有的逻辑判定，取“真”与取“假”的两种情况都能至少测一遍。
3、在循环的边界和运行的界限内执行循环体。
4、测试内部数据结构的有效性，等等。
</code></pre>

<p>以上事实说明，软件测试有一个致命的缺陷，即测试的不完全、不彻底性。由于任何程序只能进行少量（相对于穷举的巨大数量而言）的有限的测试，在未发现错误时，不能说明程序中没有错误。</p>

<h5>灰盒测试</h5>

<p>灰盒测试，是介于白盒测试与黑盒测试之间的，可以这样理解，灰盒测试关注输出对于输入的正确性，同时也关注内部表现，但这种关注不象白盒那样详细、完整，只是通过一些表征性的现象、事件、标志来判断内部的运行状态，有时候输出是正确的，但内部其实已经错误了，这种情况非常多，如果每次都通过白盒测试来操作，效率会很低，因此需要采取这样的一种灰盒的方法。</p>

<h3>全栈相关</h3>

<h3>算法（常用、排序）</h3>

<h3>数据结构</h3>

<h3>设计模式（32中）</h3>

<h3>架构设计</h3>

<h3>逆向工程</h3>

<h3>实战应用</h3>

<pre><code>Q Q：2211523682/790806573

微信：18370997821/13148454507

微博WB:http://weibo.com/u/3288975567?is_hot=1

git博文：http://al1020119.github.io/

github：https://github.com/al1020119
</code></pre>

<p><img src="http://al1020119.github.io/images/iCocosCoder.jpg" title="Caption" ></p>

<p><img src="http://al1020119.github.io/images/iCocosPublic.jpg" title="Caption" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[多线程之葵花宝典]]></title>
    <link href="http://al1020119.github.io/blog/2016/07/10/duoxianc/"/>
    <updated>2016-07-10T14:59:42+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/07/10/duoxianc</id>
    <content type="html"><![CDATA[<h2>一、进程和线程</h2>

<h4>1.什么是进程</h4>

<pre><code>进程是指在系统中正在运行的一个应用程序

每个进程之间是独立的，每个进程均运行在其专用且受保护的内存空间内





比如同时打开QQ、Xcode，系统就会分别启动2个进程

通过“活动监视器”可以查看Mac系统中所开启的进程
</code></pre>

<!--more-->


<h4>2.什么是线程</h4>

<pre><code>1个进程要想执行任务，必须得有线程（每1个进程至少要有1条线程）

线程是进程的基本执行单元，一个进程（程序）的所有任务都在线程中执行

比如使用酷狗播放音乐、使用迅雷下载电影，都需要在线程中执行
</code></pre>

<p> 　　</p>

<h4>3.线程的串行</h4>

<pre><code>1个线程中任务的执行是串行的

如果要在1个线程中执行多个任务，那么只能一个一个地按顺序执行这些任务

也就是说，在同一时间内，1个线程只能执行1个任务

比如在1个线程中下载3个文件（分别是文件A、文件B、文件C）
</code></pre>

<h2>二、多线程</h2>

<h4>1.什么是多线程</h4>

<pre><code>1个进程中可以开启多条线程，每条线程可以并行（同时）执行不同的任务

进程 -&gt;车间，线程-&gt;车间工人

多线程技术可以提高程序的执行效率

比如同时开启3条线程分别下载3个文件（分别是文件A、文件B、文件C）
</code></pre>

<h4>2.多线程的原理</h4>

<pre><code>同一时间，CPU只能处理1条线程，只有1条线程在工作（执行）
多线程并发（同时）执行，其实是CPU快速地在多条线程之间调度（切换）
如果CPU调度线程的时间足够快，就造成了多线程并发执行的假象
思考：如果线程非常非常多，会发生什么情况？
CPU会在N多线程之间调度，CPU会累死，消耗大量的CPU资源
每条线程被调度执行的频次会降低（线程的执行效率降低）
</code></pre>

<h4>3.多线程的优缺点</h4>

<p>多线程的优点</p>

<pre><code>能适当提高程序的执行效率

能适当提高资源利用率（CPU、内存利用率）
</code></pre>

<p>多线程的缺点</p>

<pre><code>开启线程需要占用一定的内存空间（默认情况下，主线程占用1M，子线程占用512KB），如果开启大量的线程，会占用大量的内存空间，降低程序的性能

线程越多，CPU在调度线程上的开销就越大

程序设计更加复杂：比如线程之间的通信、多线程的数据共享
</code></pre>

<h4>4.多线程在iOS开发中的应用</h4>

<pre><code>主线程:一个iOS程序运行后，默认会开启1条线程，称为“主线程”或“UI线程”

主线程的主要作用

显示\刷新UI界面

处理UI事件（比如点击事件、滚动事件、拖拽事件等）
</code></pre>

<p>主线程的使用注意:别将比较耗时的操作放到主线程中。</p>

<p>耗时操作会卡住主线程，严重影响UI的流畅度，给用户一种“卡”的坏体验</p>

<h2>多线程的四中方式</h2>

<h4>1. Pthreads</h4>

<h4>2. NSThread</h4>

<h4>3. GCD</h4>

<h4>4. NSOperation &amp; NSOperationQueue</h4>

<h2>多线程的全解析-看了不信你还不会？</h2>

<p><img src="http://al1020119.github.io/images/multithread.png" title="Caption" ></p>

<pre><code>Q Q：2211523682/790806573

微信：18370997821/13148454507

微博WB:http://weibo.com/u/3288975567?is_hot=1

git博文：http://al1020119.github.io/

github：https://github.com/al1020119
</code></pre>

<p><img src="http://al1020119.github.io/images/iCocosCoder.jpg" title="Caption" ></p>

<p><img src="http://al1020119.github.io/images/iCocosPublic.jpg" title="Caption" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CoreData 😘 SQLite 😍 FMDB]]></title>
    <link href="http://al1020119.github.io/blog/2016/07/05/zsqlfmdbcoredata/"/>
    <updated>2016-07-05T14:59:42+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/07/05/zsqlfmdbcoredata</id>
    <content type="html"><![CDATA[<p>概览</p>

<p>在iOS开发中数据存储的方式可以归纳为两类：一类是存储为文件，另一类是存储到数据库。例如前面IOS开发系列—Objective-C之Foundation框架的文章中提到归档、plist文件存储，包括偏好设置其本质都是存储为文件，只是说归档或者plist文件存储可以选择保存到沙盒中，而偏好设置系统已经规定只能保存到沙盒的Library/Preferences目录。当然，文件存储并不作为本文的重点内容。本文重点还是说数据库存储，做过数据库开发的朋友应该知道，可以通过SQL直接访问数据库，也可以通过ORM进行对象关系映射访问数据库。这两种方式恰恰对应iOS中SQLite和Core Data的内容，在此将重点进行分析:</p>

<h3>1. SQLite</h3>

<h3>2. Core Data</h3>

<h3>3. FMDB</h3>

<!--more-->


<hr />

<h2>SQLite</h2>

<p>SQLite是目前主流的嵌入式关系型数据库，其最主要的特点就是轻量级、跨平台，当前很多嵌入式操作系统都将其作为数据库首选。虽然SQLite是一款轻型数据库，但是其功能也绝不亚于很多大型关系数据库。学习数据库就要学习其相关的定义、操作、查询语言，也就是大家日常说得SQL语句。和其他数据库相比，SQLite中的SQL语法并没有太大的差别，因此这里对于SQL语句的内容不会过多赘述，大家可以参考SQLite中其他SQL相关的内容，这里还是重点讲解iOS中如何使用SQLite构建应用程序。先看一下SQLite数据库的几个特点：</p>

<ol>
<li><p>基于C语言开发的轻型数据库</p></li>
<li><p>在iOS中需要使用C语言语法进行数据库操作、访问（无法使用ObjC直接访问，因为libqlite3框架基于C语言编写）</p></li>
<li><p>SQLite中采用的是动态数据类型，即使创建时定义了一种类型，在实际操作时也可以存储其他类型，但是推荐建库时使用合适的类型（特别是应用需要考虑跨平台的情况时）</p></li>
<li><p>建立连接后通常不需要关闭连接（尽管可以手动关闭）</p></li>
</ol>


<p>要使用SQLite很简单，如果在Mac OSX上使用可以考虑到SQLite官方网站下载命令行工具，也可以使用类似于SQLiteManager、Navicat for SQLite等工具。为了方便大家开发调试，建议在开发环境中安装上述工具。</p>

<p>在iOS中操作SQLite数据库可以分为以下几步（注意先在项目中导入libsqlite3框架）：</p>

<ol>
<li><p>打开数据库，利用sqlite3_open()打开数据库会指定一个数据库文件保存路径，如果文件存在则直接打开，否则创建并打开。打开数据库会得到一个sqlite3类型的对象，后面需要借助这个对象进行其他操作。</p></li>
<li><p>执行SQL语句，执行SQL语句又包括有返回值的语句和无返回值语句。</p></li>
<li><p>对于无返回值的语句（如增加、删除、修改等）直接通过sqlite3_exec()函数执行；</p></li>
<li><p>对于有返回值的语句则首先通过sqlite3_prepare_v2()进行sql语句评估（语法检测），然后通过sqlite3_step()依次取出查询结果的每一行数据，对于每行数据都可以通过对应的sqlite3_column_类型()方法获得对应列的数据，如此反复循环直到遍历完成。当然，最后需要释放句柄。</p></li>
</ol>


<p>在整个操作过程中无需管理数据库连接，对于嵌入式SQLite操作是持久连接（尽管可以通过sqlite3_close()关闭），不需要开发人员自己释放连接。纵观整个操作过程，其实与其他平台的开发没有明显的区别，较为麻烦的就是数据读取，在iOS平台中使用C进行数据读取采用了游标的形式，每次只能读取一行数据，较为麻烦。因此实际开发中不妨对这些操作进行封装：</p>

<p>KCDbManager.h
    //
    //  DbManager.h
    //  DataAccess
    //
    //  Created by Kenshin Cui on 14-3-29.
    //  Copyright &copy; 2014年 Kenshin Cui. All rights reserved.
    //
    #import &lt;Foundation/Foundation.h>
    #import &lt;sqlite3.h>
    #import &ldquo;KCSingleton.h&rdquo;
    @interface KCDbManager : NSObject
    singleton_interface(KCDbManager);
    #pragma mark - 属性
    #pragma mark 数据库引用，使用它进行数据库操作
    @property (nonatomic) sqlite3 <em>database;
    #pragma mark - 共有方法
    /**
     *  打开数据库
     *
     *  @param dbname 数据库名称
     </em>/
    -(void)openDb:(NSString <em>)dbname;
    /**
     *  执行无返回值的sql
     *
     *  @param sql sql语句
     </em>/
    -(void)executeNonQuery:(NSString <em>)sql;
    /**
     *  执行有返回值的sql
     *
     *  @param sql sql语句
     *
     *  @return 查询结果
     </em>/
    -(NSArray <em>)executeQuery:(NSString </em>)sql;
    @end</p>

<pre><code>KCDbManager.m
//
//  DbManager.m
//  DataAccess
//
//  Created by Kenshin Cui on 14-3-29.
//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.
//
#import "KCDbManager.h"
#import &lt;sqlite3.h&gt;
#import "KCSingleton.h"
#import "KCAppConfig.h"
#ifndef kDatabaseName
#define kDatabaseName @"myDatabase.db"
#endif
@interface KCDbManager()
@end
@implementation KCDbManager
singleton_implementation(KCDbManager)
#pragma mark 重写初始化方法
-(instancetype)init{
    KCDbManager *manager;
    if((manager=[super init]))
    {
        [manager openDb:kDatabaseName];
    }
    return manager;
}
-(void)openDb:(NSString *)dbname{
    //取得数据库保存路径，通常保存沙盒Documents目录
    NSString *directory=[NSSearchPathForDirectoriesInDomains(NSDocumentationDirectory, NSUserDomainMask, YES) firstObject];
    NSLog(@"%@",directory);
    NSString *filePath=[directory stringByAppendingPathComponent:dbname];
    //如果有数据库则直接打开，否则创建并打开（注意filePath是ObjC中的字符串，需要转化为C语言字符串类型）
    if (SQLITE_OK ==sqlite3_open(filePath.UTF8String, &amp;_database)) {
        NSLog(@"数据库打开成功!");
    }else{
        NSLog(@"数据库打开失败!");
    }
}
-(void)executeNonQuery:(NSString *)sql{
    char *error;
    //单步执行sql语句，用于插入、修改、删除
    if (SQLITE_OK!=sqlite3_exec(_database, sql.UTF8String, NULL, NULL,&amp;error)) {
        NSLog(@"执行SQL语句过程中发生错误！错误信息：%s",error);
    }
}
-(NSArray *)executeQuery:(NSString *)sql{
    NSMutableArray *rows=[NSMutableArray array];//数据行

    //评估语法正确性
    sqlite3_stmt *stmt;
    //检查语法正确性
    if (SQLITE_OK==sqlite3_prepare_v2(_database, sql.UTF8String, -1, &amp;stmt, NULL)) {
        //单步执行sql语句
        while (SQLITE_ROW==sqlite3_step(stmt)) {
            int columnCount= sqlite3_column_count(stmt);
            NSMutableDictionary *dic=[NSMutableDictionary dictionary];
            for (int i=0; i&lt;columnCount; i++) {
                const char *name= sqlite3_column_name(stmt, i);//取得列名
                const unsigned char *value= sqlite3_column_text(stmt, i);//取得某列的值
                dic[[NSString stringWithUTF8String:name]]=[NSString stringWithUTF8String:(const char *)value];
            }
            [rows addObject:dic];
        }
    }

    //释放句柄
    sqlite3_finalize(stmt);

    return rows;
}
@end
</code></pre>

<p>在上面的类中对于数据库操作进行了封装，封装之后数据操作更加方便，同时所有的语法都由C转换成了ObjC。</p>

<p>下面仍然以微博查看为例进行SQLite演示。当然实际开发中微博数据是从网络读取的，但是考虑到缓存问题，通常会选择将微博数据保存到本地，下面的Demo演示了将数据存放到本地数据库以及数据读取的过程。当然，实际开发中并不会在视图控制器中直接调用数据库操作方法，在这里通常会引入两个概念Model和Service。Model自不必多说，就是MVC中的模型。而Service指的是操作数据库的服务层，它封装了对于Model的基本操作方法，实现具体的业务逻辑。为了解耦，在控制器中是不会直接接触数据库的，控制器中只和模型（模型是领域的抽象）、服务对象有关系，借助服务层对模型进行各类操作，模型的操作反应到数据库中就是对表中数据的操作。具体关系如下：</p>

<p><img src="http://al1020119.github.io/images/CSR001.jpg" title="Caption" ></p>

<p>要完成上述功能，首先定义一个应用程序全局对象进行数据库、表的创建。为了避免每次都创建数据库和表出错，这里利用了偏好设置进行保存当前创建状态（其实这也是数据存储的一部分），如果创建过了数据库则不再创建，否则创建数据库和表。</p>

<p>KCDatabaseCreator.m</p>

<pre><code>//
//  KCDatabaseCreator.m
//  DataAccess
//
//  Created by Kenshin Cui on 14-3-29.
//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.
//
#import "KCDatabaseCreator.h"
#import "KCDbManager.h"
@implementation KCDatabaseCreator
+(void)initDatabase{
    NSString *key=@"IsCreatedDb";
    NSUserDefaults *defaults=[[NSUserDefaults alloc]init];
    if ([[defaults valueForKey:key] intValue]!=1) {
        [self createUserTable];
        [self createStatusTable];
        [defaults setValue:@1 forKey:key];
    }
}
+(void)createUserTable{
    NSString *sql=@"CREATE TABLE User (Id integer PRIMARY KEY AUTOINCREMENT,name text,screenName text, profileImageUrl text,mbtype text,city text)";
    [[KCDbManager sharedKCDbManager] executeNonQuery:sql];
}
+(void)createStatusTable{
    NSString *sql=@"CREATE TABLE Status (Id integer PRIMARY KEY AUTOINCREMENT,source text,createdAt date,\"text\" text,user integer REFERENCES User (Id))";
    [[KCDbManager sharedKCDbManager] executeNonQuery:sql];
}
@end
</code></pre>

<p>其次，定义数据模型，这里定义用户User和微博Status两个数据模型类。注意模型应该尽量保持其单纯性，仅仅是简单的POCO，不要引入视图、控制器等相关内容。</p>

<p>KCUser.h</p>

<pre><code>//
//  KCUser.h
//  UrlConnection
//
//  Created by Kenshin Cui on 14-3-22.
//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.
//
#import &lt;Foundation/Foundation.h&gt;
@interface KCUser : NSObject
#pragma mark 编号
@property (nonatomic,strong) NSNumber *Id;
#pragma mark 用户名
@property (nonatomic,copy) NSString *name;
#pragma mark 用户昵称
@property (nonatomic,copy) NSString *screenName;
#pragma mark 头像
@property (nonatomic,copy) NSString *profileImageUrl;
#pragma mark 会员类型
@property (nonatomic,copy) NSString *mbtype;
#pragma mark 城市
@property (nonatomic,copy) NSString *city;
#pragma mark - 动态方法
/**
 *  初始化用户
 *
 *  @param name 用户名
 *  @param city 所在城市
 *
 *  @return 用户对象
 */
-(KCUser *)initWithName:(NSString *)name screenName:(NSString *)screenName profileImageUrl:(NSString *)profileImageUrl mbtype:(NSString *)mbtype city:(NSString *)city;
/**
 *  使用字典初始化用户对象
 *
 *  @param dic 用户数据
 *
 *  @return 用户对象
 */
-(KCUser *)initWithDictionary:(NSDictionary *)dic;
#pragma mark - 静态方法
+(KCUser *)userWithName:(NSString *)name screenName:(NSString *)screenName profileImageUrl:(NSString *)profileImageUrl mbtype:(NSString *)mbtype city:(NSString *)city;
@end
</code></pre>

<p>KCUser.m</p>

<pre><code>//
//  KCUser.m
//  UrlConnection
//
//  Created by Kenshin Cui on 14-3-22.
//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.
//
#import "KCUser.h"
@implementation KCUser
-(KCUser *)initWithName:(NSString *)name screenName:(NSString *)screenName profileImageUrl:(NSString *)profileImageUrl mbtype:(NSString *)mbtype city:(NSString *)city{
    if (self=[super init]) {
        self.name=name;
        self.screenName=screenName;
        self.profileImageUrl=profileImageUrl;
        self.mbtype=mbtype;
        self.city=city;
    }
    return self;
}
-(KCUser *)initWithDictionary:(NSDictionary *)dic{
    if (self=[super init]) {
        [self setValuesForKeysWithDictionary:dic];
    }
    return self;
}
+(KCUser *)userWithName:(NSString *)name screenName:(NSString *)screenName profileImageUrl:(NSString *)profileImageUrl mbtype:(NSString *)mbtype city:(NSString *)city{
    KCUser *user=[[KCUser alloc]initWithName:name screenName:screenName profileImageUrl:profileImageUrl mbtype:mbtype city:city];
    return user;
}
</code></pre>

<p>@end</p>

<p>KCStatus.h</p>

<pre><code>//
//  KCStatus.h
//  UITableView
//
//  Created by Kenshin Cui on 14-3-1.
//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.
//
#import &lt;Foundation/Foundation.h&gt;
#import "KCUser.h"
@interface KCStatus : NSObject
#pragma mark - 属性
@property (nonatomic,strong) NSNumber *Id;//微博id
@property (nonatomic,strong) KCUser *user;//发送用户
@property (nonatomic,copy) NSString *createdAt;//创建时间
@property (nonatomic,copy) NSString *source;//设备来源
@property (nonatomic,copy) NSString *text;//微博内容
#pragma mark - 动态方法
/**
 *  初始化微博数据
 *
 *  @param createAt        创建日期
 *  @param source          来源
 *  @param text            微博内容
 *  @param user            发送用户
 *
 *  @return 微博对象
 */
-(KCStatus *)initWithCreateAt:(NSString *)createAt source:(NSString *)source text:(NSString *)text user:(KCUser *)user;
/**
 *  初始化微博数据
 *
 *  @param profileImageUrl 用户头像
 *  @param mbtype          会员类型
 *  @param createAt        创建日期
 *  @param source          来源
 *  @param text            微博内容
 *  @param userId          用户编号
 *
 *  @return 微博对象
 */
-(KCStatus *)initWithCreateAt:(NSString *)createAt source:(NSString *)source text:(NSString *)text userId:(int)userId;
/**
 *  使用字典初始化微博对象
 *
 *  @param dic 字典数据
 *
 *  @return 微博对象
 */
-(KCStatus *)initWithDictionary:(NSDictionary *)dic;
#pragma mark - 静态方法
/**
 *  初始化微博数据
 *
 *  @param createAt        创建日期
 *  @param source          来源
 *  @param text            微博内容
 *  @param user            发送用户
 *
 *  @return 微博对象
 */
+(KCStatus *)statusWithCreateAt:(NSString *)createAt source:(NSString *)source text:(NSString *)text user:(KCUser *)user;
/**
 *  初始化微博数据
 *
 *  @param profileImageUrl 用户头像
 *  @param mbtype          会员类型
 *  @param createAt        创建日期
 *  @param source          来源
 *  @param text            微博内容
 *  @param userId          用户编号
 *
 *  @return 微博对象
 */
+(KCStatus *)statusWithCreateAt:(NSString *)createAt source:(NSString *)source text:(NSString *)text userId:(int)userId;
@end
</code></pre>

<p>KCStatus.m</p>

<pre><code>//
//  KCStatus.m
//  UITableView
//
//  Created by Kenshin Cui on 14-3-1.
//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.
//
#import "KCStatus.h"
@implementation KCStatus
-(KCStatus *)initWithDictionary:(NSDictionary *)dic{
    if (self=[super init]) {
        [self setValuesForKeysWithDictionary:dic];
        self.user=[[KCUser alloc]init];
        self.user.Id=dic[@"user"];
    }
    return self;
}
-(KCStatus *)initWithCreateAt:(NSString *)createAt source:(NSString *)source text:(NSString *)text user:(KCUser *)user{
    if (self=[super init]) {
        self.createdAt=createAt;
        self.source=source;
        self.text=text;
        self.user=user;
    }
    return self;
}
-(KCStatus *)initWithCreateAt:(NSString *)createAt source:(NSString *)source text:(NSString *)text userId:(int)userId{
    if (self=[super init]) {
        self.createdAt=createAt;
        self.source=source;
        self.text=text;
        KCUser *user=[[KCUser alloc]init];
        user.Id=[NSNumber numberWithInt:userId];
        self.user=user;
    }
    return self;
}
-(NSString *)source{
    return [NSString stringWithFormat:@"来自 %@",_source];
}
+(KCStatus *)statusWithCreateAt:(NSString *)createAt source:(NSString *)source text:(NSString *)text user:(KCUser *)user{
    KCStatus *status=[[KCStatus alloc]initWithCreateAt:createAt source:source text:text user:user];
    return status;
}
+(KCStatus *)statusWithCreateAt:(NSString *)createAt source:(NSString *)source text:(NSString *)text userId:(int)userId{
    KCStatus *status=[[KCStatus alloc]initWithCreateAt:createAt source:source text:text userId:userId];
    return status;
}
@end
</code></pre>

<p>然后，编写服务类，进行数据的增、删、改、查操作，由于服务类方法同样不需要过多的配置，因此定义为单例，保证程序中只有一个实例即可。服务类中调用前面封装的数据库方法将对数据库的操作转换为对模型的操作。</p>

<p>KCUserService.h</p>

<pre><code>//
//  KCUserService.h
//  DataAccess
//
//  Created by Kenshin Cui on 14-3-29.
//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.
//
#import &lt;Foundation/Foundation.h&gt;
#import "KCUser.h"
#import "KCSingleton.h"
@interface KCUserService : NSObject
singleton_interface(KCUserService)
/**
 *  添加用户信息
 *
 *  @param user 用户对象
 */
-(void)addUser:(KCUser *)user;
/**
 *  删除用户
 *
 *  @param user 用户对象
 */
-(void)removeUser:(KCUser *)user;
/**
 *  根据用户名删除用户
 *
 *  @param name 用户名
 */
-(void)removeUserByName:(NSString *)name;
/**
 *  修改用户内容
 *
 *  @param user 用户对象
 */
-(void)modifyUser:(KCUser *)user;
/**
 *  根据用户编号取得用户
 *
 *  @param Id 用户编号
 *
 *  @return 用户对象
 */
-(KCUser *)getUserById:(int)Id;
/**
 *  根据用户名取得用户
 *
 *  @param name 用户名
 *
 *  @return 用户对象
 */
-(KCUser *)getUserByName:(NSString *)name;
@end
</code></pre>

<p>KCUserService.m</p>

<pre><code>//
//  KCUserService.m
//  DataAccess
//
//  Created by Kenshin Cui on 14-3-29.
//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.
//
#import "KCUserService.h"
#import "KCUser.h"
#import "KCDbManager.h"
@implementation KCUserService
singleton_implementation(KCUserService)
-(void)addUser:(KCUser *)user{
    NSString *sql=[NSString stringWithFormat:@"INSERT INTO User (name,screenName, profileImageUrl,mbtype,city) VALUES('%@','%@','%@','%@','%@')",user.name,user.screenName, user.profileImageUrl,user.mbtype,user.city];
    [[KCDbManager sharedKCDbManager] executeNonQuery:sql];
}
-(void)removeUser:(KCUser *)user{
    NSString *sql=[NSString stringWithFormat:@"DELETE FROM User WHERE Id='%@'",user.Id];
    [[KCDbManager sharedKCDbManager] executeNonQuery:sql];
}
-(void)removeUserByName:(NSString *)name{
    NSString *sql=[NSString stringWithFormat:@"DELETE FROM User WHERE name='%@'",name];
    [[KCDbManager sharedKCDbManager] executeNonQuery:sql];
}
-(void)modifyUser:(KCUser *)user{
    NSString *sql=[NSString stringWithFormat:@"UPDATE User SET name='%@',screenName='%@',profileImageUrl='%@',mbtype='%@',city='%@' WHERE Id='%@'",user.name,user.screenName,user.profileImageUrl,user.mbtype,user.city,user.Id];
    [[KCDbManager sharedKCDbManager] executeNonQuery:sql];
}
-(KCUser *)getUserById:(int)Id{
    KCUser *user=[[KCUser alloc]init];
    NSString *sql=[NSString stringWithFormat:@"SELECT name,screenName,profileImageUrl,mbtype,city FROM User WHERE Id='%i'", Id];
    NSArray *rows= [[KCDbManager sharedKCDbManager] executeQuery:sql];
    if (rows&amp;&amp;rows.count&gt;0) {
        [user setValuesForKeysWithDictionary:rows[0]];
    }
    return user;
}
-(KCUser *)getUserByName:(NSString *)name{
    KCUser *user=[[KCUser alloc]init];
    NSString *sql=[NSString stringWithFormat:@"SELECT Id, name,screenName,profileImageUrl,mbtype,city FROM User WHERE name='%@'", name];
    NSArray *rows= [[KCDbManager sharedKCDbManager] executeQuery:sql];
    if (rows&amp;&amp;rows.count&gt;0) {
        [user setValuesForKeysWithDictionary:rows[0]];
    }
    return user;
}
@end
</code></pre>

<p>KCStatusService.h</p>

<pre><code>//
//  KCStatusService.h
//  DataAccess
//
//  Created by Kenshin Cui on 14-3-29.
//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.
//
#import &lt;Foundation/Foundation.h&gt;
#import "KCSingleton.h"
@class KCStatus;
@interface KCStatusService : NSObject
singleton_interface(KCStatusService)
/**
 *  添加微博信息
 *
 *  @param status 微博对象
 */
-(void)addStatus:(KCStatus *)status;
/**
 *  删除微博
 *
 *  @param status 微博对象
 */
-(void)removeStatus:(KCStatus *)status;
/**
 *  修改微博内容
 *
 *  @param status 微博对象
 */
-(void)modifyStatus:(KCStatus *)status;
/**
 *  根据编号取得微博
 *
 *  @param Id 微博编号
 *
 *  @return 微博对象
 */
-(KCStatus *)getStatusById:(int)Id;
/**
 *  取得所有微博对象
 *
 *  @return 所有微博对象
 */
-(NSArray *)getAllStatus;
@end
</code></pre>

<p>KCStatusService.m</p>

<pre><code>//
//  KCStatusService.m
//  DataAccess
//
//  Created by Kenshin Cui on 14-3-29.
//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.
//
#import "KCStatusService.h"
#import "KCDbManager.h"
#import "KCStatus.h"
#import "KCUserService.h"
#import "KCSingleton.h"
@interface KCStatusService(){

}
@end
@implementation KCStatusService
singleton_implementation(KCStatusService)
-(void)addStatus:(KCStatus *)status{
    NSString *sql=[NSString stringWithFormat:@"INSERT INTO Status (source,createdAt,\"text\" ,user) VALUES('%@','%@','%@','%@')",status.source,status.createdAt,status.text,status.user.Id];
    [[KCDbManager sharedKCDbManager] executeNonQuery:sql];
}
-(void)removeStatus:(KCStatus *)status{
    NSString *sql=[NSString stringWithFormat:@"DELETE FROM Status WHERE Id='%@'",status.Id];
    [[KCDbManager sharedKCDbManager] executeNonQuery:sql];
}
-(void)modifyStatus:(KCStatus *)status{
    NSString *sql=[NSString stringWithFormat:@"UPDATE Status SET source='%@',createdAt='%@',\"text\"='%@' ,user='%@' WHERE Id='%@'",status.source,status.createdAt,status.text,status.user, status.Id];
    [[KCDbManager sharedKCDbManager] executeNonQuery:sql];
}
-(KCStatus *)getStatusById:(int)Id{
    KCStatus *status=[[KCStatus alloc]init];
    NSString *sql=[NSString stringWithFormat:@"SELECT Id, source,createdAt,\"text\" ,user FROM Status WHERE Id='%i'", Id];
    NSArray *rows= [[KCDbManager sharedKCDbManager] executeQuery:sql];
    if (rows&amp;&amp;rows.count&gt;0) {
        [status setValuesForKeysWithDictionary:rows[0]];
        status.user=[[KCUserService sharedKCUserService] getUserById:[(NSNumber *)rows[0][@"user"] intValue]] ;
    }
    return status;
}
-(NSArray *)getAllStatus{
    NSMutableArray *array=[NSMutableArray array];
    NSString *sql=@"SELECT Id, source,createdAt,\"text\" ,user FROM Status ORDER BY Id";
    NSArray *rows= [[KCDbManager sharedKCDbManager] executeQuery:sql];
    for (NSDictionary *dic in rows) {
        KCStatus *status=[self getStatusById:[(NSNumber *)dic[@"Id"] intValue]];
        [array addObject:status];
    }
    return array;
}
@end
</code></pre>

<p>最后，在视图控制器中调用相应的服务层进行各类数据操作，在下面的代码中分别演示了增、删、改、查四类操作。</p>

<pre><code>KCMainViewController.m
//
//  KCMainTableViewController.m
//  DataAccess
//
//  Created by Kenshin Cui on 14-3-29.
//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.
//
#import "KCMainTableViewController.h"
#import "KCDbManager.h"
#import "KCDatabaseCreator.h"
#import "KCUser.h"
#import "KCStatus.h"
#import "KCUserService.h"
#import "KCStatusService.h"
#import "KCStatusTableViewCell.h"
@interface KCMainTableViewController (){
    NSArray *_status;
    NSMutableArray *_statusCells;
}
@end
@implementation KCMainTableViewController
- (void)viewDidLoad {
    [super viewDidLoad];
    [KCDatabaseCreator initDatabase];

//    [self addUsers];
//    [self removeUser];
//    [self modifyUserInfo];

//    [self addStatus];

    [self loadStatusData];

}
-(void)addUsers{
    KCUser *user1=[KCUser userWithName:@"Binger" screenName:@"冰儿" profileImageUrl:@"binger.jpg" mbtype:@"mbtype.png" city:@"北京"];
    [[KCUserService sharedKCUserService] addUser:user1];
    KCUser *user2=[KCUser userWithName:@"Xiaona" screenName:@"小娜" profileImageUrl:@"xiaona.jpg" mbtype:@"mbtype.png" city:@"北京"];
    [[KCUserService sharedKCUserService] addUser:user2];
    KCUser *user3=[KCUser userWithName:@"Lily" screenName:@"丽丽" profileImageUrl:@"lily.jpg" mbtype:@"mbtype.png" city:@"北京"];
    [[KCUserService sharedKCUserService] addUser:user3];
    KCUser *user4=[KCUser userWithName:@"Qianmo" screenName:@"阡陌" profileImageUrl:@"qianmo.jpg" mbtype:@"mbtype.png" city:@"北京"];
    [[KCUserService sharedKCUserService] addUser:user4];
    KCUser *user5=[KCUser userWithName:@"Yanyue" screenName:@"炎月" profileImageUrl:@"yanyue.jpg" mbtype:@"mbtype.png" city:@"北京"];
    [[KCUserService sharedKCUserService] addUser:user5];
}
-(void)addStatus{
    KCStatus *status1=[KCStatus statusWithCreateAt:@"9:00" source:@"iPhone 6" text:@"一只雪猴在日本边泡温泉边玩iPhone的照片，获得了\"2014年野生动物摄影师\"大赛特等奖。一起来为猴子配个词" userId:1];
    [[KCStatusService sharedKCStatusService] addStatus:status1];
    KCStatus *status2=[KCStatus statusWithCreateAt:@"9:00" source:@"iPhone 6" text:@"一只雪猴在日本边泡温泉边玩iPhone的照片，获得了\"2014年野生动物摄影师\"大赛特等奖。一起来为猴子配个词" userId:1];
    [[KCStatusService sharedKCStatusService] addStatus:status2];
    KCStatus *status3=[KCStatus statusWithCreateAt:@"9:30" source:@"iPhone 6" text:@"【我们送iPhone6了 要求很简单】真心回馈粉丝，小编觉得现在最好的奖品就是iPhone6了。今起到12月31日，关注我们，转发微博，就有机会获iPhone6(奖品可能需要等待)！每月抽一台[鼓掌]。不费事，还是试试吧，万一中了呢" userId:2];
    [[KCStatusService sharedKCStatusService] addStatus:status3];
    KCStatus *status4=[KCStatus statusWithCreateAt:@"9:45" source:@"iPhone 6" text:@"重大新闻：蒂姆库克宣布出柜后，ISIS战士怒扔iPhone，沙特神职人员呼吁人们换回iPhone 4。[via Pan-Arabia Enquirer]" userId:3];
    [[KCStatusService sharedKCStatusService] addStatus:status4];
    KCStatus *status5=[KCStatus statusWithCreateAt:@"10:05" source:@"iPhone 6" text:@"小伙伴们，有谁知道怎么往Iphone4S里倒东西？倒入的东西又该在哪里找？用了Iphone这么长时间，还真的不知道怎么弄！有谁知道啊？谢谢！" userId:4];
    [[KCStatusService sharedKCStatusService] addStatus:status5];
    KCStatus *status6=[KCStatus statusWithCreateAt:@"10:07" source:@"iPhone 6" text:@"在音悦台iPhone客户端里发现一个悦单《Infinite 金明洙》，推荐给大家! " userId:1];
    [[KCStatusService sharedKCStatusService] addStatus:status6];
    KCStatus *status7=[KCStatus statusWithCreateAt:@"11:20" source:@"iPhone 6" text:@"如果sony吧mp3播放器产品发展下去，不贪图手头节目源的现实利益，就木有苹果的ipod，也就木有iphone。柯达类似的现实利益，不自我革命的案例也是一种巨头的宿命。" userId:2];
    [[KCStatusService sharedKCStatusService] addStatus:status7];
    KCStatus *status8=[KCStatus statusWithCreateAt:@"13:00" source:@"iPhone 6" text:@"【iPhone 7 Plus】新买的iPhone 7 Plus ，如何？够酷炫么？" userId:2];
    [[KCStatusService sharedKCStatusService] addStatus:status8];
    KCStatus *status9=[KCStatus statusWithCreateAt:@"13:24" source:@"iPhone 6" text:@"自拍神器#卡西欧TR500#，tr350S～价格美丽，行货，全国联保～iPhone6 iPhone6Plus卡西欧TR150 TR200 TR350 TR350S全面到货 招收各种代理！[给力]微信：39017366" userId:3];
    [[KCStatusService sharedKCStatusService] addStatus:status9];
    KCStatus *status10=[KCStatus statusWithCreateAt:@"13:26" source:@"iPhone 6" text:@"猜到猴哥玩手机时所思所想者，再奖iPhone一部。（奖品由“2014年野生动物摄影师”评委会颁发）" userId:3];
    [[KCStatusService sharedKCStatusService] addStatus:status10];
}
-(void)removeUser{
    //注意在SQLite中区分大小写
    [[KCUserService sharedKCUserService] removeUserByName:@"Yanyue"];
}
-(void)modifyUserInfo{
    KCUser *user1= [[KCUserService sharedKCUserService]getUserByName:@"Xiaona"];
    user1.city=@"上海";
    [[KCUserService sharedKCUserService] modifyUser:user1];

    KCUser *user2= [[KCUserService sharedKCUserService]getUserByName:@"Lily"];
    user2.city=@"深圳";
    [[KCUserService sharedKCUserService] modifyUser:user2];
}
#pragma mark 加载数据
-(void)loadStatusData{
    _statusCells=[[NSMutableArray alloc]init];
    _status=[[KCStatusService sharedKCStatusService]getAllStatus];
    [_status enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {
        KCStatusTableViewCell *cell=[[KCStatusTableViewCell alloc]init];
        cell.status=(KCStatus *)obj;
        [_statusCells addObject:cell];
    }];
    NSLog(@"%@",[_status lastObject]);
}
#pragma mark - Table view data source
- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView {
    return 1;
}
- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section {
    return _status.count;
}
- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {
    static NSString *identtityKey=@"myTableViewCellIdentityKey1";
    KCStatusTableViewCell *cell=[self.tableView dequeueReusableCellWithIdentifier:identtityKey];
    if(cell==nil){
        cell=[[KCStatusTableViewCell alloc]initWithStyle:UITableViewCellStyleValue1 reuseIdentifier:identtityKey];
    }
    cell.status=_status[indexPath.row];
    return cell;
}
-(CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath{
    return ((KCStatusTableViewCell *)_statusCells[indexPath.row]).height;
}
-(CGFloat)tableView:(UITableView *)tableView heightForHeaderInSection:(NSInteger)section{
    return 20.0f;
}
@end
</code></pre>

<p>项目目录结构：</p>

<p><img src="http://al1020119.github.io/images/CSR002.jpg" title="Caption" ></p>

<p>运行效果</p>

<p><img src="http://al1020119.github.io/images/CSR003.jpg" title="Caption" >
Core Data</p>

<p>基本概念</p>

<p>当前，各类应用开发中只要牵扯到数据库操作通常都会用到一个概念“对象关系映射（ORM）”。例如在Java平台使用Hibernate，在.NET平台使用Entity Framework、Linq、NHibernate等。在iOS中也不例外，iOS中ORM框架首选Core Data，这是官方推荐的，不需要借助第三方框架。无论是哪种平台、哪种技术，ORM框架的作用都是相同的，那就是将关系数据库中的表（准确的说是实体）转换为程序中的对象，其本质还是对数据库的操作（例如Core Data中如果存储类型配置为SQLite则本质还是操作的SQLite数据库）。细心的朋友应该已经注意到，在上面的SQLite中其实我们在KCMainViewController中进行的数据库操作已经转换为了对象操作，服务层中的方法中已经将对数据库的操作封装起来，转换为了对Model的操作，这种方式已经是面向对象的。上述通过将对象映射到实体的过程完全是手动完成的，相对来说操作比较复杂，就拿对KCStatus对象的操作来说：首先要手动创建数据库（Status表），其次手动创建模型KCStatus，接着创建服务层KCStatusService。Core Data正是为了解决这个问题而产生的，它将数据库的创建、表的创建、对象和表的转换等操作封装起来，简化了我们的操作（注意Core Data只是将对象关系的映射简化了，并不是把服务层替代了，这一点大家需要明白）。</p>

<p>使用Core Data进行数据库存取并不需要手动创建数据库，这个过程完全由Core Data框架完成，开发人员面对的是模型，主要的工作就是把模型创建起来，具体数据库如何创建则不用管。在iOS项目中添加“Data Model”文件。然后在其中创建实体和关系：</p>

<p><img src="http://al1020119.github.io/images/CSR004.jpg" title="Caption" >
<img src="http://al1020119.github.io/images/CSR005.jpg" title="Caption" ></p>

<p>模型创建的过程中需要注意：</p>

<p>1.实体对象不需要创建ID主键，Attributes中应该是有意义属性（创建过程中应该考虑对象的属性而不是数据库中表有几个字段，尽管多数属性会对应表的字段）。</p>

<p>2.所有的属性应该指定具体类型（尽管在SQLite中可以不指定），因为实体对象会对应生成ObjC模型类。</p>

<p>3.实体对象中其他实体对象类型的属性应该通过Relationships建立，并且注意实体之间的对应关系（例如一个用户有多条微博，而一条微博则只属于一个用户,用户和微博形成一对多的关系）。</p>

<p>以上模型创建后，接下来就是根据上面的模型文件（.xcdatamodeld文件）生成具体的实体类。在Xcode中添加“NSManagedObject Subclass”文件，按照步骤选择创建的模型及实体，Xcode就会根据所创建模型生成具体的实体类。</p>

<p>User.h</p>

<pre><code>//
//  User.h
//  CoreData
//
//  Created by Kenshin Cui on 14/03/27.
//  Copyright (c) 2014年 cmjstudio. All rights reserved.
//
#import &lt;Foundation/Foundation.h&gt;
#import &lt;CoreData/CoreData.h&gt;
@class Status;
@interface User : NSManagedObject
@property (nonatomic, retain) NSString * city;
@property (nonatomic, retain) NSString * mbtype;
@property (nonatomic, retain) NSString * name;
@property (nonatomic, retain) NSString * profileImageUrl;
@property (nonatomic, retain) NSString * screenName;
@property (nonatomic, retain) NSSet *statuses;
@end
@interface User (CoreDataGeneratedAccessors)
- (void)addStatusesObject:(Status *)value;
- (void)removeStatusesObject:(Status *)value;
- (void)addStatuses:(NSSet *)values;
- (void)removeStatuses:(NSSet *)values;
@end
</code></pre>

<p>User.m</p>

<pre><code>//
//  User.m
//  CoreData
//
//  Created by Kenshin Cui on 14/03/27.
//  Copyright (c) 2014年 cmjstudio. All rights reserved.
//
#import "User.h"
#import "Status.h"
@implementation User
@dynamic city;
@dynamic mbtype;
@dynamic name;
@dynamic profileImageUrl;
@dynamic screenName;
@dynamic statuses;
@end
</code></pre>

<p>Status.h</p>

<pre><code>//
//  Status.h
//  CoreData
//
//  Created by Kenshin Cui on 14/03/27.
//  Copyright (c) 2014年 cmjstudio. All rights reserved.
//
#import &lt;Foundation/Foundation.h&gt;
#import &lt;CoreData/CoreData.h&gt;
@interface Status : NSManagedObject
@property (nonatomic, retain) NSDate * createdAt;
@property (nonatomic, retain) NSString * source;
@property (nonatomic, retain) NSString * text;
@property (nonatomic, retain) NSManagedObject *user;
@end

Status.m


//
//  Status.m
//  CoreData
//
//  Created by Kenshin Cui on 14/03/27.
//  Copyright (c) 2014年 cmjstudio. All rights reserved.
//
#import "Status.h"
@implementation Status
@dynamic createdAt;
@dynamic source;
@dynamic text;
@dynamic user;
@end
</code></pre>

<p>很显然，通过模型生成类的过程相当简单，通常这些类也不需要手动维护，如果模型发生的变化只要重新生成即可。有几点需要注意：</p>

<p>1.所有的实体类型都继承于NSManagedObject，每个NSManagedObject对象对应着数据库中一条记录。</p>

<p>2.集合属性（例如User中的status）生成了访问此属性的分类方法。</p>

<p>3.使用@dynamic代表具体属性实现，具体实现细节不需要开发人员关心。</p>

<p>当然，了解了这些还不足以完成数据的操作。究竟Core Data具体的设计如何，要完成数据的存取我们还需要了解一下Core Data几个核心的类。</p>

<p><img src="http://al1020119.github.io/images/CSR006.jpg" title="Caption" ></p>

<ol>
<li><p>Persistent Object Store：可以理解为存储持久对象的数据库（例如SQLite，注意Core Data也支持其他类型的数据存储，例如xml、二进制数据等）。</p></li>
<li><p>Managed Object Model：对象模型，对应Xcode中创建的模型文件。</p></li>
<li><p>Persistent Store Coordinator：对象模型和实体类之间的转换协调器，用于管理不同存储对象的上下文。</p></li>
<li><p>Managed Object Context:对象管理上下文，负责实体对象和数据库之间的交互。</p></li>
</ol>


<p>Core Data使用</p>

<p>Core Data使用起来相对直接使用SQLite3的API而言更加的面向对象，操作过程通常分为以下几个步骤：</p>

<p>1.创建管理上下文</p>

<p>创建管理上下可以细分为：加载模型文件->指定数据存储路径->创建对应数据类型的存储->创建管理对象上下方并指定存储。</p>

<p>经过这几个步骤之后可以得到管理对象上下文NSManagedObjectContext，以后所有的数据操作都由此对象负责。同时如果是第一次创建上下文，Core Data会自动创建存储文件（例如这里使用SQLite3存储），并且根据模型对象创建对应的表结构。下图为第一次运行生成的数据库及相关映射文件：</p>

<p><img src="http://al1020119.github.io/images/CSR007.jpg" title="Caption" ></p>

<p>为了方便后面使用，NSManagedObjectContext对象可以作为单例或静态属性来保存，下面是创建的管理对象上下文的主要代码：</p>

<pre><code>-(NSManagedObjectContext *)createDbContext{
    NSManagedObjectContext *context;
    //打开模型文件，参数为nil则打开包中所有模型文件并合并成一个
    NSManagedObjectModel *model=[NSManagedObjectModel mergedModelFromBundles:nil];
    //创建解析器
    NSPersistentStoreCoordinator *storeCoordinator=[[NSPersistentStoreCoordinator alloc]initWithManagedObjectModel:model];
    //创建数据库保存路径
    NSString *dir=[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject];
    NSLog(@"%@",dir);
    NSString *path=[dir stringByAppendingPathComponent:@"myDatabase.db"];
    NSURL *url=[NSURL fileURLWithPath:path];
    //添加SQLite持久存储到解析器
    NSError *error;
    [storeCoordinator addPersistentStoreWithType:NSSQLiteStoreType configuration:nil URL:url options:nil error:&amp;error];
    if(error){
        NSLog(@"数据库打开失败！错误:%@",error.localizedDescription);
    }else{
        context=[[NSManagedObjectContext alloc]init];
        context.persistentStoreCoordinator=storeCoordinator;
        NSLog(@"数据库打开成功！");
    }
    return context;
}
</code></pre>

<p>2.查询数据</p>

<p>对于有条件的查询，在Core Data中是通过谓词来实现的。首先创建一个请求，然后设置请求条件，最后调用上下文执行请求的方法。</p>

<pre><code>-(void)addUserWithName:(NSString *)name screenName:(NSString *)screenName profileImageUrl:(NSString *)profileImageUrl mbtype:(NSString *)mbtype city:(NSString *)city{
    //添加一个对象
    User *us= [NSEntityDescription insertNewObjectForEntityForName:@"User" inManagedObjectContext:self.context];
    us.name=name;
    us.screenName=screenName;
    us.profileImageUrl=profileImageUrl;
    us.mbtype=mbtype;
    us.city=city;
    NSError *error;
    //保存上下文
    if (![self.context save:&amp;error]) {
        NSLog(@"添加过程中发生错误,错误信息：%@！",error.localizedDescription);
    }
}
</code></pre>

<p>如果有多个条件，只要使用谓词组合即可，那么对于关联对象条件怎么查询呢？这里分为两种情况进行介绍：</p>

<p>a.查找一个对象只有唯一一个关联对象的情况，例如查找用户名为“Binger”的微博（一个微博只能属于一个用户），通过keypath查询</p>

<pre><code>-(NSArray *)getStatusesByUserName:(NSString *)name{
    NSFetchRequest *request=[NSFetchRequest fetchRequestWithEntityName:@"Status"];
    request.predicate=[NSPredicate predicateWithFormat:@"user.name=%@",name];
    NSArray *array=[self.context executeFetchRequest:request error:nil];
    return  array;
}
</code></pre>

<p>此时如果跟踪Core Data生成的SQL语句会发现其实就是把Status表和User表进行了关联查询（JOIN连接）。</p>

<p>b.查找一个对象有多个关联对象的情况，例如查找发送微博内容中包含“Watch”并且用户昵称为“小娜”的用户（一个用户有多条微博），此时可以充分利用谓词进行过滤。</p>

<pre><code>-(NSArray *)getUsersByStatusText:(NSString *)text screenName:(NSString *)screenName{
    NSFetchRequest *request=[NSFetchRequest fetchRequestWithEntityName:@"Status"];
    request.predicate=[NSPredicate predicateWithFormat:@"text LIKE '*Watch*'",text];
    NSArray *statuses=[self.context executeFetchRequest:request error:nil];

    NSPredicate *userPredicate= [NSPredicate predicateWithFormat:@"user.screenName=%@",screenName];
    NSArray *users= [statuses filteredArrayUsingPredicate:userPredicate];
    return users;
}
</code></pre>

<p>注意：如果单纯查找微博中包含“Watch”的用户，直接查出对应的微博，然后通过每个微博的user属性即可获得用户，此时就不用使用额外的谓词过滤条件。</p>

<p>3.插入数据</p>

<p>插入数据需要调用实体描述对象NSEntityDescription返回一个实体对象，然后设置对象属性，最后保存当前上下文即可。这里需要注意，增、删、改操作完最后必须调用管理对象上下文的保存方法，否则操作不会执行。</p>

<pre><code>-(void)addUserWithName:(NSString *)name screenName:(NSString *)screenName profileImageUrl:(NSString *)profileImageUrl mbtype:(NSString *)mbtype city:(NSString *)city{
    //添加一个对象
    User *us= [NSEntityDescription insertNewObjectForEntityForName:@"User" inManagedObjectContext:self.context];
    us.name=name;
    us.screenName=screenName;
    us.profileImageUrl=profileImageUrl;
    us.mbtype=mbtype;
    us.city=city;
    NSError *error;
    //保存上下文
    if (![self.context save:&amp;error]) {
        NSLog(@"添加过程中发生错误,错误信息：%@！",error.localizedDescription);
    }
}
</code></pre>

<p>4.删除数据</p>

<p>删除数据可以直接调用管理对象上下文的deleteObject方法，删除完保存上下文即可。注意，删除数据前必须先查询到对应对象。</p>

<pre><code>-(void)removeUser:(User *)user{
    [self.context deleteObject:user];
    NSError *error;
    if (![self.context save:&amp;error]) {
        NSLog(@"删除过程中发生错误，错误信息：%@!",error.localizedDescription);
    }
}
</code></pre>

<p>5.修改数据</p>

<p>修改数据首先也是取出对应的实体对象，然后通过修改对象的属性，最后保存上下文。</p>

<pre><code>-(void)modifyUserWithName:(NSString *)name screenName:(NSString *)screenName profileImageUrl:(NSString *)profileImageUrl mbtype:(NSString *)mbtype city:(NSString *)city{
    User *us=[self getUserByName:name];
    us.screenName=screenName;
    us.profileImageUrl=profileImageUrl;
    us.mbtype=mbtype;
    us.city=city;
    NSError *error;
    if (![self.context save:&amp;error]) {
        NSLog(@"修改过程中发生错误,错误信息：%@",error.localizedDescription);
    }
}
</code></pre>

<p>调试</p>

<p>虽然Core Data（如果使用SQLite数据库）操作最终转换为SQL操作，但是调试起来却不想操作SQL那么方便。特别是对于初学者而言经常出现查询报错的问题，如果能看到最终生成的SQL语句自然对于调试很有帮助。事实上在Xcode中是支持Core Data调试的，具体操作：Product-Scheme-Edit Scheme-Run-Arguments中依次添加两个参数（注意参数顺序不能错）：-com.apple.CoreData.SQLDebug、1。然后在运行程序过程中如果操作了数据库就会将SQL语句打印在输出面板。</p>

<p><img src="http://al1020119.github.io/images/CSR008.jpg" title="Caption" ></p>

<p>注意：如果模型发生了变化，此时可以重新生成实体类文件，但是所生成的数据库并不会自动更新，这时需要考虑重新生成数据库并迁移原有的数据。</p>

<p>FMDB</p>

<p>基本使用</p>

<p>相比于SQLite3来说Core Data存在着诸多优势，它面向对象，开发人员不必过多的关心更多数据库操作知识，同时它基于ObjC操作，书写更加优雅等。但是它本身也存在着一定的限制，例如如果考虑到跨平台，则只能选择SQLite，因为无论是iOS还是Android都可以使用同一个数据库，降低了开发成本和维护成本。其次是当前多数ORM框架都存在的性能问题，因为ORM最终转化为SQL操作，其中牵扯到模型数据转化，其性能自然比不上直接使用SQL操作数据库。那么有没有更好的选择呢？答案就是对SQLite进行封装。</p>

<p>其实通过前面对于SQLite的分析，大家应该已经看到KCDbManager就是对于SQLite封装的结果，开发人员面对的只有SQL和ObjC方法，不用过多libsqlite3的C语言API。但它毕竟只是一个简单的封装，还有更多的细节没有考虑，例如如何处理并发安全性，如何更好的处理事务等。因此，这里推荐使用第三方框架FMDB，整个框架非常轻量级但又不失灵活性，也是很多企业开发的首选。</p>

<p>1.FMDB既然是对于libsqlite3框架的封装，自然使用起来也是类似的，使用前也要打开一个数据库，这个数据库文件存在则直接打开否则会创建并打开。这里FMDB引入了一个MFDatabase对象来表示数据库，打开数据库和后面的数据库操作全部依赖此对象。下面是打开数据库获得MFDatabase对象的代码：</p>

<pre><code>-(void)openDb:(NSString *)dbname{
    //取得数据库保存路径，通常保存沙盒Documents目录
    NSString *directory=[NSSearchPathForDirectoriesInDomains(NSDocumentationDirectory, NSUserDomainMask, YES) firstObject];
    NSLog(@"%@",directory);
    NSString *filePath=[directory stringByAppendingPathComponent:dbname];
    //创建FMDatabase对象
    self.database=[FMDatabase databaseWithPath:filePath];
    //打开数据上
    if ([self.database open]) {
        NSLog(@"数据库打开成功!");
    }else{
        NSLog(@"数据库打开失败!");
    }
}
</code></pre>

<p>注意：dataWithPath中的路径参数一般会选择保存到沙箱中的Documents目录中；如果这个参数设置为nil则数据库会在内存中创建；如果设置为@””则会在沙箱中的临时目录创建,应用程序关闭则文件删除。</p>

<p>2.对于数据库的操作跟前面KCDbManager的封装是类似的，在FMDB中FMDatabase类提供了两个方法executeUpdate:和executeQuery:分别用于执行无返回结果的查询和有返回结果的查询。当然这两个方法有很多的重载这里就不详细解释了。唯一需要指出的是，如果调用有格式化参数的sql语句时，格式化符号使用“?”而不是“%@”、等。下面是两种情况的代码片段：</p>

<p>a.无返回结果</p>

<p>-(void)executeNonQuery:(NSString *)sql{
    //执行更新sql语句，用于插入、修改、删除
    if (![self.database executeUpdate:sql]) {
        NSLog(@&ldquo;执行SQL语句过程中发生错误！&rdquo;);
    }
}</p>

<p>b.有返回结果</p>

<p>-(NSArray <em>)executeQuery:(NSString </em>)sql{
    NSMutableArray <em>array=[NSMutableArray array];
    //执行查询sql语句
    FMResultSet </em>result= [self.database executeQuery:sql];
    while (result.next) {
        NSMutableDictionary *dic=[NSMutableDictionary dictionary];
        for (int i=0; i&lt;result.columnCount; ++i) {
            dic[[result columnNameForIndex:i]]=[result stringForColumnIndex:i];
        }
        [array addObject:dic];
    }
    return array;
}</p>

<p>对于有返回结果的查询而言，查询完返回一个游标FMResultSet，通过遍历游标进行查询。而且FMDB中提供了大量intForColumn、stringForColumn等方法进行取值。</p>

<p>并发和事务</p>

<p>我们知道直接使用libsqlite3进行数据库操作其实是线程不安全的，如果遇到多个线程同时操作一个表的时候可能会发生意想不到的结果。为了解决这个问题建议在多线程中使用FMDatabaseQueue对象，相比FMDatabase而言，它是线程安全的。</p>

<p>创建FMDatabaseQueue的方法是类似的，调用databaseQueueWithPath:方法即可。注意这里不需要调用打开操作。</p>

<pre><code>-(void)openDb:(NSString *)dbname{
    //取得数据库保存路径，通常保存沙盒Documents目录
    NSString *directory=[NSSearchPathForDirectoriesInDomains(NSDocumentationDirectory, NSUserDomainMask, YES) firstObject];
    NSLog(@"%@",directory);
    NSString *filePath=[directory stringByAppendingPathComponent:dbname];
    //创建FMDatabaseQueue对象
    self.database=[FMDatabaseQueue databaseQueueWithPath:filePath];
}
</code></pre>

<p>然后所有的增删改查操作调用FMDatabaseQueue的inDatabase:方法在block中执行操作sql语句即可。</p>

<pre><code>-(void)executeNonQuery:(NSString *)sql{
    //执行更新sql语句，用于插入、修改、删除
    [self.database inDatabase:^(FMDatabase *db) {
        [db executeQuery:sql];
    }];
}
-(NSArray *)executeQuery:(NSString *)sql{
    NSMutableArray *array=[NSMutableArray array];
    [self.database inDatabase:^(FMDatabase *db) {
        //执行查询sql语句
        FMResultSet *result= [db executeQuery:sql];
        while (result.next) {
            NSMutableDictionary *dic=[NSMutableDictionary dictionary];
            for (int i=0; i&lt;result.columnCount; ++i) {
                dic[[result columnNameForIndex:i]]=[result stringForColumnIndex:i];
            }
            [array addObject:dic];
        }
    }];
    return array;
}
</code></pre>

<p>之所以将事务放到FMDB中去说并不是因为只有FMDB才支持事务，而是因为FMDB将其封装成了几个方法来调用，不用自己写对应的sql而已。其实在在使用libsqlite3操作数据库时也是原生支持事务的（因为这里的事务是基于数据库的，FMDB还是使用的SQLite数据库），只要在执行sql语句前加上“begin transaction;”执行完之后执行“commit transaction;”或者“rollback transaction;”进行提交或回滚即可。另外在Core Data中大家也可以发现，所有的增、删、改操作之后必须调用上下文的保存方法，其实本身就提供了事务的支持，只要不调用保存方法，之前所有的操作是不会提交的。在FMDB中FMDatabase有beginTransaction、commit、rollback三个方法进行开启事务、提交事务和回滚事务。</p>

<p>总结：</p>

<p>core data</p>

<p>core data 基于model-view-controller（mvc）模式下，为创建分解的cocoa应用程序提供了一个灵活和强大的数据模型框架。</p>

<p>core data可以使你以图形界面的方式快速的定义app的数据模型，同时在你的代码中容易获取到它。core data提供了基础结构去处理常用的功能，例如保存，恢复，撤销和重做，允许你在app中继续创建新的任务。在使用core data的时候，你不用安装额外的数据库系统，因为core data使用内置的sqlite数据库。</p>

<p>core data提供了一个通用的数据管理解决方案来处理那些所有需要数据模型的app(或大或小)。app使用core data来管理数据对象是很多的益处。</p>

<p>苹果的图形用户界面编译器-interface builder（IB），提供了对core data controller对象的预构建，从而来减少app的用户界面和它的数据模型之间的粘滞代码。在使用core data的时候你不需要考虑sql的语法问题，也不需要管理相关的逻辑树去追踪用户的行为，更不用建立新的永久机制。当你写你app的用户界面到它的 core data模型的时候，它已经为你把所有的东西都做好了。</p>

<p>core data将你app的模型层放入到一组定义在内存中的数据对象。core data会追踪这些对象的改变，同时可以根据需要做相反的改变，例如用户执行撤销命令。当core data在对你app数据的改变进行保存的时候，core data会把这些数据归档，并永久性保存。它保存的数据在一些常规的文件，你可以在Finder中可以进行管理，用spotlight进行搜索，备份到 cd，和email给朋友或者家人。</p>

<p>在使用core data框架的时候，你可以创建一个管理对象的模型，该模型提供了对模型对象的抽象定义，这也就是我们所知道的entities，它可以在我们的程序中使用。</p>

<p>core data是一个实体-关系模型，该模型是使用Xcode的数据模型设计工具来定义的，对数据实体以及他们的关系提供了丰富的环境。</p>

<p>sqlite</p>

<p>mac os x中sqlite库，它是一个轻量级功能强大的关系数据引擎，也很容易嵌入到应用程序。可以在多个平台使用，sqlite是一个轻量级的嵌入式sql数据库编程。与core data框架不同的是，sqlite是使用程序式的，sql的主要的API来直接操作数据表。</p>

<p>fmdb
FMDB框架其实只是一层很薄的封装，主要的类也就两个：FMDatabase和FMResultSet。在使用fmdb的时候还需要导入libsqlite3.0.dylib。</p>

<p>core data允许用户使用代表实体和实体间关系的高层对象来操作数据。它也可以管理串行化的数据，提供对象生存期管理与object_graph 管理，包括存储。Core Data直接与Sqlite交互，避免开发者使用原本的SQL语句.</p>

<p>上面的三种，都是在什么情况下使用呢？
在编写程序的时候尽量使用core data，这样才是最优的选择。
至于sqlite和fmdb的使用情况，这个看个人喜好了，个人觉得没什么标准。fmdb就是对sqlite的封装，使用起来有方便的接口，没那么麻烦而已。</p>

<pre><code>Q Q：2211523682/790806573

微信：18370997821/13148454507

微博WB:http://weibo.com/u/3288975567?is_hot=1

git博文：http://al1020119.github.io/

github：https://github.com/al1020119
</code></pre>

<p><img src="http://al1020119.github.io/images/iCocosCoder.jpg" title="Caption" ></p>

<p><img src="http://al1020119.github.io/images/iCocosPublic.jpg" title="Caption" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CoreData 大战 SQLite]]></title>
    <link href="http://al1020119.github.io/blog/2016/07/05/xsqlyucoredata/"/>
    <updated>2016-07-05T14:59:42+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/07/05/xsqlyucoredata</id>
    <content type="html"><![CDATA[<p>凭良心讲，我不能告诉你不去使用Core Data。它不错，而且也在变好，并且它被很多其他Cocoa开发者所理解，当有新人加入你的组或者需要别人接手你的项目的时候，这点很重要。</p>

<p>更重要的是，不值得花时间和精力去写自己的系统去代替它。真的，使用Core Data吧。</p>

<p>为什么我不使用Core Data<br/>
 Mike Ash写到：就我自己而言，我不是个狂热粉丝。我发现API是笨拙的，并且框架本身对于大量的数据是极其缓慢的。</p>

<p>一个实际的例子：10,000条目
想象一个RSS阅读器，一个用户可以在一个feed上点击右键，并且选择标记所有为已读。</p>

<!--more-->


<p>引擎下，有一个带有read属性的Article实体。把所有条目标记为已读，程序需要加载这个feed的所有文章(可能通过一对多的关系)，然后设置read属性为YES。</p>

<p>大部分情况下这样没关系。但是设想那个feed里有200个文章，为了避免阻塞主线程，你可能考虑在后台线程里做这个工作(特别当你的程序是一个iPhone应用)。当你一开始使用Core Data多线程，事情就开始变的不好处理了。</p>

<p>这可能还凑合，至少不值得切换走Core Data。</p>

<p>但是接下来加同步。</p>

<p>我用过两种不同的获取已读文章ID列表的RSS同步接口。其中一个返回近10,000个ID。</p>

<p>你不会打算在主线程中加载10,000个文章，然后设置read为NO。你甚至不想在后台线程里加载10,000个文章，即使很小心的管理内存，这有太多的工作（如果你频繁的这么做，想一下对电池寿命的影响）。</p>

<p>你真正想要做的是，让数据库给在ID列表里的每一个文章设置read为YES。</p>

<p>SQLite可以做到这个，只用一次调用。假设uniqueID上有索引，这会很快。而且你可以在后台线程执行像在主线程执行一样容易。</p>

<p>另一个例子：快速启动
我想减少我的另一个程序的启动时间，不只是开始的时间，而是在数据显示之前的所有时间。</p>

<p>那是个类似Twitter的应用(虽然它不是)，它显示消息的时间轴。显示时间轴意味着获取消息，加载相关用户。它很快，但是在启动的时候，会填充UI，然后填充数据。</p>

<p>关于iPhone的应用（或者所有应用）我的理论是，启动时间很重要，比其他大部分开发者想的都要重要。应用的启动很慢看起来不像是要启动一样，因为人们潜意识里记得，并且会产生阻止启动应用的想法。减少启动时间就减少了摩擦，让用户更有可能继续使用你的应用，并且推荐给其他人。这是你让你的应用成功的一部分。</p>

<p>因为我不使用Core Data，我手边有一个简单的，保守的解决方案。我把timeline（消息和人物对象）通过NSCoding保存到一个plist文件中。启动的时候它读这个文件，创建消息和人物对象，UI一出现就显示时间轴。</p>

<p>这明显的减少了延迟。</p>

<p>把消息和人物对象作为NSManagedObject的实例对象，这是不可能的。（假设我有编码的并且存储的IDs对象，但是那意味着读plist然后触及数据库。这种方式我完全避免了数据库）。</p>

<p>在更新更快的机器出来后, 我去掉了那些代码。回顾过去，我希望我可以把它留下来。</p>

<p>我怎么考虑这个问题
当考虑是否使用Core Data时，我考虑下面这些事情：</p>

<p>会有难以置信数量的数据吗？
对于一个RSS阅读器或者Twitter应用，答案显而易见：是的。有些人关注上百个人。一个人可能订阅了上千个feeds。</p>

<p>即使你的应用不从网络获取数据，仍然有可能让用户自动添加数据。如果你用一个支持AppleScript的Mac，有些人会写脚本去加载非常多的数据。如果通过web API去加数据也是一样的。</p>

<p>会有一个Web API包含类似于数据库的终端吗（对比类对象终端）？
一个RSS同步API能够返回一个已读文章的uniquelIDs列表。一个记笔记的应用的一个同步API可能返回已存档的和已删除的笔记的uniquelIDs。</p>

<p>用户可能通过操作处理大量对象吗？
在底层，需要考虑和之前一样的问题。当有人删除所有下载的5，000个面食食谱，你的食谱应用可以多好的完成这个功能（在iPhone上？）？</p>

<p>当我决定使用Core Data（我已经发布过使用Core Data的应用），我会小心留意我怎么使用它。为了得到好的性能，我发现我把它当做一个SQL数据库的一个奇怪接口来使用，然后我知道我应该舍弃Core Data，直接使用SQLite。</p>

<p>我怎么使用SQLite
我通过FMDB Wrapper来使用SQLite，FMDB来自Flying Meat Software，由Gus Mueller提供。</p>

<p>基本操作
我在iPhone以前，Core Data以前就使用过SQLite。这是它怎么工作的的要点：</p>

<ol>
<li>所有数据库访问-读和写-发生在连续的队列里，在一个后台线程。在主线程中触及数据库是从来不被允许的。使用一个连续队列来保证每一件事是按顺序发生的。</li>
<li>我大量使用blocks来让异步程序容易点。</li>
<li>模型对象只存在在主线程（但有两个重要的例外），改变会触发一个后台保存。</li>
<li>模型对象列出来他们在数据库中存储的属性。可能在代码里或者在plist文件里。
5, 一些模型对象是唯一的，一些不是。取决于应用的需要（大部分情况是唯一的）。</li>
<li>对关系型数据，我尽可能避免连表查询。</li>
<li>一些对象类型在启动的时候就完全读入内存，另一些对象类型可能只需要创建并维护一个他们的uniqueIDs的。NSMutableSet，所以不需要去触及数据库，我就知道已经有什么。</li>
<li>Web API的调用发生在后台线程，他们使用分开的模型对象。
我会通过我现在的应用的代码来详细描述。</li>
</ol>


<p>数据库更新
在我最近的应用中，有一个单一的数据库控制器-VSDatabaseController，它通过FMDB来与SQLite对话。</p>

<p>FMDB区分更新和查询。更新数据库，app调用：</p>

<pre><code>-[VSDatabaseController runDatabaseBlockInTransaction:(VSDatabaseUpdateBlock)databaseBlock] 
</code></pre>

<p>VSDatabaseUpdateBlock很简单：</p>

<pre><code>typedef void (^VSDatabaseUpdateBlock)(FMDatabase *database); 
</code></pre>

<p>runDatabaseBlockInTransaction也很简单：</p>

<pre><code>- (void)runDatabaseBlockInTransaction:(VSDatabaseUpdateBlock)databaseBlock { 
    dispatch_async(self.serialDispatchQueue, ^{ 
        @autoreleasepool { 
            [self beginTransaction]; 
            databaseBlock(self.database); 
            [self endTransaction]; 
        } 
    }); 
} 
</code></pre>

<p>（注意我用自己的连续调度队列。Gus建议看一下FMDatabaseQueue，也是一个连续调度队列。我还没能去看一下，因为它比FMDB的其他东西都要新。）</p>

<p>beginTransaction和endTransaction的调用是可嵌套的（在我的数据库控制器里）。在合适的时候他们会调用-[FMDatabase beginTransaction] 和 -[FMDatabase commit]。（使用事务是让SQLite变快的关键。）提示：我把当前事务存储在-[NSThread threadDictionary]。它很好获取每一个线程的数据，我几乎从不用其他的。</p>

<p>这儿有个调用更新数据库的简单例子：</p>

<pre><code>- (void)emptyTagsLookupTableForNote:(VSNote *)note { 
    NSString *uniqueID = note.uniqueID; 
    [self runDatabaseBlockInTransaction:^(FMDatabase *database) { 
        [database executeUpdate: 
            @"delete from tagsNotesLookup where noteUniqueID = ?;", uniqueID]; 
    }]; 
} 
</code></pre>

<p>这说明一些事情。首先SQL不可怕。即使你从没见过它，你也知道这行代码做了什么。</p>

<p>像VSDatabaseController的所有其他公共接口，emptyTagsLookupTableForNote应该在主线程中被调用。模型对象只能在主线程中被引用，所以在block中用uniqueID，而不是VSNote对象。</p>

<p>注意在这种情况下，我更新了一个查找表。Notes和tags是多对多关系，一种表现方式是用一个数据库表映射note uniqueIDs和tag uniqueIDs。这些表不会很难维护，但是如果可能，我确实尝试避免他们的使用。</p>

<p>注意在更新字符串中的?。-[FMDatabase executeUpdate:] 是一个可变参数函数。SQLite支持使用占位符?，所以你不需要把正真的值放入字符串。这儿有一个安全问题：它帮助守护程序反对SQL插入。如果你需要避开某些值，它也为你省了麻烦。</p>

<p>最后，在tagsNotesLookup表中，有一个noteUniquelID的索引（索引是SQLite性能的又一个关键）。这行代码在每次启动时都调用：</p>

<pre><code>[self.database executeUpdate: 
    @"CREATE INDEX if not exists noteUniqueIDIndex on tagsNotesLookup (noteUniqueID);"]; 
</code></pre>

<p>数据库获取
要获取对象，app调用：</p>

<pre><code>-[VSDatabaseController runFetchForClass:(Class)databaseObjectClass  
                             fetchBlock:(VSDatabaseFetchBlock)fetchBlock  
                      fetchResultsBlock:(VSDatabaseFetchResultsBlock)fetchResultsBlock]; 
</code></pre>

<p>这两行代码做了大部分工作：</p>

<pre><code>FMResultSet *resultSet = fetchBlock(self.database); 
NSArray *fetchedObjects = [self databaseObjectsWithResultSet:resultSet  
                                                       class:databaseObjectClass]; 
</code></pre>

<p>用FMDB查找数据库返回一个FMResultSet. 通过resultSet你可以逐句循环，创建模型对象。</p>

<p>我建议写通用的代码去转换数据库行到对象。一种我使用的方法是用一个plist，映射column名字到对象属性。它也包含类型，所以你知道是否需要调用 -[FMResultSet dateForColumn:]， -[FMResultSet stringForColumn:]或其他。</p>

<p>在我的最新应用里我做了些简单的事情。数据库行刚好对应模型对象属性的名字。所有属性都是strings，除了那些名字以“Date”结尾的属性。很简单，但是你可以看到需要一个清晰的对应关系。</p>

<p>唯一对象
创建模型对象和从数据库获取数据在同一个后台线程。一获取到，程序会把他们转到主线程。</p>

<p>通常我有uniqued对象。同一个数据库行结果始终对应同一个对象。</p>

<p>为了做到唯一，我创建了一个对象缓存，一个NSMapTable，在init函数里：_objectCache = [NSMapTable weakToWeakObjectsMapTable]。我来解释一下：</p>

<p>例如，当你做一个数据库获取并且把对象转交给一个视图控制器，你希望在视图控制器使用完这些对象后，或者一个不一样的视图控制器显示了，这些对象可以消失。</p>

<p>如果你的对象缓存是一个NSMutableDictionary，你将需要做一些额外的工作来清空缓存中的对象。确定它对应的对象在别的地方是否有引用就变的很痛苦。NSMapTable是弱引用，就会自动处理这个问题。</p>

<p>所以：我们在主线程中让对象唯一。如果一个对象已经在对象缓存中存在，我们就用那个存在的对象。（主线程胜出，因为它可能有新的改变。）如果对象缓存中没有，它会被加上。</p>

<p>保持对象在内存中
有很多次，把整个对象类型保留在内存中是有道理的。我最新的app有一个VSTag对象。虽然可能有成百上千个笔记，但tags的数量很小，基本少于10。一个tag只有6个属性：3个BOOL，两个很小的NSstring，还有一个NSDate。</p>

<p>启动的时候，app获取所有tags并且把他们保存在两个字典里，一个主键是tag的uniqueID，另一个主键是tag名字的小写。</p>

<p>这简化了很多事，不只是tag自动补全系统，这个可以完全在内存中操作，不需要数据库获取。</p>

<p>但是很多次，把所有数据保留在内存中是不实际的。比如我们不会在内存中保留所有笔记。</p>

<p>但是也有很多次，当不能在内存中保留对象时，你希望在内存中保留所有uniqueIDs。你会像这样做一个获取：</p>

<pre><code>FMResultSet *resultSet = [self.database executeQuery:@"select uniqueID from some_table"]; 
</code></pre>

<p>resultSet只包含了uniqueIDs， 你可以存储到一个NSMutableSet里。</p>

<p>我发现有时这个对web APIs很有用。想象一个API调用返回从某个确定的时间以后的，已创建笔记的uniqueIDs列表。如果我本地已经有了一个包含所有笔记uniqueIDs的NSMutableSet，我可以快速检查(通过 -[NSMutableSet minusSet])是否有漏掉的笔记，然后去调用另一个API下载那些漏掉的笔记。这些完全不需要触及数据库。</p>

<p>但是，像这样的事情应该小心处理。app可以提供足够的内存吗？它真的简化编程并且提高性能了吗？</p>

<p>用SQLite和FMDB而不是Core Data，给你带来大量的灵活性和聪明解决办法的空间。记住有的时候聪明是好的，也有的时候聪明是一个大错误。</p>

<p>Web APIs
我的API调用在后台进程（经常用一个NSOperationQueue，所以我可以取消操作）。模型对象只在主线程，但是我还传递模型对象给我的API调用。</p>

<p>是这样的：一个数据库对象有一个detachedCopy方法，可以复制数据库对象。这个复制对象不是引用自我用来唯一化的对象缓存。唯一引用那个对象的地方是API调用，当API调用结束，那个复制的对象就消失了。</p>

<p>这是一个好的系统，因为它意味着我可以在API调用里使用模型对象。方法看起来像这样：</p>

<pre><code>- (void)uploadNote:(VSNote *)note { 
    VSNoteAPICall *apiCall = [[VSNoteAPICall alloc] initWithNote:[note detachedCopy]]; 
    [self enqueueAPICall:apiCall]; 
} 
</code></pre>

<p>VSNoteAPICall从复制的VSNote获取值，并且创建HTTP请求，而不是一个字典或其他笔记的表现形式。</p>

<p>处理Web API返回值
我对web返回值做了一些类似的事情。我会对返回的JSON或者XML创建一个模型对象，这个模型对象也是分离的。它不是存储在为了唯一性的模型缓存里。</p>

<p>这儿有些事情是不确定的。有时有必要用那个模型对象在两个地方做本地修改：在内存缓存和数据库。</p>

<p>数据库通常是容易的部分。比如：我的应用已经有一个方法来保存笔记对象。它用一个SQL insert或者replace字符串。我只需调用那个从web API返回值生成的笔记对象，数据库就会更新。</p>

<p>但是可能那个对象有一个在内存中的版本，幸运的是我们很容易找到：</p>

<pre><code>VSNote *cachedNote = [self.mapTable objectForKey:downloadedNote.uniqueID]; 
</code></pre>

<p>如果cachedNote存在，我会让它从downloadedNote中获取值，而不是替换它（这样可能违反唯一性）。这可以共享detachedCopy方法的代码。</p>

<p>一旦cachedNote更新了，观察者会通过KVO通知笔记，或者我会发送一个NSNotification，或者两者都做。</p>

<p>Web API调用也会返回一些其他值。我提到过RSS阅读器可能获得一个已读条目的大列表。这种情况下，我用那个列表创建了一个NSSet，在内存中更新每一个缓存文章的read属性，然后调用-[FMDatabase executeUpdate:]。</p>

<p>让它工作快速的关键是NSMapTable的查找是快速的。如果你找的对象在一个NSArray里，我们该重新考虑。</p>

<p>数据库迁移
Core Data的数据库迁移很酷，当它可行的时候。但是不可避免的，它是代码和数据库中的一层。如果你越直接使用SQLite，你更新数据库越直接。你可以安全容易的做到这点。</p>

<p>比如加一个表：</p>

<pre><code>[self.database executeUpdate:@"CREATE TABLE if not exists tags " 
    "(uniqueID TEXT UNIQUE, name TEXT, deleted INTEGER, deletedModificationDate DATE);"]; 
</code></pre>

<p>或者加一个索引：</p>

<pre><code>[self.database executeUpdate:@"CREATE INDEX if not exists " 
    "archivedSortDateIndex on notes (archived, sortDate);"]; 
</code></pre>

<p>或者加一列：</p>

<pre><code>[self.database executeUpdate:@"ALTER TABLE tags ADD deletedDate DATE"]; 
</code></pre>

<p>应用应该在代码的第一个地方用上面这些代码设置数据库。以后的改变只需加executeUpdate的调用 — 我让他们按顺序执行。因为我的数据库是我设计的，不会有什么问题（我从没碰到性能问题，它很快）。</p>

<p>当然大的改变需要更多代码。如果你的数据通过web获取，有时你可以从一个新数据库模型开始，重新下载你需要的数据。</p>

<p>性能技巧
SQLite可以非常非常快，它也可以非常慢。完全取决于你怎么使用它。</p>

<p>事务
把更新包装在事务里。在更新前调用 -[FMDatabase beginTransaction] ，更新后调用-[FMDatabase commit]。</p>

<p>如果你不得不反规范化（ Denormalize）
反规范化让人很不爽。这个方法是，为了加速检索而添加冗余数据，但是它意味着你需要维护冗余数据。</p>

<p>我总是疯狂避免它，直到这样能有严重的性能区别。然后我会尽可能少得这么做。</p>

<p>使用索引
我的应用中tags表的创建语句像这样：</p>

<pre><code>CREATE TABLE if not exists tags  
  (uniqueID TEXT UNIQUE, name TEXT, deleted INTEGER, deletedModificationDate DATE); 
</code></pre>

<p>uniqueID列是自动索引的，因为它定义为unique。但是如果我想用name来查询表，我可能会在name上创建一个索引，像这样：</p>

<pre><code>CREATE INDEX if not exists tagNameIndex on tags (name); 
</code></pre>

<p>你可以一次性在多列上创建索引，像这样：</p>

<pre><code>CREATE INDEX if not exists archivedSortDateIndex on notes (archived, sortDate); 
</code></pre>

<p>但是注意太多索引会降低你的插入速度。你只需要足够数量并且是对的那些。</p>

<p>使用命令行应用
当我的app在模拟器里运行时，我会打印数据库的路径。我可以通过sqlite3的命令行来打开数据库。（通过man sqlite3命令来了解这个应用的更多信息）。</p>

<p>打开数据库的命令：sqlite3 “数据库的路径”。</p>

<p>打开以后，你可以看schema: type .schema。</p>

<p>你可以更新和查询，这是在使用你的app之前检查SQL是否正确的很好的方式。</p>

<p>这里面最酷的一部分是，SQLite Explain Query Plan命令，你会希望确保你的语句执行的尽可能快。</p>

<p>真实的例子
我的应用显示所有没有归档笔记的标签列表。每当笔记或者标签有变化，这个查询就会重新执行一次，所以它需要很快。</p>

<p>我可以用SQL join来查询，但是很慢（joins都很慢）。</p>

<p>所以我放弃sqlite3并开始尝试别的方法。我又看了一次我的schema，意识到我可以反规范化。一个笔记的归档状态可以存储在notes表里，它也可以存储在tagsNotesLookup表。</p>

<p>然后我可以执行一个查询：</p>

<pre><code>select distinct tagUniqueID from tagsNotesLookup where archived=0; 
</code></pre>

<p>我已经有了一个在tagUniqueID上的索引。所以我用explain query plan来告诉我当我执行这个查询的时候会发生什么。</p>

<pre><code>sqlite&gt; explain query plan select distinct tagUniqueID from tagsNotesLookup where archived=0; 
0|0|0|SCAN TABLE tagsNotesLookup USING INDEX tagUniqueIDIndex (~100000 rows) 
</code></pre>

<p>它用了一个索引，但是SCAN TABLE听起来不太好，最好是一个SEARCH TABLE并且覆盖一个索引。
我在tagUniqueID和archive上建了索引：</p>

<pre><code>CREATE INDEX archivedTagUniqueID on tagsNotesLookup(archived, tagUniqueID); 
</code></pre>

<p>再次执行explain query plan:</p>

<pre><code>sqlite&gt; explain query plan select distinct tagUniqueID from tagsNotesLookup where archived=0; 
0|0|0|SEARCH TABLE tagsNotesLookup USING COVERING INDEX archivedTagUniqueID (archived=?) (~10 rows) 
</code></pre>

<p>好多了。</p>

<p>更多性能提示
FMDB的某处加了缓存statements的能力，所以当创建或打开一个数据库的时候，我总是调用[self.database setShouldCacheStatements:YES] 。这意味着对每个调用你不需要再次编译每个statement。</p>

<p>我从来没有找到使用vacuum的好的指引，如果数据库没有定期压缩，它会越来越慢。我的应用会跑一个vacuum，但只是每周一次（它在NSUserDefaults里存储上次vacuum的时间，然后在开始的时候检查是否过了一周）。</p>

<p>如果能auto_vacuum那更好，看pragma statements supported by SQLite列表。</p>

<p>其他酷的东西
Gus Mueller让我涉及自定义SQLite方法的内容。我并没有真的使用这些东西，既然他指出了，我可以放心的说我能找到它的用处。因为它很酷。</p>

<p>在Gus的帖子里，有一个查询是这样的：</p>

<pre><code>select displayName, key from items where UTTypeConformsTo(uti, ?) order by 2; 
</code></pre>

<p>SQLite完全不知道UITypes。但是你可以加核心方法，查看-[FMDatabase makeFunctionNamed:maximumArguments:withBlock:]。</p>

<p>你可以执行一个大的查询来替代，然后评估每个对象。但是那需要更多工作。最好在SQL级就过滤，而不是在将表格行转为对象以后。</p>

<p>最后
你真的应该使用Core Data，我不是在开玩笑。</p>

<p>我用SQLite和FMDB一段时间了，我对多得的好处感到很兴奋，也得到非同一般的性能。但是记住机器在变快，其他看你代码的人期望看到他已经知道的Core Data, 另一些不打算看你的数据库代码。所以请把这整篇文章看做一个疯子的叫喊，关于他为自己建立的细节的疯狂的世界，并把自己锁在里面。</p>

<p>请享受了不起的Core Data的文章（有点难过的摇头）。</p>

<p>接下来，在查完Gus指出的自定义SQLite方法特性后，我会研究SQLite的full-text search extension. 总有更多的内容需要去学习。</p>

<pre><code>Q Q：2211523682/790806573

微信：18370997821/13148454507

微博WB:http://weibo.com/u/3288975567?is_hot=1

git博文：http://al1020119.github.io/

github：https://github.com/al1020119
</code></pre>

<p><img src="http://al1020119.github.io/images/iCocosCoder.jpg" title="Caption" ></p>

<p><img src="http://al1020119.github.io/images/iCocosPublic.jpg" title="Caption" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Realm 爆菊 CoreData]]></title>
    <link href="http://al1020119.github.io/blog/2016/07/05/ycoredatayurealm/"/>
    <updated>2016-07-05T04:59:42+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/07/05/ycoredatayurealm</id>
    <content type="html"><![CDATA[<p>本文具有强烈的个人感情色彩,如有观看不适,请尽快关闭。本文仅作为个人学习记录使用，也欢迎在许可协议范围内转载或使用，请尊重版权并且保留原文链接，谢谢您的理解合作。如果您觉得本站对您能有帮助，您可以使用RSS方式订阅本站，这样您将能在第一时间获取本站信息。
碎碎念</p>

<p>OhMyStar 2 也进行了一段时日，我把持久化的方式从CoreData 换到了 Realm。有些感悟，顺手就记录一下吧。以下评论都是自己很主观的感受，无实际测试数据支持。
论 iOS 的持久化</p>

<!--more-->


<p>iOS 持久化其实也没多少选择， 高端一点CoreData、Realm、FMDB、KV类(LevelDB等)。低端一些直接一个 NSArray 就写成 Plist 也能持久化下来。</p>

<p>在网络环境越来越快的当下和大部分应用数据都可能是网络应用，如果业务逻辑并不复杂，其实极端一点就只用写到 JSON 转 Object 就好了。而且一堆这样好用的封装，远有Mantle 近有YYModel。</p>

<p>所以需要持久化的时候，我觉的可以慎重的评估一下需求。想明白了，后面可以节省很多事情。</p>

<p>本文章主要对比 Realm 和 CoreData，其他的就不涉及了。</p>

<p>Realm
优点
入门门槛低</p>

<p>Realm文档就算一个字一个字扣着读完，一个下午就足够了。而且还有中文版本，不要太友好哦，有点不习惯诶。</p>

<p>文档覆盖了80%的使用情况，甚至有些太简陋的嫌疑。但不管怎么样，这种入门条件比起 CoreData 写了三个月都没搞清楚 Context 要好的多。</p>

<p>在库的工具链上，安装一个 Realm Browser 以后就不需要其他辅助了。还是简单。</p>

<p>几乎做到了上手即用的程度。五星好评。</p>

<p>PS：我用了一个通宵把 OhMyStar 2 的持久化从 CoreData 换到了 Realm ，优化调整了大概5天左右达到勉强可以用的情况 。在这之前并没有任何 Realm 的经验。
据说性能好一些</p>

<p>Realm官方介绍Fast一段中</p>

<p>Counts</p>

<p><img src="http://al1020119.github.io/images/benchmarks.001b.png" title="Caption" ></p>

<p>Queries</p>

<p><img src="http://al1020119.github.io/images/benchmarks.002b.png" title="Caption" ></p>

<p>Inserts</p>

<p><img src="http://al1020119.github.io/images/benchmarks.003b.png" title="Caption" ></p>

<p>在写这里的时候我顺手Google了一下 发现一篇Core Data, FMDB, Realm 性能测试。我就多说几句</p>

<p>总觉得大家对 CoreData 误会蛮深，代码 Fork 看了一下， 总觉得不应该这样写来比性能的，但是一时半会也不知道怎么改。我只能说我在优化 CoreData 的时候根据 WWDC 上教的还是提升很高，另外一个事情是 CoreData 一般都用 Sqlite 做后端。所以如果你的查询是经过优化的，确认打出来的SQL语句科学以后，Sqlite(CoreData) 跟 Sqlite(FMDB)我觉得性能就算有差距，这差距没有能大到选择方案的决定性因素。如果使用 CoreData 遇到性能瓶颈，你应该仔细的研究 WWDC 和几篇很好的文章。确保你的 CoreData 使用方式是正确科学的。
没有需要架构Context那种烦人的东西</p>

<p>应该也算Realm简单的一个方面，Realm 只要保持自己线程里面，自己的 Realm Store 操作是正确的即可。如果是 CoreData，怎么架构一个科学的 Context Stack 就足够让我头疼一整，iOS 还好，界面是一个接着一个(VC跟VC之间的层级关系很清晰)。而 OhMyStar 2 这种 OS X 桌面应用场景VC之间很复杂，线程之间Context的关系让出现很多问题。
支持 NSPredicate</p>

<p>从 CoreData 转过来并没有太多的不适应
很简单的使用多个存储文件</p>

<p>举个例子，多用户登陆情况下。用户是单独的存储文件，和全部用户使用同一个存储文件。后者需要每条用户数据都要关联一次当前用户，所有查询用户数据的时候，你都必须加上当前用户的查询项。而使用每个用户单独一个数据文件的时候，整个存储结构会清爽很多。
技术支持</p>

<p>至少实在没法的时候还可以去微博上吐槽他们，他们其实也有极大的热情来解决你遇到的问题。CoreData 这种遇到问题就只能自己默默的吞下。
缺点
关联关系弱的一逼</p>

<p>简单说来就是对象跟对象之间的一对多关系和多对多关系。并不能映射，需要在双方里面都写上属性，此外还需要在设置的时候两边同时设置。查询时候也是 NSPredicate 也仅仅只支持一些一层的查询，没法做出带SUBQUERY的复杂查询出来。
强制内省容错机制导致存储文件不断变大</p>

<p>Realm本身感觉有一个数据容错机制。但是这个机制在数据库文件有错误的情况自己修复的时候，会无限增大。具体我这里表现为，打开看只有3000条数据，但是文件大小已经有3GB。重现Bug也很容易，只要你在写数据库的时候,用Realm Browser查看一下，crash之后在打开就很容易出现。</p>

<p>官方文档里面有说到会造成这种情形的原因，我在尽我所能的避免问题以后。存储文件还是会有可能不那么夸张的变大一些。但是用Realm Browser查看数据是正常的。所以我觉得官方应该提供一个函数，可以删除掉那些容易的东西。保持存储文件的干净。
没有细粒化通知</p>

<p>也就是说，当我在某个地方做出修改。 我其他地方只知道Realm有修改，但是没法知道我是增加、修改还是删除了数据。不知道我更新的是那一条数据。据文档说，将来会解决这个问题，就只有拭目以待。
增加包体积</p>

<p>据官方说会增加1MB左右的包大小，如果你是一个小体积应用，或者是一个几千万用户的主流应用。对包大小敏感的话慎用。
核心代码目前闭源</p>

<p>对于在我们这样一个作恶满天飞的天朝长大的孩子来说，有些孩子对闭源这个事情还是挺在意的。不过官方说将来会开源，我还是倾向于相信 Realm 他们的人品。
CoreData</p>

<p>CoreData 相关资料相对多一些我就简单说
优点
官方支持 &amp;&amp; 亲儿子</p>

<p>系统自带，Apple支持
带图形化的Model编辑</p>

<p>对于视觉化动物来说比较友好，也可以清楚的知道自己设计的 Model 之间的关系
强大的关联关系</p>

<p>以前不觉得，用了 Realm 才发现 CoreData 的关联关系如此好用，一对多，多对多。想怎么查询就怎么查询，可以写出很复杂的查询逻辑来。
强大的查询</p>

<p>虽然可能在设置NSFetchRequest的时候感觉很多东西要弄，但是复杂也带来了强大的功能，NSFetchRequest 可以设置很多，比如限制查询数量， 限制只返回某些属性值等等。就不展开说了。
精细化的通知</p>

<p>可以知道具体插入了什么、更新了什么、删除了什么。这样在刷UI，比如一个tableview的时候，你就可以控制的很准确。
缺点
入门门槛高</p>

<pre><code>CoreData 是一个博大精深的技术，不要妄想几天之内可以用的很溜。
CoreData 是一个博大精深的技术，不要妄想几天之内可以用的很溜。
CoreData 是一个博大精深的技术，不要妄想几天之内可以用的很溜。
</code></pre>

<p>如果没有足够的时间和精力去接入 CoreData。 那选型的时候应当慎重考虑。
需要一些工具才感觉好使</p>

<p>不管是老手还是新手，使用一些第三方的封装库和工具都会大大的提高使用 CoreData 的幸福指数。</p>

<p>mogenerator 是必须必须要的。</p>

<p>MagicalRecord 无愧 CoreData 第一库，据小道消息 主要贡献者 Saul Mora 可能去了微信了。
Context</p>

<p>其实还是 CoreData 门槛高的问题，对我来说。Context之间的关系和线程之间的处理让我感到很头痛，特别是 OS X  是一大堆VC铺到屏幕上，我水平又菜，出的问题很多。
多个持久化文件很麻烦</p>

<p>不是说不可以，但是真的好麻烦。</p>

<p>有个第三方库有解决CoreData这个问题 CoreStore 但是我用着不是很顺手最后弃用.
总结</p>

<p>其实吧用啥持久化都行，具体还是需要看你的需求和方案上来说哪一个方案更加适合。</p>

<p>如果简单说来，就是 Realm 更加适合一些业务逻辑不怎么复杂的场景，团队配置要求不高，有经验的人稍微看一下午就能上手。</p>

<p>CoreData 更加适合业务逻辑复杂的情况，团队配置要求比较高，有经验的老手也需要几周甚至更长的时间才能科学的使用CoreData。</p>

<pre><code>Q Q：2211523682/790806573

微信：18370997821/13148454507

微博WB:http://weibo.com/u/3288975567?is_hot=1

git博文：http://al1020119.github.io/

github：https://github.com/al1020119
</code></pre>

<p><img src="http://al1020119.github.io/images/iCocosCoder.jpg" title="Caption" ></p>

<p><img src="http://al1020119.github.io/images/iCocosPublic.jpg" title="Caption" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MagicalRecord魔法]]></title>
    <link href="http://al1020119.github.io/blog/2016/07/04/coredatedzhuangbimegic/"/>
    <updated>2016-07-04T20:59:42+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/07/04/coredatedzhuangbimegic</id>
    <content type="html"><![CDATA[<p>正文：</p>

<p>到目前为止，已经将CoreData相关的知识点都讲完了。</p>

<p>在这篇文章中，主要讲一个CoreData第三方库-MagicalRecord。目前为止这个第三方在Github上有9500+的Star，是所有CoreData第三方库中使用最多、功能最全的。在文章的后面还会对CoreData做一个总结，以及对本系列所有文章做一个总结。</p>

<p>文章中如有疏漏或错误，还请各位及时提出，谢谢！</p>

<!--more-->


<h4>MagicalRecord</h4>

<p>CoreData是苹果自家推出的一个持久化框架，使用起来更加面向对象。但是在使用过程中会出现大量代码，而且CoreData学习曲线比较陡峭，如果掌握不好，在使用过程中很容易造成其他问题。</p>

<p>国外开发者开源了一个基于CoreData封装的第三方——MagicalRecord，就像是FMDB封装SQLite一样，MagicalRecord封装的CoreData，使得原生的CoreData更加容易使用。并且MagicalRecord降低了CoreData的使用门槛，不用去手动管理之前的PSC、MOC等对象。</p>

<p>根据Github上MagicalRecord的官方文档，MagicalRecord的优点主要有三条：</p>

<ol>
<li><p>清理项目中CoreData代码</p></li>
<li><p>支持清晰、简单、一行式的查询操作</p></li>
<li><p>当需要优化请求时，可以获取NSFetchRequest进行修改</p></li>
</ol>


<p>添加MagicalRecord到项目中</p>

<p>将MagicalRecord添加到项目中，和使用其他第三方一样，可以通过下载源码和CocoaPods两种方式添加。</p>

<ol>
<li><p>从Github下载MagicalRecord源码，将源码直接拖到项目中，后续需要手动更新源码。</p></li>
<li><p>也可以通过CocoaPods安装MagicalRecord，需要在Podfile中加入下面命令，后续只需要通过命令来更新。</p></li>
</ol>


<h6>安装</h6>

<pre><code>pod "MagicalRecord"
</code></pre>

<p>在之前创建新项目时，通过勾选"Use Core Data"的方式添加CoreData到项目中，会在AppDelegate文件中生成大量CoreData相关代码。如果是大型项目，被占用的位置是很重要的。而对于MagicalRecord来说，只需要两行代码即可。</p>

<pre><code>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
// 初始化CoreData堆栈，也可以指定初始化某个CoreData堆栈
[MagicalRecord setupCoreDataStack];
return YES;
}
- (void)applicationWillTerminate:(UIApplication *)application {
// 在应用退出时，应该调用cleanUp方法
[MagicalRecord cleanUp];
}
</code></pre>

<p>MagicalRecord是支持CoreData的.xcdatamodeld文件的，使得CoreData这一优点可以继续使用。建立数据结构时还是像之前使用CoreData一样，通过.xcdatamodeld文件的方式建立。</p>

<p><img src="http://al1020119.github.io/images/coredateduoxianchenganquan004.png" title="Caption" ></p>

<h4>支持iCloud</h4>

<p>CoreData是支持iCloud的，MagicalRecord对iCloud相关的操作也做了封装，只需要使用MagicalRecord+iCloud.h类中提供的方法，就可以进行iCloud相关的操作。</p>

<p>例如下面是MagicalRecord+iCloud.h中的一个方法，需要将相关参数传入即可。</p>

<pre><code>+ (void)setupCoreDataStackWithiCloudContainer:(NSString *)containerID localStoreNamed:(NSString *)localStore;
</code></pre>

<h6>创建上下文</h6>

<p>MagicalRecord对上下文的管理和创建也比较全面，下面是MagicalRecord提供的部分创建和获取上下文的代码。因为是给NSManagedObjectContext添加的Category，可以直接用NSManagedObjectContext类调用，使用非常方便。</p>

<p>但是需要注意，虽然系统帮我们管理了上下文对象，对于耗时操作仍然要放在后台线程中处理，并且在主线程中进行UI操作。</p>

<pre><code>+ [NSManagedObjectContext MR_context]  设置默认的上下文为它的父级上下文，并发类型为NSPrivateQueueConcurrencyType

+ [NSManagedObjectContext MR_newMainQueueContext]  创建一个新的上下文，并发类型为NSMainQueueConcurrencyType

+ [NSManagedObjectContext MR_newPrivateQueueContext]  创建一个新的上下文，并发类型为NSPrivateQueueConcurrencyType

+ [NSManagedObjectContext MR_contextWithParent:]  创建一个新的上下文，允许自定义父级上下文，并发类型为NSPrivateQueueConcurrencyType

+ [NSManagedObjectContext MR_contextWithStoreCoordinator:]  创建一个新的上下文，并允许自定义持久化存储协调器，并发类型为NSPrivateQueueConcurrencyType

+ [NSManagedObjectContext MR_defaultContext]  获取默认上下文对象，项目中最基础的上下文对象，并发类型是NSMainQueueConcurrencyType
</code></pre>

<p>增删改查</p>

<p>MagicalRecord对NSManagedObject添加了一个Category，将增删改查等操作放在这个Category中，使得这些操作可以直接被NSManagedObject类及其子类调用。</p>

<ol>
<li>增</li>
</ol>


<p>对于托管模型的创建非常简单，不需要像之前还需要进行上下文的操作，现在这都是MagicalRecord帮我们完成的。</p>

<pre><code>// 创建并插入到上下文中
Employee *emp = [Employee MR_createEntity];
</code></pre>

<ol>
<li>删</li>
</ol>


<p>删除数据</p>

<pre><code>// 从上下文中删除当前对象
[emp MR_deleteEntity];
</code></pre>

<ol>
<li>改</li>
</ol>


<p>修改数据</p>

<pre><code>// 获取一个上下文对象
NSManagedObjectContext *defaultContext = [NSManagedObjectContext MR_defaultContext];
// 在当前上下文环境中创建一个新的Employee对象
Employee *emp = [Employee MR_createEntityInContext:defaultContext];
emp.name      = @"lxz";
emp.brithday  = [NSDate date];
emp.height    = @1.7;
// 保存修改到当前上下文中
[defaultContext MR_saveToPersistentStoreAndWait];
</code></pre>

<ol>
<li>查</li>
</ol>


<p> 查询数据</p>

<pre><code>// 执行查找操作，并设置排序条件
NSArray *empSorted = [Employee MR_findAllSortedBy:@"height" ascending:YES];
</code></pre>

<h4>自定义NSFetchRequest</h4>

<p>下面示例代码中，Employee根据已有的employeeFilter谓词对象，创建了employeeRequest请求对象，并将请求对象做修改后，从MOC中获取请求结果，实现自定义查找条件。</p>

<pre><code>NSPredicate *employeeFilter = [NSPredicate predicateWithFormat:@"name LIKE %@", @"*lxz*"];
NSFetchRequest *employeeRequest = [Employee MR_requestAllWithPredicate:employeeFilter];
employeeRequest.fetchOffset = 10;
employeeRequest.fetchLimit = 10;
NSArray *employees = [Employee MR_executeFetchRequest:employeeRequest];
</code></pre>

<h6>参数设置</h6>

<ol>
<li><p>可以通过修改MR_LOGGING_DISABLED预编译指令的值，控制log打印。</p>

<ul>
<li>&ldquo;#defne MR_LOGGING_DISABLED 1&rdquo;.</li>
</ul>
</li>
</ol>


<p>2.MagicalRecord在DEBUG模式下，对模型文件发生了更改，并且没有创建新的模型文件版本。MagicalRecord默认会将旧的持久化存储删除，创建新的持久化存储。</p>

<p>MagicalRecord的使用方法还有很多，这里只是将一些比较常用的拿出来讲讲，其他就不一一讲解了。在Github上有国人翻译的MagicalRecord官方文档，翻译的非常全面，而且是实时更新的。</p>

<p>这篇文章关于MagicalRecord的部分，也是参考文章来写的，我这里就犯了个懒……</p>

<h2>MagicalRecord中文文档</h2>

<h4>CoreData优缺点总结</h4>

<p>无论是什么东西，肯定不会是绝对完美的，CoreData也是如此。CoreData被设计出来后，对比其他本地持久化方案有自己独有的优势，也有比较严重的问题。</p>

<p>对于一个本地持久化方案的选取，还是要根据公司业务需求，来选择一个适合项目的方案，并没有哪个方案是万能的。</p>

<h6>优点</h6>

<pre><code>可以设置关联关系，也就是之前讲过的关联属性，关联属性可以和当前对象一起被MOC操作。

例如Company关联一个Person对象，对Company进行操作时，也可以通过点语法从Company中获取Person，Person的修改会随着Company一起被持久化。

如果用SQLite实现起来是很麻烦的，但CoreData可以很容易的完成，这也是CoreData更加面向对象的一种体现。

更加面向对象，将之前Model层的表示和持久化合二为一。把数据库的交互和对象的转换封装起来，使用时不需要接触到任何SQLite相关的代码，直接使用托管对象即可。

开发效率比较快，可以很快的封装一个基于CoreData实现的Model层，而不需要太多的代码就可以实现。

可以很好的防范SQL注入的问题。对于SQLite来说，如果是用FMDB并且用?占位符，也可以防范SQL注入的问题。

可视化化效果好且结构清晰。将模型文件内部的结构，以及实体之间的对应关系等，以可视化的结构展现出来。

对OC原生编程支持非常好，支持keyPath操作方式。例如设置NSPredicate查找条件时，可以使用keyPath的点语法设置属性。而其他持久化存储对于这点支持的不太好，需要编写很复杂的查找条件，看起来也不太好理解。

毕竟是Apple自家推出的，所以对OC融合度比较高，可以很好的配合和使用OC对象。

设置一对一或一对多的关系，设置关系后做存储和查询也非常方便，这是非常便于开发的。如果对于性能没有苛刻的要求，并且持久化对象之间关系比较复杂，比较推荐使用CoreData。
</code></pre>

<h6>缺点</h6>

<pre><code>灵活性不如SQLite，CoreData是对SQLite的一个封装，上层不能直接对数据库进行操作。处理任何数据都要按照CoreData内部的实现逻辑执行，而不能自定义执行逻辑，对执行逻辑没有可控性。

进行大量数据处理时比较吃力，性能明显低于直接操作SQLite数据库，而且内存占用非常大，需要手动做内存控制。

当执行一个操作时涉及的数据比较多，需要将所有相关的托管对象加载到内存中，而且中间还涉及到对象的转换等操作。这样对性能和内存的消耗都是非常大的，和涉及到的数据量成正比。
</code></pre>

<p>因为CoreData底层是用SQLite实现的，可以在CoreData的基础上，直接编写SQL语句对数据库进行操作。但是并不推荐这样做，在一个项目中应该只有一种持久化的主体方案。而且如果这两种方式混用的话，对于后期维护是非常困难的。</p>

<pre><code>如果出现这样的需求，最好直接去用SQLite。

CoreData入门门槛比较高，很难很好的掌握。
</code></pre>

<p>很多人都说CoreData不好用，这个原因很大一部分都是因为使用方式的问题。CoreData框架学习难度比较大，导致很多人都只是简单的使用CoreData，这些用法很多都是不合理的，很多的高级用法并没有用到。</p>

<h4>写在最后</h4>

<p>到目前为止CoreData系列的六篇文章就都写完了，文章中可能存在一些没有注意的问题，还请各位提出。博客中包括CoreData在内的所有文章永久更新维护，会不断将新知识添加到对应的文章中，也会对落后的文章进行重写。</p>

<p>在第一篇文章中也说到，我接触CoreData时间也不是很长，这系列文章更像是我学习的一个总结。但是我确实是很认真的在写，文章内容也是检查了很多遍，防止错字或者语法问题。知识点总结的还是比较全面的，在后续我还会更深入的学习CoreData，也可能会推出后续文章。</p>

<blockquote><p>许多人对于CoreData有很多意见，认为CoreData有各种各样的问题，这并不是空穴来风。在我学习CoreData的过程中，也发现CoreData确实存在诸多问题，例如查询性能略差、灵活性等。所以在使用CoreData的时候，还是根据公司业务需求来权衡是否使用CoreData。</p></blockquote>

<pre><code>Q Q：2211523682/790806573

微信：18370997821/13148454507

微博WB:http://weibo.com/u/3288975567?is_hot=1

git博文：http://al1020119.github.io/

github：https://github.com/al1020119
</code></pre>

<p><img src="http://al1020119.github.io/images/iCocosCoder.jpg" title="Caption" ></p>

<p><img src="http://al1020119.github.io/images/iCocosPublic.jpg" title="Caption" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CoreData安全问题！]]></title>
    <link href="http://al1020119.github.io/blog/2016/07/04/coredatedzhuangbianquang/"/>
    <updated>2016-07-04T18:59:42+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/07/04/coredatedzhuangbianquang</id>
    <content type="html"><![CDATA[<p>正文：</p>

<p>CoreData使用相关的技术点已经讲差不多了，我所掌握的也就这么多了&hellip;.</p>

<p>在本篇文章中主要讲CoreData的多线程，其中会包括并发队列类型、线程安全等技术点。我对多线程的理解可能不是太透彻，文章中出现的问题还请各位指出。在之后公司项目使用CoreData的过程中，我会将其中遇到的多线程相关的问题更新到文章中。</p>

<p>在文章的最后，会根据我对CoreData多线程的学习，以及在工作中的具体使用，给出一些关于多线程结构的设计建议，各位可以当做参考。</p>

<p>文章中如有疏漏或错误，还请各位及时提出，谢谢！</p>

<!--more-->


<h4>MOC并发队列类型</h4>

<p>在CoreData中MOC是支持多线程的，可以在创建MOC对象时，指定其并发队列的类型。当指定队列类型后，系统会将操作都放在指定的队列中执行，如果指定的是私有队列，系统会创建一个新的队列。但这都是系统内部的行为，我们并不能获取这个队列，队列由系统所拥有，并由系统将任务派发到这个队列中执行的。</p>

<p>NSManagedObjectContext并发队列类型:</p>

<pre><code>NSConfinementConcurrencyType : 如果使用init方法初始化上下文，默认就是这个并发类型。这个枚举值是不支持多线程的，从名字上也体现出来了。

NSPrivateQueueConcurrencyType : 私有并发队列类型，操作都是在子线程中完成的。

NSMainQueueConcurrencyType : 主并发队列类型，如果涉及到UI相关的操作，应该考虑使用这个枚举值初始化上下文。
</code></pre>

<p>其中NSConfinementConcurrencyType类型在iOS9之后已经被苹果废弃，不建议使用这个API。使用此类型创建的MOC，调用某些比较新的CoreData的API可能会导致崩溃。</p>

<h4>MOC多线程调用方式</h4>

<p>在CoreData中MOC不是线程安全的，在多线程情况下使用MOC时，不能简单的将MOC从一个线程中传递到另一个线程中使用，这并不是CoreData的多线程，而且会出问题。对于MOC多线程的使用，苹果给出了自己的解决方案。</p>

<p>在创建的MOC中使用多线程，无论是私有队列还是主队列，都应该采用下面两种多线程的使用方式，而不是自己手动创建线程。调用下面方法后，系统内部会将任务派发到不同的队列中执行。可以在不同的线程中调用MOC的这两个方法，这个是允许的。</p>

<pre><code>- (void)performBlock:(void (^)())block         //异步执行的block，调用之后会立刻返回
- (void)performBlockAndWait:(void (^)())block    //同步执行的block，调用之后会等待这个任务完成，才会继续向下执行
</code></pre>

<p>下面是多线程调用的示例代码，在多线程的环境下执行MOC的save方法，就是将save方法放在MOC的block体中异步执行，其他方法的调用也是一样的。</p>

<pre><code>[context performBlock:^{
    [context save:nil];
}];
</code></pre>

<p>但是需要注意的是，这两个block方法不能在NSConfinementConcurrencyType类型的MOC下调用，这个类型的MOC是不支持多线程的，只支持其他两种并发方式的MOC。</p>

<h4>多线程的使用</h4>

<p>在业务比较复杂的情况下，需要进行大量数据处理，并且还需要涉及到UI的操作。对于这种复杂需求，如果都放在主队列中，对性能和界面流畅度都会有很大的影响，导致用户体验非常差，降低屏幕FPS。对于这种情况，可以采取多个MOC配合的方式。</p>

<p>CoreData多线程的发展中，在iOS5经历了一次比较大的变化，之后可以更方便的使用多线程。从iOS5开始，支持设置MOC的parentContext属性，通过这个属性可以设置MOC的父MOC。下面会针对iOS5之前和之后，分别讲解CoreData的多线程使用。</p>

<p>尽管现在的开发中早就不兼容iOS5之前的系统了，但是作为了解这里还是要讲一下，而且这种同步方式在iOS5之后也是可以正常使用的，也有很多人还在使用这种同步方式，下面其他章节也是同理。</p>

<h4>iOS 5之前使用多个MOC</h4>

<p>在iOS 5之前实现MOC的多线程，可以创建多个MOC，多个MOC使用同一个PSC，并让多个MOC实现数据同步。通过这种方式不用担心PSC在调用过程中的线程问题，MOC在使用PSC进行save操作时，会对PSC进行加锁，等当前加锁的MOC执行完操作之后，其他MOC才能继续执行操作。</p>

<p>每一个PSC都对应着一个持久化存储区，PSC知道存储区中数据存储的数据结构，而MOC需要使用这个PSC进行save操作的实现。</p>

<p><img src="http://al1020119.github.io/images/coredateduoxianchenganquan001.png" title="Caption" ></p>

<h4>多线程结构</h4>

<p>这样做有一个问题，当一个MOC发生改变并持久化到本地时，系统并不会将其他MOC缓存在内存中的NSManagedObject对象改变。所以这就需要我们在MOC发生改变时，将其他MOC数据更新。</p>

<p>根据上面的解释，在下面例子中创建了一个主队列的mainMOC，主要用于UI操作。一个私有队列的backgroundMOC，用于除UI之外的耗时操作，两个MOC使用的同一个PSC。</p>

<pre><code>// 获取PSC实例对象
- (NSPersistentStoreCoordinator *)persistentStoreCoordinator {
    // 创建托管对象模型，并指明加载Company模型文件
    NSURL *modelPath = [[NSBundle mainBundle] URLForResource:@"Company" withExtension:@"momd"];
    NSManagedObjectModel *model = [[NSManagedObjectModel alloc] initWithContentsOfURL:modelPath];
       // 创建PSC对象，并将托管对象模型当做参数传入，其他MOC都是用这一个PSC。
    NSPersistentStoreCoordinator *PSC = [[NSPersistentStoreCoordinator alloc] initWithManagedObjectModel:model];
    // 根据指定的路径，创建并关联本地数据库
    NSString *dataPath = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).lastObject;
    dataPath = [dataPath stringByAppendingFormat:@"/%@.sqlite", @"Company"];
    [PSC addPersistentStoreWithType:NSSQLiteStoreType configuration:nil URL:[NSURL fileURLWithPath:dataPath] options:nil error:nil];
    return PSC;
}
// 初始化用于本地存储的所有MOC
- (void)createManagedObjectContext {
    // 创建PSC实例对象，其他MOC都用这一个PSC。
    NSPersistentStoreCoordinator *PSC = self.persistentStoreCoordinator;
    // 创建主队列MOC，用于执行UI操作
    NSManagedObjectContext *mainMOC = [[NSManagedObjectContext alloc] initWithConcurrencyType:NSMainQueueConcurrencyType];
    mainMOC.persistentStoreCoordinator = PSC;
    // 创建私有队列MOC，用于执行其他耗时操作
    NSManagedObjectContext *backgroundMOC = [[NSManagedObjectContext alloc] initWithConcurrencyType:NSPrivateQueueConcurrencyType];
    backgroundMOC.persistentStoreCoordinator = PSC;
    // 通过监听NSManagedObjectContextDidSaveNotification通知，来获取所有MOC的改变消息
    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(contextChanged:) name:NSManagedObjectContextDidSaveNotification object:nil];
}
// MOC改变后的通知回调
- (void)contextChanged:(NSNotification *)noti {
    NSManagedObjectContext *MOC = noti.object;
    // 这里需要做判断操作，判断当前改变的MOC是否我们将要做同步的MOC，如果就是当前MOC自己做的改变，那就不需要再同步自己了。
    // 由于项目中可能存在多个PSC，所以下面还需要判断PSC是否当前操作的PSC，如果不是当前PSC则不需要同步，不要去同步其他本地存储的数据。
    [MOC performBlock:^{
        // 直接调用系统提供的同步API，系统内部会完成同步的实现细节。
        [MOC mergeChangesFromContextDidSaveNotification:noti];
    }];
}
</code></pre>

<p>在上面的Demo中，创建了一个PSC，并将其他MOC都关联到这个PSC上，这样所有的MOC执行本地持久化相关的操作时，都是通过同一个PSC进行操作的。并在下面添加了一个通知，这个通知是监听所有MOC执行save操作后的通知，并在通知的回调方法中进行数据的合并。</p>

<h4>iOS5之后使用多个MOC</h4>

<blockquote><p>在iOS5之后，MOC可以设置parentContext，一个parentContext可以拥有多个ChildContext。在ChildContext执行save操作后，会将操作push到parentContext，由parentContext去完成真正的save操作，而ChildContext所有的改变都会被parentContext所知晓，这解决了之前MOC手动同步数据的问题。</p></blockquote>

<p>需要注意的是，在ChildContext调用save方法之后，此时并没有将数据写入存储区，还需要调用parentContext的save方法。因为ChildContext并不拥有PSC，ChildContext也不需要设置PSC，所以需要parentContext调用PSC来执行真正的save操作。也就是只有拥有PSC的MOC执行save操作后，才是真正的执行了写入存储区的操作。</p>

<pre><code>- (void)createManagedObjectContext {
    // 创建PSC实例对象，还是用上面Demo的实例化代码
    NSPersistentStoreCoordinator *PSC = self.persistentStoreCoordinator;
    // 创建主队列MOC，用于执行UI操作
    NSManagedObjectContext *mainMOC = [[NSManagedObjectContext alloc] initWithConcurrencyType:NSMainQueueConcurrencyType];
    mainMOC.persistentStoreCoordinator = PSC;
    // 创建私有队列MOC，用于执行其他耗时操作，backgroundMOC并不需要设置PSC
    NSManagedObjectContext *backgroundMOC = [[NSManagedObjectContext alloc] initWithConcurrencyType:NSPrivateQueueConcurrencyType];
    backgroundMOC.parentContext = mainMOC;
    // 私有队列的MOC和主队列的MOC，在执行save操作时，都应该调用performBlock:方法，在自己的队列中执行save操作。
    // 私有队列的MOC执行完自己的save操作后，还调用了主队列MOC的save方法，来完成真正的持久化操作，否则不能持久化到本地
    [backgroundMOC performBlock:^{
        [backgroundMOC save:nil];
        [mainMOC performBlock:^{
            [mainMOC save:nil];
        }];
    }];
}
</code></pre>

<p>上面例子中创建一个主队列的mainMOC，来完成UI相关的操作。创建私有队列的backgroundMOC，处理复杂逻辑以及数据处理操作，在实际开发中可以根据需求创建多个backgroundMOC。需要注意的是，在backgroundMOC执行完save方法后，又在mainMOC中执行了一次save方法，这步是很重要的。</p>

<h4>iOS5之前进行数据同步</h4>

<p>就像上面章节中讲到的，在iOS5之前存在多个MOC的情况下，一个MOC发生更改并提交存储区后，其他MOC并不知道这个改变，其他MOC和本地存储的数据是不同步的，所以就涉及到数据同步的问题。</p>

<p>进行数据同步时，会遇到多种复杂情况。例如只有一个MOC数据发生了改变，其他MOC更新时并没有对相同的数据做改变，这样不会造成冲突，可以直接将其他MOC更新。</p>

<p>如果在一个MOC数据发生改变后，其他MOC对相同的数据做了改变，而且改变的结果不同，这样在同步时就会造成冲突。下面将会按照这两种情况，分别讲一下不同情况下的冲突处理方式。</p>

<h4>简单情况下的数据同步</h4>

<p>简单情况下的数据同步，是针对于只有一个MOC的数据发生改变，并提交存储区后，其他MOC更新时并没有对相同的数据做改变，只是单纯的同步数据的情况。</p>

<p>在NSManagedObjectContext类中，根据不同操作定义了一些通知。在一个MOC发生改变时，其他地方可以通过MOC中定义的通知名，来获取MOC发生的改变。在NSManagedObjectContext中定义了下面三个通知：</p>

<pre><code>NSManagedObjectContextWillSaveNotification：MOC将要向存储区存储数据时，调用这个通知。在这个通知中不能获取发生改变相关的NSManagedObject对象。

NSManagedObjectContextDidSaveNotification：MOC向存储区存储数据后，调用这个通知。在这个通知中可以获取改变、添加、删除等信息，以及相关联的NSManagedObject对象。

NSManagedObjectContextObjectsDidChangeNotification：在MOC中任何一个托管对象发生改变时，调用这个通知。例如修改托管对象的属性。
</code></pre>

<p>通过监听NSManagedObjectContextDidSaveNotification通知，获取所有MOC的save操作。</p>

<pre><code>[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(settingsContext:) name:NSManagedObjectContextDidSaveNotification object:nil];
</code></pre>

<p>不需要在通知的回调方法中，编写代码对比被修改的托管对象。MOC为我们提供了下面的方法，只需要将通知对象传入，系统会自动同步数据。</p>

<pre><code>- (void)mergeChangesFromContextDidSaveNotification:(NSNotification *)notification;
</code></pre>

<p>下面是通知中的实现代码，但是需要注意的是，由于通知是同步执行的，在通知对应的回调方法中所处的线程，和发出通知的MOC执行操作时所处的线程是同一个线程，也就是系统performBlock:回调方法分配的线程。</p>

<p>所以其他MOC在通知回调方法中，需要注意使用performBlock:方法，并在block体中执行操作。</p>

<pre><code>- (void)settingsContext:(NSNotification *)noti {
    [context performBlock:^{
        // 调用需要同步的MOC对象的merge方法，直接将通知对象当做参数传进去即可，系统会完成同步操作。
        [context mergeChangesFromContextDidSaveNotification:noti];
    }];
}
</code></pre>

<h4>复杂情况下的数据同步</h4>

<p>在一个MOC对本地存储区的数据发生改变，而其他MOC也对同样的数据做了改变，这样后面执行save操作的MOC就会冲突，并导致后面的save操作失败，这就是复杂情况下的数据合并。</p>

<p>这是因为每次一个MOC执行一次fetch操作后，会保存一个本地持久化存储的状态，当下次执行save操作时会对比这个状态和本地持久化状态是否一样。如果一样，则代表本地没有其他MOC对存储发生过改变；如果不一样，则代表本地持久化存储被其他MOC改变过，这就是造成冲突的根本原因。</p>

<p>对于这种冲突的情况，可以通过MOC对象指定解决冲突的方案，通过mergePolicy属性来设置方案。mergePolicy属性有下面几种可选的策略，默认是NSErrorMergePolicy方式，这也是唯一一个有NSError返回值的选项。</p>

<pre><code>NSErrorMergePolicy : 默认值，当出现合并冲突时，返回一个NSError对象来描述错误，而MOC和持久化存储区不发生改变。

NSMergeByPropertyStoreTrumpMergePolicy : 以本地存储为准，使用本地存储来覆盖冲突部分。

NSMergeByPropertyObjectTrumpMergePolicy : 以MOC的为准，使用MOC来覆盖本地存储的冲突部分。

NSOverwriteMergePolicy : 以MOC为准，用MOC的所有NSManagedObject对象覆盖本地存储的对应对象。

NSRollbackMergePolicy : 以本地存储为准，MOC所有的NSManagedObject对象被本地存储的对应对象所覆盖。
</code></pre>

<p>上面五种策略中，除了第一个NSErrorMergePolicy的策略，其他四种中NSMergeByPropertyStoreTrumpMergePolicy和NSRollbackMergePolicy，以及NSMergeByPropertyObjectTrumpMergePolicy和NSOverwriteMergePolicy看起来是重复的。</p>

<p>其实它们并不是冲突的，这四种策略的不同体现在，对没有发生冲突的部分应该怎么处理。NSMergeByPropertyStoreTrumpMergePolicy和NSMergeByPropertyObjectTrumpMergePolicy对没有冲突的部分，未冲突部分数据并不会受到影响。而NSRollbackMergePolicy和NSOverwriteMergePolicy则是无论是否冲突，直接全部替换。</p>

<blockquote><p>题外话：对于MOC的这种合并策略来看，有木有感觉到CoreData解决冲突的方式，和SVN解决冲突的方式特别像。。。</p></blockquote>

<h4>线程安全</h4>

<p>无论是MOC还是托管对象，都不应该在其他MOC的线程中执行操作，这两个API都不是线程安全的。但MOC可以在其他MOC线程中调用performBlock:方法，切换到自己的线程执行操作。</p>

<p>如果其他MOC想要拿到托管对象，并在自己的队列中使用托管对象，这是不允许的，托管对象是不能直接传递到其他MOC的线程的。但是可以通过获取NSManagedObject的NSManagedObjectID对象，在其他MOC中通过NSManagedObjectID对象，从持久化存储区中获取NSManagedObject对象，这样就是允许的。NSManagedObjectID是线程安全，并且可以跨线程使用的。</p>

<p>可以通过MOC获取NSManagedObjectID对应的NSManagedObject对象，例如下面几个MOC的API。</p>

<pre><code>NSManagedObject *object = [context objectRegisteredForID:objectID];
NSManagedObject *object = [context objectWithID:objectID];
</code></pre>

<p>通过NSManagedObject对象的objectID属性，获取NSManagedObjectID类型的objectID对象。</p>

<p>NSManagedObjectID *objectID = object.objectID;</p>

<h4>CoreData多线程结构设计</h4>

<p>上面章节中写的大多都是怎么用CoreData多线程，在掌握多线程的使用后，就可以根据公司业务需求，设计一套CoreData多线程结构了。对于多线程结构的设计，应该本着尽量减少主线程压力的角度去设计，将所有耗时操作都放在子线程中执行。</p>

<p>对于具体的设计我根据不同的业务需求，给出两种设计方案的建议。</p>

<h4>两层设计方案</h4>

<ol>
<li>在项目中多线程操作比较简单时，可以创建一个主队列mainMOC，和一个或多个私有队列的backgroundMOC。将所有backgroundMOC的parentContext设置为mainMOC，采取这样的两层设计一般就能够满足大多数需求了。</li>
</ol>


<p><img src="http://al1020119.github.io/images/coredateduoxianchenganquan002.png" title="Caption" ></p>

<ol>
<li>将耗时操作都放在backgroundMOC中执行，mainMOC负责所有和UI相关的操作。所有和UI无关的工作都交给backgroundMOC，在backgroundMOC对数据发生改变后，调用save方法会将改变push到mainMOC中，再由mainMOC执行save方法将改变保存到存储区。</li>
</ol>


<p>代码这里就不写了，和上面例子中设置parentContext代码一样，主要讲一下设计思路。</p>

<h4>三层设计方案</h4>

<ul>
<li>但是我们发现，上面的save操作最后还是由mainMOC去执行的，backgroundMOC只是负责处理数据。虽然mainMOC只执行save操作并不会很耗时，但是如果save涉及的数据比较多，这样还是会对性能造成影响的。</li>
</ul>


<p>虽然客户端很少涉及到大量数据处理的需求，但是假设有这样的需求。可以考虑在两层结构之上，给mainMOC之上再添加一个parentMOC，这个parentMOC也是私有队列的MOC，用于处理save操作。</p>

<p><img src="http://al1020119.github.io/images/coredateduoxianchenganquan003.png" title="Caption" ></p>

<ul>
<li>这样CoreData存储的结构就是三层了，最底层是backgroundMOC负责处理数据，中间层是mainMOC负责UI相关操作，最上层也是一个backgroundMOC负责执行save操作。这样就将影响UI的所有耗时操作全都剥离到私有队列中执行，使性能达到了很好的优化。</li>
</ul>


<p>需要注意的是，执行MOC相关操作时，不要阻塞当前主线程。所有MOC的操作应该是异步的，无论是子线程还是主线程，尽量少的使用同步block方法。</p>

<h4>MOC同步时机</h4>

<p>设置MOC的parentContext属性之后，parent对于child的改变是知道的，但是child对于parent的改变是不知道的。苹果这样设计，应该是为了更好的数据同步。</p>

<pre><code>Employee *emp = [NSEntityDescription insertNewObjectForEntityForName:@"Employee" inManagedObjectContext:backgroundMOC];
emp.name = @"lxz";
emp.brithday = [NSDate date];
emp.height = @1.7f;
[backgroundMOC performBlock:^{
    [backgroundMOC save:nil];
    [mainMOC performBlock:^{
        [mainMOC save:nil];
    }];
}];
</code></pre>

<p>在上面这段代码中，mainMOC是backgroundMOC的parentContext。在backgroundMOC执行save方法前，backgroundMOC和mainMOC都不能获取到Employee的数据，在backgroundMOC执行完save方法后，自身上下文发生改变的同时，也将改变push到mainMOC中，mainMOC也具有了Employee对象。</p>

<p>所以在backgroundMOC的save方法执行时，是对内存中的上下文做了改变，当拥有PSC的mainMOC执行save方法后，是对本地存储区做了改变。</p>

<pre><code>Q Q：2211523682/790806573

微信：18370997821/13148454507

微博WB:http://weibo.com/u/3288975567?is_hot=1

git博文：http://al1020119.github.io/

github：https://github.com/al1020119
</code></pre>

<p><img src="http://al1020119.github.io/images/iCocosCoder.jpg" title="Caption" ></p>

<p><img src="http://al1020119.github.io/images/iCocosPublic.jpg" title="Caption" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CoreData装逼技能？]]></title>
    <link href="http://al1020119.github.io/blog/2016/07/04/coredatedzhuangbi/"/>
    <updated>2016-07-04T14:59:42+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/07/04/coredatedzhuangbi</id>
    <content type="html"><![CDATA[<p>正文：</p>

<p>在之前的文章中，已经讲了很多关于CoreData使用相关的知识点。这篇文章中主要讲两个方面，NSFetchedResultsController和版本迁移。</p>

<p>文章题目中虽然有“高级”两个字，其实讲的东西并不高级，只是因为上一篇文章中东西太多了，把两个较复杂的知识点挪到这篇文章中。</p>

<!--more-->


<p>文章中如有疏漏或错误，还请各位及时提出，谢谢！</p>

<p>NSFetchedResultsController</p>

<p>在开发过程中会经常用到UITableView这样的视图类，这些视图类需要自己管理其数据源，包括网络获取、本地存储都需要写代码进行管理。</p>

<p>而在CoreData中提供了NSFetchedResultsController类(fetched results controller，也叫FRC)，FRC可以管理UITableView或UICollectionView的数据源。这个数据源主要指本地持久化的数据，也可以用这个数据源配合着网络请求数据一起使用，主要看业务需求了。</p>

<p>本篇文章会使用UITableView作为视图类，配合NSFetchedResultsController进行后面的演示，UICollectionView配合NSFetchedResultsController的使用也是类似，这里就不都讲了。</p>

<p>简单介绍</p>

<p>就像上面说到的，NSFetchedResultsController就像是上面两种视图的数据管理者一样。FRC可以监听一个MOC的改变，如果MOC执行了托管对象的增删改操作，就会对本地持久化数据发生改变，FRC就会回调对应的代理方法，回调方法的参数会包括执行操作的类型、操作的值、indexPath等参数。</p>

<p>实际使用时，通过FRC“绑定”一个MOC，将UITableView嵌入在FRC的执行流程中。在任何地方对这个“绑定”的MOC存储区做修改，都会触发FRC的回调方法，在FRC的回调方法中嵌入UITableView代码并做对应修改即可。</p>

<p>由此可以看出FRC最大优势就是，始终和本地持久化的数据保持统一。只要本地持久化的数据发生改变，就会触发FRC的回调方法，从而在回调方法中更新上层数据源和UI。这种方式讲的简单一点，就可以叫做数据带动UI。</p>

<p><img src="http://al1020119.github.io/images/4001.png" title="Caption" ></p>

<p>FRC</p>

<p>但是需要注意一点，在FRC的初始化中传入了一个MOC参数，FRC只能监测传入的MOC发生的改变。假设其他MOC对同一个存储区发生了改变，FRC则不能监测到这个变化，不会做出任何反应。</p>

<p>所以使用FRC时，需要注意FRC只能对一个MOC的变化做出反应，所以在CoreData持久化层设计时，尽量一个存储区只对应一个MOC，或设置一个负责UI的MOC，这在后面多线程部分会详细讲解。</p>

<p>修改模型文件结构</p>

<p>在写代码之前，先对之前的模型文件结构做一些修改。</p>

<p><img src="http://al1020119.github.io/images/4002.png" title="Caption" ></p>

<p>Employee结构</p>

<p>讲FRC的时候，只需要用到Employee这一张表，其他表和设置直接忽略。需要在Employee原有字段的基础上，增加一个String类型的sectionName字段，这个字段就是用来存储section title的，在下面的文章中将会详细讲到。</p>

<p>初始化FRC</p>

<p>下面例子是比较常用的FRC初始化方式，初始化时指定的MOC，还用之前讲过的MOC初始化代码，UITableView初始化代码这里也省略了，主要突出FRC的初始化。</p>

<pre><code>// 创建请求对象，并指明操作Employee表
NSFetchRequest *request = [NSFetchRequest fetchRequestWithEntityName:@"Employee"];
// 设置排序规则，指明根据height字段升序排序
NSSortDescriptor *heightSort = [NSSortDescriptor sortDescriptorWithKey:@"height" ascending:YES];
request.sortDescriptors = @[heightSort];
// 创建NSFetchedResultsController控制器实例，并绑定MOC
NSError *error = nil;
fetchedResultController = [[NSFetchedResultsController alloc] initWithFetchRequest:request
                                                 managedObjectContext:context
                                        sectionNameKeyPath:@"sectionName"
                                               cacheName:nil];
// 设置代理，并遵守协议
fetchedResultController.delegate = self;
// 执行获取请求，执行后FRC会从持久化存储区加载数据，其他地方可以通过FRC获取数据
[fetchedResultController performFetch:&amp;error];
// 错误处理
if (error) {
    NSLog(@"NSFetchedResultsController init error : %@", error);
}
// 刷新UI
[tableView reloadData];
</code></pre>

<p>在上面初始化FRC时，传入的sectionNameKeyPath:参数，是指明当前托管对象的哪个属性当做section的title，在本文中就是Employee表的sectionName字段为section的title。从NSFetchedResultsSectionInfo协议的indexTitle属性获取这个值。</p>

<p>在sectionNameKeyPath:设置属性名后，就以这个属性名作为分组title，相同的title会被分到一个section中。</p>

<p>初始化FRC时参数managedObjectContext:传入了一个MOC参数，FRC只能监测这个传入的MOC发生的本地持久化改变。就像上面介绍时说的，其他MOC对同一个持久化存储区发生的改变，FRC则不能监测到这个变化。</p>

<p>再往后面看到cacheName:参数，这个参数我设置的是nil。参数的作用是开启FRC的缓存，对获取的数据进行缓存并指定一个名字。可以通过调用deleteCacheWithName:方法手动删除缓存。</p>

<p>但是这个缓存并没有必要，缓存是根据NSFetchRequest对象来匹配的，如果当前获取的数据和之前缓存的相匹配则直接拿来用，但是在获取数据时每次获取的数据都可能不同，缓存不能被命中则很难派上用场，而且缓存还占用着内存资源。</p>

<p>在FRC初始化完成后，调用performFetch:方法来同步获取持久化存储区数据，调用此方法后FRC保存数据的属性才会有值。获取到数据后，调用tableView的reloadData方法，会回调tableView的代理方法，可以在tableView的代理方法中获取到FRC的数据。调用performFetch:方法第一次获取到数据并不会回调FRC代理方法。</p>

<p>代理方法</p>

<p>FRC中包含UITableView执行过程中需要的相关数据，可以通过FRC的sections属性，获取一个遵守协议的对象数组，数组中的对象就代表一个section。</p>

<p>在这个协议中有如下定义，可以看出这些属性和UITableView的执行流程是紧密相关的。</p>

<pre><code>@protocol NSFetchedResultsSectionInfo
/* Name of the section */
@property (nonatomic, readonly) NSString *name;
/* Title of the section (used when displaying the index) */
@property (nullable, nonatomic, readonly) NSString *indexTitle;
/* Number of objects in section */
@property (nonatomic, readonly) NSUInteger numberOfObjects;
/* Returns the array of objects in the section. */
@property (nullable, nonatomic, readonly) NSArray *objects;
@end // NSFetchedResultsSectionInfo
</code></pre>

<p>在使用过程中应该将FRC和UITableView相互嵌套，在FRC的回调方法中嵌套UITableView的视图改变逻辑，在UITableView的回调中嵌套数据更新的逻辑。这样可以始终保证数据和UI的同步，在下面的示例代码中将会演示FRC和UITableView的相互嵌套。</p>

<pre><code>Table View Delegate

// 通过FRC的sections数组属性，获取所有section的count值
- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView {
    return fetchedResultController.sections.count;
}
// 通过当前section的下标从sections数组中取出对应的section对象，并从section对象中获取所有对象count
- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section {
    return fetchedResultController.sections[section].numberOfObjects;
}
// FRC根据indexPath获取托管对象，并给cell赋值
- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {
    Employee *emp = [fetchedResultController objectAtIndexPath:indexPath];
    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@"identifier" forIndexPath:indexPath];
    cell.textLabel.text = emp.name;
    return cell;
}
// 创建FRC对象时，通过sectionNameKeyPath:传递进去的section title的属性名，在这里获取对应的属性值
- (NSString *)tableView:(UITableView *)tableView titleForHeaderInSection:(NSInteger)section {
    return fetchedResultController.sections[section].indexTitle;
}
// 是否可以编辑
- (BOOL)tableView:(UITableView *)tableView canEditRowAtIndexPath:(NSIndexPath *)indexPath {
    return YES;
}
// 这里是简单模拟UI删除cell后，本地持久化区数据和UI同步的操作。在调用下面MOC保存上下文方法后，FRC会回调代理方法并更新UI
- (void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath {
     if (editingStyle == UITableViewCellEditingStyleDelete) {
        // 删除托管对象
        Employee *emp = [fetchedResultController objectAtIndexPath:indexPath];
        [context deleteObject:emp];
        // 保存上下文环境，并做错误处理
        NSError *error = nil;
        if (![context save:&amp;error]) {
            NSLog(@"tableView delete cell error : %@", error);
        }
    }
}
</code></pre>

<p>上面是UITableView的代理方法，代理方法中嵌套了FRC的数据获取代码，这样在刷新视图时就可以保证使用最新的数据。并且在代码中简单实现了删除cell后，通过MOC调用删除操作，使本地持久化数据和UI保持一致。</p>

<p>就像上面cellForRowAtIndexPath:方法中使用的一样，FRC提供了两个方法轻松转换indexPath和NSManagedObject的对象，在实际开发中这两个方法非常实用，这也是FRC和UITableView、UICollectionView深度融合的表现。</p>

<pre><code>- (id)objectAtIndexPath:(NSIndexPath *)indexPath;
- (nullable NSIndexPath *)indexPathForObject:(id)object;
</code></pre>

<p>Fetched Results Controller Delegate</p>

<pre><code>// Cell数据源发生改变会回调此方法，例如添加新的托管对象等
- (void)controller:(NSFetchedResultsController *)controller didChangeObject:(id)anObject atIndexPath:(nullable NSIndexPath *)indexPath forChangeType:(NSFetchedResultsChangeType)type newIndexPath:(nullable NSIndexPath *)newIndexPath {
    switch (type) {
        case NSFetchedResultsChangeInsert:
            [tableView insertRowsAtIndexPaths:@[newIndexPath] withRowAnimation:UITableViewRowAnimationAutomatic];
            break;
        case NSFetchedResultsChangeDelete:
            [tableView deleteRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationAutomatic];
            break;
        case NSFetchedResultsChangeMove:
            [tableView deleteRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationAutomatic];
            [tableView insertRowsAtIndexPaths:@[newIndexPath] withRowAnimation:UITableViewRowAnimationAutomatic];
            break;
        case NSFetchedResultsChangeUpdate: {
            UITableViewCell *cell = [tableView cellForRowAtIndexPath:indexPath];
            Employee *emp = [fetchedResultController objectAtIndexPath:indexPath];
            cell.textLabel.text = emp.name;
        }
            break;
    }
}
// Section数据源发生改变回调此方法，例如修改section title等。
- (void)controller:(NSFetchedResultsController *)controller didChangeSection:(id &lt;nsfetchedresultssectioninfo&gt;)sectionInfo atIndex:(NSUInteger)sectionIndex forChangeType:(NSFetchedResultsChangeType)type {
    switch (type) {
        case NSFetchedResultsChangeInsert:
            [tableView insertSections:[NSIndexSet indexSetWithIndex:sectionIndex] withRowAnimation:UITableViewRowAnimationAutomatic];
            break;
        case NSFetchedResultsChangeDelete:
            [tableView deleteSections:[NSIndexSet indexSetWithIndex:sectionIndex] withRowAnimation:UITableViewRowAnimationAutomatic];
            break;
        default:
            break;
    }
}
// 本地数据源发生改变，将要开始回调FRC代理方法。
- (void)controllerWillChangeContent:(NSFetchedResultsController *)controller {
    [tableView beginUpdates];
}
// 本地数据源发生改变，FRC代理方法回调完成。
- (void)controllerDidChangeContent:(NSFetchedResultsController *)controller {
    [tableView endUpdates];
}
// 返回section的title，可以在这里对title做进一步处理。这里修改title后，对应section的indexTitle属性会被更新。
- (nullable NSString *)controller:(NSFetchedResultsController *)controller sectionIndexTitleForSectionName:(NSString *)sectionName {
    return [NSString stringWithFormat:@"sectionName %@", sectionName];
}&lt;/nsfetchedresultssectioninfo&gt;
</code></pre>

<p>上面就是当本地持久化数据发生改变后，被回调的FRC代理方法的实现，可以在对应的实现中完成自己的代码逻辑。</p>

<p>在上面的章节中讲到删除cell后，本地持久化数据同步的问题。在删除cell后在tableView代理方法的回调中，调用了MOC的删除方法，使本地持久化存储和UI保持同步，并回调到下面的FRC代理方法中，在代理方法中对UI做删除操作，这样一套由UI的改变引发的删除流程就完成了。</p>

<p>目前为止已经实现了数据和UI的双向同步，即UI发生改变后本地存储发生改变，本地存储发生改变后UI也随之改变。可以通过下面添加数据的代码来测试一下，NSFetchedResultsController就讲到这里了。</p>

<pre><code>- (void)addMoreData {
    Employee *employee = [NSEntityDescription insertNewObjectForEntityForName:@"Employee" inManagedObjectContext:context];
    employee.name = [NSString stringWithFormat:@"lxz 15"];
    employee.height = @(15);
    employee.brithday = [NSDate date];
    employee.sectionName = [NSString stringWithFormat:@"3"];
    NSError *error = nil;
    if (![context save:&amp;error]) {
        NSLog(@"MOC save error : %@", error);
    }
}
</code></pre>

<p>版本迁移</p>

<p>CoreData版本迁移的方式有很多，一般都是先在Xcode中，原有模型文件的基础上，创建一个新版本的模型文件，然后在此基础上做不同方式的版本迁移。</p>

<p>本章节将会讲三种不同的版本迁移方案，但都不会讲太深，都是从使用的角度讲起，可以满足大多数版本迁移的需求。</p>

<p>为什么要版本迁移？</p>

<p>在已经运行程序并通过模型文件生成数据库后，再对模型文件进行的修改，如果只是修改已有实体属性的默认值、最大最小值、Fetch Request等属性自身包含的参数时，并不会发生错误。如果修改模型文件的结构，或修改属性名、实体名等，造成模型文件的结构发生改变，这样再次运行程序就会导致崩溃。</p>

<p>在开发测试过程中，可以直接将原有程序卸载就可以解决这个问题，但是本地之前存储的数据也会消失。如果是线上程序，就涉及到版本迁移的问题，否则会导致崩溃，并提示如下错误：</p>

<pre><code>CoreData: error: Illegal attempt to save to a file that was never opened. "This NSPersistentStoreCoordinator has no persistent stores (unknown).  It cannot perform a save operation.". No last error recorded.
</code></pre>

<p>然而在需求不断变化的过程中，后续版本肯定会对原有的模型文件进行修改，这时就需要用到版本迁移的技术，下面开始讲版本迁移的方案。</p>

<p>创建新版本模型文件</p>

<p>本文中讲的几种版本迁移方案，在迁移之前都需要对原有的模型文件创建新版本。</p>

<p>选中需要做迁移的模型文件 -> 点击菜单栏Editor -> Add Model Version -> 选择基于哪个版本的模型文件(一般都是选择目前最新的版本)，新建模型文件完成。</p>

<p>对于新版本模型文件的命名，我在创建新版本模型文件时，一般会拿当前工程版本号当做后缀，这样在模型文件版本比较多的时候，就可以很容易将模型文件版本和工程版本对应起来。</p>

<p><img src="http://al1020119.github.io/images/4003.png" title="Caption" ></p>

<p>创建新版本模型文件</p>

<p>添加完成后，会发现之前的模型文件会变成一个文件夹，里面包含着多个模型文件。</p>

<p><img src="http://al1020119.github.io/images/4004.png" title="Caption" >
模型文件夹</p>

<p>在新建的模型文件中，里面的文件结构和之前的文件结构相同。后续的修改都应该在新的模型文件上，之前的模型文件不要再动了，在修改完模型文件后，记得更新对应的模型类文件。</p>

<p>基于新的模型文件，对Employee实体做如下修改，下面的版本迁移也以此为例。</p>

<p><img src="http://al1020119.github.io/images/4005.png" title="Caption" ></p>

<p>修改之前</p>

<p>添加一个String类型的属性，设置属性名为sectionName。</p>

<p><img src="http://al1020119.github.io/images/4006.png" title="Caption" ></p>

<p>修改之后</p>

<p>此时还应该选中模型文件，设置当前模型文件的版本。这里选择将最新版本设置为刚才新建的1.1.0版本，模型文件设置工作完成。</p>

<pre><code>Show The File Inspector -&gt; Model Version -&gt; Current 设置为最新版本。
</code></pre>

<p><img src="http://al1020119.github.io/images/4007.png" title="Caption" ></p>

<p>设置版本</p>

<p>对模型文件的设置已经完成了，接下来系统还要知道我们想要怎样迁移数据。在迁移过程中可能会存在多种可能，苹果将这个灵活性留给了我们完成。剩下要做的就是编写迁移方案以及细节的代码。</p>

<p>轻量级版本迁移</p>

<p>轻量级版本迁移方案非常简单，大多数迁移工作都是由系统完成的，只需要告诉系统迁移方式即可。在持久化存储协调器(PSC)初始化对应的持久化存储(NSPersistentStore)对象时，设置options参数即可，参数是一个字典。PSC会根据传入的字典，自动推断版本迁移的过程。</p>

<p>字典中设置的key：</p>

<pre><code>    NSMigratePersistentStoresAutomaticallyOption设置为YES，CoreData会试着把低版本的持久化存储区迁移到最新版本的模型文件。

    NSInferMappingModelAutomaticallyOption设置为YES，CoreData会试着以最为合理地方式自动推断出源模型文件的实体中，某个属性到底对应于目标模型文件实体中的哪一个属性。
</code></pre>

<p>版本迁移的设置是在创建MOC时给PSC设置的，为了使代码更直观，下面只给出发生变化部分的代码，其他MOC的初始化代码都不变。</p>

<pre><code>// 设置版本迁移方案
NSDictionary *options = @{NSMigratePersistentStoresAutomaticallyOption : @YES,
                                NSInferMappingModelAutomaticallyOption : @YES};
// 创建持久化存储协调器，并将迁移方案的字典当做参数传入
[coordinator addPersistentStoreWithType:NSSQLiteStoreType configuration:nil URL:[NSURL fileURLWithPath:dataPath] options:options error:nil];
</code></pre>

<p>修改实体名</p>

<p>假设需要对已存在实体进行改名操作，需要将重命名后的实体Renaming ID，设置为之前的实体名。下面是Employee实体进行操作。</p>

<p><img src="http://al1020119.github.io/images/4008.png" title="Caption" ></p>

<p>修改实体名</p>

<p>修改后再使用实体时，应该将实体名设为最新的实体名，这里也就是Employee2，而且数据库中的数据也会迁移到Employee2表中。</p>

<pre><code>Employee2 *emp = [NSEntityDescription insertNewObjectForEntityForName:@"Employee2" inManagedObjectContext:context];
emp.name = @"lxz";
emp.brithday = [NSDate date];
emp.height = @1.9;
[context save:nil];
</code></pre>

<p>Mapping Model 迁移方案</p>

<p>轻量级迁移方案只是针对增加和改变实体、属性这样的一些简单操作，假设有更复杂的迁移需求，就应该使用Xcode提供的迁移模板(Mapping Model)。通过Xcode创建一个后缀为.xcmappingmodel的文件，这个文件是专门用来进行数据迁移用的，一些变化关系也会体现在模板中，看起来非常直观。</p>

<p>这里还以上面更改实体名，并迁移实体数据为例子，将Employee实体迁移到Employee2中。首先将Employee实体改名为Employee2，然后创建Mapping Model文件。</p>

<p>Command + N 新建文件 -> 选择 Mapping Model -> 选择源文件 Source Model -> 选择目标文件 Target Model -> 命名 Mapping Model 文件名 -> Create 创建完成。</p>

<p><img src="http://al1020119.github.io/images/4009.png" title="Caption" ></p>

<p>Mapping Model 文件</p>

<p>现在就创建好一个Mapping Model文件，文件中显示了实体、属性、Relationships，源文件和目标文件之间的关系。实体命名是EntityToEntity的方式命名的，实体包含的属性和关联关系，都会被添加到迁移方案中(Entity Mapping，Attribute Mapping，Relationship Mapping)。</p>

<p>在迁移文件的下方是源文件和目标文件的关系。</p>

<p><img src="http://al1020119.github.io/images/4010.png" title="Caption" ></p>

<p>对应关系</p>

<p>在上面图中改名后的Employee2实体并没有迁移关系，由于是改名后的实体，系统还不知道实体应该怎样做迁移。所以选中Mapping Model文件的Employee2 Mappings，可以看到右侧边栏的Source为invalid value。因为要从Employee实体迁移数据过来，所以将其选择为Employee，迁移关系就设置完成了。</p>

<p>设置完成后，还应该将之前EmployeeToEmployee的Mappings删除，因为这个实体已经被Employee2替代，它的Mappings也被Employee2 Mappings所替代，否则会报错。</p>

<p><img src="http://al1020119.github.io/images/4011.png" title="Caption" ></p>

<p>设置迁移关系</p>

<p>在实体的迁移过程中，还可以通过设置Predicate的方式，来简单的控制迁移过程。例如只需要迁移一部分指定的数据，就可以通过Predicate来指定。可以直接在右侧Filter Predicate的位置设置过滤条件，格式是$source.height &lt; 100，$source代表数据源的实体。</p>

<p><img src="http://al1020119.github.io/images/4012.png" title="Caption" ></p>

<p>Filter Predicate</p>

<p>更复杂的迁移需求</p>

<p>如果还存在更复杂的迁移需求，而且上面的迁移方式不能满足，可以考虑更复杂的迁移方式。假设要在迁移过程中，对迁移的数据进行更改，这时候上面的迁移方案就不能满足需求了。</p>

<p>对于上面提到的问题，在Mapping Model文件中选中实体，可以看到Custom Policy这个选项，选项对应的是NSEntityMigrationPolicy的子类，可以创建并设置一个子类，并重写这个类的方法来控制迁移过程。</p>

<pre><code>- (BOOL)createDestinationInstancesForSourceInstance:(NSManagedObject *)sInstance entityMapping:(NSEntityMapping *)mapping manager:(NSMigrationManager *)manager error:(NSError **)error;
</code></pre>

<p>版本迁移总结</p>

<p>版本迁移在需求的变更中肯定是要发生的，但是我们应该尽量避免这样的情况发生。在最开始设计模型文件数据结构的时候，就应该设计一个比较完善并且容易应对变化的结构，这样后面就算发生变化也不会对结构主体造成大的改动。</p>

<pre><code>Q Q：2211523682/790806573

微信：18370997821/13148454507

微博WB:http://weibo.com/u/3288975567?is_hot=1

git博文：http://al1020119.github.io/

github：https://github.com/al1020119
</code></pre>

<p><img src="http://al1020119.github.io/images/iCocosCoder.jpg" title="Caption" ></p>

<p><img src="http://al1020119.github.io/images/iCocosPublic.jpg" title="Caption" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CoreData还有撒？]]></title>
    <link href="http://al1020119.github.io/blog/2016/07/04/coredatechaiyousa/"/>
    <updated>2016-07-04T06:59:42+08:00</updated>
    <id>http://al1020119.github.io/blog/2016/07/04/coredatechaiyousa</id>
    <content type="html"><![CDATA[<p>之前两篇文章都比较偏理论，文字表达比较多一些，但都是干货！学习时先理解理论知识，才能更好的帮助后面的理解。在这篇文章中，将会涉及关于CoreData的一些复杂操作，这些操作会涉及分页查询、模糊查询、批处理等高级操作。通过这些操作可以更好的使用CoreData，提升CoreData性能。文章中将会出现大量示例代码，通过代码的方式更有助于理解。</p>

<p>文章内容还会比较多，希望各位耐心看完。文章中如有疏漏或错误，还请各位及时提出，谢谢！</p>

<p>NSPredicate</p>

<!--more-->


<p>概述</p>

<p>在iOS开发过程中，很多需求都需要用到过滤条件。例如过滤一个集合对象中存储的对象，可以通过Foundation框架下的NSPredicate类来执行这个操作。</p>

<p>CoreData中可以通过设置NSFetchRequest类的predicate属性，来设置一个NSPredicate类型的谓词对象当做过滤条件。通过设置这个过滤条件，可以只获取符合过滤条件的托管对象，不会将所有托管对象都加载到内存中。这样是非常节省内存和加快查找速度的，设计一个好的NSPredicate可以优化CoreData搜索性能。</p>

<p>语法</p>

<p>NSPredicate更加偏向于自然语言，不像SQLite一样有很多固定的语法，看起来也更加清晰易懂。例如下面需要查找条件为年龄30岁以上，并且包括30岁的条件。
1</p>

<pre><code>[NSPredicate predicateWithFormat:@"age &gt;= 30"]
</code></pre>

<p>过滤集合对象</p>

<p>可以通过NSPredicate对iOS中的集合对象执行过滤操作，可以是NSArray、NSSet及其子类。</p>

<p>对不可变数组NSArray执行的过滤，过滤后会返回一个NSArray类型的结果数组，其中存储着符合过滤条件的对象。
1</p>

<pre><code>NSArray *results = [array filteredArrayUsingPredicate:predicate]
</code></pre>

<p>对可变数组NSMutableArray执行的过滤条件，过滤后会直接改变原集合对象内部存储的对象，删除不符合条件的对象。
1</p>

<pre><code>[arrayM filterUsingPredicate:predicate]
</code></pre>

<p>复合过滤条件</p>

<p>谓词不只可以过滤简单条件，还可以过滤复杂条件，设置复合过滤条件。
1</p>

<pre><code>[NSPredicate predicateWithFormat:@"(age &lt; 25) AND (firstName = XiaoZhuang)"]
</code></pre>

<p>当然也可以通过NSCompoundPredicate对象来设置复合过滤条件，返回结果是一个NSPredicate的子类NSCompoundPredicate对象。
1</p>

<pre><code>[[NSCompoundPredicate alloc] initWithType:NSAndPredicateType subpredicates:@[predicate1, predicate2]]
</code></pre>

<p>枚举值NSCompoundPredicateType参数，可以设置三种复合条件，枚举值非常直观很容易看懂。</p>

<pre><code>NSNotPredicateType

NSAndPredicateType

NSOrPredicateType
</code></pre>

<p>基础语法</p>

<p>下面是列举的一些NSPredicate的基础语法，这些语法看起来非常容易理解，更复杂的用法可以去看苹果的官方API。</p>

<p><img src="http://al1020119.github.io/images/3001.png" title="Caption" ></p>

<p>正则表达式</p>

<p>NSPredicate中还可以使用正则表达式，可以通过正则表达式完成一些复杂需求，这使得谓词的功能更加强大，例如下面是一个手机号验证的正则表达式。
1
2</p>

<pre><code>NSString *mobile = @"^1(3[0-9]|5[0-35-9]|8[025-9])\\d{8}$";
NSPredicate *regexmobile = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", mobile];
</code></pre>

<p>模糊查询</p>

<p>NSPredicate支持对数据的模糊查询，例如下面使用通配符来匹配包含lxz的结果，具体CoreData中的使用在下面会讲到。
1</p>

<pre><code>[NSPredicate predicateWithFormat:@"name LIKE %@", @"*lxz*"]
</code></pre>

<p>keyPath</p>

<p>NSPredicate在创建查询条件时，还支持设置被匹配目标的keyPath，也就是设置更深层被匹配的目标。例如下面设置employee的name属性为查找条件，就是用点语法设置的keyPath。
1</p>

<pre><code>[NSPredicate predicateWithFormat:@"employee.name = %@", @"lxz"]
</code></pre>

<p>设置查询条件</p>

<p>在之前的文章中，执行下面MOC的fetchRequest方法，一般都需要传入一个NSFetchRequest类型的参数。这个request参数可以做一些设置操作，这样就可以以较优的性能获取指定的数据。
1</p>

<pre><code>- (nullable NSArray *)executeFetchRequest:(NSFetchRequest *)request error:(NSError **)error;
</code></pre>

<p>NSFetchRequest</p>

<p>在执行fetch操作前，可以给NSFetchRequest设置一些参数，这些参数包括谓词、排序等条件，下面是一些基础的设置。</p>

<pre><code>设置查找哪个实体，从数据库的角度来看就是查找哪张表，通过fetchRequestWithEntityName:或初始化方法来指定表名。

通过NSPredicate类型的属性，可以设置查找条件，这个属性在开发中用得最多。NSPredicate可以包括固定格式的条件以及正则表达式。

通过sortDescriptors属性，可以设置获取结果数组的排序方式，这个属性是一个数组类型，也就是可以设置多种排序条件。(但是注意条件不要冲突)

通过fetchOffset属性设置从查询结果的第几个开始获取，通过fetchLimit属性设置每次获取多少个。主要用于分页查询，后面会讲。
</code></pre>

<p>MOC执行fetch操作后，获取的结果是以数组的形式存储的，数组中存储的就是托管对象。NSFetchRequest提供了参数resultType，参数类型是一个枚举类型。通过这个参数，可以设置执行fetch操作后返回的数据类型。</p>

<pre><code>NSManagedObjectResultType: 返回值是NSManagedObject的子类，也就是托管对象，这是默认选项

NSManagedObjectIDResultType: 返回NSManagedObjectID类型的对象，也就是NSManagedObject的ID，对内存占用比较小。MOC可以通过NSManagedObjectID对象获取对应的托管对象，并且可以通过缓存NSManagedObjectID参数来节省内存消耗

NSDictionaryResultType: 返回字典类型对象

NSCountResultType: 返回请求结果的count值，这个操作是发生在数据库层级的，并不需要将数据加载到内存中
</code></pre>

<p>设置获取条件</p>

<pre><code>// 建立获取数据的请求对象，并指明操作Employee表
NSFetchRequest *request = [NSFetchRequest fetchRequestWithEntityName:@"Employee"];
// 设置请求条件，通过设置的条件，来过滤出需要的数据
NSPredicate *predicate = [NSPredicate predicateWithFormat:@"name = %@", @"lxz"];
request.predicate = predicate;
// 设置请求结果排序方式，可以设置一个或一组排序方式，最后将所有的排序方式添加到排序数组中
NSSortDescriptor *sort = [NSSortDescriptor sortDescriptorWithKey:@"height" ascending:YES];
// NSSortDescriptor的操作都是在SQLite层级完成的，不会将对象加载到内存中，所以对内存的消耗是非常小的
request.sortDescriptors = @[sort];
// 执行获取请求操作，获取的托管对象将会被存储在一个数组中并返回
NSError *error = nil;
NSArray *employees = [context executeFetchRequest:request error:&amp;error];
[employees enumerateObjectsUsingBlock:^(Employee * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
    NSLog(@"Employee Name : %@, Height : %@, Brithday : %@", obj.name, obj.height, obj.brithday);
}];
// 错误处理
if (error) {
    NSLog(@"CoreData Fetch Data Error : %@", error);
}
</code></pre>

<p>这里设置NSFetchRequest对象的一些请求条件，设置查找Employee表中name为lxz的数据，并且将所有符合的数据用height值升序的方式排列。</p>

<p>有实体关联关系</p>

<p>一个模型文件中的不同实体间，可以设置实体间的关联关系，这个在之前的文章中讲过。实体关联关系分为对一或对多，也可以设置是否双向关联。</p>

<p>这里演示的实体只是简单的To One的关系，并且下面会给出设置是否双向关联的区别对比。</p>

<p>插入实体</p>

<pre><code>// 创建托管对象，并将其关联到指定的MOC上
Employee *zsEmployee = [NSEntityDescription insertNewObjectForEntityForName:@"Employee" inManagedObjectContext:context];
zsEmployee.name = @"zhangsan";
zsEmployee.height = @1.9f;
zsEmployee.brithday = [NSDate date];
Employee *lsEmployee = [NSEntityDescription insertNewObjectForEntityForName:@"Employee" inManagedObjectContext:context];
lsEmployee.name = @"lisi";
lsEmployee.height = @1.7f;
lsEmployee.brithday = [NSDate date];
Department *iosDepartment = [NSEntityDescription insertNewObjectForEntityForName:@"Department" inManagedObjectContext:context];
iosDepartment.departName = @"iOS";
iosDepartment.createDate = [NSDate date];
iosDepartment.employee = zsEmployee;
Department *androidDepartment = [NSEntityDescription insertNewObjectForEntityForName:@"Department" inManagedObjectContext:context];
androidDepartment.departName = @"android";
androidDepartment.createDate = [NSDate date];
androidDepartment.employee = lsEmployee;
// 执行存储操作
NSError *error = nil;
if (context.hasChanges) {
    [context save:&amp;error];
}
// 错误处理
if (error) {
    NSLog(@"Association Table Add Data Error : %@", error);
}
</code></pre>

<p>上面创建了四个实体，并且将Employee都关联到Department上，完成关联操作后通过MOC存储到本地。</p>

<p>可以看到上面所有的托管对象创建时，都使用NSEntityDescription的insert方法创建，并和上下文建立关系。这时就想问了，我能直接采用传统的init方法创建吗？</p>

<p>会崩的！创建托管对象时需要指定MOC，在运行时动态的生成set、get方法。但是直接通过init方法初始化的对象，系统是不知道这里是需要系统自身生成set、get方法的，而且系统也不知道应该对应哪个MOC，会导致方法未实现的崩溃。所以就出现了开发中经常出现的错误，如下面崩溃信息：
1</p>

<pre><code>-[Employee setName:]: unrecognized selector sent to instance 0x7fa665900f60
</code></pre>

<p>双向关联</p>

<p>在上一篇文章中提到过双向关联的概念，也就是设置Relationship时Inverse是否为空。下面是Employee和Department在数据库中，设置inverse和没有设置inverse的两种数据存储，可以很清晰的对比出设置双向关联的区别。</p>

<p>测试代码还是用上面插入实体的代码，只是更改inverse选项。</p>

<p>设置双向关联</p>

<p><img src="http://al1020119.github.io/images/3002.png" title="Caption" ></p>

<p>Employee</p>

<p><img src="http://al1020119.github.io/images/3003.png" title="Caption" ></p>

<p>Department</p>

<p>未设置双向关联</p>

<p><img src="http://al1020119.github.io/images/3004.png" title="Caption" ></p>

<p>Employee</p>

<p><img src="http://al1020119.github.io/images/3005.png" title="Caption" ></p>

<p>Department</p>

<p>从图中可以看出，未设置双向关联的实体，Department关联Employee为属性并存储后，Department表中的关系是存在的，但Employee表中的关系依然是空的。而设置双向关联后的实体，在Department关联Employee为属性并存储后，Employee在表中自动设置了和Department的关系。</p>

<p>双向关联的关系不只体现在数据库中，在程序运行过程中托管对象的关联属性，也是随着发生变化的。双向关联的双方，一方的关联属性设置关系后，另一方关联属性的关系也会发生变化。用下面的代码打印一下各自的关联属性，结果和上面数据库的变化是一样的。
1</p>

<pre><code>NSLog(@"Department : %@, Employee : %@", androidDepartment.employee, lsEmployee.department);
</code></pre>

<p>查询操作</p>

<pre><code>// 创建获取数据的请求对象，并指明操作Department表
NSFetchRequest *request = [NSFetchRequest fetchRequestWithEntityName:@"Department"];
// 设置请求条件，设置employee的name为请求条件。NSPredicate的好处在于，可以设置keyPath条件
NSPredicate *predicate = [NSPredicate predicateWithFormat:@"employee.name = %@", @"lxz"];
request.predicate = predicate;
// 执行查找操作
NSError *error = nil;
NSArray *departments = [context executeFetchRequest:request error:&amp;error];
[departments enumerateObjectsUsingBlock:^(Department * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
    NSLog(@"Department Search Result DepartName : %@, employee name : %@", obj.departName, obj.employee.name);
}];
// 错误处理
if (error) {
    NSLog(@"Department Search Error : %@", error);
}
</code></pre>

<p>查找Department实体，并打印实体内容。就像上面讲的双向关系一样，有关联关系的实体，自己被查找出来后，也会将与之关联的其他实体也查找出来，并且查找出来的实体都是关联着MOC的。</p>

<p>分页查询</p>

<p>在从本地存储区获取数据时，可以指定从第几个获取，以及本次查询获取多少个数据，联合起来使用就是分页查询。当然也可以根据需求，单独使用这两个API。</p>

<p>这种需求在实际开发中非常常见，例如TableView中，上拉加载数据，每次加载20条数据，就可以利用分页查询轻松实现。</p>

<pre><code>// 创建获取数据的请求对象，并指明操作Employee表
NSFetchRequest *request = [NSFetchRequest fetchRequestWithEntityName:@"Employee"];
// 设置查找起始点，这里是从搜索结果的第六个开始获取
request.fetchOffset = 6;
// 设置分页，每次请求获取六个托管对象
request.fetchLimit = 6;
// 设置排序规则，这里设置身高升序排序
NSSortDescriptor *descriptor = [NSSortDescriptor sortDescriptorWithKey:@"height" ascending:YES];
request.sortDescriptors = @[descriptor];
// 执行查询操作
NSError *error = nil;
NSArray *employees = [context executeFetchRequest:request error:&amp;error];
[employees enumerateObjectsUsingBlock:^(Employee * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
    NSLog(@"Page Search Result Name : %@, height : %@", obj.name, obj.height);
}];
// 错误处理
if (error) {
    NSLog(@"Page Search Data Error : %@", error);
}
</code></pre>

<p>上面是一个按照身高升序排序，分页获取搜索结果的例子。查找Employee表中的实体，将结果按照height字段升序排序，并从结果的第六个开始查找，并且设置获取的数量也是六个。</p>

<p>模糊查询</p>

<p>有时需要获取具有某些相同特征的数据，这样就需要对查询的结果做模糊匹配。在CoreData执行模糊匹配时，可以通过NSPredicate执行这个操作。</p>

<pre><code>// 创建获取数据的请求对象，设置对Employee表进行操作
NSFetchRequest *request = [NSFetchRequest fetchRequestWithEntityName:@"Employee"];
// 创建模糊查询条件。这里设置的带通配符的查询，查询条件是结果包含lxz
NSPredicate *predicate = [NSPredicate predicateWithFormat:@"name LIKE %@", @"*lxz*"];
request.predicate = predicate;
// 执行查询操作
NSError *error = nil;
NSArray *employees = [context executeFetchRequest:request error:&amp;error];
[employees enumerateObjectsUsingBlock:^(Employee * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
    NSLog(@"Fuzzy Search Result Name : %@, height : %@", obj.name, obj.height);
}];
// 错误处理
if (error) {
    NSLog(@"Fuzzy Search Data Error : %@", error);
}
</code></pre>

<p>上面是使用通配符的方式进行模糊查询，NSPredicate支持多种形式的模糊查询，下面列举一些简单的匹配方式。模糊查询条件对大小写不敏感，所以查询条件大小写均可。</p>

<pre><code>以lxz开头
</code></pre>

<p>1</p>

<pre><code>NSPredicate *predicate = [NSPredicate predicateWithFormat:@"name BEGINSWITH %@", @"lxz"];

以lxz结尾
</code></pre>

<p>1</p>

<pre><code>NSPredicate *predicate = [NSPredicate predicateWithFormat:@"name ENDSWITH %@", @"lxz"];

其中包含lxz
</code></pre>

<p>1</p>

<pre><code>NSPredicate *predicate = [NSPredicate predicateWithFormat:@"name contains %@", @"lxz"];

查询条件结果包含lxz
</code></pre>

<p>1</p>

<pre><code>NSPredicate *predicate = [NSPredicate predicateWithFormat:@"name LIKE %@", @"*lxz*"];
</code></pre>

<p>加载请求模板</p>

<p>在之前的文章中谈到在模型文件中设置请求模板，也就是在.xcdatamodeld文件中，设置Fetch Requests，使用时可以通过对应的NSManagedObjectModel获取设置好的模板。</p>

<p>&hellip;. 省略上下文创建步骤 &hellip;.</p>

<pre><code>// 通过MOC获取模型文件对应的托管对象模型
NSManagedObjectModel *model = context.persistentStoreCoordinator.managedObjectModel;
// 通过.xcdatamodeld文件中设置的模板名，获取请求对象
NSFetchRequest *fetchRequest = [model fetchRequestTemplateForName:@"EmployeeFR"];
// 请求数据，下面的操作和普通请求一样
NSError *error = nil;
NSArray *dataList = [context executeFetchRequest:fetchRequest error:&amp;error];
[dataList enumerateObjectsUsingBlock:^(Employee * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
    NSLog(@"Employee.count = %ld, Employee.height = %f", dataList.count, [obj.height floatValue]);
}];
// 错误处理
if (error) {
    NSLog(@"Execute Fetch Request Error : %@", error);
}
</code></pre>

<p>获取结果Count值</p>

<p>开发过程中有时需要只获取所需数据的Count值，也就是执行获取操作后数组中所存储的对象数量。遇到这个需求，如果像之前一样MOC执行获取操作，获取到数组然后取Count，这样对内存消耗是很大的。</p>

<p>对于这个需求，苹果提供了两种常用的方式获取这个Count值。这两种获取操作，都是在数据库中完成的，并不需要将托管对象加载到内存中，对内存的开销也是很小的。</p>

<pre><code>方法1，设置resultType


// 设置过滤条件，可以根据需求设置自己的过滤条件
NSPredicate *predicate = [NSPredicate predicateWithFormat:@"height &lt; 2"];
// 创建请求对象，并指明操作Employee表
NSFetchRequest *fetchRequest = [NSFetchRequest fetchRequestWithEntityName:@"Employee"];
fetchRequest.predicate = predicate;
// 这一步是关键。设置返回结果类型为Count，返回结果为NSNumber类型
fetchRequest.resultType = NSCountResultType;
// 执行查询操作，返回的结果还是数组，数组中只存在一个对象，就是计算出的Count值
NSError *error = nil;
NSArray *dataList = [context executeFetchRequest:fetchRequest error:&amp;error];
NSInteger count = [dataList.firstObject integerValue];
NSLog(@"fetch request result Employee.count = %ld", count);
// 错误处理
if (error) {
    NSLog(@"fetch request result error : %@", error);
}
</code></pre>

<p>方法1中设置NSFetchRequest对象的resultType为NSCountResultType，获取到结果的Count值。这个枚举值在之前的文章中提到过，除了Count参数，还可以设置其他三种参数。</p>

<pre><code>方法2，使用MOC提供的方法


// 设置过滤条件
NSPredicate *predicate = [NSPredicate predicateWithFormat:@"height &lt; 2"];
// 创建请求对象，指明操作Employee表
NSFetchRequest *fetchRequest = [NSFetchRequest fetchRequestWithEntityName:@"Employee"];
fetchRequest.predicate = predicate;
// 通过调用MOC的countForFetchRequest:error:方法，获取请求结果count值，返回结果直接是NSUInteger类型变量
NSError *error = nil;
NSUInteger count = [context countForFetchRequest:fetchRequest error:&amp;error];
NSLog(@"fetch request result count is : %ld", count);
// 错误处理
if (error) {
    NSLog(@"fetch request result error : %@", error);
}
</code></pre>

<p>MOC提供了专门获取请求结果Count值的方法，通过这个方法可以直接返回一个NSUInteger类型的Count值，使用起来比上面的方法更方便点，其他都是一样的。</p>

<p>位运算</p>

<p>假设有需求是对Employee表中，所有托管对象的height属性计算总和。这个需求在数据量比较大的情况下，将所有托管对象加载到内存中是非常消耗内存的，就算批量加载也比较耗时耗内存。</p>

<p>CoreData对于这样的需求，提供了位运算的功能。MOC在执行请求时，是支持对数据进行位运算的。这个操作依然是在数据库层完成的，对内存的占用非常小。</p>

<pre><code>// 创建请求对象，指明操作Employee表
NSFetchRequest *fetchRequest = [NSFetchRequest fetchRequestWithEntityName:@"Employee"];
// 设置返回值为字典类型，这是为了结果可以通过设置的name名取出，这一步是必须的
fetchRequest.resultType = NSDictionaryResultType;
// 创建描述对象
NSExpressionDescription *expressionDes = [[NSExpressionDescription alloc] init];
// 设置描述对象的name，最后结果需要用这个name当做key来取出结果
expressionDes.name = @"sumOperatin";
// 设置返回值类型，根据运算结果设置类型
expressionDes.expressionResultType = NSFloatAttributeType;
// 创建具体描述对象，用来描述对那个属性进行什么运算(可执行的运算类型很多，这里描述的是对height属性，做sum运算)
NSExpression *expression = [NSExpression expressionForFunction:@"sum:" arguments:@[[NSExpression expressionForKeyPath:@"height"]]];
// 只能对应一个具体描述对象
expressionDes.expression = expression;
// 给请求对象设置描述对象，这里是一个数组类型，也就是可以设置多个描述对象
fetchRequest.propertiesToFetch = @[expressionDes];
// 执行请求，返回值还是一个数组，数组中只有一个元素，就是存储计算结果的字典
NSError *error = nil;
NSArray *resultArr = [context executeFetchRequest:fetchRequest error:&amp;error];
// 通过上面设置的name值，当做请求结果的key取出计算结果
NSNumber *number = resultArr.firstObject[@"sumOperatin"];
NSLog(@"fetch request result is %f", [number floatValue]);
// 错误处理
if (error) {
    NSLog(@"fetch request result error : %@", error);
}
</code></pre>

<p>执行结果：</p>

<p><img src="http://al1020119.github.io/images/3006.png" title="Caption" ></p>

<p>从执行结果可以看到，MOC对所有查找到的托管对象height属性执行了求和操作，并将结果放在字典中返回。位运算主要是通过NSFetchRequest对象的propertiesToFetch属性设置，这个属性可以设置多个描述对象，最后通过不同的name当做key来取出结果即可。</p>

<p>NSExpression类可以描述多种运算，可以在NSExpression.h文件中的注释部分，看到所有支持的运算类型，大概看了一下有二十多种运算。而且除了上面NSExpression调用的方法，此类还支持点语法的位运算，例如下面的例子。
1</p>

<pre><code>[NSExpression expressionWithFormat:@"@sum.height"];
</code></pre>

<p>批处理</p>

<p>在使用CoreData之前，我和公司同事也讨论过，假设遇到需要大量数据处理的时候怎么办。CoreData对于大量数据处理的灵活性肯定不如SQLite，这时候还需要自己使用其他方式优化数据处理。虽然在移动端这种情况很少出现，但是在持久层设计时还是要考虑这方面。</p>

<p>当需要进行数据的处理时，CoreData需要先将数据加载到内存中，然后才能对数据进行处理。这样对于大量数据来说，都加载到内存中是非常消耗内存的，而且容易导致崩溃的发生。如果遇到更改所有数据的某个字段这样的简单需求，需要将相关的托管对象都加载到内存中，然后进行更改、保存。</p>

<p>对于上面这样的问题，CoreData在iOS8推出了批量更新API，通过这个API可以直接在数据库一层就完成更新操作，而不需要将数据加载到内存。除了批量更新操作，在iOS9中还推出了批量删除API，也是在数据库一层完成的操作。关于批处理的API很多都是iOS8、iOS9出来的，使用时需要注意版本兼容。</p>

<p>但是有个问题，批量更新和批量删除的两个API，都是直接对数据库进行操作，更新完之后会导致MOC缓存和本地持久化数据不同步的问题。所以需要手动刷新受影响的MOC中存储的托管对象，使MOC和本地统一。假设你使用了NSFetchedResultsController，为了保证界面和数据的统一，这一步更新操作更需要做。</p>

<p>批量更新</p>

<pre><code>// 创建批量更新对象，并指明操作Employee表。
NSBatchUpdateRequest *updateRequest = [NSBatchUpdateRequest batchUpdateRequestWithEntityName:@"Employee"];
// 设置返回值类型，默认是什么都不返回(NSStatusOnlyResultType)，这里设置返回发生改变的对象Count值
updateRequest.resultType = NSUpdatedObjectsCountResultType;
// 设置发生改变字段的字典
updateRequest.propertiesToUpdate = @{@"height" : [NSNumber numberWithFloat:5.f]};
// 执行请求后，返回值是一个特定的result对象，通过result的属性获取返回的结果。MOC的这个API是从iOS8出来的，所以需要注意版本兼容。
NSError *error = nil;
NSBatchUpdateResult *result = [context executeRequest:updateRequest error:&amp;error];
NSLog(@"batch update count is %ld", [result.result integerValue]);
// 错误处理
if (error) {
    NSLog(@"batch update request result error : %@", error);
}
// 更新MOC中的托管对象，使MOC和本地持久化区数据同步
[context refreshAllObjects];
</code></pre>

<p>上面对Employee表中所有的托管对象height值做了批量更新，在更新时通过设置propertiesToUpdate字典来控制更新字段和更新的值，设置格式是字段名 : 新值。通过设置批处理对象的predicate属性，设置一个谓词对象来控制受影响的对象。</p>

<p>还可以对多个存储区(数据库)做同样批处理操作，通过设置其父类的affectedStores属性，类型是一个数组，可以包含受影响的存储区，多个存储区的操作对批量删除同样适用。</p>

<p>MOC在执行请求方法时，发现方法名也不一样了，执行的是executeRequest: error:方法，这个方法是从iOS8之后出来的。方法传入的参数是NSBatchUpdateRequest类，此类并不是继承自NSFetchRequest类，而是直接继承自NSPersistentStoreRequest，和NSFetchRequest是平级关系。</p>

<p>批量删除</p>

<pre><code>// 创建请求对象，并指明对Employee表做操作
NSFetchRequest *fetchRequest = [NSFetchRequest fetchRequestWithEntityName:@"Employee"];
// 通过谓词设置过滤条件，设置条件为height小于1.7
NSPredicate *predicate = [NSPredicate predicateWithFormat:@"height &lt; %f", 1.7f];
fetchRequest.predicate = predicate;
// 创建批量删除请求，并使用上面创建的请求对象当做参数进行初始化
NSBatchDeleteRequest *deleteRequest = [[NSBatchDeleteRequest alloc] initWithFetchRequest:fetchRequest];
// 设置请求结果类型，设置为受影响对象的Count
deleteRequest.resultType = NSBatchDeleteResultTypeCount;
// 使用NSBatchDeleteResult对象来接受返回结果，通过id类型的属性result获取结果
NSError *error = nil;
NSBatchDeleteResult *result = [context executeRequest:deleteRequest error:&amp;error];
NSLog(@"batch delete request result count is %ld", [result.result integerValue]);
// 错误处理
if (error) {
    NSLog(@"batch delete request error : %@", error);
}
// 更新MOC中的托管对象，使MOC和本地持久化区数据同步
[context refreshAllObjects];
</code></pre>

<p>大多数情况下，涉及到托管对象的操作，都需要将其加载到内存中完成。所以使用CoreData时，需要注意内存的使用，不要在内存中存在过多的托管对象。在已经做系统兼容的情况下，进行大量数据的操作时，应该尽量使用批处理来完成操作。</p>

<p>需要注意的是，refreshAllObjects是从iOS9出来的，在iOS9之前因为要做版本兼容，所以需要使用refreshObject: mergeChanges:方法更新托管对象。</p>

<p>异步请求</p>

<pre><code>// 创建请求对象，并指明操作Employee表
NSFetchRequest *fetchRequest = [NSFetchRequest fetchRequestWithEntityName:@"Employee"];
// 创建异步请求对象，并通过一个block进行回调，返回结果是一个NSAsynchronousFetchResult类型参数
NSAsynchronousFetchRequest *asycFetchRequest = [[NSAsynchronousFetchRequest alloc] initWithFetchRequest:fetchRequest completionBlock:^(NSAsynchronousFetchResult * _Nonnull result) {
    [result.finalResult enumerateObjectsUsingBlock:^(Employee * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
        NSLog(@"fetch request result Employee.count = %ld, Employee.name = %@", result.finalResult.count, obj.name);
    }];
}];
// 执行异步请求，和批量处理执行同一个请求方法
NSError *error = nil;
[context executeRequest:asycFetchRequest error:&amp;error];
// 错误处理
if (error) {
    NSLog(@"fetch request result error : %@", error);
}
</code></pre>

<p>上面通过NSAsynchronousFetchRequest对象创建了一个异步请求，并通过block进行回调。如果有多个请求同时发起，不需要担心线程安全的问题，系统会将所有的异步请求添加到一个操作队列中，在前一个任务访问数据库时，CoreData会将数据库加锁，等前面的执行完成才会继续执行后面的操作。</p>

<p>NSAsynchronousFetchRequest提供了cancel方法，也就是可以在请求过程中，将这个请求取消。还可以通过一个NSProgress类型的属性，获取请求完成进度。NSAsynchronousFetchRequest类从iOS8开始可以使用，所以低版本需要做版本兼容。</p>

<p>需要注意的是，执行请求时MOC并发类型不能是NSConfinementConcurrencyType，这个并发类型已经被抛弃，会导致崩溃。</p>

<pre><code>Q Q：2211523682/790806573

微信：18370997821/13148454507

微博WB:http://weibo.com/u/3288975567?is_hot=1

git博文：http://al1020119.github.io/

github：https://github.com/al1020119
</code></pre>

<p><img src="http://al1020119.github.io/images/iCocosCoder.jpg" title="Caption" ></p>

<p><img src="http://al1020119.github.io/images/iCocosPublic.jpg" title="Caption" ></p>
]]></content>
  </entry>
  
</feed>
