
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>iOS梦工厂</title>
  <meta name="author" content="iCocos">

  
  <meta name="description" content="控制器（View）生命周期 当一个视图控制器被创建，并在屏幕上显示的时候。 代码的执行顺序 1、 alloc 创建对象，分配空间
2、init (initWithNibName) 初始化对象，初始化数据
3、loadView 从nib载入视图 ，通常这一步不需要去干涉。 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://al1020119.github.io/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="iOS梦工厂" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//libs.baidu.com/jquery/1.7.2/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <script>
function addBlankTargetForLinks () {
    $('a[href^="http"]').each(function(){
                              $(this).attr('target', '_blank');
                              });
}
$(document).bind('DOMNodeInserted', function(event) {
             addBlankTargetForLinks();
             });
</script>
  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">iOS梦工厂</a></h1>
  
    <h2>不战胜自己，何以改变未来！</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="al1020119.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">首页</a></li>
  <li><a href="/blog/archives">归档</a></li>
  <li><a href="/iCocos">iCocos</a></li>
  <li><a href="/other">其他</a></li>
  <li><a href="/about">关于</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/11/28/iossheng-ming-zhou-qi/">iOS生命周期</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><h3>控制器（View）生命周期</h3>

<p>当一个视图控制器被创建，并在屏幕上显示的时候。 代码的执行顺序</p>

<pre><code>1、 alloc                                   创建对象，分配空间
2、init (initWithNibName) 初始化对象，初始化数据
3、loadView                          从nib载入视图 ，通常这一步不需要去干涉。除非你没有使用xib文件创建视图
4、viewDidLoad                   载入完成，可以进行自定义数据以及动态创建其他控件
5、viewWillAppear              视图将出现在屏幕之前，马上这个视图就会被展现在屏幕上了
6、viewDidAppear               视图已在屏幕上渲染完成
</code></pre>

<p>当一个视图被移除屏幕并且销毁的时候的执行顺序，这个顺序差不多和上面的相反</p>

<pre><code>1、viewWillDisappear            视图将被从屏幕上移除之前执行
2、viewDidDisappear             视图已经被从屏幕上移除，用户看不到这个视图了
3、dealloc                                 视图被销毁，此处需要对你在init和viewDidLoad中创建的对象进行释放
</code></pre>

<p>－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－</p>

<h3>app的启动过程</h3>

<pre><code>1.先执行main函数，main内部会调用UIApplicationMain函数

2.UIApplicationMain函数里面做了什么事情：

    1&gt; 创建UIApplication对象
    2&gt; 创建UIApplication的delegate对象—–PYAppDelegate
    3&gt; 开启一个消息循环

每监听到对应的系统事件时，就会通知MJAppDelegate

根据plist文件判断是否需要加载storyBoard
</code></pre>

<p>如果有storyBoard</p>

<pre><code>加载Info.plist文件，读取最主要storyboard文件的名称

加载最主要的storyboard文件，创建白色箭头所指的控制器对象

并且设置创建的控制器为UIWindow的rootViewController属性(根控制器)

初始化对应的子控件
</code></pre>

<p>如果没有storyBoard</p>

<pre><code>在代理的difinishLuaunchWithOPtions中为应用程序创建一个UIWindow对象(继承自UIView)，设置为PYAppDelegate的window属性

并且设置创建的控制器为UIWindow的rootViewController属性(根控制器)

初始化对应的子控件
</code></pre>

<p>－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－</p>

<h3>App的生命周期</h3>

<p>这里只是简单的总结，关于有些方法我们并没有解除过，所以就略过了。</p>

<pre><code> 1、application didFinishLaunchingWithOptions：当应用程序启动时执行，应用程序启动入口，只在应用程序启动时执行一次。若用户直接启动，lauchOptions内无数据,若通过其他方式启动应用，lauchOptions包含对应方式的内容。
 2、applicationWillResignActive：在应用程序将要由活动状态切换到非活动状态时候，要执行的委托调用，如 按下 home 按钮，返回主屏幕，或全屏之间切换应用程序等。

 3、applicationDidEnterBackground：在应用程序已进入后台程序时，要执行的委托调用。

 4、applicationWillEnterForeground：在应用程序将要进入前台时(被激活)，要执行的委托调用，刚好与applicationWillResignActive 方法相对应。

 5、applicationDidBecomeActive：在应用程序已被激活后，要执行的委托调用，刚好与applicationDidEnterBackground 方法相对应。

 6、applicationWillTerminate：在应用程序要完全推出的时候，要执行的委托调用，这个需要要设置UIApplicationExitsOnSuspend的键值。
</code></pre>
</div>
  
  




| <a href="/blog/2015/11/28/iossheng-ming-zhou-qi/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/11/28/chang-lian-jie-and-duan-lian-jie/">长链接&amp;短链接</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><ul>
<li>HTTP协议与TCP/IP协议的关系</li>
<li>如何理解HTTP协议是无状态的</li>
<li>什么是长连接、短连接？

<ul>
<li> TCP连接</li>
<li> TCP短连接</li>
<li> TCP长连接</li>
</ul>
</li>
<li>长连接短连接操作过程</li>
<li>长连接和短连接的优点和缺点</li>
<li>什么时候用长连接，短连接？</li>
</ul>


<h3>HTTP协议与TCP/IP协议的关系</h3>

<p>HTTP的长连接和短连接本质上是TCP长连接和短连接。HTTP属于应用层协议，在传输层使用TCP协议，在网络层使用IP协议。IP协议主要解决网络路由和寻址问题，TCP协议主要解决如何在IP层之上可靠的传递数据包，使在网络上的另一端收到发端发出的所有包，并且顺序与发出顺序一致。TCP有可靠，面向连接的特点。</p>

<h3>如何理解HTTP协议是无状态的</h3>

<p>HTTP协议是无状态的，指的是协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。也就是说，打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系。HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接）。</p>

<h3>什么是长连接、短连接？</h3>

<p>在HTTP/1.0中，默认使用的是短连接。也就是说，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。如果客户端浏览器访问的某个HTML或其他类型的 Web页中包含有其他的Web资源，如JavaScript文件、图像文件、CSS文件等；当浏览器每遇到这样一个Web资源，就会建立一个HTTP会话。</p>

<p>但从 HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头有加入这行代码：</p>

<p>Connection:keep-alive</p>

<p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的 TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接要客户端和服务端都支持长连接。</p>

<p>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</p>

<h5>TCP连接</h5>

<p>当网络通信时采用TCP协议时，在真正的读写操作之前，server与client之间必须建立一个连接，当读写操作完成后，双方不再需要这个连接 时它们可以释放这个连接，连接的建立是需要三次握手的，而释放则需要4次握手，所以说每个连接的建立都是需要资源消耗和时间消耗的</p>

<p>经典的三次握手示意图：</p>

<p>经典的四次握手关闭图：</p>

<h5>TCP短连接</h5>

<p>我们模拟一下TCP短连接的情况，client向server发起连接请求，server接到请求，然后双方建立连接。client向server 发送消息，server回应client，然后一次读写就完成了，这时候双方任何一个都可以发起close操作，不过一般都是client先发起 close操作。为什么呢，一般的server不会回复完client后立即关闭连接的，当然不排除有特殊的情况。从上面的描述看，短连接一般只会在 client/server间传递一次读写操作</p>

<p>短连接的优点是：管理起来比较简单，存在的连接都是有用的连接，不需要额外的控制手段</p>

<h5>TCP长连接</h5>

<p>接下来我们再模拟一下长连接的情况，client向server发起连接，server接受client连接，双方建立连接。Client与server完成一次读写之后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。</p>

<p>首先说一下TCP/IP详解上讲到的TCP保活功能，保活功能主要为服务器应用提供，服务器应用希望知道客户主机是否崩溃，从而可以代表客户使用资源。如果客户已经消失，使得服务器上保留一个半开放的连接，而服务器又在等待来自客户端的数据，则服务器将应远等待客户端的数据，保活功能就是试图在服务 器端检测到这种半开放的连接。</p>

<p>如果一个给定的连接在两小时内没有任何的动作，则服务器就向客户发一个探测报文段，客户主机必须处于以下4个状态之一：</p>

<p>客户主机依然正常运行，并从服务器可达。客户的TCP响应正常，而服务器也知道对方是正常的，服务器在两小时后将保活定时器复位。
客户主机已经崩溃，并且关闭或者正在重新启动。在任何一种情况下，客户的TCP都没有响应。服务端将不能收到对探测的响应，并在75秒后超时。服务器总共发送10个这样的探测 ，每个间隔75秒。如果服务器没有收到一个响应，它就认为客户主机已经关闭并终止连接。
客户主机崩溃并已经重新启动。服务器将收到一个对其保活探测的响应，这个响应是一个复位，使得服务器终止这个连接。
客户机正常运行，但是服务器不可达，这种情况与2类似，TCP能发现的就是没有收到探查的响应。</p>

<h5>长连接短连接操作过程</h5>

<p>短连接的操作步骤是：</p>

<p>建立连接——数据传输——关闭连接…建立连接——数据传输——关闭连接</p>

<p>长连接的操作步骤是：</p>

<p>建立连接——数据传输…（保持连接）…数据传输——关闭连接</p>

<h3>长连接和短连接的优点和缺点</h3>

<p>由上可以看出，长连接可以省去较多的TCP建立和关闭的操作，减少浪费，节约时间。对于频繁请求资源的客户来说，较适用长连接。不过这里存在一个问题，存活功能的探测周期太长，还有就是它只是探测TCP连接的存活，属于比较斯文的做法，遇到恶意的连接时，保活功能就不够使了。在长连接的应用场景下，client端一般不会主动关闭它们之间的连接，Client与server之间的连接如果一直不关闭的话，会存在一个问题，随着客户端连接越来越多，server早晚有扛不住的时候，这时候server端需要采取一些策略，如关闭一些长时间没有读写事件发生的连接，这样可 以避免一些恶意连接导致server端服务受损；如果条件再允许就可以以客户端机器为颗粒度，限制每个客户端的最大长连接数，这样可以完全避免某个蛋疼的客户端连累后端服务。</p>

<p>短连接对于服务器来说管理较为简单，存在的连接都是有用的连接，不需要额外的控制手段。但如果客户请求频繁，将在TCP的建立和关闭操作上浪费时间和带宽。</p>

<p>长连接和短连接的产生在于client和server采取的关闭策略，具体的应用场景采用具体的策略，没有十全十美的选择，只有合适的选择。</p>

<h3>什么时候用长连接，短连接？</h3>

<p>长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况，。每个TCP连接都需要三步握手，这需要时间，如果每个操作都是先连接，再操作的话那么处理速度会降低很多，所以每个操作完后都不断开，次处理时直接发送数据包就OK了，不用建立TCP连接。例如：数据库的连接用长连接， 如果用短连接频繁的通信会造成socket错误，而且频繁的socket 创建也是对资源的浪费。</p>

<p>而像WEB网站的http服务一般都用短链接，因为长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以并发量大，但每个用户无需频繁操作情况下需用短连好。</p>
</div>
  
  




| <a href="/blog/2015/11/28/chang-lian-jie-and-duan-lian-jie/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/11/28/iosban-ben-gua-pei-wen-ti-(6,7,8,9)/">iOS版本适配问题（6，7，8，9）</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><h2>iOS6新特性</h2>

<h4>一、关于内存警告</h4>

<p>ios6中废除了viewDidUnload，viewWillUnload这两个系统回调，收到内存警告时在didReceiveMemoryWarning中进行相关的处理。</p>

<pre><code>- (void)viewDidUnload {
    [super viewDidUnload];
    // 处理 ios6 以下的系统内存警告系统回调消息
}

// 这里处理ios6 的内存警告
- (void)didReceiveMemoryWarning {
    [super didReceiveMemoryWarning];

float sysVer = [[[UIDevice currentDevice] systemVersion] floatValue];
//ios6 的特殊处理

if (sysVer &gt;= 6.0f) {
    // 保证 invisible,  因为即使在当前界面也会收到系统回调
    if (self.view.window == nil) {
        //.......
        // 做相关的释放操作
        self.view = nil;   // 确保下次会重新加载
    }
}
}
</code></pre>

<h4>二、关于屏幕旋转</h4>

<p>同样ios6 废除了shouldAutorotateToInterfaceOrientation这个旋转屏幕的设置接口。</p>

<ul>
<li><p>必须在两个新接口中设置旋转属性:shouldAutorotate、supportedInterfaceOrientations。</p></li>
<li><p>收到旋转事件后的处理，同样在willRotateToInterfaceOrientation和didRotateFromInterfaceOrientation中进行。</p></li>
</ul>


<h4>三、UISwitch</h4>

<p>ios6下，新增了以下几个属性，可以设置开关的颜色以及背景图。</p>

<pre><code>@property (nonatomic,  retain) UIColor *tintColor;

@property (nonatomic,  retain) UIColor *thumbTintColor;

@property (nonatomic,  retain) UIImage *onImage;

@property (nonatomic,  retain) UIImage *offImage;
</code></pre>

<h4>四、UINavigationBar</h4>

<p>ios6新增了，设置阴影图片的属性。</p>

<pre><code>@property (nonatomic, retain) UIImage *shadowImage;
</code></pre>

<h4>五、UIImage</h4>

<p>可以在ios6下设置图片的scale比例尺寸了。</p>

<pre><code>+ (UIImage *)imageWithData:(NSData *)data scale:(CGFloat)scale;

- (id)initWithData:(NSData *)data scale:(CGFloat)scale;
</code></pre>

<h4>六、UIRefreshControl</h4>

<p>之前苹果官方是没有现成的下拉刷新的控件，都是自己实现或者使用比较成熟的开源库。</p>

<ul>
<li>ios6苹果加入了UIRefreshControl，配合UITableView直接实现下拉刷新。</li>
</ul>


<h4>七、UICollectionView</h4>

<p>全新的集合控件，应用场景有类似照片墙，瀑布流等。</p>

<h2>iOS7新特性</h2>

<h4>一、已禁用-[UIDevice uniqueIdentifier]</h4>

<p>苹果总是把用户的隐私看的很重要。-[UIDevice uniqueIdentifier]在iOS5实际在iOS5的时候已经被遗弃了，但是iOS7中已经完全的禁用了它。Xcode5甚至不会允许你编译包含了指引到-[UIDevice uniqueIdentifier]的app。</p>

<ul>
<li>此外，iOS7之前的使用了-[UIDevice uniqueIdentifier] 的app如果在iOS7上运行，它不会返回设备的UUID，而是会返回一串字符串，以FFFFFFFF开头，跟着-[UIDevice identifierForVendor]的十六进制值。</li>
</ul>


<h4>二、UIPasteboard由共享变为沙盒化了</h4>

<p>UIPasteboard过去是用来做app之间的数据分享的。UIPasteboard本无问题，但是开发者开始使用它来存储标识符，和其他的相关app分享这些标识符的时候问题就出现了。有一个使用这种把戏的就是OpenUDID。</p>

<ul>
<li>在iOS7中，使用 +[UIPasteboard pasteboardWithName:create:]和 +[UIPasteboard pasteboardWithUniqueName]创建剪贴板，而且只对相同的app group可见，这样就让OpenUDID不那么有用了。</li>
</ul>


<h4>三、MAC地址不能再用来设别设备</h4>

<p>还有一个生成iOS设备唯一标示符的方法是使用iOS设备的Media Access Control（MAC）地址。一个MAC地址是一个唯一的号码，它是物理网络层级方面分配给网络适配器的。这个地址苹果还有其他的名字，比如说是硬件地址（Hardware Address)或是Wifi地址，都是指同样的东西。</p>

<ul>
<li><p>有很多工程和框架都使用这个方法来生成唯一的设备ID。比如说ODIN。然而，苹果并不希望有人通过MAC地址来分辨用户，所以如果你在iOS7系统上查询MAC地址，它现在只会返回02:00:00:00:00:00。</p></li>
<li><p>现在苹果明确的表明你应该使用-[UIDevice identifierForVendor]或是-[ASIdentifierManager advertisingIdentifier]来作为你框架和应用的唯一标示符。坦白的来说，应对这些变化也不是那么的难，见以下代码片段：</p></li>
</ul>


<hr />

<pre><code>NSString *identifierForVendor = [[UIDevice currentDevice].identifierForVendor UUIDString];

NSString *identifierForAdvertising = [[ASIdentifierManager sharedManager].advertisingIdentifier UUIDString];
</code></pre>

<p>每种方法都适配一种特别的用法：</p>

<ul>
<li><p>identifierForVendor对供应商来说是唯一的一个值，也就是说，由同一个公司发行的的app在相同的设备上运行的时候都会有这个相同的标识符。然而，如果用户删除了这个供应商的app然后再重新安装的话，这个标识符就会不一致。</p></li>
<li><p>advertisingIdentifier会返回给在这个设备上所有软件供应商相同的 一个值，所以只能在广告的时候使用。这个值会因为很多情况而有所变化，比如说用户初始化设备的时候便会改变。</p></li>
</ul>


<h4>四、iOS现在要求app如需使用麦克风，需要征得用户同意</h4>

<p>以前如果app需要使用用户的位置，通讯录，日历，提醒以及照片，接受推送消息，使用用户的社交网络的时候需要征得用户的同意。现在在iOS7当中，使用麦克风也需要取得用户同意了。如果用户不允许app使用麦克风的话，那么需要使用麦克风的app就不能接收不到任何声音。</p>

<p>以下的代码是用来查询用户是否允许app使用麦克风：</p>

<pre><code>//第一次调用这个方法的时候，系统会提示用户让他同意你的app获取麦克风的数据
// 其他时候调用方法的时候，则不会提醒用户
// 而会传递之前的值来要求用户同意
[[AVAudioSession sharedInstance] requestRecordPermission:^(BOOL granted) {
    if (granted) {
        // 用户同意获取数据
    } else {
        // 可以显示一个提示框告诉用户这个app没有得到允许？
    }
}];
</code></pre>

<p>你同时还要注意，如果你在获得用户的同意之前使用任何方法来使用麦克风的话，会引起iOS系统弹出以下警示栏：</p>

<p><img src="/images/banbenshipei001.jpg" title="Caption" ></p>

<h4>五、[NSArray firstObject]的实现</h4>

<p>-[NSArray firstObject]可能是Objective-C中被调用做多的API。在Open Radar上一个简单的调查显示有一些需求苹果已经做了记录。好消息是现在这些需求已经得到了解决。. firstObject的使用可以追溯到iOS4.0，但是那时仅仅是一个私有方法。在iOS7以前，工程师用下面的方式来使用它：</p>

<pre><code>NSArray *arr = @[];
id item = [arr firstObject];

// 在之前你需要做以下工作
id item = [arr count] &gt; 0 ? arr[0] : nil;
</code></pre>

<p>因为上面的方式很平常，有些人将它作为一个类增加到NSArray中，然后创建他们自己的firstObject方法。</p>

<p>这个方法的问题是这个方法的名字必须是唯一的，否则的话这个方法所引发的问题无法预估。</p>

<ul>
<li>请确保检查你是否有任何自定义的代码在NSArray上实现了firstObject，如果有的话看看它是否是必须的，不是必须的话就把它全部移除。</li>
</ul>


<h4>六、增加了instancetype</h4>

<p>instancetype让iOS7API变得更加难懂。苹果改变了大部分 initializer和简易构造函数（convenience constructors），用instancetype代替id作返回类型。但是这个instancetype是什么呢？</p>

<ul>
<li><p>instancetype用来在声明一个方法时告诉编译器其返回类型，它表示返回调用该方法的类的对象。</p></li>
<li><p>这比之前返回id的通常做法要好，编译器可以对返回类型做一些检查，如果出现错误，在编译时就能提醒你，而不是在程序运行时发生崩溃。</p></li>
<li><p>同时，在调用子类方法时，使用它还可以省去对返回值的强制类型转换，编译器能够正确推断方法的返回值类型。</p></li>
<li><p>要说到instancetaype的缺点和优点吗？基本上，在任何可能的情况下都可以使用它。</p></li>
</ul>


<h4>七、设置UIImage的渲染模式：UIImage.renderingMode</h4>

<p>着色（Tint Color）是iOS7界面中的一个重大改变，你可以设置一个UIImage在渲染时是否使用当前视图的Tint Color。</p>

<pre><code>UIImage新增了一个只读属性：renderingMode，对应的还有一个新增方法：*imageWithRenderingMode:，它使用UIImageRenderingMode枚举值来设置图片的renderingMode属性。该枚举中包含下列值：



// 根据图片的使用环境和所处的绘图上下文自动调整渲染模式
UIImageRenderingModeAutomatic 

// 始终绘制图片原始状态，不使用Tint Color
UIImageRenderingModeAlwaysOriginal 

// 始终根据Tint Color绘制图片，忽略图片的颜色信息
UIImageRenderingModeAlwaysTemplate
</code></pre>

<p>renderingMode属性的默认值是UIImageRenderingModeAutomatic，即UIImage是否使用
Tint Color取决于它显示的位置。其他情况可以看下面的图例：</p>

<p><img src="/images/banbenshipei002.jpg" title="Caption" ></p>

<p>以下的代码说明了使用一个既定的rendering模式创建图片是多么简单：</p>

<pre><code>UIImage *img = [UIImage imageNamed:@"myimage"];

img = [img imageWithRenderingMode:UIImageRenderingModeAlwaysTemplate];
</code></pre>

<h4>八、tintcolor VS barTintColor</h4>

<p>iOS7中你可以使用一个给定的颜色，甚至是记入颜色主题来给整个app着色，帮助你的app脱颖而出。设置app的tint color很简答，只要使用UIView的新属性tintColor即可。</p>

<p>这个属性是否听上去很熟悉呢？应该很熟悉，有些类，比如说UINaviagtionBar，UISearchBar，UITabBar以及UIToolbar已经有了这么命名的属性。他们现在有了一个新的属性：barTintColor。</p>

<p>为了避免使用新属性的时候犯错误，如果你的appp需要支持iOS6以前的系统的时候，请检查一下。</p>

<pre><code>UINavigationBar *bar = self.navigationController.navigationBar;
UIColor *color = [UIColor greenColor];

if ([bar respondsToSelector:@selector(setBarTintColor:)]) { // iOS 7+
    bar.barTintColor = color;
} else { // what year is this? 2012?
    bar.tintColor = color;
}
</code></pre>

<h4>九、去掉了纹理颜色</h4>

<p><img src="/images/banbenshipei003.jpg" title="Caption" ></p>

<p>纹理颜色？对，不再使用他们了，不能再创建可以展现纹理的颜色。</p>

<p>根据UIInterface.h文件中的注释，-[UIColor groupTableViewBackgroundColor]应该是要在iOS6当中即被删除了，但是它仅仅只是不像之前那样返回纹理颜色了。然而，以下的颜色在iOS7当中被删除了:</p>

<pre><code>+ (UIColor *)viewFlipsideBackgroundColor;

+ (UIColor *)scrollViewTexturedBackgroundColor;

+ (UIColor *)underPageBackgroundColor;
</code></pre>

<h4>十、UIButtonTypeRoundRect被UIButtonTypeSystem取代了</h4>

<p><img src="/images/banbenshipei004.jpg" title="Caption" ></p>

<ul>
<li><p>在iOS开发刚开始就陪伴着你的老朋友现在也被删除了，它就是UIButtonTypeRoundRect ，被新的UIButtonTypeSystem取代了。</p></li>
<li><p>如果每次iOS系统的发布都没有一些新的功能会是什么样子？这些新功能相信大部分开发者已经知道了，你可能会发现一些新颖的方式将它们整合到你的app中去！</p></li>
</ul>


<h4>十一、检查无线路由是否可用</h4>

<p>定制一个视频播放器的能力在iOS版本每次的发布中一直有所进步。比如说，在iOS6之前，你不能在MPVolumeView中改变AirPlay的icon。</p>

<p>在iOS7当中，你可以通过AirPlay，蓝牙或是其他的虚线机制了解是否有一个远程的设备可用。了解它的话，就可以让你的app在恰当的时候做恰当的事，比如说，在没有远程设备的时候就不显示AirPlay的icon。</p>

<p>以下是新增加到MPVolumeView的新属性和推送</p>

<pre><code>@property (nonatomic, readonly) BOOL wirelessRoutesAvailable; //  是否有设备可以连接的无线线路？
@property (nonatomic, readonly) BOOL wirelessRouteActive; // 设备现在是否连接上了网络
NSString *const MPVolumeViewWirelessRoutesAvailableDidChangeNotification;
NSString *const MPVolumeViewWirelessRouteActiveDidChangeNotification;
</code></pre>

<h4>十二、了解蜂窝网络</h4>

<p>在iOS7之前，是使用Reachability来检测设备是否连接到WWAN或是Wifi的。iOS7在这个基础上更进了一步，它会告诉你的设备连接上的是那种蜂窝网络，比如说是Edge网络，HSDPA网络，或是LTE网络。告诉用户他们连接上的是哪种网络可以优化用户体验，因为这样他们会知道网速如何，不会去请求需要高网速的网络请求。</p>

<p>这是CTTelephonyNetworkInfo的部分功能，它是CoreTelephony框架的一部分。iOS7还增加了currentRadioAccessTechnology属性和CTRadioAccessTechnologyDidChangeNotification到这个类。还有一些新的字符串常量来定义可能的值，比如说是CTRadioAccessTechnologyLTE。</p>

<p>以下代码告诉你在app delegate中如何使用这个新功能：</p>

<pre><code>@import CoreTelephony.CTTelephonyNetworkInfo; // new modules syntax!
@interface AppDelegate ()
// we need to keep a reference to the CTTelephonyNetworkInfo object, otherwise the notifications won't be fired!
@property (nonatomic, strong) CTTelephonyNetworkInfo *networkInfo;
@end

@implementation ViewController

- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
    // whatever stuff your method does...

    self.networkInfo = [[CTTelephonyNetworkInfo alloc] init];
    NSLog(@"Initial cell connection: %@", self.networkInfo.currentRadioAccessTechnology);
    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(radioAccessChanged) name:
     CTRadioAccessTechnologyDidChangeNotification object:nil];

    // whatever stuff your method does...
}

- (void)radioAccessChanged {
    NSLog(@"Now you're connected via %@", self.networkInfo.currentRadioAccessTechnology);
}

@end
</code></pre>

<h6>##注意：研究一下CTTelephonyNetworkInfo.h 文件来看看是否有其他无线网络类型的的字符串常量。如果设备没有连上的话，currentRadioAccessTechnology 则会返回nil。</h6>

<h4>十三、通过iCloud同步用户设备的密码</h4>

<p>iOS7以及Mavericks增加了iCloud Keychain来提供密码，以及iCloud中一些敏感数据的同步。开发者可以通过keychain中的kSecAttrSynchronizable key来遍历dictionary对象。</p>

<p>由于直接处理keychain比较难，封装库提供了一个简单的处理keychain的方法。SSKeychain封装库可能是最有名的的一个，作为一种福利，现在它支持在iCloud同步。</p>

<p>以下代码片段显示了如何使用SSKeychain：</p>

<pre><code>#import &lt;SSKeychain.h&gt;

- (BOOL)saveCredentials:(NSError **)error {
    SSKeychainQuery *query = [[SSKeychainQuery alloc] init];
    query.password = @"MySecretPassword";
    query.service = @"MyAwesomeService";
    query.account = @"John Doe";
    query.synchronizable = YES;
    return [query save:&amp;error];
}

- (NSString *)savedPassword:(NSError **)error {
    SSKeychainQuery *query = [[SSKeychainQuery alloc] init];
    query.service = @"MyAwesomeService";
    query.account = @"John Doe";
    query.synchronizable = YES;
    query.password = nil;
    if ([query fetch:&amp;error]) {
        return query.password;
    }
    return nil;
}
</code></pre>

<p>不要忘记CocoaPods是快速便捷安装SSKeychian的好方法。</p>

<h4>十四、使用NSAttributedString显示HTML</h4>

<p>在app中使用webview有时会让人非常沮丧，即使只是显示少量的HTMLneirong ,webview也会消耗大量的内存。现在iOS7让这些变得简单了，你可以从用少量代码在HTML文件中创建一个NSAttributedString，比如：</p>

<pre><code>NSString *html = @"&lt;bold&gt;Wow!&lt;/bold&gt; Now &lt;em&gt;iOS&lt;/em&gt; can create &lt;h3&gt;NSAttributedString&lt;/h3&gt; from HTMLs!";
NSDictionary *options = @{NSDocumentTypeDocumentAttribute: NSHTMLTextDocumentType};

NSAttributedString *attrString = [[NSAttributedString alloc] initWithData:[html dataUsingEncoding:NSUTF8StringEncoding] options:options documentAttributes:nil error:nil];
</code></pre>

<p>现在你可以在任意的UIKit对象上使用NSAttributedString 了，比如说是一个UILabel或是一个UITextField。</p>

<p>注意：NSHTMLTextDocumentType 只是NSDocumentTypeDocumentAttribute key一种可能的值。你还可以使用NSPlainTextDocumentType，NSRTFTextDocumentType或是NSRTFDTextDocumentType。</p>

<p>你还可以从NSAttributedString中创建一个HTML字符串，如下：</p>

<pre><code>NSAttributedString *attrString; // from previous code
NSDictionary *options = @{NSDocumentTypeDocumentAttribute: NSHTMLTextDocumentType};

NSData *htmlData = [attrString dataFromRange:NSMakeRange(0, [attrString length]) documentAttributes:options error:nil];
NSString *htmlString = [[NSString alloc] initWithData:htmlData encoding:NSUTF8StringEncoding];
</code></pre>

<p>现在你估计在app中会更多的使用HTML了。</p>

<h4>十五、使用原生的Base64</h4>

<p>Base64是使用ASCII码显示二进制数据的一种流行方法。直到现在，开发者还不得不使用开源的工具来编码解码Base64的内容。</p>

<p>现在iOS7引入了以下四种新的NSData方法来操作Base64编码的数据：</p>

<pre><code>// From NSData.h
- (id)initWithBase64EncodedString:(NSString *)base64String options:(NSDataBase64DecodingOptions)options;

- (NSString *)base64EncodedStringWithOptions:(NSDataBase64EncodingOptions)options;

- (id)initWithBase64EncodedData:(NSData *)base64Data options:(NSDataBase64DecodingOptions)options;

- (NSData *)base64EncodedDataWithOptions:(NSDataBase64EncodingOptions)options;
这些方法可以帮助你轻易的将NSData对象转化为Base64，或者将Base64转化为NSData object。见以下的例子：


NSData* sampleData = [@"Some sample data" dataUsingEncoding:NSUTF8StringEncoding];

NSString * base64String = [sampleData base64EncodedStringWithOptions:0];
NSLog(@"Base64-encoded string is %@", base64String); // prints "U29tZSBzYW1wbGUgZGF0YQ=="

NSData* dataFromString = [[NSData alloc] initWithBase64EncodedString:base64String options:0];
NSLog(@"String is %@",[NSString stringWithUTF8String:[dataFromString bytes]]); // prints "String is Some sample data"
</code></pre>

<p>如果你需要支持iOS6或者更早以前的系统，你可以使用以下两个方法：</p>

<pre><code>/* These methods first appeared in NSData.h on OS X 10.9 and iOS 7.0. They are deprecated in the same releases in favor of
 the methods in the &lt;code&gt;NSDataBase64Encoding&lt;/code&gt; category. However, these methods have existed for several releases, so
 they may be used for applications targeting releases prior to OS X 10.9 and iOS 7.0.
 */
- (id)initWithBase64Encoding:(NSString *)base64String;
- (NSString *)base64Encoding;
</code></pre>

<h4>十六、使用UIApplicationUserDidTakeScreenshotNotification来检查截图</h4>

<p>在iOS7之前，像Snapshot或是Facebook Poke这样的app是使用一些很精巧的方法来检测用户是否有截图。然而，iOS7提供一个崭新的推送方法：UIApplicationUserDidTakeScreenshotNotification。只要像往常一样订阅即可知道什么时候截图了。</p>

<p>注意：UIApplicationUserDidTakeScreenshotNotification 将会在截图完成之后显示。现在在截图截取之前无法得到通知。希望苹果会在iOS8当中增加UIApplicationUserWillTakeScreenshotNotification。</p>

<h4>十七、实现多语言语音合成</h4>

<p>如果可以让app说话会不会很好呢？iOS7加入了两个新类：AVSpeechSynthesizer 以及AVSpeechUtterance。这两个类可以给你的app发声。很有意思不是吗？有多种语言可供选择——Siri不会说的语言也有，比如说巴西葡萄牙语。</p>

<p>使用这两个类给app提供语言合成的功能非常简单。AVSpeechUtterance 代表你想说什么，如何说。AVSpeechSynthesizer 用来发出这些声音，见以下代码片段：</p>

<pre><code>AVSpeechSynthesizer *synthesizer = [[AVSpeechSynthesizer alloc] init];
AVSpeechUtterance *utterance =
[AVSpeechUtterance speechUtteranceWithString:@"Wow, I have such a nice voice!"];
utterance.rate = AVSpeechUtteranceMaximumSpeechRate / 4.0f;
utterance.voice = [AVSpeechSynthesisVoice voiceWithLanguage:@"en-US"]; // defaults to your system language
[synthesizer speakUtterance:utterance];
</code></pre>

<h4>十八、使用了新的UIScreenEdgePanGestureRecognizer</h4>

<p>UIScreenEdgePanGestureRecognizer 继承自UIPanGestureRecognizer ，它可以让你从屏幕边界即可检测手势。</p>

<p>使用新的手势识别器很简单，见以下：</p>

<pre><code>UIScreenEdgePanGestureRecognizer *recognizer = [[UIScreenEdgePanGestureRecognizer alloc] initWithTarget:self action:@selector(handleScreenEdgeRecognizer:)];
recognizer.edges = UIRectEdgeLeft;
</code></pre>

<p>[self.view addGestureRecognizer:recognizer];
十九、使用UIScrollViewKeyboardDismissMode实现了Message app的行为
像Messages app一样在滚动的时候可以让键盘消失是一种非常好的体验。然而，将这种行为整合到你的app很难。幸运的是，苹果给UIScrollView添加了一个很好用的属性keyboardDismissMode，这样可以方便很多。</p>

<p>现在仅仅只需要在Storyboard中改变一个简单的属性，或者增加一行代码，你的app可以和办到和Messages app一样的事情了。</p>

<p>这个属性使用了新的UIScrollViewKeyboardDismissMode enum枚举类型。这个enum枚举类型可能的值如下：</p>

<pre><code>UIScrollViewKeyboardDismissModeNone        // the keyboard is not dismissed automatically when scrolling
UIScrollViewKeyboardDismissModeOnDrag      // dismisses the keyboard when a drag begins
UIScrollViewKeyboardDismissModeInteractive // the keyboard follows the dragging touch off screen, and may be
pulled upward again to cancel the dismiss
</code></pre>

<p>以下是让键盘可以在滚动的时候消失需要设置的属性：</p>

<p><img src="/images/banbenshipei005.jpg" title="Caption" ></p>

<h4>二十、使用Core Image来检测眨眼以及微笑</h4>

<p>iOS给Core Image增加了两种人脸检测功能：CIDetectorEyeBlink以及CIDetectorSmile。这也就是说你现在可以在照片中检测微笑以及眨眼。</p>

<p>以下是在app中使用它的方法：</p>

<pre><code>UIImage *image = [UIImage imageNamed:@"myImage"];
CIDetector *detector = [CIDetector detectorOfType:CIDetectorTypeFace
                                          context:nil
                                          options:@{CIDetectorAccuracy: CIDetectorAccuracyHigh}];

NSDictionary *options = @{ CIDetectorSmile: @YES, CIDetectorEyeBlink: @YES };

NSArray *features = [detector featuresInImage:image.CIImage options:options];

for (CIFaceFeature *feature in features) {
    NSLog(@"Bounds: %@", NSStringFromCGRect(feature.bounds));

if (feature.hasSmile) {
    NSLog(@"Nice smile!");
} else {
    NSLog(@"Why so serious?");

if (feature.leftEyeClosed || feature.rightEyeClosed) {
    NSLog(@"Open your eyes!");
}
</code></pre>

<p>}</p>

<h4>二十一、给UITextView增加了链接</h4>

<p>现在在iOS添加你自己的Twitter账户更加简单了，现在你可以给一个NSAttributedString增加链接了，然后当它被点击的时候唤起一个定制的action。</p>

<p>首先，创建一个NSAttributedString然后增加给它增加一个NSLinkAttributeName 属性，见以下：</p>

<pre><code>NSMutableAttributedString *attributedString = [[NSMutableAttributedString alloc] initWithString:@"This is an example by @marcelofabri_"];
[attributedString addAttribute:NSLinkAttributeName
                         value:@"username://marcelofabri_"
                         range:[[attributedString string] rangeOfString:@"@marcelofabri_"]];


NSDictionary *linkAttributes = @{NSForegroundColorAttributeName: [UIColor greenColor],
                                 NSUnderlineColorAttributeName: [UIColor lightGrayColor],
                                 NSUnderlineStyleAttributeName: @(NSUnderlinePatternSolid)};

// assume that textView is a UITextView previously created (either by code or Interface Builder)
textView.linkTextAttributes = linkAttributes; // customizes the appearance of links
textView.attributedText = attributedString;
textView.delegate = self;
</code></pre>

<p>这样就可以让链接在文本中显示。然而，你也可以控制当链接被点击的时候会发生什么，实现这个可以使用UITextViewDelegate协议的新的shouldInteractWithURL方法，就像这样：</p>

<pre><code>- (BOOL)textView:(UITextView *)textView shouldInteractWithURL:(NSURL *)URL inRange:(NSRange)characterRange {
    if ([[URL scheme] isEqualToString:@"username"]) {
        NSString *username = [URL host];
        // do something with this username
        // ...
        return NO;
    }
    return YES; // let the system open this URL
}
</code></pre>

<h2>iOS8新特性</h2>

<h4>一、UIAlertController对alert&amp;actionSheet的封装</h4>

<p>UIAlertController.h</p>

<p>提示框按钮的选择</p>

<pre><code>typedef NS_ENUM(NSInteger, UIAlertActionStyle) {

UIAlertActionStyleDefault = 0,

UIAlertActionStyleCancel,

UIAlertActionStyleDestructive

} NS_ENUM_AVAILABLE_IOS(8_0);
</code></pre>

<p>提示框的样式</p>

<pre><code>typedef NS_ENUM(NSInteger, UIAlertControllerStyle) {

UIAlertControllerStyleActionSheet = 0,

UIAlertControllerStyleAlert

} NS_ENUM_AVAILABLE_IOS(8_0);

NS_CLASS_AVAILABLE_IOS(8_0) @interface UIAlertAction : NSObject &lt;NSCopying&gt;
</code></pre>

<p>创建提示框按钮</p>

<pre><code>+ (instancetype)actionWithTitle:(NSString *)title style:(UIAlertActionStyle)style handler:(void (^)(UIAlertAction *action))handler;

@property (nonatomic, readonly) NSString *title;

@property (nonatomic, readonly) UIAlertActionStyle style;

@property (nonatomic, getter=isEnabled) BOOL enabled;

@end

NS_CLASS_AVAILABLE_IOS(8_0) @interface UIAlertController : UIViewController
</code></pre>

<p>创建提示框</p>

<pre><code>+ (instancetype)alertControllerWithTitle:(NSString *)title message:(NSString *)message preferredStyle:(UIAlertControllerStyle)preferredStyle;
</code></pre>

<p>添加按钮</p>

<pre><code>- (void)addAction:(UIAlertAction *)action;

@property (nonatomic, readonly) NSArray *actions;
</code></pre>

<p>添加文本输入框</p>

<pre><code>- (void)addTextFieldWithConfigurationHandler:(void (^)(UITextField *textField))configurationHandler;

@property (nonatomic, readonly) NSArray *textFields;

@property (nonatomic, copy) NSString *title;

@property (nonatomic, copy) NSString *message;

@property (nonatomic, readonly) UIAlertControllerStyle preferredStyle;
</code></pre>

<p>简单实用示例：</p>

<pre><code>// 1.创建提示框对象，默认是actionSheet效果
UIAlertController *alert = [UIAlertController alertControllerWithTitle:@"注意" message:@"我的呈现方式变了" preferredStyle:UIAlertControllerStyleAlert];

// 2.创建取消按钮并添加到提示框上
[alert addAction:[UIAlertAction actionWithTitle:@"取消" style:UIAlertActionStyleCancel handler:^(UIAlertAction *action) {

    NSLog(@"取消按钮被点击了");
}]];

// 3.呈现提示框
[self presentViewController:alert animated:YES completion:nil];
</code></pre>

<h4>二、UIPopoverController直接通过present方式呈现</h4>

<pre><code>UIViewController.h


typedef NS_ENUM(NSInteger, UIModalPresentationStyle) {

UIModalPresentationFullScreen = 0,

UIModalPresentationPageSheet NS_ENUM_AVAILABLE_IOS(3_2),

UIModalPresentationFormSheet NS_ENUM_AVAILABLE_IOS(3_2),

UIModalPresentationCurrentContext NS_ENUM_AVAILABLE_IOS(3_2),

UIModalPresentationCustom NS_ENUM_AVAILABLE_IOS(7_0),

UIModalPresentationOverFullScreen NS_ENUM_AVAILABLE_IOS(8_0),

UIModalPresentationOverCurrentContext NS_ENUM_AVAILABLE_IOS(8_0),

UIModalPresentationPopover NS_ENUM_AVAILABLE_IOS(8_0),

UIModalPresentationNone NS_ENUM_AVAILABLE_IOS(7_0) = -1,

};

@property (nonatomic,readonly) UIPopoverPresentationController *popoverPresentationController NS_AVAILABLE_IOS(8_0);
</code></pre>

<p>使用示例：</p>

<pre><code>// 1.创建内容控制器
UITableViewController *contentVc = [[UITableViewController alloc] init];

// 2.1 设置呈现方式
contentVc.modalPresentationStyle = UIModalPresentationPopover;

// 2.2设置在导航栏的左边按钮呈现
contentVc.popoverPresentationController.barButtonItem = self.navigationItem.leftBarButtonItem;

// 3.呈现
[self presentViewController:contentVc animated:YES completion:nil];
以前的方式：



// 1.创建内容控制器
UITableViewController *contentVc = [[UITableViewController alloc] init];

// 2.创建popover
UIPopoverController *popover = [[UIPopoverController alloc] initWithContentViewController:contentVc];

popover.popoverContentSize = CGSizeMake(100, 100);

// 3.呈现
[popover presentPopoverFromBarButtonItem:self.navigationItem.leftBarButtonItem permittedArrowDirections:UIPopoverArrowDirectionAny animated:YES];
</code></pre>

<h4>三、获取用户授权的用户隐私保护</h4>

<p>地图定位示例 ：</p>

<pre><code>// 导入定位框架
#import &lt;CoreLocation/CoreLocation.h&gt;

@interface ViewController ()&lt;CLLocationManagerDelegate&gt;

// 设置定位对象
@property(nonatomic,strong)CLLocationManager* maneger;

@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];

    // 当使用iOS8定位的时候需要请求用户授权，且在info.plist里添加字段NSLocationAlwaysUsageDescription 请求用户授权的描述
    // iOS7仅仅需要在info.plist里添加字段Privacy - Location Usage Description 请求用户授权的描述
    // 不需要再写下面的代码
    if (IOS8) {
        [self.maneger requestAlwaysAuthorization];//请求用户授权 
    }

    // 开启定位
    [self.maneger startUpdatingLocation];

}
</code></pre>

<h4>四、针对屏幕适配应运而生的size classes</h4>

<p>size classes是为了解决storyboard只能订制一种屏幕样式的问题，它不再是具体的尺寸，而是抽象尺寸通过宽/高 的compact、any、regular 组成了九种组合包含了所有苹果设备的尺寸。</p>

<h2>iOS9新特性</h2>

<h4>一、网络适配</h4>

<p>iOS9系统发送的网络请求将统一使用TLS 1.2 SSL。采用TLS 1.2 协议，目的是强制增强数据访问安全，而且系统Foundation框架下的相关网络请求，将不再默认使用HTTP等不安全的网络协议，而默认采用TLS 1.2。服务器因此需要更新，以解析相关数据。如不更新，可通过在 info.plist 中声明，倒退回不安全的网络请求。</p>

<p>什么是SSL/TLS？跟HTTP和HTTPS有什么关系？</p>

<p>跟往常一样，先说结论：</p>

<p>HTTP + SSL/TLS + TCP = HTTPS
TLS 是 SSL 新的别称。举个例子：</p>

<p>“TLS1.0”之于“SSL3.1”，犹“公元2015”之于“民国104”，或者是“一千克”之于“一公斤”，或者是“半斤”之于“八两”：称呼不同，但意思相同。</p>

<p>SSL 3.0版本之后的迭代版本被重新命名为TLS 1.0，也就是说：</p>

<p>TLS 1.0 ＝ SSL 3.1
所以他们是一个东西，我们平常也经常简单见到 “SSL/TLS” 这种说法。常用的是下面这些：</p>

<pre><code>SSL 2.0

SSL 3.0

TLS 1.0 (SSL 3.1)

TLS 1.1 (SSL 3.1)

TLS 1.2 (SSL 3.1)
</code></pre>

<p>那为什么标题是“使用HTTPS”而没有提及SSL和TLS什么事？ 要理解这个，要看下一个公式：</p>

<pre><code>HTTP + SSL/TLS + TCP = HTTPS
</code></pre>

<p>打个比方：如果原来的 HTTP 是塑料水管，容易被戳破；那么如今新设计的 HTTPS 就像是在原有的塑料水管之外，再包一层金属水管。一来，原有的塑料水管照样运行；二来，用金属加固了之后，不容易被戳破。</p>

<p>目前，应用最广泛的是TLS 1.0，接下来是SSL 3.0。但是，主流浏览器都已经实现了TLS 1.2的支持。Apple让你的HTTP采用SSL/TLS协议，就是让你从HTTP转到HTTPS。</p>

<p>以前的HTTP不是也能用吗？为什么要用SSL/TLS，闲得慌？！Apple是不是又在反人类？</p>

<p>不使用SSL/TLS的HTTP通信，就是不加密的通信！</p>

<p>所有信息明文传播，带来了三大风险：</p>

<pre><code>窃听风险（eavesdropping）：第三方可以获知通信内容。

篡改风险（tampering）：第三方可以修改通信内容。

冒充风险（pretending）：第三方可以冒充他人身份参与通信。
</code></pre>

<p>SSL/TLS协议是为了解决这三大风险而设计的，希望达到：</p>

<pre><code>所有信息都是加密传播，第三方无法窃听。

具有校验机制，一旦被篡改，通信双方会立刻发现。

配备身份证书，防止身份被冒充。

如何适配？---弱弱地问下：加班要多久？
</code></pre>

<p>正如文章开头所说：</p>

<p>TLS 1.2 协议 强制增强数据访问安全 系统 Foundation 框架下的相关网络请求，将不再默认使用 HTTP 等不安全的网络协议，而默认采用 TLS 1.2。服务器因此需要更新，以解析相关数据。如不更新，可通过在 Info.plist 中声明，倒退回不安全的网络请求。</p>

<ul>
<li><p>方案一：立即让公司的服务端升级使用TLS 1.2。</p></li>
<li><p>方案二：虽Apple不建议，但可通过在 Info.plist 中声明，倒退回不安全的网络请求依然能让App访问指定http，甚至任意的http。</p></li>
</ul>


<p>info.plist 配置中的XML源码如下所示:</p>

<p><img src="/images/banbenshipei006.jpg" title="Caption" ></p>

<p>上面是比较严谨的做法，指定了能访问哪些特定的HTTP。当然也有暴力的做法： 彻底倒退回不安全的HTTP网络请求，能任意进行HTTP请求，比如你在开发一款浏览器App，或者你想偷懒，或者后台想偷懒，或者公司不给你升级服务器。但目前Apple的官方文档并未提及如何在 info.plist 配置可以参考本文：<a href="http://blog.6ag.cn/1065.html">http://blog.6ag.cn/1065.html</a></p>

<h4>二、更灵活的后台定位</h4>

<p>如果不适配iOS9，就不能偷偷在后台定位。不过苹果将允许出现这种场景：</p>

<p>同一App中的多个location manager，一些只能在前台定位，另一些可在后台定位，并可随时开启或者关闭特定location manager的后台定位。</p>

<p>如何偷偷在后台定位：</p>

<pre><code>// 1. 实例化定位管理器
_locationManager = [[CLLocationManager alloc] init];

// 2. 设置代理
_locationManager.delegate = self;

// 3. 定位精度
[_locationManager setDesiredAccuracy:kCLLocationAccuracyBest];

// 4.请求用户权限：分为：?只在前台开启定位?在后台也可定位，
//注意：建议只请求?和?中的一个，如果两个权限都需要，只请求?即可，
//??这样的顺序，将导致bug：第一次启动程序后，系统将只请求?的权限，?的权限系统不会请求，只会在下一次启动应用时请求?
if ([[[UIDevice currentDevice] systemVersion] floatValue] &gt;= 8) {
    //[_locationManager requestWhenInUseAuthorization];//?只在前台开启定位
    [_locationManager requestAlwaysAuthorization];//?在后台也可定位
}

// 5.iOS9新特性：将允许出现这种场景：同一app中多个location manager：一些只能在前台定位，另一些可在后台定位（并可随时禁止其后台定位）。
if ([[[UIDevice currentDevice] systemVersion] floatValue] &gt;= 9) {
    _locationManager.allowsBackgroundLocationUpdates = YES;
}

// 6. 更新用户位置
[_locationManager startUpdatingLocation];
但是如果照着这种方式尝试，而没有配置info.plist，100%你的程序会崩溃掉，并报错：

*** Assertion failure in -[CLLocationManager setAllowsBackgroundLocationUpdates:], /BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreLocationFramework_Sim/CoreLocation-1808.1.5/Framework/CoreLocation/CLLocationManager.m:593
</code></pre>

<p>要将 info.plist 配置如下：</p>

<p><img src="/images/banbenshipei007.jpg" title="Caption" ></p>

<p>对应的 Info.plist 的XML源码是：</p>

<p><img src="/images/banbenshipei008.jpg" title="Caption" ></p>

<h4>三、Bitcode</h4>

<p>bitcode的理解应该是把程序编译成的一种过渡代码，然后苹果再把这个过渡代码编译成可执行的程序。bitcode也允许苹果在后期重新优化我们程序的二进制文件，有类似于App瘦身的思想。未来Watch应用须包含Bitcode，iOS不强制，但Xcode7默认会开启Bitcode。</p>

<p>用了xcode7的编译器编译之前没问题的项目可能会出现下列报错。</p>

<pre><code>XXXX’ does not contain bitcode. You must rebuild it with bitcode enabled (Xcode setting ENABLE_BITCODE), obtain an updated library from the vendor, or disable bitcode forthistarget. forarchitecture arm64
</code></pre>

<p>问题的原因是：某些第三方库还不支持bitcode。要不然是等待库的开发者升级了此项功能我们更新库，要不就是把这个bitcode禁用。禁用Bitcode，方法见下图：</p>

<p><img src="/images/banbenshipei009.jpg" title="Caption" ></p>

<h4>四、企业级分发</h4>

<p>iOS9之前，企业级分发十分方便：点击App出现“信任按钮”。</p>

<p>iOS9以后，企业级分发ipa包将遭到与Mac上dmg安装包一样的待遇。默认不能安装，也不再出现“信任按钮”，必须让用户进行gif图中的设置。</p>

<p><img src="/images/banbenshipei010.jpg" title="Caption" ></p>

<h4>五、URL scheme</h4>

<p>URL scheme一般使用的场景是应用程序有分享或跳其他平台授权的功能，分享或授权后再跳回来。在iOS8并没有做过多限制，在iOS9中，如果使用URL scheme必须在"info.plist"中将你要在外部调用的URL scheme列为白名单，否则不能使用。</p>

<pre><code>canOpenURL: failed forURL : "mqzone://qqapp"- error: "This app is not allowed to query for scheme mqzone"
</code></pre>

<p>具体的解决方案也是要在info.plist中设置 LSApplicationQueriesSchemes 类型为数组，下面添加所有你用到的scheme</p>

<p><img src="/images/banbenshipei011.jpg" title="Caption" ></p>

<p>推荐一篇博客: <a href="http://awkwardhare.com/post/121196006730/quick-take-on-ios-9-url-scheme-changes">http://awkwardhare.com/post/121196006730/quick-take-on-ios-9-url-scheme-changes</a></p>

<p>其中最关键的是以下部分：</p>

<pre><code>If you call the “canOpenURL” method on a URL that is not in your whitelist, it will return “NO”, even if there is an app installed that has registered to handle this scheme. A “This app is not allowed to query for scheme xxx” syslog entry will appear.

If you call the “openURL” method on a URL that is not in your whitelist, it will fail silently. A “This app is not allowed to query for scheme xxx” syslog entry will appear.
</code></pre>

<h4>六、新字体</h4>

<p>iOS8中，字体是Helvetica，中文的字体有点类似于“华文细黑”。只是苹果手机自带渲染，所以看上去可能比普通的华文细黑要美观。iOS9中，中文系统字体变为了专为中国设计的“苹方” 有点类似于一种word字体“幼圆”。字体有轻微的加粗效果，并且最关键的是字体间隙变大了！</p>

<p>所以很多原本写死了width的label可能会出现“&hellip;”的情况。</p>

<p><img src="/images/banbenshipei012.jpg" title="Caption" ></p>

<p><img src="/images/banbenshipei013.jpg" title="Caption" ></p>

<p>上面这两张图也可以直观的看出同一个界面，同一个label的变化。</p>

<p>所以为了在界面显示上不出错，就算是固定长度的文字也还是建议使用sizetofit 或者ios向上取整 ceilf() 或者提前计算。</p>

<pre><code>CGSize size = [title sizeWithAttributes:@{NSFontAttributeName: [UIFont systemFontOfSize:14.0f]}];
CGSize adjustedSize = CGSizeMake(ceilf(size.width), ceilf(size.height));
</code></pre>

<h4>七、tableview</h4>

<p>虽然现在的iOS9已经推送正式版了，但是iOS9使用时还是会感觉到App比以前更加卡顿了，tableView拖动时卡顿显示的最为明显。 并且之前遇到一个bug，原本好的项目用xcode7一编译，tableView刷新出了问题 ，[tableView reloadData]无效，有一行cell明明改变了但是刷新不出来。 感觉可能是这个方法和某种新加的特性冲突了，猜测可能是reloadData的操作被推迟到下一个RunLoop执行最终失效。</p>

<p>解决的方法是，注释[tableView reloadData]，改用局部刷新，问题居然就解决了。</p>

<p>[self.tableView reloadSections:[NSIndexSet indexSetWithIndex:0] withRowAnimation:UITableViewRowAnimationNone];</p>

<h4>八、iPad适配Slide Over 和 Split View</h4>

<p>iPad适配Slide Over 和 Split View，若想适配multi tasking特性，唯一的建议：</p>

<p>弃纯代码，改用storyboard、xib，纵观苹果WWDC所有Demo均是如此。</p>

<pre><code>Mysteries of Auto Layout, Part 1
What's New in Storyboards
Implementing UI Designs in Interface Builder
Getting Started with Multitasking on iPad in iOS 9
Optimizing Your App for Multitasking on iPad in iOS
</code></pre>

<p>本文部分内容来自网络整理，如有错误请留言指出，谢谢！</p>
</div>
  
  




| <a href="/blog/2015/11/28/iosban-ben-gua-pei-wen-ti-(6,7,8,9)/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/11/28/blockshen-jiu/">Block深究</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><h2>目录</h2>

<ul>
<li><h5>什么是block？</h5>

<ul>
<li>block编译转换结构</li>
<li>block实际结构</li>
</ul>
</li>
<li><h5>block的类型</h5>

<ul>
<li>NSConcreteGlobalBlock和NSConcreteStackBlock</li>
<li>NSConcreteMallocBlock</li>
</ul>
</li>
<li><h5>捕捉变量对block结构的影响</h5>

<ul>
<li>局部变量</li>
<li>全局变量</li>
<li>局部静态变量</li>
<li>__block修饰的变量</li>
<li>self隐式循环引用</li>
</ul>
</li>
<li><h5>不同类型block的复制</h5>

<ul>
<li>栈block</li>
<li>堆block</li>
<li>全局block</li>
</ul>
</li>
<li><h5>block辅助函数</h5>

<ul>
<li>__block修饰的基本类型的辅助函数</li>
<li>对象的辅助函数</li>
</ul>
</li>
<li><h5>ARC中block的工作</h5>

<ul>
<li>block试验</li>
<li>block作为参数传递</li>
<li>block作为返回值</li>
<li>block属性</li>
</ul>
</li>
</ul>


<h3>参考博文</h3>

<p>最近看了一些block的资料，并动手做了一些实践，摘录并添加了一些结论。</p>

<h3>什么是block？</h3>

<p>首先，看一个极简的block：</p>

<pre><code>    int main(int argc, const char * argv[]) {
        @autoreleasepool {

            ^{ };
        }
        return 0;
    }
</code></pre>

<h5>block编译转换结构</h5>

<p>对其执行clang -rewrite-objc编译转换成C++实现，得到以下代码：</p>

<pre><code>    struct __block_impl {
        void *isa;
        int Flags;
        int Reserved;
        void *FuncPtr;
    };

    struct __main_block_impl_0 {
      struct __block_impl impl;
      struct __main_block_desc_0* Desc;
      __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) {
        impl.isa = &amp;_NSConcreteStackBlock;
        impl.Flags = flags;
        impl.FuncPtr = fp;
        Desc = desc;
      }
    };
    static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
    }

    static struct __main_block_desc_0 {
      size_t reserved;
      size_t Block_size;
    } __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};
    int main(int argc, const char * argv[]) {
        /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool;
            (void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA);
        }
        return 0;
    }
</code></pre>

<p>不难看出其中的<strong>main_block_impl_0就是block的一个C++的实现(最后面的_0代表是main中的第几个block)，也就是说也是一个结构体。
其中</strong>block_impl的定义如下：</p>

<pre><code>struct __block_impl {
  void *isa;
  int Flags;
  int Reserved;
  void *FuncPtr;
};
</code></pre>

<p>其结构体成员如下：</p>

<ul>
<li>isa，指向所属类的指针，也就是block的类型</li>
<li>flags，标志变量，在实现block的内部操作时会用到</li>
<li>Reserved，保留变量</li>
<li>FuncPtr，block执行时调用的函数指针</li>
<li>可以看出，它包含了isa指针（包含isa指针的皆为对象），也就是说block也是一个对象* (runtime里面，对象和类都是用结构体表示)。</li>
</ul>


<p>__main_block_desc_0的定义如下：</p>

<pre><code>    static struct __main_block_desc_0 {
      size_t reserved;
      size_t Block_size;
    } __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};
</code></pre>

<p>其结构成员含义如下：</p>

<ul>
<li>reserved：保留字段</li>
<li>Block_size：block大小(sizeof(struct __main_block_impl_0))</li>
<li>以上代码在定义<strong>main_block_desc_0结构体时，同时创建了</strong>main_block_desc_0_DATA，并给它赋值，以供在main函数中对__main_block_impl_0进行初始化。</li>
</ul>


<p>__main_block_impl_0定义了显式的构造函数，其函数体如下：</p>

<pre><code>  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) {
    impl.isa = &amp;_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
</code></pre>

<p>可以看出，</p>

<ul>
<li><em>_main_block_impl_0的isa指针指向了</em>NSConcreteStackBlock，</li>
<li>从main函数中看， <strong>main_block_impl_0的FuncPtr指向了函数</strong>main_block_func_0</li>
<li><strong>main_block_impl_0的Desc也指向了定义</strong>main_block_desc_0时就创建的__main_block_desc_0_DATA，其中纪录了block结构体大小等信息。</li>
<li>以上就是根据编译转换的结果，对一个简单block的解析，后面会将block操作不同类型的外部变量，对block结构的影响进行相应的说明。</li>
</ul>


<h5>block实际结构</h5>

<p>接下来观察下Block_private.h文件中对block的相关结构体的真实定义：</p>

<pre><code>/* Revised new layout. */
struct Block_descriptor {
    unsigned long int reserved;
    unsigned long int size;
    void (*copy)(void *dst, void *src);
    void (*dispose)(void *);
};


struct Block_layout {
    void *isa;
    int flags;
    int reserved;
    void (*invoke)(void *, ...);
    struct Block_descriptor *descriptor;
    /* Imported variables. */
};
</code></pre>

<p>有了上文对编译转换的分析，这里只针对略微不同的成员进行分析：</p>

<p>invoke，同上文的FuncPtr，block执行时调用的函数指针，block定义时内部的执行代码都在这个函数中
Block_descriptor，block的详细描述</p>

<ul>
<li>copy/dispose，辅助拷贝/销毁函数，处理block范围外的变量时使用</li>
<li>总体来说，block就是一个里面存储了指向函数体中包含定义block时的代码块的函数指针，以及block外部上下文变量等信息的结构体。</li>
</ul>


<h3>block的类型</h3>

<p>block的常见类型有3种：</p>

<ul>
<li>_NSConcreteGlobalBlock（全局）</li>
<li>_NSConcreteStackBlock（栈）</li>
<li>_NSConcreteMallocBlock（堆）</li>
</ul>


<p>附上APUE的进程虚拟内存段分布图：</p>

<p><img src="/images/block001.png" title="Caption" ></p>

<p>进程虚拟内存空间分布</p>

<ul>
<li>其中前2种在Block.h种声明，后1种在Block_private.h中声明，所以最后1种基本不会在源码中出现。</li>
<li>由于无法直接创建_NSConcreteMallocBlock类型的block，所以这里只对前面2种进行手动创建分析，最后1种通过源代码分析。</li>
</ul>


<h5>NSConcreteGlobalBlock和NSConcreteStackBlock</h5>

<p>首先，根据前面两种类型，编写以下代码：</p>

<pre><code>void (^globalBlock)() = ^{

};

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        void (^stackBlock1)() = ^{

        };
    }
    return 0;
}
</code></pre>

<p>对其进行编译转换后得到以下缩略代码：</p>

<pre><code>// globalBlock
struct __globalBlock_block_impl_0 {
  struct __block_impl impl;
  struct __globalBlock_block_desc_0* Desc;
  __globalBlock_block_impl_0(void *fp, struct __globalBlock_block_desc_0 *desc, int flags=0) {
    impl.isa = &amp;_NSConcreteGlobalBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};
...

// stackBlock
struct __main_block_impl_0 {
  struct __block_impl impl;
  struct __main_block_desc_0* Desc;
  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) {
    impl.isa = &amp;_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};
...
int main(int argc, const char * argv[]) {
    /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool;
        void (*stackBlock)() = (void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA);
    }
    return 0;
}
</code></pre>

<p>可以看出globalBlock的isa指向了<em>NSConcreteGlobalBlock，即在全局区域创建，编译时具体的代码就已经确定在上图中的代码段中了，block变量存储在全局数据存储区；stackBlock的isa指向了</em>NSConcreteStackBlock，即在栈区创建。</p>

<h5>NSConcreteMallocBlock</h5>

<ul>
<li><p>接下来是在堆中的block，堆中的block无法直接创建，其需要由<em>NSConcreteStackBlock类型的block拷贝而来(也就是说block需要执行copy之后才能存放到堆中)。由于block的拷贝最终都会调用</em>Block_copy_internal函数，所以观察这个函数就可以知道堆中block是如何被创建的了：</p>

<pre><code>  static void *_Block_copy_internal(const void *arg, const int flags) {
      struct Block_layout *aBlock;
      ...
      aBlock = (struct Block_layout *)arg;
      ...
      // Its a stack block.  Make a copy.
      if (!isGC) {
          // 申请block的堆内存
          struct Block_layout *result = malloc(aBlock-&gt;descriptor-&gt;size);
          if (!result) return (void *)0;
          // 拷贝栈中block到刚申请的堆内存中
          memmove(result, aBlock, aBlock-&gt;descriptor-&gt;size); // bitcopy first
          // reset refcount
          result-&gt;flags &amp;= ~(BLOCK_REFCOUNT_MASK);    // XXX not needed
          result-&gt;flags |= BLOCK_NEEDS_FREE | 1;
          // 改变isa指向_NSConcreteMallocBlock，即堆block类型
          result-&gt;isa = _NSConcreteMallocBlock;
          if (result-&gt;flags &amp; BLOCK_HAS_COPY_DISPOSE) {
              //printf("calling block copy helper %p(%p, %p)...\n", aBlock-&gt;descriptor-&gt;copy, result, aBlock);
              (*aBlock-&gt;descriptor-&gt;copy)(result, aBlock); // do fixup
          }
          return result;
      }
      else {
          ...
      }
  }
</code></pre>

<p>从以上代码以及注释可以很清楚的看出，函数通过memmove将栈中的block的内容拷贝到了堆中，并使isa指向了_NSConcreteMallocBlock。
block主要的一些学问就出在栈中block向堆中block的转移过程中了。</p></li>
</ul>


<p>捕捉变量对block结构的影响
接下来会编译转换捕捉不同变量类型的block，以对比它们的区别。</p>

<h5>局部变量</h5>

<p>前：</p>

<pre><code>- (void)test
{
    int a;
    ^{a;};
}
</code></pre>

<p>后：</p>

<pre><code>struct __Person__test_block_impl_0 {
  struct __block_impl impl;
  struct __Person__test_block_desc_0* Desc;
  int a;
  // a(_a)是构造函数的参数列表初始化形式，相当于a = _a。从_I_Person_test看，传入的就是a
  __Person__test_block_impl_0(void *fp, struct __Person__test_block_desc_0 *desc, int _a, int flags=0) : a(_a) {
    impl.isa = &amp;_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};
static void __Person__test_block_func_0(struct __Person__test_block_impl_0 *__cself) {
  int a = __cself-&gt;a; // bound by copy
a;}

static struct __Person__test_block_desc_0 {
  size_t reserved;
  size_t Block_size;
} __Person__test_block_desc_0_DATA = { 0, sizeof(struct __Person__test_block_impl_0)};

static void _I_Person_test(Person * self, SEL _cmd) {
    int a;
    (void (*)())&amp;__Person__test_block_impl_0((void *)__Person__test_block_func_0, &amp;__Person__test_block_desc_0_DATA, a);
}
</code></pre>

<p>可以看到，block相对于文章开头增加了一个int类型的成员变量，他就是用来存储外部变量a的。可以看出，这次拷贝只是一次值传递。并且当我们想在block中进行以下操作时，将会发生错误</p>

<pre><code>^{a = 10;};
</code></pre>

<p>编译器会提示</p>

<p><img src="/images/block002.png" title="Caption" ></p>

<p>错误提示
。因为_I_Person_test函数中的a和Persontest_block_func_0函数中的a并没有在同一个作用域，所以在block对a进行赋值是没有意义的，所以编译器给出了错误。我们可以通过地址传递来消除以上错误：</p>

<pre><code>- (void)test
{
    int a = 0;
    // 利用指针p存储a的地址
    int *p = &amp;a;

    ^{
        // 通过a的地址设置a的值
        *p = 10;
    };
}
</code></pre>

<p>但是变量a的生命周期是和方法test的栈相关联的，当test运行结束，栈随之销毁，那么变量a就会被销毁，p也就成为了野指针。如果block是作为参数或者返回值，这些类型都是跨栈的，也就是说再次调用会造成野指针错误。</p>

<h5>全局变量</h5>

<p>前：</p>

<pre><code>// 全局静态
static int a;
// 全局
int b;
- (void)test
{

    ^{
        a = 10;
        b = 10;
    };
}
</code></pre>

<p>后：</p>

<pre><code>static int a;
int b;

struct __Person__test_block_impl_0 {
  struct __block_impl impl;
  struct __Person__test_block_desc_0* Desc;
  __Person__test_block_impl_0(void *fp, struct __Person__test_block_desc_0 *desc, int flags=0) {
    impl.isa = &amp;_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};
static void __Person__test_block_func_0(struct __Person__test_block_impl_0 *__cself) {

        a = 10;
        b = 10;
    }

static struct __Person__test_block_desc_0 {
  size_t reserved;
  size_t Block_size;
} __Person__test_block_desc_0_DATA = { 0, sizeof(struct __Person__test_block_impl_0)};

static void _I_Person_test(Person * self, SEL _cmd) {

    (void (*)())&amp;__Person__test_block_impl_0((void *)__Person__test_block_func_0, &amp;__Person__test_block_desc_0_DATA);
}
</code></pre>

<p>可以看出，因为全局变量都是在静态数据存储区，在程序结束前不会被销毁，所以block直接访问了对应的变量，而没有在Persontest_block_impl_0结构体中给变量预留位置。</p>

<h5>局部静态变量</h5>

<p>前</p>

<pre><code>- (void)test
{
    static int a;
    ^{
        a = 10;
    };
}
</code></pre>

<p>后：</p>

<pre><code>struct __Person__test_block_impl_0 {
  struct __block_impl impl;
  struct __Person__test_block_desc_0* Desc;
  int *a;
  __Person__test_block_impl_0(void *fp, struct __Person__test_block_desc_0 *desc, int *_a, int flags=0) : a(_a) {
    impl.isa = &amp;_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};
static void __Person__test_block_func_0(struct __Person__test_block_impl_0 *__cself) {
  int *a = __cself-&gt;a; // bound by copy
        // 这里通过局部静态变量a的地址来对其进行修改
        (*a) = 10;
    }

static struct __Person__test_block_desc_0 {
  size_t reserved;
  size_t Block_size;
} __Person__test_block_desc_0_DATA = { 0, sizeof(struct __Person__test_block_impl_0)};

static void _I_Person_test(Person * self, SEL _cmd) {
    static int a;
    // 传入a的地址
    (void (*)())&amp;__Person__test_block_impl_0((void *)__Person__test_block_func_0, &amp;__Person__test_block_desc_0_DATA, &amp;a);
}
</code></pre>

<p>需要注意一点的是静态局部变量是存储在静态数据存储区域的，也就是和程序拥有一样的生命周期，也就是说在程序运行时，都能够保证block访问到一个有效的变量。但是其作用范围还是局限于定义它的函数中，所以只能在block通过静态局部变量的地址来进行访问。
关于变量的存储我原来的这篇博客有提及：c语言臆想&ndash;全局&mdash;局部变量</p>

<h5>__block修饰的变量</h5>

<p>前：</p>

<pre><code>- (void)test
{
   __block int a;
    ^{
        a = 10;
    };
}
</code></pre>

<p>后：</p>

<pre><code>struct __Block_byref_a_0 {
  void *__isa;
__Block_byref_a_0 *__forwarding;
 int __flags;
 int __size;
 int a;
};

struct __Person__test_block_impl_0 {
  struct __block_impl impl;
  struct __Person__test_block_desc_0* Desc;
  __Block_byref_a_0 *a; // by ref
  __Person__test_block_impl_0(void *fp, struct __Person__test_block_desc_0 *desc, __Block_byref_a_0 *_a, int flags=0) : a(_a-&gt;__forwarding) {
    impl.isa = &amp;_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};
static void __Person__test_block_func_0(struct __Person__test_block_impl_0 *__cself) {
  __Block_byref_a_0 *a = __cself-&gt;a; // bound by ref
        // 注意，这里的_forwarding用来保证操作的始终是堆中的拷贝a，而不是栈中的a
        (a-&gt;__forwarding-&gt;a) = 10;
    }
static void __Person__test_block_copy_0(struct __Person__test_block_impl_0*dst, struct __Person__test_block_impl_0*src) {_Block_object_assign((void*)&amp;dst-&gt;a, (void*)src-&gt;a, 8/*BLOCK_FIELD_IS_BYREF*/);}

static void __Person__test_block_dispose_0(struct __Person__test_block_impl_0*src) {_Block_object_dispose((void*)src-&gt;a, 8/*BLOCK_FIELD_IS_BYREF*/);}

static struct __Person__test_block_desc_0 {
  size_t reserved;
  size_t Block_size;
  void (*copy)(struct __Person__test_block_impl_0*, struct __Person__test_block_impl_0*);
  void (*dispose)(struct __Person__test_block_impl_0*);
} __Person__test_block_desc_0_DATA = { 0, sizeof(struct __Person__test_block_impl_0), __Person__test_block_copy_0, __Person__test_block_dispose_0};

static void _I_Person_test(Person * self, SEL _cmd) {
    // __block将a包装成了一个对象
   __attribute__((__blocks__(byref))) __Block_byref_a_0 a = {(void*)0,(__Block_byref_a_0 *)&amp;a, 0, sizeof(__Block_byref_a_0)};
;
    (void (*)())&amp;__Person__test_block_impl_0((void *)__Person__test_block_func_0, &amp;__Person__test_block_desc_0_DATA, (__Block_byref_a_0 *)&amp;a, 570425344);
}
</code></pre>

<p>可以看到，对比上面的结果，明显多了<strong>Block_byref_a_0结构体，这个结构体中含有isa指针，所以也是一个对象，它是用来包装局部变量a的。当block被copy到堆中时，</strong>Person<strong>test_block_impl_0的拷贝辅助函数</strong>Person<strong>test_block_copy_0会将</strong>Block_byref_a_0拷贝至堆中，所以即使局部变量所在堆被销毁，block依然能对堆中的局部变量进行操作。其中<strong>Block_byref_a_0成员指针</strong>forwarding用来指向它在堆中的拷贝，其依据源码如下：</p>

<pre><code>static void _Block_byref_assign_copy(void *dest, const void *arg, const int flags) {
    struct Block_byref **destp = (struct Block_byref **)dest;
    struct Block_byref *src = (struct Block_byref *)arg;

    ...
    // 堆中拷贝的forwarding指向它自己
    copy-&gt;forwarding = copy; // patch heap copy to point to itself (skip write-barrier)
    // 栈中的forwarding指向堆中的拷贝
    src-&gt;forwarding = copy;  // patch stack to point to heap copy
    ...
}
</code></pre>

<p>这样做是为了保证操作的值始终是堆中的拷贝，而不是栈中的值。（处理在局部变量所在栈还没销毁，就调用block来改变局部变量值的情况，如果没有__forwarding指针，则修改无效）
至于block如何实现对局部变量的拷贝，下面会详细说明。</p>

<h5>self隐式循环引用</h5>

<p>前：</p>

<pre><code>@implementation Person
{
    int _a;
    void (^_block)();
}
- (void)test
{
  void (^_block)() = ^{
        _a = 10;
    };
}

@end
</code></pre>

<p>后：</p>

<pre><code>struct __Person__test_block_impl_0 {
  struct __block_impl impl;
  struct __Person__test_block_desc_0* Desc;
  // 可以看到，block强引用了self
  Person *self;
  __Person__test_block_impl_0(void *fp, struct __Person__test_block_desc_0 *desc, Person *_self, int flags=0) : self(_self) {
    impl.isa = &amp;_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};
static void __Person__test_block_func_0(struct __Person__test_block_impl_0 *__cself) {
  Person *self = __cself-&gt;self; // bound by copy

        (*(int *)((char *)self + OBJC_IVAR_$_Person$_a)) = 10;
    }
static void __Person__test_block_copy_0(struct __Person__test_block_impl_0*dst, struct __Person__test_block_impl_0*src) {_Block_object_assign((void*)&amp;dst-&gt;self, (void*)src-&gt;self, 3/*BLOCK_FIELD_IS_OBJECT*/);}

static void __Person__test_block_dispose_0(struct __Person__test_block_impl_0*src) {_Block_object_dispose((void*)src-&gt;self, 3/*BLOCK_FIELD_IS_OBJECT*/);}

static struct __Person__test_block_desc_0 {
  size_t reserved;
  size_t Block_size;
  void (*copy)(struct __Person__test_block_impl_0*, struct __Person__test_block_impl_0*);
  void (*dispose)(struct __Person__test_block_impl_0*);
} __Person__test_block_desc_0_DATA = { 0, sizeof(struct __Person__test_block_impl_0), __Person__test_block_copy_0, __Person__test_block_dispose_0};

static void _I_Person_test(Person * self, SEL _cmd) {
  void (*_block)() = (void (*)())&amp;__Person__test_block_impl_0((void *)__Person__test_block_func_0, &amp;__Person__test_block_desc_0_DATA, self, 570425344);
}
</code></pre>

<p>如果在编译转换前，将<em>a改成self.a，能很明显地看出是产生了循环引用(self强引用block，block强引用self)。那么使用</em>a呢？经过编译转换后，依然可以在<strong>Person</strong>test_block_impl_0看见self的身影。且在函数<em>I_Person_test中，传入的参数也是self。通过以下语句，可以看出，不管是用什么形式访问实例变量，最终都会转换成self+变量内存偏移的形式。所以在上面例子中使用</em>a也会造成循环引用。</p>

<pre><code>static void __Person__test_block_func_0(struct __Person__test_block_impl_0 *__cself) {
  Person *self = __cself-&gt;self; // bound by copy
        // self＋实例变量a的偏移值
        (*(int *)((char *)self + OBJC_IVAR_$_Person$_a)) = 10;
    }
</code></pre>

<h3>不同类型block的复制</h3>

<p>block的复制代码在_Block_copy_internal函数中。</p>

<h5>栈block</h5>

<p>从以下代码可以看出，栈block的复制不仅仅复制了其内容，还添加了一些额外的东西</p>

<pre><code>* 1、往flags中并入了BLOCK_NEEDS_FREE（这个标志表明block需要释放，在release以及再次拷贝时会用到）

* 2、如果有辅助copy函数（BLOCK_HAS_COPY_DISPOSE），那么就调用（这个辅助copy函数是用来拷贝block捕获的变量的）

struct Block_layout *result = malloc(aBlock-&gt;descriptor-&gt;size);
if (!result) return (void *)0;
  memmove(result, aBlock, aBlock-&gt;descriptor-&gt;size); // bitcopy first
// reset refcount
result-&gt;flags &amp;= ~(BLOCK_REFCOUNT_MASK);    // XXX not needed
result-&gt;flags |= BLOCK_NEEDS_FREE | 1;
result-&gt;isa = _NSConcreteMallocBlock;
if (result-&gt;flags &amp; BLOCK_HAS_COPY_DISPOSE) {
      //printf("calling block copy helper %p(%p, %p)...\n", aBlock-&gt;descriptor-&gt;copy, result, aBlock);
      (*aBlock-&gt;descriptor-&gt;copy)(result, aBlock); // do fixup
  }
  return result;
</code></pre>

<h5>堆block</h5>

<p>从以下代码看出，如果block的flags中有BLOCK_NEEDS_FREE标志（block从栈中拷贝到堆时添加的标志），就执行latching_incr_int操作，其功能就是让block的引用计数加1。所以堆中block的拷贝只是单纯地改变了引用计数</p>

<pre><code>  ...
  if (aBlock-&gt;flags &amp; BLOCK_NEEDS_FREE) {
        // latches on high
        latching_incr_int(&amp;aBlock-&gt;flags);
        return aBlock;
    }
  ...
</code></pre>

<h5>全局block</h5>

<p>从以下代码看出，对于全局block，函数没有做任何操作，直接返回了传入的block</p>

<pre><code>else if (aBlock-&gt;flags &amp; BLOCK_IS_GLOBAL) {
      return aBlock;
}
</code></pre>

<h3>block辅助函数</h3>

<ul>
<li>上文提及到了block辅助copy与dispose处理函数，这里分析下这两个函数的内部实现。在捕* 获变量为__block修饰的基本类型，或者为对象时，block才会有这两个辅助函数。</li>
<li>block捕捉变量拷贝函数为<em>Block_object_assign。在调用复制block的函数</em>Block_copy_internal时，会根据block有无辅助函数来对捕捉变量拷贝函数<em>Block_object_assign进行调用。而在</em>Block_object_assign函数中，也会判断捕捉变量包装而成的对象(Block_byref结构体)是否有辅助函数，来进行调用。</li>
</ul>


<h5>__block修饰的基本类型的辅助函数</h5>

<p>编写以下代码：</p>

<pre><code>typedef void(^Block)();
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        __block int a;
        Block block = ^ {
            a;
        };
}
</code></pre>

<p>转换成C++代码后：</p>

<pre><code>typedef void(*Block)();
// __block int a
struct __Block_byref_a_0 {
  void *__isa;
__Block_byref_a_0 *__forwarding;
 int __flags;
 int __size;
 int a;
};

// block
struct __main_block_impl_0 {
  struct __block_impl impl;
  struct __main_block_desc_0* Desc;
  __Block_byref_a_0 *a; // by ref
  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_a_0 *_a, int flags=0) : a(_a-&gt;__forwarding) {
    impl.isa = &amp;_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};

// block函数体
static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
  __Block_byref_a_0 *a = __cself-&gt;a; // bound by ref

            (a-&gt;__forwarding-&gt;a);
        }
// 辅助copy函数
static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {_Block_object_assign((void*)&amp;dst-&gt;a, (void*)src-&gt;a, 8/*BLOCK_FIELD_IS_BYREF*/);}

// 辅助dispose函数
static void __main_block_dispose_0(struct __main_block_impl_0*src) {_Block_object_dispose((void*)src-&gt;a, 8/*BLOCK_FIELD_IS_BYREF*/);}

static struct __main_block_desc_0 {
  size_t reserved;
  size_t Block_size;
  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);
  void (*dispose)(struct __main_block_impl_0*);
} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0};
int main(int argc, const char * argv[]) {
    /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool;
        // 这里创建了，并将a的flags设置为0
        __attribute__((__blocks__(byref))) __Block_byref_a_0 a = {(void*)0,(__Block_byref_a_0 *)&amp;a, 0, sizeof(__Block_byref_a_0)};
;
        Block block = (void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_a_0 *)&amp;a, 570425344);
    }
    return 0;
}
</code></pre>

<p>从上面代码中，被<strong>block修饰的a变量变为了</strong>Block_byref_a_0类型，根据这个格式，从源码中查看得到相似的定义：</p>

<pre><code>struct Block_byref {
    void *isa;
    struct Block_byref *forwarding;
    int flags; /* refcount; */
    int size;
    void (*byref_keep)(struct Block_byref *dst, struct Block_byref *src);
    void (*byref_destroy)(struct Block_byref *);
    /* long shared[0]; */
};

// 做下对比
struct __Block_byref_a_0 {
  void *__isa;
__Block_byref_a_0 *__forwarding;
 int __flags;
 int __size;
 int a;
};

// flags/_flags类型
enum {
        /* See function implementation for a more complete description of these fields and combinations */
        // 是一个对象
        BLOCK_FIELD_IS_OBJECT   =  3,  /* id, NSObject, __attribute__((NSObject)), block, ... */
        // 是一个block
        BLOCK_FIELD_IS_BLOCK    =  7,  /* a block variable */
        // 被__block修饰的变量
        BLOCK_FIELD_IS_BYREF    =  8,  /* the on stack structure holding the __block variable */
        // 被__weak修饰的变量，只能被辅助copy函数使用
        BLOCK_FIELD_IS_WEAK     = 16,  /* declared __weak, only used in byref copy helpers */
        // block辅助函数调用（告诉内部实现不要进行retain或者copy）
        BLOCK_BYREF_CALLER      = 128  /* called from __block (byref) copy/dispose support routines. */
    };
</code></pre>

<p>可以看出，__block将原来的基本类型包装成了对象。因为以上两个结构体的前4个成员的类型都是一样的，内存空间排列一致，所以可以进行以下操作：</p>

<pre><code>// 转换成C++代码
static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {_Block_object_assign((void*)&amp;dst-&gt;a, (void*)src-&gt;a, 8/*BLOCK_FIELD_IS_BYREF*/);}

// _Block_object_assign源码
void _Block_object_assign(void *destAddr, const void *object, const int flags) {
...
    else if ((flags &amp; BLOCK_FIELD_IS_BYREF) == BLOCK_FIELD_IS_BYREF)  {
        // copying a __block reference from the stack Block to the heap
        // flags will indicate if it holds a __weak reference and needs a special isa
        _Block_byref_assign_copy(destAddr, object, flags);
    }
...
}

// _Block_byref_assign_copy源码
static void _Block_byref_assign_copy(void *dest, const void *arg, const int flags) {
    // 这里因为前面4个成员的内存分布一样，所以直接转换后，使用Block_byref的成员变量名，能访问到__Block_byref_a_0的前面4个成员
    struct Block_byref **destp = (struct Block_byref **)dest;
    struct Block_byref *src = (struct Block_byref *)arg;
...
    else if ((src-&gt;forwarding-&gt;flags &amp; BLOCK_REFCOUNT_MASK) == 0) {
        // 从main函数对__Block_byref_a_0的初始化，可以看到初始化时将flags赋值为0
        // 这里表示第一次拷贝，会进行复制操作，并修改原来flags的值
        // static int _Byref_flag_initial_value = BLOCK_NEEDS_FREE | 2;
        // 可以看出，复制后，会并入BLOCK_NEEDS_FREE，后面的2是block的初始引用计数
        ...
        copy-&gt;flags = src-&gt;flags | _Byref_flag_initial_value;
        ...
    }
    // 已经拷贝到堆了，只增加引用计数
    else if ((src-&gt;forwarding-&gt;flags &amp; BLOCK_NEEDS_FREE) == BLOCK_NEEDS_FREE) {
        latching_incr_int(&amp;src-&gt;forwarding-&gt;flags);
    }
    // 普通的赋值，里面最底层就*destptr = value;这句表达式
    _Block_assign(src-&gt;forwarding, (void **)destp);
}
</code></pre>

<p>主要操作都在代码注释中了，总体来说，__block修饰的基本类型会被包装为对象，并且只在最初block拷贝时复制一次，后面的拷贝只会增加这个捕获变量的引用计数。</p>

<h5>对象的辅助函数</h5>

<p>没有__block修饰</p>

<pre><code>typedef void(^Block)();
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        NSObject *a = [[NSObject alloc] init];
        Block block = ^ {
            a;
        };
    }
    return 0;
}
</code></pre>

<p>首先，在没有__block修饰时，对象编译转换的结果如下，删除了一些变化不大的代码：</p>

<pre><code>static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
  NSObject *a = __cself-&gt;a; // bound by copy
            a;
        }
static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {_Block_object_assign((void*)&amp;dst-&gt;a, (void*)src-&gt;a, 3/*BLOCK_FIELD_IS_OBJECT*/);}

static void __main_block_dispose_0(struct __main_block_impl_0*src) {_Block_object_dispose((void*)src-&gt;a, 3/*BLOCK_FIELD_IS_OBJECT*/);}

static struct __main_block_desc_0 {
  size_t reserved;
  size_t Block_size;
  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);
  void (*dispose)(struct __main_block_impl_0*);
} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0),
</code></pre>

<p>对象在没有<strong>block修饰时，并没有产生</strong>Block_byref_a_0结构体，只是将标志位修改为BLOCK_FIELD_IS_OBJECT。而在_Block_object_assign中对应的判断分支代码如下：</p>

<pre><code>else if ((flags &amp; BLOCK_FIELD_IS_OBJECT) == BLOCK_FIELD_IS_OBJECT) {
    _Block_retain_object(object);
    _Block_assign((void *)object, destAddr);
}
</code></pre>

<p>可以看到，block复制时，会retain捕捉对象，以增加其引用计数。</p>

<p>有__block修饰</p>

<pre><code>typedef void(^Block)();
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        __block NSObject *a = [[NSObject alloc] init];
        Block block = ^ {
            a;
        };
    }
    return 0;
}
</code></pre>

<p>在这种情况下，编译转换的部分结果如下：</p>

<pre><code>struct __Block_byref_a_0 {
  void *__isa;
__Block_byref_a_0 *__forwarding;
 int __flags;
 int __size;
 void (*__Block_byref_id_object_copy)(void*, void*);
 void (*__Block_byref_id_object_dispose)(void*);
 NSObject *a;
};
int main(int argc, const char * argv[]) {
    /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool;
attribute__((__blocks__(byref))) __Block_byref_a_0 a = {(void*)0,(__Block_byref_a_0 *)&amp;a, 33554432, sizeof(__Block_byref_a_0), __Block_byref_id_object_copy_131, __Block_byref_id_object_dispose_131,....};
Block block = (void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_a_0 *)&amp;a, 570425344);
}

// 以下的40表示__Block_byref_a_0对象a的位移（4个指针(32字节)＋2个int变量(8字节)＝40字节）
    static void __Block_byref_id_object_copy_131(void *dst, void *src) {
     _Block_object_assign((char*)dst + 40, *(void * *) ((char*)src + 40), 131);
    }
    static void __Block_byref_id_object_dispose_131(void *src) {
     _Block_object_dispose(*(void * *) ((char*)src + 40), 131);
    }
</code></pre>

<ol>
<li><p>可以看到，对于对象，<strong>Block_byref_a_0另外增加了两个辅助函数</strong>Block_byref_id_object_copy、__Block_byref_id_object_dispose,以实现对对象</p></li>
<li><p>内存的管理。其中两者的最后一个参数131表示BLOCK_BYREF_CALLER|BLOCK_FIELD_IS_OBJECT，BLOCK_BYREF_CALLER表示在内部实现中不对a对象进行retain或copy；以下为相关源码</p></li>
</ol>


<hr />

<pre><code>if ((flags &amp; BLOCK_BYREF_CALLER) == BLOCK_BYREF_CALLER) {
    ...
    else {
        // do *not* retain or *copy* __block variables whatever they are
        _Block_assign((void *)object, destAddr);
    }
}
</code></pre>

<p>_Block_byref_assign_copy函数的以下代码会对上面的辅助函数（__Block_byref_id_object_copy_131）进行调用；570425344表示BLOCK_HAS_COPY_DISPOSE|BLOCK_HAS_DESCRIPTOR，所以会执行以下相关源码：</p>

<pre><code>if (src-&gt;flags &amp; BLOCK_HAS_COPY_DISPOSE) {
    // Trust copy helper to copy everything of interest
    // If more than one field shows up in a byref block this is wrong XXX
    copy-&gt;byref_keep = src-&gt;byref_keep;
    copy-&gt;byref_destroy = src-&gt;byref_destroy;
    (*src-&gt;byref_keep)(copy, src);
}
</code></pre>

<h3>ARC中block的工作</h3>

<p><img src="/images/block003.png" title="Caption" ></p>

<p>苹果说明</p>

<p>苹果文档提及，在ARC模式下，在栈间传递block时，不需要手动copy栈中的block，即可让block正常工作。主要原因是ARC对栈中的block自动执行了copy，将<em>NSConcreteStackBlock类型的block转换成了</em>NSConcreteMallocBlock的block。</p>

<h5>block试验</h5>

<p>下面对block做点实验：</p>

<p>int main(int argc, const char * argv[]) {
    @autoreleasepool {
        int i = 10;
        void (^block)() = ^{i;};</p>

<pre><code>    __weak void (^weakBlock)() = ^{i;};

    void (^stackBlock)() = ^{};

    // ARC情况下

    // 创建时，都会在栈中
    // &lt;__NSStackBlock__: 0x7fff5fbff730&gt;
    NSLog(@"%@", ^{i;});

    // 因为stackBlock为strong类型，且捕获了外部变量，所以赋值时，自动进行了copy
    // &lt;__NSMallocBlock__: 0x100206920&gt;
    NSLog(@"%@", block);

    // 如果是weak类型的block，依然不会自动进行copy
    // &lt;__NSStackBlock__: 0x7fff5fbff728&gt;
    NSLog(@"%@", weakBlock);

    // 如果block是strong类型，并且没有捕获外部变量，那么就会转换成__NSGlobalBlock__
    // &lt;__NSGlobalBlock__: 0x100001110&gt;
    NSLog(@"%@", stackBlock);

    // 在非ARC情况下，产生以下输出
    // &lt;__NSStackBlock__: 0x7fff5fbff6d0&gt;
    // &lt;__NSStackBlock__: 0x7fff5fbff730&gt;
    // &lt;__NSStackBlock__: 0x7fff5fbff700&gt;
    // &lt;__NSGlobalBlock__: 0x1000010d0&gt;
}
return 0;
</code></pre>

<p>}</p>

<p>可以看出，ARC对类型为strong且捕获了外部变量的block进行了copy。并且当block类型为strong，但是创建时没有捕获外部变量，block最终会变成<strong>NSGlobalBlock</strong>类型（这里可能因为block中的代码没有捕获外部变量，所以不需要在栈中开辟变量，也就是说，在编译时，这个block的所有内容已经在代码段中生成了，所以就把block的类型转换为全局类型）</p>

<h5>block作为参数传递</h5>

<p>再来看下使用在栈中的block需要注意的情况：</p>

<pre><code>NSMutableArray *arrayM;
void myBlock()
{
    int a = 5;
    Block block = ^ {
        NSLog(@"%d", a);
    };

    [arrayM addObject:block];
    NSLog(@"%@", block);
}

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        arrayM = @[].mutableCopy;

        myBlock();

        Block block = [arrayM firstObject];
        // 非ARC这里崩溃
        block();
 }

// ARC情况下输出
// &lt;__NSMallocBlock__: 0x100214480&gt;

// 非ARC情况下输出
// &lt;__NSStackBlock__: 0x7fff5fbff738&gt;
// 崩溃，野指针错误
</code></pre>

<p>可以看到，ARC情况下因为自动执行了copy，所以返回类型为<strong>NSMallocBlock</strong>，在函数结束后依然可以访问；而非ARC情况下，需要我们手动调用[block copy]来将block拷贝到堆中，否则因为栈中的block生命周期和函数中的栈生命周期关联，当函数退出后，相应的堆被销毁，block也就不存在了。
如果把block的以下代码删除：</p>

<pre><code>NSLog(@"%d", a);
那么block就会变成全局类型，在main中访问也不会出崩溃。
</code></pre>

<h5>block作为返回值</h5>

<pre><code>在非ARC情况下，如果返回值是block，则一般这样操作：

return [[block copy] autorelease];
</code></pre>

<p>对于外部要使用的block，更趋向于把它拷贝到堆中，使其脱离栈生命周期的约束。</p>

<h5>block属性</h5>

<p>这里还有一点关于block类型的ARC属性。上文也说明了，ARC会自动帮strong类型且捕获外部变量的block进行copy，所以在定义block类型的属性时也可以使用strong，不一定使用copy。也就是以下代码：</p>

<pre><code>/** 假如有栈block赋给以下两个属性 **/

// 这里因为ARC，当栈block中会捕获外部变量时，这个block会被copy进堆中
// 如果没有捕获外部变量，这个block会变为全局类型
// 不管怎么样，它都脱离了栈生命周期的约束

@property (strong, nonatomic) Block *strongBlock;

// 这里都会被copy进堆中
@property (copy, nonatomic) Block *copyBlock;
</code></pre>

<p>参考博文
谈Objective-C Block的实现(<a href="http://blog.devtang.com/blog/2013/07/28/a-look-inside-blocks/">http://blog.devtang.com/blog/2013/07/28/a-look-inside-blocks/</a>)
iOS中block实现的探究(<a href="http://blog.csdn.net/jasonblog/article/details/7756763">http://blog.csdn.net/jasonblog/article/details/7756763</a>)
A look inside blocks: Episode 3
runtime.c
Block_private.h</p>
</div>
  
  




| <a href="/blog/2015/11/28/blockshen-jiu/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/11/28/zi-ding-yi-xiang-ce-shan-chu-fu-huo-de-shi-xian/">自定义相册删除复活的实现</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><p>在这里（<a href="http://www.cnblogs.com/iCocos/p/4705585.html">http://www.cnblogs.com/iCocos/p/4705585.html</a>）我们提到了。</p>

<ul>
<li>简单的实现了获取系统相册图片并且保存图片到系统相册</li>
<li>定义自定义的相册，并且保存到自定义相册</li>
</ul>


<p>这里久以一个简单的例子实现一个上面的所有功能，并且添加一个很有用的功能实现
App中自定义的相册呗删除之后再次保存相片无法成功</p>

<p>这里使用的是一个系统的库：ALAssetsLibrary</p>

<p>先来看看咱们取得相册中的相片</p>

<pre><code>- (void)getAllPhotos
{
    ALAssetsLibrary *library = [[ALAssetsLibrary alloc] init];
    // 遍历所有的文件夹, 一个ALAssetsGroup对象就代表一个文件夹
    [library enumerateGroupsWithTypes:ALAssetsGroupAll usingBlock:^(ALAssetsGroup *group, BOOL *stop) {
        // 遍历文件夹内的所有多媒体文件（图片、视频）, 一个ALAsset对象就代表一张图片
        [group enumerateAssetsUsingBlock:^(ALAsset *result, NSUInteger index, BOOL *stop) {
            // 缩略图
            XMGLog(@"%@", [UIImage imageWithCGImage:result.thumbnail]);
            // 获得原始图片
            //            XMGLog(@"%@", [UIImage imageWithCGImage:result.defaultRepresentation.fullResolutionImage]);
        }];

   } failureBlock:nil];
}
</code></pre>

<p>下面我们看看代码具体的实现</p>

<p>一：首先定义一个属性涌来记录并且实现其他一些功能</p>

<pre><code> /** 相册库 */
@property (nonatomic, strong) ALAssetsLibrary *library;
</code></pre>

<p>二：然后就懒加载这个属性</p>

<pre><code>- (ALAssetsLibrary *)library
{
    if (!_library) {
        _library = [[ALAssetsLibrary alloc] init];
    }
    return _library;
}
</code></pre>

<p>三：点击保存按钮的实现</p>

<pre><code>- (IBAction)save
{
// 获得文件夹的名字
__block NSString *groupName = [self groupName];

// self的弱引用
XMGWeakSelf;

// 图片库
__weak ALAssetsLibrary *weakLibrary = self.library;

// 创建文件夹
[weakLibrary addAssetsGroupAlbumWithName:groupName resultBlock:^(ALAssetsGroup *group) {
    if (group) { // 新创建的文件夹
        // 添加图片到文件夹中
        [weakSelf addImageToGroup:group];
    } else { // 文件夹已经存在
        [weakLibrary enumerateGroupsWithTypes:ALAssetsGroupAll usingBlock:^(ALAssetsGroup *group, BOOL *stop) {
            NSString *name = [group valueForProperty:ALAssetsGroupPropertyName];
            if ([name isEqualToString:groupName]) { // 是自己创建的文件夹
                // 添加图片到文件夹中

                [weakSelf addImageToGroup:group];

                *stop = YES; // 停止遍历
            } else if ([name isEqualToString:@"Camera Roll"]) {
                // 文件夹被用户强制删除了
                groupName = [groupName stringByAppendingString:@" "];
                // 存储新的名字
                [[NSUserDefaults standardUserDefaults] setObject:groupName forKey:XMGGroupNameKey];
                [[NSUserDefaults standardUserDefaults] synchronize];
                // 创建新的文件夹
                [weakLibrary addAssetsGroupAlbumWithName:groupName resultBlock:^(ALAssetsGroup *group) {
                    // 添加图片到文件夹中
                    [weakSelf addImageToGroup:group];
                } failureBlock:nil];
            }
        } failureBlock:nil];
    }

    } failureBlock:nil];
    }
</code></pre>

<p>四：添加图片</p>

<pre><code>/**
 * 添加一张图片到某个文件夹中
 */
- (void)addImageToGroup:(ALAssetsGroup *)group
{
__weak ALAssetsLibrary *weakLibrary = self.library;
// 需要保存的图片

CGImageRef image = self.imageView.image.CGImage;

// 添加图片到【相机胶卷】
[weakLibrary writeImageToSavedPhotosAlbum:image metadata:nil completionBlock:^(NSURL *assetURL, NSError *error) {
    [weakLibrary assetForURL:assetURL resultBlock:^(ALAsset *asset) {
        // 添加一张图片到自定义的文件夹中
        [group addAsset:asset];
        [SVProgressHUD showSuccessWithStatus:@"保存成功!"];
    } failureBlock:nil];
}];
}
</code></pre>

<p>五：关于沙河中的组名</p>

<p>先定义一个用于保存名字用的key和一个需要保存的名字</p>

<pre><code>static NSString * const iCocosGroupNameKey = @"iCocosGroupNameKey";
static NSString * const iCocosDefaultGroupName = @"iCocos";
</code></pre>

<p>实现祖名的存取</p>

<pre><code>- (NSString *)groupName
{
    // 先从沙盒中取得名字

    NSString *groupName = [[NSUserDefaults standardUserDefaults] stringForKey:XMGGroupNameKey];
    if (groupName == nil) { // 沙盒中没有存储任何文件夹的名字
   groupName = XMGDefaultGroupName;

    // 存储名字到沙盒中
    [[NSUserDefaults standardUserDefaults] setObject:groupName forKey:XMGGroupNameKey];
 [[NSUserDefaults standardUserDefaults] synchronize];
}
return groupName;
}
</code></pre>
</div>
  
  




| <a href="/blog/2015/11/28/zi-ding-yi-xiang-ce-shan-chu-fu-huo-de-shi-xian/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/11/28/xmppshi-yong-zong-jie/">XMPP使用总结</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><p>引言：
最近面试被问到了一个问题，笔者当时就懵了：什么XMPP，平时怎么使用，使用过程中遇到什么问题？。</p>

<p>但是还是通过记忆，简单的说了一下自己所知道了，不过那并没有撒卵用，所以你懂的</p>

<h6>##XMPPFramework是一个OS X/iOS平台的开源项目，使用Objective-C实现了XMPP协议（RFC-3920），同时还提供了用于读写XML的工具，大大简化了基于XMPP的通信应用的开发。</h6>

<h3>关于连接的</h3>

<pre><code>//此方法在stream开始连接服务器的时候调用
 - (void)xmppStreamDidConnect:(XMPPStream *)sender
 //此方法在stream连接断开的时候调用
 - (void)xmppStreamDidDisconnect:(XMPPStream *)sender withError:(NSError *)error;
</code></pre>

<h3>关于验证的</h3>

<pre><code>//验证失败后调用
 - (void)xmppStream:(XMPPStream *)sender didNotAuthenticate:(NSXMLElement *)error
//验证成功后调用
 - (void)xmppStreamDidAuthenticate:(XMPPStream *)sender
</code></pre>

<h3>关于通信的</h3>

<pre><code>//收到消息后调用
- (void)xmppStream:(XMPPStream *)sender didReceiveMessage:(XMPPMessage *)message
//接受到好友状态更新
- (void)xmppStream:(XMPPStream *)sender didReceivePresence:(XMPPPresence *)presence
</code></pre>

<h4>简单实战</h4>

<h6>登录和好友上下线</h6>

<h5>XMPP中常用对象们</h5>

<pre><code>XMPPStream：xmpp基础服务类
XMPPRoster：好友列表类
XMPPRosterCoreDataStorage：好友列表（用户账号）在core data中的操作类
XMPPvCardCoreDataStorage：好友名片（昵称，签名，性别，年龄等信息）在core data中的操作类
XMPPvCardTemp：好友名片实体类，从数据库里取出来的都是它
xmppvCardAvatarModule：好友头像
XMPPReconnect：如果失去连接,自动重连
XMPPRoom：提供多用户聊天支持
</code></pre>

<p>XMPPPubSub：发布订阅</p>

<h5>登录操作，也就是连接xmpp服务器</h5>

<pre><code>- (void)connect {
    if (self.xmppStream == nil) {
        self.xmppStream = [[XMPPStream alloc] init];
        [self.xmppStream addDelegate:self delegateQueue:dispatch_get_main_queue()];
    }
    if (![self.xmppStream isConnected]) {
        NSString *username = [[NSUserDefaults standardUserDefaults] objectForKey:@"username"];
        XMPPJID *jid = [XMPPJID jidWithUser:username domain:@"lizhen" resource:@"Ework"];
        [self.xmppStream setMyJID:jid];
        [self.xmppStream setHostName:@"10.4.125.113"];
        NSError *error = nil;
        if (![self.xmppStream connect:&amp;error]) {
            NSLog(@"Connect Error: %@", [[error userInfo] description]);
        }
    }
}
</code></pre>

<p>connect成功之后会依次调用XMPPStreamDelegate的方法，首先调用</p>

<pre><code>- (void)xmppStream:(XMPPStream *)sender socketDidConnect:(GCDAsyncSocket *)socket
</code></pre>

<p>&hellip;
然后</p>

<ul>
<li><p>(void)xmppStreamDidConnect:(XMPPStream *)sender
在该方法下面需要使用xmppStream 的authenticateWithPassword方法进行密码验证，成功的话会响应delegate的方法，就是下面这个</p></li>
<li><p>(void)xmppStreamDidAuthenticate:(XMPPStream *)sender</p></li>
</ul>


<h5>上线</h5>

<p>实现 - (void)xmppStreamDidAuthenticate:(XMPPStream *)sender 委托方法</p>

<pre><code>- (void)xmppStreamDidAuthenticate:(XMPPStream *)sender {
     XMPPPresence *presence = [XMPPPresence presenceWithType:@"available"];
    [self.xmppStream sendElement:presence];
 }
</code></pre>

<h5>退出并断开连接</h5>

<pre><code> - (void)disconnect {
     XMPPPresence *presence = [XMPPPresence presenceWithType:@"unavailable"];
    [self.xmppStream sendElement:presence];

      [self.xmppStream disconnect];
  }
</code></pre>

<h5>好友状态</h5>

<p>获取好友状态，通过实现</p>

<pre><code>- (void)xmppStream:(XMPPStream *)sender didReceivePresence:(XMPPPresence *)presence
</code></pre>

<p>&hellip;
方法，当接收到 presence 标签的内容时，XMPPFramework 框架回调该方法</p>

<pre><code>presence 的状态：
available 上线
away 离开
do not disturb 忙碌
unavailable 下线

- (void)xmppStream:(XMPPStream *)sender didReceivePresence:(XMPPPresence *)presence {
    NSString *presenceType = [presence type];
    NSString *presenceFromUser = [[presence from] user];
    if (![presenceFromUser isEqualToString:[[sender myJID] user]]) {
        if ([presenceType isEqualToString:@"available"]) {
            //
        } else if ([presenceType isEqualToString:@"unavailable"]) {
            //
        }
    }
}
</code></pre>

<h3>接收消息和发送消息</h3>

<h5>接收消息</h5>

<p>通过实现</p>

<ul>
<li><p>(void)xmppStream:(XMPPStream <em>)sender didReceiveMessage:(XMPPMessage </em>)message;
当接收到 message 标签的内容时，XMPPFramework 框架回调该方法
根据 XMPP 协议，消息体的内容存储在标签 body 内</p></li>
<li><p>(void)xmppStream:(XMPPStream <em>)sender didReceiveMessage:(XMPPMessage </em>)message {
  NSString *messageBody = [[message elementForName:@&ldquo;body&rdquo;] stringValue];
}</p></li>
</ul>


<h5>发送消息</h5>

<p>发送消息，我们需要根据 XMPP 协议，将数据放到标签内</p>

<pre><code>- (void)sendMessage:(NSString *) message toUser:(NSString *) user {
    NSXMLElement *body = [NSXMLElement elementWithName:@"body"];
    [body setStringValue:message];
    NSXMLElement *message = [NSXMLElement elementWithName:@"message"];
    [message addAttributeWithName:@"type" stringValue:@"chat"];
    NSString *to = [NSString stringWithFormat:@"%@@example.com", user];
    [message addAttributeWithName:@"to" stringValue:to];
    [message addChild:body];
    [self.xmppStream sendElement:message];
}
</code></pre>

<h3>获取好友信息和删除好友</h3>

<h5>好友列表和好友名片</h5>

<pre><code>[_xmppRoster fetchRoster];//获取好友列表
//获取到一个好友节点
- (void)xmppRoster:(XMPPRoster *)sender didRecieveRosterItem:(NSXMLElement *)item
//获取完好友列表
- (void)xmppRosterDidEndPopulating:(XMPPRoster *)sender
//到服务器上请求联系人名片信息
- (void)fetchvCardTempForJID:(XMPPJID *)jid;
//请求联系人的名片，如果数据库有就不请求，没有就发送名片请求
- (void)fetchvCardTempForJID:(XMPPJID *)jid ignoreStorage:(BOOL)ignoreStorage;
//获取联系人的名片，如果数据库有就返回，没有返回空，并到服务器上抓取
- (XMPPvCardTemp *)vCardTempForJID:(XMPPJID *)jid shouldFetch:(BOOL)shouldFetch;
//更新自己的名片信息
- (void)updateMyvCardTemp:(XMPPvCardTemp *)vCardTemp;
//获取到一盒联系人的名片信息的回调
- (void)xmppvCardTempModule:(XMPPvCardTempModule *)vCardTempModule
        didReceivevCardTemp:(XMPPvCardTemp *)vCardTemp
                     forJID:(XMPPJID *)jid
</code></pre>

<h5>添加好友</h5>

<pre><code>//name为用户账号
    - (void)XMPPAddFriendSubscribe:(NSString *)name
    {
        //XMPPHOST 就是服务器名，  主机名
        XMPPJID *jid = [XMPPJID jidWithString:[NSString stringWithFormat:@"%@@%@",name,XMPPHOST]];
        //[presence addAttributeWithName:@"subscription" stringValue:@"好友"];
        [xmppRoster subscribePresenceToUser:jid];

    }
</code></pre>

<h5>收到添加好友的请求</h5>

<pre><code>- (void)xmppRoster:(XMPPRoster *)sender didReceivePresenceSubscriptionRequest:(XMPPPresence *)presence
    {
        //取得好友状态
        NSString *presenceType = [NSString stringWithFormat:@"%@", [presence type]]; //online/offline
        //请求的用户
        NSString *presenceFromUser =[NSString stringWithFormat:@"%@", [[presence from] user]];
        NSLog(@"presenceType:%@",presenceType);

        NSLog(@"presence2:%@  sender2:%@",presence,sender);

        XMPPJID *jid = [XMPPJID jidWithString:presenceFromUser];
        //接收添加好友请求
        [xmppRoster acceptPresenceSubscriptionRequestFrom:jid andAddToRoster:YES];

    }
</code></pre>

<h5>删除好友</h5>

<pre><code>//删除好友，name为好友账号
- (void)removeBuddy:(NSString *)name  
{  
    XMPPJID *jid = [XMPPJID jidWithString:[NSString stringWithFormat:@"%@@%@",name,XMPPHOST]];  

    [self xmppRoster] removeUser:jid];  
}
</code></pre>

<h5>聊天室</h5>

<p>初始化聊天室</p>

<pre><code>     XMPPJID *roomJID = [XMPPJID jidWithString:ROOM_JID];

    xmppRoom = [[XMPPRoom alloc] initWithRoomStorage:self jid:roomJID];

    [xmppRoom activate:xmppStream];
     [xmppRoom addDelegate:self delegateQueue:dispatch_get_main_queue()];
</code></pre>

<p>创建聊天室成功</p>

<pre><code>`- (void)xmppRoomDidCreate:(XMPPRoom *)sender
{
    DDLogInfo(@"%@: %@", THIS_FILE, THIS_METHOD);
}`
</code></pre>

<p>加入聊天室，使用昵称</p>

<pre><code>[xmppRoom joinRoomUsingNickname:@"quack" history:nil];
</code></pre>

<p>获取聊天室信息</p>

<pre><code>- (void)xmppRoomDidJoin:(XMPPRoom *)sender
    {
        [xmppRoom fetchConfigurationForm];
        [xmppRoom fetchBanList];
        [xmppRoom fetchMembersList];
        [xmppRoom fetchModeratorsList];
    }
</code></pre>

<p>如果房间存在，会调用委托</p>

<pre><code>    // 收到禁止名单列表

    - (void)xmppRoom:(XMPPRoom *)sender didFetchBanList:(NSArray *)items;
    // 收到好友名单列表

    - (void)xmppRoom:(XMPPRoom *)sender didFetchMembersList:(NSArray *)items;
    // 收到主持人名单列表

    - (void)xmppRoom:(XMPPRoom *)sender didFetchModeratorsList:(NSArray *)items;
房间不存在，调用委托

    - (void)xmppRoom:(XMPPRoom *)sender didNotFetchBanList:(XMPPIQ *)iqError;
    - (void)xmppRoom:(XMPPRoom *)sender didNotFetchMembersList:(XMPPIQ *)iqError;
    - (void)xmppRoom:(XMPPRoom *)sender didNotFetchModeratorsList:(XMPPIQ *)iqError;
</code></pre>

<p>离开房间</p>

<pre><code>[xmppRoom deactivate:xmppStream];
</code></pre>

<p>XMPPRoomDelegate的其他代理方法:</p>

<p>离开聊天室</p>

<pre><code>    - (void)xmppRoomDidLeave:(XMPPRoom *)sender
    {
        DDLogVerbose(@"%@: %@", THIS_FILE, THIS_METHOD);
    }
</code></pre>

<p>新人加入群聊</p>

<pre><code>    - (void)xmppRoom:(XMPPRoom *)sender occupantDidJoin:(XMPPJID *)occupantJID
     {
         DDLogVerbose(@"%@: %@", THIS_FILE, THIS_METHOD);
    }
</code></pre>

<p>有人退出群聊</p>

<pre><code>    - (void)xmppRoom:(XMPPRoom *)sender occupantDidLeave:(XMPPJID *)occupantJID
    {
        DDLogVerbose(@"%@: %@", THIS_FILE, THIS_METHOD);
    }
</code></pre>

<p>有人在群里发言</p>

<pre><code>    - (void)xmppRoom:(XMPPRoom *)sender didReceiveMessage:(XMPPMessage *)message fromOccupant:(XMPPJID *)occupantJID
     {
         DDLogVerbose(@"%@: %@", THIS_FILE, THIS_METHOD);
    }
</code></pre>

<h5>消息回执</h5>

<p>这个是XEP－0184协议的内容
发送消息时附加回执请求
代码实现</p>

<pre><code>NSString *siID = [XMPPStream generateUUID];
    //发送消息
    XMPPMessage *message = [XMPPMessage messageWithType:@"chat" to:jid elementID:siID];
    NSXMLElement *receipt = [NSXMLElement elementWithName:@"request" xmlns:@"urn:xmpp:receipts"];
    [message addChild:receipt];
    [message addBody:@"测试"];
    [self.xmppStream sendElement:message];
</code></pre>

<p>收到回执请求的消息，发送回执</p>

<pre><code>- (void)xmppStream:(XMPPStream *)sender didReceiveMessage:(XMPPMessage *)message
    {
        //回执判断
        NSXMLElement *request = [message elementForName:@"request"];
        if (request)
        {
            if ([request.xmlns isEqualToString:@"urn:xmpp:receipts"])//消息回执
            {
                //组装消息回执
                XMPPMessage *msg = [XMPPMessage messageWithType:[message attributeStringValueForName:@"type"] to:message.from elementID:[message attributeStringValueForName:@"id"]];
                NSXMLElement *recieved = [NSXMLElement elementWithName:@"received" xmlns:@"urn:xmpp:receipts"];
                [msg addChild:recieved];

                //发送回执
                [self.xmppStream sendElement:msg];
            }
        }else
        {
            NSXMLElement *received = [message elementForName:@"received"];
            if (received)
            {
                if ([received.xmlns isEqualToString:@"urn:xmpp:receipts"])//消息回执
                {
                    //发送成功
                    NSLog(@"message send success!");
                }  
            }  
        }  

        //消息处理  
        //...  
    }
</code></pre>

<h5>添加AutoPing</h5>

<p>为 了监听服务器是否有效，增加心跳监听。用XEP-0199协议，在XMPPFrameWork框架下，封装了 XMPPAutoPing 和 XMPPPing两个类都可以使用，因为XMPPAutoPing已经组合进了XMPPPing类，所以XMPPAutoPing使用起来更方便。</p>

<pre><code>//初始化并启动ping
-(void)autoPingProxyServer:(NSString*)strProxyServer
{
    _xmppAutoPing = [[XMPPAutoPingalloc] init];
    [_xmppAutoPingactivate:_xmppStream];
    [_xmppAutoPingaddDelegate:selfdelegateQueue:  dispatch_get_main_queue()];
    _xmppAutoPing.respondsToQueries = YES;
    _xmppAutoPing.pingInterval=2;//ping 间隔时间
    if (nil != strProxyServer)
    {
       _xmppAutoPing.targetJID = [XMPPJID jidWithString: strProxyServer ];//设置ping目标服务器，如果为nil,则监听socketstream当前连接上的那个服务器
    }
}
//卸载监听
 [_xmppAutoPing   deactivate];
  [_xmppAutoPing   removeDelegate:self];
   _xmppAutoPing = nil;
//ping XMPPAutoPingDelegate的委托方法:
- (void)xmppAutoPingDidSendPing:(XMPPAutoPing *)sender
{
    NSLog(@"- (void)xmppAutoPingDidSendPing:(XMPPAutoPing *)sender");
}
- (void)xmppAutoPingDidReceivePong:(XMPPAutoPing *)sender
{
    NSLog(@"- (void)xmppAutoPingDidReceivePong:(XMPPAutoPing *)sender");
}

- (void)xmppAutoPingDidTimeout:(XMPPAutoPing *)sender
{
    NSLog(@"- (void)xmppAutoPingDidTimeout:(XMPPAutoPing *)sender");
}
</code></pre>
</div>
  
  




| <a href="/blog/2015/11/28/xmppshi-yong-zong-jie/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/11/28/lan-ya-kai-fa-ni-zhi-dao-duo-shao/">蓝牙开发你知道多少</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><p>蓝牙简单介绍和4.0的基本使用</p>

<p>背景：</p>

<ul>
<li>iOS的蓝牙不能用来传输文件。</li>
<li>iOS与iOS设备之间进行数据通信，使用gameKit.framework</li>
<li>iOS与其他非iOS设备进行数据通信，使用coreBluetooth.framework</li>
</ul>


<h3>iOS中蓝牙的实现方案</h3>

<p>iOS中提供了4个框架用于实现蓝牙连接</p>

<ol>
<li><p>GameKit.framework（用法简单）</p>

<p> <code>只能用于iOS设备之间的连接，多用于游戏（比如五子棋对战），从iOS7开始过期</code></p></li>
<li><p>MultipeerConnectivity.framework</p>

<p> <code>只能用于iOS设备之间的连接，从iOS7开始引入，主要用于文件共享（仅限于沙盒的文件）</code></p></li>
<li><p>ExternalAccessory.framework</p>

<p> <code>可用于第三方蓝牙设备交互，但是蓝牙设备必须经过苹果MFi认证（国内较少）</code></p></li>
<li><h6>CoreBluetooth.framework（时下热门）</h6>

<p> <code>可用于第三方蓝牙设备交互，必须要支持蓝牙4.0</code></p>

<p> <code>硬件至少是4s，系统至少是iOS6</code></p>

<p> <code>蓝牙4.0以低功耗著称，一般也叫BLE（BluetoothLowEnergy）</code></p>

<p> <code>目前应用比较多的案例：运动手坏、嵌入式设备、智能家居</code></p></li>
</ol>


<p>下面具体介绍使用CoreBluetooth.framework的代码步骤：</p>

<h5>蓝牙系统库</h5>

<pre><code>#import &lt;CoreBluetooth/CoreBluetooth.h&gt;
</code></pre>

<h5>必须要由UUID来唯一标示对应的service和characteristic</h5>

<pre><code>#define kServiceUUID @"5C476471-1109-4EBE-A826-45B4F9D74FB9"

#define kCharacteristicHeartRateUUID @"82C7AC0F-6113-4EC9-92D1-5EEF44571398"

#define kCharacteristicBodyLocationUUID @"537B5FD6-1889-4041-9C35-F6949D1CA034"
</code></pre>

<hr />

<pre><code>@interface ViewController ()&lt;CBCentralManagerDelegate,CBPeripheralDelegate&gt;



@property (nonatomic,strong)CBCentralManager * centralManager;

@property (nonatomic,strong)CBPeripheral     * peripheral;

@end
</code></pre>

<h4>创建中心角色</h4>

<pre><code>#import &lt;CoreBluetooth/CoreBluetooth.h&gt;

- (void)viewDidLoad
{

    [super viewDidLoad];

    //初始化蓝牙 central manager

    _centralManager = [[CBCentralManager alloc]initWithDelegate:self queue:dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0) options:nil];    

}
</code></pre>

<h4>扫描外设</h4>

<pre><code>[manager scanForPeripheralsWithServices:nil options:@{CBCentralManagerRestoredStateScanOptionsKey:@(YES)}];
</code></pre>

<h4>连接外设</h4>

<pre><code>- (void)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)peripheral advertisementData:(NSDictionary *)advertisementData RSSI:(NSNumber *)RSSI
{
        if([peripheral.name  isEqualToString:BLE_SERVICE_NAME]){
                [self connect:peripheral];
        }
}       

-(BOOL)connect:(CBPeripheral *)peripheral{
        self.manager.delegate = self;
        [self.manager connectPeripheral:peripheral
                                options:[NSDictionary dictionaryWithObject:[NSNumber numberWithBool:YES] forKey:CBConnectPeripheralOptionNotifyOnDisconnectionKey]];
}
</code></pre>

<h4>扫描外设中的服务和特征</h4>

<pre><code>- (void)centralManager:(CBCentralManager *)central didConnectPeripheral:(CBPeripheral *)peripheral
{

   NSLog(@"Did connect to peripheral: %@", peripheral);       

   _testPeripheral = peripheral;
   [peripheral setDelegate:self];  &lt;br&gt;//查找服务
   [peripheral discoverServices:nil];


}
</code></pre>

<h4>发现服务：</h4>

<pre><code>- (void)peripheral:(CBPeripheral *)peripheral didDiscoverServices:(NSError *)error
{


NSLog(@"didDiscoverServices");

if (error)
{
    NSLog(@"Discovered services for %@ with error: %@", peripheral.name, [error localizedDescription]);

    if ([self.delegate respondsToSelector:@selector(DidNotifyFailConnectService:withPeripheral:error:)])
        [self.delegate DidNotifyFailConnectService:nil withPeripheral:nil error:nil];

    return;
}


for (CBService *service in peripheral.services)
{
     //发现服务
    if ([service.UUID isEqual:[CBUUID UUIDWithString:UUIDSTR_ISSC_PROPRIETARY_SERVICE]])
    {
        NSLog(@"Service found with UUID: %@", service.UUID);  &lt;br&gt;//查找特征
        [peripheral discoverCharacteristics:nil forService:service];
        break;
    }


}
}
</code></pre>

<h4>发现服务中的特征：</h4>

<pre><code>- (void)peripheral:(CBPeripheral *)peripheral didDiscoverCharacteristicsForService:(CBService *)service error:(NSError *)error
{

if (error)
{
    NSLog(@"Discovered characteristics for %@ with error: %@", service.UUID, [error localizedDescription]);

    [self error];
    return;
}

NSLog(@"服务：%@",service.UUID);
for (CBCharacteristic *characteristic in service.characteristics)
{
   //发现特征
        if ([characteristic.UUID isEqual:[CBUUID UUIDWithString:@"xxxxxxx"]]) {
            NSLog(@"监听：%@",characteristic);&lt;br&gt;//监听特征
            [self.peripheral setNotifyValue:YES forCharacteristic:characteristic];
        }

}
}
</code></pre>

<h4>与外设进行数据交互</h4>

<p>读取数据：</p>

<pre><code>- (void)peripheral:(CBPeripheral *)peripheral didUpdateValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error
{
    if (error)
    {
        NSLog(@"Error updating value for characteristic %@ error: %@", characteristic.UUID, [error localizedDescription]);
        self.error_b = BluetoothError_System;
        [self error];
        return;
}

//    NSLog(@"收到的数据：%@",characteristic.value);
[self decodeData:characteristic.value];
}
</code></pre>

<h4>写数据：</h4>

<pre><code>NSData *d2 = [[PBABluetoothDecode sharedManager] HexStringToNSData:@"0x02"];
            [self.peripheral writeValue:d2 forCharacteristic:characteristic type:CBCharacteristicWriteWithoutResponse];
</code></pre>
</div>
  
  




| <a href="/blog/2015/11/28/lan-ya-kai-fa-ni-zhi-dao-duo-shao/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/11/28/cocoapodsjian-dan-cu-bao/">cocoaPods简单粗暴</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><p>直接上代码，不要问为什么，照着做就可以，我也是这么做的，具体的细节，请查看相关文档，网上太多！</p>

<p>1:移除ruby镜像（天朝的网你们懂的）</p>

<pre><code> $ gem sources --remove https://rubygems.org/ 
</code></pre>

<p>2:新增淘宝镜像</p>

<pre><code>$ gem sources -a http://ruby.taobao.org/ 
</code></pre>

<p>3:查看列表</p>

<pre><code> $ gem sources -l 
</code></pre>

<p>成功的征兆：</p>

<pre><code>*** CURRENT SOURCES ***
http://ruby.taobao.org/
$ sudo gem install cocoapods
</code></pre>

<p>4:正式安装</p>

<pre><code> sudo gem install cocoapods 
</code></pre>

<p>接下来就是开始使用了。</p>

<p>查看对应的框架</p>

<pre><code> $ pod search AFNetworking 
</code></pre>

<p>创建文件</p>

<pre><code> $ vim Podfile 
</code></pre>

<p> 或者在命令行行中cd到对应的项目文件夹使用</p>

<pre><code>touch Podfile
</code></pre>

<p>新建一个文件</p>

<p>然后在Podfile文件中输入以下文字：</p>

<pre><code>platform :ios, '7.0'
pod "AFNetworking", "~&gt; 2.0”
</code></pre>

<p>安装</p>

<pre><code> pod install  
</code></pre>

<p>更新</p>

<pre><code> $ pod update 
</code></pre>

<p>有时候可能上面的命令没有用可能是网络的原因，那么你可以试试下面的：</p>

<pre><code>pod update 换成pod update --verbose --no-repo-update
pod install 换成pod install --verbose --no-repo-update
</code></pre>

<ul>
<li>$ pod install只会按照Podfile的要求来请求类库，如果类库版本号有变化，那么将获取失败。
$ pod update会更新所有的类库，获取最新版本的类库。
或许还有一些情况是因为mac中对应的文件有问题，比如有两个Xcode的时候就会发生歧义（系统不知道用哪个），这个时候我们可以试试下面的方法。</li>
</ul>


<p>CocoaPods安装东西的时候它要找到Xcode的Developer文件夹, 如果找不到会报如下错误</p>

<ul>
<li>解决方案</li>
</ul>


<p>LNJ替换为你自己的用户名</p>

<pre><code>sudo xcode-select --switch /Users/LNJ/Applications/Xcode.app/Contents/Developer
</code></pre>

<p>而且你会发现，如果用了 $ pod update，再用 $ pod install 就成功了。</p>

<ul>
<li><p>那你也许会问，什么时候用 $ pod install，什么时候用 $ pod update 呢，我又不知道类库有没有新版本。</p></li>
<li><p>好吧，那你每次直接用 $ pod update 算了。或者先用 $ pod install，如果不行，再用 <br/>
  <code>$ pod update。</code></p></li>
</ul>


<p>当然你也可以使用Xcode插件，使用非常简单，这里就不多介绍，以后有机会给大家整理：</p>

<p><a href="https://github.com/kattrali/cocoapods-xcode-plugin">cocoapods-xcode-plugin</a></p>
</div>
  
  




| <a href="/blog/2015/11/28/cocoapodsjian-dan-cu-bao/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/11/28/qu-xiao-tableviewde-headeryu-footerde-nian-xing-xiao-guo/">取消TableView的Header与Footer的黏性效果</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><p>引言：</p>

<p>最近做一个项目的时候，遇到了一个bug问题，或者说个人能力有限，想了很久没有想到最好的方法去现实。</p>

<h6>那么是什么问题呢？</h6>

<p>首先当我在tabelView中为没饿过section设置一个header和footer之后，滑动tableView的时候，发现header和footer并不随着tableView中的cell一起滚动，而且会在顶部活着底部停留一段时间，这样的效果虽然好，但是上面就是不需要者也的功能，所以只好自己想办法解决。</p>

<p>我记得有时候header是不会停顿的，可是为什么这个时候header和footer都隐藏呢？</p>

<p>后来发现原来设置tableView.tableHeaderView = ?或者footerView的时候就不会停顿，那是当然，因为这个是tableView的一部分，不是section的一部分。</p>

<p>也在网上找了一段这样的代码</p>

<h3>去掉UItableview headerview黏性(sticky)</h3>

<pre><code>- (void)scrollViewDidScroll:(UIScrollView *)scrollView {

if (scrollView == self.tableView)

{

        CGFloat sectionHeaderHeight = 64; //sectionHeaderHeight

        if (scrollView.contentOffset.y &lt;= sectionHeaderHeight &amp;&amp; scrollView.contentOffset.y &gt;= 0) {

            scrollView.contentInset = UIEdgeInsetsMake(-scrollView.contentOffset.y, 0, 0, 0);

        } else if (scrollView.contentOffset.y &gt;= sectionHeaderHeight) {

            scrollView.contentInset = UIEdgeInsetsMake(-sectionHeaderHeight, 0, 0, 0);

        }

    }

}
</code></pre>

<p>但是他职能设置headerView不能设置footerView，自己也试着去补充footerView的实现，但是发现技术有限，所以，你懂的！</p>

<h3>最后看到国外一位大神写的一一篇文章找到了下面的代码</h3>

<pre><code> -(void)scrollViewDidScroll:(UIScrollView *)scrollView {

    if (scrollView == self.tableView)

        {

        UITableView *tableview = (UITableView *)scrollView;

        CGFloat sectionHeaderHeight = 64;

        CGFloat sectionFooterHeight = 120;

        CGFloat offsetY = tableview.contentOffset.y;

        if (offsetY &gt;= 0 &amp;&amp; offsetY &lt;= sectionHeaderHeight)

        {

            tableview.contentInset = UIEdgeInsetsMake(-offsetY, 0, -sectionFooterHeight, 0);

        }else if (offsetY &gt;= sectionHeaderHeight &amp;&amp; offsetY &lt;= tableview.contentSize.height - tableview.frame.size.height - sectionFooterHeight)

        {

            tableview.contentInset = UIEdgeInsetsMake(-sectionHeaderHeight, 0, -sectionFooterHeight, 0);

        }else if (offsetY &gt;= tableview.contentSize.height - tableview.frame.size.height - sectionFooterHeight &amp;&amp; offsetY &lt;= tableview.contentSize.height - tableview.frame.size.height)         {

            tableview.contentInset = UIEdgeInsetsMake(-offsetY, 0, -(tableview.contentSize.height - tableview.frame.size.height - sectionFooterHeight), 0);

        }

    }

}
</code></pre>

<p>注：sectionHeaderHeight和sectionFooterHeight根据项目进行设置。</p>

<p>发现基本上搞定，最后只需要设置对应的内边距即可！</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2015/11/28/qu-xiao-tableviewde-headeryu-footerde-nian-xing-xiao-guo/">阅读全文😘</a>
    </footer>
  




| <a href="/blog/2015/11/28/qu-xiao-tableviewde-headeryu-footerde-nian-xing-xiao-guo/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/11/28/tableviewqia-dun-na-du-bu-shi-shi/">UITableView性能优化与卡顿问题</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><p>引言：</p>

<p>在iOS开发中关于TableView算是已经用烂了的控件，但是又有几个人认真去考路过他的性能优化问题（卡顿）</p>

<p>最近项目中也遇到了不少卡顿的问题，为了更好的饿提高项目的性能，也为了提高自己的技术，专门花了一段时间研究了一下关于TableView的性能问题，在这里就总结了一下，希望可以帮你解决实际问题。</p>

<p>1.最常用的就是cell的重用， 注册重用标识符</p>

<pre><code>如果不重用cell时，每当一个cell显示到屏幕上时，就会重新创建一个新的cell
如果有很多数据的时候，就会堆积很多cell。如果重用cell，为cell创建一个ID
每当需要显示cell 的时候，都会先去缓冲池中寻找可循环利用的cell，如果没有再重新创建cell
设置正确的reuseIdentifer以重用cell
</code></pre>

<p>2.避免cell的重新布局</p>

<pre><code>cell的布局填充等操作 比较耗时，一般创建时就布局好
如可以将cell单独放到一个自定义类，初始化时就布局好
</code></pre>

<p>3.提前计算并缓存cell的属性及内容</p>

<pre><code>在cellForRowAtIndexPath:中尽量做更少的操作。如果需要做一些处理，那么最好做过一次之后，就将结果缓存起来。
当我们创建cell的数据源方法时，编译器并不是先创建cell 再定cell的高度
而是先根据内容一次确定每一个cell的高度，高度确定后，再创建要显示的cell，滚动时，每当cell进入凭虚都会计算高度，提前估算高度告诉编译器，编译器知道高度后，紧接着就会创建cell，这时再调用高度的具体计算方法，这样可以方式浪费时间去计算显示以外的cell
</code></pre>

<p>4.减少cell中控件的数量</p>

<pre><code>尽量使cell得布局大致相同，不同风格的cell可以使用不用的重用标识符，初始化时添加控件，
不适用的可以先隐藏
</code></pre>

<p>5.不要使用ClearColor，无背景色，透明度也不要设置为0</p>

<pre><code>渲染耗时比较长
尽量将view设置为不透明，包括cell本身。
</code></pre>

<p>6.使用局部更新</p>

<pre><code>如果只是更新某组的话，使用reloadSection进行局部更新
</code></pre>

<p>7.加载网络数据，下载图片，使用异步加载，并缓存</p>

<pre><code>如果cell显示的内容来此网络，那么确保这些内容是通过异步来获取的
</code></pre>

<p>8.少使用addView 给cell动态添加view</p>

<p>9.按需加载cell，cell滚动很快时，只加载范围内的cell</p>

<pre><code>注意正确使用懒加载
</code></pre>

<p>10.不要实现无用的代理方法，tableView只遵守两个协议</p>

<pre><code>非必要的代理或者数据源方法可以省略，比如numberofsention
</code></pre>

<p>11.缓存行高：</p>

<pre><code>如果row的高度不相同，那么将其缓存下来
estimatedHeightForRow不能和HeightForRow里面的layoutIfNeed同时存在，这两者同时存在才会出现“窜动”的bug。所以我的建议是：只要是固定行高就写预估行高来减少行高调用次数提升性能。如果是动态行高就不要写预估方法了，用一个行高的缓存字典来减少代码的调用次数即可
</code></pre>

<p>12.避免渐变，图像缩放以及离屏绘制</p>

<p>13.使用shadowPath来设置阴影。</p>

<p>14.使用适当的数据结构来保存需要的信息。不同的结构会带来不同的操作代价。</p>

<p>15.使用rowHeight, sectionFooterHeight 和 sectionHeaderHeight 来设置一个恒定 高度，而不要从delegate中获取。</p>

<hr />

<p>参考：相关性能优化问题</p>

<p><a href="http://www.cocoachina.com/ios/20150408/11501.html">iOS应用性能调优的25个建议和技巧</a></p>
</div>
  
  




| <a href="/blog/2015/11/28/tableviewqia-dun-na-du-bu-shi-shi/#comments">更多评论</a>

    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/2">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
    <h1>文章分类</h1>
    <ul id="categories">
        <li class='category'><a href='/blog/categories/欢迎来到ios梦工厂/'>欢迎来到ios梦工厂 (1)</a></li>
<li class='category'><a href='/blog/categories/程序员必备/'>程序员必备 (1)</a></li>

    </ul>
</section><section>
  <h1>最新文章</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/11/28/iossheng-ming-zhou-qi/">iOS生命周期</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/11/28/chang-lian-jie-and-duan-lian-jie/">长链接&amp;短链接</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/11/28/iosban-ben-gua-pei-wen-ti-(6,7,8,9)/">iOS版本适配问题（6，7，8，9）</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/11/28/blockshen-jiu/">Block深究</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/11/28/zi-ding-yi-xiang-ce-shan-chu-fu-huo-de-shi-xian/">自定义相册删除复活的实现</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/al1020119">@al1020119</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'al1020119',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>




<section>
<h1>扫一扫<abbr title="The word '扫一扫' is a registered trademark of DENSO WAVE INCORPORATED. It applies only for the word '扫一扫', not for image.">&trade;</abbr></h1>
<a href="http://al1020119.github.io/index.html"><img src="http://chart.apis.google.com/chart?chs=150x150&cht=qr&chld=|0&chco=165B94&chl=http://al1020119.github.io/index.html" alt="post-qrcode"></a></section>
<section>
    <h1>访客统计</h1>
    <br/>
    <a href="http://s07.flagcounter.com/more/2SH"><img src="http://s07.flagcounter.com/count/2SH/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_1/flags_0/" alt="Flag Counter" border="0"></a>
</section><section>
    <h1>新浪微博</h1>
    <ul id="weibo">
        <li>
            
            <!-- 在此插入获得的微博秀代码 -->
            <iframe width="100%" height="550" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=550&fansRow=2&ptype=1&speed=0&skin=1&isTitle=1&noborder=1&isWeibo=1&isFans=1&uid=3288975567&verifier=20ffcedd&dpc=1"></iframe>
            
        </li>
    </ul>
</section>
  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - iCocos -
  <span class="credit">Preview in <a href="https://al1020119.github.io">iCocos</a></span>
</p>

</footer>
  






<!--
--->



</body>
</html>
