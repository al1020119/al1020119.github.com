
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>iOS梦工厂</title>
  <meta name="author" content="iCocos">

  
  <meta name="description" content="layout: post
title: &ldquo;逆向工程总结&rdquo;
date: 2016-04-25 13:32:08 +0800
comments: true categories: Summary 不忍心作结，虽然才刚刚开始，很多东西都没有细细总结， &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://al1020119.github.io/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="iOS梦工厂" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">iOS梦工厂</a></h1>
  
    <h2>不战胜自己，何以改变未来！</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="al1020119.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/04/25/nixiangzongjie/">Nixiangzongjie</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-04-25T00:00:00+08:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>25</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>12:00 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><hr />

<p>layout: post
title: &ldquo;逆向工程总结&rdquo;
date: 2016-04-25 13:32:08 +0800
comments: true</p>

<h2>categories: Summary</h2>

<p>不忍心作结，虽然才刚刚开始，很多东西都没有细细总结，只可惜很多东西并非自己想的那么顺利。</p>

<p>才干了一年多的活，就见证了两个项目的死亡，这个世界远远超过自己想象中的残酷。第一个项目只历经一两个版本，无啥感情可言；第二个项目就完完全全经历了诞生到死亡的全过程，若说无感情的话，那我就是彻头彻尾的混蛋了。虽然终结是必然的，但是比预料中的更快更突然。悲剧往往就是在这种感情的强烈碰撞下诞生的。</p>

<p>祸不单行，我丢了我的iPhone。那一刻我真真实实感觉到，失去自己熟悉的亲密的东西的那种无助。若是人，不敢想象。</p>

<p>好在人有着天生的自愈能力。换了新环境已快两月，感觉以前的那些已经过去很久似的，早已渐渐淡忘。新项目的生活紧张而细致，繁密且高精度的工作会让人无暇关注其它。而且，偶尔偶尔的小波澜，比如说某人被离职了，会在你神经绷得更紧更紧。</p>

<p>不过今天，发现那个当时也凝聚了不少心血的app终于上了AppStore，推迟了足足半年有余，惊讶中夹杂着深深的悲凉。当然这不是最让人伤心的。回想起自己后来去搞了越狱版，于是乎就听到了“我的AppStore版”和“你们的越狱版”之类的言语，似乎这个东西当时几个人搞出来，就算被重构至少还有不少头文件还标记着我的名字的东西，已经被彻头彻尾和我无关了。所以，这个东西上了AppStore，似乎我也没资格感到高兴。不，应该是连感到悲哀的权利都没有。</p>

<p>最后，我没有在Appstore下载它，更别说刷一个五星评论了。这个可能还保留着我那些刚学iOS开发而写出来的无比稚嫩的代码的东西，经历了一次次的延期、需求变更，甚至一度被挂起、拆分，最终上了架，可惜连我都觉得，这东西上不上架，已经无啥意义了。</p>

<p>只是偶尔，即使已经不做越狱版了，我还会到BigBoss的统计页面，看看那个只发了四个版本的越狱版，到底被下载了多少次（BigBoss上的统计是对所有人公开的，其它渠道的下载统计等等数据，对我来说基本不可能拿得到）。看到那个数字居然还在缓慢增长，停止更新后居然还能慢慢多了两万多的下载量，嘴角还是轻轻上扬一下。当然，我知道下载量和日活量是两个完全不同的概念，卸载是个很方便的操作，况且那个支持越狱版通过桌面长按卸载deb的功能还是我做的哩。很二逼的需求，我想，这么一个没啥用户基础的软件，居然还提供快捷卸载方法，二到家了。</p>

<p>说说新项目吧。至少这个长期占据AppStore前100名中一席的app，肯定有其牛逼的原因。果不其然，要融入到这个团队之中，我至少需要先脱层皮，不然拉低整个团队的技术水平和智商水准可是不被容忍的。中途有一段时间没活干，还在内疚着没帮上什么忙，最近接连三个版本两两并行，于是就累得跟狗一样了。效率，以及对工作量的估算，对我来说还是个硬伤。</p>

<p>吐槽了半天，没总结半点和越狱开发相关的东西。可能之后会很少接触这些东西了。以此作结，纪念那段偶尔挺二逼但也挺随意的时光。</p>

<p>改bundleid，启动后改掉取bundleid的方法，让它返回的bundle固定为原来那个，然后重签名就可以了</p>

<p>如果不hook那个取bundleid的方法，登录几次就会提示你用的不是正版，然后让你退出登录</p>

<p>不过要我做盗版或多开监测的话，会加上签名验证</p>

<p>不越狱其实也可以做，二进制文件里有个dylb的map，可以差一条记录上去，挂载你自己的动态库。然后把你自己写的用来hook代码的动态库一起签名放到ipa包里安装就行了。不过略麻烦。</p>

<p>使用load command,在mach o的头里,不过也是需求重新签名</p>

<p>bundleid在二进制中也编译的有吧，仅仅改plots</p>

<p>直接改plist就行</p>

<p>bundleid在二进制中也编译的有吧，仅仅改Plist,好像不行</p>

<p>行的，已验证</p>

<p>这么说ipa重签名是可以的，难道苹果只验证plist文件？</p>

<p>不过为了原有代码里面的判断逻辑啥的正常，最好再didfinishlaunch后hook掉NSBundle 的bundleIdentifier，让其返回原来的。</p>

<p>你改为新的bundleid，然后用你自己的证书签名，苹果就当这个app是你写的了</p>

<p>可以用theos写个tweak，然后用runtime想这么玩就随意你了·</p>

<p>主要还是看能不能分析出原有的逻辑。</p>

<p>用theos就得越狱了吧</p>

<p>噗。。。都在问iOS逆向问题，有没有谁了解Android的防逆向的所谓的『加固』处理，原理是什么呢？各加的加固处理效果如何？</p>

<p>逆向的关键只有一句 找到入口</p>

<p>做过别人 app 的分析,主要 reveal 分析 view 解构，猜测对方怎么做的效果。。。</p>

<p>reveal神器，用越狱的手机+插件来拖界面</p>

<p>然后 dump 二进制文件，可以看别人在一些地方用到了什么库</p>

<p>应该只能逆向出oc的头文件，不能逆向出m文件吧？</p>

<p>另外用 cocoapod 的可以从 dump 的头文件看得出来，因为，每个 pod 都有一个 dummy class[偷笑]一下就知道对方用了什么库了</p>

<p>嗯嗯，是的，不过可以反汇编，其实 hopper 给出来的反汇编代码已经有很大帮助了</p>

<p>reveal只能看到界面相关的东西,分析界面用的,要是想把别人的逻辑都搞清楚还是挺费劲的。了解个大体还行。</p>

<p>全部逻辑搞清楚的话，其实很费劲的。。。</p>

<p>不过找关键逻辑，或者想要的东西的话，还可以了</p>

<p>现在好多https请求是单向验证，一个charles就搞定接口了</p>

<p>之前搞雅虎天气找他们地图图片怎么做的</p>

<p>最无语的是搞金融的都不加双向验证</p>

<p>我们在接口上现在HTTPS+参数加密</p>

<p>不过对于普通抓包还是够了，一开始还用zlib压缩了一层，然后发现安卓会有问题，就放弃zlib只用gzip简单压了一下</p>

<p>大家开发的时候后天接口地址是不是都放在头文件里面？地址都放在.m里面了.不过抓包跟踪一下也差不多能抓出来</p>

<p>我们通信用的ice</p>

<p>reveal感觉用得比较舒服就是调试辅助，例如找别人写的view的名字</p>

<p>用过找别人是用啥控件,唯一设备ID没啥好研究的吧,或者取出指针</p>

<p>哈哈哈，找别人用的控件我也干过。。。Reveal抓出来一看，原来也是用的第三方的View，在github上就找到了。。。</p>

<p>例如一个feed流里一个用户的头像不相似了，想看下用户头像的地址是不是有问题，就直接选中对应imageview，然后看地址，进到xcode里暂停，直接打po [0xxxxxxxxx url] 就好了</p>

<p>url还是sd_url了···忘记了···啊哈哈哈哈哈··反正这个原理···</p>

<p>@飞宇。 有啊，我是做广告相关的。大家拿出去钱砸广告新增用户就是按照这个排重的。idfa可以更改，很多刷榜公司就是靠假良骗钱的。</p>

<p>不是，是反设备清洗,防止一台设备伪造出成千上万设备</p>

<p>这不还有IP可查么</p>

<p>你可能花100w做了100w新增用户，其实是用一台设备搞出来的</p>

<p>ip也可以用vpn自动刷新，没听过刷榜公司么！之前积分墙火的时候，淘宝上一搜一大把。</p>

<p>开发相关的安全问题，除了代码安全，资源文件安全，接口安全，还有什么没？</p>

<p>人员安全？比如别把代码上传到Github里</p>

<p>最主要是别把各种 key 传 github 了，以及自建的 git 的访问权限控制好</p>

<p>别人家的app怎么在xcode里暂停调试呢？之家的···调试别人家的bug干啥···别人家的用lldbserver挂上去，也能断点</p>

<p>因为看到你前面说reveal配合调试imageview了</p>

<p>那个是调试自家的APP时用</p>

<p>ssh+debugserver是能调试 但是不太方便 有没有更好用的工具？iPhoneTunnel</p>

<p>还有一个办法，不过我试了下新版，好像经常卡死，不晓得现在还没好，你可以试试
给你截图</p>

<p>竟然截不了图了············直接说把，直接用xcode的attach proce</p>

<p>想问一下，从iOS8.4后，还有什么方法可以访问到非越狱机子的Document目录吗？</p>

<p>刚才那个方法想成功attch上，得给个啥东西来着··竟然一时想不起来了···</p>

<p>是不是要给debugserver重签名</p>

<p>给大家再说个大家可能不知道的tips，iOS5后用rvictl可以把iPhone的网卡虚拟到mac上，然后···你懂的···</p>

<p>估计现在在非越狱机子上非常难做到了。 毕竟iOS8.4后对沙盒的权限限制较大</p>

<p>iExplorer可以部分备份指定app，间接访问到document目录</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/04/20/weixinjiqiren/">微信机器人</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-04-20T13:32:08+08:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>20</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>1:32 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p> 基于iOS逆向工程的微信机器人</p>

<p>本文转自猫头鹰团队</p>

<p>推荐序</p>

<blockquote><p>本文的作者沙梓社和吴航共同编写了《 iOS 应用逆向工程》，文章中介绍的是一些基本的 iOS 领域的安全知识，但是由于普及不够，基本上没有被人们重视，希望本文能让大家重视到 iOS 的源代码安全问题。</p></blockquote>

<p>另外预告一下，我认识的一个做移动安全的白帽子即将公开一个在非越狱手机上通过 App 绕过 sandbox 的 iOS 漏洞视频，并且计划发布一系列 iOS 系统安全方面的文章。我争取到了授权，并在我的公众号上同步发表这些文章，敬请期待：）</p>

<p>以下是文章正文，略有调整。</p>

<p>讲师介绍-沙梓社</p>

<ul>
<li>湖北武汉人，《iOS 应用逆向工程》系列图书的作者，在 Cydia（最大的越狱 iOS 商店）上有 11 款独立作品，接受过 CSDN 的专访，书的英文版在 GitHub 上开源后收获了 2600+ stars，是首位在 WWJC 上发表演讲的中国人，以「提升中国 iOS 开发者在国际上的地位」为己任。</li>
</ul>


<p>在很多朋友的眼里，iOS 逆向工程是一个小众、神秘的方向，为什么我会选择这个小众的方向呢？这要从我最喜欢的一首诗说起。第一次，我是在李开复的自传《世界因你不同》里看到这首诗，当时就感觉身心得到了非常强烈的震撼：</p>

<p><img src="/images/nixiangjiqiren001.jpg" title="Caption" ></p>

<p>因为我感觉到自己就是这类人：如果有两条路给我选，我确实会选更少人走的那一条。我发现自己是一个刻意保持自己跟别人不同的人。</p>

<p>在初次读到这首诗时，我还没有开始学习 iOS。在从事 iOS 方面的研究后，又从乔帮主亲自配音的广告中寻找到了灵感，发现苹果跟我的价值观非常一致，就是要追求不同。因此，我更加认定 iOS 就是我的主攻方向。</p>

<p><img src="/images/nixiangjiqiren002.jpg" title="Caption" ></p>

<p>我的成长之路，就是一条与众不同的未选之路：别人都在学「大众情人」Windows 时，我开始学「小众路人」iOS；别人都在学 iOS 正向开发时，我开始学 iOS 逆向工程。正是因为追求不同，我写的《iOS 应用逆向工程》成为了全球唯一一本 iOS 逆向相关书籍，而且有美国和韩国的出版社想要引进本书，打破了中国 iOS 知识产权零输出的尴尬纪录。我用自己的努力代表中国 iOS 开发者在国际上发声，而且为 iOS 主流社区所认可，作为中国人我感到非常自豪。</p>

<p>简单来说，我所研究的，主要是 iOS 应用层的逆向工程，对内核层的逆向工程只是稍有涉猎，没有入门。应用层的逆向工程，我感觉自己玩得差不多了，应用层的所有逆向工程相关问题，都可以用我那本书上介绍过的知识和技术得到解决，我觉得没有太大挑战性了，主要是劳动量问题。到了这个地步，我的规划主要分为 2 个方向：</p>

<p>继续从事内核研究，这个方向的终点是「越狱」（越狱即通过漏洞利用拿到iOS的root权限，代表了iOS技术研究的最高境界）；</p>

<p>换个脑子，用一些非技术能力武装自己，让自己成为一专多能的人才。这个方向的终点就是创业。</p>

<p>当然，很多朋友会问，IT 人员创业的普遍做法，都是去 BAT 这样的互联网公司干 2 年，观察一下他们的玩法，然后拉一个团队出来干。你问啥不这么干呢？主要是碰到了一个很好的项目。大公司一直都在那里，想什么时候去都可以；而好项目却不常有，机会过去就过去了，不等人，所以我在准备并不算充分的情况下选择了创业这条路。</p>

<p>交代完了我的背景，咱们可以进入正题了😁</p>

<p><img src="/images/nixiangjiqiren003.jpg" title="Caption" ></p>

<p>大意是「通过研究现有功能的实现原理，理解并融会贯通，在此基础上实现（甚至增强）这个功能。」也就是说，不是照猫画虎，而是师夷长技，「借刀杀人」。</p>

<p>在我的理解里，逆向工程是一种工程师式的高级思维方式。给你水、面粉、糖、芝麻，让你做烧饼，这是正向工程；给你一个烧饼，让你分析出它是由多少水、多少面粉、多少糖、多少芝麻组成的，这是逆向工程。也就是说，根据图纸制作实物的这个过程是正向工程，而根据实物倒推图纸的这个过程则是逆向工程。乔布斯曾说「Good artists copy; Great artists steal.」逆向工程有异曲同工之妙。</p>

<p>举几个通过逆向工程师夷长技的例子：</p>

<p><img src="/images/nixiangjiqiren004.jpg" title="Caption" ></p>

<p>通过逆向工程分析instagram滤镜算法。一个人可以“steal”一个滤镜算法团队的工作成果；</p>

<p>研究微信的网络传输协议，就像@58沈剑 在博客里说到的那样。就我目前对微信九牛一毛的研究来说，就已经发现了一处可以进一步节省流量的地方，但是估计是因为历史遗留问题，这块代码不好动；</p>

<p>看看1Password做了哪些防护。1Password是专门用于保存密码的，类似于保险柜，安全系数必须很高，它把我们的密码存在了哪里，通过什么方式加密？这些都是值得我们学习借鉴的地方。</p>

<p>除了去学习别人的长处，逆向工程还可以发现自己和别人的短处：</p>

<p><img src="/images/nixiangjiqiren005.jpg" title="Caption" ></p>

<p>这种低级错误，星巴克可以犯，但1Password不能犯；这取决于你的产品定位。这个错误当然是通过逆向工程发现的。</p>

<p>这是某世界500强企业犯的，通过HTTP协议明文传输用户手机和密码的低级错误：</p>

<p><img src="/images/nixiangjiqiren006.jpg" title="Caption" ></p>

<p>这是某突破3亿用户的移动App：</p>

<p><img src="/images/nixiangjiqiren007.jpg" title="Caption" ></p>

<p>把传输协议的密钥硬编码在代码里，有逆向工程基础的朋友可以轻松还原整套网络传输协议。淘宝上一堆堆的这个刷榜那个刷赞，就是这个原理。</p>

<p>阿凹(猫友会吉祥物，一个微信机器人)，是「借刀杀人」最典型的运用之一：</p>

<p><img src="/images/nixiangjiqiren008.jpg" title="Caption" ></p>

<p>阿凹的实现原理，简单说，就是通过逆向工程的方式找出微信iOS客户端的收发信息等私有接口，然后基于自己的逻辑调用这些接口，实现针对特殊事件的自动化应答功能。</p>

<p>我个人最常用的iOS逆向工程工具主要有这些：</p>

<p><img src="/images/nixiangjiqiren009.jpg" title="Caption" ></p>

<ol>
<li><p>dumpdecrypted：将苹果加过密的App砸壳。通过AppStore处理的App，都是加过密的，不能直接进行二进制分析，需要先解秘，业界称为「砸壳」。它的原理是等App完全加载进内存，得到解密后，再把解密过的内存给dump出来，形成解密后的二进制文件，可以直接分析。</p></li>
<li><p>class-dump：导出MachO文件里的ObjC类及方法定义。因为ObjC是一门强烈依赖于运行时的语言，它的文件类型是MachO（类比于Windows里的PE文件类型），MachO里存放了大量运行时需要用到的信息，从中可以收集整理，还原出一个App源代码里的ObjC头文件。</p></li>
<li><p>CydiaSubstrate：将第三方动态库注入进程。它是越狱插件的存在前提。在iOS开机时，会把特定目录下的所有库，给加载到指定的进程里，俗称「hook」或「钩子」。</p></li>
<li><p>Cycript：用JS语法写ObjC方法。这是Cydia之父Saurik发明的一门语言，我个人主要用它来测试私有函数。</p></li>
<li><p>Theos：越狱插件开发工具。是我的书序作者DHowett开发的。iOS正向开发用Xcode，逆向开发用Theos。</p></li>
<li><p>IDA：全平台反汇编、反编译工具。搞技术的一般都听说过这个软件，就不多介绍了。</p></li>
<li><p>Hopper：OSX反汇编、反编译工具。比IDA便宜了1000倍，但功能跟IDA差不多；主攻苹果系操作系统。</p></li>
<li><p>debugserver + LLDB：动态调试器。是大名鼎鼎的「苹果版」GDB。</p></li>
</ol>


<p>class-dump的效果，图中显示的是新浪微博App的所有头文件：</p>

<p><img src="/images/nixiangjiqiren010.jpg" title="Caption" ></p>

<p>Cycript的效果，可以看到微信星号密码的明文：</p>

<p><img src="/images/nixiangjiqiren011.jpg" title="Caption" ></p>

<p>Theos开发插件的运行效果：</p>

<p><img src="/images/nixiangjiqiren012.jpg" title="Caption" ></p>

<p>所有进程的[NSDictionary dictionaryWithContentsOfFile:]方法均被「hook」，可以随意篡改。</p>

<p>IDA的效果：</p>

<p><img src="/images/nixiangjiqiren013.jpg" title="Caption" ></p>

<p>对于熟悉汇编语言（图里是ARM汇编）的朋友来说，所有未加密的二进制文件，均等同于开源。这是什么概念，做技术的都懂。</p>

<h6>接下来我简单介绍下阿凹的制作流程：</h6>

<p>核心在于找到收发微信消息的函数，然后加以修改利用：</p>

<p><img src="/images/nixiangjiqiren014.jpg" title="Caption" ></p>

<p>用dumpdecrypted给微信砸壳，解密出的文件近50M：</p>

<p><img src="/images/nixiangjiqiren015.jpg" title="Caption" ></p>

<p>class-dump出微信的所有头文件，近7000个：</p>

<p><img src="/images/nixiangjiqiren016.jpg" title="Caption" ></p>

<ul>
<li><p>定位到收消息的View，进而定位到V对应的C，找出逻辑层的收消息函数。</p></li>
<li><p>定位到发消息的按钮（也是一个View），进而定位到对应的C，找出逻辑层的发消息函数（这个过程没法用截图表现出来，所以我只简单描述下）。</p></li>
</ul>


<p>组合收发函数，完成阿凹的逻辑，最后写代码：</p>

<p><img src="/images/nixiangjiqiren017.jpg" title="Caption" ></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/04/15/qudongkaifa/">驱动开发</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-04-15T13:32:08+08:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>15</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>1:32 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h4>一、系统架构</h4>

<p><img src="/images/nixiangqudong001.png" title="Caption" ></p>

<p>我们编写的驱动一般运行在i/o Kit框架下。</p>

<h4>二、一些记录</h4>

<ul>
<li>开发工具 xcode</li>
<li>开发语言：c++, c</li>
</ul>


<p>c++用的是嵌入式c++，是标准c++的子集。</p>

<p>所以，stl、异常、多重继承、模板和runtime类型信息  都无法使用。</p>

<p>因为这些东西会导致编译出来的文件很大，且容易导致问题。</p>

<p>c++只能编写基于i/o Kit框架的驱动，而c语言则可以编写任意的驱动。</p>

<p>并且c++的驱动反汇编后很难看。</p>

<blockquote><p>所以写驱动还是用c吧。这一点和微软默认的一样。</p></blockquote>

<h4>三、编写一个驱动例子</h4>

<ol>
<li>创建工程</li>
</ol>


<p><img src="/images/nixiangqudong002.png" title="Caption" ></p>

<p>因为不是设备驱动，只能选择extension；如果是设备驱动，则选择IOKit Driver。</p>

<ol>
<li>写代码</li>
</ol>


<p><img src="/images/nixiangqudong003.png" title="Caption" ></p>

<p>苹果将studio.h这样的c++库换成了自己的libkern.h。</p>

<ol>
<li>添加引用库
因为代码中使用了libkern.h，所以要修改工程。</li>
</ol>


<p><img src="/images/nixiangqudong004.png" title="Caption" ></p>

<ol>
<li>驱动入口</li>
</ol>


<p><img src="/images/nixiangqudong005.png" title="Caption" ></p>

<ol>
<li><p>编译驱动</p></li>
<li><p>在xcode的product菜单里点击build就可以编译驱动了。</p></li>
<li>xcode只是能编辑和编译驱动，无法调试驱动的。</li>
<li>编译驱动时，你需要有一个开发者账号，否则编译不过。</li>
<li>我没有账号，所以后面的操作无法进行，只能把书上的翻译过来。</li>
</ol>


<p>6、运行驱动有2种方式：</p>

<ul>
<li>1、拷贝驱动文件到目录 /system/library/extensions下，重启后自动运行；</li>
<li><p>2、在terminal中运行命令启动驱动：</p>

<ul>
<li>sudo chown -R root:wheel 驱动名.kext   // 设置驱动文件的权限，如果有权限，这步可省略。
sudo kextload 驱动名.kext  // 运行驱动</li>
</ul>
</li>
<li><p>卸载驱动：sudo kextunload 驱动名.kext</p></li>
<li><p>显示当前系统中的驱动：kextstat</p></li>
</ul>


<p><img src="/images/nixiangqudong006.png" title="Caption" ></p>

<ol>
<li>查看调试信息
printf输出的信息是保存在磁盘上的log文件中。通过tail和cat命令就可以查看。log文件在/var/log/kernel.log或者/Applications/Utilities目录下。</li>
</ol>


<p><img src="/images/nixiangqudong007.png" title="Caption" ></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/04/10/nixiangzhifubao/">逆向支付宝</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-04-10T13:32:08+08:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>10</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>1:32 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>为了了解支付宝app的源码结构，我们可以使用class-dump-z工具来分析支付宝二进制。
1.下载配置class_dump_z</p>

<p>前往 <a href="https://code.google.com/p/networkpx/wiki/class_dump_z">https://code.google.com/p/networkpx/wiki/class_dump_z</a> ，下载tar包，然后解压配置到本地环境</p>

<p>$ tar -zxvf class-dump-z_0.2a.tar.gz<br/>
$ sudo cp mac_x86/class-dump-z /usr/bin/
2.class_dump支付宝app
$ class-dump-z Portal > Portal-dump.txt</p>

<p>@protocol XXEncryptedProtocol_10764b0<br/>
-(?)XXEncryptedMethod_d109df;<br/>
-(?)XXEncryptedMethod_d109d3;<br/>
-(?)XXEncryptedMethod_d109c7;<br/>
-(?)XXEncryptedMethod_d109bf;<br/>
-(?)XXEncryptedMethod_d109b8;<br/>
-(?)XXEncryptedMethod_d109a4;<br/>
-(?)XXEncryptedMethod_d10990;<br/>
-(?)XXEncryptedMethod_d1097f;<br/>
-(?)XXEncryptedMethod_d10970;<br/>
-(?)XXEncryptedMethod_d10968;<br/>
-(?)XXEncryptedMethod_d10941;<br/>
-(?)XXEncryptedMethod_d10925;<br/>
-(?)XXEncryptedMethod_d10914;<br/>
-(?)XXEncryptedMethod_d1090f;<br/>
-(?)XXEncryptedMethod_d1090a;<br/>
-(?)XXEncryptedMethod_d10904;<br/>
-(?)XXEncryptedMethod_d108f9;<br/>
-(?)XXEncryptedMethod_d108f4;<br/>
-(?)XXEncryptedMethod_d108eb;<br/>
@optional<br/>
-(?)XXEncryptedMethod_d109eb;<br/>
@end</p>

<p>查看得到的信息是加过密的，这个加密操作是苹果在部署到app store时做的，所以我们还需要做一步解密操作。
3.使用Clutch解密支付宝app</p>

<p>1）下载Clutch
iOS7越狱后的Cydia源里已经下载不到Clutch了，但是我们可以从网上下载好推进iPhone
地址：Clutch传送门</p>

<p>2）查看可解密的应用列表</p>

<p>root</p>

<h1>./Clutch</h1>

<p>Clutch-1.3.2<br/>
usage: ./Clutch [flags] [application name] [&hellip;]<br/>
Applications available: 9P_RetinaWallpapers breadtrip Chiizu CodecademyiPhone FisheyeFree food GirlsCamera IMDb InstaDaily InstaTextFree iOne ItsMe3 linecamera Moldiv MPCamera MYXJ NewsBoard Photo Blur Photo Editor PhotoWonder POCO相机 Portal QQPicShow smashbandits Spark tripcamera Tuding_vITC_01 wantu WaterMarkCamera WeiBo Weibo</p>

<p>3）解密支付宝app</p>

<p>root# ./Clutch Portal</p>

<p>Clutch-1.3.2<br/>
Cracking Portal&hellip;<br/>
Creating working directory&hellip;<br/>
Performing initial analysis&hellip;<br/>
Performing cracking preflight&hellip;<br/>
dumping binary: analyzing load commands<br/>
dumping binary: obtaining ptrace handle<br/>
dumping binary: forking to begin tracing<br/>
dumping binary: successfully forked<br/>
dumping binary: obtaining mach port<br/>
dumping binary: preparing code resign<br/>
dumping binary: preparing to dump<br/>
dumping binary: ASLR enabled, identifying dump location dynamically<br/>
dumping binary: performing dump<br/>
dumping binary: patched cryptid<br/>
dumping binary: writing new checksum<br/>
Censoring iTunesMetadata.plist&hellip;<br/>
Packaging IPA file&hellip;</p>

<p>compression level: 0<br/>
    /var/root/Documents/Cracked/支付宝钱包-v8.0.0-(Clutch-1.3.2).ipa</p>

<p>elapsed time: 7473ms</p>

<p>Applications Cracked: <br/>
Portal</p>

<p>Applications that Failed:</p>

<p>Total Success: 1 Total Failed: 0</p>

<p>4）导出已解密的支付宝app</p>

<p>从上一步骤得知，已解密的ipa位置为：/var/root/Documents/Cracked/支付宝钱包-v8.0.0-(Clutch-1.3.2).ipa
将其拷贝到本地去分析</p>

<p>4.class_dump已解密的支付宝app</p>

<p>解压.ipa后，到 支付宝钱包-v8.0.0-(Clutch-1.3.2)/Payload/Portal.app 目录下，class_dump已解密的二进制文件
1</p>

<p>$ class-dump-z Portal > ~/Portal-classdump.txt</p>

<p>这回就可以得到对应的信息了：</p>

<p>@protocol ALPNumPwdInputViewDelegate <NSObject><br/>
-(void)onPasswordDidChange:(id)onPassword;<br/>
@end</p>

<p>@protocol ALPContactBaseTableViewCellDelegate <NSObject><br/>
-(void)shareClicked:(id)clicked sender:(id)sender;<br/>
@end</p>

<p>@interface MMPPayWayViewController : XXUnknownSuperclass &lt;SubChannelSelectDelegate, UITableViewDataSource, UITableViewDelegate, CellDelegate, UIAlertViewDelegate> {<br/>
@private<br/>
    Item<em> channelSelected;<br/>
    BOOL <em>bCheck;<br/>
    BOOL </em>bOpenMiniPay;<br/>
    BOOL <em>bNeedPwd;<br/>
    BOOL </em>bSimplePwd;<br/>
    BOOL <em>bAutopayon;<br/>
    BOOL </em>bHasSub;<br/>
    BOOL <em>bFirstChannel;<br/>
    BOOL </em>bChangeSub;<br/>
    BOOL _bClickBack;<br/>
    UITableView</em> <em>channelListTableView;<br/>
    NSMutableArray* </em>channelListArray;<br/>
    NSMutableArray<em> _subChanneSelectedlList;<br/>
    NSMutableArray</em> <em>unCheckArray;<br/>
    UIButton* </em>saveButton;<br/>
    UILabel<em> _tipLabel;<br/>
    MMPPasswordSwichView</em> <em>payWaySwitch;<br/>
    MMPPopupAlertView* </em>alertView;<br/>
    UIView<em> <em>setView;<br/>
    int </em>originalSelectedRow;<br/>
    int _currentSelectedRow;<br/>
    NSString</em> <em>statusCode;<br/>
    ChannelListModel* </em>defaultChannelList;<br/>
}<br/>
@property(assign, nonatomic) BOOL bClickBack;<br/>
@property(retain, nonatomic) ChannelListModel<em> defaultChannelList;<br/>
@property(retain, nonatomic) NSString</em> statusCode;<br/>
@property(assign, nonatomic) int currentSelectedRow;<br/>
@property(assign, nonatomic) int originalSelectedRow;<br/>
@property(retain, nonatomic) UIView<em> setView;<br/>
@property(retain, nonatomic) MMPPopupAlertView</em> alertView;<br/>
@property(retain, nonatomic) MMPPasswordSwichView<em> payWaySwitch;<br/>
@property(assign, nonatomic, getter=isSubChannelChanged) BOOL bChangeSub;<br/>
@property(assign, nonatomic) BOOL bFirstChannel;<br/>
@property(assign, nonatomic) BOOL bHasSub;<br/>
@property(assign, nonatomic) BOOL bAutopayon;<br/>
@property(assign, nonatomic) BOOL bSimplePwd;<br/>
@property(assign, nonatomic) BOOL bNeedPwd;<br/>
@property(assign, nonatomic) BOOL bOpenMiniPay;<br/>
@property(assign, nonatomic) BOOL bCheck;<br/>
@property(retain, nonatomic) UILabel</em> tipLabel;<br/>
@property(retain, nonatomic) UIButton<em> saveButton;<br/>
@property(retain, nonatomic) NSMutableArray</em> unCheckArray;<br/>
@property(retain, nonatomic) NSMutableArray<em> subChanneSelectedlList;<br/>
@property(retain, nonatomic) NSMutableArray</em> channelListArray;<br/>
@property(retain, nonatomic) UITableView* channelListTableView;<br/>
-(void).cxx_destruct;<br/>
-(void)subChannelDidSelected:(id)subChannel;<br/>
-(void)switchCheckButtonClicked:(id)clicked;<br/>
-(void)checkboxButtonClicked:(id)clicked;<br/>
-(void)onCellClick:(id)click;<br/>
-(void)showSubChannels;<br/>
-(void)tableView:(id)view didSelectRowAtIndexPath:(id)indexPath;<br/>
-(id)tableView:(id)view cellForRowAtIndexPath:(id)indexPath;<br/>
-(int)tableView:(id)view numberOfRowsInSection:(int)section;<br/>
-(float)tableView:(id)view heightForRowAtIndexPath:(id)indexPath;<br/>
-(int)numberOfSectionsInTableView:(id)tableView;<br/>
-(void)setTableViewFootView:(id)view;<br/>
-(void)setTableViewHeaderView:(id)view;<br/>
-(id)tableView:(id)view viewForHeaderInSection:(int)section;<br/>
-(id)tableView:(id)view viewForFooterInSection:(int)section;<br/>
-(float)tableView:(id)view heightForHeaderInSection:(int)section;<br/>
-(float)tableView:(id)view heightForFooterInSection:(int)section;<br/>
-(void)alertView:(id)view clickedButtonAtIndex:(int)index;<br/>
-(void)clickSave;<br/>
-(void)netWorkRequestWithPwd:(id)pwd;<br/>
-(void)setPayWaySwitchStates:(id)states;<br/>
-(void)changePayWaySwitch:(id)aSwitch;<br/>
-(void)scrollToSelectedRow;<br/>
-(void)didReceiveMemoryWarning;<br/>
-(void)viewDidLoad;<br/>
-(void)applicationEnterBackground:(id)background;<br/>
-(void)dealloc;<br/>
-(void)goBack;<br/>
-(BOOL)isChannelsSetChanged;<br/>
-(id)subChannelCode:(int)code;<br/>
-(id)subChannelDesc:(int)desc;<br/>
-(id)initWithDefaultData:(id)defaultData;<br/>
-(id)initWithNibName:(id)nibName bundle:(id)bundle;<br/>
-(void)commonInit:(id)init;<br/>
@end
5.分析支付宝源码片段</p>

<p>1）使用了@private关键字限制成员访问权限
但是实际上，在Objective-C编程中，使用@private连Keypath访问都拦不住的</p>

<p>2）抛出了冗长的成员对象
这非常有利分析程序结构
6.进一步思考</p>

<p>1）如何利用 class-dump 结果，结合 cycript 进行攻击呢？
2）class-dump-z 如此强大，有什么方法可以减少暴露的信息吗？</p>

<p>接下来的博文将针对上面的思考，继续总结～</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/04/05/fei6sshixian3dtouch/">非6S-实现3D Touch</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-04-05T13:32:08+08:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>5</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>1:32 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>首先先给我这困难的语言表达能力道个歉哈，真的尽力了。
本章排版是参照<a href="http://bbs.pediy.com/showthread.php?t=205133%E5%A4%A7%E7%A5%9E%E7%9A%84%E6%9D%A5%E6%8E%92%E7%9A%84%EF%BC%8C%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%86%99%E5%BF%83%E5%BE%97%E6%96%87%EF%BC%8C%E4%B9%9F%E6%8A%8A%E6%89%80%E5%AD%A6%E5%88%B0%E7%9A%84%E5%88%86%E4%BA%AB%E7%BB%99%E5%A4%A7%E5%AE%B6">http://bbs.pediy.com/showthread.php?t=205133%E5%A4%A7%E7%A5%9E%E7%9A%84%E6%9D%A5%E6%8E%92%E7%9A%84%EF%BC%8C%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%86%99%E5%BF%83%E5%BE%97%E6%96%87%EF%BC%8C%E4%B9%9F%E6%8A%8A%E6%89%80%E5%AD%A6%E5%88%B0%E7%9A%84%E5%88%86%E4%BA%AB%E7%BB%99%E5%A4%A7%E5%AE%B6</a></p>

<p>最近才接触不久的逆向工程,刷夜,爆肝,把《iOS应用逆向工程》这本书的工具，全部看了一遍，并且尝试了一遍，感觉需要点什么。 那就是实践！  最近6s手机出了3DTouch，无奈手中没有这款机型，恰好最近对逆向小有心得，又听说过已经有插件能实现同样的需求，证明确实有可行性，于是开动。根据点击的判断和出现，初步感觉，这应该不需要多少行代码就能搞定，应该只要添加一个手势，或者是更改一个手势的点击事件，让系统认为发生了3DTouch点击事件，就可以了。</p>

<ul>
<li>所需工具: cycript，openSSH，class-dump</li>
<li>测试环境：iOS9.0.2，iPhone5s</li>
<li>备注：因为自身没有3DTouch，所以需要下载一个插件，让机器拥有3DTouch功能，我使用的是forcy，通过覆盖长按手势，实现</li>
</ul>


<p>通过查阅官方文档，得到关键词  Shortcut Menu peek pop
这个词将来就是要在找关键方法时刻所要用到的</p>

<h4>现在开始！</h4>

<p>通过ssh连接到手机，然后将cycript注入到SpringBoard</p>

<pre><code>huangjipingde-iPhone:~ root# cycript -p SpringBoard
</code></pre>

<p>首先 先隆重介绍1个方法，2个函数</p>

<ul>
<li>1方法 [view recursiveDescription]  该方法可以当做是Reveal的文字版，用来查看当前页面的布局</li>
<li><p>2函数，原理均是runtime，但是第二个没有怎么看懂。。。</p></li>
<li><p>printMethods 打印出该类所有的方法，后边接的是实现的地址,在这儿补充一下，如果想对某个方法打断点，但是又不想使用ida查看方法偏移，可以直接在这实现的地址处，添加断点，虽然不知道断在什么地方，但是可以肯定一定是在执行该方法的时候。效果如下图：</p></li>
</ul>


<p>代码:</p>

<pre><code>function printMethods(className){
var count = new new Type("I");
var methods = class_copyMethodList(objc_getClass(className),count);
var methodsArray = [];
for (var i = 0; i &lt; *count; i++){
var method = methods[i];
methodsArray.push({selector:method_getName(method), implentation:method_getImplementation(method)});
}
free(methods);
free(count);
return methodsArray;
}
</code></pre>

<p><img src="/images/nixiangqudong001.png" title="Caption" ></p>

<ol>
<li><p>tryPrintIvars打印出对象所有的属性，效果如下图：
代码:</p>

<p>  function tryPrintIvars(a){
  var x={};
  for(i in <em>a){
  try{
  x[i] = (</em>a)[i];
  } catch(e){}
  }
   return x;}</p></li>
</ol>


<p><img src="/images/nixiangqudong002.png" title="Caption" ></p>

<p>准备工作都做好了，将两个函数都先输入进去</p>

<p><img src="/images/nixiangqudong003.png" title="Caption" ></p>

<p>因为最后的目标是应用图标，所以，现在我们从主界面开始着手打印它的UI布局
代码:</p>

<pre><code>[[UIApplication sharedApplication].keyWindow.rootViewController.view recursiveDescription]
</code></pre>

<p><img src="/images/nixiangqudong004.png" title="Caption" ></p>

<p>然后出来了一大片，红呦呦的代码，看着都眼睛疼，4点钟时看得眼睛都瞎了啊。此时应想，主界面可以滚动，是一个scrollView，是scrollView就得有contentSize，然后一看手机的页面，总共有5页，由于5s机型的宽度是320，所以这时候可以大胆猜测它的contentSize的最大宽度是1600，然后commond+F大法</p>

<p><img src="/images/nixiangqudong005.png" title="Caption" ></p>

<p>准确命中，同时，还注意到，它的contentOffset是960又此时我的页面正是第4页，基本锁定目标，查找frame的坐标是960，0的view，此时可以得到大量信息了，SBRootIconListView，这个就是用来装一页所有图标的View，SBIconListModel这个里边，我猜是装了该view里边的模型信息，注意，11 icons，正好是我们页面所有的图标数，此时再看后边SBIconView的size 62，62  这和图标尺寸的差距只有2个点，基本锁定，它就是我们要找的目标</p>

<p><img src="/images/nixiangqudong006.png" title="Caption" ></p>

<ul>
<li><p>此时，让我们找到是什么在处理SBIconView的事件，我们所知道的，view一般是用来展示的，事件的发生一般都会交给代理来负责。让我们使用nextResponder，或者寻找他们的代理，来定位到一个controller文件，很幸运，直接一步就找到了，就是它：SBIconController！</p></li>
<li><p>此时，我们可以class-dump出SpringBoard的头文件了，去查看一下它的里边都有些什么方法和属性，如果想偷懒，去github直接搜索也行。。。
根据关键词和方法名译的意思大致锁定出来以下几个方法</p></li>
</ul>


<p>ps：  这儿的char 是BOOL类型
代码:</p>

<pre><code>-(void)_handleShortcutMenuPeek:(id)arg1 ;
-(SBApplicationShortcutMenu *)presentedShortcutMenu;
-(char)_canRevealShortcutMenu;
-(id)_aggregateLoggingAppKeyForShortcutMenu:(id)arg1 ;
-(void)applicationShortcutMenu:(id)arg1 activateShortcutItem:(id)arg2 index:(int)arg3 ;
-(void)applicationShortcutMenu:(id)arg1 startEditingForIconView:(id)arg2 ;
-(void)applicationShortcutMenu:(id)arg1 launchApplicationWithIconView:(id)arg2 ;
-(void)applicationShortcutMenuDidPresent:(id)arg1 ;
-(void)_revealMenuForIconView:(id)arg1 presentImmediately:(char)arg2 ;
</code></pre>

<p>自己写一个tweak，hook所有的这些函数，给他们所有的实现之前加上一个NSLog（），查看调用的顺序，和传进来的值的类型。 以及一次Peek事件所关联到了哪些方法。
代码:</p>

<pre><code>%hook SBIconController

- (void)_revealMenuForIconView:(id)arg1 presentImmediately:(BOOL)arg2 {
NSLog(@"ZZT3D _revealMenuForIconView:arg1:%s,%@--arg2:%c",object_getClassName(arg1), arg1, arg2);
    %orig;
}

- (void)_handleShortcutMenuPeek:(id)arg1
{
NSLog(@"ZZT3D _handleShortcutMenuPeek:%s,%@",object_getClassName(arg1),arg1);
%orig;
}

-(char)_canRevealShortcutMenu
{
NSLog(@"ZZT3D _canRevealShortcutMenu");
  return %orig;
}
-(id)_aggregateLoggingAppKeyForShortcutMenu:(id)arg1{

 NSLog(@"ZZT3D ggregateLoggingAppKeyForShortcutMenu:%s,%@",object_getClassName(arg1),arg1);
    return %orig;
}

-(void)applicationShortcutMenu:(id)arg1 activateShortcutItem:(id)arg2 index:(int)arg3
{
NSLog(@"ZZT3D activateShortcutItem:arg1%s,%@—arg2%s,%@--arg3:%d",object_getClassName(arg1),arg1,object_getClassName(arg2),arg2,arg3);
%orig;
}


-(void)applicationShortcutMenu:(id)arg1 startEditingForIconView:(id)arg2 {
NSLog(@"ZZT3D startEditingForIconView:arg1%s,%@—arg2%s,%@",object_getClassName(arg1),arg1,object_getClassName(arg2),arg2);
%orig;

}
-(void)applicationShortcutMenu:(id)arg1 launchApplicationWithIconView:(id)arg2{
NSLog(@"ZZT3D launchApplicationWithIconView:arg1%s,%@—arg2%s,%@",object_getClassName(arg1),arg1,object_getClassName(arg2),arg2);
%orig;
}

-(void)applicationShortcutMenuDidPresent:(id)arg1{
NSLog(@"ZZT3D applicationShortcutMenuDidPresent:%s,%@",object_getClassName(arg1),arg1);
%orig;
}

%end
</code></pre>

<p>此时我们拿手机进行一次长按操作，使其弹出ShotcutMenu菜单，然后在openSSH中查看系统日志grep ZZT3D /var/log/syslog查看一下，该事件处理分别使用了那几个方法。</p>

<p><img src="/images/nixiangqudong007.png" title="Caption" ></p>

<p>因为是要欺骗系统，所以方法应该是在前方，初步定位到这3个方法，第一个顾名思义返回值就是能不能显示shotcutMenu，第二个，我们可以看到，这里传进来了一个手势，通过这手势的信息，基本可以推断，这个就是插件作者用来欺骗系统的手势，而该方法，就是手势的target方法，第三个，根据意思可以得知，从XXiconView，是否立即显示。核心就在于这儿了。最后，我们再打印一遍SBIconView的所有属性，用来确认一下</p>

<p><img src="/images/nixiangqudong008.png" title="Caption" ></p>

<p>继续搜索关键词，果然又有大收获_shortcutMenuPeekGesture有一个如此手势，里边的东西的手势。</p>

<p><img src="/images/nixiangqudong009.png" title="Caption" ></p>

<p>猜测得到了极大的肯定，下面就开始编写tweak了
由于是要给每一个iconView都添加手势，并且只添加一次，所以翻看了iconView头文件，查看他的init方法，选择了在initWithContentType中初始化。
贴上Tweak.xm的源码
关于代码的编写，中间也踩过不少坑，比如_revealMenuForIconView中的yes，no的设置，还好一开始猜的时候就全部手动赋值。
至于手势为什么传值需要如此怪异，因为检测发现原方法只识别长按手势，并不识别轻扫手势，但是因为个人习惯，不想覆盖系统的手势，只想单纯的增加一个功能。耿直的楼主尝试将一个轻扫手势，强行变成长按手势。很多属性都是readonly，但是这个使用kvc轻松搞定，现在轻扫一下手机！出现了意想之中的弹窗！
代码:</p>

<pre><code>#import "ZZ3DTouch.h"

%hook SBIconView 

- (id)initWithContentType:(id)arg1{
// 设置3Dtouch手势
  // 手势传过去的就是手势自己本身,本身拥有所在的view
  self.shortcutMenuPeekGesture = [[%c(UISwipeGestureRecognizer) alloc] initWithTarget:[%c(SBIconController) sharedInstance] action:@selector(_handleShortcutMenuPeek:)];
  self.shortcutMenuPeekGesture.direction = UISwipeGestureRecognizerDirectionUp;

  return %orig;
}

%end

%hook SBIconController

- (void)_revealMenuForIconView:(id)arg1 presentImmediately:(BOOL)arg2 {

  // yes 改为no之后没有显示，或者没有设置也会不显示

  %orig(iconView, YES);

}

- (void)_handleShortcutMenuPeek:(id)arg1

{
  UISwipeGestureRecognizer *swipe = arg1;
  UILongPressGestureRecognizer *press = [[UILongPressGestureRecognizer alloc] init];
  [press setValue:@(UIGestureRecognizerStateBegan) forKey:@"state"];
  [press setValue:swipe.view forKey:@"view"];

%orig(press);

}
%end
</code></pre>

<p><img src="/images/nixiangqudong010.png" title="Caption" ></p>

<p><img src="/images/nixiangqudong011.png" title="Caption" ></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/03/30/youxifanbianyi/">游戏反编译</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-03-30T13:32:08+08:00'><span class='date'><span class='date-month'>Mar</span> <span class='date-day'>30</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>1:32 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p> ipa游戏反编译
看不懂的请飘过，不要继续。
这不是给新手看的，也代表你不需要解决程序的修改问题。
这些技巧不只用于游戏的修改。</p>

<p>下載 Windows 工具</p>

<p>Windows :
winscp <a href="http://winscp.net/eng/download.php">http://winscp.net/eng/download.php</a>
PuTTY <a href="http://putty.very.rulez.org/latest/x86/putty.exe">http://putty.very.rulez.org/latest/x86/putty.exe</a></p>

<p>Mac / Linux :
用內置的 Terminal 便可</p>

<p>没 wifi 用 iPhone Tunnel Suite 3.0
<a href="http://bbs.weiphone.com/read-htm-tid-597149.html">http://bbs.weiphone.com/read-htm-tid-597149.html</a></p>

<p>苹果电脑用 iPhoneSSH
<a href="http://bbs.weiphone.com/read-htm-tid-720564.html">http://bbs.weiphone.com/read-htm-tid-720564.html</a></p>

<p>iPhone/iPod Touch 在 cydia 內安裝 deb 包
安装这些 deb 包最方便的方法是在 Cydia 内搜索及直接安装，这里提供的下载包及依赖包的链接下载点是方便手工安装时用</p>

<p>OpenSSH (openssh) 及 OpenSSL(openssl) （与iPhone/iPod Touch 终端操作）
<a href="http://apt.saurik.com/debs/openssh_5.2p1-8_iphoneos-arm.deb">http://apt.saurik.com/debs/openssh_5.2p1-8_iphoneos-arm.deb</a>
<a href="http://apt.saurik.com/debs/openssl_0.9.8k-9_iphoneos-arm.deb">http://apt.saurik.com/debs/openssl_0.9.8k-9_iphoneos-arm.deb</a></p>

<p>unzip 及 zip （解压缩及压缩打包工具）
<a href="http://apt.saurik.com/debs/unzip_5.52-5_iphoneos-arm.deb">http://apt.saurik.com/debs/unzip_5.52-5_iphoneos-arm.deb</a>
<a href="http://apt.saurik.com/debs/zip_2.32-5_iphoneos-arm.deb">http://apt.saurik.com/debs/zip_2.32-5_iphoneos-arm.deb</a></p>

<p>vbindiff (iPhone 上的十六进制查看差异及修改器)
<a href="http://apt.saurik.com/debs/vbindiff_3.0b1-3_iphoneos-arm.deb">http://apt.saurik.com/debs/vbindiff_3.0b1-3_iphoneos-arm.deb</a></p>

<p>Link Identity Editor (ldid) 及 Darwin CC Tools (odcctools)（修改后用 ldid 签名, odcctools 包括 otool, linker , assembler汇编)
<a href="http://apt.saurik.com/debs/ldid_610-5_iphoneos-arm.deb">http://apt.saurik.com/debs/ldid_610-5_iphoneos-arm.deb</a>
<a href="http://apt.saurik.com/debs/odcctools_286-8_iphoneos-arm.deb">http://apt.saurik.com/debs/odcctools_286-8_iphoneos-arm.deb</a>
<a href="http://apt.saurik.com/debs/uuid_1.6.0-2_iphoneos-arm.deb">http://apt.saurik.com/debs/uuid_1.6.0-2_iphoneos-arm.deb</a></p>

<p>Diff Utilities (diffutils) (文本差异工具 diff)
<a href="http://apt.saurik.com/debs/diffutils_2.8.1-6_iphoneos-arm.deb">http://apt.saurik.com/debs/diffutils_2.8.1-6_iphoneos-arm.deb</a></p>

<p>less (文本查看工具)
<a href="http://apt.saurik.com/debs/less_418-3_iphoneos-arm.deb">http://apt.saurik.com/debs/less_418-3_iphoneos-arm.deb</a></p>

<p>Vi IMproved (vim) 或 nano (文本编辑工具)
<a href="http://apt.saurik.com/debs/vim_7.1-3_iphoneos-arm.deb">http://apt.saurik.com/debs/vim_7.1-3_iphoneos-arm.deb</a>
<a href="http://apt.saurik.com/debs/ncurses_5.7-9_iphoneos-arm.deb">http://apt.saurik.com/debs/ncurses_5.7-9_iphoneos-arm.deb</a>
或
<a href="http://apt.saurik.com/debs/nano_2.0.7-5_iphoneos-arm.deb">http://apt.saurik.com/debs/nano_2.0.7-5_iphoneos-arm.deb</a>
<a href="http://apt.saurik.com/debs/ncurses_5.7-9_iphoneos-arm.deb">http://apt.saurik.com/debs/ncurses_5.7-9_iphoneos-arm.deb</a></p>

<p>GNU Debugger (gdb) (程序调试工具) iOS 4.3.x 更新
<a href="http://apt.saurik.com/debs/gdb_1518-11_iphoneos-arm.deb">http://apt.saurik.com/debs/gdb_1518-11_iphoneos-arm.deb</a>
<a href="http://apt.saurik.com/debs/ncurses_5.7-9_iphoneos-arm.deb">http://apt.saurik.com/debs/ncurses_5.7-9_iphoneos-arm.deb</a>
<a href="http://apt.saurik.com/debs/readline_6.0-7_iphoneos-arm.deb">http://apt.saurik.com/debs/readline_6.0-7_iphoneos-arm.deb</a>
<a href="http://apt.saurik.com/debs/sqlite3_3.5.9-12_iphoneos-arm.deb">http://apt.saurik.com/debs/sqlite3_3.5.9-12_iphoneos-arm.deb</a>
<a href="http://apt.saurik.com/debs/sqlite3-lib_3.5.9-2_iphoneos-arm.deb">http://apt.saurik.com/debs/sqlite3-lib_3.5.9-2_iphoneos-arm.deb</a>
<a href="http://apt.saurik.com/debs/sqlite3-dylib_3.5.9-1_iphoneos-arm.deb">http://apt.saurik.com/debs/sqlite3-dylib_3.5.9-1_iphoneos-arm.deb</a></p>

<p>GNU Debugger (gdb) (程序调试工具)
<a href="http://apt.saurik.com/debs/gdb_962-5_iphoneos-arm.deb">http://apt.saurik.com/debs/gdb_962-5_iphoneos-arm.deb</a>
<a href="http://apt.saurik.com/debs/ncurses_5.7-9_iphoneos-arm.deb">http://apt.saurik.com/debs/ncurses_5.7-9_iphoneos-arm.deb</a>
<a href="http://apt.saurik.com/debs/readline_6.0-7_iphoneos-arm.deb">http://apt.saurik.com/debs/readline_6.0-7_iphoneos-arm.deb</a>
<a href="http://apt.saurik.com/debs/sqlite3_3.5.9-12_iphoneos-arm.deb">http://apt.saurik.com/debs/sqlite3_3.5.9-12_iphoneos-arm.deb</a>
<a href="http://apt.saurik.com/debs/sqlite3-lib_3.5.9-1_iphoneos-arm.deb">http://apt.saurik.com/debs/sqlite3-lib_3.5.9-1_iphoneos-arm.deb</a>
<a href="http://apt.saurik.com/debs/sqlite3-dylib_3.5.9-1_iphoneos-arm.deb">http://apt.saurik.com/debs/sqlite3-dylib_3.5.9-1_iphoneos-arm.deb</a></p>

<p>adv-cmds (ps 工具)
<a href="http://apt.saurik.com/debs/adv-cmds_119-5_iphoneos-arm.deb">http://apt.saurik.com/debs/adv-cmds_119-5_iphoneos-arm.deb</a></p>

<p>grep (grep 文本搜索工具)
<a href="http://apt.saurik.com/debs/grep_2.5.4-3_iphoneos-arm.deb">http://apt.saurik.com/debs/grep_2.5.4-3_iphoneos-arm.deb</a></p>

<p>ARM 参考书籍</p>

<p><a href="http://bbs.weiphone.com/read-htm-tid-363306.html">http://bbs.weiphone.com/read-htm-tid-363306.html</a></p>

<p>ARM指令集及使用方法</p>

<p>ARM System Developer&rsquo;s Guide (主要是看第三章 Chapter 3)</p>

<p>ARM Assembly Language Programming</p>

<p>修改及用 gdb 调试游戏流程</p>

<p>(1) 安装及试玩游戏，每个游戏的修改方法都不同，没有玩过这游戏，怎样知道要修改什么呢？
这教程用了 Final Fantasy 2 作例子</p>

<p>(2) 用 iTunes 安装 Final Fantasy 2 破解版本 (未破解的不能反汇编)</p>

<p>(3) 用putty / ssh 连接iPhone / iPod Touch，假设你的iPhone / iPod Touch 的IP地址是192.168.1.104</p>

<p>Connection type: 选 SSH
Port 选 22
按 Open</p>

<p>PuTTY 连接 192.168.1.104 后</p>

<p>Login 打 root
Password(假设你没有更改密码) 打 alpine</p>

<p>Mac / Linux Terminal 内打
ssh <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#x6f;&#58;&#114;&#x6f;&#111;&#116;&#64;&#49;&#57;&#50;&#x2e;&#x31;&#54;&#x38;&#46;&#x31;&#46;&#x31;&#x30;&#x34;">&#114;&#111;&#x6f;&#116;&#x40;&#49;&#x39;&#50;&#x2e;&#49;&#x36;&#x38;&#x2e;&#x31;&#46;&#x31;&#x30;&#52;</a></p>

<p>(4) 进入游戏路径目录内(先决条件是已用 PuTTy / Terminal 连接iPhone / iPod Touch)
打
复制代码</p>

<pre><code>cd /var/mobile/Applications/*/FinalFantasy2.app
</code></pre>

<p>(5) 到上一层路径目录建立 cheat 临时工作路径目录及游戏程式临时修改档
打
复制代码</p>

<pre><code>cd ..
mkdir -p cheat
cd cheat
cp -p ../FinalFantasy2.app/FinalFantasy2 FinalFantasy2.original
</code></pre>

<p>(6) 反汇编原游戏程式
复制代码</p>

<pre><code>otool -tv FinalFantasy2.original &gt; FinalFantasy2.original.txt
</code></pre>

<p>(7) 查看反汇编代码分析并找出要修改的地方(每个游戏的修改地方都不同, 这点最难)
要修改游戏，你会有以下的困难或问题：</p>

<p>(i) 没有高阶源代码，只有反汇编代码
反汇编代码分析是困难的但绝对不是不可能作分析，你可以找到些不错的ARM Assembly的参考书
在上面亦已提供了一些很好的 ARM 指令参考
常见的是以下这些基本的指令及其执行条件码：</p>

<p>MOV 或 MVN 寄存器数值的传送操作
ADD 或 SUB 加减的算术操作
CMP 或 CMN 比较操作
AND、ORR、EOR 逻辑操作
B、BL、BNE、BGE 分支/跳转指令
MUL 乘法操作 或 LSL 是 二进制左移，左移一位，即十进制乘2倍
LDR 或 STR 加载及存储数据</p>

<p>每个指令都可加上执行条件码根据上一个运算、逻辑或比较指令的结果决定是否执行指令</p>

<p>执行条件码 (Condition Codes)：
① CS 及 CC（Carry）进位条件码，CS＝进位，否则＝CC(不进位).
② EQ 及 NE （Equal 或 Zero）相等或零条件码，EQ＝运算结果为相等或零时，否则＝NE(不相等).
③ VS 及 VC（Overflow）溢出条件码。 VS=溢出，否则＝VC(不溢出)。
④ PL 及 MI 条件码。 PL（Plus/Positive）＝结果为正，MI（Minus/Negative）＝结果为负。</p>

<p>⑤ GT 及 LT 条件码。 GT（Greater Than）＝大于(PL+VC+NE / MI+VS+NE)，LT（Less Than）＝小于(MI+VC / PL+VS)。
⑥ GE 及 LE 条件码。 GE（Greater Than or Equal）＝大或等于(PL+VC / MI+VS)，LE（Less Than or Equal）＝小或等于(MI+VC / PL+VS / EQ)。
⑦ HI 及 LO 条件码。 HI（Higher Than）＝无符号数(unsigned)高于(CS+NE)，LO（Lower Than）＝无符号数(unsigned)低于(CC)。
⑧ HS 及 LS 条件码。 HS（Higher or Same）＝无符号数(unsigned)高于或相等(CS/EQ)，LS（Lower or Same）＝无符号数(unsigned)低于或相等(CC/EQ)。
⑨ AL 及 NV 条件码。 条件码默认为AL（Always）＝无条件执行，NV（Never）是AL的相反＝不执行。</p>

<p>例子及其注解意思
复制代码</p>

<p>CMP R0, R1       @寄存器数值 R0 及 R1 的比较
MOVGT R2, R0     @如果结果 R0 >(大于) R1，则执行MOV R2, R0即 R2＝R0
MOVLE R2, R1     @如果结果 R0 &lt;=(小或等于) R1，则执行MOV R2, R1即 R2＝R1</p>

<p>复制代码</p>

<p>LDR R1, [R0]     @意思是 R1 = <em>R0，从R0指向的地址处的数据载入到寄存器 R1
STR R1, [R0]     @意思是 </em>R0 = R1，把寄存器 R1内的数据写到 R0 内指向的地址处</p>

<p>ARM 指令集及使用方法</p>

<p>(ii) 看不懂游戏程式流程，没法分析
有很多人都喜欢用 IDA Pro Advanced 去做分析， 无疑这软件是个非常好的静态分析工具，它有图形视图显示代码流程作搜索及深层分析。除了可分析反汇编代码外，亦可反汇编一些 otool 不能处理的工作。 但 IDA Pro Advanced 在iPhone 的程式只适合做静态的分析。</p>

<p>你可以在这里下载 IDA Pro Advanced 5.2 及其参考书，建议你使用功能及视图比较强大的 Windows 版本。
<a href="http://bbs.weiphone.com/read-htm-tid-363306.html">http://bbs.weiphone.com/read-htm-tid-363306.html</a></p>

<p>只看代码是不能作分析，要配合动态调试去了解程式的细节在实际运行时发生的数据及变化。在第15步就有用 gdb 作动态调试的例子去设置断点、继续、跟踪及分析代码。gdb 的参考书可在上面的链接下载。</p>

<p>(iii) 找不到游戏的数据例如金钱，经验值，装备，等级暂存在那？</p>

<p>引用</p>

<p>方法一：在 gdb 设置断点分析
ARM CPU 有个特性便是一些加减计算要传送到CPU寄存器(register) 进行，因此你会经常看到这些要找的数据会先从内存用LDR 指令载入到寄存器, 经过一些计算(加或减)后及防溢位判断后便用STR 指令存储这寄存器回内存地址。</p>

<p>另外由于这些程式大多是用 Objective C 或 C++ 语言写成，这些程序员会用一些描述性的函数名，例如带有 Money, Price, Gold, Exp, Item, Life, Level 字段等。</p>

<p>利用这两点便可以将程序锁定在某些函数上，再利用 gdb 调试工具暂停在某些点一步一步地单步执行及查看一些寄存器，印证是否与你要找的数据是否有关。</p>

<pre><code>在FinalFantasy2 的这实例中, 是用这方法找到修改点
用 less 工具去找寻 Money
putty / Terminal 打
</code></pre>

<p>复制代码</p>

<pre><code>less FinalFantasy2.original.txt



在 less 工具內打
</code></pre>

<p>复制代码</p>

<pre><code>/Money


去开始找寻(按 N 键去继续找寻)，便会找到这段代码像是要存储金钱数据(SetMoney)，0007b218是进入这段代码的开始地址
</code></pre>

<p>复制代码</p>

<pre><code>__ZN14cFF2GlobalWork19sysGAMEPrm_SetMoneyEj:
0007b218 e59f300c ldr r3, [pc, #12] ; 0x7b22c
0007b21c e580120c str r1, [r0, #524]
0007b220 e1510003 cmp r1, r3
0007b224 8580320c strhi r3, [r0, #524]
0007b228 e12fff1e bx lr



首先在iPhone或iPod Touch 开始Final Fantasy 2 直至游戏已 Resume及进入游戏。


① 在PuTTY / Terminal 找FinalFantasy2 的运行中的进程编号(process id)

PuTTY / Terminal 打
</code></pre>

<p>复制代码</p>

<pre><code>ps ax



得到
</code></pre>

<p>复制代码</p>

<pre><code>1115   ??  Ss     1:30.86 /var/mobile/Applications/XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX/FinalFantasy2.app/FinalFantasy2



找到FinalFantasy2 游戏现时运行中的进程编号是 1115

② 用gdb 进入调试运行中的进程编号1115
PuTTY / Terminal 打
</code></pre>

<p>复制代码</p>

<pre><code>gdb -p 1115



此时游戏会暂停，音乐也暂停

③ 用gdb 设定断点breakpoint在十六进制地址0x7b218

PuTTY / Terminal 打
</code></pre>

<p>复制代码</p>

<pre><code>break *0x7b218



④ 继续 continue 游戏
PuTTY / Terminal 打
</code></pre>

<p>复制代码</p>

<pre><code>c



⑤ 将Final Fantasy 2 游戏进入战斗，战胜后游戏会在十六进制地址0x7b218处停止

⑥ 暂停后，离开这分支__ZN14cFF2GlobalWork19sysGAMEPrm_SetMoneyEj
PuTTY / Terminal 打
</code></pre>

<p>复制代码</p>

<pre><code>finish



⑦ 反汇编现时地址上面的代码
</code></pre>

<p>复制代码</p>

<pre><code>disassem $pc-28 $pc


得到
</code></pre>

<p>复制代码</p>

<pre><code>0x0003baac &lt;_ZN10FF2cBattle12SENRIHIN_CHKEP12thBATMonsterP6X86REG 180&gt;: bl 0x78e30 &lt;_ZN14cFF2GlobalWork8InstanceEv&gt;
0x0003bab0 &lt;_ZN10FF2cBattle12SENRIHIN_CHKEP12thBATMonsterP6X86REG 184&gt;: mov r4, r0
0x0003bab4 &lt;_ZN10FF2cBattle12SENRIHIN_CHKEP12thBATMonsterP6X86REG 188&gt;: bl 0x78e30 &lt;_ZN14cFF2GlobalWork8InstanceEv&gt;
0x0003bab8 &lt;_ZN10FF2cBattle12SENRIHIN_CHKEP12thBATMonsterP6X86REG 192&gt;: bl 0x7b230 &lt;_ZN14cFF2GlobalWork19sysGAMEPrm_GetMoneyEv&gt;
0x0003babc &lt;_ZN10FF2cBattle12SENRIHIN_CHKEP12thBATMonsterP6X86REG 196&gt;: add r1, r0, r5
0x0003bac0 &lt;_ZN10FF2cBattle12SENRIHIN_CHKEP12thBATMonsterP6X86REG 200&gt;: mov r0, r4
0x0003bac4 &lt;_ZN10FF2cBattle12SENRIHIN_CHKEP12thBATMonsterP6X86REG 204&gt;: bl 0x7b218 &lt;_ZN14cFF2GlobalWork19sysGAMEPrm_SetMoneyEj&gt;



这时会发现在_ZN14cFF2GlobalWork19sysGAMEPrm_GetMoneyEv
</code></pre>

<p>及_ZN14cFF2GlobalWork19sysGAMEPrm_SetMoneyEj
中间0x0003babc 地址的代码add r1, r0, r5 是最可疑的</p>

<pre><code>⑧ 取消断点1及设定新断点breakpoint在十六进制地址0x0003babc 及重新继续continue 游戏
PuTTY / Terminal 打
</code></pre>

<p>复制代码</p>

<pre><code>disable 1
break *0x3babc
c



在iPhone或iPod Touch查看现时游戏的金钱例如是4888，将Final Fantasy 2 游戏进入战斗，战胜后游戏会新断点2地址0x3babc处停止

⑨ 当游戏在新断点2暂停时查看寄存器就发现 r0 是当时的金钱余额及 r5 是战胜后得到的金钱
PuTTY / Terminal 打
</code></pre>

<p>复制代码</p>

<pre><code>i r $r0 $r1 $r5 $pc



⑩ 假设已找到应修改的地址是 0003babc，便可继续下面第(8)步
</code></pre>

<p>引用</p>

<p>方法二：在 gdb 搜索内存数据值及设置观察点(watchpoint)</p>

<pre><code>游戏的数据都会暂存在堆(heap)内存, 于游戏退出前储存在 iPhone 或 iPod Touch的闪存记忆体内, 一些经验值或金钱的数字是比较独特，在内存重复出现的机会不多，这些唯一的数字便可用这方法去进行搜索。

这里用了 Zenonia 2 v1.0 作例子，下面的游戏截图便看到用一个独特的经验值数字 672 去开始这方法



① 在 PuTTY / Terminal 用  ps ax  的指令找到 ZENONIA2 游戏现时运行中的进程编号是 1123

② 使用 gdb 进入运行中的进程编号 1123
PuTTY / Terminal 打
</code></pre>

<p>复制代码</p>

<pre><code>gdb -p 1123



此时游戏会暂停，音乐也暂停

③ 用 gdb 输入这些指令包括，内存开始地址(0x800000)、结束地址(0x880000)及要搜索的数字672如下:

PuTTY / Terminal 打
</code></pre>

<p>复制代码</p>

<pre><code>set $x=0x800000
while(*++$x!=672 &amp;&amp; $x&lt;0x880000)
end



④ 输入 end 之后等候数十秒 ....，待gdb去搜索这段内存地址

⑤ gdb 搜索完毕后
PuTTY / Terminal 打
</code></pre>

<p>复制代码</p>

<pre><code>p/x $x


得到
</code></pre>

<p>复制代码</p>

<pre><code>$1 = 0x85e28c
</code></pre>

<p>这代表 gdb 已找到在 0x85e28c 的内存地址的存储数字是 672</p>

<pre><code>PuTTY / Terminal 打
</code></pre>

<p>复制代码</p>

<pre><code>x/dw 0x85e28c


得到确认 0x85e28c 的内存地址的存储数字是 672
</code></pre>

<p>复制代码</p>

<pre><code>0x85e28c:    672



 ⑥ 用 gdb 继续搜索
PuTTY / Terminal 打 (或按方向键 ↑ 4次，然后回车，免重复输入)
</code></pre>

<p>复制代码</p>

<pre><code>while(*++$x!=672 &amp;&amp; $x&lt;0x880000)
end


再等十多秒，gdb 搜索完毕后
PuTTY / Terminal 打
</code></pre>

<p>复制代码</p>

<pre><code>p/x $x


得到
</code></pre>

<p>复制代码</p>

<pre><code>$2 = 0x880000
</code></pre>

<p>这代表 gdb 已到结束的地址 0x880000，都没有找到。这也表示数字 672 是唯一出现在 0x85e28c 要找的内存范围内。</p>

<pre><code>⑦ 用 gdb 更改内存地址 0x85e28c 的存储数字为 1000
PuTTY / Terminal 打
</code></pre>

<p>复制代码</p>

<pre><code>set {int}0x85e28c=1000



PuTTY / Terminal 打
</code></pre>

<p>复制代码</p>

<pre><code>x/dw 0x85e28c



得到确认已成功更改数字
</code></pre>

<p>复制代码</p>

<pre><code>0x85e28c:    1000



⑧ 继续 continue 游戏
PuTTY / Terminal 打
</code></pre>

<p>复制代码</p>

<pre><code>c



⑨ 在回到游戏里退出 STATUS 画面再进入 STATUS，画面内数据重刷后，确认已成功更改经验值数字为1000


留意:由于游戏数据在堆(heap)内存的地址不是固定的，所以每次运行的进程都要再搜索新的内存地址。另外，搜索的内存地址范围也会改变，如果在 0x800000 至 0x880000 范围内找不到的话，就要往后试 0x880000 至 0x900000 新的范围。

     另外：用相同搜索方法也可以找到金钱数字在这次运行进程是在内存地址 0x874c04

⑩ 找到经验值地址后便可设置观察点(watchpoint)于内存地址 0x85e28c

设置观察点的目的是当内存地址值被读或被写时，会显示数据及暂停程序

PuTTY / Terminal 打
</code></pre>

<p>复制代码</p>

<pre><code>watch *0x85e28c


及继续游戏
PuTTY / Terminal 打
</code></pre>

<p>复制代码</p>

<pre><code>c
</code></pre>

<p>留意:游戏在观察点(watchpoint) 生效下运行是非常的慢，有些游戏是不能正常运作，有时候手机也要重启，所以下面的步骤是不一定可以进行的</p>

<pre><code>⑪ 将游戏进入战斗打怪后程序便会暂停在 0x9f508 地址，gdb 会显示
</code></pre>

<p>复制代码</p>

<pre><code>Hardware watchpoint 1: *8774284
Old value = 1000
New value = 1086
0x0009f508 in CMvPlayer::CheckLevelUp ()



PuTTY / Terminal 打
</code></pre>

<p>复制代码</p>

<pre><code>x/14i $pc-16


得到
</code></pre>

<p>复制代码</p>

<pre><code>0x9f4f8 &lt;_ZN9CMvPlayer12CheckLevelUpEj+60&gt;:    b.n    0x9f508 &lt;_ZN9CMvPlayer12CheckLevelUpEj+76&gt;
0x9f4fa &lt;_ZN9CMvPlayer12CheckLevelUpEj+62&gt;:    adds    r0, r4, #0
0x9f4fc &lt;_ZN9CMvPlayer12CheckLevelUpEj+64&gt;:    movs    r1, #1
0x9f4fe &lt;_ZN9CMvPlayer12CheckLevelUpEj+66&gt;:    movs    r2, #0
0x9f500 &lt;_ZN9CMvPlayer12CheckLevelUpEj+68&gt;:    subs    r5, r5, r3
0x9f502 &lt;_ZN9CMvPlayer12CheckLevelUpEj+70&gt;:    bl    0x9f338 &lt;_ZN9CMvPlayer9OnLevelUpEii&gt;
0x9f506 &lt;_ZN9CMvPlayer12CheckLevelUpEj+74&gt;:    movs    r3, #1
0x9f508 &lt;_ZN9CMvPlayer12CheckLevelUpEj+76&gt;:    str    r5, [r4, r6]
0x9f50a &lt;_ZN9CMvPlayer12CheckLevelUpEj+78&gt;:    cmp    r3, #0
0x9f50c &lt;_ZN9CMvPlayer12CheckLevelUpEj+80&gt;:    beq.n    0x9f516 &lt;_ZN9CMvPlayer12CheckLevelUpEj+90&gt;
0x9f50e &lt;_ZN9CMvPlayer12CheckLevelUpEj+82&gt;:    cmp    r5, #0
0x9f510 &lt;_ZN9CMvPlayer12CheckLevelUpEj+84&gt;:    beq.n    0x9f516 &lt;_ZN9CMvPlayer12CheckLevelUpEj+90&gt;
0x9f512 &lt;_ZN9CMvPlayer12CheckLevelUpEj+86&gt;:    movs    r5, #0
0x9f514 &lt;_ZN9CMvPlayer12CheckLevelUpEj+88&gt;:    b.n    0x9f4c6 &lt;_ZN9CMvPlayer12CheckLevelUpEj+10&gt;



PuTTY / Terminal 打
</code></pre>

<p>复制代码</p>

<pre><code>i r $r5 $r4 $r6 $pc
p/x $r4+$r6


得到
</code></pre>

<p>复制代码</p>

<pre><code>r5             0x43E    1086
r4             0x85DC00    8772608
r6             0x68c    1676
pc             0x9f508    652552
$5 = 0x85e28c



这时确认了 0x9f508 地址这句代码
str    r5, [r4, r6]
的意思是，r4 + r6 = 0x85e28c ，把寄存器 r5 内的数字(1086) 写到 0x85e28c 的地址
</code></pre>

<p>　
    程序因要写进这0x85e28c 的地址，所以暂停了，这就是观察点(watchpoint) 的强大功能。</p>

<pre><code>PuTTY / Terminal 打
</code></pre>

<p>复制代码</p>

<pre><code>bt


得到
</code></pre>

<p>复制代码</p>

<pre><code>#0  0x0009f508 in CMvPlayer::CheckLevelUp ()
#1  0x0009ff2e in CMvPlayer::DoUpdate ()
#2  0x00094744 in CMvObject::Update ()
#3  0x000969cc in CMvObjectMgr::Update ()
#4  0x000662e6 in CMvGameState::UpdateGame ()



这时就可根据上面得到的信息在这段代码的前后范围进行跟踪、设置断点及进一步的分析
</code></pre>

<p>有新的方法时，再继续更新 &hellip;&hellip;&hellip;&hellip;</p>

<p>(iv) 不知道修改点在那及改为什么？</p>

<p>修改程序是不能插入程序代码，主要原因是移位后的程序是不能运行的。一般的做法是找到要修改的位置在原档案位置修改代码改为你需要的指令。 修改点一定要经过分析代码后再不断地用动态分析确定后，在适当的地方重覆试验及调试验证修改后的结果 。</p>

<ul>
<li>一些RPG游戏的特性，例如是金钱或经验值是会在战斗后重算及更新，一般都是要找到及修改更新数据前的指令。金钱的修改点也可以修改在买卖装备时的指令。连续升级的修改主要是看该游戏是怎样升级，例如 Inotia 2是根据经验值去升级，只要找到判断经验值的指令代码地址，修改其判断的指令便可。</li>
</ul>


<p>对于游戏来说，一般的指令修改例子如下：</p>

<p>① 修改寄存器的增加数字例如
    Final Fantasy II 增加战胜后所得金钱
    地址 0003babc
    add r1, r0, r5
    改为
    add r1, r0, r5, lsl #5</p>

<p>② 修改寄存器减少的数字为零例如
    Inotia 2 v 1.1.0 不扣技能点
    地址 00021b9c
    sub r3, #1
    改为
    sub r3, #0</p>

<pre><code>地址 00037b46 
sub r1, #1 
改为 
sub r1, #0 
</code></pre>

<p>③ 修改比较的寄存器例如
    花儿朵朵开-v1.0 不死作弊版 (这里 r2 寄存器是花朵已绽放的数量)
    地址 00004ee8
    cmp r2, r3
    改为
    cmp r2, #1 ; 0x1</p>

<p>④ 修改arm 32 位为两个arm thumb 16 位代码例如
    Inotia 2 v 1.1.0 roll点全18
    地址 0005c404
    bl 0x9914
    改为
    mov r0, #9
    mov r0, #9</p>

<pre><code>地址 0005c404, 0005c40e, 0005c41c, 0005c426 
bl 0x9914 
改为 
mov r0, #9 
mov r0, #9 
</code></pre>

<p>⑤ 要删除代码便要用 nop (no operation) 取代
    thumb 16 bits nop 是 46c0<br/>
    arm 32 bits nop 是 e1a00000</p>

<p>(8) 在FinalFantasy2 的这实例中，假设已找到应修改的地址是 0003babc，代码是 e0801005
复制代码</p>

<pre><code>0003bab8        eb00fddc        bl 0x7b230
0003babc        e0801005        add r1, r0, r5   @意思是 r1 = r0 +r5 ; r0 是当时的金钱余额; r5 是战胜后得到的金钱
0003bac0        e1a00004        mov r0, r4
0003bac4        eb00fdd3        bl 0x7b218     @分支到函数名 __ZN14cFF2GlobalWork19sysGAMEPrm_SetMoneyEj 去更新金錢余额
</code></pre>

<p>(9) 修改目标 : 将所得金钱乘大32倍
0003babc的应修改目标代码是
复制代码</p>

<pre><code>add r1, r0, r5, lsl#5 @意思是 r1 = r0 +( r5 二进制左移五位,即十进制乘大32倍)
</code></pre>

<p>(10) 找新ARM指令代码
add r1, r0, r5 的ARM指令代码是 e0801005
修改目标是要找到 add r1, r0, r5, lsl#5 的ARM指令代码 ?</p>

<p>用 vim 或 nano 建立 armtest.s 如下
复制代码</p>

<pre><code>    .file "armtest.s"
    .globl _main
    .code 32
_main:
    add r1, r0, r5
    add r1, r0, r5, lsl #5
</code></pre>

<p>留意: 一些程式反汇编后是ARM Thumb, ARM Thumb 是16 bits 而ARM 是32 bits. ARM 32 bits 及 ARM Thumb 的分别请找上面 ARM Assembler 的参考(ARM Thumb 的可用指令是比 ARM 32 bits 少)。 如果要找 ARM Thumb 代码要将上面的.code 32改为.code 16 及加上 .thumb_func _main 如下
复制代码</p>

<pre><code>    .code 16
    .thumb_func _main
</code></pre>

<p>汇编 arm 打
复制代码</p>

<pre><code>as armtest.s -o armtest.o ; otool -tv armtest.o
</code></pre>

<p>便看到</p>

<p>复制代码</p>

<pre><code>(__TEXT,__text) section
_main:
00000000    e0801005    add r1, r0, r5
00000004    e0801285    add r1, r0, r5, lsl #5
</code></pre>

<p>及得到add r1, r0, r5, lsl #5 目标ARM指令代码为 e0801285</p>

<p>(11) 建立修改程式第一版FinalFantasy2.v1及用十六进制修改器修改代码</p>

<p>打
复制代码</p>

<pre><code>cp -p FinalFantasy2.original FinalFantasy2.v1      
vbindiff FinalFantasy2.v1
</code></pre>

<p>进入vibindiff 后按G及输入地址3AABC跳到要修改的位置如下</p>

<p>留意: 在第8步时找到的位置是0003Babc，但修改程式的位置要减去十六进制0x1000得到3Aabc
(0x3babc 减 0x1000 等于 0x3aabc)</p>

<p>按E键开始修改，将
05 10 80 E0
改为
85 12 80 E0</p>

<p>然后按Esc键及Y键确认修改</p>

<p>最后按Q键离开 vbindiff 修改器</p>

<p>如下</p>

<p>留意: 修改器显示的05 10 80 E0与反汇编的代码e0801005的位置顺序是倒的</p>

<p>(12) 反汇编修改程式第一版 v1 及比较原版本 original
打
复制代码</p>

<pre><code>otool -tv FinalFantasy2.v1 &gt; FinalFantasy2.v1.txt
diff FinalFantasy2.original.txt FinalFantasy2.v1.txt
</code></pre>

<p>也可以用 otool -otV</p>

<p>得到</p>

<p>复制代码</p>

<pre><code>&lt; FinalFantasy2.original:
---
&gt; FinalFantasy2.v1:
59597c59597
&lt; 0003babc    e0801005    add    r1, r0, r5
---
&gt; 0003babc    e0801285    add    r1, r0, r5, lsl #5
</code></pre>

<p>(13) 对修改程式第一版重新签名
打
复制代码</p>

<pre><code>ldid -s FinalFantasy2.v1
</code></pre>

<p>(14) 将签名后的程式放回程式路径进行测试
首先备份原程式(留意:要用mv移动不要用cp)
打
复制代码</p>

<pre><code>mv ../FinalFantasy2.app/FinalFantasy2 ../FinalFantasy2.app/FinalFantasy2.bak
</code></pre>

<p>安装修改后的程式及更新权限
打
复制代码</p>

<pre><code>cp -p FinalFantasy2.v1 ../FinalFantasy2.app/FinalFantasy2
chown mobile:mobile ../FinalFantasy2.app/FinalFantasy2
chmod 0755 ../FinalFantasy2.app/FinalFantasy2
</code></pre>

<p>(15) 用 gdb 调试游戏</p>

<p>调试是用 gdb，在这里的目的是设置断点使游戏暂停，查看CPU的寄存器，印证修改是否成功。由于游戏占用很多内存，在游戏运行时调试再加ssh 连接很多时候都会崩溃。所以用 iPod Touch 3代 或 iPhone 3GS 做这项工作会有优势。</p>

<p>首先在iPhone或iPod Touch 开始Final Fantasy 2 直至游戏已Resume及进入游戏。</p>

<p>在iPhone或iPod Touch查看现时游戏的金钱例如是 7223</p>

<p>① 在putty / Terminal 找 FinalFantasy2 的运行中的进程编号 (process id)</p>

<p>PuTTY / Terminal 打
复制代码</p>

<pre><code>ps ax
</code></pre>

<p>得到</p>

<p>复制代码</p>

<pre><code>1115   ??  Ss     1:30.86 /var/mobile/Applications/XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX/FinalFantasy2.app/FinalFantasy2
</code></pre>

<p>找到 FinalFantasy2 游戏现时运行中的进程编号是 1115</p>

<p>② 用 gdb 进入调试运行中的进程编号 1115
PuTTY / Terminal 打
复制代码</p>

<pre><code>gdb -p 1115
</code></pre>

<p>此时游戏会暂停，音乐也暂停</p>

<p>③ 用 gdb 设定断点breakpoint在十六进制地址 0x3babc (即在第8步时找到的位置0003babc)
PuTTY / Terminal 打
复制代码</p>

<pre><code>break *0x3babc
</code></pre>

<p>④ 继续 continue 游戏
PuTTY / Terminal 打
复制代码</p>

<pre><code>c
</code></pre>

<p>⑤ 将Final Fantasy 2 游戏进入战斗，战胜后游戏会在十六进制地址 0x3babc处停止</p>

<p>⑥ 暂停后，查看 CPU 寄存器 register (info register 指令)
PuTTY / Terminal 打
复制代码</p>

<pre><code>i r $r0 $r1 $r5 $pc
</code></pre>

<p>得到</p>

<p>复制代码</p>

<pre><code>r0             0x1c37    7223
r1             0x25    37
r5             0x25    37
pc             0x3babc    244412
</code></pre>

<p>印证了 r0=7223 是现时的金钱
游戏暂停在 pc=0x3babc</p>

<p>⑦ 查看下一步将要运行的反汇编指令
PuTTY / Terminal 打
复制代码</p>

<pre><code>x/i $pc
</code></pre>

<p>得到 add r1, r0, r5, lsl #5，印证成功修改指令</p>

<p>复制代码</p>

<pre><code>0x3babc &lt;_ZN10FF2cBattle12SENRIHIN_CHKEP12thBATMonsterP6X86REG+196&gt;:    add    r1, r0, r5, lsl #5
</code></pre>

<p>⑧ 运行下一步 stepi 指令
PuTTY / Terminal 打
复制代码</p>

<pre><code>si
</code></pre>

<p>查看 CPU 寄存器 register (info register 指令)
PuTTY / Terminal 打
复制代码</p>

<pre><code>i r $r0 $r1 $r5 $pc
</code></pre>

<p>得到
复制代码</p>

<pre><code>r0             0x1c37    7223
r1             0x20d7    8407
r5             0x25    37
pc             0x3bac0    244416
</code></pre>

<p>此时印证了 r1 = r0 +( r5 x 32)
            = 7223 + (27 x 32)
            = 8407</p>

<p>查看下一步将要运行的反汇编指令
putty / Terminal 打
复制代码</p>

<pre><code>x/i $pc
</code></pre>

<p>得到</p>

<p>复制代码</p>

<pre><code>0x3bac0 &lt;_ZN10FF2cBattle12SENRIHIN_CHKEP12thBATMonsterP6X86REG+200&gt;:    mov    r0, r4
</code></pre>

<p>⑨ 继续 continue 游戏
PuTTY / Terminal 打
复制代码</p>

<pre><code>c
</code></pre>

<p>⑩ Final Fantasy 2 游戏显示战胜后得到37的金钱，但实际金钱余额是 8407，印证修改游戏已成功。</p>

<p>⑪ 离开 gdb</p>

<p>按下Ctrl+C 组合键停止执行进程</p>

<p>PuTTY / Terminal 打
复制代码</p>

<pre><code>quit
</code></pre>

<p>及按 y 键确认离开 gdb</p>

<p>留意:在上面第⑥步暂停时，你可以输入指令去更改CPU 寄存器 register
例如打
set $r5=1000
去试试增加金钱数目</p>

<p>(16) 假设已调试完成，便可将修改后的程式打包发布</p>

<p>进入游戏路径目录内，打
复制代码</p>

<pre><code>cd /var/mobile/Applications/*/FinalFantasy2.app
</code></pre>

<p>到上一层路径目录
复制代码</p>

<pre><code>cd ..
</code></pre>

<p>建立 IPA 所要的路径及档案及删除不需要的备份档案</p>

<p>复制代码</p>

<pre><code>rm -fr Payload
mkdir -p Payload
cp -pr FinalFantasy2.app Payload/
rm -fr Payload/FinalFantasy2.app/FinalFantasy2*.bak
</code></pre>

<p>打包 ipa 为 FinalFantasy2_v1.ipod4g.ipa
复制代码</p>

<pre><code>zip -r FinalFantasy2_v1.ipod4g.ipa Payload iTunesArtwork
</code></pre>

<p>找现时的路径
复制代码</p>

<pre><code>pwd
</code></pre>

<p>得到</p>

<p>复制代码</p>

<pre><code>/var/mobile/Applications/XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
</code></pre>

<p>用 winscp 或Terminal 的 scp 指令传送这档作发布</p>

<p>复制代码</p>

<pre><code>/var/mobile/Applications/XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX/FinalFantasy2_v1.ipod4g.ipa
</code></pre>

<p>XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX 是随机路径</p>

<p>(17) 其他有用的技巧</p>

<p>① 由于修改游戏的程式代码是很少量, 相对重覆调试及动态分析工作比较多，此教程便介绍了用iPhone 的工具直接做修改及反汇编。这样对于少量修改程式代码及重覆在iPhone调试是比较要传回PC做修改是更有效率的。</p>

<p>② 调试的工具 gdb 是比较难用，但有些方法是可提高使用 gdb 的效率。</p>

<p>例如：在 gdb 建立宏 macro define
在 iphone 建立这档案(~/.gdbinit) 内容为
复制代码</p>

<pre><code>define ascii_char
set $_c=*(unsigned char *)($arg0)
if ( $_c &lt; 0x20 || $_c &gt; 0x7E )
printf "."
else
printf "%c", $_c
end
end
document ascii_char
Print the ASCII value of arg0 or '.' if value is unprintable
end
define hex_quad
printf "%02X %02X %02X %02X  %02X %02X %02X %02X",  \
*(unsigned char*)($arg0), *(unsigned char*)($arg0 + 1),  \
*(unsigned char*)($arg0 + 2), *(unsigned char*)($arg0 + 3), \
*(unsigned char*)($arg0 + 4), *(unsigned char*)($arg0 + 5), \
*(unsigned char*)($arg0 + 6), *(unsigned char*)($arg0 + 7)
end
document hex_quad
Print eight hexadecimal bytes starting at arg0
end
define hexdump
printf "%08X : ", $arg0
hex_quad $arg0
printf " - "
hex_quad ($arg0+8)
printf " "
ascii_char ($arg0)
ascii_char ($arg0+1)
ascii_char ($arg0+2)
ascii_char ($arg0+3)
ascii_char ($arg0+4)
ascii_char ($arg0+5)
ascii_char ($arg0+6)
ascii_char ($arg0+7)
ascii_char ($arg0+8)
ascii_char ($arg0+9)
ascii_char ($arg0+0xA)
ascii_char ($arg0+0xB)
ascii_char ($arg0+0xC)
ascii_char ($arg0+0xD)
ascii_char ($arg0+0xE)
ascii_char ($arg0+0xF)
printf "\n"
end
document hexdump
Display a 16-byte hex/ASCII dump of arg0
end
define hexdump1
hexdump $arg0
x/8h $arg0
printf "\n"
disassem $arg0 $arg0+16
printf "\n"
end
document hexdump1
Display a 16-byte hex/ASCII dump and disassembly of arg0
end
</code></pre>

<p>在用 gdb 调试时打
复制代码</p>

<pre><code>hexdump1 $pc
</code></pre>

<p>便可列出$pc位置后十六位的内容及反汇编的代码</p>

<p>③ 在断点设定一些要自动运行的指令</p>

<p>下面的意思是建立断点１
及在断点１停止时运行查看一些暂存器(i r $r0 $r1 $r5 $pc)及反汇编下四个指令代码(x/4i $pc)</p>

<p>复制代码</p>

<pre><code>break *0x3babc
commands 1
i r $r0 $r1 $r5 $pc
x/4i $pc
end
</code></pre>

<p>④ 在 gdb 断点暂停时，是可改变内存及指令
FinalFantasy2 的例子，0x0003babc地址的指令是
打
复制代码</p>

<pre><code>x/i 0x0003babc
</code></pre>

<p>得到代码是
复制代码</p>

<pre><code>add r1, r0, r5
</code></pre>

<p>打
复制代码</p>

<pre><code>x/xw 0x0003babc
</code></pre>

<p>得到代码数值是
复制代码</p>

<pre><code>0xe0801005
</code></pre>

<p>改变指令代码数值打
复制代码</p>

<pre><code>set {int}0x0003babc = 0xe0801285
</code></pre>

<p>检查改变后的指令打
复制代码</p>

<pre><code>x/i 0x0003babc
</code></pre>

<p>得到改变后的指令代码是
复制代码</p>

<pre><code>add r1, r0, r5, lsl #5
</code></pre>

<p>这样就不用离开 gdb 即时看到修改代码后的效果</p>

<p>⑤ gdb 执行到程序中其他地址的命令</p>

<pre><code>例子：
stepi                           单步执行一个机器指令(命令步入函数)
nexti                           单步执行一个机器指令(命令步过函数)
nexti 2                        继续执行机器指令的数目为 2 个指令
finish                          继续执行至当前函数结束后，停止于其调用点
until *0x7b224            继续执行至特定地址*0x7b224
jump *0x3baac           跳转至特定地址*0x3baac 执行
</code></pre>

<p>⑥ gdb 调试记录的命令</p>

<pre><code>例子：
set logging file ./log1.txt      设定记录档
set logging on                     开始记录
set logging off                     停止记录
</code></pre>

<p>⑦ 学习别人修改程序的方法
看别人修改程序是最好的学习方法，只要你有原版本及修改后的版本，就可以知道修改的地址及方法
例如：
下载花儿朵朵开-v1.0.rar 原版本</p>

<p>下载花儿朵朵开-v1.0.rar 不死作弊修改版</p>

<p>解压后将两个 ipa 文件，用 winscp 传到iPhone 路径 /var/root/flower 内</p>

<p>在 PuTTY / Terminal 连接iPhone / iPod Touch后</p>

<p>打
复制代码</p>

<pre><code>cd /var/root/flower
</code></pre>

<p>解压原游戏版本程序
在 PuTTY / Terminal 打
复制代码</p>

<pre><code>unzip *-v1.0.ipa
mv Payload/FlowerChainCN.app/FlowerChainCN FlowerChainCN.original
</code></pre>

<p>删除不需要的的路径及档案
在 PuTTY / Terminal 打
复制代码</p>

<pre><code>rm -fr Payload/ iTunesArtwork *.ipa
</code></pre>

<p>解压不死作弊修改版程序
在 PuTTY / Terminal 打
复制代码</p>

<pre><code>unzip *-v1.0.ipod4g.ipa
mv Payload/FlowerChainCN.app/FlowerChainCN FlowerChainCN.patched
</code></pre>

<p>删除不需要的的路径及档案
在 PuTTY / Terminal 打
复制代码</p>

<pre><code>rm -fr Payload/ iTunesArtwork *.ipa
</code></pre>

<p>反汇编原游戏程式及保存反汇编文本文件为 FlowerChainCN.original.txt
在 PuTTY / Terminal 打
复制代码</p>

<pre><code>otool -tv FlowerChainCN.original &gt; FlowerChainCN.original.txt
</code></pre>

<p>反汇编不死作弊修改版程式及保存反汇编文本文件为 FlowerChainCN.patched.txt
在 PuTTY / Terminal 打
复制代码</p>

<pre><code>otool -tv FlowerChainCN.patched &gt; FlowerChainCN.patched.txt
</code></pre>

<p>比较两个版本及找出差异
在 PuTTY / Terminal 打
复制代码</p>

<pre><code>diff FlowerChainCN.original.txt FlowerChainCN.patched.txt
</code></pre>

<p>得到
复制代码</p>

<pre><code>&lt; FlowerChainCN.original:
---
&gt; FlowerChainCN.patched:
3060c3060
&lt; 00004ee8 e1520003 cmp r2, r3
---
&gt; 00004ee8 e3520001 cmp r2, #1 ; 0x1
</code></pre>

<p>原版本列在左边及把差异列在右边并输出差异文本保存为 FlowerChainCN.diff.txt
在 PuTTY / Terminal 打
复制代码</p>

<pre><code>diff -y --left-column FlowerChainCN.original.txt FlowerChainCN.patched.txt &gt; FlowerChainCN.diff.txt
</code></pre>

<p>用 less 工具打开差异文本 FlowerChainCN.diff.txt
在 PuTTY / Terminal 打
复制代码</p>

<pre><code>less FlowerChainCN.diff.txt
</code></pre>

<p>在 less 工具内搜寻差异分隔字符 |
在 less 工具内打
复制代码</p>

<pre><code>/\|
</code></pre>

<p>得到下面差异的显示去做进一步分析
复制代码</p>

<pre><code>00004ee8 e1520003 cmp r2, r3 | 00004ee8 e3520001 cmp r2, #1 ; 0x1
</code></pre>

<p>在 PuTTY / Terminal 打这句也可看到原版本上下的代码
复制代码</p>

<pre><code>grep -C5 '|' FlowerChainCN.diff.txt
</code></pre>

<p>或
复制代码</p>

<pre><code>grep -C5 00004ee8  FlowerChainCN.original.txt
</code></pre>

<p>⑧ 最后送上我自购破解的一个很实用的iPhone小工具 - 64位计算器
这小工具除了可以做64位的计算外，还可以输入文字及显示Unicode的代码</p>

<pre><code>64 Bit Calculator

 64_Bit_Calc-v1.2.ipod4g.ipa (788 K) 下载次数:233 




64 Bit Calculator (iPad)   64_Bit_Calc_iPad-v1.2.ipa (1521 K) 下载次数:116 
</code></pre>

<p>关于 FinalFantasy2 1.0.4 版本 ldid 签名时出现错误信息 Segmentation fault</p>

<p>初代 iPhone 使用ARMv6 指令集, 直到3GS, iPad, IPhone 4设备苹果开始采用了 ARMv7 指令集</p>

<p>如果你打指令</p>

<p>复制代码</p>

<pre><code>otool -f FinalFantasy2
</code></pre>

<p>就会看到</p>

<p>复制代码</p>

<pre><code>architecture 0
    cputype 12
    cpusubtype 6
architecture 1
    cputype 12
    cpusubtype 9
</code></pre>

<p>你可以把 FinalFantasy2 切开为 FinalFantasy2V6</p>

<p>复制代码</p>

<pre><code>lipo -thin armv6  FinalFantasy2 -output FinalFantasy2V6
chmod +x FinalFantasy2V6
chown mobile:mobile FinalFantasy2V6
</code></pre>

<p>及切开为 FinalFantasy2V7</p>

<p>复制代码</p>

<pre><code>cp -p FinalFantasy2 FinalFantasy2tmp
echo -ne "\x09" | dd bs=1 seek=15 conv=notrunc status=noxfer of=FinalFantasy2tmp
echo -ne "\x06" | dd bs=1 seek=35 conv=notrunc status=noxfer of=FinalFantasy2tmp
lipo -thin armv6 FinalFantasy2tmp -output FinalFantasy2V7
rm FinalFantasy2tmp
chmod +x FinalFantasy2V7
chown mobile:mobile FinalFantasy2V7
</code></pre>

<p>但 iPhone 的 otool 不支持反汇编 ARMv7 指令集, 你要用新版本的 IDA Pro 反汇编</p>

<p>在 iPhone 你只可以反汇编 FinalFantasy2V6, 修改及用 ldid 去签名</p>

<p>FinalFantasy2V6 签名后便可替代原版本使用, 游戏来说ARMv6 指令集也可以, 只不过在新的设备上使用时不是最优化.</p>

<p>.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/03/28/huoqushoujiduanxintongxunlulianxiren/">获取短信-联系人</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-03-28T13:32:08+08:00'><span class='date'><span class='date-month'>Mar</span> <span class='date-day'>28</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>1:32 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>越狱的 ios 如何 获取 读取 提取 手机上的 短信 通话记录 联系人 等信息</p>

<p><a href="http://willson.sinaapp.com/2011/12/iphone">http://willson.sinaapp.com/2011/12/iphone</a> 获取短信脚本.html  Iphone获取短信脚本
<a href="http://bbs.9ria.com/thread-209349-1-1.html">http://bbs.9ria.com/thread-209349-1-1.html</a>          IPhone短信相关部分研究（转载）
<a href="http://blog.csdn.net/slinloss/article/details/8722806">http://blog.csdn.net/slinloss/article/details/8722806</a>       整理：iOS 短信与电话事件的获取
<a href="http://308812025-qq-com.iteye.com/blog/1549756">http://308812025-qq-com.iteye.com/blog/1549756</a>              IOS 5 拦截手机短信(需越狱)</p>

<p><a href="http://www.iteye.com/problems/84131">http://www.iteye.com/problems/84131</a>                                IOS 短信截取 监听到了事件缺不能往下执行。。。</p>

<p><a href="http://blog.csdn.net/ceko_wu/article/details/8021133">http://blog.csdn.net/ceko_wu/article/details/8021133</a>     短信数据库分析（一）</p>

<p>一般地，ios只要越狱，整体的文件系统就全部暴漏出来，使用ifunbox 工具连接iphone，即可查看。</p>

<p>短信数据库的存放位置在ios的：    /private/var/mobile/Library/SMS/sms.db</p>

<p>联系人数据库存放的位置在ios的：//private/var/mobile/Library/AddressBook/AddressBook.sqlitedb</p>

<pre><code> 联系人的头像估计存放在这里：//private/var/mobile/Library/AddressBook/AddressBookImages.sqlitedb
</code></pre>

<p>通话记录数据库的存放路径是：//private/var/wireless/Library/CallHistory/call_history.db</p>

<p>备忘录数据库的存放路径是：//private/var/mobile/Library/Notes/notes.sqlite</p>

<p>safira 浏览器的收藏夹数据库存放路径是：//private/var/mobile/Library/Safari/Bookmarks.db</p>

<p>日历数据库的存放路径是：//private/var/mobile/Library/Calendar/Calendar.sqlitedb</p>

<p>上面的数据库，无论其后缀名是.db也好，.sqlitedb、.sqlite也好，它们的真实面目是，全部都是sqlite数据库。在实际查看这些数据库时，可以将其后缀名统一改成.sqlite，当然也可以不改。查看这些数据库最好的工具是 火狐浏览器上的插件：Sqlite Manager</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/03/25/springboardjiemianjiegoufenxi/">SpringBoard界面结构分析</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-03-25T13:32:08+08:00'><span class='date'><span class='date-month'>Mar</span> <span class='date-day'>25</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>1:32 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>SpringBoard界面层级结构分析</p>

<p>cycript -p 进程ID</p>

<p>通过cycript注入到SpringBoard进程中
首先SpringBoard有点类似于一般app的结构，只不过它是由好几个window构成的，总共如下：
  锁屏状态下是SBAlertWindow
  正常状态下是SBAppWindow
  通知栏滑下来时显示SBBulletinWindow
主要分析下正常状态的window</p>

<p>SpringBoard界面层级结构分析</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/03/22/fenxiQQweixinjiemianjiegou/">分析QQ-微信界面结构</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-03-22T13:32:08+08:00'><span class='date'><span class='date-month'>Mar</span> <span class='date-day'>22</span><span class='date-suffix'>nd</span>, <span class='date-year'>2016</span></span> <span class='time'>1:32 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>使用Reveal分析其他APP（如微信、qq等）的界面结构</p>

<p>特别提醒，现已无需按下面的方式注入libReveal.dlib了，只需把libReveal.dylib上传到设备的/Library/MobileSubstrate/DynamicLibraries，然后同时编辑并上传一个libReveal.plist，格式如下：</p>

<p>nixiang0001</p>

<p> 设定BundleID
注意，此时是可以指定多个BundleID的，也就是说，你可以同时监控任意多的app；再扩大一步说，如果你愿意，不上传这个libReveal.plist，你可以监控所有app，只要你不觉得机器很慢。。。
一定确保手机和电脑端处在同一局域网中，不然看不到界面的
Reveal.app 目前能搞到2.0.3的版本且能用注册机破解，但貌似对ios7.0以上的应用无效，需要Reveal2.0.4版，但又无法破解目前，2.0.3版本百度云下载
<a href="http://c.blog.sina.com.cn/profile.php?blogid=cb8a22ea89000gtw&amp;qq-pf-to=pcqq.c2c">http://c.blog.sina.com.cn/profile.php?blogid=cb8a22ea89000gtw&amp;qq-pf-to=pcqq.c2c</a></p>

<p>打开XCode创建iOSOpenDev&ndash;》Logos Tweak的工程</p>

<p>创建动态加载Reveal的类RevealUtil：</p>

<pre><code>//
//  RevealUtil.h
//  pyu
//
//  Created by whe on 6/23/13.
//
//

#import

@interface RevealUtil : NSObject {
    void *_revealLib;
}

- (void)startReveal;
- (void)stopReveal;

@end

//
//  RevealUtil.m
//  pyu
//
//  Created by whe on 6/23/13.
//
//
#import
#import
#import "RevealUtil.h"

@implementation RevealUtil

- (void)startReveal {
    NSString *revealLibName = @"libReveal.dylib";
    //NSString *revealLibExtension = @"dylib";
    NSString *bundlePath = [[NSBundle mainBundle] bundlePath];
   //此处要先将libReveal.dylib通过iTools上传到需要分析的App的Buldle主目录下（即xxx.app目录）
    NSString *dyLibPath = [NSString stringWithFormat:@"%@/%@",bundlePath,revealLibName];
    UIAlertView *alert = [[UIAlertView alloc]
                          initWithTitle:@"Welcome"  message:[NSString stringWithFormat:@"Loading dynamic library: %@", dyLibPath]
                          delegate:nil cancelButtonTitle:@"Thanks"
                          otherButtonTitles:nil];
    [alert show];
    [alert release];

    void *revealLib = NULL;
    revealLib = dlopen([dyLibPath cStringUsingEncoding:NSUTF8StringEncoding], RTLD_NOW);

    if (revealLib == NULL)
    {
        char *error = dlerror();
        NSLog(@"dlopen error: %s", error);
    }else {
        [[NSNotificationCenter defaultCenter] postNotificationName:@"IBARevealRequestStart" object:self];
    }
}

- (void)stopReveal {
    if (_revealLib)
    {
        [[NSNotificationCenter defaultCenter] postNotificationName:@"IBARevealRequestStop" object:self];
        if (dlclose(_revealLib) == 0)
        {
            NSLog(@"Reveal library unloaded");
            _revealLib = NULL;
        }
        else
        {
            char *error = dlerror();
            NSLog(@"Reveal library could not be unloaded: %s", error);
        }
    }
}

@end
</code></pre>

<p>修改工程的xm文件内容如下：</p>

<pre><code>#import "RevealUtil.h"
</code></pre>

<p>%hook MobileAssistAppDelegate //对应分析APP的AppDelegate文件类名，不同的App这个类名可能不同，这可以先通过class-dump  xxx.app这个二进制文件，得出该APP所有的头文件，然后搜索关键字didFinishLaunchingWithOptions，找到对应文件并查看该文件内的类名即是</p>

<pre><code>- (BOOL)application:(id)arg1 didFinishLaunchingWithOptions:(id)arg2 {
    %orig;

    RevealUtil *ru = [[RevealUtil alloc] init];
    [ru startReveal];

    return YES;
}

%end
</code></pre>

<p>最终项目结构如下：</p>

<p>nixiang0002</p>

<p>注意那个Filter，其实可以不填，但要填一定要是该app的bundle identifier</p>

<p>附：OpenSSH的使用：
       ssh <a href="&#109;&#97;&#x69;&#108;&#x74;&#x6f;&#x3a;&#114;&#111;&#111;&#116;&#64;&#x31;&#x39;&#x32;&#46;&#x31;&#54;&#56;&#46;&#50;&#46;&#x35;">&#114;&#x6f;&#111;&#116;&#64;&#x31;&#57;&#50;&#x2e;&#49;&#54;&#x38;&#x2e;&#x32;&#x2e;&#53;</a> 默认密码alpine
     先通过ssh登录到手机，然后可以通过cycript -p 进程ID   依附在需要分析的应用程序上  ps ax | grep PP</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/03/20/siyouapi/">私有API</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-03-20T13:32:08+08:00'><span class='date'><span class='date-month'>Mar</span> <span class='date-day'>20</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>1:32 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>一．基本知识</p>

<p>iPhone中的API除了公开的 API：Published API外（或者叫文档中记录的API：Documented API），还有两类API：私有API：Private API和未公开的API：UnPublished API(或者叫文档中未记录的API：Undocumented API)。其中私有API是指放在PrivateFrameworks框架中的API，未公开的API是指虽然放在Frameworks框架中，但是却没有在苹果的官方文档中有使用说明、代码介绍等记录的API。后两种API是有区别的，按苹果的说法，未公开的API是还不够成熟，可能还会变动的API，等完全成型了后会变成公开的API，但是目前不对其提供承诺，就是系统版本升级后可能会失效。而私有API是苹果明确不能使用的API。虽然两者有所区别，但是在具体使用方法上是类似的。</p>

<p>二．具体介绍
1.导出生成私有API的头文件声明
使用私有或未公开的API，首先需要导出其对应的头文件，在头文件里有相关函数的声明。
工具：
class-dump
class-dump可以从编译后的Objective-C的二进制文件中提取对应的数据结构及函数等声明。
使用方法：
为了能在任意目录下使用class-dump命令，首先建议把class-dump文件拷贝到/user/local/bin/目录下，然后就可以在任意目录下执行以下命令：</p>

<p>class-dump /Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator3.0.sdk/System/Library/Frameworks/UIKit.framework/ >UIKit.h</p>

<p>以上命令就可以把 iPhoneSimulator3.0.Sdk中Frameworks框架里的UIKit.Framework框架的数据结构及函数声明等给提取出来，并且放在UIKit.h这个文件中，之后你就可以在这个头文件中找你需要API的声明及其使用方式。以同样的方法，就可以挨个导出你需要那个框架中的API 声明。</p>

<p>也可以用ericasadun写的DumpFrameworks.pl（文件中有部分注释说明）这个文件把私有框架下的API头文件全部提取出来。使用方法也是首先把class-dump文件拷贝到/user/local/bin/目录下，然后在任意一个目录下执行./DumpFrameworks.pl,然后就会在你的家目录下产生一个Headers文件夹，里面罗列了私有框架下的API头文件。</p>

<p>2.使用私有API</p>

<p>导出了私有API的头文件声明后，使用方法就比较简单了，首先在你的工程中包含进头文件，然后导入对应的框架，之后就可以类似提供了静态库的方式在我们的代码中使用这些私有API函数。</p>

<p>三．附加说明</p>

<p>iPhone编程中一些非常精致好玩的API都包含在私有API或未公开的API中，虽然我们可以以这种方式使用这些非常好的API，但是这样做是存在一定风险的，首先为公开的API有变更的可能，这样在每个固件版本中，你的代码都有可能中断。同时，最大的问题是使用了私有API的程序是不能放在App Store上销售的。因此如果我们只是为了好玩体验iPhone中这些精彩的API，那没关系。如果是为了做出程序放在App Store上销售的，那就不要动私有API的主意了。</p>

<hr />

<p>class-dump-x 提取私有库里面的隐藏文件
class-dump</p>

<p>This is a command-line utility for examining the Objective-C runtime information stored in Mach-O files. It generates declarations for the classes, categories and protocols. This is the same information provided by using &lsquo;otool -ov&rsquo;, but presented as normal Objective-C declarations, so it is much more compact and readable.
Why use class-dump?</p>

<p>It&rsquo;s a great tool for the curious. You can look at the design of closed source applications, frameworks, and bundles. Watch the interfaces evolve between releases. Experiment with private frameworks, or see what private goodies are hiding in the AppKit. Learn about the plugin API lurking in Mail.app.</p>

<p>If you find class-dump useful, you can donate to help support its development. Thanks!
Download</p>

<p>Current version: 3.3.3 (Universal, 64 and 32 bit)
Requires Mac OS X 10.5 or later.</p>

<pre><code>class-dump-3.3.3.dmg
class-dump-3.3.3.tar.gz
class-dump-3.3.3.tar.bz2
</code></pre>

<p>Changes - News
Contact</p>

<p>You can email questions and bug reports to me at class-dump@codethecode.com, or nygard at gmail.com.
Usage</p>

<p>class-dump 3.3.3 (64 bit)
Usage: class-dump [options] <mach-o-file></p>

<p>  where options are:
        -a             show instance variable offsets
        -A             show implementation addresses
        &ndash;arch <arch>  choose a specific architecture from a universal binary (ppc, ppc7400, ppc64, i386, x86_64, etc.)
        -C <regex>     only display classes matching regular expression
        -f <str>       find string in method name
        -H             generate header files in current directory, or directory specified with -o
        -I             sort classes, categories, and protocols by inheritance (overrides -s)
        -o <dir>       output directory used for -H
        -r             recursively expand frameworks and fixed VM shared libraries
        -s             sort classes and categories by name
        -S             sort methods by name
        -t             suppress header in output, for testing
        &ndash;list-arches  list the arches in the file, then exit
        &ndash;sdk-root     specify the SDK root path (full path, or 4.1, 4.0, 3.2, 10.6, 10.5, 3.1.3, 3.1.2, 3.1)</p>

<p>License</p>

<p>This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.</p>

<p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.</p>

<p>You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</p>

<p> class-dump -H  /Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator2.1.sdk/System/Library/CoreServices/SpringBoard.app/SpringBoard</p>

<pre><code> -o 
</code></pre>

<p>~/Desktop/SpringBoard</p>

<p>下载：<a href="http://ericasadun.com/HeaderDumpKit/">http://ericasadun.com/HeaderDumpKit/</a></p>

<p>使用：
1 将下载好的 class-dump 放入usr/local/bin 下.
   如果 ‘/usr/local/bin’ 不知道在哪里，可以在terminal 下输入 ‘open -a Finder /usr/local/bin’ 以便打开目录.
   记着 class-dump 要 使用 chmod 修改下执行权限.   例如：在usr/local/bin 对 class-dump 修改，可以这    样在terminal 切换到 usr/local/bin 目录下: chmod 777 class-dump .
2 将DumpFrameworks.pl 放入任意目录下.同样需要修改执行权限.</p>

<ol>
<li>OK..现在所有的准备工作作好了. 我们在 terminal 的任意目录下 输入 ： ./DumpFrameworks.pl
等待&hellip;
会有一个Heards 文件夹在你的主目录下. 里面包含了 Frmeworks 和 privateFrameworks 下所有的私有        API,尽情享用吧.!</li>
</ol>


<hr />

<p> 作为 Objective-C / Cocoa Touch 开发者，在经历了呕心沥血十月怀胎终于孕育出了一个代码包，然后踌躇满志准备提交给天杀的 Apple App Review Team  审核之时，别急，我们仍然需要诚惶诚恐的考虑一个问题，我们的代码里是否用到了 Private API ？</p>

<pre><code>什么是 Private API ？简而言之，就是这个 API 真实存在于 Cocoa Touch 中，但它又不是 Public API （有点绕吧…）。那什么是 Public API 呢？Public API 就是苹果通过 Cocoa Touch 向全世界第三方开发者公开的所有 API 。在哪可以查到 Public API ？在你的 Xcode 工程中就能查到。如这幅截图所示， Xcode 中所有 framework 的头文件都是我们可用肉眼查询的 Public API 列表。



同此同时，民间也流传着一个非官方的 Private API 列表。(iphone-private-frameworks)

于是你说，那问题不就解决了呗，只要我们洁身自好，保证自己的代码里只使用 Cocoa Touch 公布的 API ，我们就肯定不会惹上 Private API 啦。

然而实际情况往往不是这样，当今世界，嗯嗯当今世界，App Store 的竞争越发激烈，每位开发者都希望自己的代码能站在前辈优秀开源代码的基础上高屋建瓴，而不是每新建一个工程就得自己花十天半个月一遍遍 reinvent the wheel 重造车轮。 随手举几个例子， ASIHTTPRequest 、JSON 、Facebook / Three20 、 SFHFKeychainUtils ，这几套知名开源代码包存在于许许多多优秀的 iOS 应用之中。其他名气稍小但是同样流传广泛的开源或者闭源代码包就更数不胜数了。作为开发者，我们不得不频繁面对这样一个问题，我们如何确保这些第三方的代 码报里，不存在 private API ？

苹果提供了几种机器识别方法，比如 string 命令，比如 otool -ov 命令，但都不太好用。江湖上有人做了一套解决方案，名叫 AppScanner ，我老人家决定强烈推荐一下。( 貌似现在用xcode提交项目时会检测一遍是否有私有函数 )

怎么用？很简单，你把AppScanner工程编译好，然后直接将 .app 文件夹整个拖进 AppScanner 窗口里。
免费的么？几乎是免费的，虽然收费（也才 $2.99 ），但是头 14 天免费。
是否有人维护？有，而且只要你愿意出 $2.99 支持他们维护。他们还会继续开发下去。

这是一个实例的截屏，头两项 API 可疑度 100% ，说明它们就是来搞破坏的 Private API。



最后插一则八卦， Facebook / Three20 如雷贯耳，想必很多开发者都使用过。然而要命的事，在 Three20 的第一个版本中，就悄悄的藏着一条因为重名导致的假阳性 Private API 。虽然是假阳性，但那次事故仍然导致了所有使用那个版本 Three20 的 app 被惨拒。当然了，后来他们很快就修正了这个问题。
</code></pre>

<p>使用私有api开启了iphone的蓝牙。现在把方法分享出来，希望能给大家提供一些思路。</p>

<p>1.首先在/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS4.3.sdk/System/Library/PrivateFrameworks路径下找到BluetoothManager.framework（如果我没估计错的话，里面只有一个库文件，没有头文件）
2. 所需的头文件，手动添加到BluetoothManager.framework中，并建立一个Headers文件夹。
3.建立一个工程将以上路径下的BluetoothManager.framework添加到工程中
4.将以下代码添加到工程中。（注意：不需要引入BluetoothManager的头文件，否则会出现编译错误）</p>

<p>-(void)startBluetooth{</p>

<h1>if TARGET_IPHONE_SIMULATOR</h1>

<pre><code>exit( EXIT_SUCCESS ) ;
</code></pre>

<h1>else</h1>

<pre><code>/* this works in iOS 4.2.3 */
Class BluetoothManager = objc_getClass( "BluetoothManager" ) ;
id btCont = [BluetoothManager sharedInstance] ;
[self performSelector:@selector(toggle:) withObject:btCont afterDelay:1.0f] ;
</code></pre>

<h1>endif</h1>

<p>}</p>

<h1>if TARGET_IPHONE_SIMULATOR</h1>

<h1>else</h1>

<ul>
<li>(void)toggle:(id)btCont
{
  BOOL currentState = [btCont enabled] ;
  [btCont setEnabled:!currentState] ;
  [btCont setPowered:!currentState] ;</li>
</ul>


<p>}</p>

<h1>endif</h1>

<p>5.在真机上编译运行，会发现iphone的蓝牙成功开启。</p>

<p>但是，遗憾的是，目前我研究出来的只有开启蓝牙，关于设备匹配，数据传输方面没什么进展。
希望有人能再接再厉，在我的基础上研究出设备匹配和数据传输的方法</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/2">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
    <h1>文章分类</h1>
    <ul id="categories">
        <li class='category'><a href='/blog/categories/advanced/'>advanced (22)</a></li>
<li class='category'><a href='/blog/categories/algorithm/'>algorithm (1)</a></li>
<li class='category'><a href='/blog/categories/background/'>background (1)</a></li>
<li class='category'><a href='/blog/categories/bottom/'>bottom (5)</a></li>
<li class='category'><a href='/blog/categories/developer/'>developer (7)</a></li>
<li class='category'><a href='/blog/categories/fore-end/'>fore-end (2)</a></li>
<li class='category'><a href='/blog/categories/interview/'>interview (1)</a></li>
<li class='category'><a href='/blog/categories/necessary/'>necessary (5)</a></li>
<li class='category'><a href='/blog/categories/newfeatures/'>newfeatures (5)</a></li>
<li class='category'><a href='/blog/categories/performance/'>performance (8)</a></li>
<li class='category'><a href='/blog/categories/projects/'>projects (27)</a></li>
<li class='category'><a href='/blog/categories/summary/'>summary (40)</a></li>
<li class='category'><a href='/blog/categories/tools/'>tools (5)</a></li>
<li class='category'><a href='/blog/categories/watchos2/'>watchos2 (1)</a></li>

    </ul>
</section><section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2016/04/25/nixiangzongjie/">Nixiangzongjie</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/04/20/weixinjiqiren/">微信机器人</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/04/15/qudongkaifa/">驱动开发</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/04/10/nixiangzhifubao/">逆向支付宝</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/04/05/fei6sshixian3dtouch/">非6S-实现3D Touch</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/al1020119">@al1020119</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'al1020119',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>




<section>
<h1>扫一扫<abbr title="The word '扫一扫' is a registered trademark of DENSO WAVE INCORPORATED. It applies only for the word '扫一扫', not for image.">&trade;</abbr></h1>
<a href="http://al1020119.github.io/index.html"><img src="http://chart.apis.google.com/chart?chs=150x150&cht=qr&chld=|0&chco=165B94&chl=http://al1020119.github.io/index.html" alt="post-qrcode"></a></section>
<section>
    <h1>访客统计</h1>
    <br/>
    <a href="http://s07.flagcounter.com/more/2SH"><img src="http://s07.flagcounter.com/count/2SH/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_1/flags_0/" alt="Flag Counter" border="0"></a>
</section><section>
    <h1>新浪微博</h1>
    <ul id="weibo">
        <li>
            
            <!-- 在此插入获得的微博秀代码 -->
            <iframe width="100%" height="550" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=550&fansRow=2&ptype=1&speed=0&skin=1&isTitle=1&noborder=1&isWeibo=1&isFans=1&uid=3288975567&verifier=20ffcedd&dpc=1"></iframe>
            
        </li>
    </ul>
</section>
  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2016 - iCocos -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  











</body>
</html>
