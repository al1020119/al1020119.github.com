
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>iOS梦工厂</title>
  <meta name="author" content="iCocos">

  
  <meta name="description" content="网上请求疯（封）装 ordinal 一直想总结一下关于iOS的离线数据缓存的方面的问题，然后最近也简单的对AFN进行了再次封装，所有想把这两个结合起来写一下。数据展示型的页面做离线缓存可以有更好的用户体验，用户在离线环境下仍然可以获取一些数据，这里的数据缓存首选肯定是SQLite，轻量级， &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://al1020119.github.io/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="iOS梦工厂" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//libs.baidu.com/jquery/1.7.2/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <script>
function addBlankTargetForLinks () {
    $('a[href^="http"]').each(function(){
                              $(this).attr('target', '_blank');
                              });
}
$(document).bind('DOMNodeInserted', function(event) {
             addBlankTargetForLinks();
             });
</script>
  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">iOS梦工厂</a></h1>
  
    <h2>不战胜自己，何以改变未来！</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="al1020119.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">首页</a></li>
  <li><a href="/blog/archives">归档</a></li>
  <li><a href="/icocos">iCocos</a></li>
  <li><a href="/other">其他</a></li>
  <li><a href="/about">关于</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/12/04/wang-shang-qing-qiu-feng-(feng-)zhuang/">网上请求疯（封）装</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><p>一直想总结一下关于iOS的离线数据缓存的方面的问题，然后最近也简单的对AFN进行了再次封装，所有想把这两个结合起来写一下。数据展示型的页面做离线缓存可以有更好的用户体验，用户在离线环境下仍然可以获取一些数据，这里的数据缓存首选肯定是SQLite，轻量级，对数据的存储读取相对于其他几种方式有优势，这里对AFN的封装没有涉及太多业务逻辑层面的需求，主要还是对一些方法再次封装方便使用，解除项目对第三方的耦合性，能够简单的快速的更换底层使用的网络请求代码。这篇主要写离线缓存思路，对AFN的封装只做简单的介绍。</p>

<p>关于XLNetworkApi</p>

<p>XLNetworkApi的一些功能和说明：</p>

<p>使用XLNetworkRequest做一些GET、POST、PUT、DELETE请求，与业务逻辑对接部分直接以数组或者字典的形式返回。
以及网络下载、上传文件，以block的形式返回实时的下载、上传进度，上传文件参数通过模型XLFileConfig去存取。
通过继承于XLDataService来将一些数据处理，模型转化封装起来，于业务逻辑对接返回的是对应的模型，减少Controllor处理数据处理逻辑的压力。
自定义一些回调的block</p>

<pre><code>/**
请求成功block
*/
typedef void (^requestSuccessBlock)(id responseObj);
/**
请求失败block
*/
typedef void (^requestFailureBlock) (NSError *error);
/**
请求响应block
*/
typedef void (^responseBlock)(id dataObj, NSError *error);
/**
监听进度响应block
*/
typedef void (^progressBlock)(int64_t bytesWritten, int64_t totalBytesWritten, int64_t totalBytesExpectedToWrite);
XLNetworkRequest.m部分实现
#import "XLNetworkRequest.h"
#import "AFNetworking.h"
@implementation XLNetworkRequest
+ (void)getRequest:(NSString *)url params:(NSDictionary *)params success:(requestSuccessBlock)successHandler failure:(requestFailureBlock)failureHandler {
//网络不可用
  if (![self checkNetworkStatus]) {
      successHandler(nil);
      failureHandler(nil);
      return;
  }
  AFHTTPRequestOperationManager *manager = [self getRequstManager];
  [manager GET:url parameters:params success:^(AFHTTPRequestOperation * _Nonnull operation, id  _Nonnull responseObject) {
      successHandler(responseObject);
  } failure:^(AFHTTPRequestOperation * _Nullable operation, NSError * _Nonnull error) {
      XLLog(@"------请求失败-------%@",error);
      failureHandler(error);
  }];
}
</code></pre>

<p>下载部分代码</p>

<pre><code>    //下载文件，监听下载进度
    + (void)downloadRequest:(NSString *)url successAndProgress:(progressBlock)progressHandler complete:(responseBlock)completionHandler {
      if (![self checkNetworkStatus]) {
          progressHandler(0, 0, 0);
          completionHandler(nil, nil);
          return;
      }
      NSURLSessionConfiguration *sessionConfiguration = [NSURLSessionConfiguration defaultSessionConfiguration];
      AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:sessionConfiguration];
      NSURLRequest *request = [NSURLRequest requestWithURL:[NSURL URLWithString:url]];
      NSProgress *kProgress = nil;
      NSURLSessionDownloadTask *downloadTask = [manager downloadTaskWithRequest:request progress:&amp;kProgress destination:^NSURL * _Nonnull(NSURL * _Nonnull targetPath, NSURLResponse * _Nonnull response) {
          NSURL *documentUrl = [[NSFileManager defaultManager] URLForDirectory :NSDocumentDirectory inDomain:NSUserDomainMask appropriateForURL:nil create:NO error:nil];
          return [documentUrl URLByAppendingPathComponent:[response suggestedFilename]];
      } completionHandler:^(NSURLResponse * _Nonnull response, NSURL * _Nonnull filePath, NSError * _Nonnull error){
          if (error) {
              XLLog(@"------下载失败-------%@",error);
          }
          completionHandler(response, error);
      }];
      [manager setDownloadTaskDidWriteDataBlock:^(NSURLSession * _Nonnull session, NSURLSessionDownloadTask * _Nonnull downloadTask, int64_t bytesWritten, int64_t totalBytesWritten, int64_t totalBytesExpectedToWrite) {
          progressHandler(bytesWritten, totalBytesWritten, totalBytesExpectedToWrite);
      }];
      [downloadTask resume];
    }
</code></pre>

<p>上传部分代码</p>

<pre><code>//上传文件，监听上传进度
+ (void)updateRequest:(NSString *)url params:(NSDictionary *)params fileConfig:(XLFileConfig *)fileConfig successAndProgress:(progressBlock)progressHandler complete:(responseBlock)completionHandler {
  if (![self checkNetworkStatus]) {
      progressHandler(0, 0, 0);
      completionHandler(nil, nil);
      return;
  }
  NSMutableURLRequest *request = [[AFHTTPRequestSerializer serializer] multipartFormRequestWithMethod:@"POST" URLString:url parameters:params constructingBodyWithBlock:^(id  _Nonnull formData) {
      [formData appendPartWithFileData:fileConfig.fileData name:fileConfig.name fileName:fileConfig.fileName mimeType:fileConfig.mimeType];
  } error:nil];
  //获取上传进度
  AFHTTPRequestOperation *operation = [[AFHTTPRequestOperation alloc] initWithRequest:request];
  [operation setUploadProgressBlock:^(NSUInteger bytesWritten, long long totalBytesWritten, long long totalBytesExpectedToWrite) {
      progressHandler(bytesWritten, totalBytesWritten, totalBytesExpectedToWrite);
  }];
  [operation setCompletionBlockWithSuccess:^(AFHTTPRequestOperation * _Nonnull operation, id  _Nonnull responseObject) {
      completionHandler(responseObject, nil);
  } failure:^(AFHTTPRequestOperation * _Nonnull operation, NSError * _Nonnull error) {
      completionHandler(nil, error);
      if (error) {
          XLLog(@"------上传失败-------%@",error);
      }
  }];
  [operation start];
}
</code></pre>

<p>XLDataService.m部分实现</p>

<pre><code>+ (void)getWithUrl:(NSString *)url param:(id)param modelClass:(Class)modelClass responseBlock:(responseBlock)responseDataBlock {
      [XLNetworkRequest getRequest:url params:param success:^(id responseObj) {
      //数组、字典转化为模型数组
      dataObj = [self modelTransformationWithResponseObj:responseObj modelClass:modelClass];
      responseDataBlock(dataObj, nil);
  } failure:^(NSError *error) {
      responseDataBlock(nil, error);
  }];
}
</code></pre>

<p>（关键）下面这个方法提供给继承XLDataService的子类重写，将转化为模型的代码写在这里，相似业务的网络数据请求都可以用这个子类去请求数据，直接返回对应的模型数组。
    /<em>*
    数组、字典转化为模型
    </em>/
    + (id)modelTransformationWithResponseObj:(id)responseObj modelClass:(Class)modelClass {
         return nil;
    }
关于离线数据缓存</p>

<p>当用户进入程序的展示页面，有三个情况下可能涉及到数据库存取操作，简单画了个图来理解，思路比较简单，主要是一些存取的细节处理。</p>

<p>进入展示页面</p>

<p><img src="/images/net001.png" title="Caption" ></p>

<p>下拉刷新最新数据</p>

<p><img src="/images/net002.png" title="Caption" ></p>

<p>上拉加载更多数据</p>

<p><img src="/images/net003.png" title="Caption" ></p>

<p>需要注意的是，上拉加载更多的时候，每次从数据库返回一定数量的数据，而不是一次性将数据全部加载，否则会有内存问题，直到数据库中没有更多数据时再发生网络请求，再次将新数据存入数据库。这里存储数据的方式是将服务器返回每组数据的字典归档成二进制作为数据库字段直接存储，这样存储在模型属性比较多的情况下更有好处，避免每一个属性作为一个字段，另外增加了一个idStr字段用来判断数据的唯一性，避免重复存储。
首先定义一个工具类XLDataBase来做数据库相关的操作，这里用的是第三方的FMDB。</p>

<pre><code>#import "XLDataBase.h"
#import "FMDatabase.h"
#import "Item.h"
#import "MJExtension.h"
@implementation XLDataBase
static FMDatabase *_db;
+ (void)initialize {
    NSString *path = [NSString stringWithFormat:@"%@/Library/Caches/Data.db",NSHomeDirectory()];
    _db = [FMDatabase databaseWithPath:path];
    [_db open];
    [_db executeUpdate:@"CREATE TABLE IF NOT EXISTS t_item (id integer PRIMARY KEY, itemDict blob NOT NULL, idStr text NOT NULL)"];
}
//存入数据库
+ (void)saveItemDict:(NSDictionary *)itemDict {
    //此处把字典归档成二进制数据直接存入数据库，避免添加过多的数据库字段
    NSData *dictData = [NSKeyedArchiver archivedDataWithRootObject:itemDict];
    [_db executeUpdateWithFormat:@"INSERT INTO t_item (itemDict, idStr) VALUES (%@, %@)",dictData, itemDict[@"id"]];
}
//返回全部数据
+ (NSArray *)list {
    FMResultSet *set = [_db executeQuery:@"SELECT * FROM t_item"];
    NSMutableArray *list = [NSMutableArray array];
    while (set.next) {
        // 获得当前所指向的数据
        NSData *dictData = [set objectForColumnName:@"itemDict"];
        NSDictionary *dict = [NSKeyedUnarchiver unarchiveObjectWithData:dictData];
        [list addObject:[Item mj_objectWithKeyValues:dict]];
    }
    return list;
}
//取出某个范围内的数据
+ (NSArray *)listWithRange:(NSRange)range {
    NSString *SQL = [NSString stringWithFormat:@"SELECT * FROM t_item LIMIT %lu, %lu",range.location, range.length];
    FMResultSet *set = [_db executeQuery:SQL];
    NSMutableArray *list = [NSMutableArray array];
    while (set.next) {
        NSData *dictData = [set objectForColumnName:@"itemDict"];
        NSDictionary *dict = [NSKeyedUnarchiver unarchiveObjectWithData:dictData];
        [list addObject:[Item mj_objectWithKeyValues:dict]];
    }
    return list;
}
//通过一组数据的唯一标识判断数据是否存在
+ (BOOL)isExistWithId:(NSString *)idStr
{
    BOOL isExist = NO;
    FMResultSet *resultSet= [_db executeQuery:@"SELECT * FROM t_item where idStr = ?",idStr];
    while ([resultSet next]) {
        if([resultSet stringForColumn:@"idStr"]) {
            isExist = YES;
        }else{
            isExist = NO;
        }
    }
    return isExist;
}
@end
</code></pre>

<p>一些继承于XLDataService的子类的数据库存储和模型转换的逻辑代码</p>

<pre><code>#import "GetTableViewData.h"
#import "XLDataBase.h"
@implementation GetTableViewData
//重写父类方法
+ (id)modelTransformationWithResponseObj:(id)responseObj modelClass:(Class)modelClass {
    NSArray *lists = responseObj[@"data"][@"list"];
    NSMutableArray *array = [NSMutableArray array];
    for (NSDictionary *dict in lists) {
        [modelClass mj_setupReplacedKeyFromPropertyName:^NSDictionary *{
            return @{ @"ID" : @"id" };
        }];
        [array addObject:[modelClass mj_objectWithKeyValues:dict]];
        //通过idStr先判断数据是否存储过，如果没有，网络请求新数据存入数据库
        if (![XLDataBase isExistWithId:dict[@"id"]]) {
            //存数据库
            NSLog(@"存入数据库");
            [XLDataBase saveItemDict:dict];
        }
    }
    return array;
}
</code></pre>

<p>下面是一些控制器的代码实现：</p>

<pre><code>#import "ViewController.h"
#import "GetTableViewData.h"
#import "Item.h"
#import "XLDataBase.h"
#import "ItemCell.h"
#import "MJRefresh.h"
#define URL_TABLEVIEW @"https://api.108tian.com/mobile/v3/EventList?cityId=1&amp;step=10&amp;theme=0&amp;page=%lu"
@interface ViewController () {
    NSMutableArray *_dataArray;
    UITableView *_tableView;
    NSInteger _currentPage;//当前数据对应的page
}
@end
@implementation ViewController
#pragma mark Life cycle
- (void)viewDidLoad {
    [super viewDidLoad];
    // Do any additional setup after loading the view, typically from a nib.
    [self createTableView];
    _dataArray = [NSMutableArray array];
}
- (void)viewWillAppear:(BOOL)animated {
    [super viewWillAppear:animated];
    NSRange range = NSMakeRange(0, 10);
    //如果数据库有数据则读取，不发送网络请求
    if ([[XLDataBase listWithRange:range] count]) {
        [_dataArray addObjectsFromArray:[XLDataBase listWithRange:range]];
        NSLog(@"从数据库加载");
    }else{
        [self getTableViewDataWithPage:0];
    }
}
#pragma mark UI
- (void)createTableView {
    _tableView = [[UITableView alloc] initWithFrame:self.view.bounds];
    _tableView.delegate = self;
    _tableView.dataSource = self;
    _tableView.rowHeight = 100.0;
    [self.view addSubview:_tableView];
    _tableView.mj_header = [MJRefreshNormalHeader headerWithRefreshingBlock:^{
        [self loadNewData];
    }];
    _tableView.mj_footer = [MJRefreshAutoNormalFooter footerWithRefreshingBlock:^{
        [self loadMoreData];
    }];
}
#pragma mark GetDataSoure
- (void)getTableViewDataWithPage:(NSInteger)page {
    NSLog(@"发送网络请求！");
    NSString *url = [NSString stringWithFormat:URL_TABLEVIEW, page];
    [GetTableViewData getWithUrl:url param:nil modelClass:[Item class] responseBlock:^(id dataObj, NSError *error) {
        [_dataArray addObjectsFromArray:dataObj];
        [_tableView reloadData];
        [_tableView.mj_header endRefreshing];
        [_tableView.mj_footer endRefreshing];
    }];
}
- (void)loadNewData {
    NSLog(@"下拉刷新");
    _currentPage = 0;
    [_dataArray removeAllObjects];
    [self getTableViewDataWithPage:_currentPage];
}
- (void)loadMoreData {
    NSLog(@"上拉加载");
    _currentPage ++;
    NSRange range = NSMakeRange(_currentPage * 10, 10);
    if ([[XLDataBase listWithRange:range] count]) {
        [_dataArray addObjectsFromArray:[XLDataBase listWithRange:range]];
        [_tableView reloadData];
        [_tableView.mj_footer endRefreshing];
        NSLog(@"数据库加载%lu条更多数据",[[XLDataBase listWithRange:range] count]);
    }else{
        //数据库没更多数据时再网络请求
        [self getTableViewDataWithPage:_currentPage];
    }
}
#pragma mark UITableViewDataSource
- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section {
    return _dataArray.count;
}
- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {
    ItemCell *cell = [ItemCell itemCellWithTableView:tableView];
    cell.item = _dataArray[indexPath.row];
    return cell;
}
@end
</code></pre>

<p>最后附上代码的下载地址，重要的部分代码中都有相应的注释和文字打印，运行程序可以很直观的表现。</p>

<p><a href="https://github.com/ShelinShelin/OffLineCache.git">Demo</a></p>

<p>希望大家能提出一些意见，很乐意与大家互相交流。</p>
</div>
  
  




| <a href="/blog/2015/12/04/wang-shang-qing-qiu-feng-(feng-)zhuang/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/12/04/xu-lie-hua-and-fan-xu-lie-hua-shen-jiu/">序列化&amp;反序列化深究</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><ul>
<li>摘要
序列化和反序列化几乎是工程师们每天都要面对的事情，但是要精确掌握这两个概念并不容易：一方面，它们往往作为框架的一部分出现而湮没在框架之中；另一方面，它们会以其他更容易理解的概念出现，例如加密、持久化。然而，序列化和反序列化的选型却是系统设计或重构一个重要的环节，在分布式、大数据量系统设计里面更为显著。恰当的序列化协议不仅可以提高系统的通用性、强健性、安全性、优化系统性能，而且会让系统更加易于调试、便于扩展。本文从多个角度去分析和讲解“序列化和反序列化”，并对比了当前流行的几种序列化协议，期望对读者做序列化选型有所帮助。</li>
</ul>


<h2>简介</h2>

<p>文章作者服务于美团推荐与个性化组，该组致力于为美团用户提供每天billion级别的高质量个性化推荐以及排序服务。从Terabyte级别的用户行为数据，到Gigabyte级别的Deal/Poi数据；从对实时性要求毫秒以内的用户实时地理位置数据，到定期后台job数据，推荐与重排序系统需要多种类型的数据服务。推荐与重排序系统客户包括各种内部服务、美团客户端、美团网站。为了提供高质量的数据服务，为了实现与上下游各系统进行良好的对接，序列化和反序列化的选型往往是我们做系统设计的一个重要考虑因素。</p>

<p>本文内容按如下方式组织：</p>

<ul>
<li>第一部分给出了序列化和反序列化的定义，以及其在通讯协议中所处的位置。</li>
<li>第二部分从使用者的角度探讨了序列化协议的一些特性。</li>
<li>第三部分描述在具体的实施过程中典型的序列化组件，并与数据库组建进行了类比。</li>
<li>第四部分分别讲解了目前常见的几种序列化协议的特性，应用场景，并对相关组件进行举例。</li>
<li>最后一部分，基于各种协议的特性，以及相关benchmark数据，给出了作者的技术选型建议。</li>
</ul>


<h4>一、定义以及相关概念</h4>

<p>互联网的产生带来了机器间通讯的需求，而互联通讯的双方需要采用约定的协议，序列化和反序列化属于通讯协议的一部分。通讯协议往往采用分层模型，不同模型每层的功能定义以及颗粒度不同，例如：TCP/IP协议是一个四层协议，而OSI模型却是七层协议模型。在OSI七层协议模型中展现层（Presentation Layer）的主要功能是把应用层的对象转换成一段连续的二进制串，或者反过来，把二进制串转换成应用层的对象&ndash;这两个功能就是序列化和反序列化。一般而言，TCP/IP协议的应用层对应与OSI七层协议模型的应用层，展示层和会话层，所以序列化协议属于TCP/IP协议应用层的一部分。本文对序列化协议的讲解主要基于OSI七层协议模型。</p>

<ul>
<li>序列化： 将数据结构或对象转换成二进制串的过程</li>
<li>反序列化：将在序列化过程中所生成的二进制串转换成数据结构或者对象的过程</li>
</ul>


<p>数据结构、对象与二进制串
不同的计算机语言中，数据结构，对象以及二进制串的表示方式并不相同。</p>

<p>数据结构和对象：对于类似Java这种完全面向对象的语言，工程师所操作的一切都是对象（Object），来自于类的实例化。在Java语言中最接近数据结构的概念，就是POJO（Plain Old Java Object）或者Javabean－－那些只有setter/getter方法的类。而在C++这种半面向对象的语言中，数据结构和struct对应，对象和class对应。</p>

<p>二进制串：序列化所生成的二进制串指的是存储在内存中的一块数据。C++语言具有内存操作符，所以二进制串的概念容易理解，例如，C++语言的字符串可以直接被传输层使用，因为其本质上就是以'\0'结尾的存储在内存中的二进制串。在Java语言里面，二进制串的概念容易和String混淆。实际上String 是Java的一等公民，是一种特殊对象（Object）。对于跨语言间的通讯，序列化后的数据当然不能是某种语言的特殊数据类型。二进制串在Java里面所指的是byte[]，byte是Java的8中原生数据类型之一（Primitive data types）。</p>

<h4>二、序列化协议特性</h4>

<p>每种序列化协议都有优点和缺点，它们在设计之初有自己独特的应用场景。在系统设计的过程中，需要考虑序列化需求的方方面面，综合对比各种序列化协议的特性，最终给出一个折衷的方案。</p>

<h6>通用性有两个层面的意义：</h6>

<ul>
<li>第一、技术层面，序列化协议是否支持跨平台、跨语言。如果不支持，在技术层面上的通用性就大大降低了。</li>
<li>第二、流行程度，序列化和反序列化需要多方参与，很少人使用的协议往往意味着昂贵的学习成本；另一方面，流行度低的协议，往往缺乏稳定而成熟的跨语言、跨平台的公共包。</li>
</ul>


<p>强健性/鲁棒性
以下两个方面的原因会导致协议不够强健：</p>

<ul>
<li>第一、成熟度不够，一个协议从制定到实施，到最后成熟往往是一个漫长的阶段。协议的强健性依赖于大量而全面的测试，对于致力于提供高质量服务的系统，采用处于测试阶段的序列化协议会带来很高的风险。</li>
<li>第二、语言/平台的不公平性。为了支持跨语言、跨平台的功能，序列化协议的制定者需要做大量的工作；但是，当所支持的语言或者平台之间存在难以调和的特性的时候，协议制定者需要做一个艰难的决定&ndash;支持更多人使用的语言/平台，亦或支持更多的语言/平台而放弃某个特性。当协议的制定者决定为某种语言或平台提供更多支持的时候，对于使用者而言，协议的强健性就被牺牲了。</li>
</ul>


<p>可调试性/可读性
序列化和反序列化的数据正确性和业务正确性的调试往往需要很长的时间，良好的调试机制会大大提高开发效率。序列化后的二进制串往往不具备人眼可读性，为了验证序列化结果的正确性，写入方不得同时撰写反序列化程序，或提供一个查询平台&ndash;这比较费时；另一方面，如果读取方未能成功实现反序列化，这将给问题查找带来了很大的挑战&ndash;难以定位是由于自身的反序列化程序的bug所导致还是由于写入方序列化后的错误数据所导致。对于跨公司间的调试，由于以下原因，问题会显得更严重：</p>

<ul>
<li>第一、支持不到位，跨公司调试在问题出现后可能得不到及时的支持，这大大延长了调试周期。</li>
<li>第二、访问限制，调试阶段的查询平台未必对外公开，这增加了读取方的验证难度。</li>
</ul>


<p>如果序列化后的数据人眼可读，这将大大提高调试效率， XML和JSON就具有人眼可读的优点。</p>

<h6>性能包括两个方面，时间复杂度和空间复杂度：</h6>

<ul>
<li>第一、空间开销（Verbosity）， 序列化需要在原有的数据上加上描述字段，以为反序列化解析之用。如果序列化过程引入的额外开销过高，可能会导致过大的网络，磁盘等各方面的压力。对于海量分布式存储系统，数据量往往以TB为单位，巨大的的额外空间开销意味着高昂的成本。</li>
<li>第二、时间开销（Complexity），复杂的序列化协议会导致较长的解析时间，这可能会使得序列化和反序列化阶段成为整个系统的瓶颈。</li>
</ul>


<p>可扩展性/兼容性
移动互联时代，业务系统需求的更新周期变得更快，新的需求不断涌现，而老的系统还是需要继续维护。如果序列化协议具有良好的可扩展性，支持自动增加新的业务字段，而不影响老的服务，这将大大提供系统的灵活度。</p>

<p>安全性/访问限制
在序列化选型的过程中，安全性的考虑往往发生在跨局域网访问的场景。当通讯发生在公司之间或者跨机房的时候，出于安全的考虑，对于跨局域网的访问往往被限制为基于HTTP/HTTPS的80和443端口。如果使用的序列化协议没有兼容而成熟的HTTP传输层框架支持，可能会导致以下三种结果之一：</p>

<ul>
<li>第一、因为访问限制而降低服务可用性。</li>
<li>第二、被迫重新实现安全协议而导致实施成本大大提高。</li>
<li>第三、开放更多的防火墙端口和协议访问，而牺牲安全性。</li>
</ul>


<h4>三、序列化和反序列化的组件</h4>

<p>典型的序列化和反序列化过程往往需要如下组件：</p>

<ul>
<li>IDL（Interface description language）文件：参与通讯的各方需要对通讯的内容需要做相关的约定（Specifications）。为了建立一个与语言和平台无关的约定，这个约定需要采用与具体开发语言、平台无关的语言来进行描述。这种语言被称为接口描述语言（IDL），采用IDL撰写的协议约定称之为IDL文件。</li>
<li>IDL Compiler：IDL文件中约定的内容为了在各语言和平台可见，需要有一个编译器，将IDL文件转换成各语言对应的动态库。</li>
<li>Stub/Skeleton Lib：负责序列化和反序列化的工作代码。Stub是一段部署在分布式系统客户端的代码，一方面接收应用层的参数，并对其序列化后通过底层协议栈发送到服务端，另一方面接收服务端序列化后的结果数据，反序列化后交给客户端应用层；Skeleton部署在服务端，其功能与Stub相反，从传输层接收序列化参数，反序列化后交给服务端应用层，并将应用层的执行结果序列化后最终传送给客户端Stub。</li>
<li>Client/Server：指的是应用层程序代码，他们面对的是IDL所生存的特定语言的class或struct。
底层协议栈和互联网：序列化之后的数据通过底层的传输层、网络层、链路层以及物理层协议转换成数字信号在互联网中传递。
序列化组件</li>
</ul>


<p>序列化组件与数据库访问组件的对比
数据库访问对于很多工程师来说相对熟悉，所用到的组件也相对容易理解。下表类比了序列化过程中用到的部分组件和数据库访问组件的对应关系，以便于大家更好的把握序列化相关组件的概念。</p>

<table>
<thead>
<tr>
<th> 序列化组件         </th>
<th style="text-align:center;"> 数据库组件          </th>
<th style="text-align:right;"> 说明  </th>
</tr>
</thead>
<tbody>
<tr>
<td> IDL           </td>
<td style="text-align:center;">   DDL              </td>
<td style="text-align:right;"> 用于建表或者模型的语言</td>
</tr>
<tr>
<td> DL            </td>
<td style="text-align:center;"> file DB Schema    </td>
<td style="text-align:right;"> 表创建文件或模型文件</td>
</tr>
<tr>
<td> Stub/Skeleton </td>
<td style="text-align:center;">  lib  O/R mapping </td>
<td style="text-align:right;">   将class和Table或者数据模型进行映射</td>
</tr>
</tbody>
</table>


<h4>四、几种常见的序列化和反序列化协议</h4>

<p>互联网早期的序列化协议主要有COM和CORBA。</p>

<p>COM主要用于Windows平台，并没有真正实现跨平台，另外COM的序列化的原理利用了编译器中虚表，使得其学习成本巨大（想一下这个场景， 工程师需要是简单的序列化协议，但却要先掌握语言编译器）。由于序列化的数据与编译器紧耦合，扩展属性非常麻烦。</p>

<p>CORBA是早期比较好的实现了跨平台，跨语言的序列化协议。COBRA的主要问题是参与方过多带来的版本过多，版本之间兼容性较差，以及使用复杂晦涩。这些政治经济，技术实现以及早期设计不成熟的问题，最终导致COBRA的渐渐消亡。J2SE 1.3之后的版本提供了基于CORBA协议的RMI-IIOP技术，这使得Java开发者可以采用纯粹的Java语言进行CORBA的开发。</p>

<p>这里主要介绍和对比几种当下比较流行的序列化协议，包括XML、JSON、Protobuf、Thrift和Avro。</p>

<p>一个例子
如前所述，序列化和反序列化的出现往往晦涩而隐蔽，与其他概念之间往往相互包容。为了更好了让大家理解序列化和反序列化的相关概念在每种协议里面的具体实现，我们将一个例子穿插在各种序列化协议讲解中。在该例子中，我们希望将一个用户信息在多个系统里面进行传递；在应用层，如果采用Java语言，所面对的类对象如下所示：</p>

<pre><code>class Address
{
    private String city;
    private String postcode;
    private String street;
}
public class UserInfo
{
    private Integer userid;
    private String name;
    private List&lt;Address&gt; address;
}
</code></pre>

<h6>XML&amp;SOAP</h6>

<ul>
<li><p>XML是一种常用的序列化和反序列化协议，具有跨机器，跨语言等优点。 XML历史悠久，其1.0版本早在1998年就形成标准，并被广泛使用至今。XML的最初产生目标是对互联网文档（Document）进行标记，所以它的设计理念中就包含了对于人和机器都具备可读性。 但是，当这种标记文档的设计被用来序列化对象的时候，就显得冗长而复杂（Verbose and Complex）。 XML本质上是一种描述语言，并且具有自我描述（Self-describing）的属性，所以XML自身就被用于XML序列化的IDL。 标准的XML描述格式有两种：DTD（Document Type Definition）和XSD（XML Schema Definition）。作为一种人眼可读（Human-readable）的描述语言，XML被广泛使用在配置文件中，例如O/R mapping、 Spring Bean Configuration File 等。</p></li>
<li><p>SOAP（Simple Object Access protocol） 是一种被广泛应用的，基于XML为序列化和反序列化协议的结构化消息传递协议。SOAP在互联网影响如此大，以至于我们给基于SOAP的解决方案一个特定的名称&ndash;Web service。SOAP虽然可以支持多种传输层协议，不过SOAP最常见的使用方式还是XML+HTTP。SOAP协议的主要接口描述语言（IDL）是WSDL（Web Service Description Language）。SOAP具有安全、可扩展、跨语言、跨平台并支持多种传输层协议。如果不考虑跨平台和跨语言的需求，XML的在某些语言里面具有非常简单易用的序列化使用方法，无需IDL文件和第三方编译器， 例如Java＋XStream。</p></li>
</ul>


<p>自我描述与递归
SOAP是一种采用XML进行序列化和反序列化的协议，它的IDL是WSDL. 而WSDL的描述文件是XSD，而XSD自身是一种XML文件。 这里产生了一种有趣的在数学上称之为“递归”的问题，这种现象往往发生在一些具有自我属性（Self-description）的事物上。</p>

<p>IDL文件举例
采用WSDL描述上述用户基本信息的例子如下：</p>

<pre><code>&lt;xsd:complexType name='Address'&gt;
     &lt;xsd:attribute name='city' type='xsd:string' /&gt;
     &lt;xsd:attribute name='postcode' type='xsd:string' /&gt;
     &lt;xsd:attribute name='street' type='xsd:string' /&gt;
&lt;/xsd:complexType&gt;
&lt;xsd:complexType name='UserInfo'&gt;
     &lt;xsd:sequence&gt;
     &lt;xsd:element name='address' type='tns:Address'/&gt;
     &lt;xsd:element name='address1' type='tns:Address'/&gt; 
     &lt;/xsd:sequence&gt;
     &lt;xsd:attribute name='userid' type='xsd:int' /&gt;
     &lt;xsd:attribute name='name' type='xsd:string' /&gt; 
&lt;/xsd:complexType&gt;
</code></pre>

<p>典型应用场景和非应用场景
SOAP协议具有广泛的群众基础，基于HTTP的传输协议使得其在穿越防火墙时具有良好安全特性，XML所具有的人眼可读（Human-readable）特性使得其具有出众的可调试性，互联网带宽的日益剧增也大大弥补了其空间开销大（Verbose）的缺点。对于在公司之间传输数据量相对小或者实时性要求相对低（例如秒级别）的服务是一个好的选择。</p>

<p>由于XML的额外空间开销大，序列化之后的数据量剧增，对于数据量巨大序列持久化应用常景，这意味着巨大的内存和磁盘开销，不太适合XML。另外，XML的序列化和反序列化的空间和时间开销都比较大，对于对性能要求在ms级别的服务，不推荐使用。WSDL虽然具备了描述对象的能力，SOAP的S代表的也是simple，但是SOAP的使用绝对不简单。对于习惯于面向对象编程的用户，WSDL文件不直观。</p>

<p>JSON（Javascript Object Notation）
JSON起源于弱类型语言Javascript， 它的产生来自于一种称之为"Associative array"的概念，其本质是就是采用"Attribute－value"的方式来描述对象。实际上在Javascript和PHP等弱类型语言中，类的描述方式就是Associative array。JSON的如下优点，使得它快速成为最广泛使用的序列化协议之一：</p>

<ul>
<li>1、这种Associative array格式非常符合工程师对对象的理解。</li>
<li>2、它保持了XML的人眼可读（Human-readable）的优点。</li>
<li>3、相对于XML而言，序列化后的数据更加简洁。 来自于的以下链接的研究表明：XML所产生序列化之后文件的大小接近JSON的两倍。<a href="http://www.codeproject.com/Articles/604720/JSON-vs-XML-Some-hard-numbers-about-verbosity">http://www.codeproject.com/Articles/604720/JSON-vs-XML-Some-hard-numbers-about-verbosity</a></li>
<li>4、它具备Javascript的先天性支持，所以被广泛应用于Web browser的应用常景中，是Ajax的事实标准协议。</li>
<li>5、与XML相比，其协议比较简单，解析速度比较快。</li>
<li>6、松散的Associative array使得其具有良好的可扩展性和兼容性。</li>
</ul>


<p>IDL悖论
JSON实在是太简单了，或者说太像各种语言里面的类了，所以采用JSON进行序列化不需要IDL。这实在是太神奇了，存在一种天然的序列化协议，自身就实现了跨语言和跨平台。然而事实没有那么神奇，之所以产生这种假象，来自于两个原因：</p>

<h6>第一</h6>

<p>Associative array在弱类型语言里面就是类的概念，在PHP和Javascript里面Associative array就是其class的实际实现方式，所以在这些弱类型语言里面，JSON得到了非常良好的支持。</p>

<h6>第二</h6>

<p>IDL的目的是撰写IDL文件，而IDL文件被IDL Compiler编译后能够产生一些代码（Stub/Skeleton），而这些代码是真正负责相应的序列化和反序列化工作的组件。 但是由于Associative array和一般语言里面的class太像了，他们之间形成了一一对应关系，这就使得我们可以采用一套标准的代码进行相应的转化。对于自身支持Associative array的弱类型语言，语言自身就具备操作JSON序列化后的数据的能力；对于Java这强类型语言，可以采用反射的方式统一解决，例如Google提供的Gson。</p>

<p>典型应用场景和非应用场景
JSON在很多应用场景中可以替代XML，更简洁并且解析速度更快。典型应用场景包括：</p>

<ul>
<li>1、公司之间传输数据量相对小，实时性要求相对低（例如秒级别）的服务。</li>
<li>2、基于Web browser的Ajax请求。</li>
<li>3、由于JSON具有非常强的前后兼容性，对于接口经常发生变化，并对可调式性要求高的场景，例如Mobile app与服务端的通讯。</li>
<li>4、由于JSON的典型应用场景是JSON＋HTTP，适合跨防火墙访问。</li>
</ul>


<p>总的来说，采用JSON进行序列化的额外空间开销比较大，对于大数据量服务或持久化，这意味着巨大的内存和磁盘开销，这种场景不适合。没有统一可用的IDL降低了对参与方的约束，实际操作中往往只能采用文档方式来进行约定，这可能会给调试带来一些不便，延长开发周期。 由于JSON在一些语言中的序列化和反序列化需要采用反射机制，所以在性能要求为ms级别，不建议使用。</p>

<p>IDL文件举例
以下是UserInfo序列化之后的一个例子：</p>

<pre><code>{"userid":1,"name":"messi","address":[{"city":"北京","postcode":"1000000","street":"wangjingdonglu"}]}
</code></pre>

<p>Thrift
Thrift是Facebook开源提供的一个高性能，轻量级RPC服务框架，其产生正是为了满足当前大数据量、分布式、跨语言、跨平台数据通讯的需求。 但是，Thrift并不仅仅是序列化协议，而是一个RPC框架。相对于JSON和XML而言，Thrift在空间开销和解析性能上有了比较大的提升，对于对性能要求比较高的分布式系统，它是一个优秀的RPC解决方案；但是由于Thrift的序列化被嵌入到Thrift框架里面，Thrift框架本身并没有透出序列化和反序列化接口，这导致其很难和其他传输层协议共同使用（例如HTTP）。</p>

<p>典型应用场景和非应用场景
对于需求为高性能，分布式的RPC服务，Thrift是一个优秀的解决方案。它支持众多语言和丰富的数据类型，并对于数据字段的增删具有较强的兼容性。所以非常适用于作为公司内部的面向服务构建（SOA）的标准RPC框架。</p>

<p>不过Thrift的文档相对比较缺乏，目前使用的群众基础相对较少。另外由于其Server是基于自身的Socket服务，所以在跨防火墙访问时，安全是一个顾虑，所以在公司间进行通讯时需要谨慎。 另外Thrift序列化之后的数据是Binary数组，不具有可读性，调试代码时相对困难。最后，由于Thrift的序列化和框架紧耦合，无法支持向持久层直接读写数据，所以不适合做数据持久化序列化协议。</p>

<p>IDL文件举例</p>

<pre><code>struct Address
{ 
    1: required string city;
    2: optional string postcode;
    3: optional string street;
} 
struct UserInfo
{ 
    1: required string userid;
    2: required i32 name;
    3: optional list&lt;Address&gt; address;
}
</code></pre>

<p>Protobuf
Protobuf具备了优秀的序列化协议的所需的众多典型特征：</p>

<ul>
<li>1、标准的IDL和IDL编译器，这使得其对工程师非常友好。</li>
<li>2、序列化数据非常简洁，紧凑，与XML相比，其序列化之后的数据量约为1/3到1/10。</li>
<li>3、解析速度非常快，比对应的XML快约20-100倍。</li>
<li>4、提供了非常友好的动态库，使用非常简介，反序列化只需要一行代码。</li>
</ul>


<p>Protobuf是一个纯粹的展示层协议，可以和各种传输层协议一起使用；Protobuf的文档也非常完善。 但是由于Protobuf产生于Google，所以目前其仅仅支持Java、C++、Python三种语言。另外Protobuf支持的数据类型相对较少，不支持常量类型。由于其设计的理念是纯粹的展现层协议（Presentation Layer），目前并没有一个专门支持Protobuf的RPC框架。</p>

<p>典型应用场景和非应用场景
Protobuf具有广泛的用户基础，空间开销小以及高解析性能是其亮点，非常适合于公司内部的对性能要求高的RPC调用。由于Protobuf提供了标准的IDL以及对应的编译器，其IDL文件是参与各方的非常强的业务约束，另外，Protobuf与传输层无关，采用HTTP具有良好的跨防火墙的访问属性，所以Protobuf也适用于公司间对性能要求比较高的场景。由于其解析性能高，序列化后数据量相对少，非常适合应用层对象的持久化场景。</p>

<p>它的主要问题在于其所支持的语言相对较少，另外由于没有绑定的标准底层传输层协议，在公司间进行传输层协议的调试工作相对麻烦。</p>

<p>IDL文件举例</p>

<pre><code>message Address
{
    required string city=1;
        optional string postcode=2;
        optional string street=3;
}
message UserInfo
{
    required string userid=1;
    required string name=2;
    repeated Address address=3;
}
</code></pre>

<p>Avro</p>

<pre><code>Avro的产生解决了JSON的冗长和没有IDL的问题，Avro属于Apache Hadoop的一个子项目。 Avro提供两种序列化格式：JSON格式或者Binary格式。Binary格式在空间开销和解析性能方面可以和Protobuf媲美，JSON格式方便测试阶段的调试。 Avro支持的数据类型非常丰富，包括C++语言里面的union类型。Avro支持JSON格式的IDL和类似于Thrift和Protobuf的IDL（实验阶段），这两者之间可以互转。Schema可以在传输数据的同时发送，加上JSON的自我描述属性，这使得Avro非常适合动态类型语言。 Avro在做文件持久化的时候，一般会和Schema一起存储，所以Avro序列化文件自身具有自我描述属性，所以非常适合于做Hive、Pig和MapReduce的持久化数据格式。对于不同版本的Schema，在进行RPC调用的时候，服务端和客户端可以在握手阶段对Schema进行互相确认，大大提高了最终的数据解析速度。
</code></pre>

<p>典型应用场景和非应用场景
Avro解析性能高并且序列化之后的数据非常简洁，比较适合于高性能的序列化服务。</p>

<p>由于Avro目前非JSON格式的IDL处于实验阶段，而JSON格式的IDL对于习惯于静态类型语言的工程师来说不直观。</p>

<p>IDL文件举例</p>

<pre><code>protocol Userservice {
  record Address {
   string city;
   string postcode;
   string street;
  }  
  record UserInfo {
   string name;
   int userid;
   array&lt;Address&gt; address = [];
  }
}
</code></pre>

<p>所对应的JSON Schema格式如下：</p>

<pre><code>{
  "protocol" : "Userservice",
  "namespace" : "org.apache.avro.ipc.specific",
  "version" : "1.0.5",
  "types" : [ {
    "type" : "record",
    "name" : "Address",
    "fields" : [ {
      "name" : "city",
      "type" : "string"
    }, {
      "name" : "postcode",
      "type" : "string"
    }, {
      "name" : "street",
      "type" : "string"
    } ]
  }, {
    "type" : "record",
    "name" : "UserInfo",
    "fields" : [ {
      "name" : "name",
      "type" : "string"
    }, {
      "name" : "userid",
      "type" : "int"
    }, {
      "name" : "address",
      "type" : {
        "type" : "array",
        "items" : "Address"
      },
      "default" : [ ]
    } ]
  } ],
  "messages" : { }
}
</code></pre>

<h4>五、Benchmark以及选型建议</h4>

<p>Benchmark
以下数据来自<a href="https://code.google.com/p/thrift-protobuf-compare/wiki/Benchmarking">https://code.google.com/p/thrift-protobuf-compare/wiki/Benchmarking</a></p>

<ul>
<li>解析性能</li>
<li>序列化之空间开销</li>
<li>序列化大小</li>
</ul>


<p>从上图可得出如下结论：</p>

<ul>
<li>1、XML序列化（Xstream）无论在性能和简洁性上比较差。</li>
<li>2、Thrift与Protobuf相比在时空开销方面都有一定的劣势。</li>
<li>3、Protobuf和Avro在两方面表现都非常优越。</li>
</ul>


<p>选型建议</p>

<pre><code>以上描述的五种序列化和反序列化协议都各自具有相应的特点，适用于不同的场景：
1、对于公司间的系统调用，如果性能要求在100ms以上的服务，基于XML的SOAP协议是一个值得考虑的方案。
2、基于Web browser的Ajax，以及Mobile app与服务端之间的通讯，JSON协议是首选。对于性能要求不太高，或者以动态类型语言为主，或者传输数据载荷很小的的运用场景，JSON也是非常不错的选择。
3、对于调试环境比较恶劣的场景，采用JSON或XML能够极大的提高调试效率，降低系统开发成本。
4、当对性能和简洁性有极高要求的场景，Protobuf，Thrift，Avro之间具有一定的竞争关系。
5、对于T级别的数据的持久化应用场景，Protobuf和Avro是首要选择。如果持久化后的数据存储在Hadoop子项目里，Avro会是更好的选择。
6、由于Avro的设计理念偏向于动态类型语言，对于动态语言为主的应用场景，Avro是更好的选择。
7、对于持久层非Hadoop项目，以静态类型语言为主的应用场景，Protobuf会更符合静态类型语言工程师的开发习惯。
8、如果需要提供一个完整的RPC解决方案，Thrift是一个好的选择。
9、如果序列化之后需要支持不同的传输层协议，或者需要跨防火墙访问的高性能场景，Protobuf可以优先考虑。
</code></pre>
</div>
  
  




| <a href="/blog/2015/12/04/xu-lie-hua-and-fan-xu-lie-hua-shen-jiu/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/12/03/huan-cun-ji-zhi-shen-jiu/">自己写套缓存机制</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><ul>
<li>前言</li>
</ul>


<p>大家都知道UITableView，最经典在于循环利用，这里我自己模仿UITableView循环利用,写了一套自己的TableView实现方案，希望大家看了我的文章，循环利用思想有显著提升。</p>

<h2>一： 研究UITableView底层实现</h2>

<h5>1.系统UITabelView的简单使用，这里就不考虑分组了，默认为1组。</h5>

<pre><code> 1 // 返回第section组有多少行
 2 - (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section
 3 {
 4     NSLog(@"%s",__func__);
 5     return 10;
 6 }
 7  
 8 // 返回每一行cell的样子
 9 - (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath
10 {
11     NSLog(@"%s",__func__);
12     static NSString *ID = @"cell";
13     UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:ID];
14      
15     if (cell == nil) {
16          
17         cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:ID];
18     }
19      
20     cell.textLabel.text = [NSString stringWithFormat:@"%ld",indexPath.row];
21      
22     return cell;
23 }
24 // 返回每行cell的高度
25 - (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath
26 {
27     NSLog(@"%s--%@",__func__,indexPath);
28     return 100;
29 } 
</code></pre>

<h5>2.验证UITabelView的实现机制。</h5>

<p>如图打印结果:</p>

<p><img src="/images/huancun001.png" title="Caption" ></p>

<ul>
<li><p>分析：底层先获取有多少cell（10个），在获取每个cell的高度，返回高度的方法一开始调用10次。</p>

<ul>
<li>目的：确定tableView的滚动范围，一开始计算所有cell的frame,就能计算下tableView的滚动范围。</li>
</ul>
</li>
<li><p>分析：tableView:cellForRowAtIndexPath:方法什么时候调用。</p></li>
</ul>


<p>打印验证，如图：</p>

<p><img src="/images/huancun002.png" title="Caption" ></p>

<p>一开始调用了7次，因为一开始屏幕最多显示7个cell</p>

<pre><code>- 目的：一开始只加载显示出来的cell，等有新的cell出现的时候会继续调用这个方法加载cell。
</code></pre>

<h5>3.UITableView循环利用思想</h5>

<p>当新的cell出现的时候，首先从缓存池中获取，如果没有获取到，就自己创建cell。</p>

<p>当有cell移除屏幕的时候，把cell放到缓存池中去。</p>

<h2>二、自定义UIScroolView，模仿UITableView循环利用</h2>

<h5>1.提供数据源和代理方法，命名和UITableView一致。</h5>

<pre><code> 1 @class YZTableView;
 2 @protocol YZTableViewDataSource
 3  
 4 @required
 5  
 6 // 返回有多少行cell
 7 - (NSInteger)tableView:(YZTableView *)tableView numberOfRowsInSection:(NSInteger)section;
 8  
 9  
10 // 返回每行cell长什么样子
11 - (UITableViewCell *)tableView:(YZTableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath;
12  
13 @end
14  
15 @protocol YZTableViewDelegate
16  
17 // 返回每行cell有多高
18 - (CGFloat)tableView:(YZTableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath;
19  
20 @end 
</code></pre>

<h5>2.提供代理和数据源属性</h5>

<pre><code>1 @interface YZTableView : UIScrollView
2  
3 @property (nonatomic, weak) id dataSource;
4  
5 @property (nonatomic, weak) id delegate;
6  
7 @end 
</code></pre>

<p>警告:</p>

<p><img src="/images/huancun003.png" title="Caption" ></p>

<p>解决，在YZTableView.m的实现中声明。</p>

<p><img src="/images/huancun004.png" title="Caption" ></p>

<ul>
<li><p>原因：有人会问为什么我要定义同名的delegate属性，我主要想模仿系统的tableView，系统tableView也有同名的属性。</p>

<ul>
<li>思路：这样做，外界在使用设置我的tableView的delegate，就必须遵守的我的代理协议，而不是UIScrollView的代理协议。</li>
</ul>
</li>
</ul>


<h5>3.提供刷新方法reloadData，因为tableView通过这个刷新tableView。</h5>

<pre><code> 1 @interface YZTableView : UIScrollView
 2  
 3 @property (nonatomic, weak) id dataSource;
 4  
 5 @property (nonatomic, weak) id delegate;
 6  
 7 // 刷新tableView
 8 - (void)reloadData;
 9  
10 @end 
</code></pre>

<h5>4.实现reloadData方法，刷新表格</h5>

<p>回顾系统如何刷新tableView</p>

<ul>
<li><p>1).先获取有多少cell,在获取每个cell的高度。因此应该是先计算出每个cell的frame.</p></li>
<li><p>2).然后再判断当前有多少cell显示在屏幕上，就加载多少</p></li>
</ul>


<hr />

<pre><code> 1 // 刷新tableView
 2 - (void)reloadData
 3 {
 4     // 这里不考虑多组，假设tableView默认只有一组。
 5      
 6     // 先获取总共有多少cell
 7     NSInteger rows = [self.dataSource tableView:self numberOfRowsInSection:0];
 8      
 9     // 遍历所有cell的高度，计算每行cell的frame
10     CGRect cellF;
11     CGFloat cellX = 0;
12     CGFloat cellY = 0;
13     CGFloat cellW = self.bounds.size.width;
14     CGFloat cellH = 0;
15     CGFloat totalH = 0;
16      
17     for (int i = 0; i &lt; rows; i++) {
18         
19         NSIndexPath *indexPath = [NSIndexPath indexPathForRow:i inSection:0];
20         // 注意：这里获取的delegate，是UIScrollView中声明的属性
21         if ([self.delegate respondsToSelector:@selector(tableView:heightForRowAtIndexPath:)]) {
22             cellH = [self.delegate tableView:self heightForRowAtIndexPath:indexPath];
23         }else{
24             cellH = 44;
25         }
26         cellY = i * cellH;
27          
28         cellF = CGRectMake(cellX, cellY, cellW, cellH);
29          
30         // 记录每个cell的y值对应的indexPath
31         self.indexPathDict[@(cellY)] = indexPath;
32          
33         // 判断有多少cell显示在屏幕上,只加载显示在屏幕上的cell
34         if ([self isInScreen:cellF]) { // 当前cell的frame在屏幕上
35             // 通过数据源获取cell
36             UITableViewCell *cell = [self.dataSource tableView:self cellForRowAtIndexPath:indexPath];
37              
38             cell.frame = cellF;
39              
40             [self addSubview:cell];
41              
42         }
43          
44         // 添加分割线
45         UIView *divideV = [[UIView alloc] initWithFrame:CGRectMake(0, cellY + cellH - 1, cellW, 1)];
46         divideV.backgroundColor = [UIColor lightGrayColor];
47         divideV.alpha = 0.3;
48         [self addSubview:divideV];
49          
50         // 添加到cell可见数组中
51             [self.visibleCells addObject:cell];
52          
53         // 计算tableView内容总高度
54         totalH += cellY + cellH;
55      
56     }
57      
58     // 设置tableView的滚动范围
59     self.contentSize = CGSizeMake(self.bounds.size.width, totalH);
60      
61 } 
</code></pre>

<h5>5.如何判断cell显示在屏幕上</h5>

<p>当tableView内容往下走</p>

<p><img src="/images/huancun005.gif" title="Caption" ></p>

<p>当tableView内容往上走</p>

<p><img src="/images/huancun006.gif" title="Caption" ></p>

<pre><code> 1 // 根据cell尺寸判断cell在不在屏幕上
 2 - (BOOL)isInScreen:(CGRect)cellF
 3 {
 4     // tableView能滚动，因此需要加上偏移量判断
 5      
 6     // 当tableView内容往下走，offsetY会一直增加 ,cell的最大y值 &lt; offsetY偏移量   ,cell移除屏幕
 7     // tableView内容往上走 , offsetY会一直减少，屏幕的最大Y值 &lt;  cell的y值 ，Cell移除屏幕
 8     // 屏幕最大y值 = 屏幕的高度 + offsetY
 9      
10     // 这里拿屏幕来比较，其实是因为tableView的尺寸我默认等于屏幕的高度，正常应该是tableView的高度。
11     // cell在屏幕上， cell的最大y值 &gt; offsetY &amp;&amp; cell的y值 &lt; 屏幕的最大Y值(屏幕的高度 + offsetY)
12      
13     CGFloat offsetY = self.contentOffset.y;
14      
15     return CGRectGetMaxY(cellF) &gt; offsetY &amp;&amp; cellF.origin.y &lt; self.bounds.size.height + offsetY;
16  
17     } 
</code></pre>

<h5>6.在滚动的时候，如果有新的cell出现在屏幕上，先从缓存池中取，没有取到，在创建新的cell.</h5>

<ul>
<li>分析：</li>
</ul>


<p>需要及时监听tableView的滚动，判断下有没有新的cell出现。</p>

<p>大家都会想到scrollViewDidScroll方法，这个方法只要一滚动scrollView就会调用，但是这个方法有个弊端，就是tableView内部需要作为自身的代理，才能监听，这样不好，有时候外界也需要监听滚动，因此自身类最好不要成为自己的代理。（设计思想）</p>

<ul>
<li>解决：</li>
</ul>


<p>重写layoutSubviews，判断当前哪些cell显示在屏幕上。</p>

<p>因为只要一滚动，就会修改contentOffset,就会调用layoutSubviews，其实修改contentOffset，内部其实是修改tableView的bounds,而layoutSubviews刚好是父控件尺寸一改就会调用.具体需要了解scrollView底层实现。</p>

<ul>
<li>思路：</li>
</ul>


<p>判断下，当前tableView内容往上移动，还是往下移动，如何判断，取出显示在屏幕上的第一次cell，当前偏移量 > 第一个cell的y值，往下走。</p>

<p>需要搞个数组记录下，当前有多少cell显示在屏幕上，在一开始的时候记录.</p>

<pre><code> 1 @interface YZTableView ()
 2  
 3 @property (nonatomic, strong) NSMutableArray *visibleCells;
 4  
 5 @end
 6  
 7 @implementation YZTableView
 8  
 9 @dynamic delegate;
10  
11 - (NSMutableArray *)visibleCells
12 {
13  
14     if (_visibleCells == nil) {
15         _visibleCells = [NSMutableArray array];
16     }
17     return _visibleCells;
18      
19 }
20 @end 
</code></pre>

<h3>往下移动</h3>

<ul>
<li><p>1.如果已经滚动到tableView内容最底部，就不需要判断新的cell，直接返回.</p></li>
<li><p>2.需要判断之前显示在屏幕cell有没有移除屏幕</p></li>
<li><p>3.只需要判断下当前可见cell数组中第一个cell有没有离开屏幕</p></li>
<li><p>4.只需要判断下当前可见cell数组中最后一个cell的下一个cell显没显示在屏幕上即可。</p></li>
</ul>


<hr />

<pre><code> 1 // 判断有没有滚动到最底部
 2         if (offsetY + self.bounds.size.height &gt; self.contentSize.height) {
 3             return;
 4         }
 5          
 6         // 判断下当前可见cell数组中第一个cell有没有离开屏幕
 7         if ([self isInScreen:firstCell.frame] == NO) { // 如果不在屏幕
 8             // 从可见cell数组移除
 9             [self.visibleCells removeObject:firstCell];
10              
11             // 删除第0个从可见的indexPath
12             [self.visibleIndexPaths removeObjectAtIndex:0];
13              
14             // 添加到缓存池中
15             [self.reuserCells addObject:firstCell];
16              
17             // 移除父控件
18             [firstCell removeFromSuperview];
19              
20         }
21         // 判断下当前可见cell数组中最后一个cell的下一个cell显没显示在屏幕上
22         // 这里需要计算下一个cell的y值，需要获取对应的cell的高度
23         // 而高度需要根据indexPath，从数据源获取
24         // 可以数组记录每个可见cell的indexPath的顺序,然后获取对应可见的indexPath的角标，就能获取下一个indexPath.
25          
26         // 获取最后一个cell的indexPath
27         NSIndexPath *indexPath = [self.visibleIndexPaths lastObject];
28          
29         // 获取下一个cell的indexPath
30         NSIndexPath *nextIndexPath = [NSIndexPath indexPathForRow:indexPath.row + 1 inSection:0];
31          
32         // 获取cell的高度
33         if ([self.delegate respondsToSelector:@selector(tableView:heightForRowAtIndexPath:)]) {
34             cellH = [self.delegate tableView:self heightForRowAtIndexPath:nextIndexPath];
35         }else{
36             cellH = 44;
37         }
38          
39         // 计算下一个cell的y值
40         cellY = lastCellY + cellH;
41          
42         // 计算下下一个cell的frame
43         CGRect nextCellFrame = CGRectMake(cellX, cellY, cellW, cellH);
44          
45         if ([self isInScreen:nextCellFrame]) { // 如果在屏幕上，就加载
46              
47             // 通过数据源获取cell
48             UITableViewCell *cell = [self.dataSource tableView:self cellForRowAtIndexPath:nextIndexPath];
49              
50             cell.frame = nextCellFrame;
51              
52             [self insertSubview:cell atIndex:0];
53              
54             // 添加到cell可见数组中
55             [self.visibleCells addObject:cell];
56              
57             // 添加到可见的indexPaths数组
58             [self.visibleIndexPaths addObject:nextIndexPath];
59              
60              
61         } 
</code></pre>

<h3>往上移动</h3>

<ul>
<li><p>1.如果已经滚动到tableView最顶部，就不需要判断了有没有心的cell，直接返回.</p></li>
<li><p>2.需要判断之前显示在屏幕cell有没有移除屏幕</p></li>
<li><p>3.只需要判断下当前可见cell数组中最后一个cell有没有离开屏幕</p></li>
<li><p>4.只需要判断下可见cell数组中第一个cell的上一个cell显没显示在屏幕上即可</p></li>
</ul>


<p>注意点：如果可见cell数组中第一个cell的上一个cell显示到屏幕上，一定要记得是插入到可见数组第0个的位置。</p>

<pre><code> 1 // 判断有没有滚动到最顶部
 2         if (offsetY &lt; 0) {
 3             return;
 4         }
 5          
 6          
 7          
 8         // 判断下当前可见cell数组中最后一个cell有没有离开屏幕
 9         if ([self isInScreen:lastCell.frame] == NO) { // 如果不在屏幕
10             // 从可见cell数组移除
11             [self.visibleCells removeObject:lastCell];
12              
13             // 删除最后一个可见的indexPath
14             [self.visibleIndexPaths removeLastObject];
15              
16             // 添加到缓存池中
17             [self.reuserCells addObject:lastCell];
18              
19             // 移除父控件
20             [lastCell removeFromSuperview];
21              
22         }
23          
24         // 判断下可见cell数组中第一个cell的上一个cell显没显示在屏幕上
25         // 获取第一个cell的indexPath
26         NSIndexPath *indexPath = self.visibleIndexPaths[0];
27          
28          
29         // 获取下一个cell的indexPath
30         NSIndexPath *preIndexPath = [NSIndexPath indexPathForRow:indexPath.row - 1 inSection:0];
31          
32         // 获取cell的高度
33         if ([self.delegate respondsToSelector:@selector(tableView:heightForRowAtIndexPath:)]) {
34             cellH = [self.delegate tableView:self heightForRowAtIndexPath:preIndexPath];
35         }else{
36             cellH = 44;
37         }
38          
39         // 计算上一个cell的y值
40         cellY = firstCellY - cellH;
41          
42          
43         // 计算上一个cell的frame
44         CGRect preCellFrame = CGRectMake(cellX, cellY, cellW, cellH);
45          
46         if ([self isInScreen:preCellFrame]) { // 如果在屏幕上，就加载
47              
48             // 通过数据源获取cell
49             UITableViewCell *cell = [self.dataSource tableView:self cellForRowAtIndexPath:preIndexPath];
50              
51             cell.frame = preCellFrame;
52              
53             [self insertSubview:cell atIndex:0];
54              
55             // 添加到cell可见数组中,这里应该用插入，因为这是最上面一个cell,应该插入到数组第0个
56             [self.visibleCells insertObject:cell atIndex:0];
57              
58             // 添加到可见的indexPaths数组,这里应该用插入，因为这是最上面一个cell,应该插入到数组第0个
59             [self.visibleIndexPaths insertObject:preIndexPath atIndex:0];
60              
61         }
62          
63     } 
</code></pre>

<ul>
<li>问题1：</li>
</ul>


<p>判断下当前可见cell数组中最后一个cell的下一个cell显没显示在屏幕上</p>

<p>这里需要计算下一个cell的frame,frame就需要计算下一个cell的y值，需要获取对应的cell的高度 cellY = lastCellY + cellH</p>

<p>而高度需要根据indexPath，从数据源获取</p>

<ul>
<li>解决：</li>
</ul>


<p>可以搞个字典记录每个可见cell的indexPath,然后获取对应可见的indexPath，就能获取下一个indexPath.</p>

<pre><code> 1 @interface YZTableView ()
 2  
 3 // 屏幕可见数组
 4 @property (nonatomic, strong) NSMutableArray *visibleCells;
 5  
 6 // 缓存池
 7 @property (nonatomic, strong) NSMutableSet *reuserCells;
 8  
 9  
10 // 记录每个可见cell的indexPaths的顺序
11 @property (nonatomic, strong) NSMutableDictionary *visibleIndexPaths;
12  
13 @end
14  
15 - (NSMutableDictionary *)visibleIndexPaths
16 {
17     if (_visibleIndexPaths == nil) {
18         _visibleIndexPaths = [NSMutableDictionary dictionary];
19     }
20      
21     return _visibleIndexPaths;
22 } 
</code></pre>

<h5>注意：</h5>

<p>当cell从缓存池中移除，一定要记得从可见数组cell中移除，还有可见cell的indexPath也要移除.</p>

<pre><code> 1 // 判断下当前可见cell数组中第一个cell有没有离开屏幕
 2         if ([self isInScreen:firstCell.frame] == NO) { // 如果不在屏幕
 3             // 从可见cell数组移除
 4             [self.visibleCells removeObject:firstCell];
 5              
 6             // 删除第0个从可见的indexPath
 7             [self.visibleIndexPaths removeObjectAtIndex:0];
 8              
 9             // 添加到缓存池中
10             [self.reuserCells addObject:firstCell];
11              
12         }
13          
14  // 判断下当前可见cell数组中最后一个cell有没有离开屏幕
15         if ([self isInScreen:lastCell.frame] == NO) { // 如果不在屏幕
16             // 从可见cell数组移除
17             [self.visibleCells removeObject:lastCell];
18              
19             // 删除最后一个可见的indexPath
20             [self.visibleIndexPaths removeLastObject];
21              
22             // 添加到缓存池中
23             [self.reuserCells addObject:lastCell];
24              
25         } 
</code></pre>

<h5>7.缓存池搭建，缓存池其实就是一个NSSet集合。</h5>

<p>搞一个NSSet集合充当缓存池.</p>

<p>cell离开屏幕，放进缓存池</p>

<p>提供从缓存池获取方法，从缓存池中获取cell,记住要从NSSet集合移除cell.</p>

<pre><code> 1 @interface YZTableView ()
 2  
 3 // 屏幕可见数组
 4 @property (nonatomic, strong) NSMutableArray *visibleCells;
 5  
 6 // 缓存池
 7 @property (nonatomic, strong) NSMutableSet *reuserCells;
 8  
 9 // 记录每个cell的y值都对应一个indexPath
10 @property (nonatomic, strong) NSMutableDictionary *indexPathDict;
11  
12 @end
13 @implementation YZTableView
14 - (NSMutableSet *)reuserCells
15 {
16     if (_reuserCells == nil) {
17         _reuserCells = [NSMutableSet set];
18     }
19     return _reuserCells;
20 }
21  
22 // 从缓存池中获取cell
23 - (id)dequeueReusableCellWithIdentifier:(NSString *)identifier
24 {
25     UITableViewCell *cell = [self.reuserCells anyObject];
26      
27     // 能取出cell,并且cell的标示符正确
28     if (cell &amp;&amp; [cell.reuseIdentifier isEqualToString:identifier]) {     
29         // 从缓存池中获取
30         [self.reuserCells removeObject:cell];
31          
32         return cell;
33     }
34     return nil;
35 }
36  
37 @end 
</code></pre>

<h5>8.tableView细节处理</h5>

<p>原因：刷新方法经常要调用</p>

<p>解决：每次刷新的时候，先把之前记录的全部清空</p>

<pre><code> 1 // 刷新tableView
 2 - (void)reloadData
 3 {
 4      
 5     // 刷新方法经常要调用
 6     // 每次刷新的时候，先把之前记录的全部清空
 7     // 清空indexPath字典
 8     [self.indexPathDict removeAllObjects];
 9     // 清空屏幕可见数组
10     [self.visibleCells removeAllObjects];
11     ...
12 } 
</code></pre>
</div>
  
  




| <a href="/blog/2015/12/03/huan-cun-ji-zhi-shen-jiu/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/12/03/you-xiu-cheng-xu-yuan-shi-zen-yao-xie-zhu-shi-de/">够逼格的注释习惯</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><p>够逼格的注释习惯总结</p>

<p>首先关于注意这里就不说什么VVDocument了，来点新鲜的！</p>

<h6>也许你使用过#warning 警告提示</h6>

<h6>也许你也使用过#pragma marks。</h6>

<p>但是你见过或者使用过下面这个吗？</p>

<pre><code>Comments containing:
MARK:
TODO:
FIXME:
!!!:
???:
</code></pre>

<p>没有，那么你就快速的看看下面的内容，非常好用，也非常简单，不过具体使用看个人</p>

<p> 首先说一下三个最常用的：</p>

<ul>
<li>1、TODO</li>
</ul>


<p> 等待实现的功能</p>

<ul>
<li>2、FIXME</li>
</ul>


<p> 需要修正的功能</p>

<ul>
<li>3、！！！</li>
</ul>


<p> 需要改进的功能</p>

<p>具体使用</p>

<pre><code>// FIXME:sss
/* FIXME: sss */


// MARK:sss
/* MARK:sss */


// !!!:sss
/* !!!: sss */


// ???:sss
/* ???: sss */


// TODO:sss
/* TODO: sss */


// Comments containing: sss
/* Comments containing: sss */
</code></pre>

<p>注意空格.</p>

<p> 最后你会发现下面的效果，虽然和#pragma marks没有什么区别，但是这就是装逼原因</p>

<p>关于最后一个/<em> Comments containing: sss </em>/，笔者还没照发对应的使用方法，如果你知道可以联系我哦！</p>
</div>
  
  




| <a href="/blog/2015/12/03/you-xiu-cheng-xu-yuan-shi-zen-yao-xie-zhu-shi-de/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/12/03/nian-tie-shen-jiu/">粘贴深究</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><p>在iOS中，可以使用剪贴板实现应用程序之中以及应用程序之间实现数据的共享。比如你可以从iPhone QQ复制一个url，然后粘贴到safari浏览器中查看这个链接的内容。</p>

<h3>一、在iOS中下面三个控件，自身就有复制-粘贴的功能：</h3>

<ul>
<li>1、UITextView</li>
<li>2、UITextField</li>
<li>3、UIWebView</li>
</ul>


<h3>二、UIKit framework提供了几个类和协议方便我们在自己的应用程序中实现剪贴板的功能。</h3>

<ul>
<li>1、UIPasteboard：我们可以向其中写入数据，也可以读取数据</li>
<li>2、UIMenuController：显示一个快捷菜单，用来复制、剪贴、粘贴选择的项。</li>
<li>3、UIResponder中的 canPerformAction:withSender:用于控制哪些命令显示在快捷菜单中。</li>
<li>4、当快捷菜单上的命令点击的时候，UIResponderStandardEditActions将会被调用。</li>
</ul>


<h3>三、下面这些项能被放置到剪贴板中</h3>

<ul>
<li>1、UIPasteboardTypeListString —  字符串数组, 包含kUTTypeUTF8PlainText</li>
<li>2、UIPasteboardTypeListURL —   URL数组，包含kUTTypeURL</li>
<li>3、UIPasteboardTypeListImage —   图形数组, 包含kUTTypePNG 和kUTTypeJPEG</li>
<li>4、UIPasteboardTypeListColor —   颜色数组</li>
</ul>


<h3>四、剪贴板的类型分为两种：</h3>

<p>系统级：使用UIPasteboardNameGeneral和UIPasteboardNameFind创建，系统级的剪贴板，当应用程序关闭，或者卸载时，数据都不会丢失。
应用程序级：通过设置，可以让数据在应用程序关闭之后仍然保存在剪贴板中，但是应用程序卸载之后数据就会失去。我们可用通过pasteboardWithName:create：来创建。</p>

<p>了解这些之后，下面通过一系列的例子来说明如何在应用程序中使用剪贴板。</p>

<p>例子：</p>

<h5>1、复制剪贴文本。</h5>

<pre><code>下面通过一个例子，可以在tableview上显示一个快捷菜单，上面只有复制按钮，复制tableview上的数据之后，然后粘贴到title上。
</code></pre>

<p>定义一个单元格类CopyTableViewCell，在这个类的上显示快捷菜单，实现复制功能。</p>

<pre><code>@interface CopyTableViewCell : UITableViewCell {
    id delegate;
}
@property (nonatomic, retain) id delegate;
@end
</code></pre>

<p>实现CopyTableViewCell ：</p>

<pre><code>#import "CopyTableViewCell.h"

@implementation CopyTableViewCell

@synthesize delegate;

- (id)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier {
    if ((self = [super initWithStyle:style reuseIdentifier:reuseIdentifier])) {
    }
    return self;
}
- (void)setSelected:(BOOL)selected animated:(BOOL)animated {
    [super setSelected:selected animated:animated];
}
- (void)setHighlighted:(BOOL)highlighted animated:(BOOL)animated {
    [[self delegate] performSelector:@selector(showMenu:)
                          withObject:self afterDelay:0.9f];

    [super setHighlighted:highlighted animated:animated];

}
- (BOOL)canBecomeFirstResponder
{
    return YES;
}
- (BOOL)canPerformAction:(SEL)action withSender:(id)sender{
    if (action == @selector(cut:)){
        return NO;
    }
    else if(action == @selector(copy:)){
        return YES;
    }
    else if(action == @selector(paste:)){
        return NO;
    }
    else if(action == @selector(select:)){
        return NO;
    }
    else if(action == @selector(selectAll:)){
        return NO;
    }
    else
    {
        return [super canPerformAction:action withSender:sender];
    }
}
- (void)copy:(id)sender {
    UIPasteboard *pasteboard = [UIPasteboard generalPasteboard];
    [pasteboard setString:[[self textLabel]text]];
}
- (void)dealloc {
    [super dealloc];
}
@end
</code></pre>

<p>复制代码
定义CopyPasteTextController，实现粘贴功能。
    @interface CopyPasteTextController : UIViewController<UITableViewDelegate> {
        //用来标识是否显示快捷菜单
        BOOL menuVisible;
        UITableView *tableView;
    }</p>

<pre><code>@property (nonatomic, getter=isMenuVisible) BOOL menuVisible;

@property (nonatomic, retain) IBOutlet UITableView *tableView;
@end
</code></pre>

<p>实现CopyPasteTextController ：</p>

<pre><code>#import "CopyPasteTextController.h"
#import "CopyTableViewCell.h"

@implementation CopyPasteTextController
@synthesize menuVisible,tableView;
- (void)viewDidLoad {
    [super viewDidLoad];
    [self setTitle:@"文字复制粘贴"];
    //点击这个按钮将剪贴板的内容粘贴到title上
    UIBarButtonItem *addButton = [[[UIBarButtonItem alloc]
                                      initWithBarButtonSystemItem:UIBarButtonSystemItemRefresh
                                      target:self
                                      action:@selector(readFromPasteboard:)]
                                     autorelease];
    [[self navigationItem] setRightBarButtonItem:addButton];
}


// Customize the number of sections in the table view.
- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView
{
    return 1;
}

- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section
{
    return 9;
}

// Customize the appearance of table view cells.
- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath
{
    static NSString *CellIdentifier =@"Cell";
    CopyTableViewCell *cell = (CopyTableViewCell *)[tableView
                                                           dequeueReusableCellWithIdentifier:CellIdentifier];
    if (cell == nil)
    {
        cell = [[[CopyTableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:CellIdentifier] autorelease];
        [cell setDelegate:self];
    }

    // Configure the cell.
    NSString *text = [NSString stringWithFormat:@"Row %d", [indexPath row]];
    [[cell textLabel] setText:text];
    return cell;
}

- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath
{
    if([self isMenuVisible])
    {
        return;
    }
    [[[self tableView] cellForRowAtIndexPath:indexPath] setSelected:YES
                                                           animated:YES];
}
//显示菜单
- (void)showMenu:(id)cell {
    if ([cell isHighlighted]) {
        [cell becomeFirstResponder];

        UIMenuController * menu = [UIMenuController sharedMenuController];
        [menu setTargetRect: [cell frame] inView: [self view]];
        [menu setMenuVisible: YES animated: YES];
    }
}
- (void)readFromPasteboard:(id)sender {
    [self setTitle:[NSString stringWithFormat:@"Pasteboard = %@",
                      [[UIPasteboard generalPasteboard] string]]];
}

- (void)didReceiveMemoryWarning
{
    // Releases the view if it doesn't have a superview.
    [super didReceiveMemoryWarning];

    // Relinquish ownership any cached data, images, etc that aren't in use.
}

- (void)viewDidUnload
{
    [super viewDidUnload];
    [self.tableView release];

    // Relinquish ownership of anything that can be recreated in viewDidLoad or on demand.
    // For example: self.myOutlet = nil;
}
</code></pre>

<p>复制一行数据：
点击右上角的按钮粘贴，将数据显示在title上：</p>

<h6>2、图片复制粘贴</h6>

<p>   下面通过一个例子，将图片复制和剪贴到另外一个UIImageView中间。</p>

<ul>
<li>1、在界面上放置两个uiimageview，一个是图片的数据源，一个是将图片粘贴到的地方。CopyPasteImageViewController 代码如下：</li>
</ul>


<p>@interface CopyPasteImageViewController : UIViewController {
    UIImageView <em>imageView;
    UIImageView </em>pasteView;
    UIImageView <em>selectedView;
}
@property (nonatomic, retain) IBOutlet UIImageView </em>imageView;
@property (nonatomic, retain) IBOutlet UIImageView <em>pasteView;
@property (nonatomic, retain) UIImageView </em>selectedView;
- (void)placeImageOnPasteboard:(id)view;
@end
* 2、当触摸图片的时候我们显示快捷菜单：</p>

<hr />

<pre><code>- (void)touchesBegan:(NSSet*)touches withEvent:(UIEvent*)event {
    NSSet *copyTouches = [event touchesForView:imageView];
    NSSet *pasteTouches = [event touchesForView:pasteView];

    [self becomeFirstResponder];
    if ([copyTouches count] &gt; 0) {
        [self performSelector:@selector(showMenu:)
                   withObject:imageView afterDelay:0.9f];
    }
    else  if([pasteTouches count] &gt; 0) {
        [self performSelector:@selector(showMenu:)
                   withObject:pasteView afterDelay:0.9f];
    }
    [super touchesBegan:touches withEvent:event];
}

- (void)showMenu:(id)view {
    [self setSelectedView:view];

    UIMenuController * menu = [UIMenuController sharedMenuController];
    [menu setTargetRect: CGRectMake(5, 10, 1, 1) inView: view];
    [menu setMenuVisible: YES animated: YES];
}
</code></pre>

<p>这里的快捷菜单，显示三个菜单项：剪贴、粘贴、复制：</p>

<hr />

<pre><code>- (BOOL)canPerformAction:(SEL)action withSender:(id)sender{
    if (action == @selector(cut:)) {
        return ([self selectedView] == imageView) ? YES : NO;
    } else if (action == @selector(copy:)) {
        return ([self selectedView] == imageView) ? YES : NO;
    } else if (action == @selector(paste:)) {
        return ([self selectedView] == pasteView) ? YES : NO;
    } else if (action == @selector(select:)) {
        return NO;
    } else if (action == @selector(selectAll:)) {
        return NO;
    } else {
        return [super canPerformAction:action withSender:sender];
    }
}
- (void)cut:(id)sender {
    [self copy:sender];
    [imageView setHidden:YES];
}
- (void)copy:(id)sender {
    [self placeImageOnPasteboard:[self imageView]];
}
- (void)paste:(id)sender {
    UIPasteboard *appPasteBoard =
    [UIPasteboard pasteboardWithName:@"CopyPasteImage" create:YES];
    NSData *data =[appPasteBoard dataForPasteboardType:@"com.marizack.CopyPasteImage.imageView"];
    pasteView.image = [UIImage imageWithData:data];
}
</code></pre>
</div>
  
  




| <a href="/blog/2015/12/03/nian-tie-shen-jiu/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/12/02/xiao-chu-jing-gao/">消除警告</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><h6>前言：</h6>

<p>现在你维护的项目有多少警告？看着几百条警告觉得心里烦么？你真的觉得警告又不是错误可以完全不管么？ 如果你也被这些问题困惑，可以和我一起进行下面的操作。其实大部分的警告都是很好改的，把自己整个项目的警告撸一遍应该也就耗费半小时的时间，一次麻烦带来之后的清净这样不好么？</p>

<p>本文分为三个部分：</p>

<ul>
<li>1.简单粗暴的消除警告。</li>
<li>2.详细科学的消除警告。（包括警告收录）</li>
<li>3.添加警告。</li>
</ul>


<h4>一、简单粗暴的消除警告</h4>

<p>警告如果是自己项目中的还好直接改了，如果是第三方库，你改了之后，pod下作者更新一下又白改了，所以可以用这种简单粗暴的方法：直接让第三方库的警告不显示</p>

<p> 就是在podfile文件里面加上一行指令 。
inhibit_all_warnings!
如果某警告实在无法消除，但是又不想让他显示，可以加入预编译指令</p>

<p>比如我已经知道某行会报上面警告了，我就用这个宏把这几行包住，就不会报引号中-Wunused-variable的警告了</p>

<pre><code>#pragma clang diagnostic push
#pragma clang diagnostic ignored"-Wunused-variable" //这里是会报警告的代码

#pragma clang diagnostic pop
</code></pre>

<p>这个-Wunused-variable代表的意思就是 有的东西 你实例化了但是没有使用（同上面第几条）。 但是如何得到一个警告的标示符？</p>

<ol>
<li><p>如图选择一个警告，点击右键，reveal in log  就能看到右边有个方括号[]里面的东西就是 这个警告对应的标示符</p></li>
<li><p>如果希望整个项目中都忽略 某种很无聊的警告，就在项目中Build Setting里加上这个标示符，可以连着加的。</p></li>
<li><p>如果不想整个项目都忽略，只想个别文件忽略，那就找到个别文件加上此指令，这个操作应该使用率不高（一般都是全项目忽略），就不上图了。去Build Phases 里面的 Compile Sources里面改。</p></li>
</ol>


<h4>二、详细科学的消除警告</h4>

<p>其实笔者本意是想把一些第一眼看不懂比较坑的警告收录进来，但是后来发现那基本没几个需要些写了，所以就采用了全收录的方法，遇到的就记录下以后也会不断更新。 可以直接按command+F 在本页面搜索警告</p>

<pre><code>Unused variable 'replyURL'
</code></pre>

<h6>1.没有使用</h6>

<pre><code>Cannot find protocol definition for 'TencentSessionDelegate'
</code></pre>

<h6>2.这种明明都能运行还说我没有定义的警告，是因为你这个协议虽然定义了，但是你这个协议可能还遵守了XX协议，然后这个XX协议没有定义导致会报这种警告，所以遇到这种警告要往“父协议”找。 举个栗子，上面这行就是腾讯授权的库里面报的警告，</h6>

<pre><code>@protocol TencentSessionDelegate
此协议遵守了TencentApiInterfaceDelegate协议，在TencentOAuth.h类中#import "TencentApiInterface.h" 警告可破


Null passed to a callee that requires a non-null argument
</code></pre>

<h6>3.这个警告比较新，是xcode6.3开始 为了让OC也能有swift的？和！的功能，你在声明一个属性的时候加上 <strong>nullable（？可以为空）与</strong>nonnull（！不能为空） 如果放在@property里面的话不用写下划线</h6>

<pre><code>@property (nonatomic, copy, nonnull) NSString * tickets;
@property (nonatomic, copy) NSString * __nonnull tickets;
</code></pre>

<p>或者用宏NS_ASSUME_NONNULL_BEGIN和NS_ASSUME_NONNULL_END 包住多个属性全部具备nonnull，然后仅对需要nullable的改下就行，有点类似于f-no-objc-arc那种先整体给个路线在单独改个别文件的思想。 此警告就是某属性说好的不能为空，你又在某地方写了XX = nil 所以冲突了。</p>

<pre><code>Auto property synthesis will not synthesize property 'privateCacheDirectory'; it will be implemented by its superclass, use @dynamic to acknowledge intention
</code></pre>

<h6>4.他说你的父类实现了setget方法，但是如果你什么都不写，就会系统自动生成出最一般的setget方法，请用@dynamic 来承认父类实现的这个getset方法。</h6>

<pre><code>Unsupported Configuration: Scene is unreachable due to lack of entry points and does not have an identifier for runtime access via -instantiateViewControllerWithIdentifier:.
</code></pre>

<h6>5.一般是storyboard报的警告，简而言之就是你有的页面没有和箭头所指的控制器连起来，导致最终改页面可能无法显示。</h6>

<pre><code>Deprecated: Push segues are deprecated in iOS 8.0 and later
</code></pre>

<h6>6.iOS8之后呢，不要再用push拖线了，统一用show，他会自己根据你是否有导航栏来判断走push还是走modal</h6>

<pre><code>Unsupported Configuration: Plain Style unsupported in a Navigation Item
</code></pre>

<h6>7.导航栏的item 不支持用plain ，那就用Bordered呗。</h6>

<pre><code>The launch image set "LaunchImage" has 2 unassigned images.
The app icon set "AppIcon" has 2 unassigned images.
</code></pre>

<h6>8.几张图标还是启动图找不到自己的位置，可能是一次导入了全部尺寸图片，但是右边的设置只勾了iOS8的 那iOS7尺寸的图标就会报此警告。删掉，或者对照右边匹配。</h6>

<pre><code>'sizeWithFont:constrainedToSize:lineBreakMode:' is deprecated: first deprecated in iOS 7.0 - Use -boundingRectWithSize:options:attributes:context:
</code></pre>

<h6>9.方法废除，旧的方法sizeWithFontToSize在iOS7后就废除了取而代之是boundingRectWithSize方法</h6>

<pre><code>Undeclared selector 'historyAction'
</code></pre>

<h6>10.使用未声明的方法，一般出现在@selector() 括号里写了个不存在的方法或方法名写错了。</h6>

<pre><code>PerformSelector may cause a leak because its selector is unknown
</code></pre>

<h6>11.这个和上面类似就是直接把上面那个@SEL拿来用会报这个警告</h6>

<pre><code>'strongify' macro redefined
</code></pre>

<h6>12.这个宏声明重复,删一个吧</h6>

<pre><code>'UITextAttributeFont' is deprecated: first deprecated in iOS 7.0 - Use NSFontAttributeName
'UITextAttributeTextColor' is deprecated: first deprecated in iOS 7.0 - Use NSForegroundColorAttributeName
'UITextAttributeTextShadowColor' is deprecated: first deprecated in iOS 7.0 - Use NSShadowAttributeName with an NSShadow instance as the value
</code></pre>

<h6>13.方法废除,一般一起出现</h6>

<pre><code>Code will never be executed
</code></pre>

<h6>14.他说这代码永远也轮不到他执行，估计是有几行代码写在了return之后</h6>

<pre><code>Assigning to 'id' from incompatible type 'SXTabViewController *const __strong'
</code></pre>

<h6>15.一般出现在xxx.delegate = self ，应该在上面遵守协议</h6>

<pre><code>Format specifies type 'unsigned long' but the argument has type 'unsigned int'
</code></pre>

<h6>16.这个警告一般会出现在NSStringWithFormat里面 前面%d %lu 什么的和后面填进去的参数不匹配就报了警告</h6>

<pre><code>Values of type 'NSInteger' should not be used as format arguments; add an explicit cast to 'long' instead
</code></pre>

<h6>17.类似于上面，也是format里面前后写的不匹配</h6>

<pre><code>Method 'dealWithURL:andTitle:andKeyword:' in protocol 'SXPostAdDelegate' not implemented
</code></pre>

<h6>18.经典警告，遵守了协议，但是没有实现协议方法。 也可能你实现了只是又加了个参数或是你写的方法和协议方法名字有点轻微不同</h6>

<pre><code>Using integer absolute value function 'abs' when argument is of floating point type
</code></pre>

<h6>19.这个可以自动修正，就是说abs适用于整数绝对值，要是float取绝对值要用fabsf</h6>

<pre><code>Attribute Unavailable: Automatic Preferred Max Layout Width is not available on iOS versions prior to 8.0
</code></pre>

<h6>20.有的方法你用的太落后了，也有的方法你用的太超前了。 说这个最大宽度在iOS8之前的系统是要坑的</h6>

<pre><code>Too many personality routines for compact unwind to encode
</code></pre>

<h6>21.你可以在otherlink 中加入 -Wl,-no_compact_unwind 去掉该警告，根据苹果的解释，这个是由于某些地方 c/c++/oc/oc++混用会造成编译警告。一般没有什么伤害。</h6>

<pre><code>Property 'ssid' requires method 'ssid' to be defined - use @synthesize, @dynamic or provide a method implementation in this class implementation
</code></pre>

<h6>22.说这个ssid必须要定义个这个属性的getter方法，如果警告是setSsid就是setter方法， 用@synthesize和@dynamic 都行，一个是让编译器生成getter和setter，一个是自己生成，如果你有模型分发或kvc之类的，选@dynamic就行</h6>

<pre><code>Unknown escape sequence '\)'
</code></pre>

<h6>23.未知的转义序列。 一般有个斜杠再加个东西他都会以为是转义字符，一看\）不认识就报警告了，一般正则表达式容易报这种警告</h6>

<pre><code>Property 'LoginPort' not found on object of type 'LoginLvsTestTask *'; did you mean to access property loginPort?
</code></pre>

<h6>24.这种可以点击自动修复，是典型的大小写写错了，他提醒了一下。</h6>

<pre><code>Variable 'type' is used uninitialized whenever switch default is taken
</code></pre>

<h6>25.这是出现在switch语句中的警告， 一般可能是switch外面定义了个type但是并没有初始化（初始化操作都写在switch的各个分支里），然后在最后return type。 但是switch的有个分支没有对type初始化，他说如果你来到这个分支的话，那还没初始化就要被return。</h6>

<h5>三、添加警告</h5>

<h6>1.首先最常用的就是 普通警告，这也没什么好说的了</h6>

<pre><code>#warning TODO
</code></pre>

<h6>2.如果是自己写的文件或第三方库，有了新的接口，然后提示旧的接口废除的话需要在方法后加上宏NS_DEPRECATED_IOS和范围</h6>

<pre><code>- (void)addTapAction:(SEL)tapAction target:(id)target NS_DEPRECATED_IOS(2_0, 4_0);
</code></pre>

<h6>3.如果需要在此方法后加上带信息的警告则需要这么写</h6>

<pre><code>- (void)addTapAction:(SEL)tapAction target:(id)target __attribute((deprecated("这个接口会爆内存 不建议使用")));
</code></pre>

<p>显示的效果像这样：</p>
</div>
  
  




| <a href="/blog/2015/12/02/xiao-chu-jing-gao/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/12/02/quan-ping-fan-hui-(runtime)/">全屏返回（Runtime）</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><blockquote><p>前言</p>

<p>此次文章，讲述的是导航控制器全屏滑动返回效果，而且代码量非常少，10行内搞定。</p></blockquote>

<p>如果喜欢我的文章，可以关注我，也可以来小码哥，了解下我们的iOS培训课程。陆续还会有更新ing&hellip;.</p>

<h5>一、自定义导航控制器</h5>

<p>目的：以后需要使用全屏滑动返回功能，就使用自己定义的导航控制器。</p>

<h5>二、分析导航控制器侧滑功能</h5>

<p>效果：导航控制器默认自带了侧滑功能，当用户在界面的左边滑动的时候，就会有侧滑功能。</p>

<p>系统自带的侧滑效果：</p>

<p>分析：</p>

<ul>
<li><p>1.导航控制器的view自带了滑动手势，只不过手势的触发范围只能在左边。</p></li>
<li><p>2.当用户在界面左边拖动，就会触发滑动手势方法，并且有滑动返回功能，说明系统手势触发的方法已经实现了滑动返回功能。</p></li>
<li><p>3.为什么说系统手势触发的方法已经实现了滑动返回功能？</p></li>
</ul>


<h3>原因：</h3>

<p>创建滑动手势对象的时候，需要绑定监听者，当触发手势的时候会调用target的action。</p>

<p>UIPanGestureRecognizer *pan = [[UIPanGestureRecognizer alloc] initWithTarget:target action:action];
当用户在界面左边滑动，有滑动返回功能，这是因为触发手势了，调用target的action方法，说明action方法内部实现滑动返回功能，否则就不会有滑动返回效果。</p>

<h5>三、实现全屏滑动功能分析</h5>

<p>打印导航控制器自带的滑动手势，看下它的真实面目。</p>

<p>系统自带的滑动手势interactivePopGestureRecognizer</p>

<pre><code>//  self指向的导航控制器，在导航控制器的viewDidLoad方法打印 
- (void)viewDidLoad { 
    [super viewDidLoad]; 
    NSLog(@"%@",self.interactivePopGestureRecognizer); 
} 
</code></pre>

<p>由图中可知：</p>

<ul>
<li><p>1.系统自带的手势是UIScreenEdgePanGestureRecognizer类型对象,屏幕边缘滑动手势</p></li>
<li><p>2.系统自带手势target是_UINavigationInteractiveTransition类型的对象</p></li>
<li><p>3.target调用的action方法名叫handleNavigationTransition:</p></li>
</ul>


<p>分析：</p>

<p>UIScreenEdgePanGestureRecognizer，看名称就知道，这个手势的范围只能在屏幕的周边，就是因为这个手势，系统自带的滑动效果，只能实现侧边滑动。</p>

<h5>四、如何实现全屏滑动功能</h5>

<p>给自己的导航控制器，添加一个全屏的滑动手势，调用系统自带滑动手势的target的action方法，利用系统实现的滑动返回功能，加上自己全屏滑动手势，就有全屏滑动功能了。</p>

<p>问题：如何拿到系统自带的target对象?，action方法名已经知道，而且系统肯定在target对象实现了，只要拿到target对象，调用这个方法就行。</p>

<p>通过打印系统自带的滑动手势的代理，发现正好是_UINavigationInteractiveTransition对象，因此我猜测这个代理对象就是target对象,只要拿到它，就拿到系统自带滑动手势的target对象。</p>

<pre><code>// 打印系统自带滑动手势的代理对象 
SLog(@"%@",self.interactivePopGestureRecognizer.delegate); 
</code></pre>

<p>导航控制器全屏滑动注意点:</p>

<ul>
<li><p>1.禁止系统自带滑动手势使用。</p></li>
<li><p>2.只有导航控制器的非根控制器才需要触发手势，使用手势代理，控制手势触发。</p></li>
</ul>


<p>全屏滑动代码实现</p>

<pre><code>- (void)viewDidLoad { 
    [super viewDidLoad]; 
    // 获取系统自带滑动手势的target对象 
    id target = self.interactivePopGestureRecognizer.delegate; 
    // 创建全屏滑动手势，调用系统自带滑动手势的target的action方法 
    UIPanGestureRecognizer *pan = [[UIPanGestureRecognizer alloc] initWithTarget:target action:@selector(handleNavigationTransition:)]; 
    // 设置手势代理，拦截手势触发 
    pan.delegate = self; 
    // 给导航控制器的view添加全屏滑动手势 
    [self.view addGestureRecognizer:pan]; 
    // 禁止使用系统自带的滑动手势 
    self.interactivePopGestureRecognizer.enabled = NO; 
} 
// 什么时候调用：每次触发手势之前都会询问下代理，是否触发。 
// 作用：拦截手势触发 
- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer 
{ 
    // 注意：只有非根控制器才有滑动返回功能，根控制器没有。 
    // 判断导航控制器是否只有一个子控制器，如果只有一个子控制器，肯定是根控制器 
    if (self.childViewControllers.count == 1) { 
        // 表示用户在根控制器界面，就不需要触发滑动手势， 
        return NO; 
    } 
    return YES; 
} 
</code></pre>
</div>
  
  




| <a href="/blog/2015/12/02/quan-ping-fan-hui-(runtime)/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/12/02/qie-huan-kong-zhi-qi/">切换控制器</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><p>从一个视图控制器切换到另一个视图控制器的几种方式</p>

<h4>1,模态(modal)画面的显示方法：</h4>

<p>例如iphone通讯录管理程序中，追加新的通讯纪录时，就是使用这种模态画面
例：点击一个按钮，进入另一个界面
    - (IBAction)pressAbout:(id)sender {</p>

<pre><code>iCocosViewController *iCocos=[[[iCocosViewController alloc] initWithNibName:@"iCocosViewController" bundle:nil] autorelease];

[self presentModalViewController:aboutanimated:YES];//显示模态画面

关闭模态画面的方法：

[self dissmissModalViewControllerAnimationed:YES];
</code></pre>

<h4>2,SwitchViewController中有2个控制器的属性：BviewController,CViewController</h4>

<ul>
<li>使用方法：insertSubview: atIndex:
这种画面跳转方法并非最佳的跳转方法：</li>
<li>实际上并非真的实现了两个画面间的跳转，而是同时启动了2个画面，控制其中哪一个画面显示在前台，哪一个画面显示在后台而已。</li>
<li>这种画面跳转方式有一个很大的缺点，即当画面数量增加时，画面跳转的实现代码将月来越复杂，而且各个画面间不可避免的有相互依赖关系。</li>
</ul>


<h4>3,UITabBarController实现并列画面跳转（这里其实就是window的切花）</h4>

<pre><code>//将5个viewController实例放入TabBar的viewcontrollers属性中    

self.tabBarController.viewControllers = @[navFrist, navSecond,navThird,navFourth,navFifth];   

self.window.rootViewController = self.tabBarController;

[self.window addSubview:self.tabBarController.view];//将根控制器的视图加到应用程序主窗口
</code></pre>

<h4>4,UINavigationController实现多层画面跳转，在导航控制器中，载入有层级关系的界面</h4>

<pre><code>- (IBAction)addRightAction:(id)sender
{
    iCocosViewController *iCocos=[[[iCocosViewController alloc]initWithNibName:@"iCocosViewController" bundle:nil] autorelease];

[self.navigationController pushViewController:aiCocos animated:YES];
}
</code></pre>
</div>
  
  




| <a href="/blog/2015/12/02/qie-huan-kong-zhi-qi/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/12/01/appqia-dun-liao-zen-yao-ban-%3F/">App卡顿了怎么办？</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><p><img src="/images/kadun001.jpg" title="Caption" ></p>

<p>在 VSync 信号到来后，系统图形服务会通过 CADisplayLink 等机制通知 App，App 主线程开始在 CPU 中计算显示内容，比如视图的创建、布局计算、图片解码、文本绘制等。</p>

<p>随后 CPU 会将计算好的内容提交到 GPU 去，由 GPU 进行变换、合成、渲染。随后 GPU 会把渲染结果提交到帧缓冲区去，等待下一次 VSync 信号到来时显示到屏幕上。</p>

<p>由于垂直同步的机制，如果在一个 VSync 时间内，CPU 或者 GPU 没有完成内容提交，则那一帧就会被丢弃，等待下一次机会再显示，而这时显示屏会保留之前的内容不变。这就是界面卡顿的原因。</p>

<p>从上面的图中可以看到，CPU 和 GPU 不论哪个阻碍了显示流程，都会造成掉帧现象。所以开发时，也需要分别对 CPU 和 GPU 压力进行评估和优化。</p>

<h2>CPU 资源消耗原因和解决方案</h2>

<h4>对象创建</h4>

<p>对象的创建会分配内存、调整属性、甚至还有读取文件等操作，比较消耗 CPU 资源。</p>

<p>尽量用轻量的对象代替重量的对象，可以对性能有所优化。</p>

<p>比如 CALayer 比 UIView 要轻量许多，那么不需要响应触摸事件的控件，用 CALayer 显示会更加合适。如果对象不涉及 UI 操作，则尽量放到后台线程去创建，但可惜的是包含有 CALayer 的控件，都只能在主线程创建和操作。通过 Storyboard 创建视图对象时，其资源消耗会比直接通过代码创建对象要大非常多，在性能敏感的界面里，Storyboard 并不是一个好的技术选择。</p>

<p>尽量推迟对象创建的时间，并把对象的创建分散到多个任务中去。尽管这实现起来比较麻烦，并且带来的优势并不多，但如果有能力做，还是要尽量尝试一下。如果对象可以复用，并且复用的代价比释放、创建新对象要小，那么这类对象应当尽量放到一个缓存池里复用。</p>

<h4>对象调整</h4>

<p>对象的调整也经常是消耗 CPU 资源的地方。</p>

<p>这里特别说一下 CALayer：</p>

<ul>
<li><p>CALayer 内部并没有属性，当调用属性方法时，它内部是通过运行时 resolveInstanceMethod 为对象临时添加一个方法，并把对应属性值保存到内部的一个 Dictionary 里，同时还会通知 delegate、创建动画等等，非常消耗资源。</p></li>
<li><p>UIView 的关于显示相关的属性（比如 frame/bounds/transform）等实际上都是 CALayer 属性映射来的，所以对 UIView 的这些属性进行调整时，消耗的资源要远大于一般的属性。对此你在应用中，应该尽量减少不必要的属性修改。</p></li>
</ul>


<p>当视图层次调整时，UIView、CALayer 之间会出现很多方法调用与通知，所以在优化性能时，应该尽量避免调整视图层次、添加和移除视图。</p>

<h4>对象销毁</h4>

<p>对象的销毁虽然消耗资源不多，但累积起来也是不容忽视的。通常当容器类持有大量对象时，其销毁时的资源消耗就非常明显。同样的，如果对象可以放到后台线程去释放，那就挪到后台线程去。这里有个小 Tip：把对象捕获到 block 中，然后扔到后台队列去随便发送个消息以避免编译器警告，就可以让对象在后台线程销毁了。</p>

<pre><code>NSArray *tmp = self.array;

self.array = nil;

dispatch_async(queue, ^{

    [tmp class];

});
</code></pre>

<h4>布局计算</h4>

<p>视图布局的计算是 App 中最为常见的消耗 CPU 资源的地方。如果能在后台线程提前计算好视图布局、并且对视图布局进行缓存，那么这个地方基本就不会产生性能问题了。</p>

<p>不论通过何种技术对视图进行布局，其最终都会落到对 UIView.frame/bounds/center 等属性的调整上。上面也说过，对这些属性的调整非常消耗资源，所以尽量提前计算好布局，在需要时一次性调整好对应属性，而不要多次、频繁的计算和调整这些属性。</p>

<h4>Autolayout</h4>

<ul>
<li>Autolayout 是苹果本身提倡的技术，在大部分情况下也能很好的提升开发效率，但是 Autolayout 对于复杂视图来说常常会产生严重的性能问题。随着视图数量的增长，Autolayout 带来的 CPU 消耗会呈指数级上升。具体数据可以看这个文章：<a href="http://pilky.me/36/%E3%80%82">http://pilky.me/36/%E3%80%82</a> 如果你不想手动调整 frame 等属性，你可以用一些工具方法替代（比如常见的 left/right/top/bottom/width/height 快捷属性），或者使用 ComponentKit、AsyncDisplayKit 等框架。</li>
</ul>


<h4>文本计算</h4>

<p>如果一个界面中包含大量文本（比如微博微信朋友圈等），文本的宽高计算会占用很大一部分资源，并且不可避免。如果你对文本显示没有特殊要求，可以参考下 UILabel 内部的实现方式：用 [NSAttributedString boundingRectWithSize:options:context:] 来计算文本宽高，用 -[NSAttributedString drawWithRect:options:context:] 来绘制文本。尽管这两个方法性能不错，但仍旧需要放到后台线程进行以避免阻塞主线程。</p>

<blockquote><p>注意：如果你用 CoreText 绘制文本，那就可以先生成 CoreText 排版对象，然后自己计算了，并且 CoreText 对象还能保留以供稍后绘制使用。</p></blockquote>

<h4>文本渲染</h4>

<p>屏幕上能看到的所有文本内容控件，包括 UIWebView，在底层都是通过 CoreText 排版、绘制为 Bitmap 显示的。常见的文本控件 （UILabel、UITextView 等），其排版和绘制都是在主线程进行的，当显示大量文本时，CPU 的压力会非常大。对此解决方案只有一个，那就是自定义文本控件，用 TextKit 或最底层的 CoreText 对文本异步绘制。尽管这实现起来非常麻烦，但其带来的优势也非常大，CoreText 对象创建好后，能直接获取文本的宽高等信息，避免了多次计算（调整 UILabel 大小时算一遍、UILabel 绘制时内部再算一遍）；CoreText 对象占用内存较少，可以缓存下来以备稍后多次渲染。</p>

<h4>图片的解码</h4>

<p>当你用 UIImage 或 CGImageSource 的那几个方法创建图片时，图片数据并不会立刻解码。图片设置到 UIImageView 或者 CALayer.contents 中去，并且 CALayer 被提交到 GPU 前，CGImage 中的数据才会得到解码。这一步是发生在主线程的，并且不可避免。如果想要绕开这个机制，常见的做法是在后台线程先把图片绘制到 CGBitmapContext 中，然后从 Bitmap 直接创建图片。目前常见的网络图片库都自带这个功能。</p>

<h4>图像的绘制</h4>

<p>图像的绘制通常是指用那些以 CG 开头的方法把图像绘制到画布中，然后从画布创建图片并显示这样一个过程。这个最常见的地方就是 [UIView drawRect:] 里面了。由于 CoreGraphic 方法通常都是线程安全的，所以图像的绘制可以很容易的放到后台线程进行。一个简单异步绘制的过程大致如下（实际情况会比这个复杂得多，但原理基本一致）：</p>

<pre><code>- (void)display {

    dispatch_async(backgroundQueue, ^{

    CGContextRef ctx = CGBitmapContextCreate(...);

    // draw in context...

    CGImageRef img = CGBitmapContextCreateImage(ctx);

    CFRelease(ctx);

    dispatch_async(mainQueue, ^{

        layer.contents = img;

    });

    });
}
</code></pre>

<h2>GPU 资源消耗原因和解决方案</h2>

<p>相对于 CPU 来说，GPU 能干的事情比较单一：接收提交的纹理（Texture）和顶点描述（三角形），应用变换（transform）、混合并渲染，然后输出到屏幕上。通常你所能看到的内容，主要也就是纹理（图片）和形状（三角模拟的矢量图形）两类。</p>

<h4>纹理的渲染</h4>

<p>所有的 Bitmap，包括图片、文本、栅格化的内容，最终都要由内存提交到显存，绑定为 GPU Texture。不论是提交到显存的过程，还是 GPU 调整和渲染 Texture 的过程，都要消耗不少 GPU 资源。当在较短时间显示大量图片时（比如 TableView 存在非常多的图片并且快速滑动时），CPU 占用率很低，GPU 占用非常高，界面仍然会掉帧。避免这种情况的方法只能是尽量减少在短时间内大量图片的显示，尽可能将多张图片合成为一张进行显示。</p>

<blockquote><p>注意：当图片过大，超过 GPU 的最大纹理尺寸时，图片需要先由 CPU 进行预处理，这对 CPU 和 GPU 都会带来额外的资源消耗。目前来说，iPhone 4S 以上机型，纹理尺寸上限都是 4096x4096，更详细的资料可以看这里：iosres.com。所以，尽量不要让图片和视图的大小超过这个值。</p></blockquote>

<h4>视图的混合 (Composing)</h4>

<p>当多个视图（或者说 CALayer）重叠在一起显示时，GPU 会首先把他们混合到一起。如果视图结构过于复杂，混合的过程也会消耗很多 GPU 资源。为了减轻这种情况的 GPU 消耗，应用应当尽量减少视图数量和层次，并在不透明的视图里标明 opaque 属性以避免无用的 Alpha 通道合成。当然，这也可以用上面的方法，把多个视图预先渲染为一张图片来显示。</p>

<h4>图形的生成</h4>

<p>CALayer 的 border、圆角、阴影、遮罩（mask），CASharpLayer 的矢量图形显示，通常会触发离屏渲染（offscreen rendering），而离屏渲染通常发生在 GPU 中。当一个列表视图中出现大量圆角的 CALayer，并且快速滑动时，可以观察到 GPU 资源已经占满，而 CPU 资源消耗很少。这时界面仍然能正常滑动，但平均帧数会降到很低。为了避免这种情况，可以尝试开启 CALayer.shouldRasterize 属性，但这会把原本离屏渲染的操作转嫁到 CPU 上去。对于只需要圆角的某些场合，也可以用一张已经绘制好的圆角图片覆盖到原本视图上面来模拟相同的视觉效果。最彻底的解决办法，就是把需要显示的图形在后台线程绘制为图片，避免使用圆角、阴影、遮罩等属性。</p>
</div>
  
  




| <a href="/blog/2015/12/01/appqia-dun-liao-zen-yao-ban-%3F/#comments">更多评论</a>

    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/12/01/zi-dian-zhuan-mo-xing-shen-jiu/">字典转模型深究</a></h1>
    
    
      <p class="meta">
        








 <time if="if" updated="updated" data-updated="true" endif="endif" itemprop="datePublished dateCreated"> ordinal </time> 
        
      </p>
    
  </header>


  <div class="entry-content"><blockquote><p>引言：
在文字开始之前先介绍两个软件：</p></blockquote>

<h5>JSONExport</h5>

<p><img src="/images/zidianzhuanmoxin005.png" title="Caption" ></p>

<h5>JSON Accelerator</h5>

<p><img src="/images/zidianzhuanmoxin006.png" title="Caption" ></p>

<blockquote><p>关于模型类的两个神器，我也是刚接触不久，但是感觉非常有用，基本上可以节省你在模型类上的99%的时间。</p></blockquote>

<ul>
<li>如果你觉得自己对应本文后面的内容非常了解，那么请直接下载上面的软件试试。</li>
<li>如果你并不是很熟练，那么轻认真看完后面的内容，相信对你有好处，再去下载对应的软件。</li>
</ul>


<p>关于Plist转模型在iOS开发中是非常常见的，每开一一个项目或者实现一个功能都要用到它，所以今天就给大家讲讲Plist怎么转成模型数据，</p>

<blockquote><p>前提：必须有一个Plist文件或者通过一定的方式返回的plist数据</p></blockquote>

<h2>一：直接加载Plist数据</h2>

<p><img src="/images/zidianzhuanmoxin001.png" title="Caption" ></p>

<pre><code>定义一个数组属性 
@property (nonatomic, assign) NSArray *apps; 
</code></pre>

<h6>获取Plist文件</h6>

<pre><code>//懒加载plist文件，返回一个apps数据，后面直接使用旧可以
-(NSArray *)apps
{
    if (_apps == nil) {
        _apps = [NSArray arrayWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@"iCocos.plist" ofType:nil]];
    }
    return _apps;
}
</code></pre>

<h6>加载Plsit中的数据</h6>

<pre><code>    //取出数组中对应的数据放到一个字典里面
    NSDictionary *dic = self.apps[i];


    //创建一个UIImageView
    UIImageView *icon = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, iW, 50)];
    /**
     取出字典中的icon
    */
     icon.image = [UIImage imageNamed:dic[@"icon"]];

    [view addSubview:icon];



    //创建一个Label
    UILabel *l = [[UILabel alloc] initWithFrame:CGRectMake(0, CGRectGetMaxY(icon.frame), iW, 20)];
    /**
     取出字典中的label
     */
    l.text = dic[@"label"];

    [view addSubview:l];



    //创建一个按钮
    UIButton *btn = [[UIButton alloc] initWithFrame:CGRectMake(0, CGRectGetMaxY(l.frame), iW, 20)];
    /**
     取出字典中的btn
     */
    [btn setTitle:dic[@"btn"] forState:UIControlStateNormal];

    [view addSubview:btn];
</code></pre>

<h2>二：使用简单的模型加载Plist数据</h2>

<p><img src="/images/zidianzhuanmoxin002.png" title="Caption" ></p>

<pre><code> 1 //定义一个数组属性

  2 @property (nonatomic, assign) NSArray *apps; 
</code></pre>

<h6>在模型中定义模型对应的属性</h6>

<pre><code>@property (nonatomic, copy) NSString *icon;


@property (nonatomic, copy) NSString *label;


@property (nonatomic, copy) NSString *btn;
</code></pre>

<h6>模型方法</h6>

<pre><code>/**
 模型数据方法
 */
+(instancetype)messageWithDict:(NSDictionary *)dict;


-(instancetype)initWithDict:(NSDictionary *)dict;
</code></pre>

<h6>模型的实现文件</h6>

<pre><code>/**
 模型数据方法的实现
 */

+ (instancetype)messageWithDict:(NSDictionary *)dict
{
    return [[self alloc] initWithDict:dict];
}

- (instancetype)initWithDict:(NSDictionary *)dict
{
    if (self = [super init]) {
        [self setValuesForKeysWithDictionary:dict];
    }
    return self;
}
</code></pre>

<h6>实用模型加载Plist文件</h6>

<pre><code>/**
 模型数据的加载，返回arry以后我们就只要使用array就能使用这个模型类里面的数据也就是使用plist数据
 */
//懒加载plist文件，返回一个apps数据，后面直接使用旧可以
-(NSMutableArray *)apps
{
    if (_apps == nil) {
        NSArray *array = [NSArray arrayWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@"iCocos.plist" ofType:nil]];

        NSMutableArray *arrayApps = [NSMutableArray array];

        for (NSDictionary *dic in array) {
            appsModel *model = [[appsModel alloc] init];
            model.label = dic[@"label"];
            model.btn = dic[@"btn"];
            model.icon = dic[@"icon"];

            [arrayApps addObject:model];
        }
        _apps = arrayApps;
    }
    return _apps;
}
</code></pre>

<h6>加载模型中对应的plist数据</h6>

<pre><code>    //取出数组中对应的数据放到一个字典里面
    appsModel *app = self.apps[i];


    //创建一个UIImageView
    UIImageView *icon = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, iW, 50)];
    /**
     取出字典中的icon
     */
    icon.image = [UIImage imageNamed:app.icon];
    [view addSubview:icon];



    //创建一个Label
    UILabel *l = [[UILabel alloc] initWithFrame:CGRectMake(0, CGRectGetMaxY(icon.frame), iW, 20)];
    /**
     取出字典中的label
     */
    l.text = app.label;
    [view addSubview:l];



    //创建一个按钮
    UIButton *btn = [[UIButton alloc] initWithFrame:CGRectMake(0, CGRectGetMaxY(l.frame), iW, 20)];
    /**
     取出字典中的btn
     */
    [btn setTitle:app.btn forState:UIControlStateNormal];
    [view addSubview:btn];
</code></pre>

<h5>注：上面是plist中的属性和模型中定义的属性一一对应的时候的，如果不是一一对应我们就要将模型一个一个的赋值与实现</h5>

<pre><code>- (instancetype)initWithDict:(NSDictionary *)dict
{
self = [super init];
if (self) {
    self.label = dict[@"label"];
    self.btn = dict[@"btn"];
    self.icon = dict[@"icon"];

//[self setValue:dict[@"label"] forKeyPath:@"label"];

    //封装
    [self setValuesForKeysWithDictionary:dict];
}

return self;
}
</code></pre>

<p>/<em>*
 模型数据的加载，返回arry以后我们就只要使用array就能使用这个模型类里面的数据也就是使用plist数据
 </em>/</p>

<pre><code>//懒加载plist文件，返回一个apps数据，后面直接使用旧可以
-(NSMutableArray *)apps
{
    if (_apps == nil) {
        NSArray *array = [NSArray arrayWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@"iCocos.plist" ofType:nil]];

        NSMutableArray *arrayApps = [NSMutableArray array];

        for (NSDictionary *dic in array) {
//            appsModel *model = [[appsModel alloc] initWithDict:dic];
            appsModel *model = [appsModel appsWithDict:dic];

            [arrayApps addObject:model];
        }
        _apps = arrayApps;
    }
    return _apps;
}
</code></pre>

<h6>我们也可以讲加载模型的代码进行封装，这样更加简单的实现模式数据的的使用</h6>

<p>在模型中定义并且实现一个模型封装的方法</p>

<pre><code>+(NSArray *)appList
{
        NSArray *array = [NSArray arrayWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@"iCocos.plist" ofType:nil]];

        NSMutableArray *arrayApps = [NSMutableArray array];

        for (NSDictionary *dic in array) {
            //            appsModel *model = [[appsModel alloc] initWithDict:dic];
            appsModel *model = [appsModel appsWithDict:dic];

            [arrayApps addObject:model];
    }
    return arrayApps;

}
</code></pre>

<h6>实用的时候只要直接使用封装好的模型方法就可以：</h6>

<pre><code>/**
 模型数据的加载，返回arry以后我们就只要使用array就能使用这个模型类里面的数据也就是使用plist数据
 */
//懒加载plist文件，返回一个apps数据，后面直接使用旧可以
-(NSArray *)apps
{
    if (_apps == nil) {

        _apps = [appsModel appList];
    }
    return _apps;
}
</code></pre>

<h2>三：复杂Plist转模型</h2>

<p>有的时候我们会遇到Plist中还有更小一级的节点和属性这个时候我们就需要更复杂的模型来加载，但是实用起来并不复杂</p>

<p>比如Plist中海油一个friends这歌子模型</p>

<p><img src="/images/zidianzhuanmoxin003.png" title="Caption" ></p>

<h6>那么我转模型的时候就可以根据plist中的数据进行处理，</h6>

<h6>首先我们一一般都是从子模型开始，我们就先定义子模型</h6>

<pre><code>/**
 根据plist里面存在的子列中的数据再创建一个模型数据
 */

/**
 设置子模型数据的属性
 */

@property (nonatomic, assign) NSString *icon;

@property (nonatomic, assign) NSString *intro;

@property (nonatomic, assign) NSString *name;

@property (nonatomic, assign, getter=isVip)BOOL vip;


/**
 子模型数据的方法
 */
+ (instancetype)friendWithDict:(NSDictionary *)dict;

- (instancetype)initWithDict:(NSDictionary *)dict;
</code></pre>

<h6>子模型的实现</h6>

<pre><code>/**
 子模型数据的方法de实现
 */

+ (instancetype)friendWithDict:(NSDictionary *)dict
{
    return [[self alloc] initWithDict:dict];
}

- (instancetype)initWithDict:(NSDictionary *)dict
{
    if (self = [super init]) {
        [self setValuesForKeysWithDictionary:dict];
    }
    return self;
}
</code></pre>

<h6>然后就是根模型</h6>

<pre><code>/**
 根据plist中的数据创建一个模型数据
 */

/**
 设置模型数据的中的属性
 */

@property (nonatomic, assign) NSArray *friends;

@property (nonatomic, copy) NSString *name;

@property (nonatomic, assign) NSNumber *online;

/**
 模型数据的方法
 */

+ (instancetype)groupWithDict:(NSDictionary *)dict;


- (instancetype)initWithDict:(NSDictionary *)dict;
</code></pre>

<h6>根模型的实现，这里只需要在根模型加载需要实现的子模型酒可以</h6>

<pre><code>/**
 模型数据的方法的实现
 */

+ (instancetype)groupWithDict:(NSDictionary *)dict
{
    return [[self alloc] initWithDict:dict];
}

- (instancetype)initWithDict:(NSDictionary *)dict
{
    if (self = [super init]) {
        [self setValuesForKeysWithDictionary:dict];

        NSMutableArray *friendArray = [NSMutableArray array];
        for (NSDictionary *dict in self.friends) {
            FriendsPlistChildren *friend = [FriendsPlistChildren friendWithDict:dict];
            [friendArray addObject:friend];
        }
        self.friends = friendArray;
    }
    return self;
}
</code></pre>

<h6>使用模型数据，方法还是和之前一样的，不需要去处理子模型，因为我们在跟模型里面已经处理好了</h6>

<pre><code>/**
 加载模型数据的方法
 */

- (NSArray *)groups
{
    if (_groups == nil) {
        NSArray *dictArray = [NSArray arrayWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@"friends.plist" ofType:nil]];

        NSMutableArray *groupArray = [NSMutableArray array];
        for (NSDictionary *dict in dictArray) {
            FirendsPlistRoot *group = [FirendsPlistRoot groupWithDict:dict];
            [groupArray addObject:group];
        }

        _groups = groupArray;
    }
    return _groups;
}
</code></pre>

<h2>四：使用第三份库</h2>

<p>在iOS届有一个神人不知道大家知不知道————他叫李明杰，他（MJ）不仅技术牛逼，而且对天朝iOS界的贡献也是无法用语言来形容的，如果你是老一辈的iOS开发者倒是很正常，如果你只是刚开始学习iOS或者学习iOS不久你都不知道或者没有听过这个名字那么就可以说明你真的out了，甚至说你你根本没有用心在学，关于这个神人我就不做多介绍了，如果你想知道更多，请点击www.520it.com</p>

<p>今天我就使用他的一个NB的框架来实现plist转模型数据，这个框架使用起来非常简单，一行代码就可以搞定你想的功能，</p>

<p>首先你需要去github上面下载这个框架：<a href="https://github.com/CoderMJLee/MJExtension">MJExtension</a></p>

<p>下载好了之后直接讲MJExtension拖到你的项目</p>

<p><img src="/images/zidianzhuanmoxin004.png" title="Caption" ></p>

<h6>首先根据plist数据新建对应的模型数据</h6>

<p>这里我一新浪微博中的小部分做测试</p>

<pre><code>#import "User.h"
#import "Status.h"
#import "StatusResult.h"

/**
 *  微博文本内容
 */
@property (copy, nonatomic) NSString *text;

/**
 *  微博作者
 */
@property (strong, nonatomic) User *user;

/**
 *  转发的微博
 */
@property (strong, nonatomic) Status *retweetedStatus;
/**
 *  存放着某一页微博数据（里面都是Status模型）
 */
@property (strong, nonatomic) NSMutableArray *statuses;

/**
 *  总数
 */
@property (assign, nonatomic) NSNumber *totalNumber;

/**
 *  上一页的游标
 */
@property (assign, nonatomic) long long previousCursor;

/**
 *  下一页的游标
 */
@property (assign, nonatomic) long long nextCursor;
/**
 *  名称
 */
@property (copy, nonatomic) NSString *name;

/**
 *  头像
 */
@property (copy, nonatomic) NSString *icon;
</code></pre>

<h6>下面就是证明去使用这个框架实现你想要的功能了，这里介绍了几乎你开发中需要用到的所有方法和例子，</h6>

<pre><code>/**
 MJ友情提醒：
 1.MJExtension是一套“字典和模型之间互相转换”的轻量级框架
 2.MJExtension能完成的功能
 * 字典 --&gt; 模型
 * 模型 --&gt; 字典
 * 字典数组 --&gt; 模型数组
 * 模型数组 --&gt; 字典数组
 3.具体用法主要参考 main.m中各个函数 以及 "NSObject+MJKeyValue.h"
 4.希望各位大神能用得爽
 */

#import &lt;Foundation/Foundation.h&gt;
#import "MJExtension.h"
#import "User.h"
#import "Status.h"
#import "StatusResult.h"

/**
 *  简单的字典 -&gt; 模型
 */
void keyValues2object()
{
    // 1.定义一个字典
    NSDictionary *dict = @{
                           @"name" : @"Jack",
                           @"icon" : @"lufy.png",
                           };

    // 2.将字典转为User模型
    User *user = [User objectWithKeyValues:dict];

    // 3.打印User模型的属性
    NSLog(@"name=%@, icon=%@", user.name, user.icon);
}

/**
 *  复杂的字典 -&gt; 模型 (模型里面包含了模型)
 */
void keyValues2object2()
{
    // 1.定义一个字典
    NSDictionary *dict = @{
                           @"text" : @"是啊，今天天气确实不错！",

                           @"user" : @{
                                   @"name" : @"Jack",
                                   @"icon" : @"lufy.png"
                                   },

                           @"retweetedStatus" : @{
                                   @"text" : @"今天天气真不错！",

                                   @"user" : @{
                                           @"name" : @"Rose",
                                           @"icon" : @"nami.png"
                                           }
                                   }
                           };

    // 2.将字典转为Status模型
    Status *status = [Status objectWithKeyValues:dict];

    // 3.打印status的属性
    NSString *text = status.text;
    NSString *name = status.user.name;
    NSString *icon = status.user.icon;
    NSLog(@"text=%@, name=%@, icon=%@", text, name, icon);

    // 4.打印status.retweetedStatus的属性
    NSString *text2 = status.retweetedStatus.text;
    NSString *name2 = status.retweetedStatus.user.name;
    NSString *icon2 = status.retweetedStatus.user.icon;
    NSLog(@"text2=%@, name2=%@, icon2=%@", text2, name2, icon2);
}

/**
 *  复杂的字典 -&gt; 模型 (模型的数组属性里面又装着模型)
 */
void keyValues2object3()
{
    // 1.定义一个字典
    NSDictionary *dict = @{
                           @"statuses" : @[
                                   @{
                                       @"text" : @"今天天气真不错！",

                                       @"user" : @{
                                               @"name" : @"Rose",
                                               @"icon" : @"nami.png"
                                               }
                                       },

                                   @{
                                       @"text" : @"明天去旅游了",

                                       @"user" : @{
                                               @"name" : @"Jack",
                                               @"icon" : @"lufy.png"
                                               }
                                       },

                                   @{
                                       @"text" : @"嘿嘿，这东西不错哦！",

                                       @"user" : @{
                                               @"name" : @"Jim",
                                               @"icon" : @"zero.png"
                                               }
                                       }

                                   ],

                           @"totalNumber" : @"2014",

                           @"previousCursor" : @"13476589",

                           @"nextCursor" : @"13476599"
                           };

    // 2.将字典转为StatusResult模型
    StatusResult *result = [StatusResult objectWithKeyValues:dict];

    // 3.打印StatusResult模型的简单属性
    NSLog(@"totalNumber=%d, previousCursor=%lld, nextCursor=%lld", result.totalNumber, result.previousCursor, result.nextCursor);

    // 4.打印statuses数组中的模型属性
    for (Status *status in result.statuses) {
        NSString *text = status.text;
        NSString *name = status.user.name;
        NSString *icon = status.user.icon;
        NSLog(@"text=%@, name=%@, icon=%@", text, name, icon);
    }
}

/**
 *  字典数组 -&gt; 模型数组
 */
void keyValuesArray2objectArray()
{
    // 1.定义一个字典数组
    NSArray *dictArray = @[
                           @{
                               @"name" : @"Jack",
                               @"icon" : @"lufy.png",
                               },

                           @{
                               @"name" : @"Rose",
                               @"icon" : @"nami.png",
                               },

                           @{
                               @"name" : @"Jim",
                               @"icon" : @"zero.png",
                               }
                           ];

    // 2.将字典数组转为User模型数组
    NSArray *userArray = [User objectArrayWithKeyValuesArray:dictArray];

    // 3.打印userArray数组中的User模型属性
    for (User *user in userArray) {
        NSLog(@"name=%@, icon=%@", user.name, user.icon);
    }
}

/**
 *  模型 -&gt; 字典
 */
void object2keyValues()
{
    // 1.新建模型
    User *user = [[User alloc] init];
    user.name = @"Jack";
    user.icon = @"lufy.png";

    Status *status = [[Status alloc] init];
    status.user = user;
    status.text = @"今天的心情不错！";

    // 2.将模型转为字典
    //    NSDictionary *dict = [status keyValues];
    NSDictionary *dict = status.keyValues;
    NSLog(@"%@", dict);
}

/**
 *  模型数组 -&gt; 字典数组
 */
void objectArray2keyValuesArray()
{
    // 1.新建模型数组
    User *user1 = [[User alloc] init];
    user1.name = @"Jack";
    user1.icon = @"lufy.png";

    User *user2 = [[User alloc] init];
    user2.name = @"Rose";
    user2.icon = @"nami.png";

    User *user3 = [[User alloc] init];
    user3.name = @"Jim";
    user3.icon = @"zero.png";

    NSArray *userArray = @[user1, user2, user3];

    // 2.将模型数组转为字典数组
    NSArray *dictArray = [User keyValuesArrayWithObjectArray:userArray];
    NSLog(@"%@", dictArray);
}

int main(int argc, const char * argv[])
{
    @autoreleasepool {
        // 简单的字典 -&gt; 模型
        keyValues2object();

        // 复杂的字典 -&gt; 模型 (模型里面包含了模型)
        keyValues2object2();

        // 复杂的字典 -&gt; 模型 (模型的数组属性里面又装着模型)
        keyValues2object3();

        // 字典数组 -&gt; 模型数组
        keyValuesArray2objectArray();

        // 模型转字典
        object2keyValues();

        // 模型数组 -&gt; 字典数组
        objectArray2keyValuesArray();
    }
    return 0;
}
</code></pre>
</div>
  
  




| <a href="/blog/2015/12/01/zi-dian-zhuan-mo-xing-shen-jiu/#comments">更多评论</a>

    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/2">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
    <h1>文章分类</h1>
    <ul id="categories">
        <li class='category'><a href='/blog/categories/底层开发/'>底层开发 (2)</a></li>
<li class='category'><a href='/blog/categories/开发工具/'>开发工具 (1)</a></li>
<li class='category'><a href='/blog/categories/性能相关/'>性能相关 (5)</a></li>
<li class='category'><a href='/blog/categories/欢迎来到ios梦工厂/'>欢迎来到ios梦工厂 (1)</a></li>
<li class='category'><a href='/blog/categories/程序员必备/'>程序员必备 (1)</a></li>
<li class='category'><a href='/blog/categories/适配问题/'>适配问题 (1)</a></li>
<li class='category'><a href='/blog/categories/面试总结-技术/'>面试总结＋技术 (1)</a></li>
<li class='category'><a href='/blog/categories/项目实战/'>项目实战 (6)</a></li>
<li class='category'><a href='/blog/categories/高级开发/'>高级开发 (6)</a></li>

    </ul>
</section><section>
  <h1>最新文章</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/12/04/wang-shang-qing-qiu-feng-(feng-)zhuang/">网上请求疯（封）装</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/12/04/xu-lie-hua-and-fan-xu-lie-hua-shen-jiu/">序列化&amp;反序列化深究</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/12/03/huan-cun-ji-zhi-shen-jiu/">自己写套缓存机制</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/12/03/you-xiu-cheng-xu-yuan-shi-zen-yao-xie-zhu-shi-de/">够逼格的注释习惯</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/12/03/nian-tie-shen-jiu/">粘贴深究</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/al1020119">@al1020119</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'al1020119',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>




<section>
<h1>扫一扫<abbr title="The word '扫一扫' is a registered trademark of DENSO WAVE INCORPORATED. It applies only for the word '扫一扫', not for image.">&trade;</abbr></h1>
<a href="http://al1020119.github.io/index.html"><img src="http://chart.apis.google.com/chart?chs=150x150&cht=qr&chld=|0&chco=165B94&chl=http://al1020119.github.io/index.html" alt="post-qrcode"></a></section>
<section>
    <h1>访客统计</h1>
    <br/>
    <a href="http://s07.flagcounter.com/more/2SH"><img src="http://s07.flagcounter.com/count/2SH/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_1/flags_0/" alt="Flag Counter" border="0"></a>
</section><section>
    <h1>新浪微博</h1>
    <ul id="weibo">
        <li>
            
            <!-- 在此插入获得的微博秀代码 -->
            <iframe width="100%" height="550" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=550&fansRow=2&ptype=1&speed=0&skin=1&isTitle=1&noborder=1&isWeibo=1&isFans=1&uid=3288975567&verifier=20ffcedd&dpc=1"></iframe>
            
        </li>
    </ul>
</section>
  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - iCocos -
<span class="credit">Preview in <a href="http://al1020119.github.io">[曹#黎]</a></span>
</p>

</footer>
  






<!--
--->



</body>
</html>
